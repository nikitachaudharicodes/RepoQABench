{
  "repo_name": "oppia_oppia",
  "issue_id": "11431",
  "issue_description": "# Start using transaction decorator instead of  `run_in_transaction`\n\nReplace all usages of `run_in_transaction` with the new `run_in_transaction_wrapper`.\r\n\r\n### List of files\r\n- [x] email_manager.py @Nik-09\r\n- [x] feedback_jobs_continuous.py @Nik-09\r\n- [x] feedback_services.py @lkbhitesh07\r\n- [x] question_services.py @lkbhitesh07\r\n- [x] rating_services.py @vojtechjelinek (#11741)\r\n- [x] stats_services.py @lkbhitesh07\r\n- [x] suggestion_jobs_one_off.py @lkbhitesh07\r\n- [x] suggestion_services.py @lkbhitesh07\r\n- [x] user_services.py @lkbhitesh07\r\n- [x] wipeout_services.py @OBITORASU \r\n- [x] jobs.py @lkbhitesh07\r\n- [x] base_model/gae_models.py @OBITORASU \r\n- [x] statistics/gae_models.py @lkbhitesh07\r\n- [x] user_jobs_continuous.py @lkbhitesh07\r\n\r\n### Steps to refactor\r\n1. Claim one of the files listed above by pinging @vojtechjelinek.\r\n2. Look at the occurrences of `run_in_transaction` in the claimed file.\r\n3. Instead of doing for example `transaction_services.run_in_transaction(_update_user_rating)` on top of the definition of `_update_user_rating` the `@transaction_services.run_in_transaction_wrapper` decorator should be added. In the callsite, the `transaction_services.run_in_transaction(_update_user_rating)` should be replaced with `_update_user_rating_transactional()`.\r\n4. See #11741 for reference\r\n\r\nAfter all occurences are replaced remame the `run_in_transaction_wrapper` to `run_in_transaction`.",
  "issue_comments": [
    {
      "id": 747850021,
      "user": "BenHenning",
      "body": "#11404 for context."
    },
    {
      "id": 765880170,
      "user": "Nik-09",
      "body": "@vojtechjelinek can you please assign me these two files.\r\n email_manager.py\r\n feedback_jobs_continuous.py\r\n Thanks."
    },
    {
      "id": 765901085,
      "user": "lkbhitesh07",
      "body": "Hello @vojtechjelinek , \r\nWill you please assign `user_jobs_continuous.py` file to me ?\r\nThanks"
    },
    {
      "id": 766062571,
      "user": "vojtechjelinek",
      "body": "@Nik-09 Done.\r\n\r\n@lkbhitesh07 Done, can you please also follow these instructions https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia in order to contribute to Oppia."
    },
    {
      "id": 766705983,
      "user": "lkbhitesh07",
      "body": "Hello @vojtechjelinek \r\nSorry for not updating you, I was facing some troubles in my environment but now I am good to go. Also, I want to ask one question that do we have to make PR for each part of this issue, or we can simply do with 2 to 3 parts?\r\nThanks"
    },
    {
      "id": 766816101,
      "user": "vojtechjelinek",
      "body": "> Hello @vojtechjelinek\r\n> Sorry for not updating you, I was facing some troubles in my environment but now I am good to go. Also, I want to ask one question that do we have to make PR for each part of this issue, or we can simply do with 2 to 3 parts?\r\n> Thanks\r\n\r\n@lkbhitesh07 Up to you, the changes are quite small, so they can be done in one PR."
    },
    {
      "id": 766826992,
      "user": "lkbhitesh07",
      "body": ">  @lkbhitesh07 Up to you, the changes are quite small, so they can be done in one PR.\r\n\r\nOk Thanks @vojtechjelinek ,\r\nWill you please assign these files to me.\r\n`jobs.py` \r\n`base_model/gae_models.py`\r\n`statistics/gae_models.py`\r\n\r\n"
    },
    {
      "id": 767022176,
      "user": "lkbhitesh07",
      "body": "Hi @vojtechjelinek \r\ncan I please go ahead with the rest of the files, I'm halfway done?\r\nThanks"
    },
    {
      "id": 767043887,
      "user": "vojtechjelinek",
      "body": "@lkbhitesh07 Let's leave that to other new contributors, you can take up other issues. Btw did you fill the [Oppia contributor survey](https://goo.gl/forms/otv30JV3Ihv0dT3C3)?"
    },
    {
      "id": 767048357,
      "user": "lkbhitesh07",
      "body": "> @lkbhitesh07 Let's leave that to other new contributors, you can take up other issues. Btw did you fill the [Oppia contributor survey](https://goo.gl/forms/otv30JV3Ihv0dT3C3)?\r\n\r\n@vojtechjelinek Yes I already filled the form when I contributed few years back, also I'm done with all the files here except `statistics/gae_models.py` and `wipeout_services.py` . Can I please make a PR?\r\nSorry for that, I'll keep it in mind from next time."
    },
    {
      "id": 767163697,
      "user": "vojtechjelinek",
      "body": "@lkbhitesh07 Okay I found you in our system. Sure make the PR for these or include them in the PR that you already made."
    },
    {
      "id": 767164162,
      "user": "lkbhitesh07",
      "body": "@vojtechjelinek Thank you so much."
    },
    {
      "id": 767222130,
      "user": "lkbhitesh07",
      "body": "Hello, @vojtechjelinek I'm done with all the files except `statistics/gae_models.py` and `wipeout_services.py`. As you suggested and discussed above will be leaving these 2 files for new contributors.\r\nAlso please review these PRs #11782 #11783 \r\nThanks for all your support."
    },
    {
      "id": 768212598,
      "user": "lkbhitesh07",
      "body": "Hello @vojtechjelinek \r\nI figured out that in my previous comment I accidentally mentioned `statistics/gae_models.py` instead of `base_model/gae_models.py`. Will you please correct it. I'm done with `statistics/gae_models.py` and waiting for your approval.\r\nThanks"
    },
    {
      "id": 769314050,
      "user": "OBITORASU",
      "body": "@vojtechjelinek can I take up the two remaining files ```base_model/gae_models.py``` and ``` wipeout_services.py```? I was suggested to work on this issue as a part of my onboarding."
    },
    {
      "id": 769450783,
      "user": "vojtechjelinek",
      "body": "@OBITORASU Sure, I have assigned those to you."
    },
    {
      "id": 769603396,
      "user": "OBITORASU",
      "body": "@vojtechjelinek I had a doubt regarding ```base_model/gae_models.py```\r\nSo to elaborate, we have a classmethod namely:\r\n``` \r\n@classmethod\r\n    def delete_multi(cls, entities):\r\n        \"\"\"Deletes the given datastore_services.Model instances.\r\n\r\n        Args:\r\n            entities: list(datastore_services.Model). The list of model\r\n                instances to be deleted.\r\n        \"\"\"\r\n        datastore_services.delete_multi([entity.key for entity in entities])\r\n```\r\nNow datastore_services is defined as:\r\n```\r\ndatastore_services = models.Registry.import_datastore_services()\r\n```\r\nSo till here I have a clear idea of what is going on. Now the issue is when searching for ```transaction_services.run_in_transaction``` I came across this particular line of code:\r\n```\r\ntransaction_services.run_in_transaction(\r\n                    datastore_services.delete_multi,\r\n                    all_models_keys[\r\n                        i:i + feconf.MAX_NUMBER_OF_OPS_IN_TRANSACTION])\r\n```\r\nNow my question is why have a classmethod delete_multi if we are not using BaseModel.delete_multi anywhere in code of the particular file. As there has been no instance of BaseModel.delete_multi when I try to find it.\r\n\r\nImages for reference:\r\n![Screenshot_20210129_113536](https://user-images.githubusercontent.com/65222459/106238851-99e37780-6227-11eb-9dfe-96b1ce788e30.png)\r\n\r\n![Screenshot_20210129_113552](https://user-images.githubusercontent.com/65222459/106238880-a962c080-6227-11eb-9f04-067932d5b068.png)\r\n\r\n![Screenshot_20210129_113813](https://user-images.githubusercontent.com/65222459/106238901-b4b5ec00-6227-11eb-9a1a-2648b4ffee5e.png)\r\n\r\n![image](https://user-images.githubusercontent.com/65222459/106238996-dfa04000-6227-11eb-905a-6f200387a8e5.png)\r\n\r\n\r\n\r\n"
    },
    {
      "id": 769615647,
      "user": "OBITORASU",
      "body": "Also another question regarding the ```wipeout_services.py```\r\nJust to confirm, is it ```wipeout_services.py``` or ```wipeout_service.py``` ?\r\nApparently I can't fuzzy find ```wipeout_services.py``` the closest file to it is ```wipeout_service.py``` which I can find."
    },
    {
      "id": 769812285,
      "user": "vojtechjelinek",
      "body": "@OBITORASU The `BaseModel.delete_multi` can be used in other files, also since some models inherit from `BaseModel` (like `UserSettingsModel`), the `delete_multi` can be used in these classes too."
    },
    {
      "id": 769883834,
      "user": "OBITORASU",
      "body": "Thanks for the explanation :)"
    },
    {
      "id": 773592309,
      "user": "vojtechjelinek",
      "body": "@Nik-09 How is your work going? Do you need help with anything?"
    },
    {
      "id": 773776981,
      "user": "Nik-09",
      "body": "> @Nik-09 How is your work going? Do you need help with anything?\r\n\r\nI have created Pr please ask @aks681 to review [pr link](https://github.com/oppia/oppia/pull/11781)\r\nThanks @vojtechjelinek and @aks681 .\r\n"
    },
    {
      "id": 774506264,
      "user": "17sushmita",
      "body": "Hi @vojtechjelinek , Is there any task available in this issue?"
    },
    {
      "id": 774507361,
      "user": "vojtechjelinek",
      "body": "@17sushmita No, it isn't."
    },
    {
      "id": 787082016,
      "user": "AwsSG",
      "body": "Hi @vojtechjelinek \r\nI am hoping to contribute to Oppia through GSOC, and currently looking for an issue to contribute in. \r\nAre any of the files in the list still available? Or are they all resolved?"
    },
    {
      "id": 787532604,
      "user": "vojtechjelinek",
      "body": "@AwsSG All are resolved in this issue."
    }
  ],
  "text_context": "# Start using transaction decorator instead of  `run_in_transaction`\n\nReplace all usages of `run_in_transaction` with the new `run_in_transaction_wrapper`.\r\n\r\n### List of files\r\n- [x] email_manager.py @Nik-09\r\n- [x] feedback_jobs_continuous.py @Nik-09\r\n- [x] feedback_services.py @lkbhitesh07\r\n- [x] question_services.py @lkbhitesh07\r\n- [x] rating_services.py @vojtechjelinek (#11741)\r\n- [x] stats_services.py @lkbhitesh07\r\n- [x] suggestion_jobs_one_off.py @lkbhitesh07\r\n- [x] suggestion_services.py @lkbhitesh07\r\n- [x] user_services.py @lkbhitesh07\r\n- [x] wipeout_services.py @OBITORASU \r\n- [x] jobs.py @lkbhitesh07\r\n- [x] base_model/gae_models.py @OBITORASU \r\n- [x] statistics/gae_models.py @lkbhitesh07\r\n- [x] user_jobs_continuous.py @lkbhitesh07\r\n\r\n### Steps to refactor\r\n1. Claim one of the files listed above by pinging @vojtechjelinek.\r\n2. Look at the occurrences of `run_in_transaction` in the claimed file.\r\n3. Instead of doing for example `transaction_services.run_in_transaction(_update_user_rating)` on top of the definition of `_update_user_rating` the `@transaction_services.run_in_transaction_wrapper` decorator should be added. In the callsite, the `transaction_services.run_in_transaction(_update_user_rating)` should be replaced with `_update_user_rating_transactional()`.\r\n4. See #11741 for reference\r\n\r\nAfter all occurences are replaced remame the `run_in_transaction_wrapper` to `run_in_transaction`.\n\n#11404 for context.\n\n@vojtechjelinek can you please assign me these two files.\r\n email_manager.py\r\n feedback_jobs_continuous.py\r\n Thanks.\n\nHello @vojtechjelinek , \r\nWill you please assign `user_jobs_continuous.py` file to me ?\r\nThanks\n\n@Nik-09 Done.\r\n\r\n@lkbhitesh07 Done, can you please also follow these instructions https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia in order to contribute to Oppia.\n\nHello @vojtechjelinek \r\nSorry for not updating you, I was facing some troubles in my environment but now I am good to go. Also, I want to ask one question that do we have to make PR for each part of this issue, or we can simply do with 2 to 3 parts?\r\nThanks\n\n> Hello @vojtechjelinek\r\n> Sorry for not updating you, I was facing some troubles in my environment but now I am good to go. Also, I want to ask one question that do we have to make PR for each part of this issue, or we can simply do with 2 to 3 parts?\r\n> Thanks\r\n\r\n@lkbhitesh07 Up to you, the changes are quite small, so they can be done in one PR.\n\n>  @lkbhitesh07 Up to you, the changes are quite small, so they can be done in one PR.\r\n\r\nOk Thanks @vojtechjelinek ,\r\nWill you please assign these files to me.\r\n`jobs.py` \r\n`base_model/gae_models.py`\r\n`statistics/gae_models.py`\r\n\r\n\n\nHi @vojtechjelinek \r\ncan I please go ahead with the rest of the files, I'm halfway done?\r\nThanks\n\n@lkbhitesh07 Let's leave that to other new contributors, you can take up other issues. Btw did you fill the [Oppia contributor survey](https://goo.gl/forms/otv30JV3Ihv0dT3C3)?\n\n> @lkbhitesh07 Let's leave that to other new contributors, you can take up other issues. Btw did you fill the [Oppia contributor survey](https://goo.gl/forms/otv30JV3Ihv0dT3C3)?\r\n\r\n@vojtechjelinek Yes I already filled the form when I contributed few years back, also I'm done with all the files here except `statistics/gae_models.py` and `wipeout_services.py` . Can I please make a PR?\r\nSorry for that, I'll keep it in mind from next time.\n\n@lkbhitesh07 Okay I found you in our system. Sure make the PR for these or include them in the PR that you already made.\n\n@vojtechjelinek Thank you so much.\n\nHello, @vojtechjelinek I'm done with all the files except `statistics/gae_models.py` and `wipeout_services.py`. As you suggested and discussed above will be leaving these 2 files for new contributors.\r\nAlso please review these PRs #11782 #11783 \r\nThanks for all your support.\n\nHello @vojtechjelinek \r\nI figured out that in my previous comment I accidentally mentioned `statistics/gae_models.py` instead of `base_model/gae_models.py`. Will you please correct it. I'm done with `statistics/gae_models.py` and waiting for your approval.\r\nThanks\n\n@vojtechjelinek can I take up the two remaining files ```base_model/gae_models.py``` and ``` wipeout_services.py```? I was suggested to work on this issue as a part of my onboarding.\n\n@OBITORASU Sure, I have assigned those to you.\n\n@vojtechjelinek I had a doubt regarding ```base_model/gae_models.py```\r\nSo to elaborate, we have a classmethod namely:\r\n``` \r\n@classmethod\r\n    def delete_multi(cls, entities):\r\n        \"\"\"Deletes the given datastore_services.Model instances.\r\n\r\n        Args:\r\n            entities: list(datastore_services.Model). The list of model\r\n                instances to be deleted.\r\n        \"\"\"\r\n        datastore_services.delete_multi([entity.key for entity in entities])\r\n```\r\nNow datastore_services is defined as:\r\n```\r\ndatastore_services = models.Registry.import_datastore_services()\r\n```\r\nSo till here I have a clear idea of what is going on. Now the issue is when searching for ```transaction_services.run_in_transaction``` I came across this particular line of code:\r\n```\r\ntransaction_services.run_in_transaction(\r\n                    datastore_services.delete_multi,\r\n                    all_models_keys[\r\n                        i:i + feconf.MAX_NUMBER_OF_OPS_IN_TRANSACTION])\r\n```\r\nNow my question is why have a classmethod delete_multi if we are not using BaseModel.delete_multi anywhere in code of the particular file. As there has been no instance of BaseModel.delete_multi when I try to find it.\r\n\r\nImages for reference:\r\n![Screenshot_20210129_113536](https://user-images.githubusercontent.com/65222459/106238851-99e37780-6227-11eb-9dfe-96b1ce788e30.png)\r\n\r\n![Screenshot_20210129_113552](https://user-images.githubusercontent.com/65222459/106238880-a962c080-6227-11eb-9f04-067932d5b068.png)\r\n\r\n![Screenshot_20210129_113813](https://user-images.githubusercontent.com/65222459/106238901-b4b5ec00-6227-11eb-9a1a-2648b4ffee5e.png)\r\n\r\n![image](https://user-images.githubusercontent.com/65222459/106238996-dfa04000-6227-11eb-905a-6f200387a8e5.png)\r\n\r\n\r\n\r\n\n\nAlso another question regarding the ```wipeout_services.py```\r\nJust to confirm, is it ```wipeout_services.py``` or ```wipeout_service.py``` ?\r\nApparently I can't fuzzy find ```wipeout_services.py``` the closest file to it is ```wipeout_service.py``` which I can find.\n\n@OBITORASU The `BaseModel.delete_multi` can be used in other files, also since some models inherit from `BaseModel` (like `UserSettingsModel`), the `delete_multi` can be used in these classes too.\n\nThanks for the explanation :)\n\n@Nik-09 How is your work going? Do you need help with anything?\n\n> @Nik-09 How is your work going? Do you need help with anything?\r\n\r\nI have created Pr please ask @aks681 to review [pr link](https://github.com/oppia/oppia/pull/11781)\r\nThanks @vojtechjelinek and @aks681 .\r\n\n\nHi @vojtechjelinek , Is there any task available in this issue?\n\n@17sushmita No, it isn't.\n\nHi @vojtechjelinek \r\nI am hoping to contribute to Oppia through GSOC, and currently looking for an issue to contribute in. \r\nAre any of the files in the list still available? Or are they all resolved?\n\n@AwsSG All are resolved in this issue.",
  "pr_link": "https://github.com/oppia/oppia/pull/11781",
  "code_context": [
    {
      "filename": "core/domain/email_manager.py",
      "content": "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Config properties and functions for managing email notifications.\"\"\"\n\nfrom __future__ import absolute_import  # pylint: disable=import-only-modules\nfrom __future__ import unicode_literals  # pylint: disable=import-only-modules\n\nimport datetime\nimport logging\n\nfrom constants import constants\nfrom core.domain import config_domain\nfrom core.domain import email_services\nfrom core.domain import html_cleaner\nfrom core.domain import rights_domain\nfrom core.domain import subscription_services\nfrom core.domain import user_services\nfrom core.platform import models\nimport feconf\nimport python_utils\nimport schema_utils\nimport utils\n\n(email_models, suggestion_models) = models.Registry.import_models(\n    [models.NAMES.email, models.NAMES.suggestion])\napp_identity_services = models.Registry.import_app_identity_services()\ntransaction_services = models.Registry.import_transaction_services()\n\n\ndef log_new_error(*args, **kwargs):\n    \"\"\"Logs an error message (This is a stub for logging.error(), so that the\n    latter can be swapped out in tests).\n    \"\"\"\n    logging.error(*args, **kwargs)\n\n\nNEW_REVIEWER_EMAIL_DATA = {\n    constants.REVIEW_CATEGORY_TRANSLATION: {\n        'review_category': 'translations',\n        'to_check': 'translation suggestions',\n        'description_template': '%s language translations',\n        'rights_message_template': (\n            'review translation suggestions made by contributors in the %s '\n            'language')\n    },\n    constants.REVIEW_CATEGORY_VOICEOVER: {\n        'review_category': 'voiceovers',\n        'to_check': 'voiceover applications',\n        'description_template': '%s language voiceovers',\n        'rights_message_template': (\n            'review voiceover applications made by contributors in the %s '\n            'language')\n    },\n    constants.REVIEW_CATEGORY_QUESTION: {\n        'review_category': 'questions',\n        'to_check': 'question suggestions',\n        'description': 'questions',\n        'rights_message': 'review question suggestions made by contributors'\n    }\n}\n\nREMOVED_REVIEWER_EMAIL_DATA = {\n    constants.REVIEW_CATEGORY_TRANSLATION: {\n        'review_category': 'translation',\n        'role_description_template': (\n            'translation reviewer role in the %s language'),\n        'rights_message_template': (\n            'review translation suggestions made by contributors in the %s '\n            'language'),\n        'contribution_allowed': 'translations'\n    },\n    constants.REVIEW_CATEGORY_VOICEOVER: {\n        'review_category': 'voiceover',\n        'role_description_template': (\n            'voiceover reviewer role in the %s language'),\n        'rights_message_template': (\n            'review voiceover applications made by contributors in the %s '\n            'language'),\n        'contribution_allowed': 'voiceovers'\n    },\n    constants.REVIEW_CATEGORY_QUESTION: {\n        'review_category': 'question',\n        'role_description': 'question reviewer role',\n        'rights_message': 'review question suggestions made by contributors',\n        'contribution_allowed': 'questions'\n    }\n}\n\nNOTIFICATION_USER_IDS_LIST_SCHEMA = {\n    'type': schema_utils.SCHEMA_TYPE_LIST,\n    'items': {\n        'type': schema_utils.SCHEMA_TYPE_UNICODE,\n        'validators': [{\n            'id': 'is_valid_user_id',\n        }]\n    },\n    'validators': [{\n        'id': 'has_length_at_most',\n        'max_value': 5\n    }, {\n        'id': 'is_uniquified',\n    }]\n}\n\nEMAIL_HTML_BODY_SCHEMA = {\n    'type': schema_utils.SCHEMA_TYPE_UNICODE,\n    'ui_config': {\n        'rows': 20,\n    }\n}\n\nEMAIL_CONTENT_SCHEMA = {\n    'type': schema_utils.SCHEMA_TYPE_DICT,\n    'properties': [{\n        'name': 'subject',\n        'schema': {\n            'type': schema_utils.SCHEMA_TYPE_UNICODE,\n        },\n    }, {\n        'name': 'html_body',\n        'schema': EMAIL_HTML_BODY_SCHEMA,\n    }],\n}\n\nEMAIL_SENDER_NAME = config_domain.ConfigProperty(\n    'email_sender_name', {'type': 'unicode'},\n    'The default sender name for outgoing emails.', 'Site Admin')\nEMAIL_FOOTER = config_domain.ConfigProperty(\n    'email_footer', {'type': 'unicode', 'ui_config': {'rows': 5}},\n    'The footer to append to all outgoing emails. (This should be written in '\n    'HTML and include an unsubscribe link.)',\n    'You can change your email preferences via the '\n    '<a href=\"%s%s\">Preferences</a> page.' % (\n        feconf.OPPIA_SITE_URL, feconf.PREFERENCES_URL))\n\n_PLACEHOLDER_SUBJECT = 'THIS IS A PLACEHOLDER.'\n_PLACEHOLDER_HTML_BODY = 'THIS IS A <b>PLACEHOLDER</b> AND SHOULD BE REPLACED.'\n\nSIGNUP_EMAIL_CONTENT = config_domain.ConfigProperty(\n    'signup_email_content', EMAIL_CONTENT_SCHEMA,\n    'Content of email sent after a new user signs up. (The email body should '\n    'be written with HTML and not include a salutation or footer.) These '\n    'emails are only sent if the functionality is enabled in feconf.py.',\n    {\n        'subject': _PLACEHOLDER_SUBJECT,\n        'html_body': _PLACEHOLDER_HTML_BODY,\n    })\n\nEXPLORATION_ROLE_MANAGER = 'manager rights'\nEXPLORATION_ROLE_EDITOR = 'editor rights'\nEXPLORATION_ROLE_VOICE_ARTIST = 'voice artist rights'\nEXPLORATION_ROLE_PLAYTESTER = 'playtest access'\n\nEDITOR_ROLE_EMAIL_HTML_ROLES = {\n    rights_domain.ROLE_OWNER: EXPLORATION_ROLE_MANAGER,\n    rights_domain.ROLE_EDITOR: EXPLORATION_ROLE_EDITOR,\n    rights_domain.ROLE_VOICE_ARTIST: EXPLORATION_ROLE_VOICE_ARTIST,\n    rights_domain.ROLE_VIEWER: EXPLORATION_ROLE_PLAYTESTER\n}\n\n_EDITOR_ROLE_EMAIL_HTML_RIGHTS = {\n    'can_manage': '<li>Change the exploration permissions</li><br>',\n    'can_edit': '<li>Edit the exploration</li><br>',\n    'can_voiceover': '<li>Voiceover the exploration</li><br>',\n    'can_play': '<li>View and playtest the exploration</li><br>'\n}\n\n# We don't include \"can_voiceover\" for managers and editors, since this is\n# implied by the email description for \"can_edit\".\nEDITOR_ROLE_EMAIL_RIGHTS_FOR_ROLE = {\n    EXPLORATION_ROLE_MANAGER: (\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_manage'] +\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_edit'] +\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_play']),\n    EXPLORATION_ROLE_EDITOR: (\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_edit'] +\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_play']),\n    EXPLORATION_ROLE_VOICE_ARTIST: (\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_voiceover'] +\n        _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_play']),\n    EXPLORATION_ROLE_PLAYTESTER: _EDITOR_ROLE_EMAIL_HTML_RIGHTS['can_play']\n}\n\nUNPUBLISH_EXPLORATION_EMAIL_HTML_BODY = config_domain.ConfigProperty(\n    'unpublish_exploration_email_html_body', EMAIL_HTML_BODY_SCHEMA,\n    'Default content for the email sent after an exploration is unpublished '\n    'by a moderator. These emails are only sent if the functionality is '\n    'enabled in feconf.py. Leave this field blank if emails should not be '\n    'sent.',\n    'I\\'m writing to inform you that I have unpublished the above '\n    'exploration.')\n\nNOTIFICATION_USER_IDS_FOR_FAILED_TASKS = config_domain.ConfigProperty(\n    'notification_user_ids_for_failed_tasks',\n    NOTIFICATION_USER_IDS_LIST_SCHEMA,\n    'User IDs to notify if an ML training task fails',\n    []\n)\n\nCONTRIBUTOR_DASHBOARD_REVIEWER_NOTIFICATION_EMAIL_DATA = {\n    'email_body_template': (\n        'Hi %s,'\n        '<br><br>'\n        'There are new review opportunities that we think you might be '\n        'interested in on the <a href=\"%s%s\">Contributor Dashboard</a>. '\n        'Here are some examples of contributions that have been waiting '\n        'the longest for review:'\n        '<br><br>'\n        '<ul>%s</ul><br>'\n        'Please take some time to review any of the above contributions (if '\n        'they still need a review) or any other contributions on the '\n        'dashboard. We appreciate your help!'\n        '<br><br>'\n        'Thanks again, and happy reviewing!<br>'\n        '- The Oppia Contributor Dashboard Team'\n        '<br><br>%s'\n    ),\n    'email_subject': 'Contributor Dashboard Reviewer Opportunities'\n}\n\nHTML_FOR_SUGGESTION_DESCRIPTION = {\n    # The templates below are for listing the information for each suggestion\n    # type offered on the Contributor Dashboard.\n    'suggestion_template': {\n        feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: (\n            '<li>The following %s translation suggestion was submitted for '\n            'review %s ago:<br>%s</li><br>'),\n        feconf.SUGGESTION_TYPE_ADD_QUESTION: (\n            '<li>The following question suggestion was submitted for review '\n            '%s ago:<br>%s</li><br>')\n    },\n    # Each suggestion type has a lambda function to retrieve the values needed\n    # to populate the above suggestion template.\n    'suggestion_template_values_getter_functions': {\n        feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: (\n            lambda values_dict: (\n                values_dict['language'], values_dict['review_wait_time'],\n                values_dict['suggestion_content'])\n        ),\n        feconf.SUGGESTION_TYPE_ADD_QUESTION: (\n            lambda values_dict: (\n                values_dict['review_wait_time'],\n                values_dict['suggestion_content'])\n        )\n    }\n}\n\nADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA = {\n    'email_body_template': (\n        'Hi %s,'\n        '<br><br>'\n        'In the <a href=\"%s%s#/roles\">admin roles page,</a> please add '\n        'reviewers to the Contributor Dashboard community by entering their '\n        'username(s) and allow reviewing for the suggestion types that need '\n        'more reviewers bolded below.'\n        '<br><br>%s'\n        'Thanks so much - we appreciate your help!<br><br>'\n        'Best Wishes!<br>'\n        '- The Oppia Contributor Dashboard Team'\n    ),\n    'email_subject': 'Reviewers Needed for Contributor Dashboard',\n    # The templates below are for listing the information for each suggestion\n    # type that needs more reviewers. For translation languages there are two\n    # templates to account for: whether one or multiple languages needs more\n    # reviewers.\n    'one_language_template': (\n        'There have been <b>%s translation suggestions</b> created on the '\n        '<a href=\"%s%s\">Contributor Dashboard page</a> where there are not '\n        'enough reviewers.<br><br>'\n    ),\n    'multi_language_template': (\n        'There have been <b>translation suggestions</b> created on the '\n        '<a href=\"%s%s\">Contributor Dashboard page</a> in languages where '\n        'there are not enough reviewers. The languages that need more '\n        'reviewers are:'\n        '<br><ul>%s</ul><br>'\n    ),\n    'question_template': (\n        'There have been <b>question suggestions</b> created on the '\n        '<a href=\"%s%s\">Contributor Dashboard page</a> where there are not '\n        'enough reviewers.<br><br>' % (\n            feconf.OPPIA_SITE_URL, feconf.CONTRIBUTOR_DASHBOARD_URL))\n}\n\nADMIN_NOTIFICATION_FOR_SUGGESTIONS_NEEDING_REVIEW_EMAIL_DATA = {\n    'email_body_template': (\n        'Hi %s,<br><br>'\n        'There are suggestions on the <a href=\"%s%s\">Contributor Dashboard</a> '\n        'that have been waiting for more than %s days for review. Please take '\n        'a look at the suggestions mentioned below and help them get reviewed '\n        'by going to the <a href=\"%s%s#/roles\">admin roles page</a> and either:'\n        '<br><br><ul>'\n        '<li>Add more reviewers to the suggestion types that have suggestions '\n        'waiting too long for a review</li><br>'\n        '<li>Find the existing reviewers and email reviewers directly about '\n        'the suggestions waiting for a review</li><br>'\n        '</ul><br>'\n        'Here are the suggestions that have been waiting too long for a review:'\n        '<br><br>'\n        '<ul>%s</ul><br>'\n        'Thanks so much - we appreciate your help!<br>'\n        'Best Wishes!<br><br>'\n        '- The Oppia Contributor Dashboard Team'\n    ),\n    'email_subject': (\n        'Contributor Dashboard Suggestions Have Been Waiting Too Long for '\n        'Review')\n}\n\nSENDER_VALIDATORS = {\n    feconf.EMAIL_INTENT_SIGNUP: (lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_UNPUBLISH_EXPLORATION: (\n        user_services.is_at_least_moderator),\n    feconf.EMAIL_INTENT_DAILY_BATCH: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_EDITOR_ROLE_NOTIFICATION: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_SUGGESTION_NOTIFICATION: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_SUBSCRIPTION_NOTIFICATION: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_QUERY_STATUS_NOTIFICATION: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_MARKETING: user_services.is_admin,\n    feconf.EMAIL_INTENT_DELETE_EXPLORATION: (\n        user_services.is_at_least_moderator),\n    feconf.EMAIL_INTENT_REPORT_BAD_CONTENT: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_ONBOARD_REVIEWER: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_REMOVE_REVIEWER: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_REVIEW_CREATOR_DASHBOARD_SUGGESTIONS: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_ADDRESS_CONTRIBUTOR_DASHBOARD_SUGGESTIONS: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_REVIEW_CONTRIBUTOR_DASHBOARD_SUGGESTIONS: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_ADD_CONTRIBUTOR_DASHBOARD_REVIEWERS: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_VOICEOVER_APPLICATION_UPDATES: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.EMAIL_INTENT_ACCOUNT_DELETED: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.BULK_EMAIL_INTENT_MARKETING: user_services.is_admin,\n    feconf.BULK_EMAIL_INTENT_IMPROVE_EXPLORATION: user_services.is_admin,\n    feconf.BULK_EMAIL_INTENT_CREATE_EXPLORATION: user_services.is_admin,\n    feconf.BULK_EMAIL_INTENT_CREATOR_REENGAGEMENT: user_services.is_admin,\n    feconf.BULK_EMAIL_INTENT_ML_JOB_FAILURE: (\n        lambda x: x == feconf.SYSTEM_COMMITTER_ID),\n    feconf.BULK_EMAIL_INTENT_LEARNER_REENGAGEMENT: user_services.is_admin,\n    feconf.BULK_EMAIL_INTENT_TEST: user_services.is_admin\n}\n\n\ndef require_sender_id_is_valid(intent, sender_id):\n    \"\"\"Ensure that the sender ID is valid, based on the email's intent.\n\n    Many emails are only allowed to be sent by a certain user or type of user,\n    e.g. 'admin' or an admin/moderator. This function will raise an exception\n    if the given sender is not allowed to send this type of email.\n\n    Args:\n        intent: str. The intent string, i.e. the purpose of the email.\n            Valid intent strings are defined in feconf.py.\n        sender_id: str. The ID of the user sending the email.\n\n    Raises:\n        Exception. The email intent is invalid.\n        Exception. The sender_id is not appropriate for the given intent.\n    \"\"\"\n\n    if intent not in SENDER_VALIDATORS:\n        raise Exception('Invalid email intent string: %s' % intent)\n    else:\n        if not SENDER_VALIDATORS[intent](sender_id):\n            logging.error(\n                'Invalid sender_id %s for email with intent \\'%s\\'' %\n                (sender_id, intent))\n            raise Exception(\n                'Invalid sender_id for email with intent \\'%s\\'' % intent)\n\n\ndef _send_email(\n        recipient_id, sender_id, intent, email_subject, email_html_body,\n        sender_email, bcc_admin=False, sender_name=None, reply_to_id=None,\n        recipient_email=None):\n    \"\"\"Sends an email to the given recipient.\n\n    This function should be used for sending all user-facing emails.\n\n    Raises an Exception if the sender_id is not appropriate for the given\n    intent. Currently we support only system-generated emails and emails\n    initiated by moderator actions.\n\n    Args:\n        recipient_id: str. The user ID of the recipient.\n        sender_id: str. The user ID of the sender.\n        intent: str. The intent string for the email, i.e. the purpose/type.\n        email_subject: str. The subject of the email.\n        email_html_body: str. The body (message) of the email.\n        sender_email: str. The sender's email address.\n        bcc_admin: bool. Whether to send a copy of the email to the admin's\n            email address.\n        sender_name: str or None. The name to be shown in the \"sender\" field of\n            the email.\n        reply_to_id: str or None. The unique reply-to id used in reply-to email\n            address sent to recipient.\n        recipient_email: str or None. Override for the recipient email.\n            This should only be used when the user with user_id equal to\n            recipient_id does not exist or is deleted and their email cannot be\n            retrieved via get_email_from_user_id.\n    \"\"\"\n\n    if sender_name is None:\n        sender_name = EMAIL_SENDER_NAME.value\n\n    require_sender_id_is_valid(intent, sender_id)\n\n    if recipient_email is None:\n        recipient_email = user_services.get_email_from_user_id(recipient_id)\n\n    cleaned_html_body = html_cleaner.clean(email_html_body)\n    if cleaned_html_body != email_html_body:\n        log_new_error(\n            'Original email HTML body does not match cleaned HTML body:\\n'\n            'Original:\\n%s\\n\\nCleaned:\\n%s\\n' %\n            (email_html_body, cleaned_html_body))\n        return\n\n    raw_plaintext_body = cleaned_html_body.replace('<br/>', '\\n').replace(\n        '<br>', '\\n').replace('<li>', '<li>- ').replace('</p><p>', '</p>\\n<p>')\n    cleaned_plaintext_body = html_cleaner.strip_html_tags(raw_plaintext_body)\n\n    if email_models.SentEmailModel.check_duplicate_message(\n            recipient_id, email_subject, cleaned_plaintext_body):\n        log_new_error(\n            'Duplicate email:\\n'\n            'Details:\\n%s %s\\n%s\\n\\n' %\n            (recipient_id, email_subject, cleaned_plaintext_body))\n        return\n    @transaction_services.run_in_transaction_wrapper\n    def _send_email_transactional():\n        \"\"\"Sends the email to a single recipient.\"\"\"\n        sender_name_email = '%s <%s>' % (sender_name, sender_email)\n\n        email_services.send_mail(\n            sender_name_email, recipient_email, email_subject,\n            cleaned_plaintext_body, cleaned_html_body, bcc_admin=bcc_admin,\n            reply_to_id=reply_to_id)\n        email_models.SentEmailModel.create(\n            recipient_id, recipient_email, sender_id, sender_name_email, intent,\n            email_subject, cleaned_html_body, datetime.datetime.utcnow())\n\n    _send_email_transactional()\n\n\ndef _send_bulk_mail(\n        recipient_ids, sender_id, intent, email_subject, email_html_body,\n        sender_email, sender_name, instance_id):\n    \"\"\"Sends an email to all given recipients.\n\n    Args:\n        recipient_ids: list(str). The user IDs of the email recipients.\n        sender_id: str. The ID of the user sending the email.\n        intent: str. The intent string, i.e. the purpose of the email.\n        email_subject: str. The subject of the email.\n        email_html_body: str. The body (message) of the email.\n        sender_email: str. The sender's email address.\n        sender_name: str. The name to be shown in the \"sender\" field of the\n            email.\n        instance_id: str. The ID of the BulkEmailModel entity instance.\n    \"\"\"\n    require_sender_id_is_valid(intent, sender_id)\n\n    recipients_settings = user_services.get_users_settings(recipient_ids)\n    recipient_emails = [user.email for user in recipients_settings]\n\n    cleaned_html_body = html_cleaner.clean(email_html_body)\n    if cleaned_html_body != email_html_body:\n        log_new_error(\n            'Original email HTML body does not match cleaned HTML body:\\n'\n            'Original:\\n%s\\n\\nCleaned:\\n%s\\n' %\n            (email_html_body, cleaned_html_body))\n        return\n\n    raw_plaintext_body = cleaned_html_body.replace('<br/>', '\\n').replace(\n        '<br>', '\\n').replace('<li>', '<li>- ').replace('</p><p>', '</p>\\n<p>')\n    cleaned_plaintext_body = html_cleaner.strip_html_tags(raw_plaintext_body)\n\n    @transaction_services.run_in_transaction_wrapper\n    def _send_bulk_mail_transactional(instance_id):\n        \"\"\"Sends the emails in bulk to the recipients.\n\n        Args:\n            instance_id: str. The ID of the BulkEmailModel entity instance.\n        \"\"\"\n        sender_name_email = '%s <%s>' % (sender_name, sender_email)\n\n        email_services.send_bulk_mail(\n            sender_name_email, recipient_emails, email_subject,\n            cleaned_plaintext_body, cleaned_html_body)\n\n        email_models.BulkEmailModel.create(\n            instance_id, recipient_ids, sender_id, sender_name_email, intent,\n            email_subject, cleaned_html_body, datetime.datetime.utcnow())\n\n    _send_bulk_mail_transactional(instance_id)\n\n\ndef send_job_failure_email(job_id):\n    \"\"\"Sends an email to admin email as well as any email addresses\n    specificed on the admin config page.\n\n    Args:\n        job_id: str. The Job ID of the failing job.\n    \"\"\"\n    mail_subject = 'Failed ML Job'\n    mail_body = ((\n        'ML job %s has failed. For more information,'\n        'please visit the admin page at:\\n'\n        'https://www.oppia.org/admin#/jobs') % job_id)\n    send_mail_to_admin(mail_subject, mail_body)\n    recipient_ids = (\n        NOTIFICATION_USER_IDS_FOR_FAILED_TASKS.value)\n    bulk_email_model_id = email_models.BulkEmailModel.get_new_id('')\n    if recipient_ids:\n        _send_bulk_mail(\n            recipient_ids, feconf.SYSTEM_COMMITTER_ID,\n            feconf.BULK_EMAIL_INTENT_ML_JOB_FAILURE, mail_subject, mail_body,\n            feconf.SYSTEM_EMAIL_ADDRESS, feconf.SYSTEM_EMAIL_NAME,\n            bulk_email_model_id\n        )\n\n\ndef send_dummy_mail_to_admin(username):\n    \"\"\"Send an email from the specified email address to admin.\n\n    Args:\n        username: str. Username of the sender.\n    \"\"\"\n\n    email_body = 'This is a test mail from %s.' % (username)\n    email_subject = 'Test Mail'\n    system_name_email = '%s <%s>' % (\n        feconf.SYSTEM_EMAIL_NAME, feconf.SYSTEM_EMAIL_ADDRESS)\n\n    email_services.send_mail(\n        system_name_email, feconf.ADMIN_EMAIL_ADDRESS, email_subject,\n        email_body, email_body.replace('\\n', '<br/>'), bcc_admin=False)\n\n\ndef send_mail_to_admin(email_subject, email_body):\n    \"\"\"Send an email to the admin email address.\n\n    The email is sent to the ADMIN_EMAIL_ADDRESS set in feconf.py.\n\n    Args:\n        email_subject: str. Subject of the email.\n        email_body: str. Body (message) of the email.\n    \"\"\"\n\n    app_id = app_identity_services.get_application_id()\n    body = '(Sent from %s)\\n\\n%s' % (app_id, email_body)\n    system_name_email = '%s <%s>' % (\n        feconf.SYSTEM_EMAIL_NAME, feconf.SYSTEM_EMAIL_ADDRESS)\n    email_services.send_mail(\n        system_name_email, feconf.ADMIN_EMAIL_ADDRESS, email_subject,\n        body, body.replace('\\n', '<br/>'), bcc_admin=False)\n\n\ndef send_post_signup_email(user_id, test_for_duplicate_email=False):\n    \"\"\"Sends a post-signup email to the given user.\n\n    Raises an exception if emails are not allowed to be sent to users (i.e.\n    feconf.CAN_SEND_EMAILS is False).\n\n    Args:\n        user_id: str. User ID of the user that signed up.\n        test_for_duplicate_email: bool. For testing duplicate emails.\n    \"\"\"\n\n    if not test_for_duplicate_email:\n        for key, content in SIGNUP_EMAIL_CONTENT.value.items():\n            if content == SIGNUP_EMAIL_CONTENT.default_value[key]:\n                log_new_error(\n                    'Please ensure that the value for the admin config '\n                    'property SIGNUP_EMAIL_CONTENT is set, before allowing '\n                    'post-signup emails to be sent.')\n                return\n\n    recipient_username = user_services.get_username(user_id)\n    email_subject = SIGNUP_EMAIL_CONTENT.value['subject']\n    email_body = 'Hi %s,<br><br>%s<br><br>%s' % (\n        recipient_username, SIGNUP_EMAIL_CONTENT.value['html_body'],\n        EMAIL_FOOTER.value)\n\n    _send_email(\n        user_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_SIGNUP,\n        email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef get_moderator_unpublish_exploration_email():\n    \"\"\"Returns a draft of the text of the body for an email sent immediately\n    when a moderator unpublishes an exploration. An empty body is a signal to\n    the frontend that no email will be sent.\n\n    Returns:\n        str. Draft of the email body for an email sent after the moderator\n        unpublishes an exploration, or an empty string if no email should\n        be sent.\n    \"\"\"\n\n    try:\n        require_moderator_email_prereqs_are_satisfied()\n    except utils.ValidationError:\n        return ''\n\n    return config_domain.Registry.get_config_property(\n        'unpublish_exploration_email_html_body').value\n\n\ndef require_moderator_email_prereqs_are_satisfied():\n    \"\"\"Raises an exception if, for any reason, moderator emails cannot be sent.\n\n    Raises:\n        ValidationError. The feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION is False.\n        ValidationError. The feconf.CAN_SEND_EMAILS is False.\n    \"\"\"\n\n    if not feconf.REQUIRE_EMAIL_ON_MODERATOR_ACTION:\n        raise utils.ValidationError(\n            'For moderator emails to be sent, please ensure that '\n            'REQUIRE_EMAIL_ON_MODERATOR_ACTION is set to True.')\n    if not feconf.CAN_SEND_EMAILS:\n        raise utils.ValidationError(\n            'For moderator emails to be sent, please ensure that '\n            'CAN_SEND_EMAILS is set to True.')\n\n\ndef send_moderator_action_email(\n        sender_id, recipient_id, intent, exploration_title, email_body):\n    \"\"\"Sends a email immediately following a moderator action (unpublish,\n    delete) to the given user.\n\n    Raises an exception if emails are not allowed to be sent to users (i.e.\n    feconf.CAN_SEND_EMAILS is False).\n\n    Args:\n        sender_id: str. User ID of the sender.\n        recipient_id: str. User ID of the recipient.\n        intent: str. The intent string (cause/purpose) of the email.\n        exploration_title: str. The title of the exploration on which the\n            moderator action was taken.\n        email_body: str. The email content/message.\n    \"\"\"\n\n    require_moderator_email_prereqs_are_satisfied()\n    email_config = feconf.VALID_MODERATOR_ACTIONS[intent]\n\n    recipient_username = user_services.get_username(recipient_id)\n    sender_username = user_services.get_username(sender_id)\n    email_subject = feconf.VALID_MODERATOR_ACTIONS[intent]['email_subject_fn'](\n        exploration_title)\n    email_salutation_html = email_config['email_salutation_html_fn'](\n        recipient_username)\n    email_signoff_html = email_config['email_signoff_html_fn'](sender_username)\n\n    full_email_content = (\n        '%s<br><br>%s<br><br>%s<br><br>%s' % (\n            email_salutation_html, email_body, email_signoff_html,\n            EMAIL_FOOTER.value))\n    _send_email(\n        recipient_id, sender_id, intent, email_subject, full_email_content,\n        feconf.SYSTEM_EMAIL_ADDRESS, bcc_admin=True)\n\n\ndef send_role_notification_email(\n        inviter_id, recipient_id, recipient_role, exploration_id,\n        exploration_title):\n    \"\"\"Sends a email when a new user is given activity rights (Manager, Editor,\n    Viewer) to an exploration by creator of exploration.\n\n    Email will only be sent if recipient wants to receive these emails (i.e.\n    'can_receive_editor_role_email' is set True in recipent's preferences).\n\n    Args:\n        inviter_id: str. ID of the user who invited the recipient to the new\n            role.\n        recipient_id: str. User ID of the recipient.\n        recipient_role: str. Role given to the recipient. Must be defined in\n            EDITOR_ROLE_EMAIL_HTML_ROLES.\n        exploration_id: str. ID of the exploration for which the recipient has\n            been given the new role.\n        exploration_title: str. Title of the exploration for which the recipient\n            has been given the new role.\n\n    Raises:\n        Exception. The role is invalid (i.e. not defined in\n            EDITOR_ROLE_EMAIL_HTML_ROLES).\n    \"\"\"\n\n    # Editor role email body and email subject templates.\n    email_subject_template = (\n        '%s - invitation to collaborate')\n\n    email_body_template = (\n        'Hi %s,<br>'\n        '<br>'\n        '<b>%s</b> has granted you %s to their exploration, '\n        '\"<a href=\"https://www.oppia.org/create/%s\">%s</a>\", on Oppia.org.<br>'\n        '<br>'\n        'This allows you to:<br>'\n        '<ul>%s</ul>'\n        'You can find the exploration '\n        '<a href=\"https://www.oppia.org/create/%s\">here</a>.<br>'\n        '<br>'\n        'Thanks, and happy collaborating!<br>'\n        '<br>'\n        'Best wishes,<br>'\n        'The Oppia Team<br>'\n        '<br>%s')\n\n    # Return from here if sending email is turned off.\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    # Return from here is sending editor role email is disabled.\n    if not feconf.CAN_SEND_EDITOR_ROLE_EMAILS:\n        log_new_error('This app cannot send editor role emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    inviter_username = user_services.get_username(inviter_id)\n    recipient_preferences = user_services.get_email_preferences(recipient_id)\n\n    if not recipient_preferences.can_receive_editor_role_email:\n        # Do not send email if recipient has declined.\n        return\n\n    if recipient_role not in EDITOR_ROLE_EMAIL_HTML_ROLES:\n        raise Exception(\n            'Invalid role: %s' % recipient_role)\n\n    role_description = EDITOR_ROLE_EMAIL_HTML_ROLES[recipient_role]\n    rights_html = EDITOR_ROLE_EMAIL_RIGHTS_FOR_ROLE[role_description]\n\n    email_subject = email_subject_template % exploration_title\n    email_body = email_body_template % (\n        recipient_username, inviter_username, role_description, exploration_id,\n        exploration_title, rights_html, exploration_id, EMAIL_FOOTER.value)\n\n    _send_email(\n        recipient_id, feconf.SYSTEM_COMMITTER_ID,\n        feconf.EMAIL_INTENT_EDITOR_ROLE_NOTIFICATION, email_subject, email_body,\n        feconf.NOREPLY_EMAIL_ADDRESS, sender_name=inviter_username)\n\n\ndef send_emails_to_subscribers(creator_id, exploration_id, exploration_title):\n    \"\"\"Sends an email to all the subscribers of the creators when the creator\n    publishes an exploration.\n\n    Args:\n        creator_id: str. The id of the creator who has published an exploration\n            and to whose subscribers we are sending emails.\n        exploration_id: str. The id of the exploration which the creator has\n            published.\n        exploration_title: str. The title of the exploration which the creator\n            has published.\n    \"\"\"\n\n    creator_name = user_services.get_username(creator_id)\n    email_subject = ('%s has published a new exploration!' % creator_name)\n    email_body_template = (\n        'Hi %s,<br>'\n        '<br>'\n        '%s has published a new exploration! You can play it here: '\n        '<a href=\"https://www.oppia.org/explore/%s\">%s</a><br>'\n        '<br>'\n        'Thanks, and happy learning!<br>'\n        '<br>'\n        'Best wishes,<br>'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not feconf.CAN_SEND_SUBSCRIPTION_EMAILS:\n        log_new_error('This app cannot send subscription emails to users.')\n        return\n\n    recipient_list = subscription_services.get_all_subscribers_of_creator(\n        creator_id)\n    recipients_usernames = user_services.get_usernames(recipient_list)\n    recipients_preferences = user_services.get_users_email_preferences(\n        recipient_list)\n    for index, username in enumerate(recipients_usernames):\n        if recipients_preferences[index].can_receive_subscription_email:\n            email_body = email_body_template % (\n                username, creator_name, exploration_id,\n                exploration_title, EMAIL_FOOTER.value)\n            _send_email(\n                recipient_list[index], feconf.SYSTEM_COMMITTER_ID,\n                feconf.EMAIL_INTENT_SUBSCRIPTION_NOTIFICATION,\n                email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_feedback_message_email(recipient_id, feedback_messages):\n    \"\"\"Sends an email when creator receives feedback message to an exploration.\n\n    Args:\n        recipient_id: str. User ID of recipient.\n        feedback_messages: dict. Contains feedback messages. Example:\n\n            {\n                'exploration_id': {\n                    'title': 'Exploration 1234',\n                    'messages': ['Feedback message 1', 'Feedback message 2']\n                }\n            }\n    \"\"\"\n    email_subject_template = (\n        'You\\'ve received %s new message%s on your explorations')\n\n    email_body_template = (\n        'Hi %s,<br>'\n        '<br>'\n        'You\\'ve received %s new message%s on your Oppia explorations:<br>'\n        '<ul>%s</ul>'\n        'You can view and reply to your messages from your '\n        '<a href=\"https://www.oppia.org/creator-dashboard\">dashboard</a>.'\n        '<br>'\n        '<br>Thanks, and happy teaching!<br>'\n        '<br>'\n        'Best wishes,<br>'\n        'The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS:\n        log_new_error('This app cannot send feedback message emails to users.')\n        return\n\n    if not feedback_messages:\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n\n    messages_html = ''\n    count_messages = 0\n    for exp_id, reference in feedback_messages.items():\n        messages_html += (\n            '<li><a href=\"https://www.oppia.org/create/%s#/feedback\">'\n            '%s</a>:<br><ul>' % (exp_id, reference['title']))\n        for message in reference['messages']:\n            messages_html += ('<li>%s<br></li>' % message)\n            count_messages += 1\n        messages_html += '</ul></li>'\n\n    email_subject = email_subject_template % (\n        (count_messages, 's') if count_messages > 1 else ('a', ''))\n\n    email_body = email_body_template % (\n        recipient_username, count_messages if count_messages > 1\n        else 'a', 's' if count_messages > 1 else '', messages_html,\n        EMAIL_FOOTER.value)\n\n    _send_email(\n        recipient_id, feconf.SYSTEM_COMMITTER_ID,\n        feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION,\n        email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef can_users_receive_thread_email(\n        recipient_ids, exploration_id, has_suggestion):\n    \"\"\"Returns if users can receive email.\n\n    Args:\n        recipient_ids: list(str). IDs of persons that should receive the email.\n        exploration_id: str. ID of exploration that received new message.\n        has_suggestion: bool. True if thread contains suggestion.\n\n    Returns:\n        list(bool). True if user can receive the email, False otherwise.\n    \"\"\"\n    users_global_prefs = (\n        user_services.get_users_email_preferences(recipient_ids))\n    users_exploration_prefs = (\n        user_services.get_users_email_preferences_for_exploration(\n            recipient_ids, exploration_id))\n    zipped_preferences = list(\n        python_utils.ZIP(users_global_prefs, users_exploration_prefs))\n\n    result = []\n    if has_suggestion:\n        for user_global_prefs, user_exploration_prefs in zipped_preferences:\n            result.append(\n                user_global_prefs.can_receive_feedback_message_email\n                and not user_exploration_prefs.mute_suggestion_notifications)\n    else:\n        for user_global_prefs, user_exploration_prefs in zipped_preferences:\n            result.append(\n                user_global_prefs.can_receive_feedback_message_email\n                and not user_exploration_prefs.mute_feedback_notifications)\n\n    return result\n\n\ndef send_suggestion_email(\n        exploration_title, exploration_id, author_id, recipient_list):\n    \"\"\"Send emails to notify the given recipients about new suggestion.\n\n    Each recipient will only be emailed if their email preferences allow for\n    incoming feedback message emails.\n\n    Args:\n        exploration_title: str. Title of the exploration with the new\n            suggestion.\n        exploration_id: str. The ID of the exploration with the new suggestion.\n        author_id: str. The user ID of the author of the suggestion.\n        recipient_list: list(str). The user IDs of the email recipients.\n    \"\"\"\n\n    email_subject = 'New suggestion for \"%s\"' % exploration_title\n\n    email_body_template = (\n        'Hi %s,<br>'\n        '%s has submitted a new suggestion for your Oppia exploration, '\n        '<a href=\"https://www.oppia.org/create/%s\">\"%s\"</a>.<br>'\n        'You can accept or reject this suggestion by visiting the '\n        '<a href=\"https://www.oppia.org/create/%s#/feedback\">feedback page</a> '\n        'for your exploration.<br>'\n        '<br>'\n        'Thanks!<br>'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS:\n        log_new_error('This app cannot send feedback message emails to users.')\n        return\n\n    author_username = user_services.get_username(author_id)\n    can_users_receive_email = (\n        can_users_receive_thread_email(recipient_list, exploration_id, True))\n    for index, recipient_id in enumerate(recipient_list):\n        recipient_username = user_services.get_username(recipient_id)\n        # Send email only if recipient wants to receive.\n        if can_users_receive_email[index]:\n            email_body = email_body_template % (\n                recipient_username, author_username, exploration_id,\n                exploration_title, exploration_id, EMAIL_FOOTER.value)\n            _send_email(\n                recipient_id, feconf.SYSTEM_COMMITTER_ID,\n                feconf.EMAIL_INTENT_SUGGESTION_NOTIFICATION,\n                email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_instant_feedback_message_email(\n        recipient_id, sender_id, message, email_subject, exploration_title,\n        exploration_id, thread_title, reply_to_id=None):\n    \"\"\"Send an email when a new message is posted to a feedback thread, or when\n    the thread's status is changed.\n\n    Args:\n        recipient_id: str. The user ID of the recipient.\n        sender_id: str. The user ID of the sender.\n        message: str. The message text or status change text from the sender.\n        email_subject: str. The subject line to be sent in the email.\n        exploration_title: str. The title of the exploration.\n        exploration_id: str. ID of the exploration the feedback thread is about.\n        thread_title: str. The title of the feedback thread.\n        reply_to_id: str or None. The unique reply-to id used in reply-to email\n            sent to recipient.\n    \"\"\"\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'New update to thread \"%s\" on '\n        '<a href=\"https://www.oppia.org/create/%s#/feedback\">%s</a>:<br>'\n        '<ul><li>%s: %s<br></li></ul>'\n        '(You received this message because you are a '\n        'participant in this thread.)<br><br>'\n        'Best wishes,<br>'\n        'The Oppia team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS:\n        log_new_error('This app cannot send feedback message emails to users.')\n        return\n\n    sender_username = user_services.get_username(sender_id)\n    recipient_username = user_services.get_username(recipient_id)\n    recipient_preferences = user_services.get_email_preferences(recipient_id)\n\n    if recipient_preferences.can_receive_feedback_message_email:\n        email_body = email_body_template % (\n            recipient_username, thread_title, exploration_id,\n            exploration_title, sender_username, message, EMAIL_FOOTER.value)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION, email_subject,\n            email_body, feconf.NOREPLY_EMAIL_ADDRESS, reply_to_id=reply_to_id)\n\n\ndef send_flag_exploration_email(\n        exploration_title, exploration_id, reporter_id, report_text):\n    \"\"\"Send an email to all moderators when an exploration is flagged.\n\n    Args:\n        exploration_title: str. The title of the flagged exporation.\n        exploration_id: str. The ID of the flagged exploration.\n        reporter_id: str. The user ID of the reporter.\n        report_text: str. The message entered by the reporter.\n    \"\"\"\n    email_subject = 'Exploration flagged by user: \"%s\"' % exploration_title\n\n    email_body_template = (\n        'Hello Moderator,<br>'\n        '%s has flagged exploration \"%s\" on the following '\n        'grounds: <br>'\n        '%s .<br>'\n        'You can modify the exploration by clicking '\n        '<a href=\"https://www.oppia.org/create/%s\">here</a>.<br>'\n        '<br>'\n        'Thanks!<br>'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    reporter_username = user_services.get_username(reporter_id)\n\n    email_body = email_body_template % (\n        reporter_username, exploration_title, report_text, exploration_id,\n        EMAIL_FOOTER.value)\n\n    recipient_list = user_services.get_user_ids_by_role(\n        feconf.ROLE_ID_MODERATOR)\n    for recipient_id in recipient_list:\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_REPORT_BAD_CONTENT,\n            email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_query_completion_email(recipient_id, query_id):\n    \"\"\"Send an email to the initiator of a bulk email query with a link to view\n    the query results.\n\n    Args:\n        recipient_id: str. The recipient ID.\n        query_id: str. The query ID.\n    \"\"\"\n    email_subject = 'Query %s has successfully completed' % query_id\n\n    email_body_template = (\n        'Hi %s,<br>'\n        'Your query with id %s has succesfully completed its '\n        'execution. Visit the result page '\n        '<a href=\"https://www.oppia.org/emaildashboardresult/%s\">here</a> '\n        'to see result of your query.<br><br>'\n        'Thanks!<br>'\n        '<br>'\n        'Best wishes,<br>'\n        'The Oppia Team<br>'\n        '<br>%s')\n\n    recipient_username = user_services.get_username(recipient_id)\n    email_body = email_body_template % (\n        recipient_username, query_id, query_id, EMAIL_FOOTER.value)\n    _send_email(\n        recipient_id, feconf.SYSTEM_COMMITTER_ID,\n        feconf.EMAIL_INTENT_QUERY_STATUS_NOTIFICATION, email_subject,\n        email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_query_failure_email(recipient_id, query_id, query_params):\n    \"\"\"Send an email to the initiator of a failed bulk email query.\n\n    Args:\n        recipient_id: str. The recipient ID.\n        query_id: str. The query ID.\n        query_params: dict. The parameters of the query, as key:value.\n    \"\"\"\n    email_subject = 'Query %s has failed' % query_id\n\n    email_body_template = (\n        'Hi %s,<br>'\n        'Your query with id %s has failed due to error '\n        'during execution. '\n        'Please check the query parameters and submit query again.<br><br>'\n        'Thanks!<br>'\n        '<br>'\n        'Best wishes,<br>'\n        'The Oppia Team<br>'\n        '<br>%s')\n\n    recipient_username = user_services.get_username(recipient_id)\n    email_body = email_body_template % (\n        recipient_username, query_id, EMAIL_FOOTER.value)\n    _send_email(\n        recipient_id, feconf.SYSTEM_COMMITTER_ID,\n        feconf.EMAIL_INTENT_QUERY_STATUS_NOTIFICATION, email_subject,\n        email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n    admin_email_subject = 'Query job has failed.'\n    admin_email_body_template = (\n        'Query job with %s query id has failed in its execution.\\n'\n        'Query parameters:\\n\\n')\n\n    for key in sorted(query_params):\n        admin_email_body_template += '%s: %s\\n' % (key, query_params[key])\n\n    admin_email_body = admin_email_body_template % query_id\n    send_mail_to_admin(admin_email_subject, admin_email_body)\n\n\ndef send_user_query_email(\n        sender_id, recipient_ids, email_subject, email_body, email_intent):\n    \"\"\"Sends an email to all the recipients of the query.\n\n    Args:\n        sender_id: str. The ID of the user sending the email.\n        recipient_ids: list(str). The user IDs of the email recipients.\n        email_subject: str. The subject of the email.\n        email_body: str. The body of the email.\n        email_intent: str. The intent string, i.e. the purpose of the email.\n\n    Returns:\n        bulk_email_model_id: str. The ID of the bulk email model.\n    \"\"\"\n    bulk_email_model_id = email_models.BulkEmailModel.get_new_id('')\n    sender_name = user_services.get_username(sender_id)\n    sender_email = user_services.get_email_from_user_id(sender_id)\n    _send_bulk_mail(\n        recipient_ids, sender_id, email_intent, email_subject, email_body,\n        sender_email, sender_name, bulk_email_model_id)\n    return bulk_email_model_id\n\n\ndef send_test_email_for_bulk_emails(tester_id, email_subject, email_body):\n    \"\"\"Sends a test email to the tester.\n\n    Args:\n        tester_id: str. The user ID of the tester.\n        email_subject: str. The subject of the email.\n        email_body: str. The body of the email.\n    \"\"\"\n    tester_name = user_services.get_username(tester_id)\n    tester_email = user_services.get_email_from_user_id(tester_id)\n    _send_email(\n        tester_id, tester_id, feconf.BULK_EMAIL_INTENT_TEST,\n        email_subject, email_body, tester_email, sender_name=tester_name)\n\n\ndef send_mail_to_onboard_new_reviewers(recipient_id, category):\n    \"\"\"Sends an email to users who have crossed the threshold score.\n\n    Args:\n        recipient_id: str. The ID of the user who is being offered to become a\n            reviewer.\n        category: str. The category that the user is being offered to review.\n    \"\"\"\n\n    email_subject = 'Invitation to review suggestions'\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'Thank you for actively contributing high-quality suggestions for '\n        'Oppia\\'s lessons in %s, and for helping to make these lessons better '\n        'for students around the world!<br><br>'\n        'In recognition of your contributions, we would like to invite you to '\n        'become one of Oppia\\'s reviewers. As a reviewer, you will be able to '\n        'review suggestions in %s, and contribute to helping ensure that any '\n        'edits made to lessons preserve the lessons\\' quality and are '\n        'beneficial for students.<br><br>'\n        'If you\\'d like to help out as a reviewer, please visit your '\n        '<a href=\"https://www.oppia.org/creator-dashboard/\">dashboard</a>. '\n        'and set your review preferences accordingly. Note that, if you accept,'\n        'you will receive occasional emails inviting you to review incoming '\n        'suggestions by others.<br><br>'\n        'Again, thank you for your contributions to the Oppia community!<br>'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        recipient_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        email_body = email_body_template % (\n            recipient_username, category, category, EMAIL_FOOTER.value)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_ONBOARD_REVIEWER,\n            email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_mail_to_notify_users_to_review(recipient_id, category):\n    \"\"\"Sends an email to users to review suggestions in categories they have\n    agreed to review for.\n\n    Args:\n        recipient_id: str. The id of the user who is being pinged to review\n            suggestions.\n        category: str. The category of the suggestions to review.\n    \"\"\"\n\n    email_subject = 'Notification to review suggestions'\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'Just a heads-up that there are new suggestions to '\n        'review in %s, which you are registered as a reviewer for.'\n        '<br><br>Please take a look at and accept/reject these suggestions at'\n        ' your earliest convenience. You can visit your '\n        '<a href=\"https://www.oppia.org/creator-dashboard/\">dashboard</a> '\n        'to view the list of suggestions that need a review.<br><br>'\n        'Thank you for helping improve Oppia\\'s lessons!'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        recipient_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        email_body = email_body_template % (\n            recipient_username, category, EMAIL_FOOTER.value)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_REVIEW_CREATOR_DASHBOARD_SUGGESTIONS,\n            email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef _create_html_for_reviewable_suggestion_email_info(\n        reviewable_suggestion_email_info):\n    \"\"\"Creates the html for the given reviewable_suggestion_email_info. This\n    html content is used to provide information about a suggestion in an\n    email.\n\n    Args:\n        reviewable_suggestion_email_info: ReviewableSuggestionEmailInfo. The\n            information about the suggestion that will be used to form the\n            html for the email. This includes the suggestion type, language,\n            content and review submission date.\n\n    Returns:\n        str. A string containing the html that represents the suggestion\n        information.\n    \"\"\"\n    # Get the language of the suggestion.\n    language = utils.get_supported_audio_language_description(\n        reviewable_suggestion_email_info.language_code)\n    # Calculate how long the suggestion has been waiting for review.\n    suggestion_review_wait_time = (\n        datetime.datetime.utcnow() - (\n            reviewable_suggestion_email_info.submission_datetime))\n    # Get a string composed of the largest time unit that has a\n    # value, followed by that time unit. For example, if the\n    # suggestion had been waiting for review for 5 days and 2 hours,\n    # '5 days' would be returned. This is more user friendly since a\n    # high level of precision is not needed.\n    human_readable_review_wait_time = (\n        utils.create_string_from_largest_unit_in_timedelta(\n            suggestion_review_wait_time))\n    values_to_populate_suggestion_template_dict = {\n        'language': language,\n        'review_wait_time': human_readable_review_wait_time,\n        'suggestion_content': (\n            reviewable_suggestion_email_info.suggestion_content)\n    }\n    get_values_to_populate_suggestion_template = (\n        HTML_FOR_SUGGESTION_DESCRIPTION[\n            'suggestion_template_values_getter_functions'][\n                reviewable_suggestion_email_info.suggestion_type])\n    suggestion_template = (\n        HTML_FOR_SUGGESTION_DESCRIPTION[\n            'suggestion_template'][\n                reviewable_suggestion_email_info.suggestion_type])\n    return suggestion_template % (\n        get_values_to_populate_suggestion_template(\n            values_to_populate_suggestion_template_dict))\n\n\ndef send_mail_to_notify_admins_suggestions_waiting_long(\n        admin_ids, reviewable_suggestion_email_infos):\n    \"\"\"Sends an email to admins to inform them about the suggestions that have\n    been waiting longer than\n    suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days for a\n    review on the Contributor Dashboard. Admins can be informed about at most\n    suggestion_models.MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN suggestions.\n    The information about the suggestions is organized in descending order\n    by the suggestion's review wait time.\n\n    Args:\n        admin_ids: list(str). The user ids of the admins to notify.\n        reviewable_suggestion_email_infos: list(ReviewableSuggestionEmailInfo).\n            list(ReviewableSuggestionEmailContentInfo). A list of suggestion\n            email content info objects that represent suggestions\n            that have been waiting too long for review to notify the admins\n            about. Each object contains includes the suggestion type, language,\n            content and review submission date. The objects are sorted in\n            descending order based on review wait time.\n    \"\"\"\n    email_subject = (\n        ADMIN_NOTIFICATION_FOR_SUGGESTIONS_NEEDING_REVIEW_EMAIL_DATA[\n            'email_subject'])\n    email_body_template = (\n        ADMIN_NOTIFICATION_FOR_SUGGESTIONS_NEEDING_REVIEW_EMAIL_DATA[\n            'email_body_template'])\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not (\n            config_domain\n            .ENABLE_ADMIN_NOTIFICATIONS_FOR_SUGGESTIONS_NEEDING_REVIEW.value):\n        log_new_error(\n            'The \"notify_admins_suggestions_waiting_too_long\" property '\n            'must be enabled on the admin config page in order to send '\n            'admins the emails.'\n        )\n        return\n\n    if not reviewable_suggestion_email_infos:\n        logging.info(\n            'There were no Contributor Dashboard suggestions that were waiting '\n            'too long for a review.')\n        return\n\n    if not admin_ids:\n        log_new_error('There were no admins to notify.')\n        return\n\n    suggestion_descriptions = []\n    # Get the html for the list of suggestions that have been waiting too long\n    # for a review.\n    for reviewable_suggestion_email_info in reviewable_suggestion_email_infos:\n        suggestion_descriptions.append(\n            _create_html_for_reviewable_suggestion_email_info(\n                reviewable_suggestion_email_info))\n\n    list_of_suggestion_descriptions = ''.join(\n        suggestion_descriptions)\n\n    # Get the emails and usernames of the admins.\n    admin_user_settings = user_services.get_users_settings(admin_ids)\n    admin_usernames, admin_emails = list(python_utils.ZIP(*[\n        (admin_user_setting.username, admin_user_setting.email)\n        if admin_user_setting is not None else (None, None)\n        for admin_user_setting in admin_user_settings\n    ]))\n\n    for index, admin_id in enumerate(admin_ids):\n        if not admin_emails[index]:\n            log_new_error(\n                'There was no email for the given admin id: %s.' % admin_id)\n            continue\n        else:\n            email_body = email_body_template % (\n                admin_usernames[index], feconf.OPPIA_SITE_URL,\n                feconf.CONTRIBUTOR_DASHBOARD_URL,\n                suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS,\n                feconf.OPPIA_SITE_URL, feconf.ADMIN_URL,\n                list_of_suggestion_descriptions)\n\n            _send_email(\n                admin_id, feconf.SYSTEM_COMMITTER_ID,\n                feconf.EMAIL_INTENT_ADDRESS_CONTRIBUTOR_DASHBOARD_SUGGESTIONS,\n                email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS,\n                recipient_email=admin_emails[index])\n\n\ndef send_mail_to_notify_admins_that_reviewers_are_needed(\n        admin_ids, suggestion_types_needing_reviewers):\n    \"\"\"Sends an email to admins to notify them that there are specific\n    suggestion types on the Contributor Dashboard that need more reviewers.\n\n    Note: it is assumed that all admins are super admins because only super\n    admins have access to the admin page where reviewers can be added to the\n    Contributor Dashboard. Also note that these emails are sent out regardless\n    of the admins' email preferences.\n\n    Args:\n        admin_ids: list(str). The user ids of the admins to notify.\n        suggestion_types_needing_reviewers: dict. A dictionary where the keys\n            are suggestion types and each value corresponds to a set that\n            contains the language codes within the suggestion type that need\n            more reviewers. For example, for translation suggestions, the value\n            would be a set of language codes that translations are offered in\n            that need more reviewers.\n    \"\"\"\n    email_subject = ADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA[\n        'email_subject']\n    email_body_template = ADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA[\n        'email_body_template']\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not (\n            config_domain\n            .ENABLE_ADMIN_NOTIFICATIONS_FOR_REVIEWER_SHORTAGE.value):\n        log_new_error(\n            'The \"enable_admin_notifications_for_reviewer_shortage\" '\n            'property must be enabled on the admin config page in order to '\n            'send admins the emails.'\n        )\n        return\n\n    if not suggestion_types_needing_reviewers:\n        logging.info(\n            'There were no suggestion types that needed more reviewers on the '\n            'Contributor Dashboard.')\n        return\n\n    if not admin_ids:\n        log_new_error('There were no admins to notify.')\n        return\n\n    # Create the html for the suggestion types that need more reviewers for the\n    # email body html.\n    suggestion_types_needing_reviewers_paragraphs = []\n    if feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT in (\n            suggestion_types_needing_reviewers):\n        language_codes_that_need_reviewers = (\n            suggestion_types_needing_reviewers[\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT])\n        # There are different templates to handle whether multiple languages\n        # need more reviewers or just one language.\n        if len(language_codes_that_need_reviewers) == 1:\n            suggestion_types_needing_reviewers_paragraphs.append(\n                ADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA[\n                    'one_language_template'] % (\n                        utils.get_supported_audio_language_description(\n                            language_codes_that_need_reviewers.pop()),\n                        feconf.OPPIA_SITE_URL,\n                        feconf.CONTRIBUTOR_DASHBOARD_URL))\n\n        else:\n            html_for_languages_that_need_more_reviewers = ''.join(\n                [\n                    '<li><b>%s</b></li><br>' % (\n                        utils.get_supported_audio_language_description(\n                            language_code)) for language_code in\n                    language_codes_that_need_reviewers\n                ]\n            )\n            suggestion_types_needing_reviewers_paragraphs.append(\n                ADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA[\n                    'multi_language_template'] % (\n                        feconf.OPPIA_SITE_URL,\n                        feconf.CONTRIBUTOR_DASHBOARD_URL,\n                        html_for_languages_that_need_more_reviewers))\n\n    if feconf.SUGGESTION_TYPE_ADD_QUESTION in (\n            suggestion_types_needing_reviewers):\n        suggestion_types_needing_reviewers_paragraphs.append(\n            ADMIN_NOTIFICATION_FOR_REVIEWER_SHORTAGE_EMAIL_DATA[\n                'question_template'])\n\n    suggestion_types_needing_reviewers_html = ''.join(\n        suggestion_types_needing_reviewers_paragraphs)\n\n    # Get the emails and usernames of the admins.\n    admin_user_settings = user_services.get_users_settings(admin_ids)\n    admin_usernames, admin_emails = list(python_utils.ZIP(*[\n        (admin_user_setting.username, admin_user_setting.email)\n        if admin_user_setting is not None else (None, None)\n        for admin_user_setting in admin_user_settings\n    ]))\n\n    for index, admin_id in enumerate(admin_ids):\n        if not admin_emails[index]:\n            log_new_error(\n                'There was no email for the given admin id: %s.' % admin_id)\n            continue\n        else:\n            email_body = email_body_template % (\n                admin_usernames[index], feconf.OPPIA_SITE_URL, feconf.ADMIN_URL,\n                suggestion_types_needing_reviewers_html)\n\n            _send_email(\n                admin_id, feconf.SYSTEM_COMMITTER_ID,\n                feconf.EMAIL_INTENT_ADD_CONTRIBUTOR_DASHBOARD_REVIEWERS,\n                email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS,\n                recipient_email=admin_emails[index])\n\n\ndef send_mail_to_notify_contributor_dashboard_reviewers(\n        reviewer_ids, reviewers_suggestion_email_infos):\n    \"\"\"Sends an email to each reviewer notifying them of the suggestions on the\n    Contributor Dashboard that have been waiting the longest for review, and\n    that the reviewer has permission to review.\n\n    Args:\n        reviewer_ids: list(str). A list of the Contributor Dashboard reviewer\n            user ids to notify.\n        reviewers_suggestion_email_infos:\n            list(list(ReviewableSuggestionEmailInfo)). A list of suggestion\n            email content info objects for each reviewer. These suggestion\n            email content info objects contain the key information about the\n            suggestions we're notifying reviewers about and will be used to\n            compose the email body for each reviewer.\n    \"\"\"\n    email_subject = CONTRIBUTOR_DASHBOARD_REVIEWER_NOTIFICATION_EMAIL_DATA[\n        'email_subject']\n    email_body_template = (\n        CONTRIBUTOR_DASHBOARD_REVIEWER_NOTIFICATION_EMAIL_DATA[\n            'email_body_template'])\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    if not (\n            config_domain\n            .CONTRIBUTOR_DASHBOARD_REVIEWER_EMAILS_IS_ENABLED.value):\n        log_new_error(\n            'The \"contributor_dashboard_reviewer_emails_is_enabled\" property '\n            'must be enabled on the admin config page in order to send '\n            'reviewers the emails.'\n        )\n        return\n\n    if not reviewer_ids:\n        log_new_error('No Contributor Dashboard reviewers to notify.')\n        return\n\n    reviewer_user_settings = user_services.get_users_settings(reviewer_ids)\n    reviewer_usernames, reviewer_emails = list(python_utils.ZIP(*[\n        (reviewer_user_setting.username, reviewer_user_setting.email)\n        if reviewer_user_setting is not None else (None, None)\n        for reviewer_user_setting in reviewer_user_settings\n    ]))\n\n    for index, reviewer_id in enumerate(reviewer_ids):\n        if not reviewers_suggestion_email_infos[index]:\n            logging.info(\n                'There were no suggestions to recommend to the reviewer with '\n                'user id: %s.' % reviewer_id)\n            continue\n        elif not reviewer_emails[index]:\n            log_new_error(\n                'There was no email for the given reviewer id: %s.' % (\n                    reviewer_id))\n            continue\n        else:\n            suggestion_descriptions = []\n            for reviewer_suggestion_email_info in (\n                    reviewers_suggestion_email_infos[index]):\n                suggestion_descriptions.append(\n                    _create_html_for_reviewable_suggestion_email_info(\n                        reviewer_suggestion_email_info))\n\n            email_body = email_body_template % (\n                reviewer_usernames[index], feconf.OPPIA_SITE_URL,\n                feconf.CONTRIBUTOR_DASHBOARD_URL, ''.join(\n                    suggestion_descriptions),\n                EMAIL_FOOTER.value)\n\n            _send_email(\n                reviewer_id, feconf.SYSTEM_COMMITTER_ID,\n                feconf.EMAIL_INTENT_REVIEW_CONTRIBUTOR_DASHBOARD_SUGGESTIONS,\n                email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS,\n                recipient_email=reviewer_emails[index])\n\n\ndef send_accepted_voiceover_application_email(\n        recipient_id, lesson_title, language_code):\n    \"\"\"Sends an email to users to an give update on the accepted voiceover\n    application.\n\n    Args:\n        recipient_id: str. The id of the user whose voiceover application got\n            accepted.\n        lesson_title: str. The title of the lessons for which the voiceover\n            application got accepted.\n        language_code: str. The language code for which the voiceover\n            application got accepted.\n    \"\"\"\n    email_subject = '[Accepted] Updates on submitted voiceover application'\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'Congratulations! Your voiceover application for \"%s\" lesson got '\n        'accepted and you have been assigned with a voice artist role in the '\n        'lesson. Now you will be able to add voiceovers to the lesson in %s '\n        'language.'\n        '<br><br>You can check the wiki page to learn'\n        '<a href=\"https://github.com/oppia/oppia/wiki/'\n        'Instructions-for-voice-artists\">how to voiceover a lesson</a><br><br>'\n        'Thank you for helping improve Oppia\\'s lessons!'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        recipient_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        language = utils.get_supported_audio_language_description(language_code)\n        email_body = email_body_template % (\n            recipient_username, lesson_title, language, EMAIL_FOOTER.value)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_VOICEOVER_APPLICATION_UPDATES,\n            email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_rejected_voiceover_application_email(\n        recipient_id, lesson_title, language_code, rejection_message):\n    \"\"\"Sends an email to users to give update on the rejected voiceover\n    application.\n\n    Args:\n        recipient_id: str. The id of the user whose voiceover application got\n            accepted.\n        lesson_title: str. The title of the lessons for which the voiceover\n            application got accepted.\n        language_code: str. The language code in which for which the voiceover\n            application got accepted.\n        rejection_message: str. The message left by the reviewer while rejecting\n            the voiceover application.\n    \"\"\"\n    email_subject = 'Updates on submitted voiceover application'\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'Your voiceover application for \"%s\" lesson in language %s got rejected'\n        ' and the reviewer has left a message.'\n        '<br><br>Review message: %s<br><br>'\n        'You can create a new voiceover application through the'\n        '<a href=\"https://oppia.org/contributor-dashboard\">'\n        'contributor dashboard</a> page.<br><br>'\n        '- The Oppia Team<br>'\n        '<br>%s')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        recipient_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        language = utils.get_supported_audio_language_description(language_code)\n        email_body = email_body_template % (\n            recipient_username, lesson_title, language,\n            rejection_message, EMAIL_FOOTER.value)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_VOICEOVER_APPLICATION_UPDATES,\n            email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_account_deleted_email(user_id, user_email):\n    \"\"\"Sends an email to user whose account was deleted.\n\n    Args:\n        user_id: str. The id of the user whose account got deleted.\n        user_email: str. The email of the user whose account got deleted.\n    \"\"\"\n    email_subject = 'Account deleted'\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'Your account was successfully deleted.<br><br>'\n        '- The Oppia Team')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    email_body = email_body_template % user_email\n    _send_email(\n        user_id, feconf.SYSTEM_COMMITTER_ID,\n        feconf.EMAIL_INTENT_ACCOUNT_DELETED, email_subject, email_body,\n        feconf.NOREPLY_EMAIL_ADDRESS, bcc_admin=True,\n        recipient_email=user_email)\n\n\ndef send_account_deletion_failed_email(user_id, user_email):\n    \"\"\"Sends an email to admin about the failure of the job that is supposed to\n    delete the user.\n\n    Args:\n        user_id: str. The id of the user whose account failed to get deleted.\n        user_email: str. The email of the user whose account failed to\n            get deleted.\n    \"\"\"\n    email_subject = 'WIPEOUT: Account deletion failed'\n    email_body_template = (\n        'The Wipeout process failed for the user '\n        'with ID \\'%s\\' and email \\'%s\\'.' % (user_id, user_email)\n    )\n    send_mail_to_admin(email_subject, email_body_template)\n\n\ndef send_email_to_new_contribution_reviewer(\n        recipient_id, review_category, language_code=None):\n    \"\"\"Sends an email to user who is assigned as a reviewer.\n\n    Args:\n        recipient_id: str. The ID of the user.\n        review_category: str. The category in which user can review.\n        language_code: None|str. The language code for a language if the review\n            item is translation or voiceover else None.\n    \"\"\"\n    if review_category not in NEW_REVIEWER_EMAIL_DATA:\n        raise Exception('Invalid review_category: %s' % review_category)\n\n    review_category_data = NEW_REVIEWER_EMAIL_DATA[review_category]\n    email_subject = 'You have been invited to review Oppia %s' % (\n        review_category_data['review_category'])\n\n    if review_category in [\n            constants.REVIEW_CATEGORY_TRANSLATION,\n            constants.REVIEW_CATEGORY_VOICEOVER]:\n        language_description = utils.get_supported_audio_language_description(\n            language_code).capitalize()\n        review_category_description = (\n            review_category_data['description_template'] % language_description)\n        reviewer_rights_message = (\n            review_category_data['rights_message_template'] % (\n                language_description))\n    else:\n        review_category_description = review_category_data['description']\n        reviewer_rights_message = review_category_data['rights_message']\n\n    to_review = review_category_data['to_check']\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'This is to let you know that the Oppia team has added you as a '\n        'reviewer for %s. This allows you to %s.<br><br>'\n        'You can check the %s waiting for review in the '\n        '<a href=\"https://www.oppia.org/contributor-dashboard\">'\n        'Contributor Dashboard</a>.<br><br>'\n        'Thanks, and happy contributing!<br><br>'\n        'Best wishes,<br>'\n        'The Oppia Community')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(recipient_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        recipient_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        email_body = email_body_template % (\n            recipient_username, review_category_description,\n            reviewer_rights_message, to_review)\n        _send_email(\n            recipient_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_ONBOARD_REVIEWER, email_subject, email_body,\n            feconf.NOREPLY_EMAIL_ADDRESS)\n\n\ndef send_email_to_removed_contribution_reviewer(\n        user_id, review_category, language_code=None):\n    \"\"\"Sends an email to user who is removed from the reviewer position.\n\n    Args:\n        user_id: str. The ID of the user.\n        review_category: str. The category which for which review role is\n            removed.\n        language_code: None|str. The language code for a language if the review\n            item is translation or voiceover else None.\n    \"\"\"\n    if review_category not in REMOVED_REVIEWER_EMAIL_DATA:\n        raise Exception('Invalid review_category: %s' % review_category)\n\n    review_category_data = REMOVED_REVIEWER_EMAIL_DATA[review_category]\n    email_subject = 'You have been unassigned as a %s reviewer' % (\n        review_category_data['review_category'])\n\n    if review_category in [\n            constants.REVIEW_CATEGORY_TRANSLATION,\n            constants.REVIEW_CATEGORY_VOICEOVER]:\n        language_description = utils.get_supported_audio_language_description(\n            language_code).capitalize()\n        reviewer_role_description = (\n            review_category_data['role_description_template'] % (\n                language_description))\n        reviewer_rights_message = (\n            review_category_data['rights_message_template'] % (\n                language_description))\n    else:\n        reviewer_role_description = review_category_data['role_description']\n        reviewer_rights_message = review_category_data['rights_message']\n\n    email_body_template = (\n        'Hi %s,<br><br>'\n        'The Oppia team has removed you from the %s. You won\\'t be able to %s '\n        'any more, but you can still contribute %s through the '\n        '<a href=\"https://www.oppia.org/contributor-dashboard\">'\n        'Contributor Dashboard</a>.<br><br>'\n        'Thanks, and happy contributing!<br><br>'\n        'Best wishes,<br>'\n        'The Oppia Community')\n\n    if not feconf.CAN_SEND_EMAILS:\n        log_new_error('This app cannot send emails to users.')\n        return\n\n    recipient_username = user_services.get_username(user_id)\n    can_user_receive_email = user_services.get_email_preferences(\n        user_id).can_receive_email_updates\n\n    # Send email only if recipient wants to receive.\n    if can_user_receive_email:\n        email_body = email_body_template % (\n            recipient_username, reviewer_role_description,\n            reviewer_rights_message,\n            review_category_data['contribution_allowed'])\n        _send_email(\n            user_id, feconf.SYSTEM_COMMITTER_ID,\n            feconf.EMAIL_INTENT_REMOVE_REVIEWER, email_subject, email_body,\n            feconf.NOREPLY_EMAIL_ADDRESS)\n"
    },
    {
      "filename": "core/domain/feedback_jobs_continuous.py",
      "content": "# coding: utf-8\n#\n# Copyright 2015 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Continuous computation jobs for feedback system.\"\"\"\n\nfrom __future__ import absolute_import  # pylint: disable=import-only-modules\nfrom __future__ import unicode_literals  # pylint: disable=import-only-modules\n\nfrom core import jobs\nfrom core.domain import feedback_domain\nfrom core.platform import models\nimport feconf\nimport python_utils\n\n(base_models, feedback_models, exp_models,) = models.Registry.import_models([\n    models.NAMES.base_model, models.NAMES.feedback, models.NAMES.exploration\n])\n\ndatastore_services = models.Registry.import_datastore_services()\ntransaction_services = models.Registry.import_transaction_services()\n\n\nclass FeedbackAnalyticsRealtimeModel(\n        jobs.BaseRealtimeDatastoreClassForContinuousComputations):\n    \"\"\"A continuous-computation job that sets the number of open threads\n    and the total number of threads to the default integer value of zero\n    in the realtime layer.\n    \"\"\"\n\n    num_open_threads = datastore_services.IntegerProperty(default=0)\n    num_total_threads = datastore_services.IntegerProperty(default=0)\n\n\nclass FeedbackAnalyticsAggregator(jobs.BaseContinuousComputationManager):\n    \"\"\"A continuous-computation job that computes analytics for feedback\n    threads of explorations.\n    \"\"\"\n\n    @classmethod\n    def get_event_types_listened_to(cls):\n        \"\"\"Get the event types that this class is subscribed to.\n\n        Returns:\n            list(str). List of event types that this class is subscribed to.\n        \"\"\"\n        return [feconf.EVENT_TYPE_NEW_THREAD_CREATED,\n                feconf.EVENT_TYPE_THREAD_STATUS_CHANGED]\n\n    @classmethod\n    def _get_realtime_datastore_class(cls):\n        \"\"\"Get the realtime datastore class used by the realtime layer.\n\n        Returns:\n            datastore_services.MetaModel. Datastore class used by the realtime\n            layer, which should be a subclass of\n            BaseRealtimeDatastoreClassForContinuousComputations.\n        \"\"\"\n        return FeedbackAnalyticsRealtimeModel\n\n    @classmethod\n    def _get_batch_job_manager_class(cls):\n        \"\"\"Get manager class for the continuously-running batch job.\n\n        Returns:\n            type. Manager class for continuous-running batch job.\n        \"\"\"\n        return FeedbackAnalyticsMRJobManager\n\n    @classmethod\n    def _handle_incoming_event(cls, active_realtime_layer, event_type, *args):\n        \"\"\"Records thread analytics in the given realtime layer.\n\n        Args:\n            active_realtime_layer: int. The currently active realtime\n                datastore layer.\n            event_type: str. The event triggered by the student.\n            *args: list(*). Variable length argument list. The\n                first element of *args corresponds to the id\n                of the exploration currently being played.\n        \"\"\"\n        exp_id = args[0]\n\n        @transaction_services.run_in_transaction_wrapper\n        def _increment_open_threads_count_transactional():\n            \"\"\"Increments count of open threads by one.\"\"\"\n            realtime_class = cls._get_realtime_datastore_class()\n            realtime_model_id = realtime_class.get_realtime_id(\n                active_realtime_layer, exp_id)\n\n            model = realtime_class.get(realtime_model_id, strict=False)\n            if model is None:\n                realtime_class(\n                    id=realtime_model_id, num_open_threads=1,\n                    realtime_layer=active_realtime_layer).put()\n            else:\n                model.num_open_threads += 1\n                model.update_timestamps()\n                model.put()\n\n        @transaction_services.run_in_transaction_wrapper\n        def _increment_total_threads_count_transactional():\n            \"\"\"Increments count of total threads by one.\"\"\"\n            realtime_class = cls._get_realtime_datastore_class()\n            realtime_model_id = realtime_class.get_realtime_id(\n                active_realtime_layer, exp_id)\n\n            model = realtime_class.get(realtime_model_id, strict=False)\n            if model is None:\n                realtime_class(\n                    id=realtime_model_id, num_total_threads=1,\n                    realtime_layer=active_realtime_layer).put()\n            else:\n                model.num_total_threads += 1\n                model.update_timestamps()\n                model.put()\n\n        @transaction_services.run_in_transaction_wrapper\n        def _decrement_open_threads_count_transactional():\n            \"\"\"Decrements count of open threads by one.\"\"\"\n            realtime_class = cls._get_realtime_datastore_class()\n            realtime_model_id = realtime_class.get_realtime_id(\n                active_realtime_layer, exp_id)\n\n            model = realtime_class.get(realtime_model_id, strict=False)\n            if model is None:\n                realtime_class(\n                    id=realtime_model_id, num_open_threads=-1,\n                    realtime_layer=active_realtime_layer).put()\n            else:\n                model.num_open_threads -= 1\n                model.update_timestamps()\n                model.put()\n\n        if event_type == feconf.EVENT_TYPE_NEW_THREAD_CREATED:\n            _increment_total_threads_count_transactional()\n            _increment_open_threads_count_transactional()\n        elif event_type == feconf.EVENT_TYPE_THREAD_STATUS_CHANGED:\n            old_status = args[1]\n            updated_status = args[2]\n            # Status changed from closed to open.\n            if (old_status != feedback_models.STATUS_CHOICES_OPEN\n                    and updated_status == feedback_models.STATUS_CHOICES_OPEN):\n                _increment_open_threads_count_transactional()\n            # Status changed from open to closed.\n            elif (old_status == feedback_models.STATUS_CHOICES_OPEN\n                  and updated_status != feedback_models.STATUS_CHOICES_OPEN):\n                _decrement_open_threads_count_transactional()\n\n    # Public query methods.\n    @classmethod\n    def get_thread_analytics_multi(cls, exploration_ids):\n        \"\"\"Gets the thread analytics for the explorations specified by the\n        exploration_ids.\n\n        Args:\n            exploration_ids: list(str). IDs of the explorations to get analytics\n                for.\n\n        Returns:\n            list(dict). Each dict in this list corresponds to an\n            exploration ID in the input list, and has two keys:\n            - num_open_threads: int. The count of open feedback threads\n              for this exploration.\n            - num_total_threads: int. The count of all feedback threads\n              for this exploration.\n        \"\"\"\n        realtime_model_ids = cls.get_multi_active_realtime_layer_ids(\n            exploration_ids)\n        realtime_models = cls._get_realtime_datastore_class().get_multi(\n            realtime_model_ids)\n\n        feedback_thread_analytics_models = (\n            feedback_models.FeedbackAnalyticsModel.get_multi(exploration_ids))\n        return [feedback_domain.FeedbackAnalytics(\n            feconf.ENTITY_TYPE_EXPLORATION, exploration_ids[i],\n            (\n                realtime_models[i].num_open_threads\n                if realtime_models[i] is not None else 0) +\n            (\n                feedback_thread_analytics_models[i].num_open_threads\n                if feedback_thread_analytics_models[i] is not None else 0),\n            (\n                realtime_models[i].num_total_threads\n                if realtime_models[i] is not None else 0) +\n            (\n                feedback_thread_analytics_models[i].num_total_threads\n                if feedback_thread_analytics_models[i] is not None else 0)\n        ) for i in python_utils.RANGE(len(exploration_ids))]\n\n    @classmethod\n    def get_thread_analytics(cls, exploration_id):\n        \"\"\"Retrieves the analytics for feedback threads.\n\n        Args:\n            exploration_id: str. ID of the exploration to get analytics for.\n\n        Returns:\n            dict. Contains two keys:\n                - num_open_threads: int. The count of open feedback threads for\n                    this exploration.\n                - num_total_threads: int. The count of all feedback\n                    threads for this exploration.\n        \"\"\"\n        return FeedbackAnalyticsAggregator.get_thread_analytics_multi(\n            [exploration_id])[0]\n\n\nclass FeedbackAnalyticsMRJobManager(\n        jobs.BaseMapReduceJobManagerForContinuousComputations):\n    \"\"\"Job that creates FeedbackAnalyticsModels for explorations by calculating\n    various analytics for feedback threads corresponding to an exploration.\n\n    Currently, this job calculates the number of open feedback threads, as well\n    as the total feedback thread count for each exploration.\n    \"\"\"\n\n    @classmethod\n    def _get_continuous_computation_class(cls):\n        \"\"\"Get class for continuous computaion that computes analytics\n        for feedback threads of explorations.\n\n        Returns:\n            type. Class for continuous computaion of analytics.\n        \"\"\"\n        return FeedbackAnalyticsAggregator\n\n    @classmethod\n    def entity_classes_to_map_over(cls):\n        \"\"\"Get the list of classes that this class maps over\n\n        Returns:\n            list(GeneralFeedbackThreadModel). List of classes of feedback\n            thread models.\n        \"\"\"\n        return [feedback_models.GeneralFeedbackThreadModel]\n\n    @staticmethod\n    def map(item):\n        \"\"\"Map function.\n\n        Args:\n            item: GeneralFeedbackThreadModel. A general feedback thread model\n                instance.\n\n        Yields:\n            2-tuple of (entity_id, status). Where:\n                - entity_id: str. The exploration id associated to the feedback\n                    thread.\n                - status: str. The feedback thread's status.\n        \"\"\"\n        yield (item.entity_id, item.status)\n\n    @staticmethod\n    def reduce(key, stringified_values):\n        \"\"\"Reduce function.\n\n        Args:\n            key: str. The exploration ID.\n            stringified_values: list(str). List of all statuses from all\n                mappers tagged with the given key.\n      \"\"\"\n        num_open_threads = stringified_values.count(\n            feedback_models.STATUS_CHOICES_OPEN)\n        num_total_threads = len(stringified_values)\n\n        feedback_models.FeedbackAnalyticsModel.create(\n            key, num_open_threads, num_total_threads)\n"
    }
  ],
  "questions": [
    "Hi @vojtechjelinek \r\ncan I please go ahead with the rest of the files, I'm halfway done?\r\nThanks",
    "Also another question regarding the ```wipeout_services.py```\r\nJust to confirm, is it ```wipeout_services.py``` or ```wipeout_service.py``` ?\r\nApparently I can't fuzzy find ```wipeout_services.py``` the closest file to it is ```wipeout_service.py``` which I can find."
  ],
  "golden_answers": [
    "@lkbhitesh07 Let's leave that to other new contributors, you can take up other issues. Btw did you fill the [Oppia contributor survey](https://goo.gl/forms/otv30JV3Ihv0dT3C3)?",
    "@OBITORASU The `BaseModel.delete_multi` can be used in other files, also since some models inherit from `BaseModel` (like `UserSettingsModel`), the `delete_multi` can be used in these classes too."
  ],
  "questions_generated": [
    "What is the main task described in the issue for the oppia_oppia repository?",
    "What steps are suggested to refactor the transaction handling in the oppia_oppia repository?",
    "Which files have been claimed by contributor @lkbhitesh07 for refactoring in the issue discussed?",
    "Why is it necessary to replace `run_in_transaction` with `run_in_transaction_wrapper`?",
    "What is the role of the `transaction_services` module in the oppia_oppia repository?",
    "What is the purpose of using a decorator like `run_in_transaction_wrapper` in Python?",
    "How should the function call be modified after applying the `run_in_transaction_wrapper` decorator?",
    "What reference is provided for understanding the changes needed in the oppia_oppia repository?"
  ],
  "golden_answers_generated": [
    "The main task described in the issue is to replace all usages of `run_in_transaction` with the new `run_in_transaction_wrapper` in various files within the repository.",
    "The steps suggested include claiming a file, looking for occurrences of `run_in_transaction`, replacing it with the `run_in_transaction_wrapper` decorator, and renaming the function call from `transaction_services.run_in_transaction(_update_user_rating)` to `_update_user_rating_transactional()`.",
    "Contributor @lkbhitesh07 has claimed the following files for refactoring: feedback_services.py, question_services.py, stats_services.py, suggestion_jobs_one_off.py, suggestion_services.py, user_services.py, jobs.py, statistics/gae_models.py, and user_jobs_continuous.py.",
    "While the specific reason isn't detailed in the context provided, typically such replacements are necessary for code optimization, to adhere to updated coding standards, or to utilize enhanced functionality provided by the new wrapper.",
    "The `transaction_services` module in oppia_oppia is likely responsible for handling database transactions, ensuring that operations are executed in a transactional manner to maintain data integrity.",
    "A decorator like `run_in_transaction_wrapper` is used to wrap a function with additional behavior. In this context, it adds transactional behavior to a function, ensuring that the function's operations are executed within a transaction.",
    "After applying the `run_in_transaction_wrapper` decorator, the function should be renamed to include `_transactional` at the end of its name, and any calls to `transaction_services.run_in_transaction(function_name)` should be replaced with `function_name_transactional()`.",
    "The issue mentions to see #11741 for reference, which likely contains examples or further details about the changes needed for replacing `run_in_transaction` with `run_in_transaction_wrapper`."
  ]
}