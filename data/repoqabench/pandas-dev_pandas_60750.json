{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "60750",
  "issue_description": "# BUG: `pd.Series.isnumeric()` doesn't work on decimal value strings\n\n### Pandas version checks\n\n- [x] I have checked that this issue has not already been reported.\n\n- [x] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [x] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\n\ndf = pd.DataFrame({\"string_values\": [\"1\", \"1.0\", \"1.1\"]})\ndf.string_values.str.isnumeric()\n```\n\n### Issue Description\n\nThe series method `.isnumeric()` only works on integer strings. If a string number is decimal, it will return `False`. When running the example below, the following is returned: \n\n<img width=\"609\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/9cdd0a8e-4a74-4e2f-ba07-44914a085b4d\" />\n\nThis is the docs description for the method: \n\n<img width=\"758\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/0c10d350-56af-4699-8fcb-2f20a739e28a\" />\n\n\n### Expected Behavior\n\nRunning the method on decimal strings should return `True`.\n\n### Installed Versions\n\n<details>\n\nINSTALLED VERSIONS\n------------------\ncommit                : 0691c5cf90477d3503834d983f69350f250a6ff7\npython                : 3.12.8\npython-bits           : 64\nOS                    : Linux\nOS-release            : 5.15.49-linuxkit-pr\nVersion               : #1 SMP PREEMPT Thu May 25 07:27:39 UTC 2023\nmachine               : x86_64\nprocessor             : \nbyteorder             : little\nLC_ALL                : None\nLANG                  : C.UTF-8\nLOCALE                : C.UTF-8\n\npandas                : 2.2.3\nnumpy                 : 2.2.1\npytz                  : 2024.2\ndateutil              : 2.9.0.post0\npip                   : 24.3.1\nCython                : None\nsphinx                : None\nIPython               : 8.31.0\nadbc-driver-postgresql: None\nadbc-driver-sqlite    : None\nbs4                   : 4.12.3\nblosc                 : None\nbottleneck            : None\ndataframe-api-compat  : None\nfastparquet           : None\nfsspec                : None\nhtml5lib              : None\nhypothesis            : None\ngcsfs                 : None\njinja2                : 3.1.5\nlxml.etree            : 5.3.0\nmatplotlib            : 3.10.0\nnumba                 : None\nnumexpr               : None\nodfpy                 : None\nopenpyxl              : 3.1.5\npandas_gbq            : None\npsycopg2              : 2.9.10\npymysql               : None\npyarrow               : 18.1.0\npyreadstat            : None\npytest                : 8.3.4\npython-calamine       : None\npyxlsb                : None\ns3fs                  : None\nscipy                 : 1.15.1\nsqlalchemy            : 2.0.37\ntables                : None\ntabulate              : 0.9.0\nxarray                : None\nxlrd                  : 2.0.1\nxlsxwriter            : None\nzstandard             : None\ntzdata                : 2024.2\nqtpy                  : None\npyqt5                 : None\n\n</details>\n",
  "issue_comments": [
    {
      "id": 2606024278,
      "user": "akj2018",
      "body": "Hi @sf-dcp,\n\nThis is not a bug in `pd.Series.isnumeric()` but expected behavior.  As per [documentation](https://docs.python.org/3/library/stdtypes.html#str.isnumeric) for `str.isnumeric()`,  . (decimal point) is not a numeric character, so strings with decimal points like \"1.1\" fail the isnumeric() check.\n\n![Image](https://github.com/user-attachments/assets/1c06aeed-8f30-44f3-b513-ebf85627d31f)\n\n`str.isnumeric()` method checks if:\n\n1. All characters in the string are **numeric characters.**\n2. There is at least one character in the string.\n\nNumeric characters are those with the Unicode property values:\n- Numeric_Type=Digit (e.g., \"1\", \"2\", \"3\")\n- Numeric_Type=Decimal (e.g., standard decimal digits like \"1\", \"2\")\n- Numeric_Type=Numeric (e.g., fractions like \"⅕\", Roman numerals, etc.)\n\nTherefore, `.` (decimal character) **does not have the Unicode numeric property**; it's categorized as punctuation.\n\n## Solution 01 - Using regex\n\n```python\nimport re\n\ndef is_numeric(string):\n    pattern = r'^-?\\d+(\\.\\d+)?$'\n    return bool(re.match(pattern, string))\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\"  and \"0.0\".\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n- Does not works for scientific notations, \"1e10\" returns `False`\n\n## Solution 02 - Using `float()`\n\n```python\ndef is_numeric(string):\n    try:\n        float(string)\n        return True\n    except ValueError:\n        return False\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\", \"1e10\" (scientific notation), and \"0.0\"\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n\n## Performance Consideration\n- Regex: Slower due to the regex engine's overhead of parsing and matching patterns.\n- Float-based: Faster, as it directly leverages Python’s built-in C-optimized parsing.\n\n```python \n# Test dataset (mix of numeric and non-numeric strings)\ndata = [\"1\", \"123.45\", \"-987.65\", \"0\", \"abc\", \"123.45.67\"] * 1_000_000\n```\n\n- Regex time: 5.59 seconds\n- Float time: 2.23 seconds"
    },
    {
      "id": 2608025900,
      "user": "sf-dcp",
      "body": "Hi @akj2018, thanks for the prompt reply and suggestions. I think the method name is a bit misleading then where I would expect a string number (with a dot or a negative integer string) to be returned `True`. But I also understand the logic behind it. At a minimum, I would recommend updating the method docs with a note or warning calling out the method's behavior when it comes to decimal numbers and/or negative numbers. Again, thanks for clarifying."
    },
    {
      "id": 2608458161,
      "user": "rhshadrach",
      "body": "Thanks for the report! This mirrors Python behavior:\n\n```python\nprint(\"1.2\".isnumeric())\n# False\n```\n\nThe first line of the docstring states:\n\n> Check whether all characters in each string are numeric.\n\nAre you saying there might be some confusion as to whether `.` is a numeric character?"
    },
    {
      "id": 2611284505,
      "user": "sf-dcp",
      "body": "@rhshadrach, yep, I may be biased here but I can interpret `.` being numeric like in a decimal number :) I believe an explicit message about numeric values other than integers (negative and decimal string values) would be beneficial for at least a portion of `pandas` users.   "
    },
    {
      "id": 2614108361,
      "user": "rhshadrach",
      "body": "I'd be okay with this addition. PRs are welcome!"
    },
    {
      "id": 2614251691,
      "user": "akj2018",
      "body": "take"
    },
    {
      "id": 2618558396,
      "user": "JyotiP24",
      "body": "Hi,\nI'd like to take on this issue and contribute to improving the documentation to explicitly clarify the behavior of pd.Series.str.isnumeric() regarding decimal and negative numbers. I'll ensure the updated docs provide clear examples and explanations for users. Please let me know if there are any additional points you'd like me to cover."
    },
    {
      "id": 2618565430,
      "user": "akj2018",
      "body": "Hi @JyotiP24 ,\nI am currently working on the issue and will be making a PR tomorrow. \nThanks "
    },
    {
      "id": 2628908660,
      "user": "prakhar-bip",
      "body": "what if we try  this code ?\n\n\n```\ndef is_numeric(string):\n    if (string.isnumeric()):\n        return True;\n\n    else:\n        try:\n            float(string)\n            return True;\n        except ValueError:\n            return False\n```"
    },
    {
      "id": 2628943357,
      "user": "arnav1209",
      "body": "I noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?"
    },
    {
      "id": 2629402138,
      "user": "rhshadrach",
      "body": "> Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nNo, pandas' `isnumeic` should match Python's `isnumeric`."
    },
    {
      "id": 2630487098,
      "user": "pranavgudagi",
      "body": "Is this issue still open i want to contribute  to this  issue .Please assign me this issue ."
    },
    {
      "id": 2630503988,
      "user": "akj2018",
      "body": "Hi @pranavgudagi  ,\nI am currently working on the issue.\nThanks"
    },
    {
      "id": 2661179179,
      "user": "WalkingDevFlag",
      "body": "```python\n@forbid_nonstring_types(['bytes'])\ndef isnumeric(self, extended=False):\n    if extended:\n        regex = r'^[+-]?(\\d+([.]\\d*)?([eE][+-]?\\d+)?|[.]\\d+([eE][+-]?\\d+)?)$'\n        return self._data.str.match(regex, na=False)\n    return self._data._str_map(\n        fname=\"isnumeric\", dtype=np.dtype(\"bool\"), na_value=False\n    )\n```\nwould this be a good solution to handling decimal strings?"
    },
    {
      "id": 2661542600,
      "user": "Varun270",
      "body": "@akj2018 Are You still working on this?"
    },
    {
      "id": 2663533994,
      "user": "Anurag-Varma",
      "body": "@arnav1209 \n> I noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nAs mentioned, we should not change the code, this bug is a documentation fixing issue\n\n> No, pandas' `isnumeic` should match Python's `isnumeric`.\n\n"
    },
    {
      "id": 2663538130,
      "user": "Anurag-Varma",
      "body": "Hey @akj2018 \n\nIt's been 2 weeks, can you confirm if you are still working on it or if I can take the issue ?"
    },
    {
      "id": 2663572554,
      "user": "akj2018",
      "body": "Hi @Anurag-Varma,\n\nYes, I am still working on it. Due to health related concerns, I was not able to complete it. I will make a PR today without further delay. \n\nIn future, please me mindful to wait for a while before taking an action. \n\nThanks "
    },
    {
      "id": 2663649666,
      "user": "Anurag-Varma",
      "body": "> Hi [@Anurag-Varma](https://github.com/Anurag-Varma),\n> \n> Yes, I am still working on it. Due to health related concerns, I was not able to complete it. I will make a PR today without further delay.\n> \n> In future, please me mindful to wait for a while before taking an action.\n> \n> Thanks\n\nIt's been 3 weeks since your last update on PR and 2 weeks ago you have mentioned that you are still working. I didn't find any updates on your remote repository in your account related to this issue so I just took it. But if you are still working then you can continue and send a PR."
    },
    {
      "id": 2663685351,
      "user": "akj2018",
      "body": "@Anurag-Varma Yes, because I haven't updated the remote with my local changes. \n\nKindly refer the contribution guide in such situations, which mentions to ask the assigne along with period of inactivity. \n\nhttps://pandas.pydata.org/docs/development/contributing.html#finding-an-issue-to-contribute-to\n\nRest assured that I will making a PR today so there is no further delay. "
    }
  ],
  "text_context": "# BUG: `pd.Series.isnumeric()` doesn't work on decimal value strings\n\n### Pandas version checks\n\n- [x] I have checked that this issue has not already been reported.\n\n- [x] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [x] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\n\ndf = pd.DataFrame({\"string_values\": [\"1\", \"1.0\", \"1.1\"]})\ndf.string_values.str.isnumeric()\n```\n\n### Issue Description\n\nThe series method `.isnumeric()` only works on integer strings. If a string number is decimal, it will return `False`. When running the example below, the following is returned: \n\n<img width=\"609\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/9cdd0a8e-4a74-4e2f-ba07-44914a085b4d\" />\n\nThis is the docs description for the method: \n\n<img width=\"758\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/0c10d350-56af-4699-8fcb-2f20a739e28a\" />\n\n\n### Expected Behavior\n\nRunning the method on decimal strings should return `True`.\n\n### Installed Versions\n\n<details>\n\nINSTALLED VERSIONS\n------------------\ncommit                : 0691c5cf90477d3503834d983f69350f250a6ff7\npython                : 3.12.8\npython-bits           : 64\nOS                    : Linux\nOS-release            : 5.15.49-linuxkit-pr\nVersion               : #1 SMP PREEMPT Thu May 25 07:27:39 UTC 2023\nmachine               : x86_64\nprocessor             : \nbyteorder             : little\nLC_ALL                : None\nLANG                  : C.UTF-8\nLOCALE                : C.UTF-8\n\npandas                : 2.2.3\nnumpy                 : 2.2.1\npytz                  : 2024.2\ndateutil              : 2.9.0.post0\npip                   : 24.3.1\nCython                : None\nsphinx                : None\nIPython               : 8.31.0\nadbc-driver-postgresql: None\nadbc-driver-sqlite    : None\nbs4                   : 4.12.3\nblosc                 : None\nbottleneck            : None\ndataframe-api-compat  : None\nfastparquet           : None\nfsspec                : None\nhtml5lib              : None\nhypothesis            : None\ngcsfs                 : None\njinja2                : 3.1.5\nlxml.etree            : 5.3.0\nmatplotlib            : 3.10.0\nnumba                 : None\nnumexpr               : None\nodfpy                 : None\nopenpyxl              : 3.1.5\npandas_gbq            : None\npsycopg2              : 2.9.10\npymysql               : None\npyarrow               : 18.1.0\npyreadstat            : None\npytest                : 8.3.4\npython-calamine       : None\npyxlsb                : None\ns3fs                  : None\nscipy                 : 1.15.1\nsqlalchemy            : 2.0.37\ntables                : None\ntabulate              : 0.9.0\nxarray                : None\nxlrd                  : 2.0.1\nxlsxwriter            : None\nzstandard             : None\ntzdata                : 2024.2\nqtpy                  : None\npyqt5                 : None\n\n</details>\n\n\nHi @sf-dcp,\n\nThis is not a bug in `pd.Series.isnumeric()` but expected behavior.  As per [documentation](https://docs.python.org/3/library/stdtypes.html#str.isnumeric) for `str.isnumeric()`,  . (decimal point) is not a numeric character, so strings with decimal points like \"1.1\" fail the isnumeric() check.\n\n![Image](https://github.com/user-attachments/assets/1c06aeed-8f30-44f3-b513-ebf85627d31f)\n\n`str.isnumeric()` method checks if:\n\n1. All characters in the string are **numeric characters.**\n2. There is at least one character in the string.\n\nNumeric characters are those with the Unicode property values:\n- Numeric_Type=Digit (e.g., \"1\", \"2\", \"3\")\n- Numeric_Type=Decimal (e.g., standard decimal digits like \"1\", \"2\")\n- Numeric_Type=Numeric (e.g., fractions like \"⅕\", Roman numerals, etc.)\n\nTherefore, `.` (decimal character) **does not have the Unicode numeric property**; it's categorized as punctuation.\n\n## Solution 01 - Using regex\n\n```python\nimport re\n\ndef is_numeric(string):\n    pattern = r'^-?\\d+(\\.\\d+)?$'\n    return bool(re.match(pattern, string))\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\"  and \"0.0\".\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n- Does not works for scientific notations, \"1e10\" returns `False`\n\n## Solution 02 - Using `float()`\n\n```python\ndef is_numeric(string):\n    try:\n        float(string)\n        return True\n    except ValueError:\n        return False\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\", \"1e10\" (scientific notation), and \"0.0\"\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n\n## Performance Consideration\n- Regex: Slower due to the regex engine's overhead of parsing and matching patterns.\n- Float-based: Faster, as it directly leverages Python’s built-in C-optimized parsing.\n\n```python \n# Test dataset (mix of numeric and non-numeric strings)\ndata = [\"1\", \"123.45\", \"-987.65\", \"0\", \"abc\", \"123.45.67\"] * 1_000_000\n```\n\n- Regex time: 5.59 seconds\n- Float time: 2.23 seconds\n\nHi @akj2018, thanks for the prompt reply and suggestions. I think the method name is a bit misleading then where I would expect a string number (with a dot or a negative integer string) to be returned `True`. But I also understand the logic behind it. At a minimum, I would recommend updating the method docs with a note or warning calling out the method's behavior when it comes to decimal numbers and/or negative numbers. Again, thanks for clarifying.\n\nThanks for the report! This mirrors Python behavior:\n\n```python\nprint(\"1.2\".isnumeric())\n# False\n```\n\nThe first line of the docstring states:\n\n> Check whether all characters in each string are numeric.\n\nAre you saying there might be some confusion as to whether `.` is a numeric character?\n\n@rhshadrach, yep, I may be biased here but I can interpret `.` being numeric like in a decimal number :) I believe an explicit message about numeric values other than integers (negative and decimal string values) would be beneficial for at least a portion of `pandas` users.   \n\nI'd be okay with this addition. PRs are welcome!\n\ntake\n\nHi,\nI'd like to take on this issue and contribute to improving the documentation to explicitly clarify the behavior of pd.Series.str.isnumeric() regarding decimal and negative numbers. I'll ensure the updated docs provide clear examples and explanations for users. Please let me know if there are any additional points you'd like me to cover.\n\nHi @JyotiP24 ,\nI am currently working on the issue and will be making a PR tomorrow. \nThanks \n\nwhat if we try  this code ?\n\n\n```\ndef is_numeric(string):\n    if (string.isnumeric()):\n        return True;\n\n    else:\n        try:\n            float(string)\n            return True;\n        except ValueError:\n            return False\n```\n\nI noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\n> Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nNo, pandas' `isnumeic` should match Python's `isnumeric`.\n\nIs this issue still open i want to contribute  to this  issue .Please assign me this issue .\n\nHi @pranavgudagi  ,\nI am currently working on the issue.\nThanks\n\n```python\n@forbid_nonstring_types(['bytes'])\ndef isnumeric(self, extended=False):\n    if extended:\n        regex = r'^[+-]?(\\d+([.]\\d*)?([eE][+-]?\\d+)?|[.]\\d+([eE][+-]?\\d+)?)$'\n        return self._data.str.match(regex, na=False)\n    return self._data._str_map(\n        fname=\"isnumeric\", dtype=np.dtype(\"bool\"), na_value=False\n    )\n```\nwould this be a good solution to handling decimal strings?\n\n@akj2018 Are You still working on this?\n\n@arnav1209 \n> I noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nAs mentioned, we should not change the code, this bug is a documentation fixing issue\n\n> No, pandas' `isnumeic` should match Python's `isnumeric`.\n\n\n\nHey @akj2018 \n\nIt's been 2 weeks, can you confirm if you are still working on it or if I can take the issue ?\n\nHi @Anurag-Varma,\n\nYes, I am still working on it. Due to health related concerns, I was not able to complete it. I will make a PR today without further delay. \n\nIn future, please me mindful to wait for a while before taking an action. \n\nThanks \n\n> Hi [@Anurag-Varma](https://github.com/Anurag-Varma),\n> \n> Yes, I am still working on it. Due to health related concerns, I was not able to complete it. I will make a PR today without further delay.\n> \n> In future, please me mindful to wait for a while before taking an action.\n> \n> Thanks\n\nIt's been 3 weeks since your last update on PR and 2 weeks ago you have mentioned that you are still working. I didn't find any updates on your remote repository in your account related to this issue so I just took it. But if you are still working then you can continue and send a PR.\n\n@Anurag-Varma Yes, because I haven't updated the remote with my local changes. \n\nKindly refer the contribution guide in such situations, which mentions to ask the assigne along with period of inactivity. \n\nhttps://pandas.pydata.org/docs/development/contributing.html#finding-an-issue-to-contribute-to\n\nRest assured that I will making a PR today so there is no further delay. ",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/60960",
  "code_context": [
    {
      "filename": "pandas/core/strings/accessor.py",
      "content": "from __future__ import annotations\n\nimport codecs\nfrom functools import wraps\nimport re\nfrom typing import (\n    TYPE_CHECKING,\n    Literal,\n    cast,\n)\nimport warnings\n\nimport numpy as np\n\nfrom pandas._config import get_option\n\nfrom pandas._libs import lib\nfrom pandas._typing import (\n    AlignJoin,\n    DtypeObj,\n    F,\n    Scalar,\n    npt,\n)\nfrom pandas.util._decorators import Appender\nfrom pandas.util._exceptions import find_stack_level\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_extension_array_dtype,\n    is_integer,\n    is_list_like,\n    is_numeric_dtype,\n    is_object_dtype,\n    is_re,\n    is_string_dtype,\n)\nfrom pandas.core.dtypes.dtypes import (\n    ArrowDtype,\n    CategoricalDtype,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndex,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.core.construction import extract_array\n\nif TYPE_CHECKING:\n    from collections.abc import (\n        Callable,\n        Hashable,\n        Iterator,\n    )\n\n    from pandas._typing import NpDtype\n\n    from pandas import (\n        DataFrame,\n        Index,\n        Series,\n    )\n\n_shared_docs: dict[str, str] = {}\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n\ndef forbid_nonstring_types(\n    forbidden: list[str] | None, name: str | None = None\n) -> Callable[[F], F]:\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func: F) -> F:\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    f\"Cannot use .str.{func_name} with values of \"\n                    f\"inferred dtype '{self._inferred_dtype}'.\"\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return cast(F, wrapper)\n\n    return _forbid_nonstring_types\n\n\ndef _map_and_wrap(name: str | None, docstring: str | None):\n    @forbid_nonstring_types([\"bytes\"], name=name)\n    def wrapper(self):\n        result = getattr(self._data.array, f\"_str_{name}\")()\n        return self._wrap_result(\n            result, returns_string=name not in (\"isnumeric\", \"isdecimal\")\n        )\n\n    wrapper.__doc__ = docstring\n    return wrapper\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index.\n\n    NAs stay NA unless handled otherwise by a particular method.\n    Patterned after Python's string methods, with some inspiration from\n    R's stringr package.\n\n    Parameters\n    ----------\n    data : Series or Index\n        The content of the Series or Index.\n\n    See Also\n    --------\n    Series.str : Vectorized string functions for Series.\n    Index.str : Vectorized string functions for Index.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"A_Str_Series\"])\n    >>> s\n    0    A_Str_Series\n    dtype: object\n\n    >>> s.str.split(\"_\")\n    0    [A, Str, Series]\n    dtype: object\n\n    >>> s.str.replace(\"_\", \"\")\n    0    AStrSeries\n    dtype: object\n    \"\"\"\n\n    # Note: see the docstring in pandas.core.strings.__init__\n    # for an explanation of the implementation.\n    # TODO: Dispatch all the methods\n    # Currently the following are not dispatched to the array\n    # * cat\n    # * extractall\n\n    def __init__(self, data) -> None:\n        from pandas.core.arrays.string_ import StringDtype\n\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = isinstance(data.dtype, CategoricalDtype)\n        self._is_string = isinstance(data.dtype, StringDtype)\n        self._data = data\n\n        self._index = self._name = None\n        if isinstance(data, ABCSeries):\n            self._index = data.index\n            self._name = data.name\n\n        # ._values.categories works for both Series/Index\n        self._parent = data._values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object, and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        data = extract_array(data)\n\n        values = getattr(data, \"categories\", data)  # categorical / normal\n\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\n                f\"Can only use .str accessor with string values, not {inferred_dtype}\"\n            )\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        result = self._data.array._str_getitem(key)\n        return self._wrap_result(result)\n\n    def __iter__(self) -> Iterator:\n        raise TypeError(f\"'{type(self).__name__}' object is not iterable\")\n\n    def _wrap_result(\n        self,\n        result,\n        name=None,\n        expand: bool | None = None,\n        fill_value=np.nan,\n        returns_string: bool = True,\n        dtype=None,\n    ):\n        from pandas import (\n            Index,\n            MultiIndex,\n        )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            if isinstance(result, ABCDataFrame):\n                result = result.__finalize__(self._orig, name=\"str\")\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        # Ideally the array method returns the right array type.\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n        elif expand is True and not isinstance(self._orig, ABCIndex):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n            if isinstance(result.dtype, ArrowDtype):\n                import pyarrow as pa\n\n                from pandas.compat import pa_version_under11p0\n\n                from pandas.core.arrays.arrow.array import ArrowExtensionArray\n\n                value_lengths = pa.compute.list_value_length(result._pa_array)\n                max_len = pa.compute.max(value_lengths).as_py()\n                min_len = pa.compute.min(value_lengths).as_py()\n                if result._hasna:\n                    # ArrowExtensionArray.fillna doesn't work for list scalars\n                    result = ArrowExtensionArray(\n                        result._pa_array.fill_null([None] * max_len)\n                    )\n                if min_len < max_len:\n                    # append nulls to each scalar list element up to max_len\n                    if not pa_version_under11p0:\n                        result = ArrowExtensionArray(\n                            pa.compute.list_slice(\n                                result._pa_array,\n                                start=0,\n                                stop=max_len,\n                                return_fixed_size_list=True,\n                            )\n                        )\n                    else:\n                        all_null = np.full(max_len, fill_value=None, dtype=object)\n                        values = result.to_numpy()\n                        new_values = []\n                        for row in values:\n                            if len(row) < max_len:\n                                nulls = all_null[: max_len - len(row)]\n                                row = np.append(row, nulls)\n                            new_values.append(row)\n                        pa_type = result._pa_array.type\n                        result = ArrowExtensionArray(pa.array(new_values, type=pa_type))\n                if name is None:\n                    name = range(max_len)\n                result = (\n                    pa.compute.list_flatten(result._pa_array)\n                    .to_numpy()\n                    .reshape(len(result), max_len)\n                )\n                result = {\n                    label: ArrowExtensionArray(pa.array(res))\n                    for label, res in zip(name, result.T)\n                }\n            elif is_object_dtype(result):\n\n                def cons_row(x):\n                    if is_list_like(x):\n                        return x\n                    else:\n                        return [x]\n\n                result = [cons_row(x) for x in result]\n                if result and not self._is_string:\n                    # propagate nan values to match longest sequence (GH 18450)\n                    max_len = max(len(x) for x in result)\n                    result = [\n                        x * max_len if len(x) == 0 or x[0] is np.nan else x\n                        for x in result\n                    ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndex):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out: Index = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name, dtype=dtype)\n        else:\n            index = self._orig.index\n            # This is a mess.\n            _dtype: DtypeObj | str | None = dtype\n            vdtype = getattr(result, \"dtype\", None)\n            if _dtype is not None:\n                pass\n            elif self._is_string:\n                if is_bool_dtype(vdtype):\n                    _dtype = result.dtype\n                elif returns_string:\n                    _dtype = self._orig.dtype\n                else:\n                    _dtype = vdtype\n            elif vdtype is not None:\n                _dtype = vdtype\n\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=_dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index, dtype=_dtype)\n            result = result.__finalize__(self._orig, method=\"str\")\n            if name is not None and result.ndim == 1:\n                # __finalize__ might copy over the original name, but we may\n                # want the new name (e.g. str.extract).\n                result.name = name\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n        from pandas import (\n            DataFrame,\n            Series,\n        )\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndex) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndex):\n            return [Series(others, index=idx, dtype=others.dtype)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            try:\n                others = list(others)  # ensure iterators do not get read twice etc\n            except TypeError:\n                # e.g. ser.str, raise below\n                pass\n            else:\n                # in case of list-like `others`, all elements must be\n                # either Series/Index/np.ndarray (1-dim)...\n                if all(\n                    isinstance(x, (ABCSeries, ABCIndex, ExtensionArray))\n                    or (isinstance(x, np.ndarray) and x.ndim == 1)\n                    for x in others\n                ):\n                    los: list[Series] = []\n                    while others:  # iterate through list and append each element\n                        los = los + self._get_series_list(others.pop(0))\n                    return los\n                # ... or just strings\n                elif all(not is_list_like(x) for x in others):\n                    return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarray \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(\n        self,\n        others=None,\n        sep: str | None = None,\n        na_rep=None,\n        join: AlignJoin = \"left\",\n    ) -> str | Series | Index:\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series([\"a\", \"b\", np.nan, \"d\"])\n        >>> s.str.cat(sep=\" \")\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=\" \", na_rep=\"?\")\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat([\"A\", \"B\", \"C\", \"D\"], sep=\",\")\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat([\"A\", \"B\", \"C\", \"D\"], sep=\",\", na_rep=\"-\")\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat([\"A\", \"B\", \"C\", \"D\"], na_rep=\"-\")\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series([\"d\", \"a\", \"e\", \"c\"], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=\"left\", na_rep=\"-\")\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join=\"outer\", na_rep=\"-\")\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join=\"inner\", na_rep=\"-\")\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join=\"right\", na_rep=\"-\")\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        # TODO: dispatch\n        from pandas import (\n            Index,\n            Series,\n            concat,\n        )\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndex):\n            data = Series(self._orig, index=self._orig, dtype=self._orig.dtype)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            # error: Incompatible types in assignment (expression has type\n            # \"ndarray\", variable has type \"Series\")\n            data = ensure_object(data)  # type: ignore[assignment]\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                return sep.join(data[~na_mask])\n            elif na_rep is not None and na_mask.any():\n                return sep.join(np.where(na_mask, na_rep, data))\n            else:\n                return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError as err:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            ) from err\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        out: Index | Series\n        if isinstance(self._orig.dtype, CategoricalDtype):\n            # We need to infer the new categories.\n            dtype = self._orig.dtype.categories.dtype\n        else:\n            dtype = self._orig.dtype\n        if isinstance(self._orig, ABCIndex):\n            # add dtype for case that result is all-NA\n            if isna(result).all():\n                dtype = object  # type: ignore[assignment]\n\n            out = Index(result, dtype=dtype, name=self._orig.name)\n        else:  # Series\n            res_ser = Series(\n                result, dtype=dtype, index=data.index, name=self._orig.name, copy=False\n            )\n            out = res_ser.__finalize__(self._orig, method=\"str_cat\")\n        return out\n\n    _shared_docs[\"str_split\"] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string.\n\n    Parameters\n    ----------\n    pat : str%(pat_regex)s, optional\n        %(pat_description)s.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the split strings into separate columns.\n\n        - If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        - If ``False``, return Series/Index, containing lists of strings.\n    %(regex_argument)s\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n    %(raises_split)s\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n    %(regex_pat_note)s\n    Examples\n    --------\n    >>> s = pd.Series(\n    ...     [\n    ...         \"this is a regular sentence\",\n    ...         \"https://docs.python.org/3/tutorial/index.html\",\n    ...         np.nan\n    ...     ]\n    ... )\n    >>> s\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat=\"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3         4\n    0                                           this    is     a  regular  sentence\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None      None\n    2                                            NaN   NaN   NaN      NaN       NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n    %(regex_examples)s\"\"\"\n\n    @Appender(\n        _shared_docs[\"str_split\"]\n        % {\n            \"side\": \"beginning\",\n            \"pat_regex\": \" or compiled regex\",\n            \"pat_description\": \"String or regular expression to split on\",\n            \"regex_argument\": \"\"\"\n    regex : bool, default None\n        Determines if the passed-in pattern is a regular expression:\n\n        - If ``True``, assumes the passed-in pattern is a regular expression\n        - If ``False``, treats the pattern as a literal string.\n        - If ``None`` and `pat` length is 1, treats `pat` as a literal string.\n        - If ``None`` and `pat` length is not 1, treats `pat` as a regular expression.\n        - Cannot be set to False if `pat` is a compiled regex\n\n        .. versionadded:: 1.4.0\n         \"\"\",\n            \"raises_split\": \"\"\"\n                      Raises\n                      ------\n                      ValueError\n                          * if `regex` is False and `pat` is a compiled regex\n                      \"\"\",\n            \"regex_pat_note\": \"\"\"\n    Use of `regex =False` with a `pat` as a compiled regex will raise an error.\n            \"\"\",\n            \"method\": \"split\",\n            \"regex_examples\": r\"\"\"\n    Remember to escape special characters when explicitly using regular expressions.\n\n    >>> s = pd.Series([\"foo and bar plus baz\"])\n    >>> s.str.split(r\"and|plus\", expand=True)\n        0   1   2\n    0 foo bar baz\n\n    Regular expressions can be used to handle urls or file names.\n    When `pat` is a string and ``regex=None`` (the default), the given `pat` is compiled\n    as a regex only if ``len(pat) != 1``.\n\n    >>> s = pd.Series(['foojpgbar.jpg'])\n    >>> s.str.split(r\".\", expand=True)\n               0    1\n    0  foojpgbar  jpg\n\n    >>> s.str.split(r\"\\.jpg\", expand=True)\n               0 1\n    0  foojpgbar\n\n    When ``regex=True``, `pat` is interpreted as a regex\n\n    >>> s.str.split(r\"\\.jpg\", regex=True, expand=True)\n               0 1\n    0  foojpgbar\n\n    A compiled regex can be passed as `pat`\n\n    >>> import re\n    >>> s.str.split(re.compile(r\"\\.jpg\"), expand=True)\n               0 1\n    0  foojpgbar\n\n    When ``regex=False``, `pat` is interpreted as the string itself\n\n    >>> s.str.split(r\"\\.jpg\", regex=False, expand=True)\n                   0\n    0  foojpgbar.jpg\n    \"\"\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def split(\n        self,\n        pat: str | re.Pattern | None = None,\n        *,\n        n=-1,\n        expand: bool = False,\n        regex: bool | None = None,\n    ):\n        if regex is False and is_re(pat):\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if is_re(pat):\n            regex = True\n        result = self._data.array._str_split(pat, n, expand, regex)\n        if self._data.dtype == \"category\":\n            dtype = self._data.dtype.categories.dtype\n        else:\n            dtype = object if self._data.dtype == object else None\n        return self._wrap_result(\n            result, expand=expand, returns_string=expand, dtype=dtype\n        )\n\n    @Appender(\n        _shared_docs[\"str_split\"]\n        % {\n            \"side\": \"end\",\n            \"pat_regex\": \"\",\n            \"pat_description\": \"String to split on\",\n            \"regex_argument\": \"\",\n            \"raises_split\": \"\",\n            \"regex_pat_note\": \"\",\n            \"method\": \"rsplit\",\n            \"regex_examples\": \"\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, *, n=-1, expand: bool = False):\n        result = self._data.array._str_rsplit(pat, n=n)\n        dtype = object if self._data.dtype == object else None\n        return self._wrap_result(\n            result, expand=expand, returns_string=expand, dtype=dtype\n        )\n\n    _shared_docs[\"str_partition\"] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n        Returns appropriate type based on `expand` parameter with strings\n        split based on the `sep` parameter.\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               )\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep: str = \" \", expand: bool = True):\n        result = self._data.array._str_partition(sep, expand)\n        if self._data.dtype == \"category\":\n            dtype = self._data.dtype.categories.dtype\n        else:\n            dtype = object if self._data.dtype == object else None\n        return self._wrap_result(\n            result, expand=expand, returns_string=expand, dtype=dtype\n        )\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep: str = \" \", expand: bool = True):\n        result = self._data.array._str_rpartition(sep, expand)\n        if self._data.dtype == \"category\":\n            dtype = self._data.dtype.categories.dtype\n        else:\n            dtype = object if self._data.dtype == object else None\n        return self._wrap_result(\n            result, expand=expand, returns_string=expand, dtype=dtype\n        )\n\n    def get(self, i):\n        \"\"\"\n        Extract element from each component at specified position or with specified key.\n\n        Extract element from lists, tuples, dict, or strings in each element in the\n        Series/Index.\n\n        Parameters\n        ----------\n        i : int or hashable dict label\n            Position or key of element to extract.\n\n        Returns\n        -------\n        Series or Index\n            Series or Index where each value is the extracted element from\n            the corresponding input component.\n\n        See Also\n        --------\n        Series.str.extract : Extract capture groups in the regex as columns\n            in a DataFrame.\n\n        Examples\n        --------\n        >>> s = pd.Series(\n        ...     [\n        ...         \"String\",\n        ...         (1, 2, 3),\n        ...         [\"a\", \"b\", \"c\"],\n        ...         123,\n        ...         -456,\n        ...         {1: \"Hello\", \"2\": \"World\"},\n        ...     ]\n        ... )\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.get(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.get(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n\n        Return element with given key\n\n        >>> s = pd.Series(\n        ...     [\n        ...         {\"name\": \"Hello\", \"value\": \"World\"},\n        ...         {\"name\": \"Goodbye\", \"value\": \"Planet\"},\n        ...     ]\n        ... )\n        >>> s.str.get(\"name\")\n        0      Hello\n        1    Goodbye\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_get(i)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep: str):\n        \"\"\"\n        Join lists contained as elements in the Series/Index with passed delimiter.\n\n        If the elements of a Series are lists themselves, join the content of these\n        lists using the delimiter passed to the function.\n        This function is an equivalent to :meth:`str.join`.\n\n        Parameters\n        ----------\n        sep : str\n            Delimiter to use between list entries.\n\n        Returns\n        -------\n        Series/Index: object\n            The list entries concatenated by intervening occurrences of the\n            delimiter.\n\n        Raises\n        ------\n        AttributeError\n            If the supplied Series contains neither strings nor lists.\n\n        See Also\n        --------\n        str.join : Standard library version of this method.\n        Series.str.split : Split strings around given separator/delimiter.\n\n        Notes\n        -----\n        If any of the list items is not a string object, the result of the join\n        will be `NaN`.\n\n        Examples\n        --------\n        Example with a list that contains non-string elements.\n\n        >>> s = pd.Series(\n        ...     [\n        ...         [\"lion\", \"elephant\", \"zebra\"],\n        ...         [1.1, 2.2, 3.3],\n        ...         [\"cat\", np.nan, \"dog\"],\n        ...         [\"cow\", 4.5, \"goat\"],\n        ...         [\"duck\", [\"swan\", \"fish\"], \"guppy\"],\n        ...     ]\n        ... )\n        >>> s\n        0        [lion, elephant, zebra]\n        1                [1.1, 2.2, 3.3]\n        2                [cat, nan, dog]\n        3               [cow, 4.5, goat]\n        4    [duck, [swan, fish], guppy]\n        dtype: object\n\n        Join all lists using a '-'. The lists containing object(s) of types other\n        than str will produce a NaN.\n\n        >>> s.str.join(\"-\")\n        0    lion-elephant-zebra\n        1                    NaN\n        2                    NaN\n        3                    NaN\n        4                    NaN\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_join(sep)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(\n        self,\n        pat,\n        case: bool = True,\n        flags: int = 0,\n        na=lib.no_default,\n        regex: bool = True,\n    ):\n        r\"\"\"\n        Test if pattern or regex is contained within a string of a Series or Index.\n\n        Return boolean Series or Index based on whether a given pattern or regex is\n        contained within a string of a Series or Index.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence or regular expression.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Flags to pass through to the re module, e.g. re.IGNORECASE.\n        na : scalar, optional\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For the nullable\n            ``StringDtype``, ``pandas.NA`` is used. For the ``\"str\"`` dtype,\n            ``False`` is used.\n        regex : bool, default True\n            If True, assumes the pat is a regular expression.\n\n            If False, treats the pat as a literal string.\n\n        Returns\n        -------\n        Series or Index of boolean values\n            A Series or Index of boolean values indicating whether the\n            given pattern is contained within the string of each element\n            of the Series or Index.\n\n        See Also\n        --------\n        match : Analogous, but stricter, relying on re.match instead of re.search.\n        Series.str.startswith : Test if the start of each string element matches a\n            pattern.\n        Series.str.endswith : Same as startswith, but tests the end of string.\n\n        Examples\n        --------\n        Returning a Series of booleans using only a literal pattern.\n\n        >>> s1 = pd.Series([\"Mouse\", \"dog\", \"house and parrot\", \"23\", np.nan])\n        >>> s1.str.contains(\"og\", regex=False)\n        0    False\n        1     True\n        2    False\n        3    False\n        4      NaN\n        dtype: object\n\n        Returning an Index of booleans using only a literal pattern.\n\n        >>> ind = pd.Index([\"Mouse\", \"dog\", \"house and parrot\", \"23.0\", np.nan])\n        >>> ind.str.contains(\"23\", regex=False)\n        Index([False, False, False, True, nan], dtype='object')\n\n        Specifying case sensitivity using `case`.\n\n        >>> s1.str.contains(\"oG\", case=True, regex=True)\n        0    False\n        1    False\n        2    False\n        3    False\n        4      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN` replaces NaN values\n        with `False`. If Series or Index does not contain NaN values\n        the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n        >>> s1.str.contains(\"og\", na=False, regex=True)\n        0    False\n        1     True\n        2    False\n        3    False\n        4    False\n        dtype: bool\n\n        Returning 'house' or 'dog' when either expression occurs in a string.\n\n        >>> s1.str.contains(\"house|dog\", regex=True)\n        0    False\n        1     True\n        2     True\n        3    False\n        4      NaN\n        dtype: object\n\n        Ignoring case sensitivity using `flags` with regex.\n\n        >>> import re\n        >>> s1.str.contains(\"PARROT\", flags=re.IGNORECASE, regex=True)\n        0    False\n        1    False\n        2     True\n        3    False\n        4      NaN\n        dtype: object\n\n        Returning any digit using regular expression.\n\n        >>> s1.str.contains(\"\\\\d\", regex=True)\n        0    False\n        1    False\n        2    False\n        3     True\n        4      NaN\n        dtype: object\n\n        Ensure `pat` is a not a literal pattern when `regex` is set to True.\n        Note in the following example one might expect only `s2[1]` and `s2[3]` to\n        return `True`. However, '.0' as a regex matches any character\n        followed by a 0.\n\n        >>> s2 = pd.Series([\"40\", \"40.0\", \"41\", \"41.0\", \"35\"])\n        >>> s2.str.contains(\".0\", regex=True)\n        0     True\n        1     True\n        2    False\n        3     True\n        4    False\n        dtype: bool\n        \"\"\"\n        if regex and re.compile(pat).groups:\n            warnings.warn(\n                \"This pattern is interpreted as a regular expression, and has \"\n                \"match groups. To actually get the groups, use str.extract.\",\n                UserWarning,\n                stacklevel=find_stack_level(),\n            )\n\n        result = self._data.array._str_contains(pat, case, flags, na, regex)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat: str, case: bool = True, flags: int = 0, na=lib.no_default):\n        \"\"\"\n        Determine if each string starts with a match of a regular expression.\n\n        Determines whether each string in the Series or Index starts with a\n        match to a specified regular expression. This function is especially\n        useful for validating prefixes, such as ensuring that codes, tags, or\n        identifiers begin with a specific pattern.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE.\n        na : scalar, optional\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For the nullable\n            ``StringDtype``, ``pandas.NA`` is used. For the ``\"str\"`` dtype,\n            ``False`` is used.\n\n        Returns\n        -------\n        Series/Index/array of boolean values\n            A Series, Index, or array of boolean values indicating whether the start\n            of each string matches the pattern. The result will be of the same type\n            as the input.\n\n        See Also\n        --------\n        fullmatch : Stricter matching that requires the entire string to match.\n        contains : Analogous, but less strict, relying on re.search instead of\n            re.match.\n        extract : Extract matched groups.\n\n        Examples\n        --------\n        >>> ser = pd.Series([\"horse\", \"eagle\", \"donkey\"])\n        >>> ser.str.match(\"e\")\n        0   False\n        1   True\n        2   False\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_match(pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def fullmatch(self, pat, case: bool = True, flags: int = 0, na=lib.no_default):\n        \"\"\"\n        Determine if each string entirely matches a regular expression.\n\n        Checks if each string in the Series or Index fully matches the\n        specified regular expression pattern. This function is useful when the\n        requirement is for an entire string to conform to a pattern, such as\n        validating formats like phone numbers or email addresses.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence or regular expression.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE.\n        na : scalar, optional\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For the nullable\n            ``StringDtype``, ``pandas.NA`` is used. For the ``\"str\"`` dtype,\n            ``False`` is used.\n\n        Returns\n        -------\n        Series/Index/array of boolean values\n            The function returns a Series, Index, or array of boolean values,\n            where True indicates that the entire string matches the regular\n            expression pattern and False indicates that it does not.\n\n        See Also\n        --------\n        match : Similar, but also returns `True` when only a *prefix* of the string\n            matches the regular expression.\n        extract : Extract matched groups.\n\n        Examples\n        --------\n        >>> ser = pd.Series([\"cat\", \"duck\", \"dove\"])\n        >>> ser.str.fullmatch(r\"d.+\")\n        0   False\n        1    True\n        2    True\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_fullmatch(pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(\n        self,\n        pat: str | re.Pattern | dict,\n        repl: str | Callable | None = None,\n        n: int = -1,\n        case: bool | None = None,\n        flags: int = 0,\n        regex: bool = False,\n    ):\n        r\"\"\"\n        Replace each occurrence of pattern/regex in the Series/Index.\n\n        Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on\n        the regex value.\n\n        Parameters\n        ----------\n        pat : str, compiled regex, or a dict\n            String can be a character sequence or regular expression.\n            Dictionary contains <key : value> pairs of strings to be replaced\n            along with the updated value.\n        repl : str or callable\n            Replacement string or a callable. The callable is passed the regex\n            match object and must return a replacement string to be used.\n            Must have a value of None if `pat` is a dict\n            See :func:`re.sub`.\n        n : int, default -1 (all)\n            Number of replacements to make from start.\n        case : bool, default None\n            Determines if replace is case sensitive:\n\n            - If True, case sensitive (the default if `pat` is a string)\n            - Set to False for case insensitive\n            - Cannot be set if `pat` is a compiled regex.\n\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n            regex.\n        regex : bool, default False\n            Determines if the passed-in pattern is a regular expression:\n\n            - If True, assumes the passed-in pattern is a regular expression.\n            - If False, treats the pattern as a literal string\n            - Cannot be set to False if `pat` is a compiled regex or `repl` is\n              a callable.\n\n        Returns\n        -------\n        Series or Index of object\n            A copy of the object with all matching occurrences of `pat` replaced by\n            `repl`.\n\n        Raises\n        ------\n        ValueError\n            * if `regex` is False and `repl` is a callable or `pat` is a compiled\n              regex\n            * if `pat` is a compiled regex and `case` or `flags` is set\n            * if `pat` is a dictionary and `repl` is not None.\n\n        See Also\n        --------\n        Series.str.replace : Method to replace occurrences of a substring with another\n            substring.\n        Series.str.extract : Extract substrings using a regular expression.\n        Series.str.findall : Find all occurrences of a pattern or regex in each string.\n        Series.str.split : Split each string by a specified delimiter or pattern.\n\n        Notes\n        -----\n        When `pat` is a compiled regex, all flags should be included in the\n        compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n        regex will raise an error.\n\n        Examples\n        --------\n        When `pat` is a dictionary, every key in `pat` is replaced\n        with its corresponding value:\n\n        >>> pd.Series([\"A\", \"B\", np.nan]).str.replace(pat={\"A\": \"a\", \"B\": \"b\"})\n        0    a\n        1    b\n        2    NaN\n        dtype: object\n\n        When `pat` is a string and `regex` is True, the given `pat`\n        is compiled as a regex. When `repl` is a string, it replaces matching\n        regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n        left as is:\n\n        >>> pd.Series([\"foo\", \"fuz\", np.nan]).str.replace(\"f.\", \"ba\", regex=True)\n        0    bao\n        1    baz\n        2    NaN\n        dtype: object\n\n        When `pat` is a string and `regex` is False, every `pat` is replaced with\n        `repl` as with :meth:`str.replace`:\n\n        >>> pd.Series([\"f.o\", \"fuz\", np.nan]).str.replace(\"f.\", \"ba\", regex=False)\n        0    bao\n        1    fuz\n        2    NaN\n        dtype: object\n\n        When `repl` is a callable, it is called on every `pat` using\n        :func:`re.sub`. The callable should expect one positional argument\n        (a regex object) and return a string.\n\n        To get the idea:\n\n        >>> pd.Series([\"foo\", \"fuz\", np.nan]).str.replace(\"f\", repr, regex=True)\n        0    <re.Match object; span=(0, 1), match='f'>oo\n        1    <re.Match object; span=(0, 1), match='f'>uz\n        2                                            NaN\n        dtype: object\n\n        Reverse every lowercase alphabetic word:\n\n        >>> repl = lambda m: m.group(0)[::-1]\n        >>> ser = pd.Series([\"foo 123\", \"bar baz\", np.nan])\n        >>> ser.str.replace(r\"[a-z]+\", repl, regex=True)\n        0    oof 123\n        1    rab zab\n        2        NaN\n        dtype: object\n\n        Using regex groups (extract second group and swap case):\n\n        >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n        >>> repl = lambda m: m.group(\"two\").swapcase()\n        >>> ser = pd.Series([\"One Two Three\", \"Foo Bar Baz\"])\n        >>> ser.str.replace(pat, repl, regex=True)\n        0    tWO\n        1    bAR\n        dtype: object\n\n        Using a compiled regex with flags\n\n        >>> import re\n        >>> regex_pat = re.compile(r\"FUZ\", flags=re.IGNORECASE)\n        >>> pd.Series([\"foo\", \"fuz\", np.nan]).str.replace(regex_pat, \"bar\", regex=True)\n        0    foo\n        1    bar\n        2    NaN\n        dtype: object\n        \"\"\"\n        if isinstance(pat, dict) and repl is not None:\n            raise ValueError(\"repl cannot be used when pat is a dictionary\")\n\n        # Check whether repl is valid (GH 13438, GH 15055)\n        if not isinstance(pat, dict) and not (isinstance(repl, str) or callable(repl)):\n            raise TypeError(\"repl must be a string or callable\")\n\n        is_compiled_re = is_re(pat)\n        if regex or regex is None:\n            if is_compiled_re and (case is not None or flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n\n        elif is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        elif callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n\n        if case is None:\n            case = True\n\n        res_output = self._data\n        if not isinstance(pat, dict):\n            pat = {pat: repl}\n\n        for key, value in pat.items():\n            result = res_output.array._str_replace(\n                key, value, n=n, case=case, flags=flags, regex=regex\n            )\n            res_output = self._wrap_result(result)\n\n        return res_output\n\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        \"\"\"\n        Duplicate each string in the Series or Index.\n\n        Duplicates each string in the Series or Index, either by applying the\n        same repeat count to all elements or by using different repeat values\n        for each element.\n\n        Parameters\n        ----------\n        repeats : int or sequence of int\n            Same value for all (int) or different value per (sequence).\n\n        Returns\n        -------\n        Series or pandas.Index\n            Series or Index of repeated string objects specified by\n            input parameter repeats.\n\n        See Also\n        --------\n        Series.str.lower : Convert all characters in each string to lowercase.\n        Series.str.upper : Convert all characters in each string to uppercase.\n        Series.str.title : Convert each string to title case (capitalizing the first\n            letter of each word).\n        Series.str.strip : Remove leading and trailing whitespace from each string.\n        Series.str.replace : Replace occurrences of a substring with another substring\n            in each string.\n        Series.str.ljust : Left-justify each string in the Series/Index by padding with\n            a specified character.\n        Series.str.rjust : Right-justify each string in the Series/Index by padding with\n            a specified character.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"a\", \"b\", \"c\"])\n        >>> s\n        0    a\n        1    b\n        2    c\n        dtype: object\n\n        Single int repeats string in Series\n\n        >>> s.str.repeat(repeats=2)\n        0    aa\n        1    bb\n        2    cc\n        dtype: object\n\n        Sequence of int repeats corresponding string in Series\n\n        >>> s.str.repeat(repeats=[1, 2, 3])\n        0      a\n        1     bb\n        2    ccc\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_repeat(repeats)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(\n        self,\n        width: int,\n        side: Literal[\"left\", \"right\", \"both\"] = \"left\",\n        fillchar: str = \" \",\n    ):\n        \"\"\"\n        Pad strings in the Series/Index up to width.\n\n        This function pads strings in a Series or Index to a specified width,\n        filling the extra space with a character of your choice. It provides\n        flexibility in positioning the padding, allowing it to be added to the\n        left, right, or both sides. This is useful for formatting strings to\n        align text or ensure consistent string lengths in data processing.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be filled\n            with character defined in `fillchar`.\n        side : {'left', 'right', 'both'}, default 'left'\n            Side from which to fill resulting string.\n        fillchar : str, default ' '\n            Additional character for filling, default is whitespace.\n\n        Returns\n        -------\n        Series or Index of object\n            Returns Series or Index with minimum number of char in object.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='left')``.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='right')``.\n        Series.str.center : Fills both sides of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='both')``.\n        Series.str.zfill : Pad strings in the Series/Index by prepending '0'\n            character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"caribou\", \"tiger\"])\n        >>> s\n        0    caribou\n        1      tiger\n        dtype: object\n\n        >>> s.str.pad(width=10)\n        0       caribou\n        1         tiger\n        dtype: object\n\n        >>> s.str.pad(width=10, side=\"right\", fillchar=\"-\")\n        0    caribou---\n        1    tiger-----\n        dtype: object\n\n        >>> s.str.pad(width=10, side=\"both\", fillchar=\"-\")\n        0    -caribou--\n        1    --tiger---\n        dtype: object\n        \"\"\"\n        if not isinstance(fillchar, str):\n            msg = f\"fillchar must be a character, not {type(fillchar).__name__}\"\n            raise TypeError(msg)\n\n        if len(fillchar) != 1:\n            raise TypeError(\"fillchar must be a character, not str\")\n\n        if not is_integer(width):\n            msg = f\"width must be of integer type, not {type(width).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_pad(width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\"str_pad\"] = \"\"\"\n    Pad %(side)s side of strings in the Series/Index.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``.\n    fillchar : str\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series/Index of objects.\n        A Series or Index where the strings are modified by :meth:`str.%(method)s`.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character.\n    Series.str.center : Fills both sides of strings with an arbitrary\n        character.\n    Series.str.zfill : Pad strings in the Series/Index by prepending '0'\n        character.\n\n    Examples\n    --------\n    For Series.str.center:\n\n    >>> ser = pd.Series(['dog', 'bird', 'mouse'])\n    >>> ser.str.center(8, fillchar='.')\n    0   ..dog...\n    1   ..bird..\n    2   .mouse..\n    dtype: object\n\n    For Series.str.ljust:\n\n    >>> ser = pd.Series(['dog', 'bird', 'mouse'])\n    >>> ser.str.ljust(8, fillchar='.')\n    0   dog.....\n    1   bird....\n    2   mouse...\n    dtype: object\n\n    For Series.str.rjust:\n\n    >>> ser = pd.Series(['dog', 'bird', 'mouse'])\n    >>> ser.str.rjust(8, fillchar='.')\n    0   .....dog\n    1   ....bird\n    2   ...mouse\n    dtype: object\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"left and right\", \"method\": \"center\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width: int, fillchar: str = \" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"right\", \"method\": \"ljust\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width: int, fillchar: str = \" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"left\", \"method\": \"rjust\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width: int, fillchar: str = \" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width: int):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects.\n            A Series or Index where the strings are prepended with '0' characters.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills both sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"-1\", \"1\", \"1000\", 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        special character and the zero is added to the right of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     -01\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        if not is_integer(width):\n            msg = f\"width must be of integer type, not {type(width).__name__}\"\n            raise TypeError(msg)\n        f = lambda x: x.zfill(width)\n        result = self._data.array._str_map(f)\n        return self._wrap_result(result)\n\n    def slice(self, start=None, stop=None, step=None):\n        \"\"\"\n        Slice substrings from each element in the Series or Index.\n\n        Slicing substrings from strings in a Series or Index helps extract\n        specific portions of data, making it easier to analyze or manipulate\n        text. This is useful for tasks like parsing structured text fields or\n        isolating parts of strings with a consistent format.\n\n        Parameters\n        ----------\n        start : int, optional\n            Start position for slice operation.\n        stop : int, optional\n            Stop position for slice operation.\n        step : int, optional\n            Step size for slice operation.\n\n        Returns\n        -------\n        Series or Index of object\n            Series or Index from sliced substring from original string object.\n\n        See Also\n        --------\n        Series.str.slice_replace : Replace a slice with a string.\n        Series.str.get : Return element at position.\n            Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n            being the position.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"koala\", \"dog\", \"chameleon\"])\n        >>> s\n        0        koala\n        1          dog\n        2    chameleon\n        dtype: object\n\n        >>> s.str.slice(start=1)\n        0        oala\n        1          og\n        2    hameleon\n        dtype: object\n\n        >>> s.str.slice(start=-1)\n        0           a\n        1           g\n        2           n\n        dtype: object\n\n        >>> s.str.slice(stop=2)\n        0    ko\n        1    do\n        2    ch\n        dtype: object\n\n        >>> s.str.slice(step=2)\n        0      kaa\n        1       dg\n        2    caeen\n        dtype: object\n\n        >>> s.str.slice(start=0, stop=5, step=3)\n        0    kl\n        1     d\n        2    cm\n        dtype: object\n\n        Equivalent behaviour to:\n\n        >>> s.str[0:5:3]\n        0    kl\n        1     d\n        2    cm\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_slice(start, stop, step)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        \"\"\"\n        Replace a positional slice of a string with another value.\n\n        This function allows replacing specific parts of a string in a Series\n        or Index by specifying start and stop positions. It is useful for\n        modifying substrings in a controlled way, such as updating sections of\n        text based on their positions or patterns.\n\n        Parameters\n        ----------\n        start : int, optional\n            Left index position to use for the slice. If not specified (None),\n            the slice is unbounded on the left, i.e. slice from the start\n            of the string.\n        stop : int, optional\n            Right index position to use for the slice. If not specified (None),\n            the slice is unbounded on the right, i.e. slice until the\n            end of the string.\n        repl : str, optional\n            String for replacement. If not specified (None), the sliced region\n            is replaced with an empty string.\n\n        Returns\n        -------\n        Series or Index\n            Same type as the original object.\n\n        See Also\n        --------\n        Series.str.slice : Just slicing without replacement.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"a\", \"ab\", \"abc\", \"abdc\", \"abcde\"])\n        >>> s\n        0        a\n        1       ab\n        2      abc\n        3     abdc\n        4    abcde\n        dtype: object\n\n        Specify just `start`, meaning replace `start` until the end of the\n        string with `repl`.\n\n        >>> s.str.slice_replace(1, repl=\"X\")\n        0    aX\n        1    aX\n        2    aX\n        3    aX\n        4    aX\n        dtype: object\n\n        Specify just `stop`, meaning the start of the string to `stop` is replaced\n        with `repl`, and the rest of the string is included.\n\n        >>> s.str.slice_replace(stop=2, repl=\"X\")\n        0       X\n        1       X\n        2      Xc\n        3     Xdc\n        4    Xcde\n        dtype: object\n\n        Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n        replaced with `repl`. Everything before or after `start` and `stop` is\n        included as is.\n\n        >>> s.str.slice_replace(start=1, stop=3, repl=\"X\")\n        0      aX\n        1      aX\n        2      aX\n        3     aXc\n        4    aXde\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_slice_replace(start, stop, repl)\n        return self._wrap_result(result)\n\n    def decode(\n        self, encoding, errors: str = \"strict\", dtype: str | DtypeObj | None = None\n    ):\n        \"\"\"\n        Decode character string in the Series/Index using indicated encoding.\n\n        Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n        python3.\n\n        Parameters\n        ----------\n        encoding : str\n            Specifies the encoding to be used.\n        errors : str, optional\n            Specifies the error handling scheme.\n            Possible values are those supported by :meth:`bytes.decode`.\n        dtype : str or dtype, optional\n            The dtype of the result. When not ``None``, must be either a string or\n            object dtype. When ``None``, the dtype of the result is determined by\n            ``pd.options.future.infer_string``.\n\n            .. versionadded:: 2.3.0\n\n        Returns\n        -------\n        Series or Index\n            A Series or Index with decoded strings.\n\n        See Also\n        --------\n        Series.str.encode : Encodes strings into bytes in a Series/Index.\n\n        Examples\n        --------\n        For Series:\n\n        >>> ser = pd.Series([b\"cow\", b\"123\", b\"()\"])\n        >>> ser.str.decode(\"ascii\")\n        0   cow\n        1   123\n        2   ()\n        dtype: object\n        \"\"\"\n        if dtype is not None and not is_string_dtype(dtype):\n            raise ValueError(f\"dtype must be string or object, got {dtype=}\")\n        if dtype is None and get_option(\"future.infer_string\"):\n            dtype = \"str\"\n        # TODO: Add a similar _bytes interface.\n        if encoding in _cpython_optimized_decoders:\n            # CPython optimized implementation\n            f = lambda x: x.decode(encoding, errors)\n        else:\n            decoder = codecs.getdecoder(encoding)\n            f = lambda x: decoder(x, errors)[0]\n        arr = self._data.array\n        result = arr._str_map(f)\n        return self._wrap_result(result, dtype=dtype)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors: str = \"strict\"):\n        \"\"\"\n        Encode character string in the Series/Index using indicated encoding.\n\n        Equivalent to :meth:`str.encode`.\n\n        Parameters\n        ----------\n        encoding : str\n            Specifies the encoding to be used.\n        errors : str, optional\n            Specifies the error handling scheme.\n            Possible values are those supported by :meth:`str.encode`.\n\n        Returns\n        -------\n        Series/Index of objects\n            A Series or Index with strings encoded into bytes.\n\n        See Also\n        --------\n        Series.str.decode : Decodes bytes into strings in a Series/Index.\n\n        Examples\n        --------\n        >>> ser = pd.Series([\"cow\", \"123\", \"()\"])\n        >>> ser.str.encode(encoding=\"ascii\")\n        0     b'cow'\n        1     b'123'\n        2      b'()'\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_encode(encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\"str_strip\"] = r\"\"\"\n    Remove %(position)s characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Replaces any non-strings in Series with NaNs.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index with the strings being stripped from the %(side)s.\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan, 10, True])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    4           10\n    5         True\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    4        NaN\n    5        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    4       NaN\n    5       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    4       NaN\n    5       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\n            \"side\": \"left and right sides\",\n            \"method\": \"strip\",\n            \"position\": \"leading and trailing\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = self._data.array._str_strip(to_strip)\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\"side\": \"left side\", \"method\": \"lstrip\", \"position\": \"leading\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = self._data.array._str_lstrip(to_strip)\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\"side\": \"right side\", \"method\": \"rstrip\", \"position\": \"trailing\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = self._data.array._str_rstrip(to_strip)\n        return self._wrap_result(result)\n\n    _shared_docs[\"str_removefix\"] = r\"\"\"\n    Remove a %(side)s from an object series.\n\n    If the %(side)s is not present, the original string will be returned.\n\n    Parameters\n    ----------\n    %(side)s : str\n        Remove the %(side)s of the string.\n\n    Returns\n    -------\n    Series/Index: object\n        The Series or Index with given %(side)s removed.\n\n    See Also\n    --------\n    Series.str.remove%(other_side)s : Remove a %(other_side)s from an object series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"str_foo\", \"str_bar\", \"no_prefix\"])\n    >>> s\n    0    str_foo\n    1    str_bar\n    2    no_prefix\n    dtype: object\n    >>> s.str.removeprefix(\"str_\")\n    0    foo\n    1    bar\n    2    no_prefix\n    dtype: object\n\n    >>> s = pd.Series([\"foo_str\", \"bar_str\", \"no_suffix\"])\n    >>> s\n    0    foo_str\n    1    bar_str\n    2    no_suffix\n    dtype: object\n    >>> s.str.removesuffix(\"_str\")\n    0    foo\n    1    bar\n    2    no_suffix\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_removefix\"] % {\"side\": \"prefix\", \"other_side\": \"suffix\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def removeprefix(self, prefix: str):\n        result = self._data.array._str_removeprefix(prefix)\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"str_removefix\"] % {\"side\": \"suffix\", \"other_side\": \"prefix\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def removesuffix(self, suffix: str):\n        result = self._data.array._str_removesuffix(suffix)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(\n        self,\n        width: int,\n        expand_tabs: bool = True,\n        tabsize: int = 8,\n        replace_whitespace: bool = True,\n        drop_whitespace: bool = True,\n        initial_indent: str = \"\",\n        subsequent_indent: str = \"\",\n        fix_sentence_endings: bool = False,\n        break_long_words: bool = True,\n        break_on_hyphens: bool = True,\n        max_lines: int | None = None,\n        placeholder: str = \" [...]\",\n    ):\n        r\"\"\"\n        Wrap strings in Series/Index at specified line width.\n\n        This method has the same keyword parameters and defaults as\n            :class:`textwrap.TextWrapper`.\n\n        Parameters\n        ----------\n        width : int, optional\n            Maximum line width.\n        expand_tabs : bool, optional\n            If True, tab characters will be expanded to spaces (default: True).\n        tabsize : int, optional\n            If expand_tabs is true, then all tab characters in text will be\n            expanded to zero or more spaces, depending on the current column\n            and the given tab size (default: 8).\n        replace_whitespace : bool, optional\n            If True, each whitespace character (as defined by string.whitespace)\n            remaining after tab expansion will be replaced by a single space\n            (default: True).\n        drop_whitespace : bool, optional\n            If True, whitespace that, after wrapping, happens to end up at the\n            beginning or end of a line is dropped (default: True).\n        initial_indent : str, optional\n            String that will be prepended to the first line of wrapped output.\n            Counts towards the length of the first line. The empty string is\n            not indented (default: '').\n        subsequent_indent : str, optional\n            String that will be prepended to all lines of wrapped output except\n            the first. Counts towards the length of each line except the first\n            (default: '').\n        fix_sentence_endings : bool, optional\n            If true, TextWrapper attempts to detect sentence endings and ensure\n            that sentences are always separated by exactly two spaces. This is\n            generally desired for text in a monospaced font. However, the sentence\n            detection algorithm is imperfect: it assumes that a sentence ending\n            consists of a lowercase letter followed by one of '.', '!', or '?',\n            possibly followed by one of '\"' or \"'\", followed by a space. One\n            problem with this algorithm is that it is unable to detect the\n            difference between “Dr.” in `[...] Dr. Frankenstein's monster [...]`\n            and “Spot.” in `[...] See Spot. See Spot run [...]`\n            Since the sentence detection algorithm relies on string.lowercase\n            for the definition of “lowercase letter”, and a convention of using\n            two spaces after a period to separate sentences on the same line,\n            it is specific to English-language texts (default: False).\n        break_long_words : bool, optional\n            If True, then words longer than width will be broken in order to ensure\n            that no lines are longer than width. If it is false, long words will\n            not be broken, and some lines may be longer than width (default: True).\n        break_on_hyphens : bool, optional\n            If True, wrapping will occur preferably on whitespace and right after\n            hyphens in compound words, as it is customary in English. If false,\n            only whitespaces will be considered as potentially good places for line\n            breaks, but you need to set break_long_words to false if you want truly\n            insecable words (default: True).\n        max_lines : int, optional\n            If not None, then the output will contain at most max_lines lines, with\n            placeholder appearing at the end of the output (default: None).\n        placeholder : str, optional\n            String that will appear at the end of the output text if it has been\n            truncated (default: ' [...]').\n\n        Returns\n        -------\n        Series or Index\n            A Series or Index where the strings are wrapped at the specified line width.\n\n        See Also\n        --------\n        Series.str.strip : Remove leading and trailing characters in Series/Index.\n        Series.str.lstrip : Remove leading characters in Series/Index.\n        Series.str.rstrip : Remove trailing characters in Series/Index.\n\n        Notes\n        -----\n        Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n        default settings. To achieve behavior matching R's stringr library str_wrap\n        function, use the arguments:\n\n        - expand_tabs = False\n        - replace_whitespace = True\n        - drop_whitespace = True\n        - break_long_words = False\n        - break_on_hyphens = False\n\n        Examples\n        --------\n        >>> s = pd.Series([\"line to be wrapped\", \"another line to be wrapped\"])\n        >>> s.str.wrap(12)\n        0             line to be\\nwrapped\n        1    another line\\nto be\\nwrapped\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_wrap(\n            width=width,\n            expand_tabs=expand_tabs,\n            tabsize=tabsize,\n            replace_whitespace=replace_whitespace,\n            drop_whitespace=drop_whitespace,\n            initial_indent=initial_indent,\n            subsequent_indent=subsequent_indent,\n            fix_sentence_endings=fix_sentence_endings,\n            break_long_words=break_long_words,\n            break_on_hyphens=break_on_hyphens,\n            max_lines=max_lines,\n            placeholder=placeholder,\n        )\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(\n        self,\n        sep: str = \"|\",\n        dtype: NpDtype | None = None,\n    ):\n        \"\"\"\n        Return DataFrame of dummy/indicator variables for Series.\n\n        Each string in Series is split by sep and returned as a DataFrame\n        of dummy/indicator variables.\n\n        Parameters\n        ----------\n        sep : str, default \"|\"\n            String to split on.\n        dtype : dtype, default np.int64\n            Data type for new columns. Only a single dtype is allowed.\n\n        Returns\n        -------\n        DataFrame\n            Dummy variables corresponding to values of the Series.\n\n        See Also\n        --------\n        get_dummies : Convert categorical variable into dummy/indicator\n            variables.\n\n        Examples\n        --------\n        >>> pd.Series([\"a|b\", \"a\", \"a|c\"]).str.get_dummies()\n           a  b  c\n        0  1  1  0\n        1  1  0  0\n        2  1  0  1\n\n        >>> pd.Series([\"a|b\", np.nan, \"a|c\"]).str.get_dummies()\n           a  b  c\n        0  1  1  0\n        1  0  0  0\n        2  1  0  1\n\n        >>> pd.Series([\"a|b\", np.nan, \"a|c\"]).str.get_dummies(dtype=bool)\n                a      b      c\n        0   True   True    False\n        1   False  False   False\n        2   True   False   True\n        \"\"\"\n        from pandas.core.frame import DataFrame\n\n        if dtype is not None and not (is_numeric_dtype(dtype) or is_bool_dtype(dtype)):\n            raise ValueError(\"Only numeric or boolean dtypes are supported for 'dtype'\")\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        result, name = self._data.array._str_get_dummies(sep, dtype)\n        if is_extension_array_dtype(dtype):\n            return self._wrap_result(\n                DataFrame(result, columns=name, dtype=dtype),\n                name=name,\n                returns_string=False,\n            )\n        return self._wrap_result(\n            result,\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        \"\"\"\n        Map all characters in the string through the given mapping table.\n\n        This method is equivalent to the standard :meth:`str.translate`\n        method for strings. It maps each character in the string to a new\n        character according to the translation table provided. Unmapped\n        characters are left unchanged, while characters mapped to None\n        are removed.\n\n        Parameters\n        ----------\n        table : dict\n            Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n            None. Unmapped characters are left untouched.\n            Characters mapped to None are deleted. :meth:`str.maketrans` is a\n            helper function for making translation tables.\n\n        Returns\n        -------\n        Series or Index\n            A new Series or Index with translated strings.\n\n        See Also\n        --------\n        Series.str.replace : Replace occurrences of pattern/regex in the\n            Series with some other string.\n        Index.str.replace : Replace occurrences of pattern/regex in the\n            Index with some other string.\n\n        Examples\n        --------\n        >>> ser = pd.Series([\"El niño\", \"Françoise\"])\n        >>> mytable = str.maketrans({\"ñ\": \"n\", \"ç\": \"c\"})\n        >>> ser.str.translate(mytable)\n        0   El nino\n        1   Francoise\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_translate(table)\n        dtype = object if self._data.dtype == \"object\" else None\n        return self._wrap_result(result, dtype=dtype)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def count(self, pat, flags: int = 0):\n        r\"\"\"\n        Count occurrences of pattern in each string of the Series/Index.\n\n        This function is used to count the number of times a particular regex\n        pattern is repeated in each of the string elements of the\n        :class:`~pandas.Series`.\n\n        Parameters\n        ----------\n        pat : str\n            Valid regular expression.\n        flags : int, default 0, meaning no flags\n            Flags for the `re` module. For a complete list, `see here\n            <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n\n        Returns\n        -------\n        Series or Index\n            Same type as the calling object containing the integer counts.\n\n        See Also\n        --------\n        re : Standard library module for regular expressions.\n        str.count : Standard library version, without regular expression support.\n\n        Notes\n        -----\n        Some characters need to be escaped when passing in `pat`.\n        eg. ``'$'`` has a special meaning in regex and must be escaped when\n        finding this literal character.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"A\", \"B\", \"Aaba\", \"Baca\", np.nan, \"CABA\", \"cat\"])\n        >>> s.str.count(\"a\")\n        0    0.0\n        1    0.0\n        2    2.0\n        3    2.0\n        4    NaN\n        5    0.0\n        6    1.0\n        dtype: float64\n\n        Escape ``'$'`` to find the literal dollar sign.\n\n        >>> s = pd.Series([\"$\", \"B\", \"Aab$\", \"$$ca\", \"C$B$\", \"cat\"])\n        >>> s.str.count(\"\\\\$\")\n        0    1\n        1    0\n        2    1\n        3    2\n        4    2\n        5    0\n        dtype: int64\n\n        This is also available on Index\n\n        >>> pd.Index([\"A\", \"A\", \"Aaba\", \"cat\"]).str.count(\"a\")\n        Index([0, 0, 2, 1], dtype='int64')\n        \"\"\"\n        result = self._data.array._str_count(pat, flags)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def startswith(\n        self, pat: str | tuple[str, ...], na: Scalar | lib.NoDefault = lib.no_default\n    ) -> Series | Index:\n        \"\"\"\n        Test if the start of each string element matches a pattern.\n\n        Equivalent to :meth:`str.startswith`.\n\n        Parameters\n        ----------\n        pat : str or tuple[str, ...]\n            Character sequence or tuple of strings. Regular expressions are not\n            accepted.\n        na : scalar, optional\n            Object shown if element tested is not a string. The default depends\n            on dtype of the array. For object-dtype, ``numpy.nan`` is used.\n            For the nullable ``StringDtype``, ``pandas.NA`` is used.\n            For the ``\"str\"`` dtype, ``False`` is used.\n\n        Returns\n        -------\n        Series or Index of bool\n            A Series of booleans indicating whether the given pattern matches\n            the start of each string element.\n\n        See Also\n        --------\n        str.startswith : Python standard library string method.\n        Series.str.endswith : Same as startswith, but tests the end of string.\n        Series.str.contains : Tests if string element contains a pattern.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"bat\", \"Bear\", \"cat\", np.nan])\n        >>> s\n        0     bat\n        1    Bear\n        2     cat\n        3     NaN\n        dtype: object\n\n        >>> s.str.startswith(\"b\")\n        0     True\n        1    False\n        2    False\n        3      NaN\n        dtype: object\n\n        >>> s.str.startswith((\"b\", \"B\"))\n        0     True\n        1     True\n        2    False\n        3      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN`.\n\n        >>> s.str.startswith(\"b\", na=False)\n        0     True\n        1    False\n        2    False\n        3    False\n        dtype: bool\n        \"\"\"\n        if not isinstance(pat, (str, tuple)):\n            msg = f\"expected a string or tuple, not {type(pat).__name__}\"\n            raise TypeError(msg)\n        result = self._data.array._str_startswith(pat, na=na)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def endswith(\n        self, pat: str | tuple[str, ...], na: Scalar | lib.NoDefault = lib.no_default\n    ) -> Series | Index:\n        \"\"\"\n        Test if the end of each string element matches a pattern.\n\n        Equivalent to :meth:`str.endswith`.\n\n        Parameters\n        ----------\n        pat : str or tuple[str, ...]\n            Character sequence or tuple of strings. Regular expressions are not\n            accepted.\n        na : scalar, optional\n            Object shown if element tested is not a string. The default depends\n            on dtype of the array. For object-dtype, ``numpy.nan`` is used.\n            For the nullable ``StringDtype``, ``pandas.NA`` is used.\n            For the ``\"str\"`` dtype, ``False`` is used.\n\n        Returns\n        -------\n        Series or Index of bool\n            A Series of booleans indicating whether the given pattern matches\n            the end of each string element.\n\n        See Also\n        --------\n        str.endswith : Python standard library string method.\n        Series.str.startswith : Same as endswith, but tests the start of string.\n        Series.str.contains : Tests if string element contains a pattern.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"bat\", \"bear\", \"caT\", np.nan])\n        >>> s\n        0     bat\n        1    bear\n        2     caT\n        3     NaN\n        dtype: object\n\n        >>> s.str.endswith(\"t\")\n        0     True\n        1    False\n        2    False\n        3      NaN\n        dtype: object\n\n        >>> s.str.endswith((\"t\", \"T\"))\n        0     True\n        1    False\n        2     True\n        3      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN`.\n\n        >>> s.str.endswith(\"t\", na=False)\n        0     True\n        1    False\n        2    False\n        3    False\n        dtype: bool\n        \"\"\"\n        if not isinstance(pat, (str, tuple)):\n            msg = f\"expected a string or tuple, not {type(pat).__name__}\"\n            raise TypeError(msg)\n        result = self._data.array._str_endswith(pat, na=na)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def findall(self, pat, flags: int = 0):\n        \"\"\"\n        Find all occurrences of pattern or regular expression in the Series/Index.\n\n        Equivalent to applying :func:`re.findall` to all the elements in the\n        Series/Index.\n\n        Parameters\n        ----------\n        pat : str\n            Pattern or regular expression.\n        flags : int, default 0\n            Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n            means no flags).\n\n        Returns\n        -------\n        Series/Index of lists of strings\n            All non-overlapping matches of pattern or regular expression in each\n            string of this Series/Index.\n\n        See Also\n        --------\n        count : Count occurrences of pattern or regular expression in each string\n            of the Series/Index.\n        extractall : For each string in the Series, extract groups from all matches\n            of regular expression and return a DataFrame with one row for each\n            match and one column for each group.\n        re.findall : The equivalent ``re`` function to all non-overlapping matches\n            of pattern or regular expression in string, as a list of strings.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"Lion\", \"Monkey\", \"Rabbit\"])\n\n        The search for the pattern 'Monkey' returns one match:\n\n        >>> s.str.findall(\"Monkey\")\n        0          []\n        1    [Monkey]\n        2          []\n        dtype: object\n\n        On the other hand, the search for the pattern 'MONKEY' doesn't return any\n        match:\n\n        >>> s.str.findall(\"MONKEY\")\n        0    []\n        1    []\n        2    []\n        dtype: object\n\n        Flags can be added to the pattern or regular expression. For instance,\n        to find the pattern 'MONKEY' ignoring the case:\n\n        >>> import re\n        >>> s.str.findall(\"MONKEY\", flags=re.IGNORECASE)\n        0          []\n        1    [Monkey]\n        2          []\n        dtype: object\n\n        When the pattern matches more than one string in the Series, all matches\n        are returned:\n\n        >>> s.str.findall(\"on\")\n        0    [on]\n        1    [on]\n        2      []\n        dtype: object\n\n        Regular expressions are supported too. For instance, the search for all the\n        strings ending with the word 'on' is shown next:\n\n        >>> s.str.findall(\"on$\")\n        0    [on]\n        1      []\n        2      []\n        dtype: object\n\n        If the pattern is found more than once in the same string, then a list of\n        multiple strings is returned:\n\n        >>> s.str.findall(\"b\")\n        0        []\n        1        []\n        2    [b, b]\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_findall(pat, flags)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(\n        self, pat: str, flags: int = 0, expand: bool = True\n    ) -> DataFrame | Series | Index:\n        r\"\"\"\n        Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n        For each subject string in the Series, extract groups from the\n        first match of regular expression `pat`.\n\n        Parameters\n        ----------\n        pat : str\n            Regular expression pattern with capturing groups.\n        flags : int, default 0 (no flags)\n            Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n            modify regular expression matching for things like case,\n            spaces, etc. For more details, see :mod:`re`.\n        expand : bool, default True\n            If True, return DataFrame with one column per capture group.\n            If False, return a Series/Index if there is one capture group\n            or DataFrame if there are multiple capture groups.\n\n        Returns\n        -------\n        DataFrame or Series or Index\n            A DataFrame with one row for each subject string, and one\n            column for each group. Any capture group names in regular\n            expression pat will be used for column names; otherwise\n            capture group numbers will be used. The dtype of each result\n            column is always object, even when no match is found. If\n            ``expand=False`` and pat has only one capture group, then\n            return a Series (if subject is a Series) or Index (if subject\n            is an Index).\n\n        See Also\n        --------\n        extractall : Returns all matches (not just the first match).\n\n        Examples\n        --------\n        A pattern with two groups will return a DataFrame with two columns.\n        Non-matches will be NaN.\n\n        >>> s = pd.Series([\"a1\", \"b2\", \"c3\"])\n        >>> s.str.extract(r\"([ab])(\\d)\")\n            0    1\n        0    a    1\n        1    b    2\n        2  NaN  NaN\n\n        A pattern may contain optional groups.\n\n        >>> s.str.extract(r\"([ab])?(\\d)\")\n            0  1\n        0    a  1\n        1    b  2\n        2  NaN  3\n\n        Named groups will become column names in the result.\n\n        >>> s.str.extract(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n        letter digit\n        0      a     1\n        1      b     2\n        2    NaN   NaN\n\n        A pattern with one group will return a DataFrame with one column\n        if expand=True.\n\n        >>> s.str.extract(r\"[ab](\\d)\", expand=True)\n            0\n        0    1\n        1    2\n        2  NaN\n\n        A pattern with one group will return a Series if expand=False.\n\n        >>> s.str.extract(r\"[ab](\\d)\", expand=False)\n        0      1\n        1      2\n        2    NaN\n        dtype: object\n        \"\"\"\n        from pandas import DataFrame\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        regex = re.compile(pat, flags=flags)\n        if regex.groups == 0:\n            raise ValueError(\"pattern contains no capture groups\")\n\n        if not expand and regex.groups > 1 and isinstance(self._data, ABCIndex):\n            raise ValueError(\"only one regex group is supported with Index\")\n\n        obj = self._data\n        result_dtype = _result_dtype(obj)\n\n        returns_df = regex.groups > 1 or expand\n\n        if returns_df:\n            name = None\n            columns = _get_group_names(regex)\n\n            if obj.array.size == 0:\n                result = DataFrame(columns=columns, dtype=result_dtype)\n\n            else:\n                result_list = self._data.array._str_extract(\n                    pat, flags=flags, expand=returns_df\n                )\n\n                result_index: Index | None\n                if isinstance(obj, ABCSeries):\n                    result_index = obj.index\n                else:\n                    result_index = None\n\n                result = DataFrame(\n                    result_list, columns=columns, index=result_index, dtype=result_dtype\n                )\n\n        else:\n            name = _get_single_group_name(regex)\n            result = self._data.array._str_extract(pat, flags=flags, expand=returns_df)\n        return self._wrap_result(result, name=name, dtype=result_dtype)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags: int = 0) -> DataFrame:\n        r\"\"\"\n        Extract capture groups in the regex `pat` as columns in DataFrame.\n\n        For each subject string in the Series, extract groups from all\n        matches of regular expression pat. When each subject string in the\n        Series has exactly one match, extractall(pat).xs(0, level='match')\n        is the same as extract(pat).\n\n        Parameters\n        ----------\n        pat : str\n            Regular expression pattern with capturing groups.\n        flags : int, default 0 (no flags)\n            A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n            to modify regular expression matching for things like case, spaces,\n            etc. Multiple flags can be combined with the bitwise OR operator,\n            for example ``re.IGNORECASE | re.MULTILINE``.\n\n        Returns\n        -------\n        DataFrame\n            A ``DataFrame`` with one row for each match, and one column for each\n            group. Its rows have a ``MultiIndex`` with first levels that come from\n            the subject ``Series``. The last level is named 'match' and indexes the\n            matches in each item of the ``Series``. Any capture group names in\n            regular expression pat will be used for column names; otherwise capture\n            group numbers will be used.\n\n        See Also\n        --------\n        extract : Returns first match only (not all matches).\n\n        Examples\n        --------\n        A pattern with one group will return a DataFrame with one column.\n        Indices with no matches will not appear in the result.\n\n        >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n        >>> s.str.extractall(r\"[ab](\\d)\")\n                0\n        match\n        A 0      1\n          1      2\n        B 0      1\n\n        Capture group names are used for column names of the result.\n\n        >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n                digit\n        match\n        A 0         1\n          1         2\n        B 0         1\n\n        A pattern with two groups will return a DataFrame with two columns.\n\n        >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n                letter digit\n        match\n        A 0          a     1\n          1          a     2\n        B 0          b     1\n\n        Optional groups that do not match are NaN in the result.\n\n        >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n                letter digit\n        match\n        A 0          a     1\n          1          a     2\n        B 0          b     1\n        C 0        NaN     1\n        \"\"\"\n        # TODO: dispatch\n        return str_extractall(self._orig, pat, flags)\n\n    _shared_docs[\"find\"] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index.\n\n    Each of returned indexes corresponds to the position where the\n    substring is fully contained between [start:end]. Return -1 on\n    failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of int.\n        A Series (if the input is a Series) or an Index (if the input is an\n        Index) of the %(side)s indexes corresponding to the positions where the\n        substring is found in each string of the input.\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n    For Series.str.find:\n\n    >>> ser = pd.Series([\"_cow_\", \"duck_\", \"do_v_e\"])\n    >>> ser.str.find(\"_\")\n    0   0\n    1   4\n    2   2\n    dtype: int64\n\n    For Series.str.rfind:\n\n    >>> ser = pd.Series([\"_cow_\", \"duck_\", \"do_v_e\"])\n    >>> ser.str.rfind(\"_\")\n    0   4\n    1   4\n    2   4\n    dtype: int64\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % {\n            \"side\": \"lowest\",\n            \"method\": \"find\",\n            \"also\": \"rfind : Return highest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start: int = 0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_find(sub, start, end)\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % {\n            \"side\": \"highest\",\n            \"method\": \"rfind\",\n            \"also\": \"find : Return lowest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start: int = 0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_rfind(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form.\n\n        Returns\n        -------\n        Series/Index of objects\n            A Series or Index of strings in the same Unicode form specified by `form`.\n            The returned object retains the same type as the input (Series or Index),\n            and contains the normalized strings.\n\n        See Also\n        --------\n        Series.str.upper : Convert all characters in each string to uppercase.\n        Series.str.lower : Convert all characters in each string to lowercase.\n        Series.str.title : Convert each string to title case (capitalizing the\n            first letter of each word).\n        Series.str.strip : Remove leading and trailing whitespace from each string.\n        Series.str.replace : Replace occurrences of a substring with another substring\n            in each string.\n\n        Examples\n        --------\n        >>> ser = pd.Series([\"ñ\"])\n        >>> ser.str.normalize(\"NFC\") == ser.str.normalize(\"NFD\")\n        0   False\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_normalize(form)\n        return self._wrap_result(result)\n\n    _shared_docs[\"index\"] = \"\"\"\n    Return %(side)s indexes in each string in Series/Index.\n\n    Each of the returned indexes corresponds to the position where the\n    substring is fully contained between [start:end]. This is the same\n    as ``str.%(similar)s`` except instead of returning -1, it raises a\n    ValueError when the substring is not found. Equivalent to standard\n    ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns a Series or an Index of the %(side)s indexes\n        in each string of the input.\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n    For Series.str.index:\n\n    >>> ser = pd.Series([\"horse\", \"eagle\", \"donkey\"])\n    >>> ser.str.index(\"e\")\n    0   4\n    1   0\n    2   4\n    dtype: int64\n\n    For Series.str.rindex:\n\n    >>> ser = pd.Series([\"Deer\", \"eagle\", \"Sheep\"])\n    >>> ser.str.rindex(\"e\")\n    0   2\n    1   4\n    2   3\n    dtype: int64\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % {\n            \"side\": \"lowest\",\n            \"similar\": \"find\",\n            \"method\": \"index\",\n            \"also\": \"rindex : Return highest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start: int = 0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_index(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % {\n            \"side\": \"highest\",\n            \"similar\": \"rfind\",\n            \"method\": \"rindex\",\n            \"also\": \"index : Return lowest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start: int = 0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_rindex(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    def len(self):\n        \"\"\"\n        Compute the length of each element in the Series/Index.\n\n        The element may be a sequence (such as a string, tuple or list) or a collection\n        (such as a dictionary).\n\n        Returns\n        -------\n        Series or Index of int\n            A Series or Index of integer values indicating the length of each\n            element in the Series or Index.\n\n        See Also\n        --------\n        str.len : Python built-in function returning the length of an object.\n        Series.size : Returns the length of the Series.\n\n        Examples\n        --------\n        Returns the length (number of characters) in a string. Returns the\n        number of entries for dictionaries, lists or tuples.\n\n        >>> s = pd.Series(\n        ...     [\"dog\", \"\", 5, {\"foo\": \"bar\"}, [2, 3, 5, 7], (\"one\", \"two\", \"three\")]\n        ... )\n        >>> s\n        0                  dog\n        1\n        2                    5\n        3       {'foo': 'bar'}\n        4         [2, 3, 5, 7]\n        5    (one, two, three)\n        dtype: object\n        >>> s.str.len()\n        0    3.0\n        1    0.0\n        2    NaN\n        3    1.0\n        4    4.0\n        5    3.0\n        dtype: float64\n        \"\"\"\n        result = self._data.array._str_len()\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\"casemethods\"] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series or Index of objects\n        A Series or Index where the strings are modified by :meth:`str.%(method)s`.\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n    # Types:\n    #   cases:\n    #       upper, lower, title, capitalize, swapcase, casefold\n    #   boolean:\n    #     isalpha, isnumeric isalnum isdigit isdecimal isspace islower\n    #     isupper istitle isascii\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args: dict[str, dict[str, str]] = {}\n    _doc_args[\"lower\"] = {\"type\": \"lowercase\", \"method\": \"lower\", \"version\": \"\"}\n    _doc_args[\"upper\"] = {\"type\": \"uppercase\", \"method\": \"upper\", \"version\": \"\"}\n    _doc_args[\"title\"] = {\"type\": \"titlecase\", \"method\": \"title\", \"version\": \"\"}\n    _doc_args[\"capitalize\"] = {\n        \"type\": \"be capitalized\",\n        \"method\": \"capitalize\",\n        \"version\": \"\",\n    }\n    _doc_args[\"swapcase\"] = {\n        \"type\": \"be swapcased\",\n        \"method\": \"swapcase\",\n        \"version\": \"\",\n    }\n    _doc_args[\"casefold\"] = {\n        \"type\": \"be casefolded\",\n        \"method\": \"casefold\",\n        \"version\": \"\",\n    }\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"lower\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def lower(self):\n        result = self._data.array._str_lower()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"upper\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def upper(self):\n        result = self._data.array._str_upper()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"title\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def title(self):\n        result = self._data.array._str_title()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def capitalize(self):\n        result = self._data.array._str_capitalize()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def swapcase(self):\n        result = self._data.array._str_swapcase()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def casefold(self):\n        result = self._data.array._str_casefold()\n        return self._wrap_result(result)\n\n    _shared_docs[\"ismethods\"] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n    \"\"\"\n    _shared_docs[\"isalpha\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"isnumeric\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but\n    also includes other characters that can represent quantities such as\n    unicode fractions.\n\n    >>> s1 = pd.Series(['one', 'one1', '1', '', '³', '⅕'])\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    5     True\n    dtype: bool\n\n    For a string to be considered numeric, all its characters must have a Unicode\n    numeric property matching :py:meth:`str.is_numeric`. As a consequence,\n    the following cases are **not** recognized as numeric:\n\n    - **Decimal numbers** (e.g., \"1.1\"): due to period ``\".\"``\n    - **Negative numbers** (e.g., \"-5\"):  due to minus sign ``\"-\"``\n    - **Scientific notation** (e.g., \"1e3\"): due to characters like ``\"e\"``\n\n    >>> s2 = pd.Series([\"1.1\", \"-5\", \"1e3\"])\n    >>> s2.str.isnumeric()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"isalnum\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"isdecimal\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    The ``s3.str.isdecimal`` method checks for characters used to form\n    numbers in base 10.\n\n    >>> s3 = pd.Series(['23', '³', '⅕', ''])\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"isdigit\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    Similar to ``str.isdecimal`` but also includes special digits, like\n    superscripted and subscripted digits in unicode.\n\n    >>> s3 = pd.Series(['23', '³', '⅕', ''])\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n\n    _shared_docs[\"isspace\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"islower\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n\n    _shared_docs[\"isupper\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"istitle\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isascii : Check whether all characters are ascii.\n    Series.str.isupper : Check whether all characters are uppercase.\n\n    Examples\n    --------\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _shared_docs[\"isascii\"] = \"\"\"\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n    Series.str.isupper : Check whether all characters are uppercase.\n\n    Examples\n    ------------\n    The ``s5.str.isascii`` method checks for whether all characters are ascii\n    characters, which includes digits 0-9, capital and lowercase letters A-Z,\n    and some other special characters.\n\n    >>> s5 = pd.Series(['ö', 'see123', 'hello world', ''])\n    >>> s5.str.isascii()\n    0    False\n    1     True\n    2     True\n    3     True\n    dtype: bool\n    \"\"\"\n\n    _doc_args[\"isalnum\"] = {\"type\": \"alphanumeric\", \"method\": \"isalnum\"}\n    _doc_args[\"isalpha\"] = {\"type\": \"alphabetic\", \"method\": \"isalpha\"}\n    _doc_args[\"isdigit\"] = {\"type\": \"digits\", \"method\": \"isdigit\"}\n    _doc_args[\"isspace\"] = {\"type\": \"whitespace\", \"method\": \"isspace\"}\n    _doc_args[\"islower\"] = {\"type\": \"lowercase\", \"method\": \"islower\"}\n    _doc_args[\"isascii\"] = {\"type\": \"ascii\", \"method\": \"isascii\"}\n    _doc_args[\"isupper\"] = {\"type\": \"uppercase\", \"method\": \"isupper\"}\n    _doc_args[\"istitle\"] = {\"type\": \"titlecase\", \"method\": \"istitle\"}\n    _doc_args[\"isnumeric\"] = {\"type\": \"numeric\", \"method\": \"isnumeric\"}\n    _doc_args[\"isdecimal\"] = {\"type\": \"decimal\", \"method\": \"isdecimal\"}\n    # force _noarg_wrapper return type with dtype=np.dtype(bool) (GH 29624)\n\n    isalnum = _map_and_wrap(\n        \"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"]\n        + _shared_docs[\"isalnum\"],\n    )\n    isalpha = _map_and_wrap(\n        \"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"]\n        + _shared_docs[\"isalpha\"],\n    )\n    isdigit = _map_and_wrap(\n        \"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"]\n        + _shared_docs[\"isdigit\"],\n    )\n    isspace = _map_and_wrap(\n        \"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"]\n        + _shared_docs[\"isspace\"],\n    )\n    islower = _map_and_wrap(\n        \"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"]\n        + _shared_docs[\"islower\"],\n    )\n    isascii = _map_and_wrap(\n        \"isascii\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isascii\"]\n        + _shared_docs[\"isascii\"],\n    )\n    isupper = _map_and_wrap(\n        \"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"]\n        + _shared_docs[\"isupper\"],\n    )\n    istitle = _map_and_wrap(\n        \"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"]\n        + _shared_docs[\"istitle\"],\n    )\n    isnumeric = _map_and_wrap(\n        \"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"]\n        + _shared_docs[\"isnumeric\"],\n    )\n    isdecimal = _map_and_wrap(\n        \"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"]\n        + _shared_docs[\"isdecimal\"],\n    )\n\n\ndef cat_safe(list_of_columns: list[npt.NDArray[np.object_]], sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    f\"column {dtype}\"\n                ) from None\n    return result\n\n\ndef cat_core(list_of_columns: list, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        arr_of_cols = np.asarray(list_of_columns, dtype=object)\n        return np.sum(arr_of_cols, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    arr_with_sep = np.asarray(list_with_sep, dtype=object)\n    return np.sum(arr_with_sep, axis=0)\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    from pandas.core.arrays.string_ import StringDtype\n\n    if isinstance(arr.dtype, (ArrowDtype, StringDtype)):\n        return arr.dtype\n    return object\n\n\ndef _get_single_group_name(regex: re.Pattern) -> Hashable:\n    if regex.groupindex:\n        return next(iter(regex.groupindex))\n    else:\n        return None\n\n\ndef _get_group_names(regex: re.Pattern) -> list[Hashable] | range:\n    \"\"\"\n    Get named groups from compiled regex.\n\n    Unnamed groups are numbered.\n\n    Parameters\n    ----------\n    regex : compiled regex\n\n    Returns\n    -------\n    list of column labels\n    \"\"\"\n    rng = range(regex.groups)\n    names = {v: k for k, v in regex.groupindex.items()}\n    if not names:\n        return rng\n    result: list[Hashable] = [names.get(1 + i, i) for i in rng]\n    arr = np.array(result)\n    if arr.dtype.kind == \"i\" and lib.is_range_indexer(arr, len(arr)):\n        return rng\n    return result\n\n\ndef str_extractall(arr, pat, flags: int = 0) -> DataFrame:\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True).astype(arr.dtype)\n\n    columns = _get_group_names(regex)\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.nan if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n"
    }
  ],
  "questions": [
    "Hi @sf-dcp,\n\nThis is not a bug in `pd.Series.isnumeric()` but expected behavior.  As per [documentation](https://docs.python.org/3/library/stdtypes.html#str.isnumeric) for `str.isnumeric()`,  . (decimal point) is not a numeric character, so strings with decimal points like \"1.1\" fail the isnumeric() check.\n\n![Image](https://github.com/user-attachments/assets/1c06aeed-8f30-44f3-b513-ebf85627d31f)\n\n`str.isnumeric()` method checks if:\n\n1. All characters in the string are **numeric characters.**\n2. There is at least one character in the string.\n\nNumeric characters are those with the Unicode property values:\n- Numeric_Type=Digit (e.g., \"1\", \"2\", \"3\")\n- Numeric_Type=Decimal (e.g., standard decimal digits like \"1\", \"2\")\n- Numeric_Type=Numeric (e.g., fractions like \"⅕\", Roman numerals, etc.)\n\nTherefore, `.` (decimal character) **does not have the Unicode numeric property**; it's categorized as punctuation.\n\n## Solution 01 - Using regex\n\n```python\nimport re\n\ndef is_numeric(string):\n    pattern = r'^-?\\d+(\\.\\d+)?$'\n    return bool(re.match(pattern, string))\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\"  and \"0.0\".\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n- Does not works for scientific notations, \"1e10\" returns `False`\n\n## Solution 02 - Using `float()`\n\n```python\ndef is_numeric(string):\n    try:\n        float(string)\n        return True\n    except ValueError:\n        return False\n```\n\n**Note**:\n- correctly identifies valid numeric strings like \"1\", \"-2.5\", \"1e10\" (scientific notation), and \"0.0\"\n- rejects invalid strings like \"1.0.0\", \"abc\", or empty strings.\n\n## Performance Consideration\n- Regex: Slower due to the regex engine's overhead of parsing and matching patterns.\n- Float-based: Faster, as it directly leverages Python’s built-in C-optimized parsing.\n\n```python \n# Test dataset (mix of numeric and non-numeric strings)\ndata = [\"1\", \"123.45\", \"-987.65\", \"0\", \"abc\", \"123.45.67\"] * 1_000_000\n```\n\n- Regex time: 5.59 seconds\n- Float time: 2.23 seconds",
    "Thanks for the report! This mirrors Python behavior:\n\n```python\nprint(\"1.2\".isnumeric())\n# False\n```\n\nThe first line of the docstring states:\n\n> Check whether all characters in each string are numeric.\n\nAre you saying there might be some confusion as to whether `.` is a numeric character?",
    "what if we try  this code ?\n\n\n```\ndef is_numeric(string):\n    if (string.isnumeric()):\n        return True;\n\n    else:\n        try:\n            float(string)\n            return True;\n        except ValueError:\n            return False\n```",
    "I noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?",
    "```python\n@forbid_nonstring_types(['bytes'])\ndef isnumeric(self, extended=False):\n    if extended:\n        regex = r'^[+-]?(\\d+([.]\\d*)?([eE][+-]?\\d+)?|[.]\\d+([eE][+-]?\\d+)?)$'\n        return self._data.str.match(regex, na=False)\n    return self._data._str_map(\n        fname=\"isnumeric\", dtype=np.dtype(\"bool\"), na_value=False\n    )\n```\nwould this be a good solution to handling decimal strings?"
  ],
  "golden_answers": [
    "Hi @akj2018, thanks for the prompt reply and suggestions. I think the method name is a bit misleading then where I would expect a string number (with a dot or a negative integer string) to be returned `True`. But I also understand the logic behind it. At a minimum, I would recommend updating the method docs with a note or warning calling out the method's behavior when it comes to decimal numbers and/or negative numbers. Again, thanks for clarifying.",
    "@rhshadrach, yep, I may be biased here but I can interpret `.` being numeric like in a decimal number :) I believe an explicit message about numeric values other than integers (negative and decimal string values) would be beneficial for at least a portion of `pandas` users.",
    "> Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nNo, pandas' `isnumeic` should match Python's `isnumeric`.",
    "> Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nNo, pandas' `isnumeic` should match Python's `isnumeric`.",
    "@arnav1209 \n> I noticed that pd.Series.isnumeric() currently returns False for '3.14' due to the behavior of Python’s str.isnumeric(). Would the intended fix be to have isnumeric() return True for strings that represent valid decimal numbers? Also, should we extend this to handle signs (like -3.14) or scientific notation (like 1e3), or keep it simple?\n\nAs mentioned, we should not change the code, this bug is a documentation fixing issue\n\n> No, pandas' `isnumeic` should match Python's `isnumeric`."
  ],
  "questions_generated": [
    "Why does the `str.isnumeric()` method in pandas only return `True` for integer strings and not for decimal strings?",
    "What changes would be necessary in the pandas codebase to make `pd.Series.str.isnumeric()` return `True` for decimal strings?",
    "How does the current implementation of `str.isnumeric()` method in pandas correlate with its Python standard library counterpart?",
    "What could be the potential implications of changing the behavior of `pd.Series.str.isnumeric()` to support decimal strings?",
    "What are the potential challenges in modifying the pandas `str.isnumeric()` method to handle decimal strings, and how might these challenges be addressed?"
  ],
  "golden_answers_generated": [
    "The `str.isnumeric()` method in pandas is designed to check if all characters in each string are numeric characters. In Python, the `isnumeric()` method on strings returns `True` only for strings that contain numeric characters, which does not include decimal points. Therefore, when applied to strings like '1.0' or '1.1', which contain a decimal point, it returns `False`.",
    "To make `pd.Series.str.isnumeric()` return `True` for decimal strings, one potential change would be to modify the underlying implementation to recognize and handle decimal points as valid numeric characters. This could involve adding a custom logic to the method that checks for the presence of a single decimal point and ensures that all other characters are numeric digits.",
    "The current implementation of `str.isnumeric()` in pandas closely follows the behavior of Python's standard library string method `isnumeric()`. Both methods check for numeric characters in a string but do not consider decimal points as numeric, hence returning `False` for strings containing decimal values.",
    "Changing the behavior of `pd.Series.str.isnumeric()` to support decimal strings could potentially affect existing codebases that rely on the current behavior. It would necessitate a review of documentation and possibly a major version update, as it changes the contract of the method. Developers would need to be informed of this change to avoid unexpected results in their data processing pipelines.",
    "One challenge in modifying the `str.isnumeric()` method to handle decimal strings is ensuring it accurately distinguishes between valid numeric strings with decimals and invalid formats (e.g., multiple decimal points). This requires robust parsing logic. These challenges might be addressed by implementing a regular expression or parsing logic that validates the format of numeric strings, ensuring that only one decimal point is allowed and that it is flanked by numeric characters."
  ]
}