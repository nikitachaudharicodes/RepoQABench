{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "38543",
  "issue_description": "# `np.array([pd.Series({'a':'a'})])` works but `np.array([pd.Series({1:1})])` doesn't\n\nThe last line here throws a `KeyError: 0`\r\n```\r\nimport numpy as np\r\nimport pandas as pd\r\nnp.array([pd.Series({0:0})])\r\nnp.array([pd.Series({'a':'a'})])\r\nnp.array([pd.Series({1:1})])\r\n```\r\nIs that a bug?",
  "issue_comments": [
    {
      "id": 747947723,
      "user": "jorisvandenbossche",
      "body": "Can you show the output of `pd.show_versions()` ?"
    },
    {
      "id": 748140257,
      "user": "MarcoGorelli",
      "body": "I can't reproduce this on v1.1.5"
    },
    {
      "id": 748142634,
      "user": "soerenwolfers",
      "body": "Sorry, \r\n\r\npandas           : 1.1.4\r\nnumpy            : 1.17.4"
    },
    {
      "id": 748157274,
      "user": "MarcoGorelli",
      "body": "Thanks, can confirm this reproduces.\r\n\r\nIf you upgrade pandas to 1.1.5 you'll find it fixed - it would be good to do a git bisect to figure out when this was fixed, and (if it was fixed accidentally) to add a test"
    },
    {
      "id": 748169235,
      "user": "simonjayhawkins",
      "body": "can't reproduce with 0.25.3, 1.0.5, 1.1.3, 1.1.4, 1.1.5, master (all envs using numpy 1.19+)"
    },
    {
      "id": 748171996,
      "user": "MarcoGorelli",
      "body": "Same, just tried in 1.1.4 with numpy 1.19.4 and it works fine.\r\n\r\nConversely, on `master` and with numpy 1.17.4, it still fails. I think we can close this as an upstream bug anyway"
    },
    {
      "id": 748176159,
      "user": "jorisvandenbossche",
      "body": "But is it an identified / reported upstream issue? \r\nI think it's still good to add a test (it's not given that this was an intentional/tested fix on numpy's side)"
    },
    {
      "id": 748180929,
      "user": "MarcoGorelli",
      "body": "Sure - @soerenwolfers do you feel like contributing a test for this issue? If so, please check the [contributing guide](https://pandas.pydata.org/pandas-docs/dev/development/contributing.html)"
    },
    {
      "id": 748205378,
      "user": "seberg",
      "body": "Wow, there was an additional layer of confusion to unravel here :) (for myself). If there is only a single item in the dataframe, NumPy used to do use `series[0]` to get that item. But if there were more items it effectively used `list(series)`.  Since `list()` probably uses `__iter__` internally – and that goes by position and not index – the only thing that gives different results on new NumPy seems to be the specific case of a series with a single element and non 0 index."
    },
    {
      "id": 894717951,
      "user": "horaceklai",
      "body": "take"
    },
    {
      "id": 896358748,
      "user": "horaceklai",
      "body": "Hi I'm not sure what to do now. I made a PR and did the changes requested, but when running the tests, it throws the Key error: 0 as stated in the beginning of this issue.\r\n\r\nhttps://github.com/pandas-dev/pandas/pull/42939"
    }
  ],
  "text_context": "# `np.array([pd.Series({'a':'a'})])` works but `np.array([pd.Series({1:1})])` doesn't\n\nThe last line here throws a `KeyError: 0`\r\n```\r\nimport numpy as np\r\nimport pandas as pd\r\nnp.array([pd.Series({0:0})])\r\nnp.array([pd.Series({'a':'a'})])\r\nnp.array([pd.Series({1:1})])\r\n```\r\nIs that a bug?\n\nCan you show the output of `pd.show_versions()` ?\n\nI can't reproduce this on v1.1.5\n\nSorry, \r\n\r\npandas           : 1.1.4\r\nnumpy            : 1.17.4\n\nThanks, can confirm this reproduces.\r\n\r\nIf you upgrade pandas to 1.1.5 you'll find it fixed - it would be good to do a git bisect to figure out when this was fixed, and (if it was fixed accidentally) to add a test\n\ncan't reproduce with 0.25.3, 1.0.5, 1.1.3, 1.1.4, 1.1.5, master (all envs using numpy 1.19+)\n\nSame, just tried in 1.1.4 with numpy 1.19.4 and it works fine.\r\n\r\nConversely, on `master` and with numpy 1.17.4, it still fails. I think we can close this as an upstream bug anyway\n\nBut is it an identified / reported upstream issue? \r\nI think it's still good to add a test (it's not given that this was an intentional/tested fix on numpy's side)\n\nSure - @soerenwolfers do you feel like contributing a test for this issue? If so, please check the [contributing guide](https://pandas.pydata.org/pandas-docs/dev/development/contributing.html)\n\nWow, there was an additional layer of confusion to unravel here :) (for myself). If there is only a single item in the dataframe, NumPy used to do use `series[0]` to get that item. But if there were more items it effectively used `list(series)`.  Since `list()` probably uses `__iter__` internally – and that goes by position and not index – the only thing that gives different results on new NumPy seems to be the specific case of a series with a single element and non 0 index.\n\ntake\n\nHi I'm not sure what to do now. I made a PR and did the changes requested, but when running the tests, it throws the Key error: 0 as stated in the beginning of this issue.\r\n\r\nhttps://github.com/pandas-dev/pandas/pull/42939",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/42939",
  "code_context": [
    {
      "filename": "pandas/tests/series/test_constructors.py",
      "content": "from collections import OrderedDict\nfrom datetime import (\n    datetime,\n    timedelta,\n)\n\nfrom dateutil.tz import tzoffset\nimport numpy as np\nimport numpy.ma as ma\nimport pytest\n\nfrom pandas._libs import (\n    iNaT,\n    lib,\n)\nfrom pandas.compat.numpy import np_version_under1p19\nimport pandas.util._test_decorators as td\n\nfrom pandas.core.dtypes.common import (\n    is_categorical_dtype,\n    is_datetime64tz_dtype,\n)\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\n\nimport pandas as pd\nfrom pandas import (\n    Categorical,\n    DataFrame,\n    DatetimeIndex,\n    Index,\n    Interval,\n    IntervalIndex,\n    MultiIndex,\n    NaT,\n    Period,\n    RangeIndex,\n    Series,\n    Timestamp,\n    date_range,\n    isna,\n    period_range,\n    timedelta_range,\n)\nimport pandas._testing as tm\nfrom pandas.core.api import Int64Index\nfrom pandas.core.arrays import (\n    IntervalArray,\n    period_array,\n)\nfrom pandas.core.internals.blocks import NumericBlock\n\n\nclass TestSeriesConstructors:\n    @pytest.mark.parametrize(\n        \"constructor,check_index_type\",\n        [\n            # NOTE: some overlap with test_constructor_empty but that test does not\n            # test for None or an empty generator.\n            # test_constructor_pass_none tests None but only with the index also\n            # passed.\n            (lambda: Series(), True),\n            (lambda: Series(None), True),\n            (lambda: Series({}), True),\n            (lambda: Series(()), False),  # creates a RangeIndex\n            (lambda: Series([]), False),  # creates a RangeIndex\n            (lambda: Series(_ for _ in []), False),  # creates a RangeIndex\n            (lambda: Series(data=None), True),\n            (lambda: Series(data={}), True),\n            (lambda: Series(data=()), False),  # creates a RangeIndex\n            (lambda: Series(data=[]), False),  # creates a RangeIndex\n            (lambda: Series(data=(_ for _ in [])), False),  # creates a RangeIndex\n        ],\n    )\n    def test_empty_constructor(self, constructor, check_index_type):\n        # TODO: share with frame test of the same name\n        with tm.assert_produces_warning(FutureWarning):\n            expected = Series()\n            result = constructor()\n\n        assert len(result.index) == 0\n        tm.assert_series_equal(result, expected, check_index_type=check_index_type)\n\n    def test_invalid_dtype(self):\n        # GH15520\n        msg = \"not understood\"\n        invalid_list = [Timestamp, \"Timestamp\", list]\n        for dtype in invalid_list:\n            with pytest.raises(TypeError, match=msg):\n                Series([], name=\"time\", dtype=dtype)\n\n    def test_invalid_compound_dtype(self):\n        # GH#13296\n        c_dtype = np.dtype([(\"a\", \"i8\"), (\"b\", \"f4\")])\n        cdt_arr = np.array([(1, 0.4), (256, -13)], dtype=c_dtype)\n\n        with pytest.raises(ValueError, match=\"Use DataFrame instead\"):\n            Series(cdt_arr, index=[\"A\", \"B\"])\n\n    def test_scalar_conversion(self):\n\n        # Pass in scalar is disabled\n        scalar = Series(0.5)\n        assert not isinstance(scalar, float)\n\n        # Coercion\n        assert float(Series([1.0])) == 1.0\n        assert int(Series([1.0])) == 1\n\n    def test_scalar_extension_dtype(self, ea_scalar_and_dtype):\n        # GH 28401\n\n        ea_scalar, ea_dtype = ea_scalar_and_dtype\n\n        ser = Series(ea_scalar, index=range(3))\n        expected = Series([ea_scalar] * 3, dtype=ea_dtype)\n\n        assert ser.dtype == ea_dtype\n        tm.assert_series_equal(ser, expected)\n\n    def test_constructor(self, datetime_series):\n        with tm.assert_produces_warning(FutureWarning):\n            empty_series = Series()\n        assert datetime_series.index._is_all_dates\n\n        # Pass in Series\n        derived = Series(datetime_series)\n        assert derived.index._is_all_dates\n\n        assert tm.equalContents(derived.index, datetime_series.index)\n        # Ensure new index is not created\n        assert id(datetime_series.index) == id(derived.index)\n\n        # Mixed type Series\n        mixed = Series([\"hello\", np.NaN], index=[0, 1])\n        assert mixed.dtype == np.object_\n        assert mixed[1] is np.NaN\n\n        assert not empty_series.index._is_all_dates\n        with tm.assert_produces_warning(FutureWarning):\n            assert not Series().index._is_all_dates\n\n        # exception raised is of type ValueError GH35744\n        with pytest.raises(ValueError, match=\"Data must be 1-dimensional\"):\n            Series(np.random.randn(3, 3), index=np.arange(3))\n\n        mixed.name = \"Series\"\n        rs = Series(mixed).name\n        xp = \"Series\"\n        assert rs == xp\n\n        # raise on MultiIndex GH4187\n        m = MultiIndex.from_arrays([[1, 2], [3, 4]])\n        msg = \"initializing a Series from a MultiIndex is not supported\"\n        with pytest.raises(NotImplementedError, match=msg):\n            Series(m)\n\n    @pytest.mark.parametrize(\"input_class\", [list, dict, OrderedDict])\n    def test_constructor_empty(self, input_class):\n        with tm.assert_produces_warning(FutureWarning):\n            empty = Series()\n            empty2 = Series(input_class())\n\n        # these are Index() and RangeIndex() which don't compare type equal\n        # but are just .equals\n        tm.assert_series_equal(empty, empty2, check_index_type=False)\n\n        # With explicit dtype:\n        empty = Series(dtype=\"float64\")\n        empty2 = Series(input_class(), dtype=\"float64\")\n        tm.assert_series_equal(empty, empty2, check_index_type=False)\n\n        # GH 18515 : with dtype=category:\n        empty = Series(dtype=\"category\")\n        empty2 = Series(input_class(), dtype=\"category\")\n        tm.assert_series_equal(empty, empty2, check_index_type=False)\n\n        if input_class is not list:\n            # With index:\n            with tm.assert_produces_warning(FutureWarning):\n                empty = Series(index=range(10))\n                empty2 = Series(input_class(), index=range(10))\n            tm.assert_series_equal(empty, empty2)\n\n            # With index and dtype float64:\n            empty = Series(np.nan, index=range(10))\n            empty2 = Series(input_class(), index=range(10), dtype=\"float64\")\n            tm.assert_series_equal(empty, empty2)\n\n            # GH 19853 : with empty string, index and dtype str\n            empty = Series(\"\", dtype=str, index=range(3))\n            empty2 = Series(\"\", index=range(3))\n            tm.assert_series_equal(empty, empty2)\n\n    @pytest.mark.parametrize(\"input_arg\", [np.nan, float(\"nan\")])\n    def test_constructor_nan(self, input_arg):\n        empty = Series(dtype=\"float64\", index=range(10))\n        empty2 = Series(input_arg, index=range(10))\n\n        tm.assert_series_equal(empty, empty2, check_index_type=False)\n\n    @pytest.mark.parametrize(\n        \"dtype\",\n        [\"f8\", \"i8\", \"M8[ns]\", \"m8[ns]\", \"category\", \"object\", \"datetime64[ns, UTC]\"],\n    )\n    @pytest.mark.parametrize(\"index\", [None, Index([])])\n    def test_constructor_dtype_only(self, dtype, index):\n        # GH-20865\n        result = Series(dtype=dtype, index=index)\n        assert result.dtype == dtype\n        assert len(result) == 0\n\n    def test_constructor_no_data_index_order(self):\n        with tm.assert_produces_warning(FutureWarning):\n            result = Series(index=[\"b\", \"a\", \"c\"])\n        assert result.index.tolist() == [\"b\", \"a\", \"c\"]\n\n    def test_constructor_no_data_string_type(self):\n        # GH 22477\n        result = Series(index=[1], dtype=str)\n        assert np.isnan(result.iloc[0])\n\n    @pytest.mark.parametrize(\"item\", [\"entry\", \"ѐ\", 13])\n    def test_constructor_string_element_string_type(self, item):\n        # GH 22477\n        result = Series(item, index=[1], dtype=str)\n        assert result.iloc[0] == str(item)\n\n    def test_constructor_dtype_str_na_values(self, string_dtype):\n        # https://github.com/pandas-dev/pandas/issues/21083\n        ser = Series([\"x\", None], dtype=string_dtype)\n        result = ser.isna()\n        expected = Series([False, True])\n        tm.assert_series_equal(result, expected)\n        assert ser.iloc[1] is None\n\n        ser = Series([\"x\", np.nan], dtype=string_dtype)\n        assert np.isnan(ser.iloc[1])\n\n    def test_constructor_series(self):\n        index1 = [\"d\", \"b\", \"a\", \"c\"]\n        index2 = sorted(index1)\n        s1 = Series([4, 7, -5, 3], index=index1)\n        s2 = Series(s1, index=index2)\n\n        tm.assert_series_equal(s2, s1.sort_index())\n\n    def test_constructor_iterable(self):\n        # GH 21987\n        class Iter:\n            def __iter__(self):\n                yield from range(10)\n\n        expected = Series(list(range(10)), dtype=\"int64\")\n        result = Series(Iter(), dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_sequence(self):\n        # GH 21987\n        expected = Series(list(range(10)), dtype=\"int64\")\n        result = Series(range(10), dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_single_str(self):\n        # GH 21987\n        expected = Series([\"abc\"])\n        result = Series(\"abc\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_list_like(self):\n\n        # make sure that we are coercing different\n        # list-likes to standard dtypes and not\n        # platform specific\n        expected = Series([1, 2, 3], dtype=\"int64\")\n        for obj in [[1, 2, 3], (1, 2, 3), np.array([1, 2, 3], dtype=\"int64\")]:\n            result = Series(obj, index=[0, 1, 2])\n            tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"dtype\", [\"bool\", \"int32\", \"int64\", \"float64\"])\n    def test_constructor_index_dtype(self, dtype):\n        # GH 17088\n\n        s = Series(Index([0, 2, 4]), dtype=dtype)\n        assert s.dtype == dtype\n\n    @pytest.mark.parametrize(\n        \"input_vals\",\n        [\n            ([1, 2]),\n            ([\"1\", \"2\"]),\n            (list(date_range(\"1/1/2011\", periods=2, freq=\"H\"))),\n            (list(date_range(\"1/1/2011\", periods=2, freq=\"H\", tz=\"US/Eastern\"))),\n            ([Interval(left=0, right=5)]),\n        ],\n    )\n    def test_constructor_list_str(self, input_vals, string_dtype):\n        # GH 16605\n        # Ensure that data elements from a list are converted to strings\n        # when dtype is str, 'str', or 'U'\n        result = Series(input_vals, dtype=string_dtype)\n        expected = Series(input_vals).astype(string_dtype)\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_list_str_na(self, string_dtype):\n        result = Series([1.0, 2.0, np.nan], dtype=string_dtype)\n        expected = Series([\"1.0\", \"2.0\", np.nan], dtype=object)\n        tm.assert_series_equal(result, expected)\n        assert np.isnan(result[2])\n\n    def test_constructor_generator(self):\n        gen = (i for i in range(10))\n\n        result = Series(gen)\n        exp = Series(range(10))\n        tm.assert_series_equal(result, exp)\n\n        # same but with non-default index\n        gen = (i for i in range(10))\n        result = Series(gen, index=range(10, 20))\n        exp.index = range(10, 20)\n        tm.assert_series_equal(result, exp)\n\n    def test_constructor_map(self):\n        # GH8909\n        m = map(lambda x: x, range(10))\n\n        result = Series(m)\n        exp = Series(range(10))\n        tm.assert_series_equal(result, exp)\n\n        # same but with non-default index\n        m = map(lambda x: x, range(10))\n        result = Series(m, index=range(10, 20))\n        exp.index = range(10, 20)\n        tm.assert_series_equal(result, exp)\n\n    def test_constructor_categorical(self):\n        cat = Categorical([0, 1, 2, 0, 1, 2], [\"a\", \"b\", \"c\"], fastpath=True)\n        res = Series(cat)\n        tm.assert_categorical_equal(res.values, cat)\n\n        # can cast to a new dtype\n        result = Series(Categorical([1, 2, 3]), dtype=\"int64\")\n        expected = Series([1, 2, 3], dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n    def test_construct_from_categorical_with_dtype(self):\n        # GH12574\n        cat = Series(Categorical([1, 2, 3]), dtype=\"category\")\n        assert is_categorical_dtype(cat)\n        assert is_categorical_dtype(cat.dtype)\n\n    def test_construct_intlist_values_category_dtype(self):\n        ser = Series([1, 2, 3], dtype=\"category\")\n        assert is_categorical_dtype(ser)\n        assert is_categorical_dtype(ser.dtype)\n\n    def test_constructor_categorical_with_coercion(self):\n        factor = Categorical([\"a\", \"b\", \"b\", \"a\", \"a\", \"c\", \"c\", \"c\"])\n        # test basic creation / coercion of categoricals\n        s = Series(factor, name=\"A\")\n        assert s.dtype == \"category\"\n        assert len(s) == len(factor)\n        str(s.values)\n        str(s)\n\n        # in a frame\n        df = DataFrame({\"A\": factor})\n        result = df[\"A\"]\n        tm.assert_series_equal(result, s)\n        result = df.iloc[:, 0]\n        tm.assert_series_equal(result, s)\n        assert len(df) == len(factor)\n        str(df.values)\n        str(df)\n\n        df = DataFrame({\"A\": s})\n        result = df[\"A\"]\n        tm.assert_series_equal(result, s)\n        assert len(df) == len(factor)\n        str(df.values)\n        str(df)\n\n        # multiples\n        df = DataFrame({\"A\": s, \"B\": s, \"C\": 1})\n        result1 = df[\"A\"]\n        result2 = df[\"B\"]\n        tm.assert_series_equal(result1, s)\n        tm.assert_series_equal(result2, s, check_names=False)\n        assert result2.name == \"B\"\n        assert len(df) == len(factor)\n        str(df.values)\n        str(df)\n\n    def test_constructor_categorical_with_coercion2(self):\n        # GH8623\n        x = DataFrame(\n            [[1, \"John P. Doe\"], [2, \"Jane Dove\"], [1, \"John P. Doe\"]],\n            columns=[\"person_id\", \"person_name\"],\n        )\n        x[\"person_name\"] = Categorical(x.person_name)  # doing this breaks transform\n\n        expected = x.iloc[0].person_name\n        result = x.person_name.iloc[0]\n        assert result == expected\n\n        result = x.person_name[0]\n        assert result == expected\n\n        result = x.person_name.loc[0]\n        assert result == expected\n\n    def test_constructor_series_to_categorical(self):\n        # see GH#16524: test conversion of Series to Categorical\n        series = Series([\"a\", \"b\", \"c\"])\n\n        result = Series(series, dtype=\"category\")\n        expected = Series([\"a\", \"b\", \"c\"], dtype=\"category\")\n\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_categorical_dtype(self):\n        result = Series(\n            [\"a\", \"b\"], dtype=CategoricalDtype([\"a\", \"b\", \"c\"], ordered=True)\n        )\n        assert is_categorical_dtype(result.dtype) is True\n        tm.assert_index_equal(result.cat.categories, Index([\"a\", \"b\", \"c\"]))\n        assert result.cat.ordered\n\n        result = Series([\"a\", \"b\"], dtype=CategoricalDtype([\"b\", \"a\"]))\n        assert is_categorical_dtype(result.dtype)\n        tm.assert_index_equal(result.cat.categories, Index([\"b\", \"a\"]))\n        assert result.cat.ordered is False\n\n        # GH 19565 - Check broadcasting of scalar with Categorical dtype\n        result = Series(\n            \"a\", index=[0, 1], dtype=CategoricalDtype([\"a\", \"b\"], ordered=True)\n        )\n        expected = Series(\n            [\"a\", \"a\"], index=[0, 1], dtype=CategoricalDtype([\"a\", \"b\"], ordered=True)\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_categorical_string(self):\n        # GH 26336: the string 'category' maintains existing CategoricalDtype\n        cdt = CategoricalDtype(categories=list(\"dabc\"), ordered=True)\n        expected = Series(list(\"abcabc\"), dtype=cdt)\n\n        # Series(Categorical, dtype='category') keeps existing dtype\n        cat = Categorical(list(\"abcabc\"), dtype=cdt)\n        result = Series(cat, dtype=\"category\")\n        tm.assert_series_equal(result, expected)\n\n        # Series(Series[Categorical], dtype='category') keeps existing dtype\n        result = Series(result, dtype=\"category\")\n        tm.assert_series_equal(result, expected)\n\n    def test_categorical_sideeffects_free(self):\n        # Passing a categorical to a Series and then changing values in either\n        # the series or the categorical should not change the values in the\n        # other one, IF you specify copy!\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        s = Series(cat, copy=True)\n        assert s.cat is not cat\n        s.cat.categories = [1, 2, 3]\n        exp_s = np.array([1, 2, 3, 1], dtype=np.int64)\n        exp_cat = np.array([\"a\", \"b\", \"c\", \"a\"], dtype=np.object_)\n        tm.assert_numpy_array_equal(s.__array__(), exp_s)\n        tm.assert_numpy_array_equal(cat.__array__(), exp_cat)\n\n        # setting\n        s[0] = 2\n        exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(s.__array__(), exp_s2)\n        tm.assert_numpy_array_equal(cat.__array__(), exp_cat)\n\n        # however, copy is False by default\n        # so this WILL change values\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        s = Series(cat)\n        assert s.values is cat\n        s.cat.categories = [1, 2, 3]\n        exp_s = np.array([1, 2, 3, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(s.__array__(), exp_s)\n        tm.assert_numpy_array_equal(cat.__array__(), exp_s)\n\n        s[0] = 2\n        exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(s.__array__(), exp_s2)\n        tm.assert_numpy_array_equal(cat.__array__(), exp_s2)\n\n    def test_unordered_compare_equal(self):\n        left = Series([\"a\", \"b\", \"c\"], dtype=CategoricalDtype([\"a\", \"b\"]))\n        right = Series(Categorical([\"a\", \"b\", np.nan], categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(left, right)\n\n    def test_constructor_maskedarray(self):\n        data = ma.masked_all((3,), dtype=float)\n        result = Series(data)\n        expected = Series([np.nan, np.nan, np.nan])\n        tm.assert_series_equal(result, expected)\n\n        data[0] = 0.0\n        data[2] = 2.0\n        index = [\"a\", \"b\", \"c\"]\n        result = Series(data, index=index)\n        expected = Series([0.0, np.nan, 2.0], index=index)\n        tm.assert_series_equal(result, expected)\n\n        data[1] = 1.0\n        result = Series(data, index=index)\n        expected = Series([0.0, 1.0, 2.0], index=index)\n        tm.assert_series_equal(result, expected)\n\n        data = ma.masked_all((3,), dtype=int)\n        result = Series(data)\n        expected = Series([np.nan, np.nan, np.nan], dtype=float)\n        tm.assert_series_equal(result, expected)\n\n        data[0] = 0\n        data[2] = 2\n        index = [\"a\", \"b\", \"c\"]\n        result = Series(data, index=index)\n        expected = Series([0, np.nan, 2], index=index, dtype=float)\n        tm.assert_series_equal(result, expected)\n\n        data[1] = 1\n        result = Series(data, index=index)\n        expected = Series([0, 1, 2], index=index, dtype=int)\n        tm.assert_series_equal(result, expected)\n\n        data = ma.masked_all((3,), dtype=bool)\n        result = Series(data)\n        expected = Series([np.nan, np.nan, np.nan], dtype=object)\n        tm.assert_series_equal(result, expected)\n\n        data[0] = True\n        data[2] = False\n        index = [\"a\", \"b\", \"c\"]\n        result = Series(data, index=index)\n        expected = Series([True, np.nan, False], index=index, dtype=object)\n        tm.assert_series_equal(result, expected)\n\n        data[1] = True\n        result = Series(data, index=index)\n        expected = Series([True, True, False], index=index, dtype=bool)\n        tm.assert_series_equal(result, expected)\n\n        data = ma.masked_all((3,), dtype=\"M8[ns]\")\n        result = Series(data)\n        expected = Series([iNaT, iNaT, iNaT], dtype=\"M8[ns]\")\n        tm.assert_series_equal(result, expected)\n\n        data[0] = datetime(2001, 1, 1)\n        data[2] = datetime(2001, 1, 3)\n        index = [\"a\", \"b\", \"c\"]\n        result = Series(data, index=index)\n        expected = Series(\n            [datetime(2001, 1, 1), iNaT, datetime(2001, 1, 3)],\n            index=index,\n            dtype=\"M8[ns]\",\n        )\n        tm.assert_series_equal(result, expected)\n\n        data[1] = datetime(2001, 1, 2)\n        result = Series(data, index=index)\n        expected = Series(\n            [datetime(2001, 1, 1), datetime(2001, 1, 2), datetime(2001, 1, 3)],\n            index=index,\n            dtype=\"M8[ns]\",\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_maskedarray_hardened(self):\n        # Check numpy masked arrays with hard masks -- from GH24574\n        data = ma.masked_all((3,), dtype=float).harden_mask()\n        result = Series(data)\n        expected = Series([np.nan, np.nan, np.nan])\n        tm.assert_series_equal(result, expected)\n\n    def test_series_ctor_plus_datetimeindex(self):\n        rng = date_range(\"20090415\", \"20090519\", freq=\"B\")\n        data = {k: 1 for k in rng}\n\n        result = Series(data, index=rng)\n        assert result.index is rng\n\n    def test_constructor_default_index(self):\n        s = Series([0, 1, 2])\n        tm.assert_index_equal(s.index, Index(range(3)), exact=True)\n\n    @pytest.mark.parametrize(\n        \"input\",\n        [\n            [1, 2, 3],\n            (1, 2, 3),\n            list(range(3)),\n            Categorical([\"a\", \"b\", \"a\"]),\n            (i for i in range(3)),\n            map(lambda x: x, range(3)),\n        ],\n    )\n    def test_constructor_index_mismatch(self, input):\n        # GH 19342\n        # test that construction of a Series with an index of different length\n        # raises an error\n        msg = r\"Length of values \\(3\\) does not match length of index \\(4\\)\"\n        with pytest.raises(ValueError, match=msg):\n            Series(input, index=np.arange(4))\n\n    def test_constructor_numpy_scalar(self):\n        # GH 19342\n        # construction with a numpy scalar\n        # should not raise\n        result = Series(np.array(100), index=np.arange(4), dtype=\"int64\")\n        expected = Series(100, index=np.arange(4), dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_broadcast_list(self):\n        # GH 19342\n        # construction with single-element container and index\n        # should raise\n        msg = r\"Length of values \\(1\\) does not match length of index \\(3\\)\"\n        with pytest.raises(ValueError, match=msg):\n            Series([\"foo\"], index=[\"a\", \"b\", \"c\"])\n\n    def test_constructor_corner(self):\n        df = tm.makeTimeDataFrame()\n        objs = [df, df]\n        s = Series(objs, index=[0, 1])\n        assert isinstance(s, Series)\n\n    def test_constructor_sanitize(self):\n        s = Series(np.array([1.0, 1.0, 8.0]), dtype=\"i8\")\n        assert s.dtype == np.dtype(\"i8\")\n\n        s = Series(np.array([1.0, 1.0, np.nan]), copy=True, dtype=\"i8\")\n        assert s.dtype == np.dtype(\"f8\")\n\n    def test_constructor_copy(self):\n        # GH15125\n        # test dtype parameter has no side effects on copy=True\n        for data in [[1.0], np.array([1.0])]:\n            x = Series(data)\n            y = Series(x, copy=True, dtype=float)\n\n            # copy=True maintains original data in Series\n            tm.assert_series_equal(x, y)\n\n            # changes to origin of copy does not affect the copy\n            x[0] = 2.0\n            assert not x.equals(y)\n            assert x[0] == 2.0\n            assert y[0] == 1.0\n\n    @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite test\n    @pytest.mark.parametrize(\n        \"index\",\n        [\n            date_range(\"20170101\", periods=3, tz=\"US/Eastern\"),\n            date_range(\"20170101\", periods=3),\n            timedelta_range(\"1 day\", periods=3),\n            period_range(\"2012Q1\", periods=3, freq=\"Q\"),\n            Index(list(\"abc\")),\n            Int64Index([1, 2, 3]),\n            RangeIndex(0, 3),\n        ],\n        ids=lambda x: type(x).__name__,\n    )\n    def test_constructor_limit_copies(self, index):\n        # GH 17449\n        # limit copies of input\n        s = Series(index)\n\n        # we make 1 copy; this is just a smoke test here\n        assert s._mgr.blocks[0].values is not index\n\n    def test_constructor_pass_none(self):\n        with tm.assert_produces_warning(FutureWarning):\n            s = Series(None, index=range(5))\n        assert s.dtype == np.float64\n\n        s = Series(None, index=range(5), dtype=object)\n        assert s.dtype == np.object_\n\n        # GH 7431\n        # inference on the index\n        with tm.assert_produces_warning(FutureWarning):\n            s = Series(index=np.array([None]))\n            expected = Series(index=Index([None]))\n        tm.assert_series_equal(s, expected)\n\n    def test_constructor_pass_nan_nat(self):\n        # GH 13467\n        exp = Series([np.nan, np.nan], dtype=np.float64)\n        assert exp.dtype == np.float64\n        tm.assert_series_equal(Series([np.nan, np.nan]), exp)\n        tm.assert_series_equal(Series(np.array([np.nan, np.nan])), exp)\n\n        exp = Series([NaT, NaT])\n        assert exp.dtype == \"datetime64[ns]\"\n        tm.assert_series_equal(Series([NaT, NaT]), exp)\n        tm.assert_series_equal(Series(np.array([NaT, NaT])), exp)\n\n        tm.assert_series_equal(Series([NaT, np.nan]), exp)\n        tm.assert_series_equal(Series(np.array([NaT, np.nan])), exp)\n\n        tm.assert_series_equal(Series([np.nan, NaT]), exp)\n        tm.assert_series_equal(Series(np.array([np.nan, NaT])), exp)\n\n    def test_constructor_cast(self):\n        msg = \"could not convert string to float\"\n        with pytest.raises(ValueError, match=msg):\n            Series([\"a\", \"b\", \"c\"], dtype=float)\n\n    def test_constructor_signed_int_overflow_deprecation(self):\n        # GH#41734 disallow silent overflow\n        msg = \"Values are too large to be losslessly cast\"\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([1, 200, 923442], dtype=\"int8\")\n\n        expected = Series([1, -56, 50], dtype=\"int8\")\n        tm.assert_series_equal(ser, expected)\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([1, 200, 923442], dtype=\"uint8\")\n\n        expected = Series([1, 200, 50], dtype=\"uint8\")\n        tm.assert_series_equal(ser, expected)\n\n    def test_constructor_unsigned_dtype_overflow(self, any_unsigned_int_numpy_dtype):\n        # see gh-15832\n        msg = \"Trying to coerce negative values to unsigned integers\"\n        with pytest.raises(OverflowError, match=msg):\n            Series([-1], dtype=any_unsigned_int_numpy_dtype)\n\n    def test_constructor_coerce_float_fail(self, any_int_numpy_dtype):\n        # see gh-15832\n        msg = \"Trying to coerce float values to integers\"\n        with pytest.raises(ValueError, match=msg):\n            Series([1, 2, 3.5], dtype=any_int_numpy_dtype)\n\n    def test_constructor_coerce_float_valid(self, float_numpy_dtype):\n        s = Series([1, 2, 3.5], dtype=float_numpy_dtype)\n        expected = Series([1, 2, 3.5]).astype(float_numpy_dtype)\n        tm.assert_series_equal(s, expected)\n\n    def test_constructor_invalid_coerce_ints_with_float_nan(self, any_int_numpy_dtype):\n        # GH 22585\n\n        msg = \"cannot convert float NaN to integer\"\n        with pytest.raises(ValueError, match=msg):\n            Series([1, 2, np.nan], dtype=any_int_numpy_dtype)\n\n    def test_constructor_dtype_no_cast(self):\n        # see gh-1572\n        s = Series([1, 2, 3])\n        s2 = Series(s, dtype=np.int64)\n\n        s2[1] = 5\n        assert s[1] == 5\n\n    def test_constructor_datelike_coercion(self):\n\n        # GH 9477\n        # incorrectly inferring on dateimelike looking when object dtype is\n        # specified\n        s = Series([Timestamp(\"20130101\"), \"NOV\"], dtype=object)\n        assert s.iloc[0] == Timestamp(\"20130101\")\n        assert s.iloc[1] == \"NOV\"\n        assert s.dtype == object\n\n    def test_constructor_datelike_coercion2(self):\n        # the dtype was being reset on the slicing and re-inferred to datetime\n        # even thought the blocks are mixed\n        belly = \"216 3T19\".split()\n        wing1 = \"2T15 4H19\".split()\n        wing2 = \"416 4T20\".split()\n        mat = pd.to_datetime(\"2016-01-22 2019-09-07\".split())\n        df = DataFrame({\"wing1\": wing1, \"wing2\": wing2, \"mat\": mat}, index=belly)\n\n        result = df.loc[\"3T19\"]\n        assert result.dtype == object\n        result = df.loc[\"216\"]\n        assert result.dtype == object\n\n    def test_constructor_mixed_int_and_timestamp(self, frame_or_series):\n        # specifically Timestamp with nanos, not datetimes\n        objs = [Timestamp(9), 10, NaT.value]\n        result = frame_or_series(objs, dtype=\"M8[ns]\")\n\n        expected = frame_or_series([Timestamp(9), Timestamp(10), NaT])\n        tm.assert_equal(result, expected)\n\n    def test_constructor_datetimes_with_nulls(self):\n        # gh-15869\n        for arr in [\n            np.array([None, None, None, None, datetime.now(), None]),\n            np.array([None, None, datetime.now(), None]),\n        ]:\n            result = Series(arr)\n            assert result.dtype == \"M8[ns]\"\n\n    def test_constructor_dtype_datetime64(self):\n\n        s = Series(iNaT, dtype=\"M8[ns]\", index=range(5))\n        assert isna(s).all()\n\n        # in theory this should be all nulls, but since\n        # we are not specifying a dtype is ambiguous\n        s = Series(iNaT, index=range(5))\n        assert not isna(s).all()\n\n        s = Series(np.nan, dtype=\"M8[ns]\", index=range(5))\n        assert isna(s).all()\n\n        s = Series([datetime(2001, 1, 2, 0, 0), iNaT], dtype=\"M8[ns]\")\n        assert isna(s[1])\n        assert s.dtype == \"M8[ns]\"\n\n        s = Series([datetime(2001, 1, 2, 0, 0), np.nan], dtype=\"M8[ns]\")\n        assert isna(s[1])\n        assert s.dtype == \"M8[ns]\"\n\n    def test_constructor_dtype_datetime64_10(self):\n        # GH3416\n        dates = [\n            np.datetime64(datetime(2013, 1, 1)),\n            np.datetime64(datetime(2013, 1, 2)),\n            np.datetime64(datetime(2013, 1, 3)),\n        ]\n\n        s = Series(dates)\n        assert s.dtype == \"M8[ns]\"\n\n        s.iloc[0] = np.nan\n        assert s.dtype == \"M8[ns]\"\n\n        # GH3414 related\n        expected = Series(\n            [datetime(2013, 1, 1), datetime(2013, 1, 2), datetime(2013, 1, 3)],\n            dtype=\"datetime64[ns]\",\n        )\n\n        result = Series(Series(dates).view(np.int64) / 1000000, dtype=\"M8[ms]\")\n        tm.assert_series_equal(result, expected)\n\n        result = Series(dates, dtype=\"datetime64[ns]\")\n        tm.assert_series_equal(result, expected)\n\n        expected = Series(\n            [NaT, datetime(2013, 1, 2), datetime(2013, 1, 3)], dtype=\"datetime64[ns]\"\n        )\n        result = Series([np.nan] + dates[1:], dtype=\"datetime64[ns]\")\n        tm.assert_series_equal(result, expected)\n\n        dts = Series(dates, dtype=\"datetime64[ns]\")\n\n        # valid astype\n        with tm.assert_produces_warning(FutureWarning):\n            # astype(np.int64) deprecated\n            dts.astype(\"int64\")\n\n        # invalid casting\n        msg = r\"cannot astype a datetimelike from \\[datetime64\\[ns\\]\\] to \\[int32\\]\"\n        with pytest.raises(TypeError, match=msg):\n            dts.astype(\"int32\")\n\n        # ints are ok\n        # we test with np.int64 to get similar results on\n        # windows / 32-bit platforms\n        with tm.assert_produces_warning(FutureWarning):\n            # astype(np.int64) deprecated\n            result = Series(dts, dtype=np.int64)\n            expected = Series(dts.astype(np.int64))\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dtype_datetime64_9(self):\n        # invalid dates can be help as object\n        result = Series([datetime(2, 1, 1)])\n        assert result[0] == datetime(2, 1, 1, 0, 0)\n\n        result = Series([datetime(3000, 1, 1)])\n        assert result[0] == datetime(3000, 1, 1, 0, 0)\n\n    def test_constructor_dtype_datetime64_8(self):\n        # don't mix types\n        result = Series([Timestamp(\"20130101\"), 1], index=[\"a\", \"b\"])\n        assert result[\"a\"] == Timestamp(\"20130101\")\n        assert result[\"b\"] == 1\n\n    def test_constructor_dtype_datetime64_7(self):\n        # GH6529\n        # coerce datetime64 non-ns properly\n        dates = date_range(\"01-Jan-2015\", \"01-Dec-2015\", freq=\"M\")\n        values2 = dates.view(np.ndarray).astype(\"datetime64[ns]\")\n        expected = Series(values2, index=dates)\n\n        for dtype in [\"s\", \"D\", \"ms\", \"us\", \"ns\"]:\n            values1 = dates.view(np.ndarray).astype(f\"M8[{dtype}]\")\n            result = Series(values1, dates)\n            tm.assert_series_equal(result, expected)\n\n        # GH 13876\n        # coerce to non-ns to object properly\n        expected = Series(values2, index=dates, dtype=object)\n        for dtype in [\"s\", \"D\", \"ms\", \"us\", \"ns\"]:\n            values1 = dates.view(np.ndarray).astype(f\"M8[{dtype}]\")\n            result = Series(values1, index=dates, dtype=object)\n            tm.assert_series_equal(result, expected)\n\n        # leave datetime.date alone\n        dates2 = np.array([d.date() for d in dates.to_pydatetime()], dtype=object)\n        series1 = Series(dates2, dates)\n        tm.assert_numpy_array_equal(series1.values, dates2)\n        assert series1.dtype == object\n\n    def test_constructor_dtype_datetime64_6(self):\n        # these will correctly infer a datetime\n        msg = \"containing strings is deprecated\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([None, NaT, \"2013-08-05 15:30:00.000001\"])\n        assert ser.dtype == \"datetime64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([np.nan, NaT, \"2013-08-05 15:30:00.000001\"])\n        assert ser.dtype == \"datetime64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([NaT, None, \"2013-08-05 15:30:00.000001\"])\n        assert ser.dtype == \"datetime64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([NaT, np.nan, \"2013-08-05 15:30:00.000001\"])\n        assert ser.dtype == \"datetime64[ns]\"\n\n    def test_constructor_dtype_datetime64_5(self):\n        # tz-aware (UTC and other tz's)\n        # GH 8411\n        dr = date_range(\"20130101\", periods=3)\n        assert Series(dr).iloc[0].tz is None\n        dr = date_range(\"20130101\", periods=3, tz=\"UTC\")\n        assert str(Series(dr).iloc[0].tz) == \"UTC\"\n        dr = date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n        assert str(Series(dr).iloc[0].tz) == \"US/Eastern\"\n\n    def test_constructor_dtype_datetime64_4(self):\n        # non-convertible\n        s = Series([1479596223000, -1479590, NaT])\n        assert s.dtype == \"object\"\n        assert s[2] is NaT\n        assert \"NaT\" in str(s)\n\n    def test_constructor_dtype_datetime64_3(self):\n        # if we passed a NaT it remains\n        s = Series([datetime(2010, 1, 1), datetime(2, 1, 1), NaT])\n        assert s.dtype == \"object\"\n        assert s[2] is NaT\n        assert \"NaT\" in str(s)\n\n    def test_constructor_dtype_datetime64_2(self):\n        # if we passed a nan it remains\n        s = Series([datetime(2010, 1, 1), datetime(2, 1, 1), np.nan])\n        assert s.dtype == \"object\"\n        assert s[2] is np.nan\n        assert \"NaN\" in str(s)\n\n    def test_constructor_with_datetime_tz(self):\n\n        # 8260\n        # support datetime64 with tz\n\n        dr = date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n        s = Series(dr)\n        assert s.dtype.name == \"datetime64[ns, US/Eastern]\"\n        assert s.dtype == \"datetime64[ns, US/Eastern]\"\n        assert is_datetime64tz_dtype(s.dtype)\n        assert \"datetime64[ns, US/Eastern]\" in str(s)\n\n        # export\n        result = s.values\n        assert isinstance(result, np.ndarray)\n        assert result.dtype == \"datetime64[ns]\"\n\n        exp = DatetimeIndex(result)\n        exp = exp.tz_localize(\"UTC\").tz_convert(tz=s.dt.tz)\n        tm.assert_index_equal(dr, exp)\n\n        # indexing\n        result = s.iloc[0]\n        assert result == Timestamp(\"2013-01-01 00:00:00-0500\", tz=\"US/Eastern\")\n        result = s[0]\n        assert result == Timestamp(\"2013-01-01 00:00:00-0500\", tz=\"US/Eastern\")\n\n        result = s[Series([True, True, False], index=s.index)]\n        tm.assert_series_equal(result, s[0:2])\n\n        result = s.iloc[0:1]\n        tm.assert_series_equal(result, Series(dr[0:1]))\n\n        # concat\n        result = pd.concat([s.iloc[0:1], s.iloc[1:]])\n        tm.assert_series_equal(result, s)\n\n        # short str\n        assert \"datetime64[ns, US/Eastern]\" in str(s)\n\n        # formatting with NaT\n        result = s.shift()\n        assert \"datetime64[ns, US/Eastern]\" in str(result)\n        assert \"NaT\" in str(result)\n\n        # long str\n        t = Series(date_range(\"20130101\", periods=1000, tz=\"US/Eastern\"))\n        assert \"datetime64[ns, US/Eastern]\" in str(t)\n\n        result = DatetimeIndex(s, freq=\"infer\")\n        tm.assert_index_equal(result, dr)\n\n    def test_constructor_with_datetime_tz4(self):\n        # inference\n        s = Series(\n            [\n                Timestamp(\"2013-01-01 13:00:00-0800\", tz=\"US/Pacific\"),\n                Timestamp(\"2013-01-02 14:00:00-0800\", tz=\"US/Pacific\"),\n            ]\n        )\n        assert s.dtype == \"datetime64[ns, US/Pacific]\"\n        assert lib.infer_dtype(s, skipna=True) == \"datetime64\"\n\n    def test_constructor_with_datetime_tz3(self):\n        s = Series(\n            [\n                Timestamp(\"2013-01-01 13:00:00-0800\", tz=\"US/Pacific\"),\n                Timestamp(\"2013-01-02 14:00:00-0800\", tz=\"US/Eastern\"),\n            ]\n        )\n        assert s.dtype == \"object\"\n        assert lib.infer_dtype(s, skipna=True) == \"datetime\"\n\n    def test_constructor_with_datetime_tz2(self):\n        # with all NaT\n        s = Series(NaT, index=[0, 1], dtype=\"datetime64[ns, US/Eastern]\")\n        expected = Series(DatetimeIndex([\"NaT\", \"NaT\"], tz=\"US/Eastern\"))\n        tm.assert_series_equal(s, expected)\n\n    @pytest.mark.parametrize(\"arr_dtype\", [np.int64, np.float64])\n    @pytest.mark.parametrize(\"dtype\", [\"M8\", \"m8\"])\n    @pytest.mark.parametrize(\"unit\", [\"ns\", \"us\", \"ms\", \"s\", \"h\", \"m\", \"D\"])\n    def test_construction_to_datetimelike_unit(self, arr_dtype, dtype, unit):\n        # tests all units\n        # gh-19223\n        dtype = f\"{dtype}[{unit}]\"\n        arr = np.array([1, 2, 3], dtype=arr_dtype)\n        s = Series(arr)\n        result = s.astype(dtype)\n        expected = Series(arr.astype(dtype))\n\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"arg\", [\"2013-01-01 00:00:00\", NaT, np.nan, None])\n    def test_constructor_with_naive_string_and_datetimetz_dtype(self, arg):\n        # GH 17415: With naive string\n        result = Series([arg], dtype=\"datetime64[ns, CET]\")\n        expected = Series(Timestamp(arg)).dt.tz_localize(\"CET\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_datetime64_bigendian(self):\n        # GH#30976\n        ms = np.datetime64(1, \"ms\")\n        arr = np.array([np.datetime64(1, \"ms\")], dtype=\">M8[ms]\")\n\n        result = Series(arr)\n        expected = Series([Timestamp(ms)])\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"interval_constructor\", [IntervalIndex, IntervalArray])\n    def test_construction_interval(self, interval_constructor):\n        # construction from interval & array of intervals\n        intervals = interval_constructor.from_breaks(np.arange(3), closed=\"right\")\n        result = Series(intervals)\n        assert result.dtype == \"interval[int64, right]\"\n        tm.assert_index_equal(Index(result.values), Index(intervals))\n\n    @pytest.mark.parametrize(\n        \"data_constructor\", [list, np.array], ids=[\"list\", \"ndarray[object]\"]\n    )\n    def test_constructor_infer_interval(self, data_constructor):\n        # GH 23563: consistent closed results in interval dtype\n        data = [Interval(0, 1), Interval(0, 2), None]\n        result = Series(data_constructor(data))\n        expected = Series(IntervalArray(data))\n        assert result.dtype == \"interval[float64, right]\"\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"data_constructor\", [list, np.array], ids=[\"list\", \"ndarray[object]\"]\n    )\n    def test_constructor_interval_mixed_closed(self, data_constructor):\n        # GH 23563: mixed closed results in object dtype (not interval dtype)\n        data = [Interval(0, 1, closed=\"both\"), Interval(0, 2, closed=\"neither\")]\n        result = Series(data_constructor(data))\n        assert result.dtype == object\n        assert result.tolist() == data\n\n    def test_construction_consistency(self):\n\n        # make sure that we are not re-localizing upon construction\n        # GH 14928\n        ser = Series(date_range(\"20130101\", periods=3, tz=\"US/Eastern\"))\n\n        result = Series(ser, dtype=ser.dtype)\n        tm.assert_series_equal(result, ser)\n\n        result = Series(ser.dt.tz_convert(\"UTC\"), dtype=ser.dtype)\n        tm.assert_series_equal(result, ser)\n\n        msg = \"will interpret the data as wall-times\"\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            # deprecate behavior inconsistent with DatetimeIndex GH#33401\n            result = Series(ser.values, dtype=ser.dtype)\n        tm.assert_series_equal(result, ser)\n\n        with tm.assert_produces_warning(None):\n            # one suggested alternative to the deprecated usage\n            middle = Series(ser.values).dt.tz_localize(\"UTC\")\n            result = middle.dt.tz_convert(ser.dtype.tz)\n        tm.assert_series_equal(result, ser)\n\n        with tm.assert_produces_warning(None):\n            # the other suggested alternative to the deprecated usage\n            result = Series(ser.values.view(\"int64\"), dtype=ser.dtype)\n        tm.assert_series_equal(result, ser)\n\n    @pytest.mark.parametrize(\n        \"data_constructor\", [list, np.array], ids=[\"list\", \"ndarray[object]\"]\n    )\n    def test_constructor_infer_period(self, data_constructor):\n        data = [Period(\"2000\", \"D\"), Period(\"2001\", \"D\"), None]\n        result = Series(data_constructor(data))\n        expected = Series(period_array(data))\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"Period[D]\"\n\n    @pytest.mark.xfail(reason=\"PeriodDtype Series not supported yet\")\n    def test_construct_from_ints_including_iNaT_scalar_period_dtype(self):\n        series = Series([0, 1000, 2000, pd._libs.iNaT], dtype=\"period[D]\")\n\n        val = series[3]\n        assert isna(val)\n\n        series[2] = val\n        assert isna(series[2])\n\n    def test_constructor_period_incompatible_frequency(self):\n        data = [Period(\"2000\", \"D\"), Period(\"2001\", \"A\")]\n        result = Series(data)\n        assert result.dtype == object\n        assert result.tolist() == data\n\n    def test_constructor_periodindex(self):\n        # GH7932\n        # converting a PeriodIndex when put in a Series\n\n        pi = period_range(\"20130101\", periods=5, freq=\"D\")\n        s = Series(pi)\n        assert s.dtype == \"Period[D]\"\n        expected = Series(pi.astype(object))\n        tm.assert_series_equal(s, expected)\n\n    def test_constructor_dict(self):\n        d = {\"a\": 0.0, \"b\": 1.0, \"c\": 2.0}\n\n        result = Series(d)\n        expected = Series(d, index=sorted(d.keys()))\n        tm.assert_series_equal(result, expected)\n\n        result = Series(d, index=[\"b\", \"c\", \"d\", \"a\"])\n        expected = Series([1, 2, np.nan, 0], index=[\"b\", \"c\", \"d\", \"a\"])\n        tm.assert_series_equal(result, expected)\n\n        pidx = tm.makePeriodIndex(100)\n        d = {pidx[0]: 0, pidx[1]: 1}\n        result = Series(d, index=pidx)\n        expected = Series(np.nan, pidx, dtype=np.float64)\n        expected.iloc[0] = 0\n        expected.iloc[1] = 1\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_list_value_explicit_dtype(self):\n        # GH 18625\n        d = {\"a\": [[2], [3], [4]]}\n        result = Series(d, index=[\"a\"], dtype=\"object\")\n        expected = Series(d, index=[\"a\"])\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_order(self):\n        # GH19018\n        # initialization ordering: by insertion order if python>= 3.6, else\n        # order by value\n        d = {\"b\": 1, \"a\": 0, \"c\": 2}\n        result = Series(d)\n        expected = Series([1, 0, 2], index=list(\"bac\"))\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_extension(self, ea_scalar_and_dtype):\n        ea_scalar, ea_dtype = ea_scalar_and_dtype\n        d = {\"a\": ea_scalar}\n        result = Series(d, index=[\"a\"])\n        expected = Series(ea_scalar, index=[\"a\"], dtype=ea_dtype)\n\n        assert result.dtype == ea_dtype\n\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"value\", [2, np.nan, None, float(\"nan\")])\n    def test_constructor_dict_nan_key(self, value):\n        # GH 18480\n        d = {1: \"a\", value: \"b\", float(\"nan\"): \"c\", 4: \"d\"}\n        result = Series(d).sort_values()\n        expected = Series([\"a\", \"b\", \"c\", \"d\"], index=[1, value, np.nan, 4])\n        tm.assert_series_equal(result, expected)\n\n        # MultiIndex:\n        d = {(1, 1): \"a\", (2, np.nan): \"b\", (3, value): \"c\"}\n        result = Series(d).sort_values()\n        expected = Series(\n            [\"a\", \"b\", \"c\"], index=Index([(1, 1), (2, np.nan), (3, value)])\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_datetime64_index(self):\n        # GH 9456\n\n        dates_as_str = [\"1984-02-19\", \"1988-11-06\", \"1989-12-03\", \"1990-03-15\"]\n        values = [42544017.198965244, 1234565, 40512335.181958228, -1]\n\n        def create_data(constructor):\n            return dict(zip((constructor(x) for x in dates_as_str), values))\n\n        data_datetime64 = create_data(np.datetime64)\n        data_datetime = create_data(lambda x: datetime.strptime(x, \"%Y-%m-%d\"))\n        data_Timestamp = create_data(Timestamp)\n\n        expected = Series(values, (Timestamp(x) for x in dates_as_str))\n\n        result_datetime64 = Series(data_datetime64)\n        result_datetime = Series(data_datetime)\n        result_Timestamp = Series(data_Timestamp)\n\n        tm.assert_series_equal(result_datetime64, expected)\n        tm.assert_series_equal(result_datetime, expected)\n        tm.assert_series_equal(result_Timestamp, expected)\n\n    def test_constructor_dict_tuple_indexer(self):\n        # GH 12948\n        data = {(1, 1, None): -1.0}\n        result = Series(data)\n        expected = Series(\n            -1.0, index=MultiIndex(levels=[[1], [1], [np.nan]], codes=[[0], [0], [-1]])\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_mapping(self, non_dict_mapping_subclass):\n        # GH 29788\n        ndm = non_dict_mapping_subclass({3: \"three\"})\n        result = Series(ndm)\n        expected = Series([\"three\"], index=[3])\n\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_list_of_tuples(self):\n        data = [(1, 1), (2, 2), (2, 3)]\n        s = Series(data)\n        assert list(s) == data\n\n    def test_constructor_tuple_of_tuples(self):\n        data = ((1, 1), (2, 2), (2, 3))\n        s = Series(data)\n        assert tuple(s) == data\n\n    def test_constructor_dict_of_tuples(self):\n        data = {(1, 2): 3, (None, 5): 6}\n        result = Series(data).sort_values()\n        expected = Series([3, 6], index=MultiIndex.from_tuples([(1, 2), (None, 5)]))\n        tm.assert_series_equal(result, expected)\n\n    # https://github.com/pandas-dev/pandas/issues/22698\n    @pytest.mark.filterwarnings(\"ignore:elementwise comparison:FutureWarning\")\n    def test_fromDict(self):\n        data = {\"a\": 0, \"b\": 1, \"c\": 2, \"d\": 3}\n\n        series = Series(data)\n        tm.assert_is_sorted(series.index)\n\n        data = {\"a\": 0, \"b\": \"1\", \"c\": \"2\", \"d\": datetime.now()}\n        series = Series(data)\n        assert series.dtype == np.object_\n\n        data = {\"a\": 0, \"b\": \"1\", \"c\": \"2\", \"d\": \"3\"}\n        series = Series(data)\n        assert series.dtype == np.object_\n\n        data = {\"a\": \"0\", \"b\": \"1\"}\n        series = Series(data, dtype=float)\n        assert series.dtype == np.float64\n\n    def test_fromValue(self, datetime_series):\n\n        nans = Series(np.NaN, index=datetime_series.index, dtype=np.float64)\n        assert nans.dtype == np.float_\n        assert len(nans) == len(datetime_series)\n\n        strings = Series(\"foo\", index=datetime_series.index)\n        assert strings.dtype == np.object_\n        assert len(strings) == len(datetime_series)\n\n        d = datetime.now()\n        dates = Series(d, index=datetime_series.index)\n        assert dates.dtype == \"M8[ns]\"\n        assert len(dates) == len(datetime_series)\n\n        # GH12336\n        # Test construction of categorical series from value\n        categorical = Series(0, index=datetime_series.index, dtype=\"category\")\n        expected = Series(0, index=datetime_series.index).astype(\"category\")\n        assert categorical.dtype == \"category\"\n        assert len(categorical) == len(datetime_series)\n        tm.assert_series_equal(categorical, expected)\n\n    def test_constructor_dtype_timedelta64(self):\n\n        # basic\n        td = Series([timedelta(days=i) for i in range(3)])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([timedelta(days=1)])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([timedelta(days=1), timedelta(days=2), np.timedelta64(1, \"s\")])\n\n        assert td.dtype == \"timedelta64[ns]\"\n\n        # mixed with NaT\n        td = Series([timedelta(days=1), NaT], dtype=\"m8[ns]\")\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([timedelta(days=1), np.nan], dtype=\"m8[ns]\")\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([np.timedelta64(300000000), NaT], dtype=\"m8[ns]\")\n        assert td.dtype == \"timedelta64[ns]\"\n\n        # improved inference\n        # GH5689\n        td = Series([np.timedelta64(300000000), NaT])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        # because iNaT is int, not coerced to timedelta\n        td = Series([np.timedelta64(300000000), iNaT])\n        assert td.dtype == \"object\"\n\n        td = Series([np.timedelta64(300000000), np.nan])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([NaT, np.timedelta64(300000000)])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        td = Series([np.timedelta64(1, \"s\")])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        # FIXME: dont leave commented-out\n        # these are frequency conversion astypes\n        # for t in ['s', 'D', 'us', 'ms']:\n        #    with pytest.raises(TypeError):\n        #        td.astype('m8[%s]' % t)\n\n        # valid astype\n        with tm.assert_produces_warning(FutureWarning):\n            # astype(int64) deprecated\n            td.astype(\"int64\")\n\n        # invalid casting\n        msg = r\"cannot astype a datetimelike from \\[timedelta64\\[ns\\]\\] to \\[int32\\]\"\n        with pytest.raises(TypeError, match=msg):\n            td.astype(\"int32\")\n\n        # this is an invalid casting\n        msg = \"|\".join(\n            [\n                \"Could not convert object to NumPy timedelta\",\n                \"Could not convert 'foo' to NumPy timedelta\",\n            ]\n        )\n        with pytest.raises(ValueError, match=msg):\n            Series([timedelta(days=1), \"foo\"], dtype=\"m8[ns]\")\n\n        # leave as object here\n        td = Series([timedelta(days=i) for i in range(3)] + [\"foo\"])\n        assert td.dtype == \"object\"\n\n        # these will correctly infer a timedelta\n        msg = \"containing strings is deprecated\"\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([None, NaT, \"1 Day\"])\n        assert ser.dtype == \"timedelta64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([np.nan, NaT, \"1 Day\"])\n        assert ser.dtype == \"timedelta64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([NaT, None, \"1 Day\"])\n        assert ser.dtype == \"timedelta64[ns]\"\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            ser = Series([NaT, np.nan, \"1 Day\"])\n        assert ser.dtype == \"timedelta64[ns]\"\n\n    # GH 16406\n    def test_constructor_mixed_tz(self):\n        s = Series([Timestamp(\"20130101\"), Timestamp(\"20130101\", tz=\"US/Eastern\")])\n        expected = Series(\n            [Timestamp(\"20130101\"), Timestamp(\"20130101\", tz=\"US/Eastern\")],\n            dtype=\"object\",\n        )\n        tm.assert_series_equal(s, expected)\n\n    def test_NaT_scalar(self):\n        series = Series([0, 1000, 2000, iNaT], dtype=\"M8[ns]\")\n\n        val = series[3]\n        assert isna(val)\n\n        series[2] = val\n        assert isna(series[2])\n\n    def test_NaT_cast(self):\n        # GH10747\n        result = Series([np.nan]).astype(\"M8[ns]\")\n        expected = Series([NaT])\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_name_hashable(self):\n        for n in [777, 777.0, \"name\", datetime(2001, 11, 11), (1,), \"\\u05D0\"]:\n            for data in [[1, 2, 3], np.ones(3), {\"a\": 0, \"b\": 1}]:\n                s = Series(data, name=n)\n                assert s.name == n\n\n    def test_constructor_name_unhashable(self):\n        msg = r\"Series\\.name must be a hashable type\"\n        for n in [[\"name_list\"], np.ones(2), {1: 2}]:\n            for data in [[\"name_list\"], np.ones(2), {1: 2}]:\n                with pytest.raises(TypeError, match=msg):\n                    Series(data, name=n)\n\n    def test_auto_conversion(self):\n        series = Series(list(date_range(\"1/1/2000\", periods=10)))\n        assert series.dtype == \"M8[ns]\"\n\n    def test_convert_non_ns(self):\n        # convert from a numpy array of non-ns timedelta64\n        arr = np.array([1, 2, 3], dtype=\"timedelta64[s]\")\n        s = Series(arr)\n        expected = Series(timedelta_range(\"00:00:01\", periods=3, freq=\"s\"))\n        tm.assert_series_equal(s, expected)\n\n        # convert from a numpy array of non-ns datetime64\n        # note that creating a numpy datetime64 is in LOCAL time!!!!\n        # seems to work for M8[D], but not for M8[s]\n        # TODO: is the above comment still accurate/needed?\n\n        arr = np.array(\n            [\"2013-01-01\", \"2013-01-02\", \"2013-01-03\"], dtype=\"datetime64[D]\"\n        )\n        ser = Series(arr)\n        expected = Series(date_range(\"20130101\", periods=3, freq=\"D\"))\n        tm.assert_series_equal(ser, expected)\n\n        arr = np.array(\n            [\"2013-01-01 00:00:01\", \"2013-01-01 00:00:02\", \"2013-01-01 00:00:03\"],\n            dtype=\"datetime64[s]\",\n        )\n        ser = Series(arr)\n        expected = Series(date_range(\"20130101 00:00:01\", periods=3, freq=\"s\"))\n        tm.assert_series_equal(ser, expected)\n\n    @pytest.mark.parametrize(\n        \"index\",\n        [\n            date_range(\"1/1/2000\", periods=10),\n            timedelta_range(\"1 day\", periods=10),\n            period_range(\"2000-Q1\", periods=10, freq=\"Q\"),\n        ],\n        ids=lambda x: type(x).__name__,\n    )\n    def test_constructor_cant_cast_datetimelike(self, index):\n\n        # floats are not ok\n        # strip Index to convert PeriodIndex -> Period\n        # We don't care whether the error message says\n        # PeriodIndex or PeriodArray\n        msg = f\"Cannot cast {type(index).__name__.rstrip('Index')}.*? to \"\n\n        with pytest.raises(TypeError, match=msg):\n            Series(index, dtype=float)\n\n        # ints are ok\n        # we test with np.int64 to get similar results on\n        # windows / 32-bit platforms\n        with tm.assert_produces_warning(FutureWarning):\n            # asype(np.int64) deprecated, use .view(np.int64) instead\n            result = Series(index, dtype=np.int64)\n            expected = Series(index.astype(np.int64))\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"index\",\n        [\n            date_range(\"1/1/2000\", periods=10),\n            timedelta_range(\"1 day\", periods=10),\n            period_range(\"2000-Q1\", periods=10, freq=\"Q\"),\n        ],\n        ids=lambda x: type(x).__name__,\n    )\n    def test_constructor_cast_object(self, index):\n        s = Series(index, dtype=object)\n        exp = Series(index).astype(object)\n        tm.assert_series_equal(s, exp)\n\n        s = Series(Index(index, dtype=object), dtype=object)\n        exp = Series(index).astype(object)\n        tm.assert_series_equal(s, exp)\n\n        s = Series(index.astype(object), dtype=object)\n        exp = Series(index).astype(object)\n        tm.assert_series_equal(s, exp)\n\n    @pytest.mark.parametrize(\"dtype\", [np.datetime64, np.timedelta64])\n    def test_constructor_generic_timestamp_no_frequency(self, dtype, request):\n        # see gh-15524, gh-15987\n        msg = \"dtype has no unit. Please pass in\"\n\n        if np.dtype(dtype).name not in [\"timedelta64\", \"datetime64\"]:\n            mark = pytest.mark.xfail(reason=\"GH#33890 Is assigned ns unit\")\n            request.node.add_marker(mark)\n\n        with pytest.raises(ValueError, match=msg):\n            Series([], dtype=dtype)\n\n    @pytest.mark.parametrize(\n        \"dtype,msg\",\n        [\n            (\"m8[ps]\", \"cannot convert timedeltalike\"),\n            (\"M8[ps]\", \"cannot convert datetimelike\"),\n        ],\n    )\n    def test_constructor_generic_timestamp_bad_frequency(self, dtype, msg):\n        # see gh-15524, gh-15987\n\n        with pytest.raises(TypeError, match=msg):\n            Series([], dtype=dtype)\n\n    @pytest.mark.parametrize(\"dtype\", [None, \"uint8\", \"category\"])\n    def test_constructor_range_dtype(self, dtype):\n        # GH 16804\n        expected = Series([0, 1, 2, 3, 4], dtype=dtype or \"int64\")\n        result = Series(range(5), dtype=dtype)\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_range_overflows(self):\n        # GH#30173 range objects that overflow int64\n        rng = range(2 ** 63, 2 ** 63 + 4)\n        ser = Series(rng)\n        expected = Series(list(rng))\n        tm.assert_series_equal(ser, expected)\n        assert list(ser) == list(rng)\n        assert ser.dtype == np.uint64\n\n        rng2 = range(2 ** 63 + 4, 2 ** 63, -1)\n        ser2 = Series(rng2)\n        expected2 = Series(list(rng2))\n        tm.assert_series_equal(ser2, expected2)\n        assert list(ser2) == list(rng2)\n        assert ser2.dtype == np.uint64\n\n        rng3 = range(-(2 ** 63), -(2 ** 63) - 4, -1)\n        ser3 = Series(rng3)\n        expected3 = Series(list(rng3))\n        tm.assert_series_equal(ser3, expected3)\n        assert list(ser3) == list(rng3)\n        assert ser3.dtype == object\n\n        rng4 = range(2 ** 73, 2 ** 73 + 4)\n        ser4 = Series(rng4)\n        expected4 = Series(list(rng4))\n        tm.assert_series_equal(ser4, expected4)\n        assert list(ser4) == list(rng4)\n        assert ser4.dtype == object\n\n    def test_constructor_tz_mixed_data(self):\n        # GH 13051\n        dt_list = [\n            Timestamp(\"2016-05-01 02:03:37\"),\n            Timestamp(\"2016-04-30 19:03:37-0700\", tz=\"US/Pacific\"),\n        ]\n        result = Series(dt_list)\n        expected = Series(dt_list, dtype=object)\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"pydt\", [True, False])\n    def test_constructor_data_aware_dtype_naive(self, tz_aware_fixture, pydt):\n        # GH#25843, GH#41555, GH#33401\n        tz = tz_aware_fixture\n        ts = Timestamp(\"2019\", tz=tz)\n        if pydt:\n            ts = ts.to_pydatetime()\n        ts_naive = Timestamp(\"2019\")\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            result = Series([ts], dtype=\"datetime64[ns]\")\n        expected = Series([ts_naive])\n        tm.assert_series_equal(result, expected)\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            result = Series(np.array([ts], dtype=object), dtype=\"datetime64[ns]\")\n        tm.assert_series_equal(result, expected)\n\n        with tm.assert_produces_warning(FutureWarning):\n            result = Series({0: ts}, dtype=\"datetime64[ns]\")\n        tm.assert_series_equal(result, expected)\n\n        with tm.assert_produces_warning(FutureWarning):\n            result = Series(ts, index=[0], dtype=\"datetime64[ns]\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_datetime64(self):\n        rng = date_range(\"1/1/2000 00:00:00\", \"1/1/2000 1:59:50\", freq=\"10s\")\n        dates = np.asarray(rng)\n\n        series = Series(dates)\n        assert np.issubdtype(series.dtype, np.dtype(\"M8[ns]\"))\n\n    def test_constructor_datetimelike_scalar_to_string_dtype(\n        self, nullable_string_dtype\n    ):\n        # https://github.com/pandas-dev/pandas/pull/33846\n        result = Series(\"M\", index=[1, 2, 3], dtype=nullable_string_dtype)\n        expected = Series([\"M\", \"M\", \"M\"], index=[1, 2, 3], dtype=nullable_string_dtype)\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            [np.datetime64(\"2012-01-01\"), np.datetime64(\"2013-01-01\")],\n            [\"2012-01-01\", \"2013-01-01\"],\n        ],\n    )\n    def test_constructor_sparse_datetime64(self, values):\n        # https://github.com/pandas-dev/pandas/issues/35762\n        dtype = pd.SparseDtype(\"datetime64[ns]\")\n        result = Series(values, dtype=dtype)\n        arr = pd.arrays.SparseArray(values, dtype=dtype)\n        expected = Series(arr)\n        tm.assert_series_equal(result, expected)\n\n    def test_construction_from_ordered_collection(self):\n        # https://github.com/pandas-dev/pandas/issues/36044\n        result = Series({\"a\": 1, \"b\": 2}.keys())\n        expected = Series([\"a\", \"b\"])\n        tm.assert_series_equal(result, expected)\n\n        result = Series({\"a\": 1, \"b\": 2}.values())\n        expected = Series([1, 2])\n        tm.assert_series_equal(result, expected)\n\n    def test_construction_from_large_int_scalar_no_overflow(self):\n        # https://github.com/pandas-dev/pandas/issues/36291\n        n = 1_000_000_000_000_000_000_000\n        result = Series(n, index=[0])\n        expected = Series(n)\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_list_of_periods_infers_period_dtype(self):\n        series = Series(list(period_range(\"2000-01-01\", periods=10, freq=\"D\")))\n        assert series.dtype == \"Period[D]\"\n\n        series = Series(\n            [Period(\"2011-01-01\", freq=\"D\"), Period(\"2011-02-01\", freq=\"D\")]\n        )\n        assert series.dtype == \"Period[D]\"\n\n    def test_constructor_subclass_dict(self, dict_subclass):\n        data = dict_subclass((x, 10.0 * x) for x in range(10))\n        series = Series(data)\n        expected = Series(dict(data.items()))\n        tm.assert_series_equal(series, expected)\n\n    def test_constructor_ordereddict(self):\n        # GH3283\n        data = OrderedDict((f\"col{i}\", np.random.random()) for i in range(12))\n\n        series = Series(data)\n        expected = Series(list(data.values()), list(data.keys()))\n        tm.assert_series_equal(series, expected)\n\n        # Test with subclass\n        class A(OrderedDict):\n            pass\n\n        series = Series(A(data))\n        tm.assert_series_equal(series, expected)\n\n    def test_constructor_dict_multiindex(self):\n        d = {(\"a\", \"a\"): 0.0, (\"b\", \"a\"): 1.0, (\"b\", \"c\"): 2.0}\n        _d = sorted(d.items())\n        result = Series(d)\n        expected = Series(\n            [x[1] for x in _d], index=MultiIndex.from_tuples([x[0] for x in _d])\n        )\n        tm.assert_series_equal(result, expected)\n\n        d[\"z\"] = 111.0\n        _d.insert(0, (\"z\", d[\"z\"]))\n        result = Series(d)\n        expected = Series(\n            [x[1] for x in _d], index=Index([x[0] for x in _d], tupleize_cols=False)\n        )\n        result = result.reindex(index=expected.index)\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_multiindex_reindex_flat(self):\n        # construction involves reindexing with a MultiIndex corner case\n        data = {(\"i\", \"i\"): 0, (\"i\", \"j\"): 1, (\"j\", \"i\"): 2, \"j\": np.nan}\n        expected = Series(data)\n\n        result = Series(expected[:-1].to_dict(), index=expected.index)\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_dict_timedelta_index(self):\n        # GH #12169 : Resample category data with timedelta index\n        # construct Series from dict as data and TimedeltaIndex as index\n        # will result NaN in result Series data\n        expected = Series(\n            data=[\"A\", \"B\", \"C\"], index=pd.to_timedelta([0, 10, 20], unit=\"s\")\n        )\n\n        result = Series(\n            data={\n                pd.to_timedelta(0, unit=\"s\"): \"A\",\n                pd.to_timedelta(10, unit=\"s\"): \"B\",\n                pd.to_timedelta(20, unit=\"s\"): \"C\",\n            },\n            index=pd.to_timedelta([0, 10, 20], unit=\"s\"),\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_infer_index_tz(self):\n        values = [188.5, 328.25]\n        tzinfo = tzoffset(None, 7200)\n        index = [\n            datetime(2012, 5, 11, 11, tzinfo=tzinfo),\n            datetime(2012, 5, 11, 12, tzinfo=tzinfo),\n        ]\n        series = Series(data=values, index=index)\n\n        assert series.index.tz == tzinfo\n\n        # it works! GH#2443\n        repr(series.index[0])\n\n    def test_constructor_with_pandas_dtype(self):\n        # going through 2D->1D path\n        vals = [(1,), (2,), (3,)]\n        ser = Series(vals)\n        dtype = ser.array.dtype  # PandasDtype\n        ser2 = Series(vals, dtype=dtype)\n        tm.assert_series_equal(ser, ser2)\n\n    def test_constructor_int_dtype_missing_values(self):\n        # GH#43017\n        result = Series(index=[0], dtype=\"int64\")\n        expected = Series(np.nan, index=[0], dtype=\"float64\")\n        tm.assert_series_equal(result, expected)\n\n    def test_constructor_bool_dtype_missing_values(self):\n        # GH#43018\n        result = Series(index=[0], dtype=\"bool\")\n        expected = Series(True, index=[0], dtype=\"bool\")\n        tm.assert_series_equal(result, expected)\n\n\nclass TestSeriesConstructorIndexCoercion:\n    def test_series_constructor_datetimelike_index_coercion(self):\n        idx = tm.makeDateIndex(10000)\n        ser = Series(np.random.randn(len(idx)), idx.astype(object))\n        with tm.assert_produces_warning(FutureWarning):\n            assert ser.index.is_all_dates\n        assert isinstance(ser.index, DatetimeIndex)\n\n    def test_series_constructor_infer_multiindex(self):\n        index_lists = [[\"a\", \"a\", \"b\", \"b\"], [\"x\", \"y\", \"x\", \"y\"]]\n\n        multi = Series(1.0, index=[np.array(x) for x in index_lists])\n        assert isinstance(multi.index, MultiIndex)\n\n        multi = Series(1.0, index=index_lists)\n        assert isinstance(multi.index, MultiIndex)\n\n        multi = Series(range(4), index=index_lists)\n        assert isinstance(multi.index, MultiIndex)\n\n\nclass TestSeriesConstructorInternals:\n    def test_constructor_no_pandas_array(self, using_array_manager):\n        ser = Series([1, 2, 3])\n        result = Series(ser.array)\n        tm.assert_series_equal(ser, result)\n        if not using_array_manager:\n            assert isinstance(result._mgr.blocks[0], NumericBlock)\n\n    @td.skip_array_manager_invalid_test\n    def test_from_array(self):\n        result = Series(pd.array([\"1H\", \"2H\"], dtype=\"timedelta64[ns]\"))\n        assert result._mgr.blocks[0].is_extension is False\n\n        result = Series(pd.array([\"2015\"], dtype=\"datetime64[ns]\"))\n        assert result._mgr.blocks[0].is_extension is False\n\n    @td.skip_array_manager_invalid_test\n    def test_from_list_dtype(self):\n        result = Series([\"1H\", \"2H\"], dtype=\"timedelta64[ns]\")\n        assert result._mgr.blocks[0].is_extension is False\n\n        result = Series([\"2015\"], dtype=\"datetime64[ns]\")\n        assert result._mgr.blocks[0].is_extension is False\n\n\ndef test_constructor(rand_series_with_duplicate_datetimeindex):\n    dups = rand_series_with_duplicate_datetimeindex\n    assert isinstance(dups, Series)\n    assert isinstance(dups.index, DatetimeIndex)\n\n\n@pytest.mark.parametrize(\n    \"input_dict,expected\",\n    [\n        ({0: 0}, np.array([[0]], dtype=np.int64)),\n        ({\"a\": \"a\"}, np.array([[\"a\"]], dtype=object)),\n        ({1: 1}, np.array([[1]], dtype=np.int64)),\n    ],\n)\n@pytest.mark.skipif(np_version_under1p19, reason=\"fails on numpy below 1.19\")\ndef test_numpy_array(input_dict, expected):\n    result = np.array([Series(input_dict)])\n    tm.assert_numpy_array_equal(result, expected)\n\n\n@pytest.mark.skipif(\n    not np_version_under1p19, reason=\"check failure on numpy below 1.19\"\n)\ndef test_numpy_array_np_v1p19():\n    with pytest.raises(KeyError, match=\"0\"):\n        np.array([Series({1: 1})])\n"
    }
  ]
}