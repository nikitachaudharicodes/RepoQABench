{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "39203",
  "issue_description": "# STYLE: dont' use pd.api.types anywhere in tests\n\nexample here: https://github.com/pandas-dev/pandas/pull/37367/files#diff-69c698518ca64a05f8b137ff9bb5445ce9fd21139b396e9b0d4ce7338b2a3984R132\r\n\r\nwe should just ban this with a precommit style rule (and import things directly). the doc-strings also should be updated to do the import once.\r\n\r\n```\r\ngrep -r pd.api.types ~/pandas-dev/pandas\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar(dt)\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar([2, 3])\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar({0: 1, 2: 3})\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar((0, 2))\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar(Fraction(3, 5))\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:    if pd.api.types.is_extension_array_dtype(dtype) or isinstance(dtype, dict):\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:        pd.api.types.is_extension_array_dtype(dtype_a)\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:        or pd.api.types.is_extension_array_dtype(dtype_b)\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:    if pd.api.types.is_extension_array_dtype(dtype) or isinstance(dtype, dict):\r\n/home/jreback/pandas-dev/pandas/tests/extension/base/dtype.py:        return not pd.api.types.is_string_dtype(dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/base/dtype.py:        return not pd.api.types.is_object_dtype(dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/arrow/arrays.py:        if pd.api.types.is_scalar(item):\r\n/home/jreback/pandas-dev/pandas/tests/extension/arrow/test_bool.py:    assert pd.api.types.is_bool_dtype(data)\r\n/home/jreback/pandas-dev/pandas/tests/extension/json/array.py:            if pd.api.types.is_bool_dtype(item.dtype):\r\n/home/jreback/pandas-dev/pandas/tests/extension/decimal/array.py:        if pd.api.types.is_list_like(value):\r\n/home/jreback/pandas-dev/pandas/tests/extension/decimal/array.py:            if pd.api.types.is_scalar(key):\r\n/home/jreback/pandas-dev/pandas/tests/extension/list/array.py:        elif pd.api.types.is_string_dtype(dtype) and not pd.api.types.is_object_dtype(\r\n/home/jreback/pandas-dev/pandas/tests/extension/test_integer.py:                and pd.api.types.is_integer_dtype(other.dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/test_floating.py:                and pd.api.types.is_float_dtype(other.dtype)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(1)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(7.15)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(False)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(\"foo\")\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(\"5\")\r\n/home/jreback/pandas-dev/pandas/core/generic.py:        >>> cat_dtype = pd.api.types.CategoricalDtype(\r\n```",
  "issue_comments": [
    {
      "id": 761579403,
      "user": "nofarm3",
      "body": "Hi @jreback!\r\n\r\nTo make sure I get this right:\r\n1. Change it to be:\r\n`from pd.api.types import is_number`\r\nand then just use it in the test.\r\n2. add a precommit rule\r\n\r\n"
    },
    {
      "id": 761581083,
      "user": "nofarm3",
      "body": "take"
    },
    {
      "id": 761583977,
      "user": "MarcoGorelli",
      "body": "Hi @nofarm3 - I haven't tried this yet but I think you'll need `from pandas.api.types import ...` (rather than `from pd.api.types import ...`) - feel free to reach out if you want/need help with anything!"
    },
    {
      "id": 761584203,
      "user": "nofarm3",
      "body": "Thanks @MarcoGorelli  !"
    },
    {
      "id": 761601874,
      "user": "jorisvandenbossche",
      "body": ">  the doc-strings also should be updated to do the import once.\r\n\r\nHow do you want the docstrings changed? \r\nNote that those are public functions, and thus need to be documented using their public import (which is pd.api.types)\r\n\r\nIn addition, IMO we should keep all occurrences in `tests/extension` as is (or at least the ones in the array classes). Those tests are meant for external projects to use and adapt, and thus should use public APIs to the extent possible."
    },
    {
      "id": 761603458,
      "user": "jreback",
      "body": "the request is to simply import infer_dtype rather than use the long form\n"
    },
    {
      "id": 761603530,
      "user": "jreback",
      "body": "having a one off is -1"
    },
    {
      "id": 761605907,
      "user": "nofarm3",
      "body": "@jreback \r\nI want to make sure I fix it the way you expect (this is my first time):\r\n\r\nFor example:\r\n`if pd.api.types.is_integer_dtype(other.dtype):`\r\n\r\n\r\nI'll change it to be:\r\n```\r\nfrom pandas._libs import lib\r\nif lib.infer_dtype(other.dtype) == \"integer\":\r\n```\r\n\r\nOr\r\n```\r\nfrom pandas.api.types import is_integer_dtype\r\nif is_integer_dtype(other.dtype):\r\n```\r\n\r\nI guess the first option is correct, am I right?\r\nThanks\r\n"
    },
    {
      "id": 761607092,
      "user": "MarcoGorelli",
      "body": "@nofarm3 the fastest way to get feedback is usually to just open a pull request, even if you're not sure it's correct, reviewers can make suggestions there"
    },
    {
      "id": 761607262,
      "user": "jreback",
      "body": "pls use the public api (2nd way)"
    }
  ],
  "text_context": "# STYLE: dont' use pd.api.types anywhere in tests\n\nexample here: https://github.com/pandas-dev/pandas/pull/37367/files#diff-69c698518ca64a05f8b137ff9bb5445ce9fd21139b396e9b0d4ce7338b2a3984R132\r\n\r\nwe should just ban this with a precommit style rule (and import things directly). the doc-strings also should be updated to do the import once.\r\n\r\n```\r\ngrep -r pd.api.types ~/pandas-dev/pandas\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar(dt)\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar([2, 3])\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar({0: 1, 2: 3})\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar((0, 2))\r\n/home/jreback/pandas-dev/pandas/_libs/lib.pyx:    >>> pd.api.types.is_scalar(Fraction(3, 5))\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:    if pd.api.types.is_extension_array_dtype(dtype) or isinstance(dtype, dict):\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:        pd.api.types.is_extension_array_dtype(dtype_a)\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:        or pd.api.types.is_extension_array_dtype(dtype_b)\r\n/home/jreback/pandas-dev/pandas/tests/frame/test_ufunc.py:    if pd.api.types.is_extension_array_dtype(dtype) or isinstance(dtype, dict):\r\n/home/jreback/pandas-dev/pandas/tests/extension/base/dtype.py:        return not pd.api.types.is_string_dtype(dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/base/dtype.py:        return not pd.api.types.is_object_dtype(dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/arrow/arrays.py:        if pd.api.types.is_scalar(item):\r\n/home/jreback/pandas-dev/pandas/tests/extension/arrow/test_bool.py:    assert pd.api.types.is_bool_dtype(data)\r\n/home/jreback/pandas-dev/pandas/tests/extension/json/array.py:            if pd.api.types.is_bool_dtype(item.dtype):\r\n/home/jreback/pandas-dev/pandas/tests/extension/decimal/array.py:        if pd.api.types.is_list_like(value):\r\n/home/jreback/pandas-dev/pandas/tests/extension/decimal/array.py:            if pd.api.types.is_scalar(key):\r\n/home/jreback/pandas-dev/pandas/tests/extension/list/array.py:        elif pd.api.types.is_string_dtype(dtype) and not pd.api.types.is_object_dtype(\r\n/home/jreback/pandas-dev/pandas/tests/extension/test_integer.py:                and pd.api.types.is_integer_dtype(other.dtype)\r\n/home/jreback/pandas-dev/pandas/tests/extension/test_floating.py:                and pd.api.types.is_float_dtype(other.dtype)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(1)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(7.15)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(False)\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(\"foo\")\r\n/home/jreback/pandas-dev/pandas/core/dtypes/inference.py:    >>> pd.api.types.is_number(\"5\")\r\n/home/jreback/pandas-dev/pandas/core/generic.py:        >>> cat_dtype = pd.api.types.CategoricalDtype(\r\n```\n\nHi @jreback!\r\n\r\nTo make sure I get this right:\r\n1. Change it to be:\r\n`from pd.api.types import is_number`\r\nand then just use it in the test.\r\n2. add a precommit rule\r\n\r\n\n\ntake\n\nHi @nofarm3 - I haven't tried this yet but I think you'll need `from pandas.api.types import ...` (rather than `from pd.api.types import ...`) - feel free to reach out if you want/need help with anything!\n\nThanks @MarcoGorelli  !\n\n>  the doc-strings also should be updated to do the import once.\r\n\r\nHow do you want the docstrings changed? \r\nNote that those are public functions, and thus need to be documented using their public import (which is pd.api.types)\r\n\r\nIn addition, IMO we should keep all occurrences in `tests/extension` as is (or at least the ones in the array classes). Those tests are meant for external projects to use and adapt, and thus should use public APIs to the extent possible.\n\nthe request is to simply import infer_dtype rather than use the long form\n\n\nhaving a one off is -1\n\n@jreback \r\nI want to make sure I fix it the way you expect (this is my first time):\r\n\r\nFor example:\r\n`if pd.api.types.is_integer_dtype(other.dtype):`\r\n\r\n\r\nI'll change it to be:\r\n```\r\nfrom pandas._libs import lib\r\nif lib.infer_dtype(other.dtype) == \"integer\":\r\n```\r\n\r\nOr\r\n```\r\nfrom pandas.api.types import is_integer_dtype\r\nif is_integer_dtype(other.dtype):\r\n```\r\n\r\nI guess the first option is correct, am I right?\r\nThanks\r\n\n\n@nofarm3 the fastest way to get feedback is usually to just open a pull request, even if you're not sure it's correct, reviewers can make suggestions there\n\npls use the public api (2nd way)",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/37367",
  "code_context": [
    {
      "filename": "pandas/core/strings/accessor.py",
      "content": "import codecs\nfrom functools import wraps\nimport re\nfrom typing import Dict, List, Optional\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nfrom pandas.util._decorators import Appender\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n)\nfrom pandas.core.dtypes.generic import ABCDataFrame, ABCIndex, ABCMultiIndex, ABCSeries\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.base import NoNewAttributesMixin\n\n_shared_docs: Dict[str, str] = {}\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    f\"Cannot use .str.{func_name} with values of \"\n                    f\"inferred dtype '{self._inferred_dtype}'.\"\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _map_and_wrap(name, docstring):\n    @forbid_nonstring_types([\"bytes\"], name=name)\n    def wrapper(self):\n        result = getattr(self._data.array, f\"_str_{name}\")()\n        return self._wrap_result(result)\n\n    wrapper.__doc__ = docstring\n    return wrapper\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index.\n\n    NAs stay NA unless handled otherwise by a particular method.\n    Patterned after Python's string methods, with some inspiration from\n    R's stringr package.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"A_Str_Series\"])\n    >>> s\n    0    A_Str_Series\n    dtype: object\n\n    >>> s.str.split(\"_\")\n    0    [A, Str, Series]\n    dtype: object\n\n    >>> s.str.replace(\"_\", \"\")\n    0    AStrSeries\n    dtype: object\n    \"\"\"\n\n    # Note: see the docstring in pandas.core.strings.__init__\n    # for an explanation of the implementation.\n    # TODO: Dispatch all the methods\n    # Currently the following are not dispatched to the array\n    # * cat\n    # * extract\n    # * extractall\n\n    def __init__(self, data):\n        from pandas.core.arrays.string_ import StringDtype\n\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data.dtype)\n        self._is_string = isinstance(data.dtype, StringDtype)\n        self._data = data\n\n        self._index = self._name = None\n        if isinstance(data, ABCSeries):\n            self._index = data.index\n            self._name = data.name\n\n        # ._values.categories works for both Series/Index\n        self._parent = data._values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object, and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        from pandas import StringDtype\n\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # explicitly allow StringDtype\n        if isinstance(values.dtype, StringDtype):\n            return \"string\"\n\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        result = self._data.array._str_getitem(key)\n        return self._wrap_result(result)\n\n    def __iter__(self):\n        warnings.warn(\n            \"Columnar iteration over characters will be deprecated in future releases.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self,\n        result,\n        name=None,\n        expand=None,\n        fill_value=np.nan,\n        returns_string=True,\n    ):\n        from pandas import Index, MultiIndex\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            if isinstance(result, ABCDataFrame):\n                result = result.__finalize__(self._orig, name=\"str\")\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        # Ideally the array method returns the right array type.\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndex):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndex):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            # This is a mess.\n            dtype: Optional[str]\n            if self._is_string and returns_string:\n                dtype = \"string\"\n            else:\n                dtype = None\n\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index)\n            result = result.__finalize__(self._orig, method=\"str\")\n            if name is not None and result.ndim == 1:\n                # __finalize__ might copy over the original name, but we may\n                # want the new name (e.g. str.extract).\n                result.name = name\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n        from pandas import DataFrame, Series\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndex) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndex):\n            return [Series(others._values, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndex))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los: List[Series] = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarray \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        # TODO: dispatch\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndex):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError as err:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            ) from err\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndex):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            if is_categorical_dtype(self._orig.dtype):\n                # We need to infer the new categories.\n                dtype = None\n            else:\n                dtype = self._orig.dtype\n            result = Series(result, dtype=dtype, index=data.index, name=self._orig.name)\n            result = result.__finalize__(self._orig, method=\"str_cat\")\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the split strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series(\n    ...     [\n    ...         \"this is a regular sentence\",\n    ...         \"https://docs.python.org/3/tutorial/index.html\",\n    ...         np.nan\n    ...     ]\n    ... )\n    >>> s\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat=\"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3         4\n    0                                           this    is     a  regular  sentence\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None      None\n    2                                            NaN   NaN   NaN      NaN       NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n    >>> s\n    0    1+1=2\n    dtype: object\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = self._data.array._str_split(pat, n, expand)\n        return self._wrap_result(result, returns_string=expand, expand=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = self._data.array._str_rsplit(pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               )\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        result = self._data.array._str_partition(sep, expand)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        result = self._data.array._str_rpartition(sep, expand)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    def get(self, i):\n        \"\"\"\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Series/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Series or Index\n\n        Examples\n        --------\n        >>> s = pd.Series([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.get(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.get(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_get(i)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        \"\"\"\n        Join lists contained as elements in the Series/Index with passed delimiter.\n\n        If the elements of a Series are lists themselves, join the content of these\n        lists using the delimiter passed to the function.\n        This function is an equivalent to :meth:`str.join`.\n\n        Parameters\n        ----------\n        sep : str\n            Delimiter to use between list entries.\n\n        Returns\n        -------\n        Series/Index: object\n            The list entries concatenated by intervening occurrences of the\n            delimiter.\n\n        Raises\n        ------\n        AttributeError\n            If the supplied Series contains neither strings nor lists.\n\n        See Also\n        --------\n        str.join : Standard library version of this method.\n        Series.str.split : Split strings around given separator/delimiter.\n\n        Notes\n        -----\n        If any of the list items is not a string object, the result of the join\n        will be `NaN`.\n\n        Examples\n        --------\n        Example with a list that contains non-string elements.\n\n        >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n        ...                [1.1, 2.2, 3.3],\n        ...                ['cat', np.nan, 'dog'],\n        ...                ['cow', 4.5, 'goat'],\n        ...                ['duck', ['swan', 'fish'], 'guppy']])\n        >>> s\n        0        [lion, elephant, zebra]\n        1                [1.1, 2.2, 3.3]\n        2                [cat, nan, dog]\n        3               [cow, 4.5, goat]\n        4    [duck, [swan, fish], guppy]\n        dtype: object\n\n        Join all lists using a '-'. The lists containing object(s) of types other\n        than str will produce a NaN.\n\n        >>> s.str.join('-')\n        0    lion-elephant-zebra\n        1                    NaN\n        2                    NaN\n        3                    NaN\n        4                    NaN\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_join(sep)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=None, regex=True):\n        r\"\"\"\n        Test if pattern or regex is contained within a string of a Series or Index.\n\n        Return boolean Series or Index based on whether a given pattern or regex is\n        contained within a string of a Series or Index.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence or regular expression.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Flags to pass through to the re module, e.g. re.IGNORECASE.\n        na : scalar, optional\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,\n            ``pandas.NA`` is used.\n        regex : bool, default True\n            If True, assumes the pat is a regular expression.\n\n            If False, treats the pat as a literal string.\n\n        Returns\n        -------\n        Series or Index of boolean values\n            A Series or Index of boolean values indicating whether the\n            given pattern is contained within the string of each element\n            of the Series or Index.\n\n        See Also\n        --------\n        match : Analogous, but stricter, relying on re.match instead of re.search.\n        Series.str.startswith : Test if the start of each string element matches a\n            pattern.\n        Series.str.endswith : Same as startswith, but tests the end of string.\n\n        Examples\n        --------\n        Returning a Series of booleans using only a literal pattern.\n\n        >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n        >>> s1.str.contains('og', regex=False)\n        0    False\n        1     True\n        2    False\n        3    False\n        4      NaN\n        dtype: object\n\n        Returning an Index of booleans using only a literal pattern.\n\n        >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n        >>> ind.str.contains('23', regex=False)\n        Index([False, False, False, True, nan], dtype='object')\n\n        Specifying case sensitivity using `case`.\n\n        >>> s1.str.contains('oG', case=True, regex=True)\n        0    False\n        1    False\n        2    False\n        3    False\n        4      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN` replaces NaN values\n        with `False`. If Series or Index does not contain NaN values\n        the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n        >>> s1.str.contains('og', na=False, regex=True)\n        0    False\n        1     True\n        2    False\n        3    False\n        4    False\n        dtype: bool\n\n        Returning 'house' or 'dog' when either expression occurs in a string.\n\n        >>> s1.str.contains('house|dog', regex=True)\n        0    False\n        1     True\n        2     True\n        3    False\n        4      NaN\n        dtype: object\n\n        Ignoring case sensitivity using `flags` with regex.\n\n        >>> import re\n        >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n        0    False\n        1    False\n        2     True\n        3    False\n        4      NaN\n        dtype: object\n\n        Returning any digit using regular expression.\n\n        >>> s1.str.contains('\\\\d', regex=True)\n        0    False\n        1    False\n        2    False\n        3     True\n        4      NaN\n        dtype: object\n\n        Ensure `pat` is a not a literal pattern when `regex` is set to True.\n        Note in the following example one might expect only `s2[1]` and `s2[3]` to\n        return `True`. However, '.0' as a regex matches any character\n        followed by a 0.\n\n        >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n        >>> s2.str.contains('.0', regex=True)\n        0     True\n        1     True\n        2    False\n        3     True\n        4    False\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_contains(pat, case, flags, na, regex)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=None):\n        \"\"\"\n        Determine if each string starts with a match of a regular expression.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence or regular expression.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE.\n        na : scalar, optional\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,\n            ``pandas.NA`` is used.\n\n        Returns\n        -------\n        Series/array of boolean values\n\n        See Also\n        --------\n        fullmatch : Stricter matching that requires the entire string to match.\n        contains : Analogous, but less strict, relying on re.search instead of\n            re.match.\n        extract : Extract matched groups.\n        \"\"\"\n        result = self._data.array._str_match(pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def fullmatch(self, pat, case=True, flags=0, na=None):\n        \"\"\"\n        Determine if each string entirely matches a regular expression.\n\n        .. versionadded:: 1.1.0\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence or regular expression.\n        case : bool, default True\n            If True, case sensitive.\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE.\n        na : scalar, optional.\n            Fill value for missing values. The default depends on dtype of the\n            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``,\n            ``pandas.NA`` is used.\n\n        Returns\n        -------\n        Series/array of boolean values\n\n        See Also\n        --------\n        match : Similar, but also returns `True` when only a *prefix* of the string\n            matches the regular expression.\n        extract : Extract matched groups.\n        \"\"\"\n        result = self._data.array._str_fullmatch(pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=None):\n        r\"\"\"\n        Replace each occurrence of pattern/regex in the Series/Index.\n\n        Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on\n        the regex value.\n\n        Parameters\n        ----------\n        pat : str or compiled regex\n            String can be a character sequence or regular expression.\n        repl : str or callable\n            Replacement string or a callable. The callable is passed the regex\n            match object and must return a replacement string to be used.\n            See :func:`re.sub`.\n        n : int, default -1 (all)\n            Number of replacements to make from start.\n        case : bool, default None\n            Determines if replace is case sensitive:\n\n            - If True, case sensitive (the default if `pat` is a string)\n            - Set to False for case insensitive\n            - Cannot be set if `pat` is a compiled regex.\n\n        flags : int, default 0 (no flags)\n            Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n            regex.\n        regex : bool, default True\n            Determines if assumes the passed-in pattern is a regular expression:\n\n            - If True, assumes the passed-in pattern is a regular expression.\n            - If False, treats the pattern as a literal string\n            - Cannot be set to False if `pat` is a compiled regex or `repl` is\n              a callable.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        Series or Index of object\n            A copy of the object with all matching occurrences of `pat` replaced by\n            `repl`.\n\n        Raises\n        ------\n        ValueError\n            * if `regex` is False and `repl` is a callable or `pat` is a compiled\n              regex\n            * if `pat` is a compiled regex and `case` or `flags` is set\n\n        Notes\n        -----\n        When `pat` is a compiled regex, all flags should be included in the\n        compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n        regex will raise an error.\n\n        Examples\n        --------\n        When `pat` is a string and `regex` is True (the default), the given `pat`\n        is compiled as a regex. When `repl` is a string, it replaces matching\n        regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n        left as is:\n\n        >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n        0    bao\n        1    baz\n        2    NaN\n        dtype: object\n\n        When `pat` is a string and `regex` is False, every `pat` is replaced with\n        `repl` as with :meth:`str.replace`:\n\n        >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n        0    bao\n        1    fuz\n        2    NaN\n        dtype: object\n\n        When `repl` is a callable, it is called on every `pat` using\n        :func:`re.sub`. The callable should expect one positional argument\n        (a regex object) and return a string.\n\n        To get the idea:\n\n        >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n        0    <re.Match object; span=(0, 1), match='f'>oo\n        1    <re.Match object; span=(0, 1), match='f'>uz\n        2                                            NaN\n        dtype: object\n\n        Reverse every lowercase alphabetic word:\n\n        >>> repl = lambda m: m.group(0)[::-1]\n        >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n        0    oof 123\n        1    rab zab\n        2        NaN\n        dtype: object\n\n        Using regex groups (extract second group and swap case):\n\n        >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n        >>> repl = lambda m: m.group('two').swapcase()\n        >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n        0    tWO\n        1    bAR\n        dtype: object\n\n        Using a compiled regex with flags\n\n        >>> import re\n        >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n        >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n        0    foo\n        1    bar\n        2    NaN\n        dtype: object\n        \"\"\"\n        if regex is None:\n            if isinstance(pat, str) and any(c in pat for c in \".+*|^$?[](){}\\\\\"):\n                # warn only in cases where regex behavior would differ from literal\n                msg = (\n                    \"The default value of regex will change from True to False \"\n                    \"in a future version.\"\n                )\n                if len(pat) == 1:\n                    msg += (\n                        \" In addition, single character regular expressions will\"\n                        \"*not* be treated as literal strings when regex=True.\"\n                    )\n                warnings.warn(msg, FutureWarning, stacklevel=3)\n            regex = True\n        result = self._data.array._str_replace(\n            pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        \"\"\"\n        Duplicate each string in the Series or Index.\n\n        Parameters\n        ----------\n        repeats : int or sequence of int\n            Same value for all (int) or different value per (sequence).\n\n        Returns\n        -------\n        Series or Index of object\n            Series or Index of repeated string objects specified by\n            input parameter repeats.\n\n        Examples\n        --------\n        >>> s = pd.Series(['a', 'b', 'c'])\n        >>> s\n        0    a\n        1    b\n        2    c\n        dtype: object\n\n        Single int repeats string in Series\n\n        >>> s.str.repeat(repeats=2)\n        0    aa\n        1    bb\n        2    cc\n        dtype: object\n\n        Sequence of int repeats corresponding string in Series\n\n        >>> s.str.repeat(repeats=[1, 2, 3])\n        0      a\n        1     bb\n        2    ccc\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_repeat(repeats)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        \"\"\"\n        Pad strings in the Series/Index up to width.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be filled\n            with character defined in `fillchar`.\n        side : {'left', 'right', 'both'}, default 'left'\n            Side from which to fill resulting string.\n        fillchar : str, default ' '\n            Additional character for filling, default is whitespace.\n\n        Returns\n        -------\n        Series or Index of object\n            Returns Series or Index with minimum number of char in object.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='left')``.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='right')``.\n        Series.str.center : Fills both sides of strings with an arbitrary\n            character. Equivalent to ``Series.str.pad(side='both')``.\n        Series.str.zfill : Pad strings in the Series/Index by prepending '0'\n            character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"caribou\", \"tiger\"])\n        >>> s\n        0    caribou\n        1      tiger\n        dtype: object\n\n        >>> s.str.pad(width=10)\n        0       caribou\n        1         tiger\n        dtype: object\n\n        >>> s.str.pad(width=10, side='right', fillchar='-')\n        0    caribou---\n        1    tiger-----\n        dtype: object\n\n        >>> s.str.pad(width=10, side='both', fillchar='-')\n        0    -caribou--\n        1    --tiger---\n        dtype: object\n        \"\"\"\n        if not isinstance(fillchar, str):\n            msg = f\"fillchar must be a character, not {type(fillchar).__name__}\"\n            raise TypeError(msg)\n\n        if len(fillchar) != 1:\n            raise TypeError(\"fillchar must be a character, not str\")\n\n        if not is_integer(width):\n            msg = f\"width must be of integer type, not {type(width).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_pad(width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Pad %(side)s side of strings in the Series/Index.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``.\n    fillchar : str\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    filled : Series/Index of objects.\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"left and right\", \"method\": \"center\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"right\", \"method\": \"ljust\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % {\"side\": \"left\", \"method\": \"rjust\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills both sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = self.pad(width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    def slice(self, start=None, stop=None, step=None):\n        \"\"\"\n        Slice substrings from each element in the Series or Index.\n\n        Parameters\n        ----------\n        start : int, optional\n            Start position for slice operation.\n        stop : int, optional\n            Stop position for slice operation.\n        step : int, optional\n            Step size for slice operation.\n\n        Returns\n        -------\n        Series or Index of object\n            Series or Index from sliced substring from original string object.\n\n        See Also\n        --------\n        Series.str.slice_replace : Replace a slice with a string.\n        Series.str.get : Return element at position.\n            Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n            being the position.\n\n        Examples\n        --------\n        >>> s = pd.Series([\"koala\", \"dog\", \"chameleon\"])\n        >>> s\n        0        koala\n        1          dog\n        2    chameleon\n        dtype: object\n\n        >>> s.str.slice(start=1)\n        0        oala\n        1          og\n        2    hameleon\n        dtype: object\n\n        >>> s.str.slice(start=-1)\n        0           a\n        1           g\n        2           n\n        dtype: object\n\n        >>> s.str.slice(stop=2)\n        0    ko\n        1    do\n        2    ch\n        dtype: object\n\n        >>> s.str.slice(step=2)\n        0      kaa\n        1       dg\n        2    caeen\n        dtype: object\n\n        >>> s.str.slice(start=0, stop=5, step=3)\n        0    kl\n        1     d\n        2    cm\n        dtype: object\n\n        Equivalent behaviour to:\n\n        >>> s.str[0:5:3]\n        0    kl\n        1     d\n        2    cm\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_slice(start, stop, step)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        \"\"\"\n        Replace a positional slice of a string with another value.\n\n        Parameters\n        ----------\n        start : int, optional\n            Left index position to use for the slice. If not specified (None),\n            the slice is unbounded on the left, i.e. slice from the start\n            of the string.\n        stop : int, optional\n            Right index position to use for the slice. If not specified (None),\n            the slice is unbounded on the right, i.e. slice until the\n            end of the string.\n        repl : str, optional\n            String for replacement. If not specified (None), the sliced region\n            is replaced with an empty string.\n\n        Returns\n        -------\n        Series or Index\n            Same type as the original object.\n\n        See Also\n        --------\n        Series.str.slice : Just slicing without replacement.\n\n        Examples\n        --------\n        >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n        >>> s\n        0        a\n        1       ab\n        2      abc\n        3     abdc\n        4    abcde\n        dtype: object\n\n        Specify just `start`, meaning replace `start` until the end of the\n        string with `repl`.\n\n        >>> s.str.slice_replace(1, repl='X')\n        0    aX\n        1    aX\n        2    aX\n        3    aX\n        4    aX\n        dtype: object\n\n        Specify just `stop`, meaning the start of the string to `stop` is replaced\n        with `repl`, and the rest of the string is included.\n\n        >>> s.str.slice_replace(stop=2, repl='X')\n        0       X\n        1       X\n        2      Xc\n        3     Xdc\n        4    Xcde\n        dtype: object\n\n        Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n        replaced with `repl`. Everything before or after `start` and `stop` is\n        included as is.\n\n        >>> s.str.slice_replace(start=1, stop=3, repl='X')\n        0      aX\n        1      aX\n        2      aX\n        3     aXc\n        4    aXde\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_slice_replace(start, stop, repl)\n        return self._wrap_result(result)\n\n    def decode(self, encoding, errors=\"strict\"):\n        \"\"\"\n        Decode character string in the Series/Index using indicated encoding.\n\n        Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n        python3.\n\n        Parameters\n        ----------\n        encoding : str\n        errors : str, optional\n\n        Returns\n        -------\n        Series or Index\n        \"\"\"\n        # TODO: Add a similar _bytes interface.\n        if encoding in _cpython_optimized_decoders:\n            # CPython optimized implementation\n            f = lambda x: x.decode(encoding, errors)\n        else:\n            decoder = codecs.getdecoder(encoding)\n            f = lambda x: decoder(x, errors)[0]\n        arr = self._data.array\n        # assert isinstance(arr, (StringArray,))\n        result = arr._str_map(f)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        \"\"\"\n        Encode character string in the Series/Index using indicated encoding.\n\n        Equivalent to :meth:`str.encode`.\n\n        Parameters\n        ----------\n        encoding : str\n        errors : str, optional\n\n        Returns\n        -------\n        encoded : Series/Index of objects\n        \"\"\"\n        result = self._data.array._str_encode(encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove %(position)s characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\n            \"side\": \"left and right sides\",\n            \"method\": \"strip\",\n            \"position\": \"leading and trailing\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = self._data.array._str_strip(to_strip)\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\"side\": \"left side\", \"method\": \"lstrip\", \"position\": \"leading\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = self._data.array._str_lstrip(to_strip)\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"str_strip\"]\n        % {\"side\": \"right side\", \"method\": \"rstrip\", \"position\": \"trailing\"}\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = self._data.array._str_rstrip(to_strip)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        r\"\"\"\n        Wrap strings in Series/Index at specified line width.\n\n        This method has the same keyword parameters and defaults as\n        :class:`textwrap.TextWrapper`.\n\n        Parameters\n        ----------\n        width : int\n            Maximum line width.\n        expand_tabs : bool, optional\n            If True, tab characters will be expanded to spaces (default: True).\n        replace_whitespace : bool, optional\n            If True, each whitespace character (as defined by string.whitespace)\n            remaining after tab expansion will be replaced by a single space\n            (default: True).\n        drop_whitespace : bool, optional\n            If True, whitespace that, after wrapping, happens to end up at the\n            beginning or end of a line is dropped (default: True).\n        break_long_words : bool, optional\n            If True, then words longer than width will be broken in order to ensure\n            that no lines are longer than width. If it is false, long words will\n            not be broken, and some lines may be longer than width (default: True).\n        break_on_hyphens : bool, optional\n            If True, wrapping will occur preferably on whitespace and right after\n            hyphens in compound words, as it is customary in English. If false,\n            only whitespaces will be considered as potentially good places for line\n            breaks, but you need to set break_long_words to false if you want truly\n            insecable words (default: True).\n\n        Returns\n        -------\n        Series or Index\n\n        Notes\n        -----\n        Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n        default settings. To achieve behavior matching R's stringr library str_wrap\n        function, use the arguments:\n\n        - expand_tabs = False\n        - replace_whitespace = True\n        - drop_whitespace = True\n        - break_long_words = False\n        - break_on_hyphens = False\n\n        Examples\n        --------\n        >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n        >>> s.str.wrap(12)\n        0             line to be\\nwrapped\n        1    another line\\nto be\\nwrapped\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_wrap(width, **kwargs)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        \"\"\"\n        Return DataFrame of dummy/indicator variables for Series.\n\n        Each string in Series is split by sep and returned as a DataFrame\n        of dummy/indicator variables.\n\n        Parameters\n        ----------\n        sep : str, default \"|\"\n            String to split on.\n\n        Returns\n        -------\n        DataFrame\n            Dummy variables corresponding to values of the Series.\n\n        See Also\n        --------\n        get_dummies : Convert categorical variable into dummy/indicator\n            variables.\n\n        Examples\n        --------\n        >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n        a  b  c\n        0  1  1  0\n        1  1  0  0\n        2  1  0  1\n\n        >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n        a  b  c\n        0  1  1  0\n        1  0  0  0\n        2  1  0  1\n        \"\"\"\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        result, name = self._data.array._str_get_dummies(sep)\n        return self._wrap_result(\n            result,\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        \"\"\"\n        Map all characters in the string through the given mapping table.\n\n        Equivalent to standard :meth:`str.translate`.\n\n        Parameters\n        ----------\n        table : dict\n            Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n            None. Unmapped characters are left untouched.\n            Characters mapped to None are deleted. :meth:`str.maketrans` is a\n            helper function for making translation tables.\n\n        Returns\n        -------\n        Series or Index\n        \"\"\"\n        result = self._data.array._str_translate(table)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def count(self, pat, flags=0):\n        r\"\"\"\n        Count occurrences of pattern in each string of the Series/Index.\n\n        This function is used to count the number of times a particular regex\n        pattern is repeated in each of the string elements of the\n        :class:`~pandas.Series`.\n\n        Parameters\n        ----------\n        pat : str\n            Valid regular expression.\n        flags : int, default 0, meaning no flags\n            Flags for the `re` module. For a complete list, `see here\n            <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n        **kwargs\n            For compatibility with other string methods. Not used.\n\n        Returns\n        -------\n        Series or Index\n            Same type as the calling object containing the integer counts.\n\n        See Also\n        --------\n        re : Standard library module for regular expressions.\n        str.count : Standard library version, without regular expression support.\n\n        Notes\n        -----\n        Some characters need to be escaped when passing in `pat`.\n        eg. ``'$'`` has a special meaning in regex and must be escaped when\n        finding this literal character.\n\n        Examples\n        --------\n        >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n        >>> s.str.count('a')\n        0    0.0\n        1    0.0\n        2    2.0\n        3    2.0\n        4    NaN\n        5    0.0\n        6    1.0\n        dtype: float64\n\n        Escape ``'$'`` to find the literal dollar sign.\n\n        >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n        >>> s.str.count('\\\\$')\n        0    1\n        1    0\n        2    1\n        3    2\n        4    2\n        5    0\n        dtype: int64\n\n        This is also available on Index\n\n        >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n        Int64Index([0, 0, 2, 1], dtype='int64')\n        \"\"\"\n        result = self._data.array._str_count(pat, flags)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def startswith(self, pat, na=None):\n        \"\"\"\n        Test if the start of each string element matches a pattern.\n\n        Equivalent to :meth:`str.startswith`.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence. Regular expressions are not accepted.\n        na : object, default NaN\n            Object shown if element tested is not a string. The default depends\n            on dtype of the array. For object-dtype, ``numpy.nan`` is used.\n            For ``StringDtype``, ``pandas.NA`` is used.\n\n        Returns\n        -------\n        Series or Index of bool\n            A Series of booleans indicating whether the given pattern matches\n            the start of each string element.\n\n        See Also\n        --------\n        str.startswith : Python standard library string method.\n        Series.str.endswith : Same as startswith, but tests the end of string.\n        Series.str.contains : Tests if string element contains a pattern.\n\n        Examples\n        --------\n        >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n        >>> s\n        0     bat\n        1    Bear\n        2     cat\n        3     NaN\n        dtype: object\n\n        >>> s.str.startswith('b')\n        0     True\n        1    False\n        2    False\n        3      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN`.\n\n        >>> s.str.startswith('b', na=False)\n        0     True\n        1    False\n        2    False\n        3    False\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_startswith(pat, na=na)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def endswith(self, pat, na=None):\n        \"\"\"\n        Test if the end of each string element matches a pattern.\n\n        Equivalent to :meth:`str.endswith`.\n\n        Parameters\n        ----------\n        pat : str\n            Character sequence. Regular expressions are not accepted.\n        na : object, default NaN\n            Object shown if element tested is not a string. The default depends\n            on dtype of the array. For object-dtype, ``numpy.nan`` is used.\n            For ``StringDtype``, ``pandas.NA`` is used.\n\n        Returns\n        -------\n        Series or Index of bool\n            A Series of booleans indicating whether the given pattern matches\n            the end of each string element.\n\n        See Also\n        --------\n        str.endswith : Python standard library string method.\n        Series.str.startswith : Same as endswith, but tests the start of string.\n        Series.str.contains : Tests if string element contains a pattern.\n\n        Examples\n        --------\n        >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n        >>> s\n        0     bat\n        1    bear\n        2     caT\n        3     NaN\n        dtype: object\n\n        >>> s.str.endswith('t')\n        0     True\n        1    False\n        2    False\n        3      NaN\n        dtype: object\n\n        Specifying `na` to be `False` instead of `NaN`.\n\n        >>> s.str.endswith('t', na=False)\n        0     True\n        1    False\n        2    False\n        3    False\n        dtype: bool\n        \"\"\"\n        result = self._data.array._str_endswith(pat, na=na)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def findall(self, pat, flags=0):\n        \"\"\"\n        Find all occurrences of pattern or regular expression in the Series/Index.\n\n        Equivalent to applying :func:`re.findall` to all the elements in the\n        Series/Index.\n\n        Parameters\n        ----------\n        pat : str\n            Pattern or regular expression.\n        flags : int, default 0\n            Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n            means no flags).\n\n        Returns\n        -------\n        Series/Index of lists of strings\n            All non-overlapping matches of pattern or regular expression in each\n            string of this Series/Index.\n\n        See Also\n        --------\n        count : Count occurrences of pattern or regular expression in each string\n            of the Series/Index.\n        extractall : For each string in the Series, extract groups from all matches\n            of regular expression and return a DataFrame with one row for each\n            match and one column for each group.\n        re.findall : The equivalent ``re`` function to all non-overlapping matches\n            of pattern or regular expression in string, as a list of strings.\n\n        Examples\n        --------\n        >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n        The search for the pattern 'Monkey' returns one match:\n\n        >>> s.str.findall('Monkey')\n        0          []\n        1    [Monkey]\n        2          []\n        dtype: object\n\n        On the other hand, the search for the pattern 'MONKEY' doesn't return any\n        match:\n\n        >>> s.str.findall('MONKEY')\n        0    []\n        1    []\n        2    []\n        dtype: object\n\n        Flags can be added to the pattern or regular expression. For instance,\n        to find the pattern 'MONKEY' ignoring the case:\n\n        >>> import re\n        >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n        0          []\n        1    [Monkey]\n        2          []\n        dtype: object\n\n        When the pattern matches more than one string in the Series, all matches\n        are returned:\n\n        >>> s.str.findall('on')\n        0    [on]\n        1    [on]\n        2      []\n        dtype: object\n\n        Regular expressions are supported too. For instance, the search for all the\n        strings ending with the word 'on' is shown next:\n\n        >>> s.str.findall('on$')\n        0    [on]\n        1      []\n        2      []\n        dtype: object\n\n        If the pattern is found more than once in the same string, then a list of\n        multiple strings is returned:\n\n        >>> s.str.findall('b')\n        0        []\n        1        []\n        2    [b, b]\n        dtype: object\n        \"\"\"\n        result = self._data.array._str_findall(pat, flags)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        r\"\"\"\n        Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n        For each subject string in the Series, extract groups from the\n        first match of regular expression `pat`.\n\n        Parameters\n        ----------\n        pat : str\n            Regular expression pattern with capturing groups.\n        flags : int, default 0 (no flags)\n            Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n            modify regular expression matching for things like case,\n            spaces, etc. For more details, see :mod:`re`.\n        expand : bool, default True\n            If True, return DataFrame with one column per capture group.\n            If False, return a Series/Index if there is one capture group\n            or DataFrame if there are multiple capture groups.\n\n        Returns\n        -------\n        DataFrame or Series or Index\n            A DataFrame with one row for each subject string, and one\n            column for each group. Any capture group names in regular\n            expression pat will be used for column names; otherwise\n            capture group numbers will be used. The dtype of each result\n            column is always object, even when no match is found. If\n            ``expand=False`` and pat has only one capture group, then\n            return a Series (if subject is a Series) or Index (if subject\n            is an Index).\n\n        See Also\n        --------\n        extractall : Returns all matches (not just the first match).\n\n        Examples\n        --------\n        A pattern with two groups will return a DataFrame with two columns.\n        Non-matches will be NaN.\n\n        >>> s = pd.Series(['a1', 'b2', 'c3'])\n        >>> s.str.extract(r'([ab])(\\d)')\n            0    1\n        0    a    1\n        1    b    2\n        2  NaN  NaN\n\n        A pattern may contain optional groups.\n\n        >>> s.str.extract(r'([ab])?(\\d)')\n            0  1\n        0    a  1\n        1    b  2\n        2  NaN  3\n\n        Named groups will become column names in the result.\n\n        >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n        letter digit\n        0      a     1\n        1      b     2\n        2    NaN   NaN\n\n        A pattern with one group will return a DataFrame with one column\n        if expand=True.\n\n        >>> s.str.extract(r'[ab](\\d)', expand=True)\n            0\n        0    1\n        1    2\n        2  NaN\n\n        A pattern with one group will return a Series if expand=False.\n\n        >>> s.str.extract(r'[ab](\\d)', expand=False)\n        0      1\n        1      2\n        2    NaN\n        dtype: object\n        \"\"\"\n        # TODO: dispatch\n        return str_extract(self, pat, flags, expand=expand)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        r\"\"\"\n        Extract capture groups in the regex `pat` as columns in DataFrame.\n\n        For each subject string in the Series, extract groups from all\n        matches of regular expression pat. When each subject string in the\n        Series has exactly one match, extractall(pat).xs(0, level='match')\n        is the same as extract(pat).\n\n        Parameters\n        ----------\n        pat : str\n            Regular expression pattern with capturing groups.\n        flags : int, default 0 (no flags)\n            A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n            to modify regular expression matching for things like case, spaces,\n            etc. Multiple flags can be combined with the bitwise OR operator,\n            for example ``re.IGNORECASE | re.MULTILINE``.\n\n        Returns\n        -------\n        DataFrame\n            A ``DataFrame`` with one row for each match, and one column for each\n            group. Its rows have a ``MultiIndex`` with first levels that come from\n            the subject ``Series``. The last level is named 'match' and indexes the\n            matches in each item of the ``Series``. Any capture group names in\n            regular expression pat will be used for column names; otherwise capture\n            group numbers will be used.\n\n        See Also\n        --------\n        extract : Returns first match only (not all matches).\n\n        Examples\n        --------\n        A pattern with one group will return a DataFrame with one column.\n        Indices with no matches will not appear in the result.\n\n        >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n        >>> s.str.extractall(r\"[ab](\\d)\")\n                0\n        match\n        A 0      1\n        1      2\n        B 0      1\n\n        Capture group names are used for column names of the result.\n\n        >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n                digit\n        match\n        A 0         1\n        1         2\n        B 0         1\n\n        A pattern with two groups will return a DataFrame with two columns.\n\n        >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n                letter digit\n        match\n        A 0          a     1\n        1          a     2\n        B 0          b     1\n\n        Optional groups that do not match are NaN in the result.\n\n        >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n                letter digit\n        match\n        A 0          a     1\n        1          a     2\n        B 0          b     1\n        C 0        NaN     1\n        \"\"\"\n        # TODO: dispatch\n        return str_extractall(self._orig, pat, flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index.\n\n    Each of returned indexes corresponds to the position where the\n    substring is fully contained between [start:end]. Return -1 on\n    failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of int.\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % {\n            \"side\": \"lowest\",\n            \"method\": \"find\",\n            \"also\": \"rfind : Return highest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_find(sub, start, end)\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % {\n            \"side\": \"highest\",\n            \"method\": \"rfind\",\n            \"also\": \"find : Return lowest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_rfind(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form.\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        result = self._data.array._str_normalize(form)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each string in Series/Index.\n\n    Each of the returned indexes corresponds to the position where the\n    substring is fully contained between [start:end]. This is the same\n    as ``str.%(similar)s`` except instead of returning -1, it raises a\n    ValueError when the substring is not found. Equivalent to standard\n    ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % {\n            \"side\": \"lowest\",\n            \"similar\": \"find\",\n            \"method\": \"index\",\n            \"also\": \"rindex : Return highest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_index(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % {\n            \"side\": \"highest\",\n            \"similar\": \"rfind\",\n            \"method\": \"rindex\",\n            \"also\": \"index : Return lowest indexes in each strings.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        if not isinstance(sub, str):\n            msg = f\"expected a string object, not {type(sub).__name__}\"\n            raise TypeError(msg)\n\n        result = self._data.array._str_rindex(sub, start=start, end=end)\n        return self._wrap_result(result, returns_string=False)\n\n    def len(self):\n        \"\"\"\n        Compute the length of each element in the Series/Index.\n\n        The element may be a sequence (such as a string, tuple or list) or a collection\n        (such as a dictionary).\n\n        Returns\n        -------\n        Series or Index of int\n            A Series or Index of integer values indicating the length of each\n            element in the Series or Index.\n\n        See Also\n        --------\n        str.len : Python built-in function returning the length of an object.\n        Series.size : Returns the length of the Series.\n\n        Examples\n        --------\n        Returns the length (number of characters) in a string. Returns the\n        number of entries for dictionaries, lists or tuples.\n\n        >>> s = pd.Series(['dog',\n        ...                 '',\n        ...                 5,\n        ...                 {'foo' : 'bar'},\n        ...                 [2, 3, 5, 7],\n        ...                 ('one', 'two', 'three')])\n        >>> s\n        0                  dog\n        1\n        2                    5\n        3       {'foo': 'bar'}\n        4         [2, 3, 5, 7]\n        5    (one, two, three)\n        dtype: object\n        >>> s.str.len()\n        0    3.0\n        1    0.0\n        2    NaN\n        3    1.0\n        4    4.0\n        5    3.0\n        dtype: float64\n        \"\"\"\n        result = self._data.array._str_len()\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n    # Types:\n    #   cases:\n    #       upper, lower, title, capitalize, swapcase, casefold\n    #   boolean:\n    #     isalpha, isnumeric isalnum isdigit isdecimal isspace islower isupper istitle\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args: Dict[str, Dict[str, str]] = {}\n    _doc_args[\"lower\"] = {\"type\": \"lowercase\", \"method\": \"lower\", \"version\": \"\"}\n    _doc_args[\"upper\"] = {\"type\": \"uppercase\", \"method\": \"upper\", \"version\": \"\"}\n    _doc_args[\"title\"] = {\"type\": \"titlecase\", \"method\": \"title\", \"version\": \"\"}\n    _doc_args[\"capitalize\"] = {\n        \"type\": \"be capitalized\",\n        \"method\": \"capitalize\",\n        \"version\": \"\",\n    }\n    _doc_args[\"swapcase\"] = {\n        \"type\": \"be swapcased\",\n        \"method\": \"swapcase\",\n        \"version\": \"\",\n    }\n    _doc_args[\"casefold\"] = {\n        \"type\": \"be casefolded\",\n        \"method\": \"casefold\",\n        \"version\": \"\\n    .. versionadded:: 0.25.0\\n\",\n    }\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"lower\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def lower(self):\n        result = self._data.array._str_lower()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"upper\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def upper(self):\n        result = self._data.array._str_upper()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"title\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def title(self):\n        result = self._data.array._str_title()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def capitalize(self):\n        result = self._data.array._str_capitalize()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def swapcase(self):\n        result = self._data.array._str_swapcase()\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"])\n    @forbid_nonstring_types([\"bytes\"])\n    def casefold(self):\n        result = self._data.array._str_casefold()\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '', '', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = {\"type\": \"alphanumeric\", \"method\": \"isalnum\"}\n    _doc_args[\"isalpha\"] = {\"type\": \"alphabetic\", \"method\": \"isalpha\"}\n    _doc_args[\"isdigit\"] = {\"type\": \"digits\", \"method\": \"isdigit\"}\n    _doc_args[\"isspace\"] = {\"type\": \"whitespace\", \"method\": \"isspace\"}\n    _doc_args[\"islower\"] = {\"type\": \"lowercase\", \"method\": \"islower\"}\n    _doc_args[\"isupper\"] = {\"type\": \"uppercase\", \"method\": \"isupper\"}\n    _doc_args[\"istitle\"] = {\"type\": \"titlecase\", \"method\": \"istitle\"}\n    _doc_args[\"isnumeric\"] = {\"type\": \"numeric\", \"method\": \"isnumeric\"}\n    _doc_args[\"isdecimal\"] = {\"type\": \"decimal\", \"method\": \"isdecimal\"}\n    # force _noarg_wrapper return type with dtype=np.dtype(bool) (GH 29624)\n\n    isalnum = _map_and_wrap(\n        \"isalnum\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"]\n    )\n    isalpha = _map_and_wrap(\n        \"isalpha\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"]\n    )\n    isdigit = _map_and_wrap(\n        \"isdigit\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"]\n    )\n    isspace = _map_and_wrap(\n        \"isspace\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"]\n    )\n    islower = _map_and_wrap(\n        \"islower\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"]\n    )\n    isupper = _map_and_wrap(\n        \"isupper\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"]\n    )\n    istitle = _map_and_wrap(\n        \"istitle\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"]\n    )\n    isnumeric = _map_and_wrap(\n        \"isnumeric\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"]\n    )\n    isdecimal = _map_and_wrap(\n        \"isdecimal\", docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"]\n    )\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    f\"column {dtype}\"\n                ) from None\n    return result\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        arr_of_cols = np.asarray(list_of_columns, dtype=object)\n        return np.sum(arr_of_cols, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    arr_with_sep = np.asarray(list_with_sep, dtype=object)\n    return np.sum(arr_with_sep, axis=0)\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    from pandas.core.arrays.string_ import StringDtype\n\n    if isinstance(arr.dtype, StringDtype):\n        return arr.dtype.name\n    else:\n        return object\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, array\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    result_dtype = _result_dtype(arr)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n        # not dispatching, so we have to reconstruct here.\n        result = array(result, dtype=result_dtype)\n    else:\n        if isinstance(arr, ABCIndex):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.size == 0:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            dtype = _result_dtype(arr)\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=dtype,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    dtype = _result_dtype(arr)\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=dtype,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        result = _str_extract_frame(arr._orig, pat, flags=flags)\n        return result.__finalize__(arr._orig, method=\"str_extract\")\n    else:\n        result, name = _str_extract_noexpand(arr._orig, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n"
    },
    {
      "filename": "pandas/tests/dtypes/test_inference.py",
      "content": "\"\"\"\nThese the test the public routines exposed in types/common.py\nrelated to inference and not otherwise tested in types/test_common.py\n\n\"\"\"\nimport collections\nfrom collections import namedtuple\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom io import StringIO\nfrom numbers import Number\nimport re\n\nimport numpy as np\nimport pytest\nimport pytz\n\nfrom pandas._libs import lib, missing as libmissing\nimport pandas.util._test_decorators as td\n\nfrom pandas.core.dtypes import inference\nfrom pandas.core.dtypes.common import (\n    ensure_int32,\n    is_bool,\n    is_datetime64_any_dtype,\n    is_datetime64_dtype,\n    is_datetime64_ns_dtype,\n    is_datetime64tz_dtype,\n    is_float,\n    is_integer,\n    is_number,\n    is_scalar,\n    is_scipy_sparse,\n    is_timedelta64_dtype,\n    is_timedelta64_ns_dtype,\n)\n\nimport pandas as pd\nfrom pandas import (\n    Categorical,\n    DataFrame,\n    DateOffset,\n    DatetimeIndex,\n    Index,\n    Interval,\n    Period,\n    PeriodIndex,\n    Series,\n    Timedelta,\n    TimedeltaIndex,\n    Timestamp,\n)\nimport pandas._testing as tm\nfrom pandas.core.arrays import IntegerArray\n\n\n@pytest.fixture(params=[True, False], ids=str)\ndef coerce(request):\n    return request.param\n\n\n# collect all objects to be tested for list-like-ness; use tuples of objects,\n# whether they are list-like or not (special casing for sets), and their ID\nll_params = [\n    ([1], True, \"list\"),\n    ([], True, \"list-empty\"),\n    ((1,), True, \"tuple\"),\n    ((), True, \"tuple-empty\"),\n    ({\"a\": 1}, True, \"dict\"),\n    ({}, True, \"dict-empty\"),\n    ({\"a\", 1}, \"set\", \"set\"),\n    (set(), \"set\", \"set-empty\"),\n    (frozenset({\"a\", 1}), \"set\", \"frozenset\"),\n    (frozenset(), \"set\", \"frozenset-empty\"),\n    (iter([1, 2]), True, \"iterator\"),\n    (iter([]), True, \"iterator-empty\"),\n    ((x for x in [1, 2]), True, \"generator\"),\n    ((_ for _ in []), True, \"generator-empty\"),\n    (Series([1]), True, \"Series\"),\n    (Series([], dtype=object), True, \"Series-empty\"),\n    (Series([\"a\"]).str, True, \"StringMethods\"),\n    (Series([], dtype=\"O\").str, True, \"StringMethods-empty\"),\n    (Index([1]), True, \"Index\"),\n    (Index([]), True, \"Index-empty\"),\n    (DataFrame([[1]]), True, \"DataFrame\"),\n    (DataFrame(), True, \"DataFrame-empty\"),\n    (np.ndarray((2,) * 1), True, \"ndarray-1d\"),\n    (np.array([]), True, \"ndarray-1d-empty\"),\n    (np.ndarray((2,) * 2), True, \"ndarray-2d\"),\n    (np.array([[]]), True, \"ndarray-2d-empty\"),\n    (np.ndarray((2,) * 3), True, \"ndarray-3d\"),\n    (np.array([[[]]]), True, \"ndarray-3d-empty\"),\n    (np.ndarray((2,) * 4), True, \"ndarray-4d\"),\n    (np.array([[[[]]]]), True, \"ndarray-4d-empty\"),\n    (np.array(2), False, \"ndarray-0d\"),\n    (1, False, \"int\"),\n    (b\"123\", False, \"bytes\"),\n    (b\"\", False, \"bytes-empty\"),\n    (\"123\", False, \"string\"),\n    (\"\", False, \"string-empty\"),\n    (str, False, \"string-type\"),\n    (object(), False, \"object\"),\n    (np.nan, False, \"NaN\"),\n    (None, False, \"None\"),\n]\nobjs, expected, ids = zip(*ll_params)\n\n\n@pytest.fixture(params=zip(objs, expected), ids=ids)\ndef maybe_list_like(request):\n    return request.param\n\n\ndef test_is_list_like(maybe_list_like):\n    obj, expected = maybe_list_like\n    expected = True if expected == \"set\" else expected\n    assert inference.is_list_like(obj) == expected\n\n\ndef test_is_list_like_disallow_sets(maybe_list_like):\n    obj, expected = maybe_list_like\n    expected = False if expected == \"set\" else expected\n    assert inference.is_list_like(obj, allow_sets=False) == expected\n\n\ndef test_is_list_like_recursion():\n    # GH 33721\n    # interpreter would crash with SIGABRT\n    def foo():\n        inference.is_list_like([])\n        foo()\n\n    with tm.external_error_raised(RecursionError):\n        foo()\n\n\ndef test_is_sequence():\n    is_seq = inference.is_sequence\n    assert is_seq((1, 2))\n    assert is_seq([1, 2])\n    assert not is_seq(\"abcd\")\n    assert not is_seq(np.int64)\n\n    class A:\n        def __getitem__(self):\n            return 1\n\n    assert not is_seq(A())\n\n\ndef test_is_array_like():\n    assert inference.is_array_like(Series([], dtype=object))\n    assert inference.is_array_like(Series([1, 2]))\n    assert inference.is_array_like(np.array([\"a\", \"b\"]))\n    assert inference.is_array_like(Index([\"2016-01-01\"]))\n\n    class DtypeList(list):\n        dtype = \"special\"\n\n    assert inference.is_array_like(DtypeList())\n\n    assert not inference.is_array_like([1, 2, 3])\n    assert not inference.is_array_like(())\n    assert not inference.is_array_like(\"foo\")\n    assert not inference.is_array_like(123)\n\n\n@pytest.mark.parametrize(\n    \"inner\",\n    [\n        [],\n        [1],\n        (1,),\n        (1, 2),\n        {\"a\": 1},\n        {1, \"a\"},\n        Series([1]),\n        Series([], dtype=object),\n        Series([\"a\"]).str,\n        (x for x in range(5)),\n    ],\n)\n@pytest.mark.parametrize(\"outer\", [list, Series, np.array, tuple])\ndef test_is_nested_list_like_passes(inner, outer):\n    result = outer([inner for _ in range(5)])\n    assert inference.is_list_like(result)\n\n\n@pytest.mark.parametrize(\n    \"obj\",\n    [\n        \"abc\",\n        [],\n        [1],\n        (1,),\n        [\"a\"],\n        \"a\",\n        {\"a\"},\n        [1, 2, 3],\n        Series([1]),\n        DataFrame({\"A\": [1]}),\n        ([1, 2] for _ in range(5)),\n    ],\n)\ndef test_is_nested_list_like_fails(obj):\n    assert not inference.is_nested_list_like(obj)\n\n\n@pytest.mark.parametrize(\"ll\", [{}, {\"A\": 1}, Series([1]), collections.defaultdict()])\ndef test_is_dict_like_passes(ll):\n    assert inference.is_dict_like(ll)\n\n\n@pytest.mark.parametrize(\n    \"ll\",\n    [\n        \"1\",\n        1,\n        [1, 2],\n        (1, 2),\n        range(2),\n        Index([1]),\n        dict,\n        collections.defaultdict,\n        Series,\n    ],\n)\ndef test_is_dict_like_fails(ll):\n    assert not inference.is_dict_like(ll)\n\n\n@pytest.mark.parametrize(\"has_keys\", [True, False])\n@pytest.mark.parametrize(\"has_getitem\", [True, False])\n@pytest.mark.parametrize(\"has_contains\", [True, False])\ndef test_is_dict_like_duck_type(has_keys, has_getitem, has_contains):\n    class DictLike:\n        def __init__(self, d):\n            self.d = d\n\n        if has_keys:\n\n            def keys(self):\n                return self.d.keys()\n\n        if has_getitem:\n\n            def __getitem__(self, key):\n                return self.d.__getitem__(key)\n\n        if has_contains:\n\n            def __contains__(self, key) -> bool:\n                return self.d.__contains__(key)\n\n    d = DictLike({1: 2})\n    result = inference.is_dict_like(d)\n    expected = has_keys and has_getitem and has_contains\n\n    assert result is expected\n\n\ndef test_is_file_like():\n    class MockFile:\n        pass\n\n    is_file = inference.is_file_like\n\n    data = StringIO(\"data\")\n    assert is_file(data)\n\n    # No read / write attributes\n    # No iterator attributes\n    m = MockFile()\n    assert not is_file(m)\n\n    MockFile.write = lambda self: 0\n\n    # Write attribute but not an iterator\n    m = MockFile()\n    assert not is_file(m)\n\n    # gh-16530: Valid iterator just means we have the\n    # __iter__ attribute for our purposes.\n    MockFile.__iter__ = lambda self: self\n\n    # Valid write-only file\n    m = MockFile()\n    assert is_file(m)\n\n    del MockFile.write\n    MockFile.read = lambda self: 0\n\n    # Valid read-only file\n    m = MockFile()\n    assert is_file(m)\n\n    # Iterator but no read / write attributes\n    data = [1, 2, 3]\n    assert not is_file(data)\n\n\ntest_tuple = collections.namedtuple(\"test_tuple\", [\"a\", \"b\", \"c\"])\n\n\n@pytest.mark.parametrize(\"ll\", [test_tuple(1, 2, 3)])\ndef test_is_names_tuple_passes(ll):\n    assert inference.is_named_tuple(ll)\n\n\n@pytest.mark.parametrize(\"ll\", [(1, 2, 3), \"a\", Series({\"pi\": 3.14})])\ndef test_is_names_tuple_fails(ll):\n    assert not inference.is_named_tuple(ll)\n\n\ndef test_is_hashable():\n\n    # all new-style classes are hashable by default\n    class HashableClass:\n        pass\n\n    class UnhashableClass1:\n        __hash__ = None\n\n    class UnhashableClass2:\n        def __hash__(self):\n            raise TypeError(\"Not hashable\")\n\n    hashable = (1, 3.14, np.float64(3.14), \"a\", (), (1,), HashableClass())\n    not_hashable = ([], UnhashableClass1())\n    abc_hashable_not_really_hashable = (([],), UnhashableClass2())\n\n    for i in hashable:\n        assert inference.is_hashable(i)\n    for i in not_hashable:\n        assert not inference.is_hashable(i)\n    for i in abc_hashable_not_really_hashable:\n        assert not inference.is_hashable(i)\n\n    # numpy.array is no longer collections.abc.Hashable as of\n    # https://github.com/numpy/numpy/pull/5326, just test\n    # is_hashable()\n    assert not inference.is_hashable(np.array([]))\n\n\n@pytest.mark.parametrize(\"ll\", [re.compile(\"ad\")])\ndef test_is_re_passes(ll):\n    assert inference.is_re(ll)\n\n\n@pytest.mark.parametrize(\"ll\", [\"x\", 2, 3, object()])\ndef test_is_re_fails(ll):\n    assert not inference.is_re(ll)\n\n\n@pytest.mark.parametrize(\n    \"ll\", [r\"a\", \"x\", r\"asdf\", re.compile(\"adsf\"), r\"\\u2233\\s*\", re.compile(r\"\")]\n)\ndef test_is_recompilable_passes(ll):\n    assert inference.is_re_compilable(ll)\n\n\n@pytest.mark.parametrize(\"ll\", [1, [], object()])\ndef test_is_recompilable_fails(ll):\n    assert not inference.is_re_compilable(ll)\n\n\nclass TestInference:\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            np.array(list(\"abc\"), dtype=\"S1\"),\n            np.array(list(\"abc\"), dtype=\"S1\").astype(object),\n            [b\"a\", np.nan, b\"c\"],\n        ],\n    )\n    def test_infer_dtype_bytes(self, arr):\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"bytes\"\n\n    @pytest.mark.parametrize(\n        \"value, expected\",\n        [\n            (float(\"inf\"), True),\n            (np.inf, True),\n            (-np.inf, False),\n            (1, False),\n            (\"a\", False),\n        ],\n    )\n    def test_isposinf_scalar(self, value, expected):\n        # GH 11352\n        result = libmissing.isposinf_scalar(value)\n        assert result is expected\n\n    @pytest.mark.parametrize(\n        \"value, expected\",\n        [\n            (float(\"-inf\"), True),\n            (-np.inf, True),\n            (np.inf, False),\n            (1, False),\n            (\"a\", False),\n        ],\n    )\n    def test_isneginf_scalar(self, value, expected):\n        result = libmissing.isneginf_scalar(value)\n        assert result is expected\n\n    @pytest.mark.parametrize(\"coerce_numeric\", [True, False])\n    @pytest.mark.parametrize(\n        \"infinity\", [\"inf\", \"inF\", \"iNf\", \"Inf\", \"iNF\", \"InF\", \"INf\", \"INF\"]\n    )\n    @pytest.mark.parametrize(\"prefix\", [\"\", \"-\", \"+\"])\n    def test_maybe_convert_numeric_infinities(self, coerce_numeric, infinity, prefix):\n        # see gh-13274\n        result = lib.maybe_convert_numeric(\n            np.array([prefix + infinity], dtype=object),\n            na_values={\"\", \"NULL\", \"nan\"},\n            coerce_numeric=coerce_numeric,\n        )\n        expected = np.array([np.inf if prefix in [\"\", \"+\"] else -np.inf])\n        tm.assert_numpy_array_equal(result, expected)\n\n    def test_maybe_convert_numeric_infinities_raises(self):\n        msg = \"Unable to parse string\"\n        with pytest.raises(ValueError, match=msg):\n            lib.maybe_convert_numeric(\n                np.array([\"foo_inf\"], dtype=object),\n                na_values={\"\", \"NULL\", \"nan\"},\n                coerce_numeric=False,\n            )\n\n    def test_maybe_convert_numeric_post_floatify_nan(self, coerce):\n        # see gh-13314\n        data = np.array([\"1.200\", \"-999.000\", \"4.500\"], dtype=object)\n        expected = np.array([1.2, np.nan, 4.5], dtype=np.float64)\n        nan_values = {-999, -999.0}\n\n        out = lib.maybe_convert_numeric(data, nan_values, coerce)\n        tm.assert_numpy_array_equal(out, expected)\n\n    def test_convert_infs(self):\n        arr = np.array([\"inf\", \"inf\", \"inf\"], dtype=\"O\")\n        result = lib.maybe_convert_numeric(arr, set(), False)\n        assert result.dtype == np.float64\n\n        arr = np.array([\"-inf\", \"-inf\", \"-inf\"], dtype=\"O\")\n        result = lib.maybe_convert_numeric(arr, set(), False)\n        assert result.dtype == np.float64\n\n    def test_scientific_no_exponent(self):\n        # See PR 12215\n        arr = np.array([\"42E\", \"2E\", \"99e\", \"6e\"], dtype=\"O\")\n        result = lib.maybe_convert_numeric(arr, set(), False, True)\n        assert np.all(np.isnan(result))\n\n    def test_convert_non_hashable(self):\n        # GH13324\n        # make sure that we are handing non-hashables\n        arr = np.array([[10.0, 2], 1.0, \"apple\"], dtype=object)\n        result = lib.maybe_convert_numeric(arr, set(), False, True)\n        tm.assert_numpy_array_equal(result, np.array([np.nan, 1.0, np.nan]))\n\n    def test_convert_numeric_uint64(self):\n        arr = np.array([2 ** 63], dtype=object)\n        exp = np.array([2 ** 63], dtype=np.uint64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_numeric(arr, set()), exp)\n\n        arr = np.array([str(2 ** 63)], dtype=object)\n        exp = np.array([2 ** 63], dtype=np.uint64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_numeric(arr, set()), exp)\n\n        arr = np.array([np.uint64(2 ** 63)], dtype=object)\n        exp = np.array([2 ** 63], dtype=np.uint64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_numeric(arr, set()), exp)\n\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            np.array([2 ** 63, np.nan], dtype=object),\n            np.array([str(2 ** 63), np.nan], dtype=object),\n            np.array([np.nan, 2 ** 63], dtype=object),\n            np.array([np.nan, str(2 ** 63)], dtype=object),\n        ],\n    )\n    def test_convert_numeric_uint64_nan(self, coerce, arr):\n        expected = arr.astype(float) if coerce else arr.copy()\n        result = lib.maybe_convert_numeric(arr, set(), coerce_numeric=coerce)\n        tm.assert_almost_equal(result, expected)\n\n    def test_convert_numeric_uint64_nan_values(self, coerce):\n        arr = np.array([2 ** 63, 2 ** 63 + 1], dtype=object)\n        na_values = {2 ** 63}\n\n        expected = (\n            np.array([np.nan, 2 ** 63 + 1], dtype=float) if coerce else arr.copy()\n        )\n        result = lib.maybe_convert_numeric(arr, na_values, coerce_numeric=coerce)\n        tm.assert_almost_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"case\",\n        [\n            np.array([2 ** 63, -1], dtype=object),\n            np.array([str(2 ** 63), -1], dtype=object),\n            np.array([str(2 ** 63), str(-1)], dtype=object),\n            np.array([-1, 2 ** 63], dtype=object),\n            np.array([-1, str(2 ** 63)], dtype=object),\n            np.array([str(-1), str(2 ** 63)], dtype=object),\n        ],\n    )\n    def test_convert_numeric_int64_uint64(self, case, coerce):\n        expected = case.astype(float) if coerce else case.copy()\n        result = lib.maybe_convert_numeric(case, set(), coerce_numeric=coerce)\n        tm.assert_almost_equal(result, expected)\n\n    def test_convert_numeric_string_uint64(self):\n        # GH32394\n        result = lib.maybe_convert_numeric(\n            np.array([\"uint64\"], dtype=object), set(), coerce_numeric=True\n        )\n        assert np.isnan(result)\n\n    @pytest.mark.parametrize(\"value\", [-(2 ** 63) - 1, 2 ** 64])\n    def test_convert_int_overflow(self, value):\n        # see gh-18584\n        arr = np.array([value], dtype=object)\n        result = lib.maybe_convert_objects(arr)\n        tm.assert_numpy_array_equal(arr, result)\n\n    def test_maybe_convert_objects_uint64(self):\n        # see gh-4471\n        arr = np.array([2 ** 63], dtype=object)\n        exp = np.array([2 ** 63], dtype=np.uint64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_objects(arr), exp)\n\n        # NumPy bug: can't compare uint64 to int64, as that\n        # results in both casting to float64, so we should\n        # make sure that this function is robust against it\n        arr = np.array([np.uint64(2 ** 63)], dtype=object)\n        exp = np.array([2 ** 63], dtype=np.uint64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_objects(arr), exp)\n\n        arr = np.array([2, -1], dtype=object)\n        exp = np.array([2, -1], dtype=np.int64)\n        tm.assert_numpy_array_equal(lib.maybe_convert_objects(arr), exp)\n\n        arr = np.array([2 ** 63, -1], dtype=object)\n        exp = np.array([2 ** 63, -1], dtype=object)\n        tm.assert_numpy_array_equal(lib.maybe_convert_objects(arr), exp)\n\n    def test_maybe_convert_objects_datetime(self):\n        # GH27438\n        arr = np.array(\n            [np.datetime64(\"2000-01-01\"), np.timedelta64(1, \"s\")], dtype=object\n        )\n        exp = arr.copy()\n        out = lib.maybe_convert_objects(arr, convert_datetime=1, convert_timedelta=1)\n        tm.assert_numpy_array_equal(out, exp)\n\n        arr = np.array([pd.NaT, np.timedelta64(1, \"s\")], dtype=object)\n        exp = np.array([np.timedelta64(\"NaT\"), np.timedelta64(1, \"s\")], dtype=\"m8[ns]\")\n        out = lib.maybe_convert_objects(arr, convert_datetime=1, convert_timedelta=1)\n        tm.assert_numpy_array_equal(out, exp)\n\n        arr = np.array([np.timedelta64(1, \"s\"), np.nan], dtype=object)\n        exp = arr.copy()\n        out = lib.maybe_convert_objects(arr, convert_datetime=1, convert_timedelta=1)\n        tm.assert_numpy_array_equal(out, exp)\n\n    @pytest.mark.parametrize(\n        \"exp\",\n        [\n            IntegerArray(np.array([2, 0], dtype=\"i8\"), np.array([False, True])),\n            IntegerArray(np.array([2, 0], dtype=\"int64\"), np.array([False, True])),\n        ],\n    )\n    def test_maybe_convert_objects_nullable_integer(self, exp):\n        # GH27335\n        arr = np.array([2, np.NaN], dtype=object)\n        result = lib.maybe_convert_objects(arr, convert_to_nullable_integer=1)\n\n        tm.assert_extension_array_equal(result, exp)\n\n    def test_maybe_convert_objects_bool_nan(self):\n        # GH32146\n        ind = Index([True, False, np.nan], dtype=object)\n        exp = np.array([True, False, np.nan], dtype=object)\n        out = lib.maybe_convert_objects(ind.values, safe=1)\n        tm.assert_numpy_array_equal(out, exp)\n\n    def test_mixed_dtypes_remain_object_array(self):\n        # GH14956\n        array = np.array([datetime(2015, 1, 1, tzinfo=pytz.utc), 1], dtype=object)\n        result = lib.maybe_convert_objects(array, convert_datetime=1)\n        tm.assert_numpy_array_equal(result, array)\n\n\nclass TestTypeInference:\n\n    # Dummy class used for testing with Python objects\n    class Dummy:\n        pass\n\n    def test_inferred_dtype_fixture(self, any_skipna_inferred_dtype):\n        # see pandas/conftest.py\n        inferred_dtype, values = any_skipna_inferred_dtype\n\n        # make sure the inferred dtype of the fixture is as requested\n        assert inferred_dtype == lib.infer_dtype(values, skipna=True)\n\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_length_zero(self, skipna):\n        result = lib.infer_dtype(np.array([], dtype=\"i4\"), skipna=skipna)\n        assert result == \"integer\"\n\n        result = lib.infer_dtype([], skipna=skipna)\n        assert result == \"empty\"\n\n        # GH 18004\n        arr = np.array([np.array([], dtype=object), np.array([], dtype=object)])\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"empty\"\n\n    def test_integers(self):\n        arr = np.array([1, 2, 3, np.int64(4), np.int32(5)], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"integer\"\n\n        arr = np.array([1, 2, 3, np.int64(4), np.int32(5), \"foo\"], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"mixed-integer\"\n\n        arr = np.array([1, 2, 3, 4, 5], dtype=\"i4\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"integer\"\n\n    @pytest.mark.parametrize(\n        \"arr, skipna\",\n        [\n            (np.array([1, 2, np.nan, np.nan, 3], dtype=\"O\"), False),\n            (np.array([1, 2, np.nan, np.nan, 3], dtype=\"O\"), True),\n            (np.array([1, 2, 3, np.int64(4), np.int32(5), np.nan], dtype=\"O\"), False),\n            (np.array([1, 2, 3, np.int64(4), np.int32(5), np.nan], dtype=\"O\"), True),\n        ],\n    )\n    def test_integer_na(self, arr, skipna):\n        # GH 27392\n        result = lib.infer_dtype(arr, skipna=skipna)\n        expected = \"integer\" if skipna else \"integer-na\"\n        assert result == expected\n\n    def test_infer_dtype_skipna_default(self):\n        # infer_dtype `skipna` default deprecated in GH#24050,\n        #  changed to True in GH#29876\n        arr = np.array([1, 2, 3, np.nan], dtype=object)\n\n        result = lib.infer_dtype(arr)\n        assert result == \"integer\"\n\n    def test_bools(self):\n        arr = np.array([True, False, True, True, True], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"boolean\"\n\n        arr = np.array([np.bool_(True), np.bool_(False)], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"boolean\"\n\n        arr = np.array([True, False, True, \"foo\"], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"mixed\"\n\n        arr = np.array([True, False, True], dtype=bool)\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"boolean\"\n\n        arr = np.array([True, np.nan, False], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"boolean\"\n\n        result = lib.infer_dtype(arr, skipna=False)\n        assert result == \"mixed\"\n\n    def test_floats(self):\n        arr = np.array([1.0, 2.0, 3.0, np.float64(4), np.float32(5)], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"floating\"\n\n        arr = np.array([1, 2, 3, np.float64(4), np.float32(5), \"foo\"], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"mixed-integer\"\n\n        arr = np.array([1, 2, 3, 4, 5], dtype=\"f4\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"floating\"\n\n        arr = np.array([1, 2, 3, 4, 5], dtype=\"f8\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"floating\"\n\n    def test_decimals(self):\n        # GH15690\n        arr = np.array([Decimal(1), Decimal(2), Decimal(3)])\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"decimal\"\n\n        arr = np.array([1.0, 2.0, Decimal(3)])\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"mixed\"\n\n        result = lib.infer_dtype(arr[::-1], skipna=True)\n        assert result == \"mixed\"\n\n        arr = np.array([Decimal(1), Decimal(\"NaN\"), Decimal(3)])\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"decimal\"\n\n        arr = np.array([Decimal(1), np.nan, Decimal(3)], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"decimal\"\n\n    # complex is compatible with nan, so skipna has no effect\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_complex(self, skipna):\n        # gets cast to complex on array construction\n        arr = np.array([1.0, 2.0, 1 + 1j])\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"complex\"\n\n        arr = np.array([1.0, 2.0, 1 + 1j], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"mixed\"\n\n        result = lib.infer_dtype(arr[::-1], skipna=skipna)\n        assert result == \"mixed\"\n\n        # gets cast to complex on array construction\n        arr = np.array([1, np.nan, 1 + 1j])\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"complex\"\n\n        arr = np.array([1.0, np.nan, 1 + 1j], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"mixed\"\n\n        # complex with nans stays complex\n        arr = np.array([1 + 1j, np.nan, 3 + 3j], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"complex\"\n\n        # test smaller complex dtype; will pass through _try_infer_map fastpath\n        arr = np.array([1 + 1j, np.nan, 3 + 3j], dtype=np.complex64)\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == \"complex\"\n\n    def test_string(self):\n        pass\n\n    def test_unicode(self):\n        arr = [\"a\", np.nan, \"c\"]\n        result = lib.infer_dtype(arr, skipna=False)\n        # This currently returns \"mixed\", but it's not clear that's optimal.\n        # This could also return \"string\" or \"mixed-string\"\n        assert result == \"mixed\"\n\n        arr = [\"a\", np.nan, \"c\"]\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"string\"\n\n        arr = [\"a\", \"c\"]\n        result = lib.infer_dtype(arr, skipna=False)\n        assert result == \"string\"\n\n    @pytest.mark.parametrize(\n        \"dtype, missing, skipna, expected\",\n        [\n            (float, np.nan, False, \"floating\"),\n            (float, np.nan, True, \"floating\"),\n            (object, np.nan, False, \"floating\"),\n            (object, np.nan, True, \"empty\"),\n            (object, None, False, \"mixed\"),\n            (object, None, True, \"empty\"),\n        ],\n    )\n    @pytest.mark.parametrize(\"box\", [pd.Series, np.array])\n    def test_object_empty(self, box, missing, dtype, skipna, expected):\n        # GH 23421\n        arr = box([missing, missing], dtype=dtype)\n\n        result = lib.infer_dtype(arr, skipna=skipna)\n        assert result == expected\n\n    def test_datetime(self):\n\n        dates = [datetime(2012, 1, x) for x in range(1, 20)]\n        index = Index(dates)\n        assert index.inferred_type == \"datetime64\"\n\n    def test_infer_dtype_datetime64(self):\n        arr = np.array(\n            [np.datetime64(\"2011-01-01\"), np.datetime64(\"2011-01-01\")], dtype=object\n        )\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime64\"\n\n    @pytest.mark.parametrize(\"na_value\", [pd.NaT, np.nan])\n    def test_infer_dtype_datetime64_with_na(self, na_value):\n        # starts with nan\n        arr = np.array([na_value, np.datetime64(\"2011-01-02\")])\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime64\"\n\n        arr = np.array([na_value, np.datetime64(\"2011-01-02\"), na_value])\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime64\"\n\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            np.array(\n                [np.timedelta64(\"nat\"), np.datetime64(\"2011-01-02\")], dtype=object\n            ),\n            np.array(\n                [np.datetime64(\"2011-01-02\"), np.timedelta64(\"nat\")], dtype=object\n            ),\n            np.array([np.datetime64(\"2011-01-01\"), Timestamp(\"2011-01-02\")]),\n            np.array([Timestamp(\"2011-01-02\"), np.datetime64(\"2011-01-01\")]),\n            np.array([np.nan, Timestamp(\"2011-01-02\"), 1.1]),\n            np.array([np.nan, \"2011-01-01\", Timestamp(\"2011-01-02\")]),\n            np.array([np.datetime64(\"nat\"), np.timedelta64(1, \"D\")], dtype=object),\n            np.array([np.timedelta64(1, \"D\"), np.datetime64(\"nat\")], dtype=object),\n        ],\n    )\n    def test_infer_datetimelike_dtype_mixed(self, arr):\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n    def test_infer_dtype_mixed_integer(self):\n        arr = np.array([np.nan, Timestamp(\"2011-01-02\"), 1])\n        assert lib.infer_dtype(arr, skipna=True) == \"mixed-integer\"\n\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            np.array([Timestamp(\"2011-01-01\"), Timestamp(\"2011-01-02\")]),\n            np.array([datetime(2011, 1, 1), datetime(2012, 2, 1)]),\n            np.array([datetime(2011, 1, 1), Timestamp(\"2011-01-02\")]),\n        ],\n    )\n    def test_infer_dtype_datetime(self, arr):\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime\"\n\n    @pytest.mark.parametrize(\"na_value\", [pd.NaT, np.nan])\n    @pytest.mark.parametrize(\n        \"time_stamp\", [Timestamp(\"2011-01-01\"), datetime(2011, 1, 1)]\n    )\n    def test_infer_dtype_datetime_with_na(self, na_value, time_stamp):\n        # starts with nan\n        arr = np.array([na_value, time_stamp])\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime\"\n\n        arr = np.array([na_value, time_stamp, na_value])\n        assert lib.infer_dtype(arr, skipna=True) == \"datetime\"\n\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            np.array([Timedelta(\"1 days\"), Timedelta(\"2 days\")]),\n            np.array([np.timedelta64(1, \"D\"), np.timedelta64(2, \"D\")], dtype=object),\n            np.array([timedelta(1), timedelta(2)]),\n        ],\n    )\n    def test_infer_dtype_timedelta(self, arr):\n        assert lib.infer_dtype(arr, skipna=True) == \"timedelta\"\n\n    @pytest.mark.parametrize(\"na_value\", [pd.NaT, np.nan])\n    @pytest.mark.parametrize(\n        \"delta\", [Timedelta(\"1 days\"), np.timedelta64(1, \"D\"), timedelta(1)]\n    )\n    def test_infer_dtype_timedelta_with_na(self, na_value, delta):\n        # starts with nan\n        arr = np.array([na_value, delta])\n        assert lib.infer_dtype(arr, skipna=True) == \"timedelta\"\n\n        arr = np.array([na_value, delta, na_value])\n        assert lib.infer_dtype(arr, skipna=True) == \"timedelta\"\n\n    def test_infer_dtype_period(self):\n        # GH 13664\n        arr = np.array([Period(\"2011-01\", freq=\"D\"), Period(\"2011-02\", freq=\"D\")])\n        assert lib.infer_dtype(arr, skipna=True) == \"period\"\n\n        arr = np.array([Period(\"2011-01\", freq=\"D\"), Period(\"2011-02\", freq=\"M\")])\n        assert lib.infer_dtype(arr, skipna=True) == \"period\"\n\n    @pytest.mark.parametrize(\"klass\", [pd.array, pd.Series, pd.Index])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_infer_dtype_period_array(self, klass, skipna):\n        # https://github.com/pandas-dev/pandas/issues/23553\n        values = klass(\n            [\n                Period(\"2011-01-01\", freq=\"D\"),\n                Period(\"2011-01-02\", freq=\"D\"),\n                pd.NaT,\n            ]\n        )\n        assert lib.infer_dtype(values, skipna=skipna) == \"period\"\n\n    def test_infer_dtype_period_mixed(self):\n        arr = np.array(\n            [Period(\"2011-01\", freq=\"M\"), np.datetime64(\"nat\")], dtype=object\n        )\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n        arr = np.array(\n            [np.datetime64(\"nat\"), Period(\"2011-01\", freq=\"M\")], dtype=object\n        )\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n    @pytest.mark.parametrize(\"na_value\", [pd.NaT, np.nan])\n    def test_infer_dtype_period_with_na(self, na_value):\n        # starts with nan\n        arr = np.array([na_value, Period(\"2011-01\", freq=\"D\")])\n        assert lib.infer_dtype(arr, skipna=True) == \"period\"\n\n        arr = np.array([na_value, Period(\"2011-01\", freq=\"D\"), na_value])\n        assert lib.infer_dtype(arr, skipna=True) == \"period\"\n\n    @pytest.mark.parametrize(\n        \"data\",\n        [\n            [datetime(2017, 6, 12, 19, 30), datetime(2017, 3, 11, 1, 15)],\n            [Timestamp(\"20170612\"), Timestamp(\"20170311\")],\n            [\n                Timestamp(\"20170612\", tz=\"US/Eastern\"),\n                Timestamp(\"20170311\", tz=\"US/Eastern\"),\n            ],\n            [date(2017, 6, 12), Timestamp(\"20170311\", tz=\"US/Eastern\")],\n            [np.datetime64(\"2017-06-12\"), np.datetime64(\"2017-03-11\")],\n            [np.datetime64(\"2017-06-12\"), datetime(2017, 3, 11, 1, 15)],\n        ],\n    )\n    def test_infer_datetimelike_array_datetime(self, data):\n        assert lib.infer_datetimelike_array(data) == \"datetime\"\n\n    @pytest.mark.parametrize(\n        \"data\",\n        [\n            [timedelta(2017, 6, 12), timedelta(2017, 3, 11)],\n            [timedelta(2017, 6, 12), date(2017, 3, 11)],\n            [np.timedelta64(2017, \"D\"), np.timedelta64(6, \"s\")],\n            [np.timedelta64(2017, \"D\"), timedelta(2017, 3, 11)],\n        ],\n    )\n    def test_infer_datetimelike_array_timedelta(self, data):\n        assert lib.infer_datetimelike_array(data) == \"timedelta\"\n\n    def test_infer_datetimelike_array_date(self):\n        arr = [date(2017, 6, 12), date(2017, 3, 11)]\n        assert lib.infer_datetimelike_array(arr) == \"date\"\n\n    @pytest.mark.parametrize(\n        \"data\",\n        [\n            [\"2017-06-12\", \"2017-03-11\"],\n            [20170612, 20170311],\n            [20170612.5, 20170311.8],\n            [Dummy(), Dummy()],\n            [Timestamp(\"20170612\"), Timestamp(\"20170311\", tz=\"US/Eastern\")],\n            [Timestamp(\"20170612\"), 20170311],\n            [timedelta(2017, 6, 12), Timestamp(\"20170311\", tz=\"US/Eastern\")],\n        ],\n    )\n    def test_infer_datetimelike_array_mixed(self, data):\n        assert lib.infer_datetimelike_array(data) == \"mixed\"\n\n    @pytest.mark.parametrize(\n        \"first, expected\",\n        [\n            [[None], \"mixed\"],\n            [[np.nan], \"mixed\"],\n            [[pd.NaT], \"nat\"],\n            [[datetime(2017, 6, 12, 19, 30), pd.NaT], \"datetime\"],\n            [[np.datetime64(\"2017-06-12\"), pd.NaT], \"datetime\"],\n            [[date(2017, 6, 12), pd.NaT], \"date\"],\n            [[timedelta(2017, 6, 12), pd.NaT], \"timedelta\"],\n            [[np.timedelta64(2017, \"D\"), pd.NaT], \"timedelta\"],\n        ],\n    )\n    @pytest.mark.parametrize(\"second\", [None, np.nan])\n    def test_infer_datetimelike_array_nan_nat_like(self, first, second, expected):\n        first.append(second)\n        assert lib.infer_datetimelike_array(first) == expected\n\n    def test_infer_dtype_all_nan_nat_like(self):\n        arr = np.array([np.nan, np.nan])\n        assert lib.infer_dtype(arr, skipna=True) == \"floating\"\n\n        # nan and None mix are result in mixed\n        arr = np.array([np.nan, np.nan, None])\n        assert lib.infer_dtype(arr, skipna=True) == \"empty\"\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n        arr = np.array([None, np.nan, np.nan])\n        assert lib.infer_dtype(arr, skipna=True) == \"empty\"\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n        # pd.NaT\n        arr = np.array([pd.NaT])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime\"\n\n        arr = np.array([pd.NaT, np.nan])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime\"\n\n        arr = np.array([np.nan, pd.NaT])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime\"\n\n        arr = np.array([np.nan, pd.NaT, np.nan])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime\"\n\n        arr = np.array([None, pd.NaT, None])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime\"\n\n        # np.datetime64(nat)\n        arr = np.array([np.datetime64(\"nat\")])\n        assert lib.infer_dtype(arr, skipna=False) == \"datetime64\"\n\n        for n in [np.nan, pd.NaT, None]:\n            arr = np.array([n, np.datetime64(\"nat\"), n])\n            assert lib.infer_dtype(arr, skipna=False) == \"datetime64\"\n\n            arr = np.array([pd.NaT, n, np.datetime64(\"nat\"), n])\n            assert lib.infer_dtype(arr, skipna=False) == \"datetime64\"\n\n        arr = np.array([np.timedelta64(\"nat\")], dtype=object)\n        assert lib.infer_dtype(arr, skipna=False) == \"timedelta\"\n\n        for n in [np.nan, pd.NaT, None]:\n            arr = np.array([n, np.timedelta64(\"nat\"), n])\n            assert lib.infer_dtype(arr, skipna=False) == \"timedelta\"\n\n            arr = np.array([pd.NaT, n, np.timedelta64(\"nat\"), n])\n            assert lib.infer_dtype(arr, skipna=False) == \"timedelta\"\n\n        # datetime / timedelta mixed\n        arr = np.array([pd.NaT, np.datetime64(\"nat\"), np.timedelta64(\"nat\"), np.nan])\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n        arr = np.array([np.timedelta64(\"nat\"), np.datetime64(\"nat\")], dtype=object)\n        assert lib.infer_dtype(arr, skipna=False) == \"mixed\"\n\n    def test_is_datetimelike_array_all_nan_nat_like(self):\n        arr = np.array([np.nan, pd.NaT, np.datetime64(\"nat\")])\n        assert lib.is_datetime_array(arr)\n        assert lib.is_datetime64_array(arr)\n        assert not lib.is_timedelta_or_timedelta64_array(arr)\n\n        arr = np.array([np.nan, pd.NaT, np.timedelta64(\"nat\")])\n        assert not lib.is_datetime_array(arr)\n        assert not lib.is_datetime64_array(arr)\n        assert lib.is_timedelta_or_timedelta64_array(arr)\n\n        arr = np.array([np.nan, pd.NaT, np.datetime64(\"nat\"), np.timedelta64(\"nat\")])\n        assert not lib.is_datetime_array(arr)\n        assert not lib.is_datetime64_array(arr)\n        assert not lib.is_timedelta_or_timedelta64_array(arr)\n\n        arr = np.array([np.nan, pd.NaT])\n        assert lib.is_datetime_array(arr)\n        assert lib.is_datetime64_array(arr)\n        assert lib.is_timedelta_or_timedelta64_array(arr)\n\n        arr = np.array([np.nan, np.nan], dtype=object)\n        assert not lib.is_datetime_array(arr)\n        assert not lib.is_datetime64_array(arr)\n        assert not lib.is_timedelta_or_timedelta64_array(arr)\n\n        assert lib.is_datetime_with_singletz_array(\n            np.array(\n                [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                ],\n                dtype=object,\n            )\n        )\n        assert not lib.is_datetime_with_singletz_array(\n            np.array(\n                [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130102\", tz=\"CET\"),\n                ],\n                dtype=object,\n            )\n        )\n\n    @pytest.mark.parametrize(\n        \"func\",\n        [\n            \"is_datetime_array\",\n            \"is_datetime64_array\",\n            \"is_bool_array\",\n            \"is_timedelta_or_timedelta64_array\",\n            \"is_date_array\",\n            \"is_time_array\",\n            \"is_interval_array\",\n            \"is_period_array\",\n        ],\n    )\n    def test_other_dtypes_for_array(self, func):\n        func = getattr(lib, func)\n        arr = np.array([\"foo\", \"bar\"])\n        assert not func(arr)\n\n        arr = np.array([1, 2])\n        assert not func(arr)\n\n    def test_date(self):\n\n        dates = [date(2012, 1, day) for day in range(1, 20)]\n        index = Index(dates)\n        assert index.inferred_type == \"date\"\n\n        dates = [date(2012, 1, day) for day in range(1, 20)] + [np.nan]\n        result = lib.infer_dtype(dates, skipna=False)\n        assert result == \"mixed\"\n\n        result = lib.infer_dtype(dates, skipna=True)\n        assert result == \"date\"\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            [date(2020, 1, 1), Timestamp(\"2020-01-01\")],\n            [Timestamp(\"2020-01-01\"), date(2020, 1, 1)],\n            [date(2020, 1, 1), pd.NaT],\n            [pd.NaT, date(2020, 1, 1)],\n        ],\n    )\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_infer_dtype_date_order_invariant(self, values, skipna):\n        # https://github.com/pandas-dev/pandas/issues/33741\n        result = lib.infer_dtype(values, skipna=skipna)\n        assert result == \"date\"\n\n    def test_is_numeric_array(self):\n\n        assert lib.is_float_array(np.array([1, 2.0]))\n        assert lib.is_float_array(np.array([1, 2.0, np.nan]))\n        assert not lib.is_float_array(np.array([1, 2]))\n\n        assert lib.is_integer_array(np.array([1, 2]))\n        assert not lib.is_integer_array(np.array([1, 2.0]))\n\n    def test_is_string_array(self):\n\n        assert lib.is_string_array(np.array([\"foo\", \"bar\"]))\n        assert not lib.is_string_array(\n            np.array([\"foo\", \"bar\", pd.NA], dtype=object), skipna=False\n        )\n        assert lib.is_string_array(\n            np.array([\"foo\", \"bar\", pd.NA], dtype=object), skipna=True\n        )\n        # NaN is not valid for string array, just NA\n        assert not lib.is_string_array(\n            np.array([\"foo\", \"bar\", np.nan], dtype=object), skipna=True\n        )\n\n        assert not lib.is_string_array(np.array([1, 2]))\n\n    def test_to_object_array_tuples(self):\n        r = (5, 6)\n        values = [r]\n        lib.to_object_array_tuples(values)\n\n        # make sure record array works\n        record = namedtuple(\"record\", \"x y\")\n        r = record(5, 6)\n        values = [r]\n        lib.to_object_array_tuples(values)\n\n    def test_object(self):\n\n        # GH 7431\n        # cannot infer more than this as only a single element\n        arr = np.array([None], dtype=\"O\")\n        result = lib.infer_dtype(arr, skipna=False)\n        assert result == \"mixed\"\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"empty\"\n\n    def test_to_object_array_width(self):\n        # see gh-13320\n        rows = [[1, 2, 3], [4, 5, 6]]\n\n        expected = np.array(rows, dtype=object)\n        out = lib.to_object_array(rows)\n        tm.assert_numpy_array_equal(out, expected)\n\n        expected = np.array(rows, dtype=object)\n        out = lib.to_object_array(rows, min_width=1)\n        tm.assert_numpy_array_equal(out, expected)\n\n        expected = np.array(\n            [[1, 2, 3, None, None], [4, 5, 6, None, None]], dtype=object\n        )\n        out = lib.to_object_array(rows, min_width=5)\n        tm.assert_numpy_array_equal(out, expected)\n\n    def test_is_period(self):\n        assert lib.is_period(Period(\"2011-01\", freq=\"M\"))\n        assert not lib.is_period(PeriodIndex([\"2011-01\"], freq=\"M\"))\n        assert not lib.is_period(Timestamp(\"2011-01\"))\n        assert not lib.is_period(1)\n        assert not lib.is_period(np.nan)\n\n    def test_categorical(self):\n\n        # GH 8974\n        arr = Categorical(list(\"abc\"))\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"categorical\"\n\n        result = lib.infer_dtype(Series(arr), skipna=True)\n        assert result == \"categorical\"\n\n        arr = Categorical(list(\"abc\"), categories=[\"cegfab\"], ordered=True)\n        result = lib.infer_dtype(arr, skipna=True)\n        assert result == \"categorical\"\n\n        result = lib.infer_dtype(Series(arr), skipna=True)\n        assert result == \"categorical\"\n\n    def test_interval(self):\n        idx = pd.IntervalIndex.from_breaks(range(5), closed=\"both\")\n        inferred = lib.infer_dtype(idx, skipna=False)\n        assert inferred == \"interval\"\n\n        inferred = lib.infer_dtype(idx._data, skipna=False)\n        assert inferred == \"interval\"\n\n        inferred = lib.infer_dtype(Series(idx), skipna=False)\n        assert inferred == \"interval\"\n\n    @pytest.mark.parametrize(\"klass\", [pd.array, pd.Series])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    @pytest.mark.parametrize(\"data\", [[\"a\", \"b\", \"c\"], [\"a\", \"b\", pd.NA]])\n    def test_string_dtype(self, data, skipna, klass):\n        # StringArray\n        val = klass(data, dtype=\"string\")\n        inferred = lib.infer_dtype(val, skipna=skipna)\n        assert inferred == \"string\"\n\n    @pytest.mark.parametrize(\"klass\", [pd.array, pd.Series])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    @pytest.mark.parametrize(\"data\", [[True, False, True], [True, False, pd.NA]])\n    def test_boolean_dtype(self, data, skipna, klass):\n        # BooleanArray\n        val = klass(data, dtype=\"boolean\")\n        inferred = lib.infer_dtype(val, skipna=skipna)\n        assert inferred == \"boolean\"\n\n\nclass TestNumberScalar:\n    def test_is_number(self):\n\n        assert is_number(True)\n        assert is_number(1)\n        assert is_number(1.1)\n        assert is_number(1 + 3j)\n        assert is_number(np.int64(1))\n        assert is_number(np.float64(1.1))\n        assert is_number(np.complex128(1 + 3j))\n        assert is_number(np.nan)\n\n        assert not is_number(None)\n        assert not is_number(\"x\")\n        assert not is_number(datetime(2011, 1, 1))\n        assert not is_number(np.datetime64(\"2011-01-01\"))\n        assert not is_number(Timestamp(\"2011-01-01\"))\n        assert not is_number(Timestamp(\"2011-01-01\", tz=\"US/Eastern\"))\n        assert not is_number(timedelta(1000))\n        assert not is_number(Timedelta(\"1 days\"))\n\n        # questionable\n        assert not is_number(np.bool_(False))\n        assert is_number(np.timedelta64(1, \"D\"))\n\n    def test_is_bool(self):\n        assert is_bool(True)\n        assert is_bool(False)\n        assert is_bool(np.bool_(False))\n\n        assert not is_bool(1)\n        assert not is_bool(1.1)\n        assert not is_bool(1 + 3j)\n        assert not is_bool(np.int64(1))\n        assert not is_bool(np.float64(1.1))\n        assert not is_bool(np.complex128(1 + 3j))\n        assert not is_bool(np.nan)\n        assert not is_bool(None)\n        assert not is_bool(\"x\")\n        assert not is_bool(datetime(2011, 1, 1))\n        assert not is_bool(np.datetime64(\"2011-01-01\"))\n        assert not is_bool(Timestamp(\"2011-01-01\"))\n        assert not is_bool(Timestamp(\"2011-01-01\", tz=\"US/Eastern\"))\n        assert not is_bool(timedelta(1000))\n        assert not is_bool(np.timedelta64(1, \"D\"))\n        assert not is_bool(Timedelta(\"1 days\"))\n\n    def test_is_integer(self):\n        assert is_integer(1)\n        assert is_integer(np.int64(1))\n\n        assert not is_integer(True)\n        assert not is_integer(1.1)\n        assert not is_integer(1 + 3j)\n        assert not is_integer(False)\n        assert not is_integer(np.bool_(False))\n        assert not is_integer(np.float64(1.1))\n        assert not is_integer(np.complex128(1 + 3j))\n        assert not is_integer(np.nan)\n        assert not is_integer(None)\n        assert not is_integer(\"x\")\n        assert not is_integer(datetime(2011, 1, 1))\n        assert not is_integer(np.datetime64(\"2011-01-01\"))\n        assert not is_integer(Timestamp(\"2011-01-01\"))\n        assert not is_integer(Timestamp(\"2011-01-01\", tz=\"US/Eastern\"))\n        assert not is_integer(timedelta(1000))\n        assert not is_integer(Timedelta(\"1 days\"))\n        assert not is_integer(np.timedelta64(1, \"D\"))\n\n    def test_is_float(self):\n        assert is_float(1.1)\n        assert is_float(np.float64(1.1))\n        assert is_float(np.nan)\n\n        assert not is_float(True)\n        assert not is_float(1)\n        assert not is_float(1 + 3j)\n        assert not is_float(False)\n        assert not is_float(np.bool_(False))\n        assert not is_float(np.int64(1))\n        assert not is_float(np.complex128(1 + 3j))\n        assert not is_float(None)\n        assert not is_float(\"x\")\n        assert not is_float(datetime(2011, 1, 1))\n        assert not is_float(np.datetime64(\"2011-01-01\"))\n        assert not is_float(Timestamp(\"2011-01-01\"))\n        assert not is_float(Timestamp(\"2011-01-01\", tz=\"US/Eastern\"))\n        assert not is_float(timedelta(1000))\n        assert not is_float(np.timedelta64(1, \"D\"))\n        assert not is_float(Timedelta(\"1 days\"))\n\n    def test_is_datetime_dtypes(self):\n\n        ts = pd.date_range(\"20130101\", periods=3)\n        tsa = pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n\n        assert is_datetime64_dtype(\"datetime64\")\n        assert is_datetime64_dtype(\"datetime64[ns]\")\n        assert is_datetime64_dtype(ts)\n        assert not is_datetime64_dtype(tsa)\n\n        assert not is_datetime64_ns_dtype(\"datetime64\")\n        assert is_datetime64_ns_dtype(\"datetime64[ns]\")\n        assert is_datetime64_ns_dtype(ts)\n        assert is_datetime64_ns_dtype(tsa)\n\n        assert is_datetime64_any_dtype(\"datetime64\")\n        assert is_datetime64_any_dtype(\"datetime64[ns]\")\n        assert is_datetime64_any_dtype(ts)\n        assert is_datetime64_any_dtype(tsa)\n\n        assert not is_datetime64tz_dtype(\"datetime64\")\n        assert not is_datetime64tz_dtype(\"datetime64[ns]\")\n        assert not is_datetime64tz_dtype(ts)\n        assert is_datetime64tz_dtype(tsa)\n\n        for tz in [\"US/Eastern\", \"UTC\"]:\n            dtype = f\"datetime64[ns, {tz}]\"\n            assert not is_datetime64_dtype(dtype)\n            assert is_datetime64tz_dtype(dtype)\n            assert is_datetime64_ns_dtype(dtype)\n            assert is_datetime64_any_dtype(dtype)\n\n    def test_is_timedelta(self):\n        assert is_timedelta64_dtype(\"timedelta64\")\n        assert is_timedelta64_dtype(\"timedelta64[ns]\")\n        assert not is_timedelta64_ns_dtype(\"timedelta64\")\n        assert is_timedelta64_ns_dtype(\"timedelta64[ns]\")\n\n        tdi = TimedeltaIndex([1e14, 2e14], dtype=\"timedelta64[ns]\")\n        assert is_timedelta64_dtype(tdi)\n        assert is_timedelta64_ns_dtype(tdi)\n        assert is_timedelta64_ns_dtype(tdi.astype(\"timedelta64[ns]\"))\n\n        # Conversion to Int64Index:\n        assert not is_timedelta64_ns_dtype(tdi.astype(\"timedelta64\"))\n        assert not is_timedelta64_ns_dtype(tdi.astype(\"timedelta64[h]\"))\n\n\nclass TestIsScalar:\n    def test_is_scalar_builtin_scalars(self):\n        assert is_scalar(None)\n        assert is_scalar(True)\n        assert is_scalar(False)\n        assert is_scalar(Fraction())\n        assert is_scalar(0.0)\n        assert is_scalar(1)\n        assert is_scalar(complex(2))\n        assert is_scalar(float(\"NaN\"))\n        assert is_scalar(np.nan)\n        assert is_scalar(\"foobar\")\n        assert is_scalar(b\"foobar\")\n        assert is_scalar(datetime(2014, 1, 1))\n        assert is_scalar(date(2014, 1, 1))\n        assert is_scalar(time(12, 0))\n        assert is_scalar(timedelta(hours=1))\n        assert is_scalar(pd.NaT)\n        assert is_scalar(pd.NA)\n\n    def test_is_scalar_builtin_nonscalars(self):\n        assert not is_scalar({})\n        assert not is_scalar([])\n        assert not is_scalar([1])\n        assert not is_scalar(())\n        assert not is_scalar((1,))\n        assert not is_scalar(slice(None))\n        assert not is_scalar(Ellipsis)\n\n    def test_is_scalar_numpy_array_scalars(self):\n        assert is_scalar(np.int64(1))\n        assert is_scalar(np.float64(1.0))\n        assert is_scalar(np.int32(1))\n        assert is_scalar(np.complex64(2))\n        assert is_scalar(np.object_(\"foobar\"))\n        assert is_scalar(np.str_(\"foobar\"))\n        assert is_scalar(np.unicode_(\"foobar\"))\n        assert is_scalar(np.bytes_(b\"foobar\"))\n        assert is_scalar(np.datetime64(\"2014-01-01\"))\n        assert is_scalar(np.timedelta64(1, \"h\"))\n\n    def test_is_scalar_numpy_zerodim_arrays(self):\n        for zerodim in [\n            np.array(1),\n            np.array(\"foobar\"),\n            np.array(np.datetime64(\"2014-01-01\")),\n            np.array(np.timedelta64(1, \"h\")),\n            np.array(np.datetime64(\"NaT\")),\n        ]:\n            assert not is_scalar(zerodim)\n            assert is_scalar(lib.item_from_zerodim(zerodim))\n\n    @pytest.mark.filterwarnings(\"ignore::PendingDeprecationWarning\")\n    def test_is_scalar_numpy_arrays(self):\n        assert not is_scalar(np.array([]))\n        assert not is_scalar(np.array([[]]))\n        assert not is_scalar(np.matrix(\"1; 2\"))\n\n    def test_is_scalar_pandas_scalars(self):\n        assert is_scalar(Timestamp(\"2014-01-01\"))\n        assert is_scalar(Timedelta(hours=1))\n        assert is_scalar(Period(\"2014-01-01\"))\n        assert is_scalar(Interval(left=0, right=1))\n        assert is_scalar(DateOffset(days=1))\n        assert is_scalar(pd.offsets.Minute(3))\n\n    def test_is_scalar_pandas_containers(self):\n        assert not is_scalar(Series(dtype=object))\n        assert not is_scalar(Series([1]))\n        assert not is_scalar(DataFrame())\n        assert not is_scalar(DataFrame([[1]]))\n        assert not is_scalar(Index([]))\n        assert not is_scalar(Index([1]))\n        assert not is_scalar(Categorical([]))\n        assert not is_scalar(DatetimeIndex([])._data)\n        assert not is_scalar(TimedeltaIndex([])._data)\n        assert not is_scalar(DatetimeIndex([])._data.to_period(\"D\"))\n        assert not is_scalar(pd.array([1, 2, 3]))\n\n    def test_is_scalar_number(self):\n        # Number() is not recognied by PyNumber_Check, so by extension\n        #  is not recognized by is_scalar, but instances of non-abstract\n        #  subclasses are.\n\n        class Numeric(Number):\n            def __init__(self, value):\n                self.value = value\n\n            def __int__(self):\n                return self.value\n\n        num = Numeric(1)\n        assert is_scalar(num)\n\n\ndef test_datetimeindex_from_empty_datetime64_array():\n    for unit in [\"ms\", \"us\", \"ns\"]:\n        idx = DatetimeIndex(np.array([], dtype=f\"datetime64[{unit}]\"))\n        assert len(idx) == 0\n\n\ndef test_nan_to_nat_conversions():\n\n    df = DataFrame(\n        {\"A\": np.asarray(range(10), dtype=\"float64\"), \"B\": Timestamp(\"20010101\")}\n    )\n    df.iloc[3:6, :] = np.nan\n    result = df.loc[4, \"B\"]\n    assert result is pd.NaT\n\n    s = df[\"B\"].copy()\n    s[8:9] = np.nan\n    assert s[8] is pd.NaT\n\n\n@td.skip_if_no_scipy\n@pytest.mark.filterwarnings(\"ignore::PendingDeprecationWarning\")\ndef test_is_scipy_sparse(spmatrix):\n    assert is_scipy_sparse(spmatrix([[0, 1]]))\n    assert not is_scipy_sparse(np.array([1]))\n\n\ndef test_ensure_int32():\n    values = np.arange(10, dtype=np.int32)\n    result = ensure_int32(values)\n    assert result.dtype == np.int32\n\n    values = np.arange(10, dtype=np.int64)\n    result = ensure_int32(values)\n    assert result.dtype == np.int32\n"
    },
    {
      "filename": "pandas/tests/extension/base/dtype.py",
      "content": "import warnings\n\nimport numpy as np\nimport pytest\n\nimport pandas as pd\nfrom pandas.api.types import infer_dtype, is_object_dtype, is_string_dtype\nfrom pandas.tests.extension.base.base import BaseExtensionTests\n\n\nclass BaseDtypeTests(BaseExtensionTests):\n    \"\"\"Base class for ExtensionDtype classes\"\"\"\n\n    def test_name(self, dtype):\n        assert isinstance(dtype.name, str)\n\n    def test_kind(self, dtype):\n        valid = set(\"biufcmMOSUV\")\n        assert dtype.kind in valid\n\n    def test_construct_from_string_own_name(self, dtype):\n        result = dtype.construct_from_string(dtype.name)\n        assert type(result) is type(dtype)\n\n        # check OK as classmethod\n        result = type(dtype).construct_from_string(dtype.name)\n        assert type(result) is type(dtype)\n\n    def test_is_dtype_from_name(self, dtype):\n        result = type(dtype).is_dtype(dtype.name)\n        assert result is True\n\n    def test_is_dtype_unboxes_dtype(self, data, dtype):\n        assert dtype.is_dtype(data) is True\n\n    def test_is_dtype_from_self(self, dtype):\n        result = type(dtype).is_dtype(dtype)\n        assert result is True\n\n    def test_is_dtype_other_input(self, dtype):\n        assert dtype.is_dtype([1, 2, 3]) is False\n\n    def test_is_not_string_type(self, dtype):\n        return not is_string_dtype(dtype)\n\n    def test_is_not_object_type(self, dtype):\n        return not is_object_dtype(dtype)\n\n    def test_eq_with_str(self, dtype):\n        assert dtype == dtype.name\n        assert dtype != dtype.name + \"-suffix\"\n\n    def test_eq_with_numpy_object(self, dtype):\n        assert dtype != np.dtype(\"object\")\n\n    def test_eq_with_self(self, dtype):\n        assert dtype == dtype\n        assert dtype != object()\n\n    def test_array_type(self, data, dtype):\n        assert dtype.construct_array_type() is type(data)\n\n    def test_check_dtype(self, data):\n        dtype = data.dtype\n\n        # check equivalency for using .dtypes\n        df = pd.DataFrame(\n            {\"A\": pd.Series(data, dtype=dtype), \"B\": data, \"C\": \"foo\", \"D\": 1}\n        )\n\n        # TODO(numpy-1.20): This warnings filter and if block can be removed\n        # once we require numpy>=1.20\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n            result = df.dtypes == str(dtype)\n            # NumPy>=1.20.0, but not pandas.compat.numpy till there\n            # is a wheel available with this change.\n            try:\n                new_numpy_behavior = np.dtype(\"int64\") != \"Int64\"\n            except TypeError:\n                new_numpy_behavior = True\n\n        if dtype.name == \"Int64\" and not new_numpy_behavior:\n            expected = pd.Series([True, True, False, True], index=list(\"ABCD\"))\n        else:\n            expected = pd.Series([True, True, False, False], index=list(\"ABCD\"))\n\n        self.assert_series_equal(result, expected)\n\n        expected = pd.Series([True, True, False, False], index=list(\"ABCD\"))\n        result = df.dtypes.apply(str) == str(dtype)\n        self.assert_series_equal(result, expected)\n\n    def test_hashable(self, dtype):\n        hash(dtype)  # no error\n\n    def test_str(self, dtype):\n        assert str(dtype) == dtype.name\n\n    def test_eq(self, dtype):\n        assert dtype == dtype.name\n        assert dtype != \"anonther_type\"\n\n    def test_construct_from_string(self, dtype):\n        dtype_instance = type(dtype).construct_from_string(dtype.name)\n        assert isinstance(dtype_instance, type(dtype))\n\n    def test_construct_from_string_another_type_raises(self, dtype):\n        msg = f\"Cannot construct a '{type(dtype).__name__}' from 'another_type'\"\n        with pytest.raises(TypeError, match=msg):\n            type(dtype).construct_from_string(\"another_type\")\n\n    def test_construct_from_string_wrong_type_raises(self, dtype):\n        with pytest.raises(\n            TypeError,\n            match=\"'construct_from_string' expects a string, got <class 'int'>\",\n        ):\n            type(dtype).construct_from_string(0)\n\n    def test_get_common_dtype(self, dtype):\n        # in practice we will not typically call this with a 1-length list\n        # (we shortcut to just use that dtype as the common dtype), but\n        # still testing as good practice to have this working (and it is the\n        # only case we can test in general)\n        assert dtype._get_common_dtype([dtype]) == dtype\n\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_infer_dtype(self, data, data_missing, skipna):\n        # only testing that this works without raising an error\n        res = infer_dtype(data, skipna=skipna)\n        assert isinstance(res, str)\n        res = infer_dtype(data_missing, skipna=skipna)\n        assert isinstance(res, str)\n"
    },
    {
      "filename": "pandas/tests/extension/decimal/test_decimal.py",
      "content": "import decimal\nimport math\nimport operator\n\nimport numpy as np\nimport pytest\n\nimport pandas as pd\nimport pandas._testing as tm\nfrom pandas.api.types import infer_dtype\nfrom pandas.tests.extension import base\nfrom pandas.tests.extension.decimal.array import (\n    DecimalArray,\n    DecimalDtype,\n    make_data,\n    to_decimal,\n)\n\n\n@pytest.fixture\ndef dtype():\n    return DecimalDtype()\n\n\n@pytest.fixture\ndef data():\n    return DecimalArray(make_data())\n\n\n@pytest.fixture\ndef data_for_twos():\n    return DecimalArray([decimal.Decimal(2) for _ in range(100)])\n\n\n@pytest.fixture\ndef data_missing():\n    return DecimalArray([decimal.Decimal(\"NaN\"), decimal.Decimal(1)])\n\n\n@pytest.fixture\ndef data_for_sorting():\n    return DecimalArray(\n        [decimal.Decimal(\"1\"), decimal.Decimal(\"2\"), decimal.Decimal(\"0\")]\n    )\n\n\n@pytest.fixture\ndef data_missing_for_sorting():\n    return DecimalArray(\n        [decimal.Decimal(\"1\"), decimal.Decimal(\"NaN\"), decimal.Decimal(\"0\")]\n    )\n\n\n@pytest.fixture\ndef na_cmp():\n    return lambda x, y: x.is_nan() and y.is_nan()\n\n\n@pytest.fixture\ndef na_value():\n    return decimal.Decimal(\"NaN\")\n\n\n@pytest.fixture\ndef data_for_grouping():\n    b = decimal.Decimal(\"1.0\")\n    a = decimal.Decimal(\"0.0\")\n    c = decimal.Decimal(\"2.0\")\n    na = decimal.Decimal(\"NaN\")\n    return DecimalArray([b, b, na, na, a, a, b, c])\n\n\nclass BaseDecimal:\n    @classmethod\n    def assert_series_equal(cls, left, right, *args, **kwargs):\n        def convert(x):\n            # need to convert array([Decimal(NaN)], dtype='object') to np.NaN\n            # because Series[object].isnan doesn't recognize decimal(NaN) as\n            # NA.\n            try:\n                return math.isnan(x)\n            except TypeError:\n                return False\n\n        if left.dtype == \"object\":\n            left_na = left.apply(convert)\n        else:\n            left_na = left.isna()\n        if right.dtype == \"object\":\n            right_na = right.apply(convert)\n        else:\n            right_na = right.isna()\n\n        tm.assert_series_equal(left_na, right_na)\n        return tm.assert_series_equal(left[~left_na], right[~right_na], *args, **kwargs)\n\n    @classmethod\n    def assert_frame_equal(cls, left, right, *args, **kwargs):\n        # TODO(EA): select_dtypes\n        tm.assert_index_equal(\n            left.columns,\n            right.columns,\n            exact=kwargs.get(\"check_column_type\", \"equiv\"),\n            check_names=kwargs.get(\"check_names\", True),\n            check_exact=kwargs.get(\"check_exact\", False),\n            check_categorical=kwargs.get(\"check_categorical\", True),\n            obj=f\"{kwargs.get('obj', 'DataFrame')}.columns\",\n        )\n\n        decimals = (left.dtypes == \"decimal\").index\n\n        for col in decimals:\n            cls.assert_series_equal(left[col], right[col], *args, **kwargs)\n\n        left = left.drop(columns=decimals)\n        right = right.drop(columns=decimals)\n        tm.assert_frame_equal(left, right, *args, **kwargs)\n\n\nclass TestDtype(BaseDecimal, base.BaseDtypeTests):\n    def test_hashable(self, dtype):\n        pass\n\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_infer_dtype(self, data, data_missing, skipna):\n        # here overriding base test to ensure we fall back to return\n        # \"unknown-array\" for an EA pandas doesn't know\n        assert infer_dtype(data, skipna=skipna) == \"unknown-array\"\n        assert infer_dtype(data_missing, skipna=skipna) == \"unknown-array\"\n\n\nclass TestInterface(BaseDecimal, base.BaseInterfaceTests):\n    pass\n\n\nclass TestConstructors(BaseDecimal, base.BaseConstructorsTests):\n    pass\n\n\nclass TestReshaping(BaseDecimal, base.BaseReshapingTests):\n    pass\n\n\nclass TestGetitem(BaseDecimal, base.BaseGetitemTests):\n    def test_take_na_value_other_decimal(self):\n        arr = DecimalArray([decimal.Decimal(\"1.0\"), decimal.Decimal(\"2.0\")])\n        result = arr.take([0, -1], allow_fill=True, fill_value=decimal.Decimal(\"-1.0\"))\n        expected = DecimalArray([decimal.Decimal(\"1.0\"), decimal.Decimal(\"-1.0\")])\n        self.assert_extension_array_equal(result, expected)\n\n\nclass TestMissing(BaseDecimal, base.BaseMissingTests):\n    pass\n\n\nclass Reduce:\n    def check_reduce(self, s, op_name, skipna):\n\n        if op_name in [\"median\", \"skew\", \"kurt\"]:\n            msg = r\"decimal does not support the .* operation\"\n            with pytest.raises(NotImplementedError, match=msg):\n                getattr(s, op_name)(skipna=skipna)\n\n        else:\n            result = getattr(s, op_name)(skipna=skipna)\n            expected = getattr(np.asarray(s), op_name)()\n            tm.assert_almost_equal(result, expected)\n\n\nclass TestNumericReduce(Reduce, base.BaseNumericReduceTests):\n    pass\n\n\nclass TestBooleanReduce(Reduce, base.BaseBooleanReduceTests):\n    pass\n\n\nclass TestMethods(BaseDecimal, base.BaseMethodsTests):\n    @pytest.mark.parametrize(\"dropna\", [True, False])\n    def test_value_counts(self, all_data, dropna, request):\n        if any(x != x for x in all_data):\n            mark = pytest.mark.xfail(\n                reason=\"tm.assert_series_equal incorrectly raises\",\n                raises=AssertionError,\n            )\n            request.node.add_marker(mark)\n\n        all_data = all_data[:10]\n        if dropna:\n            other = np.array(all_data[~all_data.isna()])\n        else:\n            other = all_data\n\n        vcs = pd.Series(all_data).value_counts(dropna=dropna)\n        vcs_ex = pd.Series(other).value_counts(dropna=dropna)\n\n        with decimal.localcontext() as ctx:\n            # avoid raising when comparing Decimal(\"NAN\") < Decimal(2)\n            ctx.traps[decimal.InvalidOperation] = False\n\n            result = vcs.sort_index()\n            expected = vcs_ex.sort_index()\n\n        tm.assert_series_equal(result, expected)\n\n    def test_value_counts_with_normalize(self, data):\n        return super().test_value_counts_with_normalize(data)\n\n\nclass TestCasting(BaseDecimal, base.BaseCastingTests):\n    pass\n\n\nclass TestGroupby(BaseDecimal, base.BaseGroupbyTests):\n    def test_groupby_apply_identity(self, data_for_grouping, request):\n        if any(x != x for x in data_for_grouping):\n            mark = pytest.mark.xfail(reason=\"tm.assert_series_equal raises incorrectly\")\n            request.node.add_marker(mark)\n        super().test_groupby_apply_identity(data_for_grouping)\n\n    def test_groupby_agg_extension(self, data_for_grouping):\n        super().test_groupby_agg_extension(data_for_grouping)\n\n\nclass TestSetitem(BaseDecimal, base.BaseSetitemTests):\n    pass\n\n\nclass TestPrinting(BaseDecimal, base.BasePrintingTests):\n    def test_series_repr(self, data):\n        # Overriding this base test to explicitly test that\n        # the custom _formatter is used\n        ser = pd.Series(data)\n        assert data.dtype.name in repr(ser)\n        assert \"Decimal: \" in repr(ser)\n\n\n# TODO(extension)\n@pytest.mark.xfail(\n    reason=(\n        \"raising AssertionError as this is not implemented, though easy enough to do\"\n    )\n)\ndef test_series_constructor_coerce_data_to_extension_dtype_raises():\n    xpr = (\n        \"Cannot cast data to extension dtype 'decimal'. Pass the \"\n        \"extension array directly.\"\n    )\n    with pytest.raises(ValueError, match=xpr):\n        pd.Series([0, 1, 2], dtype=DecimalDtype())\n\n\ndef test_series_constructor_with_dtype():\n    arr = DecimalArray([decimal.Decimal(\"10.0\")])\n    result = pd.Series(arr, dtype=DecimalDtype())\n    expected = pd.Series(arr)\n    tm.assert_series_equal(result, expected)\n\n    result = pd.Series(arr, dtype=\"int64\")\n    expected = pd.Series([10])\n    tm.assert_series_equal(result, expected)\n\n\ndef test_dataframe_constructor_with_dtype():\n    arr = DecimalArray([decimal.Decimal(\"10.0\")])\n\n    result = pd.DataFrame({\"A\": arr}, dtype=DecimalDtype())\n    expected = pd.DataFrame({\"A\": arr})\n    tm.assert_frame_equal(result, expected)\n\n    arr = DecimalArray([decimal.Decimal(\"10.0\")])\n    result = pd.DataFrame({\"A\": arr}, dtype=\"int64\")\n    expected = pd.DataFrame({\"A\": [10]})\n    tm.assert_frame_equal(result, expected)\n\n\n@pytest.mark.parametrize(\"frame\", [True, False])\ndef test_astype_dispatches(frame):\n    # This is a dtype-specific test that ensures Series[decimal].astype\n    # gets all the way through to ExtensionArray.astype\n    # Designing a reliable smoke test that works for arbitrary data types\n    # is difficult.\n    data = pd.Series(DecimalArray([decimal.Decimal(2)]), name=\"a\")\n    ctx = decimal.Context()\n    ctx.prec = 5\n\n    if frame:\n        data = data.to_frame()\n\n    result = data.astype(DecimalDtype(ctx))\n\n    if frame:\n        result = result[\"a\"]\n\n    assert result.dtype.context.prec == ctx.prec\n\n\nclass TestArithmeticOps(BaseDecimal, base.BaseArithmeticOpsTests):\n    def check_opname(self, s, op_name, other, exc=None):\n        super().check_opname(s, op_name, other, exc=None)\n\n    def test_arith_series_with_array(self, data, all_arithmetic_operators):\n        op_name = all_arithmetic_operators\n        s = pd.Series(data)\n\n        context = decimal.getcontext()\n        divbyzerotrap = context.traps[decimal.DivisionByZero]\n        invalidoptrap = context.traps[decimal.InvalidOperation]\n        context.traps[decimal.DivisionByZero] = 0\n        context.traps[decimal.InvalidOperation] = 0\n\n        # Decimal supports ops with int, but not float\n        other = pd.Series([int(d * 100) for d in data])\n        self.check_opname(s, op_name, other)\n\n        if \"mod\" not in op_name:\n            self.check_opname(s, op_name, s * 2)\n\n        self.check_opname(s, op_name, 0)\n        self.check_opname(s, op_name, 5)\n        context.traps[decimal.DivisionByZero] = divbyzerotrap\n        context.traps[decimal.InvalidOperation] = invalidoptrap\n\n    def _check_divmod_op(self, s, op, other, exc=NotImplementedError):\n        # We implement divmod\n        super()._check_divmod_op(s, op, other, exc=None)\n\n\nclass TestComparisonOps(BaseDecimal, base.BaseComparisonOpsTests):\n    def check_opname(self, s, op_name, other, exc=None):\n        super().check_opname(s, op_name, other, exc=None)\n\n    def _compare_other(self, s, data, op_name, other):\n        self.check_opname(s, op_name, other)\n\n    def test_compare_scalar(self, data, all_compare_operators):\n        op_name = all_compare_operators\n        s = pd.Series(data)\n        self._compare_other(s, data, op_name, 0.5)\n\n    def test_compare_array(self, data, all_compare_operators):\n        op_name = all_compare_operators\n        s = pd.Series(data)\n\n        alter = np.random.choice([-1, 0, 1], len(data))\n        # Randomly double, halve or keep same value\n        other = pd.Series(data) * [decimal.Decimal(pow(2.0, i)) for i in alter]\n        self._compare_other(s, data, op_name, other)\n\n\nclass DecimalArrayWithoutFromSequence(DecimalArray):\n    \"\"\"Helper class for testing error handling in _from_sequence.\"\"\"\n\n    def _from_sequence(cls, scalars, dtype=None, copy=False):\n        raise KeyError(\"For the test\")\n\n\nclass DecimalArrayWithoutCoercion(DecimalArrayWithoutFromSequence):\n    @classmethod\n    def _create_arithmetic_method(cls, op):\n        return cls._create_method(op, coerce_to_dtype=False)\n\n\nDecimalArrayWithoutCoercion._add_arithmetic_ops()\n\n\ndef test_combine_from_sequence_raises():\n    # https://github.com/pandas-dev/pandas/issues/22850\n    ser = pd.Series(\n        DecimalArrayWithoutFromSequence(\n            [decimal.Decimal(\"1.0\"), decimal.Decimal(\"2.0\")]\n        )\n    )\n    result = ser.combine(ser, operator.add)\n\n    # note: object dtype\n    expected = pd.Series(\n        [decimal.Decimal(\"2.0\"), decimal.Decimal(\"4.0\")], dtype=\"object\"\n    )\n    tm.assert_series_equal(result, expected)\n\n\n@pytest.mark.parametrize(\n    \"class_\", [DecimalArrayWithoutFromSequence, DecimalArrayWithoutCoercion]\n)\ndef test_scalar_ops_from_sequence_raises(class_):\n    # op(EA, EA) should return an EA, or an ndarray if it's not possible\n    # to return an EA with the return values.\n    arr = class_([decimal.Decimal(\"1.0\"), decimal.Decimal(\"2.0\")])\n    result = arr + arr\n    expected = np.array(\n        [decimal.Decimal(\"2.0\"), decimal.Decimal(\"4.0\")], dtype=\"object\"\n    )\n    tm.assert_numpy_array_equal(result, expected)\n\n\n@pytest.mark.parametrize(\n    \"reverse, expected_div, expected_mod\",\n    [(False, [0, 1, 1, 2], [1, 0, 1, 0]), (True, [2, 1, 0, 0], [0, 0, 2, 2])],\n)\ndef test_divmod_array(reverse, expected_div, expected_mod):\n    # https://github.com/pandas-dev/pandas/issues/22930\n    arr = to_decimal([1, 2, 3, 4])\n    if reverse:\n        div, mod = divmod(2, arr)\n    else:\n        div, mod = divmod(arr, 2)\n    expected_div = to_decimal(expected_div)\n    expected_mod = to_decimal(expected_mod)\n\n    tm.assert_extension_array_equal(div, expected_div)\n    tm.assert_extension_array_equal(mod, expected_mod)\n\n\ndef test_ufunc_fallback(data):\n    a = data[:5]\n    s = pd.Series(a, index=range(3, 8))\n    result = np.abs(s)\n    expected = pd.Series(np.abs(a), index=range(3, 8))\n    tm.assert_series_equal(result, expected)\n\n\ndef test_array_ufunc():\n    a = to_decimal([1, 2, 3])\n    result = np.exp(a)\n    expected = to_decimal(np.exp(a._data))\n    tm.assert_extension_array_equal(result, expected)\n\n\ndef test_array_ufunc_series():\n    a = to_decimal([1, 2, 3])\n    s = pd.Series(a)\n    result = np.exp(s)\n    expected = pd.Series(to_decimal(np.exp(a._data)))\n    tm.assert_series_equal(result, expected)\n\n\ndef test_array_ufunc_series_scalar_other():\n    # check _HANDLED_TYPES\n    a = to_decimal([1, 2, 3])\n    s = pd.Series(a)\n    result = np.add(s, decimal.Decimal(1))\n    expected = pd.Series(np.add(a, decimal.Decimal(1)))\n    tm.assert_series_equal(result, expected)\n\n\ndef test_array_ufunc_series_defer():\n    a = to_decimal([1, 2, 3])\n    s = pd.Series(a)\n\n    expected = pd.Series(to_decimal([2, 4, 6]))\n    r1 = np.add(s, a)\n    r2 = np.add(a, s)\n\n    tm.assert_series_equal(r1, expected)\n    tm.assert_series_equal(r2, expected)\n\n\ndef test_groupby_agg():\n    # Ensure that the result of agg is inferred to be decimal dtype\n    # https://github.com/pandas-dev/pandas/issues/29141\n\n    data = make_data()[:5]\n    df = pd.DataFrame(\n        {\"id1\": [0, 0, 0, 1, 1], \"id2\": [0, 1, 0, 1, 1], \"decimals\": DecimalArray(data)}\n    )\n\n    # single key, selected column\n    expected = pd.Series(to_decimal([data[0], data[3]]))\n    result = df.groupby(\"id1\")[\"decimals\"].agg(lambda x: x.iloc[0])\n    tm.assert_series_equal(result, expected, check_names=False)\n    result = df[\"decimals\"].groupby(df[\"id1\"]).agg(lambda x: x.iloc[0])\n    tm.assert_series_equal(result, expected, check_names=False)\n\n    # multiple keys, selected column\n    expected = pd.Series(\n        to_decimal([data[0], data[1], data[3]]),\n        index=pd.MultiIndex.from_tuples([(0, 0), (0, 1), (1, 1)]),\n    )\n    result = df.groupby([\"id1\", \"id2\"])[\"decimals\"].agg(lambda x: x.iloc[0])\n    tm.assert_series_equal(result, expected, check_names=False)\n    result = df[\"decimals\"].groupby([df[\"id1\"], df[\"id2\"]]).agg(lambda x: x.iloc[0])\n    tm.assert_series_equal(result, expected, check_names=False)\n\n    # multiple columns\n    expected = pd.DataFrame({\"id2\": [0, 1], \"decimals\": to_decimal([data[0], data[3]])})\n    result = df.groupby(\"id1\").agg(lambda x: x.iloc[0])\n    tm.assert_frame_equal(result, expected, check_names=False)\n\n\ndef test_groupby_agg_ea_method(monkeypatch):\n    # Ensure that the result of agg is inferred to be decimal dtype\n    # https://github.com/pandas-dev/pandas/issues/29141\n\n    def DecimalArray__my_sum(self):\n        return np.sum(np.array(self))\n\n    monkeypatch.setattr(DecimalArray, \"my_sum\", DecimalArray__my_sum, raising=False)\n\n    data = make_data()[:5]\n    df = pd.DataFrame({\"id\": [0, 0, 0, 1, 1], \"decimals\": DecimalArray(data)})\n    expected = pd.Series(to_decimal([data[0] + data[1] + data[2], data[3] + data[4]]))\n\n    result = df.groupby(\"id\")[\"decimals\"].agg(lambda x: x.values.my_sum())\n    tm.assert_series_equal(result, expected, check_names=False)\n    s = pd.Series(DecimalArray(data))\n    result = s.groupby(np.array([0, 0, 0, 1, 1])).agg(lambda x: x.values.my_sum())\n    tm.assert_series_equal(result, expected, check_names=False)\n\n\ndef test_indexing_no_materialize(monkeypatch):\n    # See https://github.com/pandas-dev/pandas/issues/29708\n    # Ensure that indexing operations do not materialize (convert to a numpy\n    # array) the ExtensionArray unnecessary\n\n    def DecimalArray__array__(self, dtype=None):\n        raise Exception(\"tried to convert a DecimalArray to a numpy array\")\n\n    monkeypatch.setattr(DecimalArray, \"__array__\", DecimalArray__array__, raising=False)\n\n    data = make_data()\n    s = pd.Series(DecimalArray(data))\n    df = pd.DataFrame({\"a\": s, \"b\": range(len(s))})\n\n    # ensure the following operations do not raise an error\n    s[s > 0.5]\n    df[s > 0.5]\n    s.at[0]\n    df.at[0, \"a\"]\n\n\ndef test_to_numpy_keyword():\n    # test the extra keyword\n    values = [decimal.Decimal(\"1.1111\"), decimal.Decimal(\"2.2222\")]\n    expected = np.array(\n        [decimal.Decimal(\"1.11\"), decimal.Decimal(\"2.22\")], dtype=\"object\"\n    )\n    a = pd.array(values, dtype=\"decimal\")\n    result = a.to_numpy(decimals=2)\n    tm.assert_numpy_array_equal(result, expected)\n\n    result = pd.Series(a).to_numpy(decimals=2)\n    tm.assert_numpy_array_equal(result, expected)\n"
    },
    {
      "filename": "pandas/tests/io/test_parquet.py",
      "content": "\"\"\" test parquet compat \"\"\"\nimport datetime\nfrom distutils.version import LooseVersion\nfrom io import BytesIO\nimport os\nimport pathlib\nfrom warnings import catch_warnings\n\nimport numpy as np\nimport pytest\n\nfrom pandas.compat import PY38, is_platform_windows\nimport pandas.util._test_decorators as td\n\nimport pandas as pd\nimport pandas._testing as tm\n\nfrom pandas.io.parquet import (\n    FastParquetImpl,\n    PyArrowImpl,\n    get_engine,\n    read_parquet,\n    to_parquet,\n)\n\ntry:\n    import pyarrow\n\n    _HAVE_PYARROW = True\nexcept ImportError:\n    _HAVE_PYARROW = False\n\ntry:\n    import fastparquet\n\n    _HAVE_FASTPARQUET = True\nexcept ImportError:\n    _HAVE_FASTPARQUET = False\n\n\npytestmark = pytest.mark.filterwarnings(\n    \"ignore:RangeIndex.* is deprecated:DeprecationWarning\"\n)\n\n\n# setup engines & skips\n@pytest.fixture(\n    params=[\n        pytest.param(\n            \"fastparquet\",\n            marks=pytest.mark.skipif(\n                not _HAVE_FASTPARQUET, reason=\"fastparquet is not installed\"\n            ),\n        ),\n        pytest.param(\n            \"pyarrow\",\n            marks=pytest.mark.skipif(\n                not _HAVE_PYARROW, reason=\"pyarrow is not installed\"\n            ),\n        ),\n    ]\n)\ndef engine(request):\n    return request.param\n\n\n@pytest.fixture\ndef pa():\n    if not _HAVE_PYARROW:\n        pytest.skip(\"pyarrow is not installed\")\n    return \"pyarrow\"\n\n\n@pytest.fixture\ndef fp():\n    if not _HAVE_FASTPARQUET:\n        pytest.skip(\"fastparquet is not installed\")\n    return \"fastparquet\"\n\n\n@pytest.fixture\ndef df_compat():\n    return pd.DataFrame({\"A\": [1, 2, 3], \"B\": \"foo\"})\n\n\n@pytest.fixture\ndef df_cross_compat():\n    df = pd.DataFrame(\n        {\n            \"a\": list(\"abc\"),\n            \"b\": list(range(1, 4)),\n            # 'c': np.arange(3, 6).astype('u1'),\n            \"d\": np.arange(4.0, 7.0, dtype=\"float64\"),\n            \"e\": [True, False, True],\n            \"f\": pd.date_range(\"20130101\", periods=3),\n            # 'g': pd.date_range('20130101', periods=3,\n            #                    tz='US/Eastern'),\n            # 'h': pd.date_range('20130101', periods=3, freq='ns')\n        }\n    )\n    return df\n\n\n@pytest.fixture\ndef df_full():\n    return pd.DataFrame(\n        {\n            \"string\": list(\"abc\"),\n            \"string_with_nan\": [\"a\", np.nan, \"c\"],\n            \"string_with_none\": [\"a\", None, \"c\"],\n            \"bytes\": [b\"foo\", b\"bar\", b\"baz\"],\n            \"unicode\": [\"foo\", \"bar\", \"baz\"],\n            \"int\": list(range(1, 4)),\n            \"uint\": np.arange(3, 6).astype(\"u1\"),\n            \"float\": np.arange(4.0, 7.0, dtype=\"float64\"),\n            \"float_with_nan\": [2.0, np.nan, 3.0],\n            \"bool\": [True, False, True],\n            \"datetime\": pd.date_range(\"20130101\", periods=3),\n            \"datetime_with_nat\": [\n                pd.Timestamp(\"20130101\"),\n                pd.NaT,\n                pd.Timestamp(\"20130103\"),\n            ],\n        }\n    )\n\n\n@pytest.fixture(\n    params=[\n        datetime.datetime.now(datetime.timezone.utc),\n        datetime.datetime.now(datetime.timezone.min),\n        datetime.datetime.now(datetime.timezone.max),\n        datetime.datetime.strptime(\"2019-01-04T16:41:24+0200\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        datetime.datetime.strptime(\"2019-01-04T16:41:24+0215\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        datetime.datetime.strptime(\"2019-01-04T16:41:24-0200\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        datetime.datetime.strptime(\"2019-01-04T16:41:24-0215\", \"%Y-%m-%dT%H:%M:%S%z\"),\n    ]\n)\ndef timezone_aware_date_list(request):\n    return request.param\n\n\ndef check_round_trip(\n    df,\n    engine=None,\n    path=None,\n    write_kwargs=None,\n    read_kwargs=None,\n    expected=None,\n    check_names=True,\n    check_like=False,\n    check_dtype=True,\n    repeat=2,\n):\n    \"\"\"Verify parquet serializer and deserializer produce the same results.\n\n    Performs a pandas to disk and disk to pandas round trip,\n    then compares the 2 resulting DataFrames to verify equality.\n\n    Parameters\n    ----------\n    df: Dataframe\n    engine: str, optional\n        'pyarrow' or 'fastparquet'\n    path: str, optional\n    write_kwargs: dict of str:str, optional\n    read_kwargs: dict of str:str, optional\n    expected: DataFrame, optional\n        Expected deserialization result, otherwise will be equal to `df`\n    check_names: list of str, optional\n        Closed set of column names to be compared\n    check_like: bool, optional\n        If True, ignore the order of index & columns.\n    repeat: int, optional\n        How many times to repeat the test\n    \"\"\"\n    write_kwargs = write_kwargs or {\"compression\": None}\n    read_kwargs = read_kwargs or {}\n\n    if expected is None:\n        expected = df\n\n    if engine:\n        write_kwargs[\"engine\"] = engine\n        read_kwargs[\"engine\"] = engine\n\n    def compare(repeat):\n        for _ in range(repeat):\n            df.to_parquet(path, **write_kwargs)\n            with catch_warnings(record=True):\n                actual = read_parquet(path, **read_kwargs)\n\n            tm.assert_frame_equal(\n                expected,\n                actual,\n                check_names=check_names,\n                check_like=check_like,\n                check_dtype=check_dtype,\n            )\n\n    if path is None:\n        with tm.ensure_clean() as path:\n            compare(repeat)\n    else:\n        compare(repeat)\n\n\ndef test_invalid_engine(df_compat):\n    msg = \"engine must be one of 'pyarrow', 'fastparquet'\"\n    with pytest.raises(ValueError, match=msg):\n        check_round_trip(df_compat, \"foo\", \"bar\")\n\n\ndef test_options_py(df_compat, pa):\n    # use the set option\n\n    with pd.option_context(\"io.parquet.engine\", \"pyarrow\"):\n        check_round_trip(df_compat)\n\n\ndef test_options_fp(df_compat, fp):\n    # use the set option\n\n    with pd.option_context(\"io.parquet.engine\", \"fastparquet\"):\n        check_round_trip(df_compat)\n\n\ndef test_options_auto(df_compat, fp, pa):\n    # use the set option\n\n    with pd.option_context(\"io.parquet.engine\", \"auto\"):\n        check_round_trip(df_compat)\n\n\ndef test_options_get_engine(fp, pa):\n    assert isinstance(get_engine(\"pyarrow\"), PyArrowImpl)\n    assert isinstance(get_engine(\"fastparquet\"), FastParquetImpl)\n\n    with pd.option_context(\"io.parquet.engine\", \"pyarrow\"):\n        assert isinstance(get_engine(\"auto\"), PyArrowImpl)\n        assert isinstance(get_engine(\"pyarrow\"), PyArrowImpl)\n        assert isinstance(get_engine(\"fastparquet\"), FastParquetImpl)\n\n    with pd.option_context(\"io.parquet.engine\", \"fastparquet\"):\n        assert isinstance(get_engine(\"auto\"), FastParquetImpl)\n        assert isinstance(get_engine(\"pyarrow\"), PyArrowImpl)\n        assert isinstance(get_engine(\"fastparquet\"), FastParquetImpl)\n\n    with pd.option_context(\"io.parquet.engine\", \"auto\"):\n        assert isinstance(get_engine(\"auto\"), PyArrowImpl)\n        assert isinstance(get_engine(\"pyarrow\"), PyArrowImpl)\n        assert isinstance(get_engine(\"fastparquet\"), FastParquetImpl)\n\n\ndef test_get_engine_auto_error_message():\n    # Expect different error messages from get_engine(engine=\"auto\")\n    # if engines aren't installed vs. are installed but bad version\n    from pandas.compat._optional import VERSIONS\n\n    # Do we have engines installed, but a bad version of them?\n    pa_min_ver = VERSIONS.get(\"pyarrow\")\n    fp_min_ver = VERSIONS.get(\"fastparquet\")\n    have_pa_bad_version = (\n        False\n        if not _HAVE_PYARROW\n        else LooseVersion(pyarrow.__version__) < LooseVersion(pa_min_ver)\n    )\n    have_fp_bad_version = (\n        False\n        if not _HAVE_FASTPARQUET\n        else LooseVersion(fastparquet.__version__) < LooseVersion(fp_min_ver)\n    )\n    # Do we have usable engines installed?\n    have_usable_pa = _HAVE_PYARROW and not have_pa_bad_version\n    have_usable_fp = _HAVE_FASTPARQUET and not have_fp_bad_version\n\n    if not have_usable_pa and not have_usable_fp:\n        # No usable engines found.\n        if have_pa_bad_version:\n            match = f\"Pandas requires version .{pa_min_ver}. or newer of .pyarrow.\"\n            with pytest.raises(ImportError, match=match):\n                get_engine(\"auto\")\n        else:\n            match = \"Missing optional dependency .pyarrow.\"\n            with pytest.raises(ImportError, match=match):\n                get_engine(\"auto\")\n\n        if have_fp_bad_version:\n            match = f\"Pandas requires version .{fp_min_ver}. or newer of .fastparquet.\"\n            with pytest.raises(ImportError, match=match):\n                get_engine(\"auto\")\n        else:\n            match = \"Missing optional dependency .fastparquet.\"\n            with pytest.raises(ImportError, match=match):\n                get_engine(\"auto\")\n\n\ndef test_cross_engine_pa_fp(df_cross_compat, pa, fp):\n    # cross-compat with differing reading/writing engines\n\n    df = df_cross_compat\n    with tm.ensure_clean() as path:\n        df.to_parquet(path, engine=pa, compression=None)\n\n        result = read_parquet(path, engine=fp)\n        tm.assert_frame_equal(result, df)\n\n        result = read_parquet(path, engine=fp, columns=[\"a\", \"d\"])\n        tm.assert_frame_equal(result, df[[\"a\", \"d\"]])\n\n\ndef test_cross_engine_fp_pa(request, df_cross_compat, pa, fp):\n    # cross-compat with differing reading/writing engines\n\n    if (\n        LooseVersion(pyarrow.__version__) < \"0.15\"\n        and LooseVersion(pyarrow.__version__) >= \"0.13\"\n    ):\n        request.node.add_marker(\n            pytest.mark.xfail(\n                \"Reading fastparquet with pyarrow in 0.14 fails: \"\n                \"https://issues.apache.org/jira/browse/ARROW-6492\"\n            )\n        )\n\n    df = df_cross_compat\n    with tm.ensure_clean() as path:\n        df.to_parquet(path, engine=fp, compression=None)\n\n        with catch_warnings(record=True):\n            result = read_parquet(path, engine=pa)\n            tm.assert_frame_equal(result, df)\n\n            result = read_parquet(path, engine=pa, columns=[\"a\", \"d\"])\n            tm.assert_frame_equal(result, df[[\"a\", \"d\"]])\n\n\nclass Base:\n    def check_error_on_write(self, df, engine, exc, err_msg):\n        # check that we are raising the exception on writing\n        with tm.ensure_clean() as path:\n            with pytest.raises(exc, match=err_msg):\n                to_parquet(df, path, engine, compression=None)\n\n    def check_external_error_on_write(self, df, engine, exc):\n        # check that an external library is raising the exception on writing\n        with tm.ensure_clean() as path:\n            with tm.external_error_raised(exc):\n                to_parquet(df, path, engine, compression=None)\n\n    @tm.network\n    def test_parquet_read_from_url(self, df_compat, engine):\n        if engine != \"auto\":\n            pytest.importorskip(engine)\n        url = (\n            \"https://raw.githubusercontent.com/pandas-dev/pandas/\"\n            \"master/pandas/tests/io/data/parquet/simple.parquet\"\n        )\n        df = pd.read_parquet(url)\n        tm.assert_frame_equal(df, df_compat)\n\n\nclass TestBasic(Base):\n    def test_error(self, engine):\n        for obj in [\n            pd.Series([1, 2, 3]),\n            1,\n            \"foo\",\n            pd.Timestamp(\"20130101\"),\n            np.array([1, 2, 3]),\n        ]:\n            msg = \"to_parquet only supports IO with DataFrames\"\n            self.check_error_on_write(obj, engine, ValueError, msg)\n\n    def test_columns_dtypes(self, engine):\n        df = pd.DataFrame({\"string\": list(\"abc\"), \"int\": list(range(1, 4))})\n\n        # unicode\n        df.columns = [\"foo\", \"bar\"]\n        check_round_trip(df, engine)\n\n    def test_columns_dtypes_invalid(self, engine):\n        df = pd.DataFrame({\"string\": list(\"abc\"), \"int\": list(range(1, 4))})\n\n        msg = \"parquet must have string column names\"\n        # numeric\n        df.columns = [0, 1]\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n        # bytes\n        df.columns = [b\"foo\", b\"bar\"]\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n        # python object\n        df.columns = [\n            datetime.datetime(2011, 1, 1, 0, 0),\n            datetime.datetime(2011, 1, 1, 1, 1),\n        ]\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n    @pytest.mark.parametrize(\"compression\", [None, \"gzip\", \"snappy\", \"brotli\"])\n    def test_compression(self, engine, compression):\n\n        if compression == \"snappy\":\n            pytest.importorskip(\"snappy\")\n\n        elif compression == \"brotli\":\n            pytest.importorskip(\"brotli\")\n\n        df = pd.DataFrame({\"A\": [1, 2, 3]})\n        check_round_trip(df, engine, write_kwargs={\"compression\": compression})\n\n    def test_read_columns(self, engine):\n        # GH18154\n        df = pd.DataFrame({\"string\": list(\"abc\"), \"int\": list(range(1, 4))})\n\n        expected = pd.DataFrame({\"string\": list(\"abc\")})\n        check_round_trip(\n            df, engine, expected=expected, read_kwargs={\"columns\": [\"string\"]}\n        )\n\n    def test_write_index(self, engine):\n        check_names = engine != \"fastparquet\"\n\n        df = pd.DataFrame({\"A\": [1, 2, 3]})\n        check_round_trip(df, engine)\n\n        indexes = [\n            [2, 3, 4],\n            pd.date_range(\"20130101\", periods=3),\n            list(\"abc\"),\n            [1, 3, 4],\n        ]\n        # non-default index\n        for index in indexes:\n            df.index = index\n            if isinstance(index, pd.DatetimeIndex):\n                df.index = df.index._with_freq(None)  # freq doesnt round-trip\n            check_round_trip(df, engine, check_names=check_names)\n\n        # index with meta-data\n        df.index = [0, 1, 2]\n        df.index.name = \"foo\"\n        check_round_trip(df, engine)\n\n    def test_write_multiindex(self, pa):\n        # Not supported in fastparquet as of 0.1.3 or older pyarrow version\n        engine = pa\n\n        df = pd.DataFrame({\"A\": [1, 2, 3]})\n        index = pd.MultiIndex.from_tuples([(\"a\", 1), (\"a\", 2), (\"b\", 1)])\n        df.index = index\n        check_round_trip(df, engine)\n\n    def test_multiindex_with_columns(self, pa):\n        engine = pa\n        dates = pd.date_range(\"01-Jan-2018\", \"01-Dec-2018\", freq=\"MS\")\n        df = pd.DataFrame(np.random.randn(2 * len(dates), 3), columns=list(\"ABC\"))\n        index1 = pd.MultiIndex.from_product(\n            [[\"Level1\", \"Level2\"], dates], names=[\"level\", \"date\"]\n        )\n        index2 = index1.copy(names=None)\n        for index in [index1, index2]:\n            df.index = index\n\n            check_round_trip(df, engine)\n            check_round_trip(\n                df, engine, read_kwargs={\"columns\": [\"A\", \"B\"]}, expected=df[[\"A\", \"B\"]]\n            )\n\n    def test_write_ignoring_index(self, engine):\n        # ENH 20768\n        # Ensure index=False omits the index from the written Parquet file.\n        df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [\"q\", \"r\", \"s\"]})\n\n        write_kwargs = {\"compression\": None, \"index\": False}\n\n        # Because we're dropping the index, we expect the loaded dataframe to\n        # have the default integer index.\n        expected = df.reset_index(drop=True)\n\n        check_round_trip(df, engine, write_kwargs=write_kwargs, expected=expected)\n\n        # Ignore custom index\n        df = pd.DataFrame(\n            {\"a\": [1, 2, 3], \"b\": [\"q\", \"r\", \"s\"]}, index=[\"zyx\", \"wvu\", \"tsr\"]\n        )\n\n        check_round_trip(df, engine, write_kwargs=write_kwargs, expected=expected)\n\n        # Ignore multi-indexes as well.\n        arrays = [\n            [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n            [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n        ]\n        df = pd.DataFrame(\n            {\"one\": list(range(8)), \"two\": [-i for i in range(8)]}, index=arrays\n        )\n\n        expected = df.reset_index(drop=True)\n        check_round_trip(df, engine, write_kwargs=write_kwargs, expected=expected)\n\n    def test_write_column_multiindex(self, engine):\n        # Not able to write column multi-indexes with non-string column names.\n        mi_columns = pd.MultiIndex.from_tuples([(\"a\", 1), (\"a\", 2), (\"b\", 1)])\n        df = pd.DataFrame(np.random.randn(4, 3), columns=mi_columns)\n        msg = (\n            r\"\\s*parquet must have string column names for all values in\\s*\"\n            \"each level of the MultiIndex\"\n        )\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n    def test_write_column_multiindex_nonstring(self, pa):\n        # GH #34777\n        # Not supported in fastparquet as of 0.1.3\n        engine = pa\n\n        # Not able to write column multi-indexes with non-string column names\n        arrays = [\n            [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n            [1, 2, 1, 2, 1, 2, 1, 2],\n        ]\n        df = pd.DataFrame(np.random.randn(8, 8), columns=arrays)\n        df.columns.names = [\"Level1\", \"Level2\"]\n        msg = (\n            r\"\\s*parquet must have string column names for all values in\\s*\"\n            \"each level of the MultiIndex\"\n        )\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n    def test_write_column_multiindex_string(self, pa):\n        # GH #34777\n        # Not supported in fastparquet as of 0.1.3\n        engine = pa\n\n        # Write column multi-indexes with string column names\n        arrays = [\n            [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n            [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n        ]\n        df = pd.DataFrame(np.random.randn(8, 8), columns=arrays)\n        df.columns.names = [\"ColLevel1\", \"ColLevel2\"]\n\n        check_round_trip(df, engine)\n\n    def test_write_column_index_string(self, pa):\n        # GH #34777\n        # Not supported in fastparquet as of 0.1.3\n        engine = pa\n\n        # Write column indexes with string column names\n        arrays = [\"bar\", \"baz\", \"foo\", \"qux\"]\n        df = pd.DataFrame(np.random.randn(8, 4), columns=arrays)\n        df.columns.name = \"StringCol\"\n\n        check_round_trip(df, engine)\n\n    def test_write_column_index_nonstring(self, pa):\n        # GH #34777\n        # Not supported in fastparquet as of 0.1.3\n        engine = pa\n\n        # Write column indexes with string column names\n        arrays = [1, 2, 3, 4]\n        df = pd.DataFrame(np.random.randn(8, 4), columns=arrays)\n        df.columns.name = \"NonStringCol\"\n        msg = r\"parquet must have string column names\"\n        self.check_error_on_write(df, engine, ValueError, msg)\n\n\nclass TestParquetPyArrow(Base):\n    def test_basic(self, pa, df_full):\n\n        df = df_full\n\n        # additional supported types for pyarrow\n        dti = pd.date_range(\"20130101\", periods=3, tz=\"Europe/Brussels\")\n        dti = dti._with_freq(None)  # freq doesnt round-trip\n        df[\"datetime_tz\"] = dti\n        df[\"bool_with_none\"] = [True, None, True]\n\n        check_round_trip(df, pa)\n\n    def test_basic_subset_columns(self, pa, df_full):\n        # GH18628\n\n        df = df_full\n        # additional supported types for pyarrow\n        df[\"datetime_tz\"] = pd.date_range(\"20130101\", periods=3, tz=\"Europe/Brussels\")\n\n        check_round_trip(\n            df,\n            pa,\n            expected=df[[\"string\", \"int\"]],\n            read_kwargs={\"columns\": [\"string\", \"int\"]},\n        )\n\n    def test_to_bytes_without_path_or_buf_provided(self, pa, df_full):\n        # GH 37105\n\n        buf_bytes = df_full.to_parquet(engine=pa)\n        assert isinstance(buf_bytes, bytes)\n\n        buf_stream = BytesIO(buf_bytes)\n        res = pd.read_parquet(buf_stream)\n\n        tm.assert_frame_equal(df_full, res)\n\n    def test_duplicate_columns(self, pa):\n        # not currently able to handle duplicate columns\n        df = pd.DataFrame(np.arange(12).reshape(4, 3), columns=list(\"aaa\")).copy()\n        self.check_error_on_write(df, pa, ValueError, \"Duplicate column names found\")\n\n    def test_unsupported(self, pa):\n        if LooseVersion(pyarrow.__version__) < LooseVersion(\"0.15.1.dev\"):\n            # period - will be supported using an extension type with pyarrow 1.0\n            df = pd.DataFrame({\"a\": pd.period_range(\"2013\", freq=\"M\", periods=3)})\n            # pyarrow 0.11 raises ArrowTypeError\n            # older pyarrows raise ArrowInvalid\n            self.check_external_error_on_write(df, pa, pyarrow.ArrowException)\n\n        # timedelta\n        df = pd.DataFrame({\"a\": pd.timedelta_range(\"1 day\", periods=3)})\n        self.check_external_error_on_write(df, pa, NotImplementedError)\n\n        # mixed python objects\n        df = pd.DataFrame({\"a\": [\"a\", 1, 2.0]})\n        # pyarrow 0.11 raises ArrowTypeError\n        # older pyarrows raise ArrowInvalid\n        self.check_external_error_on_write(df, pa, pyarrow.ArrowException)\n\n    def test_categorical(self, pa):\n\n        # supported in >= 0.7.0\n        df = pd.DataFrame()\n        df[\"a\"] = pd.Categorical(list(\"abcdef\"))\n\n        # test for null, out-of-order values, and unobserved category\n        df[\"b\"] = pd.Categorical(\n            [\"bar\", \"foo\", \"foo\", \"bar\", None, \"bar\"],\n            dtype=pd.CategoricalDtype([\"foo\", \"bar\", \"baz\"]),\n        )\n\n        # test for ordered flag\n        df[\"c\"] = pd.Categorical(\n            [\"a\", \"b\", \"c\", \"a\", \"c\", \"b\"], categories=[\"b\", \"c\", \"d\"], ordered=True\n        )\n\n        if LooseVersion(pyarrow.__version__) >= LooseVersion(\"0.15.0\"):\n            check_round_trip(df, pa)\n        else:\n            # de-serialized as object for pyarrow < 0.15\n            expected = df.astype(object)\n            check_round_trip(df, pa, expected=expected)\n\n    @pytest.mark.xfail(\n        is_platform_windows() and PY38,\n        reason=\"localhost connection rejected\",\n        strict=False,\n    )\n    def test_s3_roundtrip_explicit_fs(self, df_compat, s3_resource, pa, s3so):\n        s3fs = pytest.importorskip(\"s3fs\")\n        if LooseVersion(pyarrow.__version__) <= LooseVersion(\"0.17.0\"):\n            pytest.skip()\n        s3 = s3fs.S3FileSystem(**s3so)\n        kw = {\"filesystem\": s3}\n        check_round_trip(\n            df_compat,\n            pa,\n            path=\"pandas-test/pyarrow.parquet\",\n            read_kwargs=kw,\n            write_kwargs=kw,\n        )\n\n    def test_s3_roundtrip(self, df_compat, s3_resource, pa, s3so):\n        if LooseVersion(pyarrow.__version__) <= LooseVersion(\"0.17.0\"):\n            pytest.skip()\n        # GH #19134\n        s3so = {\"storage_options\": s3so}\n        check_round_trip(\n            df_compat,\n            pa,\n            path=\"s3://pandas-test/pyarrow.parquet\",\n            read_kwargs=s3so,\n            write_kwargs=s3so,\n        )\n\n    @td.skip_if_no(\"s3fs\")  # also requires flask\n    @pytest.mark.parametrize(\n        \"partition_col\",\n        [\n            [\"A\"],\n            [],\n        ],\n    )\n    def test_s3_roundtrip_for_dir(\n        self, df_compat, s3_resource, pa, partition_col, s3so\n    ):\n        # GH #26388\n        expected_df = df_compat.copy()\n\n        # GH #35791\n        # read_table uses the new Arrow Datasets API since pyarrow 1.0.0\n        # Previous behaviour was pyarrow partitioned columns become 'category' dtypes\n        # These are added to back of dataframe on read. In new API category dtype is\n        # only used if partition field is string, but this changed again to use\n        # category dtype for all types (not only strings) in pyarrow 2.0.0\n        pa10 = (LooseVersion(pyarrow.__version__) >= LooseVersion(\"1.0.0\")) and (\n            LooseVersion(pyarrow.__version__) < LooseVersion(\"2.0.0\")\n        )\n        if partition_col:\n            if pa10:\n                partition_col_type = \"int32\"\n            else:\n                partition_col_type = \"category\"\n\n            expected_df[partition_col] = expected_df[partition_col].astype(\n                partition_col_type\n            )\n\n        check_round_trip(\n            df_compat,\n            pa,\n            expected=expected_df,\n            path=\"s3://pandas-test/parquet_dir\",\n            read_kwargs={\"storage_options\": s3so},\n            write_kwargs={\n                \"partition_cols\": partition_col,\n                \"compression\": None,\n                \"storage_options\": s3so,\n            },\n            check_like=True,\n            repeat=1,\n        )\n\n    @td.skip_if_no(\"pyarrow\")\n    def test_read_file_like_obj_support(self, df_compat):\n        buffer = BytesIO()\n        df_compat.to_parquet(buffer)\n        df_from_buf = pd.read_parquet(buffer)\n        tm.assert_frame_equal(df_compat, df_from_buf)\n\n    @td.skip_if_no(\"pyarrow\")\n    def test_expand_user(self, df_compat, monkeypatch):\n        monkeypatch.setenv(\"HOME\", \"TestingUser\")\n        monkeypatch.setenv(\"USERPROFILE\", \"TestingUser\")\n        with pytest.raises(OSError, match=r\".*TestingUser.*\"):\n            pd.read_parquet(\"~/file.parquet\")\n        with pytest.raises(OSError, match=r\".*TestingUser.*\"):\n            df_compat.to_parquet(\"~/file.parquet\")\n\n    def test_partition_cols_supported(self, pa, df_full):\n        # GH #23283\n        partition_cols = [\"bool\", \"int\"]\n        df = df_full\n        with tm.ensure_clean_dir() as path:\n            df.to_parquet(path, partition_cols=partition_cols, compression=None)\n            import pyarrow.parquet as pq\n\n            dataset = pq.ParquetDataset(path, validate_schema=False)\n            assert len(dataset.partitions.partition_names) == 2\n            assert dataset.partitions.partition_names == set(partition_cols)\n            assert read_parquet(path).shape == df.shape\n\n    def test_partition_cols_string(self, pa, df_full):\n        # GH #27117\n        partition_cols = \"bool\"\n        partition_cols_list = [partition_cols]\n        df = df_full\n        with tm.ensure_clean_dir() as path:\n            df.to_parquet(path, partition_cols=partition_cols, compression=None)\n            import pyarrow.parquet as pq\n\n            dataset = pq.ParquetDataset(path, validate_schema=False)\n            assert len(dataset.partitions.partition_names) == 1\n            assert dataset.partitions.partition_names == set(partition_cols_list)\n            assert read_parquet(path).shape == df.shape\n\n    @pytest.mark.parametrize(\"path_type\", [str, pathlib.Path])\n    def test_partition_cols_pathlib(self, pa, df_compat, path_type):\n        # GH 35902\n\n        partition_cols = \"B\"\n        partition_cols_list = [partition_cols]\n        df = df_compat\n\n        with tm.ensure_clean_dir() as path_str:\n            path = path_type(path_str)\n            df.to_parquet(path, partition_cols=partition_cols_list)\n            assert read_parquet(path).shape == df.shape\n\n    def test_empty_dataframe(self, pa):\n        # GH #27339\n        df = pd.DataFrame()\n        check_round_trip(df, pa)\n\n    def test_write_with_schema(self, pa):\n        import pyarrow\n\n        df = pd.DataFrame({\"x\": [0, 1]})\n        schema = pyarrow.schema([pyarrow.field(\"x\", type=pyarrow.bool_())])\n        out_df = df.astype(bool)\n        check_round_trip(df, pa, write_kwargs={\"schema\": schema}, expected=out_df)\n\n    @td.skip_if_no(\"pyarrow\", min_version=\"0.15.0\")\n    def test_additional_extension_arrays(self, pa):\n        # test additional ExtensionArrays that are supported through the\n        # __arrow_array__ protocol\n        df = pd.DataFrame(\n            {\n                \"a\": pd.Series([1, 2, 3], dtype=\"Int64\"),\n                \"b\": pd.Series([1, 2, 3], dtype=\"UInt32\"),\n                \"c\": pd.Series([\"a\", None, \"c\"], dtype=\"string\"),\n            }\n        )\n        if LooseVersion(pyarrow.__version__) >= LooseVersion(\"0.16.0\"):\n            expected = df\n        else:\n            # de-serialized as plain int / object\n            expected = df.assign(\n                a=df.a.astype(\"int64\"), b=df.b.astype(\"int64\"), c=df.c.astype(\"object\")\n            )\n        check_round_trip(df, pa, expected=expected)\n\n        df = pd.DataFrame({\"a\": pd.Series([1, 2, 3, None], dtype=\"Int64\")})\n        if LooseVersion(pyarrow.__version__) >= LooseVersion(\"0.16.0\"):\n            expected = df\n        else:\n            # if missing values in integer, currently de-serialized as float\n            expected = df.assign(a=df.a.astype(\"float64\"))\n        check_round_trip(df, pa, expected=expected)\n\n    @td.skip_if_no(\"pyarrow\", min_version=\"0.16.0\")\n    def test_additional_extension_types(self, pa):\n        # test additional ExtensionArrays that are supported through the\n        # __arrow_array__ protocol + by defining a custom ExtensionType\n        df = pd.DataFrame(\n            {\n                # Arrow does not yet support struct in writing to Parquet (ARROW-1644)\n                # \"c\": pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 2), (3, 4)]),\n                \"d\": pd.period_range(\"2012-01-01\", periods=3, freq=\"D\"),\n            }\n        )\n        check_round_trip(df, pa)\n\n    @td.skip_if_no(\"pyarrow\", min_version=\"0.16\")\n    def test_use_nullable_dtypes(self, pa):\n        import pyarrow.parquet as pq\n\n        table = pyarrow.table(\n            {\n                \"a\": pyarrow.array([1, 2, 3, None], \"int64\"),\n                \"b\": pyarrow.array([1, 2, 3, None], \"uint8\"),\n                \"c\": pyarrow.array([\"a\", \"b\", \"c\", None]),\n                \"d\": pyarrow.array([True, False, True, None]),\n            }\n        )\n        with tm.ensure_clean() as path:\n            # write manually with pyarrow to write integers\n            pq.write_table(table, path)\n            result1 = read_parquet(path)\n            result2 = read_parquet(path, use_nullable_dtypes=True)\n\n        assert result1[\"a\"].dtype == np.dtype(\"float64\")\n        expected = pd.DataFrame(\n            {\n                \"a\": pd.array([1, 2, 3, None], dtype=\"Int64\"),\n                \"b\": pd.array([1, 2, 3, None], dtype=\"UInt8\"),\n                \"c\": pd.array([\"a\", \"b\", \"c\", None], dtype=\"string\"),\n                \"d\": pd.array([True, False, True, None], dtype=\"boolean\"),\n            }\n        )\n        tm.assert_frame_equal(result2, expected)\n\n    @td.skip_if_no(\"pyarrow\", min_version=\"0.14\")\n    def test_timestamp_nanoseconds(self, pa):\n        # with version 2.0, pyarrow defaults to writing the nanoseconds, so\n        # this should work without error\n        df = pd.DataFrame({\"a\": pd.date_range(\"2017-01-01\", freq=\"1n\", periods=10)})\n        check_round_trip(df, pa, write_kwargs={\"version\": \"2.0\"})\n\n    def test_timezone_aware_index(self, pa, timezone_aware_date_list):\n        if LooseVersion(pyarrow.__version__) >= LooseVersion(\"2.0.0\"):\n            # temporary skip this test until it is properly resolved\n            # https://github.com/pandas-dev/pandas/issues/37286\n            pytest.skip()\n        idx = 5 * [timezone_aware_date_list]\n        df = pd.DataFrame(index=idx, data={\"index_as_col\": idx})\n\n        # see gh-36004\n        # compare time(zone) values only, skip their class:\n        # pyarrow always creates fixed offset timezones using pytz.FixedOffset()\n        # even if it was datetime.timezone() originally\n        #\n        # technically they are the same:\n        # they both implement datetime.tzinfo\n        # they both wrap datetime.timedelta()\n        # this use-case sets the resolution to 1 minute\n        check_round_trip(df, pa, check_dtype=False)\n\n    @td.skip_if_no(\"pyarrow\", min_version=\"1.0.0\")\n    def test_filter_row_groups(self, pa):\n        # https://github.com/pandas-dev/pandas/issues/26551\n        df = pd.DataFrame({\"a\": list(range(0, 3))})\n        with tm.ensure_clean() as path:\n            df.to_parquet(path, pa)\n            result = read_parquet(\n                path, pa, filters=[(\"a\", \"==\", 0)], use_legacy_dataset=False\n            )\n        assert len(result) == 1\n\n\nclass TestParquetFastParquet(Base):\n    @td.skip_if_no(\"fastparquet\", min_version=\"0.3.2\")\n    def test_basic(self, fp, df_full):\n        df = df_full\n\n        dti = pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n        dti = dti._with_freq(None)  # freq doesnt round-trip\n        df[\"datetime_tz\"] = dti\n        df[\"timedelta\"] = pd.timedelta_range(\"1 day\", periods=3)\n        check_round_trip(df, fp)\n\n    @pytest.mark.skip(reason=\"not supported\")\n    def test_duplicate_columns(self, fp):\n\n        # not currently able to handle duplicate columns\n        df = pd.DataFrame(np.arange(12).reshape(4, 3), columns=list(\"aaa\")).copy()\n        msg = \"Cannot create parquet dataset with duplicate column names\"\n        self.check_error_on_write(df, fp, ValueError, msg)\n\n    def test_bool_with_none(self, fp):\n        df = pd.DataFrame({\"a\": [True, None, False]})\n        expected = pd.DataFrame({\"a\": [1.0, np.nan, 0.0]}, dtype=\"float16\")\n        check_round_trip(df, fp, expected=expected)\n\n    def test_unsupported(self, fp):\n\n        # period\n        df = pd.DataFrame({\"a\": pd.period_range(\"2013\", freq=\"M\", periods=3)})\n        # error from fastparquet -> don't check exact error message\n        self.check_error_on_write(df, fp, ValueError, None)\n\n        # mixed\n        df = pd.DataFrame({\"a\": [\"a\", 1, 2.0]})\n        msg = \"Can't infer object conversion type\"\n        self.check_error_on_write(df, fp, ValueError, msg)\n\n    def test_categorical(self, fp):\n        df = pd.DataFrame({\"a\": pd.Categorical(list(\"abc\"))})\n        check_round_trip(df, fp)\n\n    def test_filter_row_groups(self, fp):\n        d = {\"a\": list(range(0, 3))}\n        df = pd.DataFrame(d)\n        with tm.ensure_clean() as path:\n            df.to_parquet(path, fp, compression=None, row_group_offsets=1)\n            result = read_parquet(path, fp, filters=[(\"a\", \"==\", 0)])\n        assert len(result) == 1\n\n    def test_s3_roundtrip(self, df_compat, s3_resource, fp, s3so):\n        # GH #19134\n        check_round_trip(\n            df_compat,\n            fp,\n            path=\"s3://pandas-test/fastparquet.parquet\",\n            read_kwargs={\"storage_options\": s3so},\n            write_kwargs={\"compression\": None, \"storage_options\": s3so},\n        )\n\n    def test_partition_cols_supported(self, fp, df_full):\n        # GH #23283\n        partition_cols = [\"bool\", \"int\"]\n        df = df_full\n        with tm.ensure_clean_dir() as path:\n            df.to_parquet(\n                path,\n                engine=\"fastparquet\",\n                partition_cols=partition_cols,\n                compression=None,\n            )\n            assert os.path.exists(path)\n            import fastparquet\n\n            actual_partition_cols = fastparquet.ParquetFile(path, False).cats\n            assert len(actual_partition_cols) == 2\n\n    def test_partition_cols_string(self, fp, df_full):\n        # GH #27117\n        partition_cols = \"bool\"\n        df = df_full\n        with tm.ensure_clean_dir() as path:\n            df.to_parquet(\n                path,\n                engine=\"fastparquet\",\n                partition_cols=partition_cols,\n                compression=None,\n            )\n            assert os.path.exists(path)\n            import fastparquet\n\n            actual_partition_cols = fastparquet.ParquetFile(path, False).cats\n            assert len(actual_partition_cols) == 1\n\n    def test_partition_on_supported(self, fp, df_full):\n        # GH #23283\n        partition_cols = [\"bool\", \"int\"]\n        df = df_full\n        with tm.ensure_clean_dir() as path:\n            df.to_parquet(\n                path,\n                engine=\"fastparquet\",\n                compression=None,\n                partition_on=partition_cols,\n            )\n            assert os.path.exists(path)\n            import fastparquet\n\n            actual_partition_cols = fastparquet.ParquetFile(path, False).cats\n            assert len(actual_partition_cols) == 2\n\n    def test_error_on_using_partition_cols_and_partition_on(self, fp, df_full):\n        # GH #23283\n        partition_cols = [\"bool\", \"int\"]\n        df = df_full\n        msg = (\n            \"Cannot use both partition_on and partition_cols. Use partition_cols for \"\n            \"partitioning data\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            with tm.ensure_clean_dir() as path:\n                df.to_parquet(\n                    path,\n                    engine=\"fastparquet\",\n                    compression=None,\n                    partition_on=partition_cols,\n                    partition_cols=partition_cols,\n                )\n\n    def test_empty_dataframe(self, fp):\n        # GH #27339\n        df = pd.DataFrame()\n        expected = df.copy()\n        expected.index.name = \"index\"\n        check_round_trip(df, fp, expected=expected)\n\n    def test_timezone_aware_index(self, fp, timezone_aware_date_list):\n        idx = 5 * [timezone_aware_date_list]\n\n        df = pd.DataFrame(index=idx, data={\"index_as_col\": idx})\n\n        expected = df.copy()\n        expected.index.name = \"index\"\n        check_round_trip(df, fp, expected=expected)\n\n    def test_use_nullable_dtypes_not_supported(self, fp):\n        df = pd.DataFrame({\"a\": [1, 2]})\n\n        with tm.ensure_clean() as path:\n            df.to_parquet(path)\n            with pytest.raises(ValueError, match=\"not supported for the fastparquet\"):\n                read_parquet(path, engine=\"fastparquet\", use_nullable_dtypes=True)\n"
    }
  ]
}