{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "48855",
  "issue_description": "# STYLE fix pylint issues\n\nIn https://github.com/pandas-dev/pandas/pull/48759/files we're introduced `pylint`, but have turned off its warnings as there's a _lot_ of them:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/d719840e5a2639babab3b4646b11a111547c518f/pyproject.toml#L36-L67\r\n\r\nTask here is:\r\n\r\n1. pick one of the above warnings / errors, and remove it from `pyproject.toml`\r\n2. run `pre-commit run pylint --hook-stage manual --all-files`. If this already passes, skip to step 4.\r\n3. fixup any warnings that result\r\n4. if `pre-commit run pylint --hook-stage manual --all-files` passes, then stage and commit your changes and open a pull request\r\n\r\nIf you believe a warning is a false-positive, then it's OK to ignore it in-line, e.g. \r\n```python\r\ndf.rename(id, mapper=id)  # pylint: disable=redundant-keyword-arg\r\n```\r\n\r\nPlease comment here which pylint warning you'll work on before starting so we don't duplicate work. No need to ask for permission to work on this, and no need to comment \"take\" as multiple people can work on this concurrently\r\n\r\n---\r\n\r\nNOTE: please do _not_ write \"closes #48855\" in your PR\r\n\r\n---\r\n\r\nchecks we probably can't turn off:\r\n- too-many-function-args\r\n- unsubscriptable-object\r\n- unsupported-assignment-operation\r\n- no-name-in-module\r\n- no-member\r\n- import-error\r\n- not-an-iterable\r\n- invalid-unary-operator-type\r\n- invalid-name\r\n- wrong-import-order (and anything else related with imports)\r\n- unexpected-keyword-argument\r\n- use-implicit-booleaness-not-len\r\n- use-implicit-booleaness-not-comparison\r\n- comparison-with-itself\r\n- no-else-*\r\n- line-too-long\r\n- overridden-final-method\r\n- singleton-comparison\r\n- unsupported-membership-test\r\n- pointless-statement\r\n- broad-except\r\n- undefined-variable\r\n\r\n\r\nIf you're not sure whether a check should fit into the above list, please do ask",
  "issue_comments": [
    {
      "id": 1262907019,
      "user": "shivamurali",
      "body": "Hi there! I'll get to work on the \"used-before-assignment\" warning and remove it from the pyproject.toml file.\r\n\r\nEDIT: PR went stale, anyone else is welcome to work on this"
    },
    {
      "id": 1263123670,
      "user": "Exoutia",
      "body": "Hi i am new to open source and i want to contribute to this project by fixing this but i cant seem to run pylint with --all-files option am i doing something wrong.\r\nor do i need to do something before hand beside making a branch and cloning the repo, can someone help me"
    },
    {
      "id": 1263260920,
      "user": "MarcoGorelli",
      "body": "Hi @Exoutia - please show your output\r\n\r\nThe command is `pre-commit run pylint --all-files`"
    },
    {
      "id": 1263297545,
      "user": "Exoutia",
      "body": "> Hi @Exoutia - please show your output\r\n> \r\n> The command is `pre-commit run pylint --all-files`\r\n\r\nThanks, now it ran some problems has happened during installation of pre-commit i again installed it and it got fixed\r\n![image](https://user-images.githubusercontent.com/94464106/193232132-08cc213b-f93d-485b-bdba-cd6f8f1c1a3a.png)\r\n"
    },
    {
      "id": 1263751898,
      "user": "slackline",
      "body": "I'll work on removing `import-error`."
    },
    {
      "id": 1263841120,
      "user": "gulyapulya",
      "body": "Hi! I am also new to the open source, but I want to contribute, I will work on the \"no-method-argument\". "
    },
    {
      "id": 1263893947,
      "user": "kostyafarber",
      "body": "Hi! I'll work on `inherit-non-class`."
    },
    {
      "id": 1263957186,
      "user": "soumilbaldota",
      "body": "Hi, I will take `bad-super-call` warning, I have added the pull request above."
    },
    {
      "id": 1264330898,
      "user": "FloHofstetter",
      "body": "Hi, I will take `function-redefined` warning."
    },
    {
      "id": 1264416573,
      "user": "rokaicker",
      "body": "Hi ! I'm new to open source, but I'd like to tackle the `too-many-function-args`!"
    },
    {
      "id": 1264433256,
      "user": "MarcoGorelli",
      "body": "thanks @rokaicker - that one's probably too hard to turn off for now, without going through a deprecation cycle, but there's lot's of others to choose\r\n\r\nI've added this one to the description as one that's probably not possible to turn off for now"
    },
    {
      "id": 1264512919,
      "user": "jetale",
      "body": "working on  \"unsupported-assignment-operation\""
    },
    {
      "id": 1264540559,
      "user": "Exoutia",
      "body": "i am working on \"no-self-argument\" "
    },
    {
      "id": 1264670193,
      "user": "shalearkane",
      "body": "I am working on \"unexpected-keyword-arg\""
    },
    {
      "id": 1264708291,
      "user": "roadswitcher",
      "body": "I am working on `no-name-in-module`"
    },
    {
      "id": 1264742664,
      "user": "Leviob",
      "body": "Hi, I would like to work on \"used-before-assignment,\" but I'm aware it was already claimed by @shivamurali. Can I submit my own PR for it? Thanks."
    },
    {
      "id": 1265513680,
      "user": "joaomarcoscrs",
      "body": "I'll work on the `not-callable`"
    },
    {
      "id": 1267379707,
      "user": "rAwsam",
      "body": "Hi! I am also new to the open source, but I want to contribute, I will work on the \"undefined-variable\""
    },
    {
      "id": 1269307445,
      "user": "TejasCreative",
      "body": "I'll work on `no-member`!"
    },
    {
      "id": 1269376927,
      "user": "sakalmon",
      "body": "I'll work on `unsubscriptable-object`"
    },
    {
      "id": 1269441871,
      "user": "sakalmon",
      "body": "> I'll work on `unsubscriptable-object`\r\n\r\nI'm new to open source but I removed the above line and got numerous errors. All of them were \"EE1136 - unsubscriptable (unsubscriptable-object)\". \r\n\r\n[Pylint documentation](https://pylint.pycqa.org/en/latest/user_guide/messages/error/unsubscriptable-object.html) suggests it may be because there is no `__get__item` method or `__class_getitem__` for the class. I believe this is a false positive and the error will have to remain disabled."
    },
    {
      "id": 1271353529,
      "user": "MarcoGorelli",
      "body": "thanks for looking into this @sakalmon - that's fine, I'll add that to the list of ones we can't turn off"
    },
    {
      "id": 1271450065,
      "user": "sakalmon",
      "body": "@MarcoGorelli No worries, happy to help!"
    },
    {
      "id": 1271503075,
      "user": "roadswitcher",
      "body": "> I am working on `no-name-in-module`\r\n\r\nDisabling this resulted in a substantial number of E0611s that are tied to referencing calls in underlying C implementation within the `pandas._libs/*` directories.   [Pylint documentation for other errors](https://pylint.pycqa.org/en/stable/user_guide/messages/error/no-member.html) implies that there are flags that could be invoked in order to make pylint start building AST trees from the underlying C modules, but that's probably out of scope for this issue.\r\n\r\n As with @sakalmon's investigation of `unscriptable-object`, I think that `no-name-in-module` need to remain.\r\n   \r\n \r\n\r\nUPDATE:     Finished my checks so that I'd have an Actual Number To Report: 174 false positives across 126 separate source files.      I think that's past the point of \"leave the warning turned off\" and well into the realm of \"didn't I have anything better to do with my time last evening\".     \r\n\r\nGiven how often Pandas invokes/depends on underlying C implementations for various things, I'm surprised it wasn't more. \r\n\r\nI still think it's probably not something you can turn off at this time, but if you want those 126 changed files in a PR, @MarcoGorelli , let me know.    \r\n\r\n\r\n"
    },
    {
      "id": 1272142781,
      "user": "TejasCreative",
      "body": "> I'll work on `no-member`!\r\n\r\nLooks like no-member can't be turned off. After removing it, A wide variety of E1101: Instance of xyz has no abc member. Looks like this is a false positive for object members that are created dynamically, but exist at the time they are accessed.\r\n\r\n"
    },
    {
      "id": 1272456008,
      "user": "techrajdeep",
      "body": "I am looking for an issue for my first contribution . Can you help me here."
    },
    {
      "id": 1272543145,
      "user": "slackline",
      "body": "> I'll work on removing `import-error`\r\n\r\nAs mentioned above I've opened PR #49013 which hopefully removes the need to disable `import-error`."
    },
    {
      "id": 1272592715,
      "user": "slackline",
      "body": "I was trying to work out what had been taken and what was still available, knocked up this table and thought it might be useful.\r\n\r\n| Pylint Error                       | Worked on by...        | PR              | Comment                                                                                                   |\r\n|:-----------------------------------|:----------------------:|:----------------|:----------------------------------------------------------------------------------------------------------|\r\n| `C`                                |                        |                 |                                                                                                           |\r\n| `R`                                |                        |                 |                                                                                                           |\r\n| `W`                                |                        |                 |                                                                                                           |\r\n| `abstract-class-instantiated`      |                        |                 |                                                                                                           |\r\n| `access-member-before-definition`  |                        |                 |                                                                                                           |\r\n| `bad-super-call`                   | @soumilbaldota         | #48896          |                                                                                                           |\r\n| `c-extension-no-member`            | @roadswitcher                    |   #49038              |                                                                                                           |\r\n| `function-redefined`               | @FloHofstetter         | #48906          |                                                                                                           |\r\n| `import-error`                     | @slackline             | #49013          | Can't be removed see PR discussion.                                                                       |\r\n| `inherit-non-class`                | @kostyafarber          | #48897          |                                                                                                           |\r\n| `invalid-repr-returned`            |  @vamsi-verma-s                | #49025                |                                                                                                           |\r\n| `invalid-unary-operand-type`       |                        |                 |                                                                                                           |\r\n| `misplaced-bare-raise`             |  @vamsi-verma-s                      | #49018          |                                                                                                           |\r\n| `no-member`                        | @TejasCreative         |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1272142781) |\r\n| `no-method-argument`               | @gulyapulya            |                 |                                                                                                           |\r\n| `no-name-in-module`                | @roadswitcher          |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1271503075) |\r\n| `no-self-argument`                 | @Exoutia               | #48912          |                                                                                                           |\r\n| `no-value-for-parameter`           | @shalearkane           | #48917          |                                                                                                           |\r\n| `non-iterator-returned`            |  @roadswitcher               | #49036                |                                                                                                           |\r\n| `not-an-iterable`                  | @roadswitcher            | #49031                |                                                                                                           |\r\n| `not-callable`                     | @joaomarcoscrs         |                 |                                                                                                           |\r\n| `redundant-keyword-arg`            |                        |                 |                                                                                                           |\r\n| `too-many-function-args`           |                        |                 | Not possible to turn off at present.                                                                      |\r\n| `undefined-variable`               | @rAwsam                |                 |                                                                                                           |\r\n| `unexpected-keyword-arg`           | @shalearkane           |                 |                                                                                                           |\r\n| `unpacking-non-sequence`           |                        |                 |                                                                                                           |\r\n| `unsubscriptable-object`           | @sakalmon              |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1269441871) |\r\n| `unsupported-assignment-operation` | @jetale                | #48982          |                                                                                                           |\r\n| `unsupported-membership-test`      |                        |                 |                                                                                                           |\r\n| `used-before-assignment`           | @shivamurali / @Leviob | #48895 / #48940 |                                                                                                           |\r\n"
    },
    {
      "id": 1272842946,
      "user": "techrajdeep",
      "body": "@slackline , I am looking for an issue for my first contribution , is there anything available here. Can you please help me"
    },
    {
      "id": 1272882190,
      "user": "slackline",
      "body": "@techrajdeep rows in the above table are pylint errors that have not been worked on yet. See the original post in this issue for how to go about investigating the source of the errors. If you're not familiar with the concept of linting and/or pylint then it would be worth checking the [documentation](https://pylint.pycqa.org/en/latest/)."
    }
  ],
  "text_context": "# STYLE fix pylint issues\n\nIn https://github.com/pandas-dev/pandas/pull/48759/files we're introduced `pylint`, but have turned off its warnings as there's a _lot_ of them:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/d719840e5a2639babab3b4646b11a111547c518f/pyproject.toml#L36-L67\r\n\r\nTask here is:\r\n\r\n1. pick one of the above warnings / errors, and remove it from `pyproject.toml`\r\n2. run `pre-commit run pylint --hook-stage manual --all-files`. If this already passes, skip to step 4.\r\n3. fixup any warnings that result\r\n4. if `pre-commit run pylint --hook-stage manual --all-files` passes, then stage and commit your changes and open a pull request\r\n\r\nIf you believe a warning is a false-positive, then it's OK to ignore it in-line, e.g. \r\n```python\r\ndf.rename(id, mapper=id)  # pylint: disable=redundant-keyword-arg\r\n```\r\n\r\nPlease comment here which pylint warning you'll work on before starting so we don't duplicate work. No need to ask for permission to work on this, and no need to comment \"take\" as multiple people can work on this concurrently\r\n\r\n---\r\n\r\nNOTE: please do _not_ write \"closes #48855\" in your PR\r\n\r\n---\r\n\r\nchecks we probably can't turn off:\r\n- too-many-function-args\r\n- unsubscriptable-object\r\n- unsupported-assignment-operation\r\n- no-name-in-module\r\n- no-member\r\n- import-error\r\n- not-an-iterable\r\n- invalid-unary-operator-type\r\n- invalid-name\r\n- wrong-import-order (and anything else related with imports)\r\n- unexpected-keyword-argument\r\n- use-implicit-booleaness-not-len\r\n- use-implicit-booleaness-not-comparison\r\n- comparison-with-itself\r\n- no-else-*\r\n- line-too-long\r\n- overridden-final-method\r\n- singleton-comparison\r\n- unsupported-membership-test\r\n- pointless-statement\r\n- broad-except\r\n- undefined-variable\r\n\r\n\r\nIf you're not sure whether a check should fit into the above list, please do ask\n\nHi there! I'll get to work on the \"used-before-assignment\" warning and remove it from the pyproject.toml file.\r\n\r\nEDIT: PR went stale, anyone else is welcome to work on this\n\nHi i am new to open source and i want to contribute to this project by fixing this but i cant seem to run pylint with --all-files option am i doing something wrong.\r\nor do i need to do something before hand beside making a branch and cloning the repo, can someone help me\n\nHi @Exoutia - please show your output\r\n\r\nThe command is `pre-commit run pylint --all-files`\n\n> Hi @Exoutia - please show your output\r\n> \r\n> The command is `pre-commit run pylint --all-files`\r\n\r\nThanks, now it ran some problems has happened during installation of pre-commit i again installed it and it got fixed\r\n![image](https://user-images.githubusercontent.com/94464106/193232132-08cc213b-f93d-485b-bdba-cd6f8f1c1a3a.png)\r\n\n\nI'll work on removing `import-error`.\n\nHi! I am also new to the open source, but I want to contribute, I will work on the \"no-method-argument\". \n\nHi! I'll work on `inherit-non-class`.\n\nHi, I will take `bad-super-call` warning, I have added the pull request above.\n\nHi, I will take `function-redefined` warning.\n\nHi ! I'm new to open source, but I'd like to tackle the `too-many-function-args`!\n\nthanks @rokaicker - that one's probably too hard to turn off for now, without going through a deprecation cycle, but there's lot's of others to choose\r\n\r\nI've added this one to the description as one that's probably not possible to turn off for now\n\nworking on  \"unsupported-assignment-operation\"\n\ni am working on \"no-self-argument\" \n\nI am working on \"unexpected-keyword-arg\"\n\nI am working on `no-name-in-module`\n\nHi, I would like to work on \"used-before-assignment,\" but I'm aware it was already claimed by @shivamurali. Can I submit my own PR for it? Thanks.\n\nI'll work on the `not-callable`\n\nHi! I am also new to the open source, but I want to contribute, I will work on the \"undefined-variable\"\n\nI'll work on `no-member`!\n\nI'll work on `unsubscriptable-object`\n\n> I'll work on `unsubscriptable-object`\r\n\r\nI'm new to open source but I removed the above line and got numerous errors. All of them were \"EE1136 - unsubscriptable (unsubscriptable-object)\". \r\n\r\n[Pylint documentation](https://pylint.pycqa.org/en/latest/user_guide/messages/error/unsubscriptable-object.html) suggests it may be because there is no `__get__item` method or `__class_getitem__` for the class. I believe this is a false positive and the error will have to remain disabled.\n\nthanks for looking into this @sakalmon - that's fine, I'll add that to the list of ones we can't turn off\n\n@MarcoGorelli No worries, happy to help!\n\n> I am working on `no-name-in-module`\r\n\r\nDisabling this resulted in a substantial number of E0611s that are tied to referencing calls in underlying C implementation within the `pandas._libs/*` directories.   [Pylint documentation for other errors](https://pylint.pycqa.org/en/stable/user_guide/messages/error/no-member.html) implies that there are flags that could be invoked in order to make pylint start building AST trees from the underlying C modules, but that's probably out of scope for this issue.\r\n\r\n As with @sakalmon's investigation of `unscriptable-object`, I think that `no-name-in-module` need to remain.\r\n   \r\n \r\n\r\nUPDATE:     Finished my checks so that I'd have an Actual Number To Report: 174 false positives across 126 separate source files.      I think that's past the point of \"leave the warning turned off\" and well into the realm of \"didn't I have anything better to do with my time last evening\".     \r\n\r\nGiven how often Pandas invokes/depends on underlying C implementations for various things, I'm surprised it wasn't more. \r\n\r\nI still think it's probably not something you can turn off at this time, but if you want those 126 changed files in a PR, @MarcoGorelli , let me know.    \r\n\r\n\r\n\n\n> I'll work on `no-member`!\r\n\r\nLooks like no-member can't be turned off. After removing it, A wide variety of E1101: Instance of xyz has no abc member. Looks like this is a false positive for object members that are created dynamically, but exist at the time they are accessed.\r\n\r\n\n\nI am looking for an issue for my first contribution . Can you help me here.\n\n> I'll work on removing `import-error`\r\n\r\nAs mentioned above I've opened PR #49013 which hopefully removes the need to disable `import-error`.\n\nI was trying to work out what had been taken and what was still available, knocked up this table and thought it might be useful.\r\n\r\n| Pylint Error                       | Worked on by...        | PR              | Comment                                                                                                   |\r\n|:-----------------------------------|:----------------------:|:----------------|:----------------------------------------------------------------------------------------------------------|\r\n| `C`                                |                        |                 |                                                                                                           |\r\n| `R`                                |                        |                 |                                                                                                           |\r\n| `W`                                |                        |                 |                                                                                                           |\r\n| `abstract-class-instantiated`      |                        |                 |                                                                                                           |\r\n| `access-member-before-definition`  |                        |                 |                                                                                                           |\r\n| `bad-super-call`                   | @soumilbaldota         | #48896          |                                                                                                           |\r\n| `c-extension-no-member`            | @roadswitcher                    |   #49038              |                                                                                                           |\r\n| `function-redefined`               | @FloHofstetter         | #48906          |                                                                                                           |\r\n| `import-error`                     | @slackline             | #49013          | Can't be removed see PR discussion.                                                                       |\r\n| `inherit-non-class`                | @kostyafarber          | #48897          |                                                                                                           |\r\n| `invalid-repr-returned`            |  @vamsi-verma-s                | #49025                |                                                                                                           |\r\n| `invalid-unary-operand-type`       |                        |                 |                                                                                                           |\r\n| `misplaced-bare-raise`             |  @vamsi-verma-s                      | #49018          |                                                                                                           |\r\n| `no-member`                        | @TejasCreative         |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1272142781) |\r\n| `no-method-argument`               | @gulyapulya            |                 |                                                                                                           |\r\n| `no-name-in-module`                | @roadswitcher          |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1271503075) |\r\n| `no-self-argument`                 | @Exoutia               | #48912          |                                                                                                           |\r\n| `no-value-for-parameter`           | @shalearkane           | #48917          |                                                                                                           |\r\n| `non-iterator-returned`            |  @roadswitcher               | #49036                |                                                                                                           |\r\n| `not-an-iterable`                  | @roadswitcher            | #49031                |                                                                                                           |\r\n| `not-callable`                     | @joaomarcoscrs         |                 |                                                                                                           |\r\n| `redundant-keyword-arg`            |                        |                 |                                                                                                           |\r\n| `too-many-function-args`           |                        |                 | Not possible to turn off at present.                                                                      |\r\n| `undefined-variable`               | @rAwsam                |                 |                                                                                                           |\r\n| `unexpected-keyword-arg`           | @shalearkane           |                 |                                                                                                           |\r\n| `unpacking-non-sequence`           |                        |                 |                                                                                                           |\r\n| `unsubscriptable-object`           | @sakalmon              |                 | Can't be removed see [comment](https://github.com/pandas-dev/pandas/issues/48855#issuecomment-1269441871) |\r\n| `unsupported-assignment-operation` | @jetale                | #48982          |                                                                                                           |\r\n| `unsupported-membership-test`      |                        |                 |                                                                                                           |\r\n| `used-before-assignment`           | @shivamurali / @Leviob | #48895 / #48940 |                                                                                                           |\r\n\n\n@slackline , I am looking for an issue for my first contribution , is there anything available here. Can you please help me\n\n@techrajdeep rows in the above table are pylint errors that have not been worked on yet. See the original post in this issue for how to go about investigating the source of the errors. If you're not familiar with the concept of linting and/or pylint then it would be worth checking the [documentation](https://pylint.pycqa.org/en/latest/).",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/48759",
  "code_context": [
    {
      "filename": "pandas/tests/frame/methods/test_rename.py",
      "content": "from collections import ChainMap\nimport inspect\n\nimport numpy as np\nimport pytest\n\nimport pandas.util._test_decorators as td\n\nfrom pandas import (\n    DataFrame,\n    Index,\n    MultiIndex,\n    Series,\n    merge,\n)\nimport pandas._testing as tm\n\n\nclass TestRename:\n    def test_rename_signature(self):\n        sig = inspect.signature(DataFrame.rename)\n        parameters = set(sig.parameters)\n        assert parameters == {\n            \"self\",\n            \"mapper\",\n            \"index\",\n            \"columns\",\n            \"axis\",\n            \"inplace\",\n            \"copy\",\n            \"level\",\n            \"errors\",\n        }\n\n    @pytest.mark.parametrize(\"klass\", [Series, DataFrame])\n    def test_rename_mi(self, klass):\n        obj = klass(\n            [11, 21, 31],\n            index=MultiIndex.from_tuples([(\"A\", x) for x in [\"a\", \"B\", \"c\"]]),\n        )\n        obj.rename(str.lower)\n\n    def test_rename(self, float_frame):\n        mapping = {\"A\": \"a\", \"B\": \"b\", \"C\": \"c\", \"D\": \"d\"}\n\n        renamed = float_frame.rename(columns=mapping)\n        renamed2 = float_frame.rename(columns=str.lower)\n\n        tm.assert_frame_equal(renamed, renamed2)\n        tm.assert_frame_equal(\n            renamed2.rename(columns=str.upper), float_frame, check_names=False\n        )\n\n        # index\n        data = {\"A\": {\"foo\": 0, \"bar\": 1}}\n\n        # gets sorted alphabetical\n        df = DataFrame(data)\n        renamed = df.rename(index={\"foo\": \"bar\", \"bar\": \"foo\"})\n        tm.assert_index_equal(renamed.index, Index([\"foo\", \"bar\"]))\n\n        renamed = df.rename(index=str.upper)\n        tm.assert_index_equal(renamed.index, Index([\"BAR\", \"FOO\"]))\n\n        # have to pass something\n        with pytest.raises(TypeError, match=\"must pass an index to rename\"):\n            float_frame.rename()\n\n        # partial columns\n        renamed = float_frame.rename(columns={\"C\": \"foo\", \"D\": \"bar\"})\n        tm.assert_index_equal(renamed.columns, Index([\"A\", \"B\", \"foo\", \"bar\"]))\n\n        # other axis\n        renamed = float_frame.T.rename(index={\"C\": \"foo\", \"D\": \"bar\"})\n        tm.assert_index_equal(renamed.index, Index([\"A\", \"B\", \"foo\", \"bar\"]))\n\n        # index with name\n        index = Index([\"foo\", \"bar\"], name=\"name\")\n        renamer = DataFrame(data, index=index)\n        renamed = renamer.rename(index={\"foo\": \"bar\", \"bar\": \"foo\"})\n        tm.assert_index_equal(renamed.index, Index([\"bar\", \"foo\"], name=\"name\"))\n        assert renamed.index.name == renamer.index.name\n\n    @pytest.mark.parametrize(\n        \"args,kwargs\",\n        [\n            ((ChainMap({\"A\": \"a\"}, {\"B\": \"b\"}),), {\"axis\": \"columns\"}),\n            ((), {\"columns\": ChainMap({\"A\": \"a\"}, {\"B\": \"b\"})}),\n        ],\n    )\n    def test_rename_chainmap(self, args, kwargs):\n        # see gh-23859\n        colAData = range(1, 11)\n        colBdata = np.random.randn(10)\n\n        df = DataFrame({\"A\": colAData, \"B\": colBdata})\n        result = df.rename(*args, **kwargs)\n\n        expected = DataFrame({\"a\": colAData, \"b\": colBdata})\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_multiindex(self):\n\n        tuples_index = [(\"foo1\", \"bar1\"), (\"foo2\", \"bar2\")]\n        tuples_columns = [(\"fizz1\", \"buzz1\"), (\"fizz2\", \"buzz2\")]\n        index = MultiIndex.from_tuples(tuples_index, names=[\"foo\", \"bar\"])\n        columns = MultiIndex.from_tuples(tuples_columns, names=[\"fizz\", \"buzz\"])\n        df = DataFrame([(0, 0), (1, 1)], index=index, columns=columns)\n\n        #\n        # without specifying level -> across all levels\n\n        renamed = df.rename(\n            index={\"foo1\": \"foo3\", \"bar2\": \"bar3\"},\n            columns={\"fizz1\": \"fizz3\", \"buzz2\": \"buzz3\"},\n        )\n        new_index = MultiIndex.from_tuples(\n            [(\"foo3\", \"bar1\"), (\"foo2\", \"bar3\")], names=[\"foo\", \"bar\"]\n        )\n        new_columns = MultiIndex.from_tuples(\n            [(\"fizz3\", \"buzz1\"), (\"fizz2\", \"buzz3\")], names=[\"fizz\", \"buzz\"]\n        )\n        tm.assert_index_equal(renamed.index, new_index)\n        tm.assert_index_equal(renamed.columns, new_columns)\n        assert renamed.index.names == df.index.names\n        assert renamed.columns.names == df.columns.names\n\n        #\n        # with specifying a level (GH13766)\n\n        # dict\n        new_columns = MultiIndex.from_tuples(\n            [(\"fizz3\", \"buzz1\"), (\"fizz2\", \"buzz2\")], names=[\"fizz\", \"buzz\"]\n        )\n        renamed = df.rename(columns={\"fizz1\": \"fizz3\", \"buzz2\": \"buzz3\"}, level=0)\n        tm.assert_index_equal(renamed.columns, new_columns)\n        renamed = df.rename(columns={\"fizz1\": \"fizz3\", \"buzz2\": \"buzz3\"}, level=\"fizz\")\n        tm.assert_index_equal(renamed.columns, new_columns)\n\n        new_columns = MultiIndex.from_tuples(\n            [(\"fizz1\", \"buzz1\"), (\"fizz2\", \"buzz3\")], names=[\"fizz\", \"buzz\"]\n        )\n        renamed = df.rename(columns={\"fizz1\": \"fizz3\", \"buzz2\": \"buzz3\"}, level=1)\n        tm.assert_index_equal(renamed.columns, new_columns)\n        renamed = df.rename(columns={\"fizz1\": \"fizz3\", \"buzz2\": \"buzz3\"}, level=\"buzz\")\n        tm.assert_index_equal(renamed.columns, new_columns)\n\n        # function\n        func = str.upper\n        new_columns = MultiIndex.from_tuples(\n            [(\"FIZZ1\", \"buzz1\"), (\"FIZZ2\", \"buzz2\")], names=[\"fizz\", \"buzz\"]\n        )\n        renamed = df.rename(columns=func, level=0)\n        tm.assert_index_equal(renamed.columns, new_columns)\n        renamed = df.rename(columns=func, level=\"fizz\")\n        tm.assert_index_equal(renamed.columns, new_columns)\n\n        new_columns = MultiIndex.from_tuples(\n            [(\"fizz1\", \"BUZZ1\"), (\"fizz2\", \"BUZZ2\")], names=[\"fizz\", \"buzz\"]\n        )\n        renamed = df.rename(columns=func, level=1)\n        tm.assert_index_equal(renamed.columns, new_columns)\n        renamed = df.rename(columns=func, level=\"buzz\")\n        tm.assert_index_equal(renamed.columns, new_columns)\n\n        # index\n        new_index = MultiIndex.from_tuples(\n            [(\"foo3\", \"bar1\"), (\"foo2\", \"bar2\")], names=[\"foo\", \"bar\"]\n        )\n        renamed = df.rename(index={\"foo1\": \"foo3\", \"bar2\": \"bar3\"}, level=0)\n        tm.assert_index_equal(renamed.index, new_index)\n\n    @td.skip_array_manager_not_yet_implemented  # TODO(ArrayManager) setitem copy/view\n    def test_rename_nocopy(self, float_frame, using_copy_on_write):\n        renamed = float_frame.rename(columns={\"C\": \"foo\"}, copy=False)\n\n        assert np.shares_memory(renamed[\"foo\"]._values, float_frame[\"C\"]._values)\n\n        # TODO(CoW) this also shouldn't warn in case of CoW, but the heuristic\n        # checking if the array shares memory doesn't work if CoW happened\n        with tm.assert_produces_warning(FutureWarning if using_copy_on_write else None):\n            # This loc setitem already happens inplace, so no warning\n            #  that this will change in the future\n            renamed.loc[:, \"foo\"] = 1.0\n        if using_copy_on_write:\n            assert not (float_frame[\"C\"] == 1.0).all()\n        else:\n            assert (float_frame[\"C\"] == 1.0).all()\n\n    def test_rename_inplace(self, float_frame):\n        float_frame.rename(columns={\"C\": \"foo\"})\n        assert \"C\" in float_frame\n        assert \"foo\" not in float_frame\n\n        c_values = float_frame[\"C\"]\n        float_frame = float_frame.copy()\n        return_value = float_frame.rename(columns={\"C\": \"foo\"}, inplace=True)\n        assert return_value is None\n\n        assert \"C\" not in float_frame\n        assert \"foo\" in float_frame\n        # GH 44153\n        # Used to be id(float_frame[\"foo\"]) != c_id, but flaky in the CI\n        assert float_frame[\"foo\"] is not c_values\n\n    def test_rename_bug(self):\n        # GH 5344\n        # rename set ref_locs, and set_index was not resetting\n        df = DataFrame({0: [\"foo\", \"bar\"], 1: [\"bah\", \"bas\"], 2: [1, 2]})\n        df = df.rename(columns={0: \"a\"})\n        df = df.rename(columns={1: \"b\"})\n        df = df.set_index([\"a\", \"b\"])\n        df.columns = [\"2001-01-01\"]\n        expected = DataFrame(\n            [[1], [2]],\n            index=MultiIndex.from_tuples(\n                [(\"foo\", \"bah\"), (\"bar\", \"bas\")], names=[\"a\", \"b\"]\n            ),\n            columns=[\"2001-01-01\"],\n        )\n        tm.assert_frame_equal(df, expected)\n\n    def test_rename_bug2(self):\n        # GH 19497\n        # rename was changing Index to MultiIndex if Index contained tuples\n\n        df = DataFrame(data=np.arange(3), index=[(0, 0), (1, 1), (2, 2)], columns=[\"a\"])\n        df = df.rename({(1, 1): (5, 4)}, axis=\"index\")\n        expected = DataFrame(\n            data=np.arange(3), index=[(0, 0), (5, 4), (2, 2)], columns=[\"a\"]\n        )\n        tm.assert_frame_equal(df, expected)\n\n    def test_rename_errors_raises(self):\n        df = DataFrame(columns=[\"A\", \"B\", \"C\", \"D\"])\n        with pytest.raises(KeyError, match=\"'E'] not found in axis\"):\n            df.rename(columns={\"A\": \"a\", \"E\": \"e\"}, errors=\"raise\")\n\n    @pytest.mark.parametrize(\n        \"mapper, errors, expected_columns\",\n        [\n            ({\"A\": \"a\", \"E\": \"e\"}, \"ignore\", [\"a\", \"B\", \"C\", \"D\"]),\n            ({\"A\": \"a\"}, \"raise\", [\"a\", \"B\", \"C\", \"D\"]),\n            (str.lower, \"raise\", [\"a\", \"b\", \"c\", \"d\"]),\n        ],\n    )\n    def test_rename_errors(self, mapper, errors, expected_columns):\n        # GH 13473\n        # rename now works with errors parameter\n        df = DataFrame(columns=[\"A\", \"B\", \"C\", \"D\"])\n        result = df.rename(columns=mapper, errors=errors)\n        expected = DataFrame(columns=expected_columns)\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_objects(self, float_string_frame):\n        renamed = float_string_frame.rename(columns=str.upper)\n\n        assert \"FOO\" in renamed\n        assert \"foo\" not in renamed\n\n    def test_rename_axis_style(self):\n        # https://github.com/pandas-dev/pandas/issues/12392\n        df = DataFrame({\"A\": [1, 2], \"B\": [1, 2]}, index=[\"X\", \"Y\"])\n        expected = DataFrame({\"a\": [1, 2], \"b\": [1, 2]}, index=[\"X\", \"Y\"])\n\n        result = df.rename(str.lower, axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename(str.lower, axis=\"columns\")\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename({\"A\": \"a\", \"B\": \"b\"}, axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename({\"A\": \"a\", \"B\": \"b\"}, axis=\"columns\")\n        tm.assert_frame_equal(result, expected)\n\n        # Index\n        expected = DataFrame({\"A\": [1, 2], \"B\": [1, 2]}, index=[\"x\", \"y\"])\n        result = df.rename(str.lower, axis=0)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename(str.lower, axis=\"index\")\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename({\"X\": \"x\", \"Y\": \"y\"}, axis=0)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename({\"X\": \"x\", \"Y\": \"y\"}, axis=\"index\")\n        tm.assert_frame_equal(result, expected)\n\n        result = df.rename(mapper=str.lower, axis=\"index\")\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_mapper_multi(self):\n        df = DataFrame({\"A\": [\"a\", \"b\"], \"B\": [\"c\", \"d\"], \"C\": [1, 2]}).set_index(\n            [\"A\", \"B\"]\n        )\n        result = df.rename(str.upper)\n        expected = df.rename(index=str.upper)\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_positional_named(self):\n        # https://github.com/pandas-dev/pandas/issues/12392\n        df = DataFrame({\"a\": [1, 2], \"b\": [1, 2]}, index=[\"X\", \"Y\"])\n        result = df.rename(index=str.lower, columns=str.upper)\n        expected = DataFrame({\"A\": [1, 2], \"B\": [1, 2]}, index=[\"x\", \"y\"])\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_axis_style_raises(self):\n        # see gh-12392\n        df = DataFrame({\"A\": [1, 2], \"B\": [1, 2]}, index=[\"0\", \"1\"])\n\n        # Named target and axis\n        over_spec_msg = \"Cannot specify both 'axis' and any of 'index' or 'columns'\"\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(index=str.lower, axis=1)\n\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(index=str.lower, axis=\"columns\")\n\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(columns=str.lower, axis=\"columns\")\n\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(index=str.lower, axis=0)\n\n        # Multiple targets and axis\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(str.lower, index=str.lower, axis=\"columns\")\n\n        # Too many targets\n        over_spec_msg = \"Cannot specify both 'mapper' and any of 'index' or 'columns'\"\n        with pytest.raises(TypeError, match=over_spec_msg):\n            df.rename(str.lower, index=str.lower, columns=str.lower)\n\n        # Duplicates\n        with pytest.raises(TypeError, match=\"multiple values\"):\n            df.rename(id, mapper=id)  # pylint: disable=redundant-keyword-arg\n\n    def test_rename_positional_raises(self):\n        # GH 29136\n        df = DataFrame(columns=[\"A\", \"B\"])\n        msg = r\"rename\\(\\) takes from 1 to 2 positional arguments\"\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename(None, str.lower)\n\n    def test_rename_no_mappings_raises(self):\n        # GH 29136\n        df = DataFrame([[1]])\n        msg = \"must pass an index to rename\"\n        with pytest.raises(TypeError, match=msg):\n            df.rename()\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename(None, index=None)\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename(None, columns=None)\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename(None, columns=None, index=None)\n\n    def test_rename_mapper_and_positional_arguments_raises(self):\n        # GH 29136\n        df = DataFrame([[1]])\n        msg = \"Cannot specify both 'mapper' and any of 'index' or 'columns'\"\n        with pytest.raises(TypeError, match=msg):\n            df.rename({}, index={})\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename({}, columns={})\n\n        with pytest.raises(TypeError, match=msg):\n            df.rename({}, columns={}, index={})\n\n    def test_rename_with_duplicate_columns(self):\n        # GH#4403\n        df4 = DataFrame(\n            {\"RT\": [0.0454], \"TClose\": [22.02], \"TExg\": [0.0422]},\n            index=MultiIndex.from_tuples(\n                [(600809, 20130331)], names=[\"STK_ID\", \"RPT_Date\"]\n            ),\n        )\n\n        df5 = DataFrame(\n            {\n                \"RPT_Date\": [20120930, 20121231, 20130331],\n                \"STK_ID\": [600809] * 3,\n                \"STK_Name\": [\"饡驦\", \"饡驦\", \"饡驦\"],\n                \"TClose\": [38.05, 41.66, 30.01],\n            },\n            index=MultiIndex.from_tuples(\n                [(600809, 20120930), (600809, 20121231), (600809, 20130331)],\n                names=[\"STK_ID\", \"RPT_Date\"],\n            ),\n        )\n        # TODO: can we construct this without merge?\n        k = merge(df4, df5, how=\"inner\", left_index=True, right_index=True)\n        result = k.rename(columns={\"TClose_x\": \"TClose\", \"TClose_y\": \"QT_Close\"})\n        str(result)\n        result.dtypes\n\n        expected = DataFrame(\n            [[0.0454, 22.02, 0.0422, 20130331, 600809, \"饡驦\", 30.01]],\n            columns=[\n                \"RT\",\n                \"TClose\",\n                \"TExg\",\n                \"RPT_Date\",\n                \"STK_ID\",\n                \"STK_Name\",\n                \"QT_Close\",\n            ],\n        ).set_index([\"STK_ID\", \"RPT_Date\"], drop=False)\n        tm.assert_frame_equal(result, expected)\n\n    def test_rename_boolean_index(self):\n        df = DataFrame(np.arange(15).reshape(3, 5), columns=[False, True, 2, 3, 4])\n        mapper = {0: \"foo\", 1: \"bar\", 2: \"bah\"}\n        res = df.rename(index=mapper)\n        exp = DataFrame(\n            np.arange(15).reshape(3, 5),\n            columns=[False, True, 2, 3, 4],\n            index=[\"foo\", \"bar\", \"bah\"],\n        )\n        tm.assert_frame_equal(res, exp)\n"
    },
    {
      "filename": "pandas/tests/io/test_html.py",
      "content": "from functools import partial\nfrom importlib import reload\nfrom io import (\n    BytesIO,\n    StringIO,\n)\nimport os\nfrom pathlib import Path\nimport re\nimport threading\nfrom typing import Iterator\nfrom urllib.error import URLError\n\nimport numpy as np\nimport pytest\n\nfrom pandas.compat import is_platform_windows\nimport pandas.util._test_decorators as td\n\nfrom pandas import (\n    DataFrame,\n    MultiIndex,\n    Series,\n    Timestamp,\n    date_range,\n    read_csv,\n    to_datetime,\n)\nimport pandas._testing as tm\n\nfrom pandas.io.common import file_path_to_url\nimport pandas.io.html\nfrom pandas.io.html import read_html\n\n\n@pytest.fixture(\n    params=[\n        \"chinese_utf-16.html\",\n        \"chinese_utf-32.html\",\n        \"chinese_utf-8.html\",\n        \"letz_latin1.html\",\n    ]\n)\ndef html_encoding_file(request, datapath):\n    \"\"\"Parametrized fixture for HTML encoding test filenames.\"\"\"\n    return datapath(\"io\", \"data\", \"html_encoding\", request.param)\n\n\ndef assert_framelist_equal(list1, list2, *args, **kwargs):\n    assert len(list1) == len(list2), (\n        \"lists are not of equal size \"\n        f\"len(list1) == {len(list1)}, \"\n        f\"len(list2) == {len(list2)}\"\n    )\n    msg = \"not all list elements are DataFrames\"\n    both_frames = all(\n        map(\n            lambda x, y: isinstance(x, DataFrame) and isinstance(y, DataFrame),\n            list1,\n            list2,\n        )\n    )\n    assert both_frames, msg\n    for frame_i, frame_j in zip(list1, list2):\n        tm.assert_frame_equal(frame_i, frame_j, *args, **kwargs)\n        assert not frame_i.empty, \"frames are both empty\"\n\n\n@td.skip_if_no(\"bs4\")\n@td.skip_if_no(\"html5lib\")\ndef test_bs4_version_fails(monkeypatch, datapath):\n    import bs4\n\n    monkeypatch.setattr(bs4, \"__version__\", \"4.2\")\n    with pytest.raises(ImportError, match=\"Pandas requires version\"):\n        read_html(datapath(\"io\", \"data\", \"html\", \"spam.html\"), flavor=\"bs4\")\n\n\ndef test_invalid_flavor():\n    url = \"google.com\"\n    flavor = \"invalid flavor\"\n    msg = r\"\\{\" + flavor + r\"\\} is not a valid set of flavors\"\n\n    with pytest.raises(ValueError, match=msg):\n        read_html(url, match=\"google\", flavor=flavor)\n\n\n@td.skip_if_no(\"bs4\")\n@td.skip_if_no(\"lxml\")\n@td.skip_if_no(\"html5lib\")\ndef test_same_ordering(datapath):\n    filename = datapath(\"io\", \"data\", \"html\", \"valid_markup.html\")\n    dfs_lxml = read_html(filename, index_col=0, flavor=[\"lxml\"])\n    dfs_bs4 = read_html(filename, index_col=0, flavor=[\"bs4\"])\n    assert_framelist_equal(dfs_lxml, dfs_bs4)\n\n\n@pytest.mark.parametrize(\n    \"flavor\",\n    [\n        pytest.param(\"bs4\", marks=[td.skip_if_no(\"bs4\"), td.skip_if_no(\"html5lib\")]),\n        pytest.param(\"lxml\", marks=td.skip_if_no(\"lxml\")),\n    ],\n    scope=\"class\",\n)\nclass TestReadHtml:\n    @pytest.fixture\n    def spam_data(self, datapath):\n        return datapath(\"io\", \"data\", \"html\", \"spam.html\")\n\n    @pytest.fixture\n    def banklist_data(self, datapath):\n        return datapath(\"io\", \"data\", \"html\", \"banklist.html\")\n\n    @pytest.fixture(autouse=True, scope=\"function\")\n    def set_defaults(self, flavor):\n        self.read_html = partial(read_html, flavor=flavor)\n        yield\n\n    def test_to_html_compat(self):\n        df = (\n            tm.makeCustomDataframe(\n                4,\n                3,\n                data_gen_f=lambda *args: np.random.rand(),\n                c_idx_names=False,\n                r_idx_names=False,\n            )\n            .applymap(\"{:.3f}\".format)\n            .astype(float)\n        )\n        out = df.to_html()\n        res = self.read_html(out, attrs={\"class\": \"dataframe\"}, index_col=0)[0]\n        tm.assert_frame_equal(res, df)\n\n    @pytest.mark.network\n    @tm.network(\n        url=(\n            \"https://www.fdic.gov/resources/resolutions/\"\n            \"bank-failures/failed-bank-list/index.html\"\n        ),\n        check_before_test=True,\n    )\n    def test_banklist_url_positional_match(self):\n        url = \"https://www.fdic.gov/resources/resolutions/bank-failures/failed-bank-list/index.html\"  # noqa E501\n        # Passing match argument as positional should cause a FutureWarning.\n        with tm.assert_produces_warning(FutureWarning):\n            df1 = self.read_html(\n                # lxml cannot find attrs leave out for now\n                url,\n                \"First Federal Bank of Florida\",  # attrs={\"class\": \"dataTable\"}\n            )\n        with tm.assert_produces_warning(FutureWarning):\n            # lxml cannot find attrs leave out for now\n            df2 = self.read_html(\n                url,\n                \"Metcalf Bank\",\n            )  # attrs={\"class\": \"dataTable\"})\n\n        assert_framelist_equal(df1, df2)\n\n    @pytest.mark.network\n    @tm.network(\n        url=(\n            \"https://www.fdic.gov/resources/resolutions/\"\n            \"bank-failures/failed-bank-list/index.html\"\n        ),\n        check_before_test=True,\n    )\n    def test_banklist_url(self):\n        url = \"https://www.fdic.gov/resources/resolutions/bank-failures/failed-bank-list/index.html\"  # noqa E501\n        df1 = self.read_html(\n            # lxml cannot find attrs leave out for now\n            url,\n            match=\"First Federal Bank of Florida\",  # attrs={\"class\": \"dataTable\"}\n        )\n        # lxml cannot find attrs leave out for now\n        df2 = self.read_html(\n            url,\n            match=\"Metcalf Bank\",\n        )  # attrs={\"class\": \"dataTable\"})\n\n        assert_framelist_equal(df1, df2)\n\n    @pytest.mark.network\n    @tm.network(\n        url=(\n            \"https://raw.githubusercontent.com/pandas-dev/pandas/main/\"\n            \"pandas/tests/io/data/html/spam.html\"\n        ),\n        check_before_test=True,\n    )\n    def test_spam_url(self):\n        url = (\n            \"https://raw.githubusercontent.com/pandas-dev/pandas/main/\"\n            \"pandas/tests/io/data/html/spam.html\"\n        )\n        df1 = self.read_html(url, match=\".*Water.*\")\n        df2 = self.read_html(url, match=\"Unit\")\n\n        assert_framelist_equal(df1, df2)\n\n    @pytest.mark.slow\n    def test_banklist(self, banklist_data):\n        df1 = self.read_html(banklist_data, match=\".*Florida.*\", attrs={\"id\": \"table\"})\n        df2 = self.read_html(banklist_data, match=\"Metcalf Bank\", attrs={\"id\": \"table\"})\n\n        assert_framelist_equal(df1, df2)\n\n    def test_spam(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\")\n        df2 = self.read_html(spam_data, match=\"Unit\")\n        assert_framelist_equal(df1, df2)\n\n        assert df1[0].iloc[0, 0] == \"Proximates\"\n        assert df1[0].columns[0] == \"Nutrient\"\n\n    def test_spam_no_match(self, spam_data):\n        dfs = self.read_html(spam_data)\n        for df in dfs:\n            assert isinstance(df, DataFrame)\n\n    def test_banklist_no_match(self, banklist_data):\n        dfs = self.read_html(banklist_data, attrs={\"id\": \"table\"})\n        for df in dfs:\n            assert isinstance(df, DataFrame)\n\n    def test_spam_header(self, spam_data):\n        df = self.read_html(spam_data, match=\".*Water.*\", header=2)[0]\n        assert df.columns[0] == \"Proximates\"\n        assert not df.empty\n\n    def test_skiprows_int(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=1)\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=1)\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_range(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=range(2))\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=range(2))\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_list(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=[1, 2])\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=[2, 1])\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_set(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows={1, 2})\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows={2, 1})\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_slice(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=1)\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=1)\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_slice_short(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=slice(2))\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=slice(2))\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_slice_long(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=slice(2, 5))\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=slice(4, 1, -1))\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_ndarray(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", skiprows=np.arange(2))\n        df2 = self.read_html(spam_data, match=\"Unit\", skiprows=np.arange(2))\n\n        assert_framelist_equal(df1, df2)\n\n    def test_skiprows_invalid(self, spam_data):\n        with pytest.raises(TypeError, match=(\"is not a valid type for skipping rows\")):\n            self.read_html(spam_data, match=\".*Water.*\", skiprows=\"asdf\")\n\n    def test_index(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", index_col=0)\n        df2 = self.read_html(spam_data, match=\"Unit\", index_col=0)\n        assert_framelist_equal(df1, df2)\n\n    def test_header_and_index_no_types(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", header=1, index_col=0)\n        df2 = self.read_html(spam_data, match=\"Unit\", header=1, index_col=0)\n        assert_framelist_equal(df1, df2)\n\n    def test_header_and_index_with_types(self, spam_data):\n        df1 = self.read_html(spam_data, match=\".*Water.*\", header=1, index_col=0)\n        df2 = self.read_html(spam_data, match=\"Unit\", header=1, index_col=0)\n        assert_framelist_equal(df1, df2)\n\n    def test_infer_types(self, spam_data):\n\n        # 10892 infer_types removed\n        df1 = self.read_html(spam_data, match=\".*Water.*\", index_col=0)\n        df2 = self.read_html(spam_data, match=\"Unit\", index_col=0)\n        assert_framelist_equal(df1, df2)\n\n    def test_string_io(self, spam_data):\n        with open(spam_data, encoding=\"UTF-8\") as f:\n            data1 = StringIO(f.read())\n\n        with open(spam_data, encoding=\"UTF-8\") as f:\n            data2 = StringIO(f.read())\n\n        df1 = self.read_html(data1, match=\".*Water.*\")\n        df2 = self.read_html(data2, match=\"Unit\")\n        assert_framelist_equal(df1, df2)\n\n    def test_string(self, spam_data):\n        with open(spam_data, encoding=\"UTF-8\") as f:\n            data = f.read()\n\n        df1 = self.read_html(data, match=\".*Water.*\")\n        df2 = self.read_html(data, match=\"Unit\")\n\n        assert_framelist_equal(df1, df2)\n\n    def test_file_like(self, spam_data):\n        with open(spam_data, encoding=\"UTF-8\") as f:\n            df1 = self.read_html(f, match=\".*Water.*\")\n\n        with open(spam_data, encoding=\"UTF-8\") as f:\n            df2 = self.read_html(f, match=\"Unit\")\n\n        assert_framelist_equal(df1, df2)\n\n    @pytest.mark.network\n    @tm.network\n    def test_bad_url_protocol(self):\n        with pytest.raises(URLError, match=\"urlopen error unknown url type: git\"):\n            self.read_html(\"git://github.com\", match=\".*Water.*\")\n\n    @pytest.mark.slow\n    @pytest.mark.network\n    @tm.network\n    def test_invalid_url(self):\n        msg = (\n            \"Name or service not known|Temporary failure in name resolution|\"\n            \"No tables found\"\n        )\n        with pytest.raises((URLError, ValueError), match=msg):\n            self.read_html(\"http://www.a23950sdfa908sd.com\", match=\".*Water.*\")\n\n    @pytest.mark.slow\n    def test_file_url(self, banklist_data):\n        url = banklist_data\n        dfs = self.read_html(\n            file_path_to_url(os.path.abspath(url)), match=\"First\", attrs={\"id\": \"table\"}\n        )\n        assert isinstance(dfs, list)\n        for df in dfs:\n            assert isinstance(df, DataFrame)\n\n    @pytest.mark.slow\n    def test_invalid_table_attrs(self, banklist_data):\n        url = banklist_data\n        with pytest.raises(ValueError, match=\"No tables found\"):\n            self.read_html(\n                url, match=\"First Federal Bank of Florida\", attrs={\"id\": \"tasdfable\"}\n            )\n\n    def _bank_data(self, path, *args, **kwargs):\n        return self.read_html(\n            path, match=\"Metcalf\", attrs={\"id\": \"table\"}, *args, **kwargs\n        )\n\n    @pytest.mark.slow\n    def test_multiindex_header(self, banklist_data):\n        df = self._bank_data(banklist_data, header=[0, 1])[0]\n        assert isinstance(df.columns, MultiIndex)\n\n    @pytest.mark.slow\n    def test_multiindex_index(self, banklist_data):\n        df = self._bank_data(banklist_data, index_col=[0, 1])[0]\n        assert isinstance(df.index, MultiIndex)\n\n    @pytest.mark.slow\n    def test_multiindex_header_index(self, banklist_data):\n        df = self._bank_data(banklist_data, header=[0, 1], index_col=[0, 1])[0]\n        assert isinstance(df.columns, MultiIndex)\n        assert isinstance(df.index, MultiIndex)\n\n    @pytest.mark.slow\n    def test_multiindex_header_skiprows_tuples(self, banklist_data):\n        df = self._bank_data(banklist_data, header=[0, 1], skiprows=1)[0]\n        assert isinstance(df.columns, MultiIndex)\n\n    @pytest.mark.slow\n    def test_multiindex_header_skiprows(self, banklist_data):\n        df = self._bank_data(banklist_data, header=[0, 1], skiprows=1)[0]\n        assert isinstance(df.columns, MultiIndex)\n\n    @pytest.mark.slow\n    def test_multiindex_header_index_skiprows(self, banklist_data):\n        df = self._bank_data(\n            banklist_data, header=[0, 1], index_col=[0, 1], skiprows=1\n        )[0]\n        assert isinstance(df.index, MultiIndex)\n        assert isinstance(df.columns, MultiIndex)\n\n    @pytest.mark.slow\n    def test_regex_idempotency(self, banklist_data):\n        url = banklist_data\n        dfs = self.read_html(\n            file_path_to_url(os.path.abspath(url)),\n            match=re.compile(re.compile(\"Florida\")),\n            attrs={\"id\": \"table\"},\n        )\n        assert isinstance(dfs, list)\n        for df in dfs:\n            assert isinstance(df, DataFrame)\n\n    def test_negative_skiprows(self, spam_data):\n        msg = r\"\\(you passed a negative value\\)\"\n        with pytest.raises(ValueError, match=msg):\n            self.read_html(spam_data, match=\"Water\", skiprows=-1)\n\n    @pytest.mark.network\n    @tm.network(url=\"https://docs.python.org/2/\", check_before_test=True)\n    def test_multiple_matches(self):\n        url = \"https://docs.python.org/2/\"\n        dfs = self.read_html(url, match=\"Python\")\n        assert len(dfs) > 1\n\n    @pytest.mark.network\n    @tm.network(url=\"https://docs.python.org/2/\", check_before_test=True)\n    def test_python_docs_table(self):\n        url = \"https://docs.python.org/2/\"\n        dfs = self.read_html(url, match=\"Python\")\n        zz = [df.iloc[0, 0][0:4] for df in dfs]\n        assert sorted(zz) == sorted([\"Repo\", \"What\"])\n\n    def test_empty_tables(self):\n        \"\"\"\n        Make sure that read_html ignores empty tables.\n        \"\"\"\n        html = \"\"\"\n            <table>\n                <thead>\n                    <tr>\n                        <th>A</th>\n                        <th>B</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr>\n                        <td>1</td>\n                        <td>2</td>\n                    </tr>\n                </tbody>\n            </table>\n            <table>\n                <tbody>\n                </tbody>\n            </table>\n        \"\"\"\n        result = self.read_html(html)\n        assert len(result) == 1\n\n    def test_multiple_tbody(self):\n        # GH-20690\n        # Read all tbody tags within a single table.\n        result = self.read_html(\n            \"\"\"<table>\n            <thead>\n                <tr>\n                    <th>A</th>\n                    <th>B</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>1</td>\n                    <td>2</td>\n                </tr>\n            </tbody>\n            <tbody>\n                <tr>\n                    <td>3</td>\n                    <td>4</td>\n                </tr>\n            </tbody>\n        </table>\"\"\"\n        )[0]\n\n        expected = DataFrame(data=[[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_header_and_one_column(self):\n        \"\"\"\n        Don't fail with bs4 when there is a header and only one column\n        as described in issue #9178\n        \"\"\"\n        result = self.read_html(\n            \"\"\"<table>\n                <thead>\n                    <tr>\n                        <th>Header</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr>\n                        <td>first</td>\n                    </tr>\n                </tbody>\n            </table>\"\"\"\n        )[0]\n\n        expected = DataFrame(data={\"Header\": \"first\"}, index=[0])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_thead_without_tr(self):\n        \"\"\"\n        Ensure parser adds <tr> within <thead> on malformed HTML.\n        \"\"\"\n        result = self.read_html(\n            \"\"\"<table>\n            <thead>\n                <tr>\n                    <th>Country</th>\n                    <th>Municipality</th>\n                    <th>Year</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>Ukraine</td>\n                    <th>Odessa</th>\n                    <td>1944</td>\n                </tr>\n            </tbody>\n        </table>\"\"\"\n        )[0]\n\n        expected = DataFrame(\n            data=[[\"Ukraine\", \"Odessa\", 1944]],\n            columns=[\"Country\", \"Municipality\", \"Year\"],\n        )\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_tfoot_read(self):\n        \"\"\"\n        Make sure that read_html reads tfoot, containing td or th.\n        Ignores empty tfoot\n        \"\"\"\n        data_template = \"\"\"<table>\n            <thead>\n                <tr>\n                    <th>A</th>\n                    <th>B</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>bodyA</td>\n                    <td>bodyB</td>\n                </tr>\n            </tbody>\n            <tfoot>\n                {footer}\n            </tfoot>\n        </table>\"\"\"\n\n        expected1 = DataFrame(data=[[\"bodyA\", \"bodyB\"]], columns=[\"A\", \"B\"])\n\n        expected2 = DataFrame(\n            data=[[\"bodyA\", \"bodyB\"], [\"footA\", \"footB\"]], columns=[\"A\", \"B\"]\n        )\n\n        data1 = data_template.format(footer=\"\")\n        data2 = data_template.format(footer=\"<tr><td>footA</td><th>footB</th></tr>\")\n\n        result1 = self.read_html(data1)[0]\n        result2 = self.read_html(data2)[0]\n\n        tm.assert_frame_equal(result1, expected1)\n        tm.assert_frame_equal(result2, expected2)\n\n    def test_parse_header_of_non_string_column(self):\n        # GH5048: if header is specified explicitly, an int column should be\n        # parsed as int while its header is parsed as str\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <td>S</td>\n                    <td>I</td>\n                </tr>\n                <tr>\n                    <td>text</td>\n                    <td>1944</td>\n                </tr>\n            </table>\n        \"\"\",\n            header=0,\n        )[0]\n\n        expected = DataFrame([[\"text\", 1944]], columns=(\"S\", \"I\"))\n\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.slow\n    def test_banklist_header(self, banklist_data, datapath):\n        from pandas.io.html import _remove_whitespace\n\n        def try_remove_ws(x):\n            try:\n                return _remove_whitespace(x)\n            except AttributeError:\n                return x\n\n        df = self.read_html(banklist_data, match=\"Metcalf\", attrs={\"id\": \"table\"})[0]\n        ground_truth = read_csv(\n            datapath(\"io\", \"data\", \"csv\", \"banklist.csv\"),\n            converters={\"Updated Date\": Timestamp, \"Closing Date\": Timestamp},\n        )\n        assert df.shape == ground_truth.shape\n        old = [\n            \"First Vietnamese American Bank In Vietnamese\",\n            \"Westernbank Puerto Rico En Espanol\",\n            \"R-G Premier Bank of Puerto Rico En Espanol\",\n            \"Eurobank En Espanol\",\n            \"Sanderson State Bank En Espanol\",\n            \"Washington Mutual Bank (Including its subsidiary Washington \"\n            \"Mutual Bank FSB)\",\n            \"Silver State Bank En Espanol\",\n            \"AmTrade International Bank En Espanol\",\n            \"Hamilton Bank, NA En Espanol\",\n            \"The Citizens Savings Bank Pioneer Community Bank, Inc.\",\n        ]\n        new = [\n            \"First Vietnamese American Bank\",\n            \"Westernbank Puerto Rico\",\n            \"R-G Premier Bank of Puerto Rico\",\n            \"Eurobank\",\n            \"Sanderson State Bank\",\n            \"Washington Mutual Bank\",\n            \"Silver State Bank\",\n            \"AmTrade International Bank\",\n            \"Hamilton Bank, NA\",\n            \"The Citizens Savings Bank\",\n        ]\n        dfnew = df.applymap(try_remove_ws).replace(old, new)\n        gtnew = ground_truth.applymap(try_remove_ws)\n        converted = dfnew._convert(datetime=True, numeric=True)\n        date_cols = [\"Closing Date\", \"Updated Date\"]\n        converted[date_cols] = converted[date_cols].apply(to_datetime)\n        tm.assert_frame_equal(converted, gtnew)\n\n    @pytest.mark.slow\n    def test_gold_canyon(self, banklist_data):\n        gc = \"Gold Canyon\"\n        with open(banklist_data) as f:\n            raw_text = f.read()\n\n        assert gc in raw_text\n        df = self.read_html(banklist_data, match=\"Gold Canyon\", attrs={\"id\": \"table\"})[\n            0\n        ]\n        assert gc in df.to_string()\n\n    def test_different_number_of_cols(self):\n        expected = self.read_html(\n            \"\"\"<table>\n                        <thead>\n                            <tr style=\"text-align: right;\">\n                            <th></th>\n                            <th>C_l0_g0</th>\n                            <th>C_l0_g1</th>\n                            <th>C_l0_g2</th>\n                            <th>C_l0_g3</th>\n                            <th>C_l0_g4</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                            <th>R_l0_g0</th>\n                            <td> 0.763</td>\n                            <td> 0.233</td>\n                            <td> nan</td>\n                            <td> nan</td>\n                            <td> nan</td>\n                            </tr>\n                            <tr>\n                            <th>R_l0_g1</th>\n                            <td> 0.244</td>\n                            <td> 0.285</td>\n                            <td> 0.392</td>\n                            <td> 0.137</td>\n                            <td> 0.222</td>\n                            </tr>\n                        </tbody>\n                    </table>\"\"\",\n            index_col=0,\n        )[0]\n\n        result = self.read_html(\n            \"\"\"<table>\n                    <thead>\n                        <tr style=\"text-align: right;\">\n                        <th></th>\n                        <th>C_l0_g0</th>\n                        <th>C_l0_g1</th>\n                        <th>C_l0_g2</th>\n                        <th>C_l0_g3</th>\n                        <th>C_l0_g4</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        <tr>\n                        <th>R_l0_g0</th>\n                        <td> 0.763</td>\n                        <td> 0.233</td>\n                        </tr>\n                        <tr>\n                        <th>R_l0_g1</th>\n                        <td> 0.244</td>\n                        <td> 0.285</td>\n                        <td> 0.392</td>\n                        <td> 0.137</td>\n                        <td> 0.222</td>\n                        </tr>\n                    </tbody>\n                 </table>\"\"\",\n            index_col=0,\n        )[0]\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_colspan_rowspan_1(self):\n        # GH17054\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <th>A</th>\n                    <th colspan=\"1\">B</th>\n                    <th rowspan=\"1\">C</th>\n                </tr>\n                <tr>\n                    <td>a</td>\n                    <td>b</td>\n                    <td>c</td>\n                </tr>\n            </table>\n        \"\"\"\n        )[0]\n\n        expected = DataFrame([[\"a\", \"b\", \"c\"]], columns=[\"A\", \"B\", \"C\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_colspan_rowspan_copy_values(self):\n        # GH17054\n\n        # In ASCII, with lowercase letters being copies:\n        #\n        # X x Y Z W\n        # A B b z C\n\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <td colspan=\"2\">X</td>\n                    <td>Y</td>\n                    <td rowspan=\"2\">Z</td>\n                    <td>W</td>\n                </tr>\n                <tr>\n                    <td>A</td>\n                    <td colspan=\"2\">B</td>\n                    <td>C</td>\n                </tr>\n            </table>\n        \"\"\",\n            header=0,\n        )[0]\n\n        expected = DataFrame(\n            data=[[\"A\", \"B\", \"B\", \"Z\", \"C\"]], columns=[\"X\", \"X.1\", \"Y\", \"Z\", \"W\"]\n        )\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_colspan_rowspan_both_not_1(self):\n        # GH17054\n\n        # In ASCII, with lowercase letters being copies:\n        #\n        # A B b b C\n        # a b b b D\n\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <td rowspan=\"2\">A</td>\n                    <td rowspan=\"2\" colspan=\"3\">B</td>\n                    <td>C</td>\n                </tr>\n                <tr>\n                    <td>D</td>\n                </tr>\n            </table>\n        \"\"\",\n            header=0,\n        )[0]\n\n        expected = DataFrame(\n            data=[[\"A\", \"B\", \"B\", \"B\", \"D\"]], columns=[\"A\", \"B\", \"B.1\", \"B.2\", \"C\"]\n        )\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_rowspan_at_end_of_row(self):\n        # GH17054\n\n        # In ASCII, with lowercase letters being copies:\n        #\n        # A B\n        # C b\n\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <td>A</td>\n                    <td rowspan=\"2\">B</td>\n                </tr>\n                <tr>\n                    <td>C</td>\n                </tr>\n            </table>\n        \"\"\",\n            header=0,\n        )[0]\n\n        expected = DataFrame(data=[[\"C\", \"B\"]], columns=[\"A\", \"B\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_rowspan_only_rows(self):\n        # GH17054\n\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <td rowspan=\"3\">A</td>\n                    <td rowspan=\"3\">B</td>\n                </tr>\n            </table>\n        \"\"\",\n            header=0,\n        )[0]\n\n        expected = DataFrame(data=[[\"A\", \"B\"], [\"A\", \"B\"]], columns=[\"A\", \"B\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_header_inferred_from_rows_with_only_th(self):\n        # GH17054\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <th>A</th>\n                    <th>B</th>\n                </tr>\n                <tr>\n                    <th>a</th>\n                    <th>b</th>\n                </tr>\n                <tr>\n                    <td>1</td>\n                    <td>2</td>\n                </tr>\n            </table>\n        \"\"\"\n        )[0]\n\n        columns = MultiIndex(levels=[[\"A\", \"B\"], [\"a\", \"b\"]], codes=[[0, 1], [0, 1]])\n        expected = DataFrame(data=[[1, 2]], columns=columns)\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_parse_dates_list(self):\n        df = DataFrame({\"date\": date_range(\"1/1/2001\", periods=10)})\n        expected = df.to_html()\n        res = self.read_html(expected, parse_dates=[1], index_col=0)\n        tm.assert_frame_equal(df, res[0])\n        res = self.read_html(expected, parse_dates=[\"date\"], index_col=0)\n        tm.assert_frame_equal(df, res[0])\n\n    def test_parse_dates_combine(self):\n        raw_dates = Series(date_range(\"1/1/2001\", periods=10))\n        df = DataFrame(\n            {\n                \"date\": raw_dates.map(lambda x: str(x.date())),\n                \"time\": raw_dates.map(lambda x: str(x.time())),\n            }\n        )\n        res = self.read_html(\n            df.to_html(), parse_dates={\"datetime\": [1, 2]}, index_col=1\n        )\n        newdf = DataFrame({\"datetime\": raw_dates})\n        tm.assert_frame_equal(newdf, res[0])\n\n    def test_wikipedia_states_table(self, datapath):\n        data = datapath(\"io\", \"data\", \"html\", \"wikipedia_states.html\")\n        assert os.path.isfile(data), f\"{repr(data)} is not a file\"\n        assert os.path.getsize(data), f\"{repr(data)} is an empty file\"\n        result = self.read_html(data, match=\"Arizona\", header=1)[0]\n        assert result.shape == (60, 12)\n        assert \"Unnamed\" in result.columns[-1]\n        assert result[\"sq mi\"].dtype == np.dtype(\"float64\")\n        assert np.allclose(result.loc[0, \"sq mi\"], 665384.04)\n\n    def test_wikipedia_states_multiindex(self, datapath):\n        data = datapath(\"io\", \"data\", \"html\", \"wikipedia_states.html\")\n        result = self.read_html(data, match=\"Arizona\", index_col=0)[0]\n        assert result.shape == (60, 11)\n        assert \"Unnamed\" in result.columns[-1][1]\n        assert result.columns.nlevels == 2\n        assert np.allclose(result.loc[\"Alaska\", (\"Total area[2]\", \"sq mi\")], 665384.04)\n\n    def test_parser_error_on_empty_header_row(self):\n        result = self.read_html(\n            \"\"\"\n                <table>\n                    <thead>\n                        <tr><th></th><th></tr>\n                        <tr><th>A</th><th>B</th></tr>\n                    </thead>\n                    <tbody>\n                        <tr><td>a</td><td>b</td></tr>\n                    </tbody>\n                </table>\n            \"\"\",\n            header=[0, 1],\n        )\n        expected = DataFrame(\n            [[\"a\", \"b\"]],\n            columns=MultiIndex.from_tuples(\n                [(\"Unnamed: 0_level_0\", \"A\"), (\"Unnamed: 1_level_0\", \"B\")]\n            ),\n        )\n        tm.assert_frame_equal(result[0], expected)\n\n    def test_decimal_rows(self):\n        # GH 12907\n        result = self.read_html(\n            \"\"\"<html>\n            <body>\n             <table>\n                <thead>\n                    <tr>\n                        <th>Header</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr>\n                        <td>1100#101</td>\n                    </tr>\n                </tbody>\n            </table>\n            </body>\n        </html>\"\"\",\n            decimal=\"#\",\n        )[0]\n\n        expected = DataFrame(data={\"Header\": 1100.101}, index=[0])\n\n        assert result[\"Header\"].dtype == np.dtype(\"float64\")\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\"arg\", [True, False])\n    def test_bool_header_arg(self, spam_data, arg):\n        # GH 6114\n        msg = re.escape(\n            \"Passing a bool to header is invalid. Use header=None for no header or \"\n            \"header=int or list-like of ints to specify the row(s) making up the \"\n            \"column names\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self.read_html(spam_data, header=arg)\n\n    def test_converters(self):\n        # GH 13461\n        result = self.read_html(\n            \"\"\"<table>\n                 <thead>\n                   <tr>\n                     <th>a</th>\n                    </tr>\n                 </thead>\n                 <tbody>\n                   <tr>\n                     <td> 0.763</td>\n                   </tr>\n                   <tr>\n                     <td> 0.244</td>\n                   </tr>\n                 </tbody>\n               </table>\"\"\",\n            converters={\"a\": str},\n        )[0]\n\n        expected = DataFrame({\"a\": [\"0.763\", \"0.244\"]})\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_na_values(self):\n        # GH 13461\n        result = self.read_html(\n            \"\"\"<table>\n                 <thead>\n                   <tr>\n                     <th>a</th>\n                   </tr>\n                 </thead>\n                 <tbody>\n                   <tr>\n                     <td> 0.763</td>\n                   </tr>\n                   <tr>\n                     <td> 0.244</td>\n                   </tr>\n                 </tbody>\n               </table>\"\"\",\n            na_values=[0.244],\n        )[0]\n\n        expected = DataFrame({\"a\": [0.763, np.nan]})\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_keep_default_na(self):\n        html_data = \"\"\"<table>\n                        <thead>\n                            <tr>\n                            <th>a</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                            <td> N/A</td>\n                            </tr>\n                            <tr>\n                            <td> NA</td>\n                            </tr>\n                        </tbody>\n                    </table>\"\"\"\n\n        expected_df = DataFrame({\"a\": [\"N/A\", \"NA\"]})\n        html_df = self.read_html(html_data, keep_default_na=False)[0]\n        tm.assert_frame_equal(expected_df, html_df)\n\n        expected_df = DataFrame({\"a\": [np.nan, np.nan]})\n        html_df = self.read_html(html_data, keep_default_na=True)[0]\n        tm.assert_frame_equal(expected_df, html_df)\n\n    def test_preserve_empty_rows(self):\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <th>A</th>\n                    <th>B</th>\n                </tr>\n                <tr>\n                    <td>a</td>\n                    <td>b</td>\n                </tr>\n                <tr>\n                    <td></td>\n                    <td></td>\n                </tr>\n            </table>\n        \"\"\"\n        )[0]\n\n        expected = DataFrame(data=[[\"a\", \"b\"], [np.nan, np.nan]], columns=[\"A\", \"B\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_ignore_empty_rows_when_inferring_header(self):\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <thead>\n                    <tr><th></th><th></tr>\n                    <tr><th>A</th><th>B</th></tr>\n                    <tr><th>a</th><th>b</th></tr>\n                </thead>\n                <tbody>\n                    <tr><td>1</td><td>2</td></tr>\n                </tbody>\n            </table>\n        \"\"\"\n        )[0]\n\n        columns = MultiIndex(levels=[[\"A\", \"B\"], [\"a\", \"b\"]], codes=[[0, 1], [0, 1]])\n        expected = DataFrame(data=[[1, 2]], columns=columns)\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_multiple_header_rows(self):\n        # Issue #13434\n        expected_df = DataFrame(\n            data=[(\"Hillary\", 68, \"D\"), (\"Bernie\", 74, \"D\"), (\"Donald\", 69, \"R\")]\n        )\n        expected_df.columns = [\n            [\"Unnamed: 0_level_0\", \"Age\", \"Party\"],\n            [\"Name\", \"Unnamed: 1_level_1\", \"Unnamed: 2_level_1\"],\n        ]\n        html = expected_df.to_html(index=False)\n        html_df = self.read_html(html)[0]\n        tm.assert_frame_equal(expected_df, html_df)\n\n    def test_works_on_valid_markup(self, datapath):\n        filename = datapath(\"io\", \"data\", \"html\", \"valid_markup.html\")\n        dfs = self.read_html(filename, index_col=0)\n        assert isinstance(dfs, list)\n        assert isinstance(dfs[0], DataFrame)\n\n    @pytest.mark.slow\n    def test_fallback_success(self, datapath):\n        banklist_data = datapath(\"io\", \"data\", \"html\", \"banklist.html\")\n        self.read_html(\n            banklist_data, match=\".*Water.*\", flavor=[\"lxml\", \"html5lib\"]\n        )  # pylint: disable=redundant-keyword-arg\n\n    def test_to_html_timestamp(self):\n        rng = date_range(\"2000-01-01\", periods=10)\n        df = DataFrame(np.random.randn(10, 4), index=rng)\n\n        result = df.to_html()\n        assert \"2000-01-01\" in result\n\n    def test_to_html_borderless(self):\n        df = DataFrame([{\"A\": 1, \"B\": 2}])\n        out_border_default = df.to_html()\n        out_border_true = df.to_html(border=True)\n        out_border_explicit_default = df.to_html(border=1)\n        out_border_nondefault = df.to_html(border=2)\n        out_border_zero = df.to_html(border=0)\n\n        out_border_false = df.to_html(border=False)\n\n        assert ' border=\"1\"' in out_border_default\n        assert out_border_true == out_border_default\n        assert out_border_default == out_border_explicit_default\n        assert out_border_default != out_border_nondefault\n        assert ' border=\"2\"' in out_border_nondefault\n        assert ' border=\"0\"' not in out_border_zero\n        assert \" border\" not in out_border_false\n        assert out_border_zero == out_border_false\n\n    @pytest.mark.parametrize(\n        \"displayed_only,exp0,exp1\",\n        [\n            (True, DataFrame([\"foo\"]), None),\n            (False, DataFrame([\"foo  bar  baz  qux\"]), DataFrame([\"foo\"])),\n        ],\n    )\n    def test_displayed_only(self, displayed_only, exp0, exp1):\n        # GH 20027\n        data = StringIO(\n            \"\"\"<html>\n          <body>\n            <table>\n              <tr>\n                <td>\n                  foo\n                  <span style=\"display:none;text-align:center\">bar</span>\n                  <span style=\"display:none\">baz</span>\n                  <span style=\"display: none\">qux</span>\n                </td>\n              </tr>\n            </table>\n            <table style=\"display: none\">\n              <tr>\n                <td>foo</td>\n              </tr>\n            </table>\n          </body>\n        </html>\"\"\"\n        )\n\n        dfs = self.read_html(data, displayed_only=displayed_only)\n        tm.assert_frame_equal(dfs[0], exp0)\n\n        if exp1 is not None:\n            tm.assert_frame_equal(dfs[1], exp1)\n        else:\n            assert len(dfs) == 1  # Should not parse hidden table\n\n    @pytest.mark.filterwarnings(\n        \"ignore:You provided Unicode markup but also provided a value for \"\n        \"from_encoding.*:UserWarning\"\n    )\n    def test_encode(self, html_encoding_file):\n        base_path = os.path.basename(html_encoding_file)\n        root = os.path.splitext(base_path)[0]\n        _, encoding = root.split(\"_\")\n\n        try:\n            with open(html_encoding_file, \"rb\") as fobj:\n                from_string = self.read_html(\n                    fobj.read(), encoding=encoding, index_col=0\n                ).pop()\n\n            with open(html_encoding_file, \"rb\") as fobj:\n                from_file_like = self.read_html(\n                    BytesIO(fobj.read()), encoding=encoding, index_col=0\n                ).pop()\n\n            from_filename = self.read_html(\n                html_encoding_file, encoding=encoding, index_col=0\n            ).pop()\n            tm.assert_frame_equal(from_string, from_file_like)\n            tm.assert_frame_equal(from_string, from_filename)\n        except Exception:\n            # seems utf-16/32 fail on windows\n            if is_platform_windows():\n                if \"16\" in encoding or \"32\" in encoding:\n                    pytest.skip()\n            raise\n\n    def test_parse_failure_unseekable(self):\n        # Issue #17975\n\n        if self.read_html.keywords.get(\"flavor\") == \"lxml\":\n            pytest.skip(\"Not applicable for lxml\")\n\n        class UnseekableStringIO(StringIO):\n            def seekable(self):\n                return False\n\n        bad = UnseekableStringIO(\n            \"\"\"\n            <table><tr><td>spam<foobr />eggs</td></tr></table>\"\"\"\n        )\n\n        assert self.read_html(bad)\n\n        with pytest.raises(ValueError, match=\"passed a non-rewindable file object\"):\n            self.read_html(bad)\n\n    def test_parse_failure_rewinds(self):\n        # Issue #17975\n\n        class MockFile:\n            def __init__(self, data) -> None:\n                self.data = data\n                self.at_end = False\n\n            def read(self, size=None):\n                data = \"\" if self.at_end else self.data\n                self.at_end = True\n                return data\n\n            def seek(self, offset):\n                self.at_end = False\n\n            def seekable(self):\n                return True\n\n            def __iter__(self) -> Iterator:\n                # to fool `is_file_like`, should never end up here\n                assert False\n\n        good = MockFile(\"<table><tr><td>spam<br />eggs</td></tr></table>\")\n        bad = MockFile(\"<table><tr><td>spam<foobr />eggs</td></tr></table>\")\n\n        assert self.read_html(good)\n        assert self.read_html(bad)\n\n    @pytest.mark.slow\n    def test_importcheck_thread_safety(self, datapath):\n        # see gh-16928\n\n        class ErrorThread(threading.Thread):\n            def run(self):\n                try:\n                    super().run()\n                except Exception as err:\n                    self.err = err\n                else:\n                    self.err = None\n\n        # force import check by reinitalising global vars in html.py\n        reload(pandas.io.html)\n\n        filename = datapath(\"io\", \"data\", \"html\", \"valid_markup.html\")\n        helper_thread1 = ErrorThread(target=self.read_html, args=(filename,))\n        helper_thread2 = ErrorThread(target=self.read_html, args=(filename,))\n\n        helper_thread1.start()\n        helper_thread2.start()\n\n        while helper_thread1.is_alive() or helper_thread2.is_alive():\n            pass\n        assert None is helper_thread1.err is helper_thread2.err\n\n    def test_parse_path_object(self, datapath):\n        # GH 37705\n        file_path_string = datapath(\"io\", \"data\", \"html\", \"spam.html\")\n        file_path = Path(file_path_string)\n        df1 = self.read_html(file_path_string)[0]\n        df2 = self.read_html(file_path)[0]\n        tm.assert_frame_equal(df1, df2)\n\n    def test_parse_br_as_space(self):\n        # GH 29528: pd.read_html() convert <br> to space\n        result = self.read_html(\n            \"\"\"\n            <table>\n                <tr>\n                    <th>A</th>\n                </tr>\n                <tr>\n                    <td>word1<br>word2</td>\n                </tr>\n            </table>\n        \"\"\"\n        )[0]\n\n        expected = DataFrame(data=[[\"word1 word2\"]], columns=[\"A\"])\n\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\"arg\", [\"all\", \"body\", \"header\", \"footer\"])\n    def test_extract_links(self, arg):\n        gh_13141_data = \"\"\"\n          <table>\n            <tr>\n              <th>HTTP</th>\n              <th>FTP</th>\n              <th><a href=\"https://en.wiktionary.org/wiki/linkless\">Linkless</a></th>\n            </tr>\n            <tr>\n              <td><a href=\"https://en.wikipedia.org/\">Wikipedia</a></td>\n              <td>SURROUNDING <a href=\"ftp://ftp.us.debian.org/\">Debian</a> TEXT</td>\n              <td>Linkless</td>\n            </tr>\n            <tfoot>\n              <tr>\n                <td><a href=\"https://en.wikipedia.org/wiki/Page_footer\">Footer</a></td>\n                <td>\n                  Multiple <a href=\"1\">links:</a> <a href=\"2\">Only first captured.</a>\n                </td>\n              </tr>\n            </tfoot>\n          </table>\n          \"\"\"\n\n        gh_13141_expected = {\n            \"head_ignore\": [\"HTTP\", \"FTP\", \"Linkless\"],\n            \"head_extract\": [\n                (\"HTTP\", None),\n                (\"FTP\", None),\n                (\"Linkless\", \"https://en.wiktionary.org/wiki/linkless\"),\n            ],\n            \"body_ignore\": [\"Wikipedia\", \"SURROUNDING Debian TEXT\", \"Linkless\"],\n            \"body_extract\": [\n                (\"Wikipedia\", \"https://en.wikipedia.org/\"),\n                (\"SURROUNDING Debian TEXT\", \"ftp://ftp.us.debian.org/\"),\n                (\"Linkless\", None),\n            ],\n            \"footer_ignore\": [\n                \"Footer\",\n                \"Multiple links: Only first captured.\",\n                None,\n            ],\n            \"footer_extract\": [\n                (\"Footer\", \"https://en.wikipedia.org/wiki/Page_footer\"),\n                (\"Multiple links: Only first captured.\", \"1\"),\n                None,\n            ],\n        }\n\n        data_exp = gh_13141_expected[\"body_ignore\"]\n        foot_exp = gh_13141_expected[\"footer_ignore\"]\n        head_exp = gh_13141_expected[\"head_ignore\"]\n        if arg == \"all\":\n            data_exp = gh_13141_expected[\"body_extract\"]\n            foot_exp = gh_13141_expected[\"footer_extract\"]\n            head_exp = gh_13141_expected[\"head_extract\"]\n        elif arg == \"body\":\n            data_exp = gh_13141_expected[\"body_extract\"]\n        elif arg == \"footer\":\n            foot_exp = gh_13141_expected[\"footer_extract\"]\n        elif arg == \"header\":\n            head_exp = gh_13141_expected[\"head_extract\"]\n\n        result = self.read_html(gh_13141_data, extract_links=arg)[0]\n        expected = DataFrame([data_exp, foot_exp], columns=head_exp)\n        tm.assert_frame_equal(result, expected)\n\n    def test_extract_links_bad(self, spam_data):\n        msg = (\n            \"`extract_links` must be one of \"\n            '{None, \"header\", \"footer\", \"body\", \"all\"}, got \"incorrect\"'\n        )\n        with pytest.raises(ValueError, match=msg):\n            read_html(spam_data, extract_links=\"incorrect\")\n\n    def test_extract_links_all_no_header(self):\n        # GH 48316\n        data = \"\"\"\n        <table>\n          <tr>\n            <td>\n              <a href='https://google.com'>Google.com</a>\n            </td>\n          </tr>\n        </table>\n        \"\"\"\n        result = self.read_html(data, extract_links=\"all\")[0]\n        expected = DataFrame([[(\"Google.com\", \"https://google.com\")]])\n        tm.assert_frame_equal(result, expected)\n"
    }
  ]
}