{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "39443",
  "issue_description": "# BUG: Concatenating categorical datetime columns raises a ValueError since v1.2\n\n- [X] I have checked that this issue has not already been reported.\r\n\r\n- [X] I have confirmed this bug exists on the latest version of pandas.\r\n\r\n- [X] (optional) I have confirmed this bug exists on the master branch of pandas.\r\n\r\n---\r\n\r\n#### Code Sample, a copy-pastable example\r\n\r\n```python\r\nimport pandas as pd\r\nfrom datetime import datetime\r\n\r\npd.concat([\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0], dtype='category')}),\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1], dtype='category')}),\r\n])\r\n```\r\n\r\n#### Problem description\r\n\r\nSince v1.2, concatenating two or more dataframes with at least one categorical datetime column with different categories raises this error:\r\n\r\n<details>\r\n    <summary>Traceback</summary>\r\n\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-1-36ad6bb4648d> in <module>\r\n      2 from datetime import datetime\r\n      3 \r\n----> 4 pd.concat([\r\n      5     pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0], dtype='category')}),\r\n      6     pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1], dtype='category')}),\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/reshape/concat.py in concat(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)\r\n    296     )\r\n    297 \r\n--> 298     return op.get_result()\r\n    299 \r\n    300 \r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/reshape/concat.py in get_result(self)\r\n    518                 mgrs_indexers.append((obj._mgr, indexers))\r\n    519 \r\n--> 520             new_data = concatenate_block_managers(\r\n    521                 mgrs_indexers, self.new_axes, concat_axis=self.bm_axis, copy=self.copy\r\n    522             )\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/concat.py in concatenate_block_managers(mgrs_indexers, axes, concat_axis, copy)\r\n     78                     values = values.reshape(1, len(values))\r\n     79 \r\n---> 80             b = make_block(values, placement=placement, ndim=blk.ndim)\r\n     81         else:\r\n     82             b = make_block(\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in make_block(values, placement, klass, ndim, dtype)\r\n   2730         values = DatetimeArray._simple_new(values, dtype=dtype)\r\n   2731 \r\n-> 2732     return klass(values, ndim=ndim, placement=placement)\r\n   2733 \r\n   2734 \r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in __init__(self, values, placement, ndim)\r\n    135         \"\"\"\r\n    136         # TODO(EA2D): ndim will be unnecessary with 2D EAs\r\n--> 137         self.ndim = self._check_ndim(values, ndim)\r\n    138         self.mgr_locs = placement\r\n    139         self.values = self._maybe_coerce_values(values)\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in _check_ndim(self, values, ndim)\r\n    184 \r\n    185         if self._validate_ndim and values.ndim != ndim:\r\n--> 186             raise ValueError(\r\n    187                 \"Wrong number of dimensions. \"\r\n    188                 f\"values.ndim != ndim [{values.ndim} != {ndim}]\"\r\n\r\nValueError: Wrong number of dimensions. values.ndim != ndim [1 != 2]\r\n```\r\n</details>\r\n\r\nI have confirmed that:\r\n- it happens on `v1.2.0`, `v1.2.1`, and `v1.3.0.dev0+553.gd0cfa0303` on both Windows 10 and Linux\r\n- it doesn't happen before `v1.2` or if the categories are the same\r\n\r\n#### Expected Output\r\n\r\nA single, properly concatenated dataframe:\r\n\r\n```\r\n           x\r\n0 2021-01-01\r\n1 2021-01-02\r\n```\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\n```\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 9d598a5e1eee26df95b3910e3f2934890d062caa\r\npython           : 3.9.1.final.0\r\npython-bits      : 64\r\nOS               : Linux\r\nOS-release       : 5.10.10-zen1-1-zen\r\nVersion          : #1 ZEN SMP PREEMPT Sat, 23 Jan 2021 23:59:50 +0000\r\nmachine          : x86_64\r\nprocessor        : \r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : en_US.UTF-8\r\nLOCALE           : en_US.UTF-8\r\n\r\npandas           : 1.2.1\r\nnumpy            : 1.19.5\r\npytz             : 2020.5\r\ndateutil         : 2.8.1\r\npip              : 20.3.1\r\nsetuptools       : 52.0.0\r\nCython           : 0.29.21\r\npytest           : 6.2.1\r\nhypothesis       : None\r\nsphinx           : 3.4.3\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : 4.6.2\r\nhtml5lib         : 1.1\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : 2.11.2\r\nIPython          : 7.19.0\r\npandas_datareader: None\r\nbs4              : 4.9.3\r\nbottleneck       : None\r\nfsspec           : 0.8.5\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.3.3\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : None\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.6.0\r\nsqlalchemy       : 1.3.22\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n```\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 768897534,
      "user": "MarcoGorelli",
      "body": "Thanks @aiudirog for the excellent report!\r\n\r\n\r\nIf I've done git bisect correctly, \r\n```\r\ncc957d1b4fdc4f7107ba5eae66f606663399e410 is the first bad commit\r\ncommit cc957d1b4fdc4f7107ba5eae66f606663399e410\r\nAuthor: Andrew Wieteska <48889395+arw2019@users.noreply.github.com>\r\nDate:   Wed Nov 18 13:21:50 2020 -0500\r\n\r\n     PERF/ENH: add fast astyping for Categorical (#37355)\r\n```\r\n\r\ncc @arw2019\r\n"
    },
    {
      "id": 769732590,
      "user": "simonjayhawkins",
      "body": "> ```\r\n>      PERF/ENH: add fast astyping for Categorical (#37355)\r\n> ```\r\n\r\n#37355"
    },
    {
      "id": 774278156,
      "user": "arw2019",
      "body": "looking "
    },
    {
      "id": 775213164,
      "user": "simonjayhawkins",
      "body": "moving to 1.2.3"
    },
    {
      "id": 805354101,
      "user": "mzeitlin11",
      "body": "This example works on 1.2.2 and current 1.2.x. If I've bisected correctly, was fixed by #39615 (which went in 1.2.2). A test should be added, is adding a whatsnew also needed?"
    },
    {
      "id": 819483547,
      "user": "arredond",
      "body": "take"
    },
    {
      "id": 823964197,
      "user": "arredond",
      "body": "I've provided the above PR adding a test for this case. However, I'm running in to some trouble with the PR passing the CI checks.\r\n\r\nThe initial version of the test I wrote was this like so:\r\n\r\n```python\r\n# GH 39443\r\ndf1 = DataFrame(\r\n    {\"x\": Series(datetime(2021, 1, 1), index=[0], dtype=\"category\")}\r\n)\r\ndf2 = DataFrame(\r\n    {\"x\": Series(datetime(2021, 1, 2), index=[1], dtype=\"category\")}\r\n)\r\n\r\nresult = pd.concat([df1, df2])\r\nexpected = DataFrame(\r\n    {\r\n        \"x\": Series(\r\n            [datetime(2021, 1, 1), datetime(2021, 1, 2)], dtype=\"category\"\r\n        )\r\n    }\r\n)\r\n\r\ntm.assert_equal(result, expected)\r\n```\r\n\r\nHowever, this test fails because the `category` dtype is not preserved after concatenation. This can be seen up to Pandas 1.2.4:\r\n\r\n```python\r\nisinstance(df1.dtypes['x'], CategoricalDtype) # True\r\nisinstance(df2.dtypes['x'], CategoricalDtype) # True\r\nisinstance(result.dtypes['x'], CategoricalDtype) # False\r\nresult.dtypes['x'] # dtype('<M8[ns]')\r\n```\r\n\r\nSo I rewrote the above test to pass by removing the `category` dtype in the expected result:\r\n\r\n```python\r\nexpected = DataFrame({\"x\": Series([datetime(2021, 1, 1), datetime(2021, 1, 2)])})\r\n```\r\n\r\nThis passed locally with `pytest` so I submitted a PR with a single commit: #41061. However, a [check](https://github.com/pandas-dev/pandas/runs/2394826098) failed on that PR, seemingly because _there_ the categorical dtype _was_ being preserved:\r\n\r\n```\r\n>       tm.assert_equal(result, expected)\r\nE       AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=\"x\") are different\r\nE       \r\nE       Attribute \"dtype\" are different\r\nE       [left]:  CategoricalDtype(categories=['2021-01-01', '2021-01-02'], ordered=False)\r\nE       [right]: datetime64[ns]\r\n```\r\n\r\nI then modified my test to mimick the original (preserving the categorical dtype), commited and pushed to the PR. But this time, [another check](https://github.com/pandas-dev/pandas/pull/41061/checks?check_run_id=2395366995) failed:\r\n\r\n```\r\nAssertionError: Attributes of DataFrame.iloc[:, 0] (column name=\"x\") are different\r\n\r\nAttribute \"dtype\" are different\r\n[left]:  datetime64[ns]\r\n[right]: CategoricalDtype(categories=['2021-01-01', '2021-01-02'], ordered=False)\r\n```\r\n\r\nBasically, the opposite error as before. This second time, as I had seen locally, the categorical dtype was _not_ being preserved after concatenation.\r\n\r\nIn the first case, a GH Action test was failing whereas in the second, it's the Azure Pipelines tests (all of them). I have no idea what's going on but it seems the tests are running different Pandas versions or, as @MarcoGorelli pointed out in Gitter, more appropriately, different dependencies."
    },
    {
      "id": 902161814,
      "user": "kurchi1205",
      "body": "Hi , \r\nI want to contribute first time to an Open Source Project . I want to contribute in this issue . I think the test cases are not yet ready for this . Can I start working on it ?"
    },
    {
      "id": 909138322,
      "user": "DeepakPareta",
      "body": "u could try this as well for this\r\npd.concat([\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0]}),\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1]})\r\n])"
    },
    {
      "id": 1076967979,
      "user": "pranavc28",
      "body": "take\r\n"
    },
    {
      "id": 1107875134,
      "user": "Jitmanew-Tyagi",
      "body": "take"
    },
    {
      "id": 1614958483,
      "user": "rsm-23",
      "body": "take"
    }
  ],
  "text_context": "# BUG: Concatenating categorical datetime columns raises a ValueError since v1.2\n\n- [X] I have checked that this issue has not already been reported.\r\n\r\n- [X] I have confirmed this bug exists on the latest version of pandas.\r\n\r\n- [X] (optional) I have confirmed this bug exists on the master branch of pandas.\r\n\r\n---\r\n\r\n#### Code Sample, a copy-pastable example\r\n\r\n```python\r\nimport pandas as pd\r\nfrom datetime import datetime\r\n\r\npd.concat([\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0], dtype='category')}),\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1], dtype='category')}),\r\n])\r\n```\r\n\r\n#### Problem description\r\n\r\nSince v1.2, concatenating two or more dataframes with at least one categorical datetime column with different categories raises this error:\r\n\r\n<details>\r\n    <summary>Traceback</summary>\r\n\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-1-36ad6bb4648d> in <module>\r\n      2 from datetime import datetime\r\n      3 \r\n----> 4 pd.concat([\r\n      5     pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0], dtype='category')}),\r\n      6     pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1], dtype='category')}),\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/reshape/concat.py in concat(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)\r\n    296     )\r\n    297 \r\n--> 298     return op.get_result()\r\n    299 \r\n    300 \r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/reshape/concat.py in get_result(self)\r\n    518                 mgrs_indexers.append((obj._mgr, indexers))\r\n    519 \r\n--> 520             new_data = concatenate_block_managers(\r\n    521                 mgrs_indexers, self.new_axes, concat_axis=self.bm_axis, copy=self.copy\r\n    522             )\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/concat.py in concatenate_block_managers(mgrs_indexers, axes, concat_axis, copy)\r\n     78                     values = values.reshape(1, len(values))\r\n     79 \r\n---> 80             b = make_block(values, placement=placement, ndim=blk.ndim)\r\n     81         else:\r\n     82             b = make_block(\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in make_block(values, placement, klass, ndim, dtype)\r\n   2730         values = DatetimeArray._simple_new(values, dtype=dtype)\r\n   2731 \r\n-> 2732     return klass(values, ndim=ndim, placement=placement)\r\n   2733 \r\n   2734 \r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in __init__(self, values, placement, ndim)\r\n    135         \"\"\"\r\n    136         # TODO(EA2D): ndim will be unnecessary with 2D EAs\r\n--> 137         self.ndim = self._check_ndim(values, ndim)\r\n    138         self.mgr_locs = placement\r\n    139         self.values = self._maybe_coerce_values(values)\r\n\r\nvenv/lib/python3.9/site-packages/pandas/core/internals/blocks.py in _check_ndim(self, values, ndim)\r\n    184 \r\n    185         if self._validate_ndim and values.ndim != ndim:\r\n--> 186             raise ValueError(\r\n    187                 \"Wrong number of dimensions. \"\r\n    188                 f\"values.ndim != ndim [{values.ndim} != {ndim}]\"\r\n\r\nValueError: Wrong number of dimensions. values.ndim != ndim [1 != 2]\r\n```\r\n</details>\r\n\r\nI have confirmed that:\r\n- it happens on `v1.2.0`, `v1.2.1`, and `v1.3.0.dev0+553.gd0cfa0303` on both Windows 10 and Linux\r\n- it doesn't happen before `v1.2` or if the categories are the same\r\n\r\n#### Expected Output\r\n\r\nA single, properly concatenated dataframe:\r\n\r\n```\r\n           x\r\n0 2021-01-01\r\n1 2021-01-02\r\n```\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\n```\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 9d598a5e1eee26df95b3910e3f2934890d062caa\r\npython           : 3.9.1.final.0\r\npython-bits      : 64\r\nOS               : Linux\r\nOS-release       : 5.10.10-zen1-1-zen\r\nVersion          : #1 ZEN SMP PREEMPT Sat, 23 Jan 2021 23:59:50 +0000\r\nmachine          : x86_64\r\nprocessor        : \r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : en_US.UTF-8\r\nLOCALE           : en_US.UTF-8\r\n\r\npandas           : 1.2.1\r\nnumpy            : 1.19.5\r\npytz             : 2020.5\r\ndateutil         : 2.8.1\r\npip              : 20.3.1\r\nsetuptools       : 52.0.0\r\nCython           : 0.29.21\r\npytest           : 6.2.1\r\nhypothesis       : None\r\nsphinx           : 3.4.3\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : 4.6.2\r\nhtml5lib         : 1.1\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : 2.11.2\r\nIPython          : 7.19.0\r\npandas_datareader: None\r\nbs4              : 4.9.3\r\nbottleneck       : None\r\nfsspec           : 0.8.5\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.3.3\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : None\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.6.0\r\nsqlalchemy       : 1.3.22\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n```\r\n\r\n</details>\r\n\n\nThanks @aiudirog for the excellent report!\r\n\r\n\r\nIf I've done git bisect correctly, \r\n```\r\ncc957d1b4fdc4f7107ba5eae66f606663399e410 is the first bad commit\r\ncommit cc957d1b4fdc4f7107ba5eae66f606663399e410\r\nAuthor: Andrew Wieteska <48889395+arw2019@users.noreply.github.com>\r\nDate:   Wed Nov 18 13:21:50 2020 -0500\r\n\r\n     PERF/ENH: add fast astyping for Categorical (#37355)\r\n```\r\n\r\ncc @arw2019\r\n\n\n> ```\r\n>      PERF/ENH: add fast astyping for Categorical (#37355)\r\n> ```\r\n\r\n#37355\n\nlooking \n\nmoving to 1.2.3\n\nThis example works on 1.2.2 and current 1.2.x. If I've bisected correctly, was fixed by #39615 (which went in 1.2.2). A test should be added, is adding a whatsnew also needed?\n\ntake\n\nI've provided the above PR adding a test for this case. However, I'm running in to some trouble with the PR passing the CI checks.\r\n\r\nThe initial version of the test I wrote was this like so:\r\n\r\n```python\r\n# GH 39443\r\ndf1 = DataFrame(\r\n    {\"x\": Series(datetime(2021, 1, 1), index=[0], dtype=\"category\")}\r\n)\r\ndf2 = DataFrame(\r\n    {\"x\": Series(datetime(2021, 1, 2), index=[1], dtype=\"category\")}\r\n)\r\n\r\nresult = pd.concat([df1, df2])\r\nexpected = DataFrame(\r\n    {\r\n        \"x\": Series(\r\n            [datetime(2021, 1, 1), datetime(2021, 1, 2)], dtype=\"category\"\r\n        )\r\n    }\r\n)\r\n\r\ntm.assert_equal(result, expected)\r\n```\r\n\r\nHowever, this test fails because the `category` dtype is not preserved after concatenation. This can be seen up to Pandas 1.2.4:\r\n\r\n```python\r\nisinstance(df1.dtypes['x'], CategoricalDtype) # True\r\nisinstance(df2.dtypes['x'], CategoricalDtype) # True\r\nisinstance(result.dtypes['x'], CategoricalDtype) # False\r\nresult.dtypes['x'] # dtype('<M8[ns]')\r\n```\r\n\r\nSo I rewrote the above test to pass by removing the `category` dtype in the expected result:\r\n\r\n```python\r\nexpected = DataFrame({\"x\": Series([datetime(2021, 1, 1), datetime(2021, 1, 2)])})\r\n```\r\n\r\nThis passed locally with `pytest` so I submitted a PR with a single commit: #41061. However, a [check](https://github.com/pandas-dev/pandas/runs/2394826098) failed on that PR, seemingly because _there_ the categorical dtype _was_ being preserved:\r\n\r\n```\r\n>       tm.assert_equal(result, expected)\r\nE       AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=\"x\") are different\r\nE       \r\nE       Attribute \"dtype\" are different\r\nE       [left]:  CategoricalDtype(categories=['2021-01-01', '2021-01-02'], ordered=False)\r\nE       [right]: datetime64[ns]\r\n```\r\n\r\nI then modified my test to mimick the original (preserving the categorical dtype), commited and pushed to the PR. But this time, [another check](https://github.com/pandas-dev/pandas/pull/41061/checks?check_run_id=2395366995) failed:\r\n\r\n```\r\nAssertionError: Attributes of DataFrame.iloc[:, 0] (column name=\"x\") are different\r\n\r\nAttribute \"dtype\" are different\r\n[left]:  datetime64[ns]\r\n[right]: CategoricalDtype(categories=['2021-01-01', '2021-01-02'], ordered=False)\r\n```\r\n\r\nBasically, the opposite error as before. This second time, as I had seen locally, the categorical dtype was _not_ being preserved after concatenation.\r\n\r\nIn the first case, a GH Action test was failing whereas in the second, it's the Azure Pipelines tests (all of them). I have no idea what's going on but it seems the tests are running different Pandas versions or, as @MarcoGorelli pointed out in Gitter, more appropriately, different dependencies.\n\nHi , \r\nI want to contribute first time to an Open Source Project . I want to contribute in this issue . I think the test cases are not yet ready for this . Can I start working on it ?\n\nu could try this as well for this\r\npd.concat([\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 1), index=[0]}),\r\n    pd.DataFrame({'x': pd.Series(datetime(2021, 1, 2), index=[1]})\r\n])\n\ntake\r\n\n\ntake\n\ntake",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/41061",
  "code_context": [
    {
      "filename": "pandas/tests/reshape/concat/test_categorical.py",
      "content": "from datetime import datetime\n\nimport numpy as np\n\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\n\nimport pandas as pd\nfrom pandas import (\n    Categorical,\n    DataFrame,\n    Series,\n)\nimport pandas._testing as tm\n\n\nclass TestCategoricalConcat:\n    def test_categorical_concat(self, sort):\n        # See GH 10177\n        df1 = DataFrame(\n            np.arange(18, dtype=\"int64\").reshape(6, 3), columns=[\"a\", \"b\", \"c\"]\n        )\n\n        df2 = DataFrame(np.arange(14, dtype=\"int64\").reshape(7, 2), columns=[\"a\", \"c\"])\n\n        cat_values = [\"one\", \"one\", \"two\", \"one\", \"two\", \"two\", \"one\"]\n        df2[\"h\"] = Series(Categorical(cat_values))\n\n        res = pd.concat((df1, df2), axis=0, ignore_index=True, sort=sort)\n        exp = DataFrame(\n            {\n                \"a\": [0, 3, 6, 9, 12, 15, 0, 2, 4, 6, 8, 10, 12],\n                \"b\": [\n                    1,\n                    4,\n                    7,\n                    10,\n                    13,\n                    16,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                ],\n                \"c\": [2, 5, 8, 11, 14, 17, 1, 3, 5, 7, 9, 11, 13],\n                \"h\": [None] * 6 + cat_values,\n            }\n        )\n        exp[\"h\"] = exp[\"h\"].astype(df2[\"h\"].dtype)\n        tm.assert_frame_equal(res, exp)\n\n    def test_categorical_concat_dtypes(self):\n\n        # GH8143\n        index = [\"cat\", \"obj\", \"num\"]\n        cat = Categorical([\"a\", \"b\", \"c\"])\n        obj = Series([\"a\", \"b\", \"c\"])\n        num = Series([1, 2, 3])\n        df = pd.concat([Series(cat), obj, num], axis=1, keys=index)\n\n        result = df.dtypes == \"object\"\n        expected = Series([False, True, False], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == \"int64\"\n        expected = Series([False, False, True], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == \"category\"\n        expected = Series([True, False, False], index=index)\n        tm.assert_series_equal(result, expected)\n\n    def test_concat_categoricalindex(self):\n        # GH 16111, categories that aren't lexsorted\n        categories = [9, 0, 1, 2, 3]\n\n        a = Series(1, index=pd.CategoricalIndex([9, 0], categories=categories))\n        b = Series(2, index=pd.CategoricalIndex([0, 1], categories=categories))\n        c = Series(3, index=pd.CategoricalIndex([1, 2], categories=categories))\n\n        result = pd.concat([a, b, c], axis=1)\n\n        exp_idx = pd.CategoricalIndex([9, 0, 1, 2], categories=categories)\n        exp = DataFrame(\n            {\n                0: [1, 1, np.nan, np.nan],\n                1: [np.nan, 2, 2, np.nan],\n                2: [np.nan, np.nan, 3, 3],\n            },\n            columns=[0, 1, 2],\n            index=exp_idx,\n        )\n        tm.assert_frame_equal(result, exp)\n\n    def test_categorical_concat_preserve(self):\n\n        # GH 8641  series concat not preserving category dtype\n        # GH 13524 can concat different categories\n        s = Series(list(\"abc\"), dtype=\"category\")\n        s2 = Series(list(\"abd\"), dtype=\"category\")\n\n        exp = Series(list(\"abcabd\"))\n        res = pd.concat([s, s2], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = Series(list(\"abcabc\"), dtype=\"category\")\n        res = pd.concat([s, s], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = Series(list(\"abcabc\"), index=[0, 1, 2, 0, 1, 2], dtype=\"category\")\n        res = pd.concat([s, s])\n        tm.assert_series_equal(res, exp)\n\n        a = Series(np.arange(6, dtype=\"int64\"))\n        b = Series(list(\"aabbca\"))\n\n        df2 = DataFrame({\"A\": a, \"B\": b.astype(CategoricalDtype(list(\"cab\")))})\n        res = pd.concat([df2, df2])\n        exp = DataFrame(\n            {\n                \"A\": pd.concat([a, a]),\n                \"B\": pd.concat([b, b]).astype(CategoricalDtype(list(\"cab\"))),\n            }\n        )\n        tm.assert_frame_equal(res, exp)\n\n    def test_categorical_index_preserver(self):\n\n        a = Series(np.arange(6, dtype=\"int64\"))\n        b = Series(list(\"aabbca\"))\n\n        df2 = DataFrame(\n            {\"A\": a, \"B\": b.astype(CategoricalDtype(list(\"cab\")))}\n        ).set_index(\"B\")\n        result = pd.concat([df2, df2])\n        expected = DataFrame(\n            {\n                \"A\": pd.concat([a, a]),\n                \"B\": pd.concat([b, b]).astype(CategoricalDtype(list(\"cab\"))),\n            }\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected)\n\n        # wrong categories -> uses concat_compat, which casts to object\n        df3 = DataFrame(\n            {\"A\": a, \"B\": Categorical(b, categories=list(\"abe\"))}\n        ).set_index(\"B\")\n        result = pd.concat([df2, df3])\n        expected = pd.concat(\n            [\n                df2.set_axis(df2.index.astype(object), axis=0),\n                df3.set_axis(df3.index.astype(object), axis=0),\n            ]\n        )\n        tm.assert_frame_equal(result, expected)\n\n    def test_concat_categorical_tz(self):\n        # GH-23816\n        a = Series(pd.date_range(\"2017-01-01\", periods=2, tz=\"US/Pacific\"))\n        b = Series([\"a\", \"b\"], dtype=\"category\")\n        result = pd.concat([a, b], ignore_index=True)\n        expected = Series(\n            [\n                pd.Timestamp(\"2017-01-01\", tz=\"US/Pacific\"),\n                pd.Timestamp(\"2017-01-02\", tz=\"US/Pacific\"),\n                \"a\",\n                \"b\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_concat_categorical_unchanged(self):\n        # GH-12007\n        # test fix for when concat on categorical and float\n        # coerces dtype categorical -> float\n        df = DataFrame(Series([\"a\", \"b\", \"c\"], dtype=\"category\", name=\"A\"))\n        ser = Series([0, 1, 2], index=[0, 1, 3], name=\"B\")\n        result = pd.concat([df, ser], axis=1)\n        expected = DataFrame(\n            {\n                \"A\": Series([\"a\", \"b\", \"c\", np.nan], dtype=\"category\"),\n                \"B\": Series([0, 1, np.nan, 2], dtype=\"float\"),\n            }\n        )\n        tm.assert_equal(result, expected)\n\n    def test_categorical_concat_gh7864(self):\n        # GH 7864\n        # make sure ordering is preserved\n        df = DataFrame({\"id\": [1, 2, 3, 4, 5, 6], \"raw_grade\": list(\"abbaae\")})\n        df[\"grade\"] = Categorical(df[\"raw_grade\"])\n        df[\"grade\"].cat.set_categories([\"e\", \"a\", \"b\"])\n\n        df1 = df[0:3]\n        df2 = df[3:]\n\n        tm.assert_index_equal(df[\"grade\"].cat.categories, df1[\"grade\"].cat.categories)\n        tm.assert_index_equal(df[\"grade\"].cat.categories, df2[\"grade\"].cat.categories)\n\n        dfx = pd.concat([df1, df2])\n        tm.assert_index_equal(df[\"grade\"].cat.categories, dfx[\"grade\"].cat.categories)\n\n        dfa = df1.append(df2)\n        tm.assert_index_equal(df[\"grade\"].cat.categories, dfa[\"grade\"].cat.categories)\n\n    def test_categorical_datetime_concat(self):\n        # GH 39443\n        df1 = DataFrame(\n            {\"x\": Series(datetime(2021, 1, 1), index=[0], dtype=\"category\")}\n        )\n        df2 = DataFrame(\n            {\"x\": Series(datetime(2021, 1, 2), index=[1], dtype=\"category\")}\n        )\n\n        result = pd.concat([df1, df2])\n        expected = DataFrame(\n            {\"x\": Series([datetime(2021, 1, 1), datetime(2021, 1, 2)])}\n        )\n\n        tm.assert_equal(result, expected)\n"
    }
  ]
}