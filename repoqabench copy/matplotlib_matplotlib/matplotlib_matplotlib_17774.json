{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "17774",
  "issue_description": "# Cannot make Latex plots when Pandas dataframe has underscore in variable name\n\n### Bug report\r\n\r\n**Bug summary**\r\n\r\nWhen plotting a Pandas data frame with variables that have underscores in the name, I cannot use the `usetex` option without getting an error. Currently, [the only solution I can find](https://stackoverflow.com/questions/49136882/make-tex-compatible-names-for-pandas-plotting-function) recommends that I rename the columns in my dataframe to escape special characters, but it seems like there must be a better approach.\r\n\r\n**Code for reproduction**\r\n```python\r\nimport pandas as pd\r\nimport matplotlib\r\nmatplotlib.rcParams['text.usetex'] = True\r\n\r\ndf = pd.DataFrame([0,1,2], columns = [\"test_column\"])\r\ndf.plot()\r\n```\r\n\r\n**Actual outcome**\r\n\r\n<!--The output produced by the above code, which may be a screenshot, console output, etc.-->\r\n\r\n```\r\n<matplotlib.axes._subplots.AxesSubplot at 0x22a107c4630>\r\n---------------------------------------------------------------------------\r\n...\r\n\r\nRuntimeError: latex was not able to process the following string:\r\nb'test_column'\r\n\r\n...\r\n\r\n! Missing $ inserted.\r\n<inserted text> \r\n                $\r\nl.14 ...size{10.000000}{12.500000}{\\sffamily test_\r\n                                                  column}\r\nNo pages of output.\r\n\r\n...\r\n```\r\n\r\n**Expected outcome**\r\nI think it would be good to create an option to easily prevent Latex from interpreting special characters when they appear in data frame column names.\r\n\r\n**Matplotlib version**\r\n<!--Please specify your platform and versions of the relevant libraries you are using:-->\r\n  * Operating system: Windows 10\r\n  * Matplotlib version: 3.1.3\r\n  * Matplotlib backend (`print(matplotlib.get_backend())`): Qt5Agg\r\n  * Python version: 3.6.8\r\n  * Jupyter version: Jupyterlab 2.1.4\r\n  * Other libraries: Pandas 1.0.1\r\n  * Installed with Anaconda\r\n\r\n",
  "issue_comments": [
    {
      "id": 650474443,
      "user": "jklymak",
      "body": "This seems more of a pandas issue to me because they are the ones assigning the column name to the label.  If you don't want this to happen, just do `ax.plot(df, label='test\\_column'), ax.legend()`.  \r\n\r\nNote we can't escape *all* instances of `_`, because we need them for math '$x_n$'.  I'll leave this open, because I guess its possible we might *always* want to escape `_` when its not enclosed in math delimiters.  But that seems like a lot of finicky parsing.  \r\n\r\nI guess similarly this will be hard for pandas to fix because they won't be able to escape underscore without knowing if usetex is True or not.  Obviously you don't want the escape if usetex is False."
    },
    {
      "id": 650812230,
      "user": "khof312",
      "body": "Thanks for the comments. I see why this might not be a priority, but I thought it's worth flagging for the long term since it looks like others on SO are having problems as well. Just a few further notes:\r\n\r\nRelabeling is possible but it can get a bit messy. For example, if plotting many columns then you are running list comprehensions over the variable names to generate the labels. In cases where the variable labels are applied to the axes of the plot (e.g. `scatter`), you need to rename the axes too.\r\n\r\nI agree that you don't want to escape all `_`, but if as you say it is possible to escape any that are not enclosed in math characters, or simply to apply a switch that escapes all (if making latex plots that don't involve underscores), that would be helpful. Even something like `parse_colnames_literally = True`.\r\n\r\nIn any case, thanks for the effort to think this through!"
    },
    {
      "id": 652681674,
      "user": "tacaswell",
      "body": "I think this as is related to `df.plot()` is better reported to pandas than to Matplotilb as we don't have any control of what `df.plot()` does internally. \r\n\r\n-----\r\n\r\nYou can however reproduce the same issue without using pandas via\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib\r\nmatplotlib.rcParams['text.usetex'] = True\r\ndf = {'a_b': range(5)[::-1], 'c': range(5)}\r\nfig, ax = plt.subplots()\r\nax.plot('c', 'a_b', data=df)\r\nax.legend()\r\nplt.show()\r\n```\r\n\r\nThe correct place to put the latex escaping code is in https://github.com/matplotlib/matplotlib/blob/c2e09e8a7be0db7226226412b86f71d28795c854/lib/matplotlib/__init__.py#L1295-L1301 which is used at https://github.com/matplotlib/matplotlib/blob/c2e09e8a7be0db7226226412b86f71d28795c854/lib/matplotlib/__init__.py#L1453-L1455 to infer a label when the incoming data gives it to us.\r\n\r\nI have not given this a milestone, but it should go in the first minor release once it is implemented,\r\n\r\nI labeled it as good first issue because all of the changes are relatively limited to one function so should not creep out into other parts of the code.\r\n\r\nI labeled this as medium difficulty as part of the task is to write a reliable latex escaping function.  We may be able to re-use our existing mathtext parser to determine if a a given string is valid.  However it is not obvious to me how write the function that makes `'a_b $c_d$'` a valid tex string.  There is some API design here, but I think it will be adding an rcParam to determine if we apply the above normalizer or not "
    },
    {
      "id": 652941050,
      "user": "timhoffm",
      "body": "> Relabeling is possible but it can get a bit messy.\r\n\r\nIn the simplest form this is just\r\n~~~\r\ndf.rename(lambda s: s.replace('_', '\\\\_'), axis='columns')\r\n~~~\r\nYou could also write a better mapping function an reuse that.\r\n\r\n-----\r\n\r\nGeneral question: Are we sure we can do smart escaping in a consistent way for all cases? If not, I suggest not to try. Instead, we could provide a hook to supply a custom mapping function, possibly via `rcParams['label_mapper']` (default: None)."
    },
    {
      "id": 652953936,
      "user": "anntzer",
      "body": "I would guess the *much* easier solution would be to use https://ctan.org/pkg/underscore (see also https://texfaq.org/FAQ-underscore).  Users can add it to text.latex.preamble, or we can add it to the default preamble if we want."
    },
    {
      "id": 653250054,
      "user": "tacaswell",
      "body": "Given that we already require a more-than-mimimal latex (to get cmsuper), do we already (practically) require this be available?"
    },
    {
      "id": 653258120,
      "user": "anntzer",
      "body": "fwiw this appears to be in texlive-latex-recommended."
    },
    {
      "id": 680274375,
      "user": "billbrod",
      "body": "Wanted to add, as a user: adding `r\"\\usepackage{underscore}\"` to my `text.latex.preamble` works very well as a drop-in solution; it also allows easy switching back and forth between using tex and not, which the other solutions I found on the internet (e.g., renaming all columns to replace `_` with `\\_`) do not."
    },
    {
      "id": 768598937,
      "user": "ikyman",
      "body": "So Seeing as this is still open, and that this is marked as a \"Good First Issue\", Could I work on this?"
    },
    {
      "id": 770391104,
      "user": "timhoffm",
      "body": "@ikyman Sure! There is a rough proposal on what to do at https://github.com/matplotlib/matplotlib/pull/18357#issuecomment-683410662."
    },
    {
      "id": 771136644,
      "user": "ikyman",
      "body": "Ok, and what parts of the repo do I fork?"
    },
    {
      "id": 771204524,
      "user": "timhoffm",
      "body": "You fork https://github.com/matplotlib/matplotlib and make a pull request against the `master` branch."
    }
  ],
  "text_context": "# Cannot make Latex plots when Pandas dataframe has underscore in variable name\n\n### Bug report\r\n\r\n**Bug summary**\r\n\r\nWhen plotting a Pandas data frame with variables that have underscores in the name, I cannot use the `usetex` option without getting an error. Currently, [the only solution I can find](https://stackoverflow.com/questions/49136882/make-tex-compatible-names-for-pandas-plotting-function) recommends that I rename the columns in my dataframe to escape special characters, but it seems like there must be a better approach.\r\n\r\n**Code for reproduction**\r\n```python\r\nimport pandas as pd\r\nimport matplotlib\r\nmatplotlib.rcParams['text.usetex'] = True\r\n\r\ndf = pd.DataFrame([0,1,2], columns = [\"test_column\"])\r\ndf.plot()\r\n```\r\n\r\n**Actual outcome**\r\n\r\n<!--The output produced by the above code, which may be a screenshot, console output, etc.-->\r\n\r\n```\r\n<matplotlib.axes._subplots.AxesSubplot at 0x22a107c4630>\r\n---------------------------------------------------------------------------\r\n...\r\n\r\nRuntimeError: latex was not able to process the following string:\r\nb'test_column'\r\n\r\n...\r\n\r\n! Missing $ inserted.\r\n<inserted text> \r\n                $\r\nl.14 ...size{10.000000}{12.500000}{\\sffamily test_\r\n                                                  column}\r\nNo pages of output.\r\n\r\n...\r\n```\r\n\r\n**Expected outcome**\r\nI think it would be good to create an option to easily prevent Latex from interpreting special characters when they appear in data frame column names.\r\n\r\n**Matplotlib version**\r\n<!--Please specify your platform and versions of the relevant libraries you are using:-->\r\n  * Operating system: Windows 10\r\n  * Matplotlib version: 3.1.3\r\n  * Matplotlib backend (`print(matplotlib.get_backend())`): Qt5Agg\r\n  * Python version: 3.6.8\r\n  * Jupyter version: Jupyterlab 2.1.4\r\n  * Other libraries: Pandas 1.0.1\r\n  * Installed with Anaconda\r\n\r\n\n\nThis seems more of a pandas issue to me because they are the ones assigning the column name to the label.  If you don't want this to happen, just do `ax.plot(df, label='test\\_column'), ax.legend()`.  \r\n\r\nNote we can't escape *all* instances of `_`, because we need them for math '$x_n$'.  I'll leave this open, because I guess its possible we might *always* want to escape `_` when its not enclosed in math delimiters.  But that seems like a lot of finicky parsing.  \r\n\r\nI guess similarly this will be hard for pandas to fix because they won't be able to escape underscore without knowing if usetex is True or not.  Obviously you don't want the escape if usetex is False.\n\nThanks for the comments. I see why this might not be a priority, but I thought it's worth flagging for the long term since it looks like others on SO are having problems as well. Just a few further notes:\r\n\r\nRelabeling is possible but it can get a bit messy. For example, if plotting many columns then you are running list comprehensions over the variable names to generate the labels. In cases where the variable labels are applied to the axes of the plot (e.g. `scatter`), you need to rename the axes too.\r\n\r\nI agree that you don't want to escape all `_`, but if as you say it is possible to escape any that are not enclosed in math characters, or simply to apply a switch that escapes all (if making latex plots that don't involve underscores), that would be helpful. Even something like `parse_colnames_literally = True`.\r\n\r\nIn any case, thanks for the effort to think this through!\n\nI think this as is related to `df.plot()` is better reported to pandas than to Matplotilb as we don't have any control of what `df.plot()` does internally. \r\n\r\n-----\r\n\r\nYou can however reproduce the same issue without using pandas via\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib\r\nmatplotlib.rcParams['text.usetex'] = True\r\ndf = {'a_b': range(5)[::-1], 'c': range(5)}\r\nfig, ax = plt.subplots()\r\nax.plot('c', 'a_b', data=df)\r\nax.legend()\r\nplt.show()\r\n```\r\n\r\nThe correct place to put the latex escaping code is in https://github.com/matplotlib/matplotlib/blob/c2e09e8a7be0db7226226412b86f71d28795c854/lib/matplotlib/__init__.py#L1295-L1301 which is used at https://github.com/matplotlib/matplotlib/blob/c2e09e8a7be0db7226226412b86f71d28795c854/lib/matplotlib/__init__.py#L1453-L1455 to infer a label when the incoming data gives it to us.\r\n\r\nI have not given this a milestone, but it should go in the first minor release once it is implemented,\r\n\r\nI labeled it as good first issue because all of the changes are relatively limited to one function so should not creep out into other parts of the code.\r\n\r\nI labeled this as medium difficulty as part of the task is to write a reliable latex escaping function.  We may be able to re-use our existing mathtext parser to determine if a a given string is valid.  However it is not obvious to me how write the function that makes `'a_b $c_d$'` a valid tex string.  There is some API design here, but I think it will be adding an rcParam to determine if we apply the above normalizer or not \n\n> Relabeling is possible but it can get a bit messy.\r\n\r\nIn the simplest form this is just\r\n~~~\r\ndf.rename(lambda s: s.replace('_', '\\\\_'), axis='columns')\r\n~~~\r\nYou could also write a better mapping function an reuse that.\r\n\r\n-----\r\n\r\nGeneral question: Are we sure we can do smart escaping in a consistent way for all cases? If not, I suggest not to try. Instead, we could provide a hook to supply a custom mapping function, possibly via `rcParams['label_mapper']` (default: None).\n\nI would guess the *much* easier solution would be to use https://ctan.org/pkg/underscore (see also https://texfaq.org/FAQ-underscore).  Users can add it to text.latex.preamble, or we can add it to the default preamble if we want.\n\nGiven that we already require a more-than-mimimal latex (to get cmsuper), do we already (practically) require this be available?\n\nfwiw this appears to be in texlive-latex-recommended.\n\nWanted to add, as a user: adding `r\"\\usepackage{underscore}\"` to my `text.latex.preamble` works very well as a drop-in solution; it also allows easy switching back and forth between using tex and not, which the other solutions I found on the internet (e.g., renaming all columns to replace `_` with `\\_`) do not.\n\nSo Seeing as this is still open, and that this is marked as a \"Good First Issue\", Could I work on this?\n\n@ikyman Sure! There is a rough proposal on what to do at https://github.com/matplotlib/matplotlib/pull/18357#issuecomment-683410662.\n\nOk, and what parts of the repo do I fork?\n\nYou fork https://github.com/matplotlib/matplotlib and make a pull request against the `master` branch.",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/18357",
  "code_context": [
    {
      "filename": "lib/matplotlib/tests/test_texmanager.py",
      "content": "import pytest\n\nfrom matplotlib import pyplot as plt, checkdep_usetex\nfrom matplotlib.texmanager import TexManager\n\n\nneeds_usetex = pytest.mark.skipif(\n    not checkdep_usetex(True),\n    reason=\"This test needs a TeX installation\")\n\n\ndef test_fontconfig_preamble():\n    \"\"\"\n    Test that the preamble is included in _fontconfig\n    \"\"\"\n    plt.rcParams['text.usetex'] = True\n\n    tm1 = TexManager()\n    font_config1 = tm1.get_font_config()\n\n    plt.rcParams['text.latex.preamble'] = '\\\\usepackage{txfonts}'\n    tm2 = TexManager()\n    font_config2 = tm2.get_font_config()\n\n    assert font_config1 != font_config2\n\n\n@needs_usetex\ndef test_usetex_missing_underscore():\n    \"\"\"\n    Test that failed TeX rendering due to an unescaped underscore has a\n    custom error message.\n    \"\"\"\n    with pytest.raises(RuntimeError,\n                       match='caused by an unescaped underscore'):\n        plt.text(0, 0, 'foo_bar', usetex=True)\n        plt.draw()  # TeX rendering is done at draw time\n"
    },
    {
      "filename": "lib/matplotlib/texmanager.py",
      "content": "r\"\"\"\nSupport for embedded TeX expressions in Matplotlib via dvipng and dvips for the\nraster and PostScript backends.  The tex and dvipng/dvips information is cached\nin ~/.matplotlib/tex.cache for reuse between sessions.\n\nRequirements:\n\n* latex\n* \\*Agg backends: dvipng>=1.6\n* PS backend: psfrag, dvips, and Ghostscript>=8.60\n\nBackends:\n\n* \\*Agg\n* PS\n* PDF\n\nFor raster output, you can get RGBA numpy arrays from TeX expressions\nas follows::\n\n  texmanager = TexManager()\n  s = ('\\TeX\\ is Number '\n       '$\\displaystyle\\sum_{n=1}^\\infty\\frac{-e^{i\\pi}}{2^n}$!')\n  Z = texmanager.get_rgba(s, fontsize=12, dpi=80, rgb=(1, 0, 0))\n\nTo enable tex rendering of all text in your matplotlib figure, set\n:rc:`text.usetex` to True.\n\"\"\"\n\nimport functools\nimport glob\nimport hashlib\nimport logging\nimport os\nfrom pathlib import Path\nimport re\nimport subprocess\nfrom tempfile import TemporaryDirectory\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import cbook, dviread, rcParams\n\n_log = logging.getLogger(__name__)\n\n\nclass TexManager:\n    \"\"\"\n    Convert strings to dvi files using TeX, caching the results to a directory.\n\n    Repeated calls to this constructor always return the same instance.\n    \"\"\"\n\n    # Caches.\n    texcache = os.path.join(mpl.get_cachedir(), 'tex.cache')\n    grey_arrayd = {}\n\n    font_family = 'serif'\n    font_families = ('serif', 'sans-serif', 'cursive', 'monospace')\n\n    font_info = {\n        'new century schoolbook': ('pnc', r'\\renewcommand{\\rmdefault}{pnc}'),\n        'bookman': ('pbk', r'\\renewcommand{\\rmdefault}{pbk}'),\n        'times': ('ptm', r'\\usepackage{mathptmx}'),\n        'palatino': ('ppl', r'\\usepackage{mathpazo}'),\n        'zapf chancery': ('pzc', r'\\usepackage{chancery}'),\n        'cursive': ('pzc', r'\\usepackage{chancery}'),\n        'charter': ('pch', r'\\usepackage{charter}'),\n        'serif': ('cmr', ''),\n        'sans-serif': ('cmss', ''),\n        'helvetica': ('phv', r'\\usepackage{helvet}'),\n        'avant garde': ('pag', r'\\usepackage{avant}'),\n        'courier': ('pcr', r'\\usepackage{courier}'),\n        # Loading the type1ec package ensures that cm-super is installed, which\n        # is necessary for unicode computer modern.  (It also allows the use of\n        # computer modern at arbitrary sizes, but that's just a side effect.)\n        'monospace': ('cmtt', r'\\usepackage{type1ec}'),\n        'computer modern roman': ('cmr', r'\\usepackage{type1ec}'),\n        'computer modern sans serif': ('cmss', r'\\usepackage{type1ec}'),\n        'computer modern typewriter': ('cmtt', r'\\usepackage{type1ec}')}\n\n    @cbook.deprecated(\"3.3\", alternative=\"matplotlib.get_cachedir()\")\n    @property\n    def cachedir(self):\n        return mpl.get_cachedir()\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def rgba_arrayd(self):\n        return {}\n\n    @functools.lru_cache()  # Always return the same instance.\n    def __new__(cls):\n        Path(cls.texcache).mkdir(parents=True, exist_ok=True)\n        return object.__new__(cls)\n\n    _fonts = {}  # Only for deprecation period.\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def serif(self):\n        return self._fonts.get(\"serif\", ('cmr', ''))\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def sans_serif(self):\n        return self._fonts.get(\"sans-serif\", ('cmss', ''))\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def cursive(self):\n        return self._fonts.get(\"cursive\", ('pzc', r'\\usepackage{chancery}'))\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def monospace(self):\n        return self._fonts.get(\"monospace\", ('cmtt', ''))\n\n    def get_font_config(self):\n        ff = rcParams['font.family']\n        if len(ff) == 1 and ff[0].lower() in self.font_families:\n            self.font_family = ff[0].lower()\n        else:\n            _log.info('font.family must be one of (%s) when text.usetex is '\n                      'True. serif will be used by default.',\n                      ', '.join(self.font_families))\n            self.font_family = 'serif'\n\n        fontconfig = [self.font_family]\n        for font_family in self.font_families:\n            for font in rcParams['font.' + font_family]:\n                if font.lower() in self.font_info:\n                    self._fonts[font_family] = self.font_info[font.lower()]\n                    _log.debug('family: %s, font: %s, info: %s',\n                               font_family, font, self.font_info[font.lower()])\n                    break\n                else:\n                    _log.debug('%s font is not compatible with usetex.', font)\n            else:\n                _log.info('No LaTeX-compatible font found for the %s font '\n                          'family in rcParams. Using default.', font_family)\n                self._fonts[font_family] = self.font_info[font_family]\n            fontconfig.append(self._fonts[font_family][0])\n        # Add a hash of the latex preamble to fontconfig so that the\n        # correct png is selected for strings rendered with same font and dpi\n        # even if the latex preamble changes within the session\n        preamble_bytes = self.get_custom_preamble().encode('utf-8')\n        fontconfig.append(hashlib.md5(preamble_bytes).hexdigest())\n\n        # The following packages and commands need to be included in the latex\n        # file's preamble:\n        cmd = [self._fonts['serif'][1],\n               self._fonts['sans-serif'][1],\n               self._fonts['monospace'][1]]\n        if self.font_family == 'cursive':\n            cmd.append(self._fonts['cursive'][1])\n        self._font_preamble = '\\n'.join([r'\\usepackage{type1cm}', *cmd])\n\n        return ''.join(fontconfig)\n\n    def get_basefile(self, tex, fontsize, dpi=None):\n        \"\"\"\n        Return a filename based on a hash of the string, fontsize, and dpi.\n        \"\"\"\n        s = ''.join([tex, self.get_font_config(), '%f' % fontsize,\n                     self.get_custom_preamble(), str(dpi or '')])\n        return os.path.join(\n            self.texcache, hashlib.md5(s.encode('utf-8')).hexdigest())\n\n    def get_font_preamble(self):\n        \"\"\"\n        Return a string containing font configuration for the tex preamble.\n        \"\"\"\n        return self._font_preamble\n\n    def get_custom_preamble(self):\n        \"\"\"Return a string containing user additions to the tex preamble.\"\"\"\n        return rcParams['text.latex.preamble']\n\n    def _get_preamble(self):\n        return \"\\n\".join([\n            r\"\\documentclass{article}\",\n            # Pass-through \\mathdefault, which is used in non-usetex mode to\n            # use the default text font but was historically suppressed in\n            # usetex mode.\n            r\"\\newcommand{\\mathdefault}[1]{#1}\",\n            self._font_preamble,\n            r\"\\usepackage[utf8]{inputenc}\",\n            r\"\\DeclareUnicodeCharacter{2212}{\\ensuremath{-}}\",\n            # geometry is loaded before the custom preamble as convert_psfrags\n            # relies on a custom preamble to change the geometry.\n            r\"\\usepackage[papersize=72in, margin=1in]{geometry}\",\n            self.get_custom_preamble(),\n            # textcomp is loaded last (if not already loaded by the custom\n            # preamble) in order not to clash with custom packages (e.g.\n            # newtxtext) which load it with different options.\n            r\"\\makeatletter\"\n            r\"\\@ifpackageloaded{textcomp}{}{\\usepackage{textcomp}}\"\n            r\"\\makeatother\",\n        ])\n\n    def make_tex(self, tex, fontsize):\n        \"\"\"\n        Generate a tex file to render the tex string at a specific font size.\n\n        Return the file name.\n        \"\"\"\n        basefile = self.get_basefile(tex, fontsize)\n        texfile = '%s.tex' % basefile\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(self.font_family,\n                                                       r'{\\rmfamily %s}')\n\n        Path(texfile).write_text(\n            r\"\"\"\n%s\n\\pagestyle{empty}\n\\begin{document}\n%% The empty hbox ensures that a page is printed even for empty inputs, except\n%% when using psfrag which gets confused by it.\n\\fontsize{%f}{%f}%%\n\\ifdefined\\psfrag\\else\\hbox{}\\fi%%\n%s\n\\end{document}\n\"\"\" % (self._get_preamble(), fontsize, fontsize * 1.25, fontcmd % tex),\n            encoding='utf-8')\n\n        return texfile\n\n    _re_vbox = re.compile(\n        r\"MatplotlibBox:\\(([\\d.]+)pt\\+([\\d.]+)pt\\)x([\\d.]+)pt\")\n\n    @cbook.deprecated(\"3.3\")\n    def make_tex_preview(self, tex, fontsize):\n        \"\"\"\n        Generate a tex file to render the tex string at a specific font size.\n\n        It uses the preview.sty to determine the dimension (width, height,\n        descent) of the output.\n\n        Return the file name.\n        \"\"\"\n        basefile = self.get_basefile(tex, fontsize)\n        texfile = '%s.tex' % basefile\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(self.font_family,\n                                                       r'{\\rmfamily %s}')\n\n        # newbox, setbox, immediate, etc. are used to find the box\n        # extent of the rendered text.\n\n        Path(texfile).write_text(\n            r\"\"\"\n%s\n\\usepackage[active,showbox,tightpage]{preview}\n\n%% we override the default showbox as it is treated as an error and makes\n%% the exit status not zero\n\\def\\showbox#1%%\n{\\immediate\\write16{MatplotlibBox:(\\the\\ht#1+\\the\\dp#1)x\\the\\wd#1}}\n\n\\begin{document}\n\\begin{preview}\n{\\fontsize{%f}{%f}%s}\n\\end{preview}\n\\end{document}\n\"\"\" % (self._get_preamble(), fontsize, fontsize * 1.25, fontcmd % tex),\n            encoding='utf-8')\n\n        return texfile\n\n    def _run_checked_subprocess(self, command, tex, *, cwd=None):\n        _log.debug(cbook._pformat_subprocess(command))\n        try:\n            report = subprocess.check_output(\n                command, cwd=cwd if cwd is not None else self.texcache,\n                stderr=subprocess.STDOUT)\n        except FileNotFoundError as exc:\n            raise RuntimeError(\n                'Failed to process string with tex because {} could not be '\n                'found'.format(command[0])) from exc\n        except subprocess.CalledProcessError as exc:\n            tex_log = exc.output.decode('utf-8')\n\n            # whether the exception was likely caused by an unescaped\n            # underscore. This cannot be easily determined unambiguously.\n            # By requiring `'$' not in tex` we err on the side of preventing\n            # false positives, because we only want to issue the customized\n            # error message if we are sure there's an unescaped underscore.\n            unescaped_underscore = (\n                '_' in tex and '$' not in tex and\n                re.match(r'.*Missing \\$ inserted.*_\\n', tex_log,\n                         flags=re.DOTALL)\n            )\n            if unescaped_underscore:\n                message = (\n                    '{prog} was not able to process the following string:\\n'\n                    '{tex!r}\\n\\n'\n                    'This is likely caused by an unescaped underscore.\\n'\n                    'You may escape the underscore or add '\n                    'r\"\\\\usepackage{{underscore}}\"\\n'\n                    'to the matplotlib rcParam text.latex.preamble'.format(\n                        prog=command[0],\n                        tex=tex.encode('unicode_escape')))\n            else:\n                message = (\n                    '{prog} was not able to process the following string:\\n'\n                    '{tex!r}\\n\\n'\n                    'Here is the full report generated by {prog}:\\n'\n                    '{exc}\\n\\n'.format(\n                        prog=command[0],\n                        tex=tex.encode('unicode_escape'),\n                        exc=tex_log))\n            raise RuntimeError(message) from exc\n        _log.debug(report)\n        return report\n\n    def make_dvi(self, tex, fontsize):\n        \"\"\"\n        Generate a dvi file containing latex's layout of tex string.\n\n        Return the file name.\n        \"\"\"\n\n        if dict.__getitem__(rcParams, 'text.latex.preview'):\n            return self.make_dvi_preview(tex, fontsize)\n\n        basefile = self.get_basefile(tex, fontsize)\n        dvifile = '%s.dvi' % basefile\n        if not os.path.exists(dvifile):\n            texfile = self.make_tex(tex, fontsize)\n            # Generate the dvi in a temporary directory to avoid race\n            # conditions e.g. if multiple processes try to process the same tex\n            # string at the same time.  Having tmpdir be a subdirectory of the\n            # final output dir ensures that they are on the same filesystem,\n            # and thus replace() works atomically.\n            with TemporaryDirectory(dir=Path(dvifile).parent) as tmpdir:\n                self._run_checked_subprocess(\n                    [\"latex\", \"-interaction=nonstopmode\", \"--halt-on-error\",\n                     texfile], tex, cwd=tmpdir)\n                (Path(tmpdir) / Path(dvifile).name).replace(dvifile)\n        return dvifile\n\n    @cbook.deprecated(\"3.3\")\n    def make_dvi_preview(self, tex, fontsize):\n        \"\"\"\n        Generate a dvi file containing latex's layout of tex string.\n\n        It calls make_tex_preview() method and store the size information\n        (width, height, descent) in a separate file.\n\n        Return the file name.\n        \"\"\"\n        basefile = self.get_basefile(tex, fontsize)\n        dvifile = '%s.dvi' % basefile\n        baselinefile = '%s.baseline' % basefile\n\n        if not os.path.exists(dvifile) or not os.path.exists(baselinefile):\n            texfile = self.make_tex_preview(tex, fontsize)\n            report = self._run_checked_subprocess(\n                [\"latex\", \"-interaction=nonstopmode\", \"--halt-on-error\",\n                 texfile], tex)\n\n            # find the box extent information in the latex output\n            # file and store them in \".baseline\" file\n            m = TexManager._re_vbox.search(report.decode(\"utf-8\"))\n            with open(basefile + '.baseline', \"w\") as fh:\n                fh.write(\" \".join(m.groups()))\n\n            for fname in glob.glob(basefile + '*'):\n                if not fname.endswith(('dvi', 'tex', 'baseline')):\n                    try:\n                        os.remove(fname)\n                    except OSError:\n                        pass\n\n        return dvifile\n\n    def make_png(self, tex, fontsize, dpi):\n        \"\"\"\n        Generate a png file containing latex's rendering of tex string.\n\n        Return the file name.\n        \"\"\"\n        basefile = self.get_basefile(tex, fontsize, dpi)\n        pngfile = '%s.png' % basefile\n        # see get_rgba for a discussion of the background\n        if not os.path.exists(pngfile):\n            dvifile = self.make_dvi(tex, fontsize)\n            cmd = [\"dvipng\", \"-bg\", \"Transparent\", \"-D\", str(dpi),\n                   \"-T\", \"tight\", \"-o\", pngfile, dvifile]\n            # When testing, disable FreeType rendering for reproducibility; but\n            # dvipng 1.16 has a bug (fixed in f3ff241) that breaks --freetype0\n            # mode, so for it we keep FreeType enabled; the image will be\n            # slightly off.\n            if (getattr(mpl, \"_called_from_pytest\", False)\n                    and mpl._get_executable_info(\"dvipng\").version != \"1.16\"):\n                cmd.insert(1, \"--freetype0\")\n            self._run_checked_subprocess(cmd, tex)\n        return pngfile\n\n    def get_grey(self, tex, fontsize=None, dpi=None):\n        \"\"\"Return the alpha channel.\"\"\"\n        if not fontsize:\n            fontsize = rcParams['font.size']\n        if not dpi:\n            dpi = rcParams['savefig.dpi']\n        key = tex, self.get_font_config(), fontsize, dpi\n        alpha = self.grey_arrayd.get(key)\n        if alpha is None:\n            pngfile = self.make_png(tex, fontsize, dpi)\n            rgba = mpl.image.imread(os.path.join(self.texcache, pngfile))\n            self.grey_arrayd[key] = alpha = rgba[:, :, -1]\n        return alpha\n\n    def get_rgba(self, tex, fontsize=None, dpi=None, rgb=(0, 0, 0)):\n        \"\"\"Return latex's rendering of the tex string as an rgba array.\"\"\"\n        alpha = self.get_grey(tex, fontsize, dpi)\n        rgba = np.empty((*alpha.shape, 4))\n        rgba[..., :3] = mpl.colors.to_rgb(rgb)\n        rgba[..., -1] = alpha\n        return rgba\n\n    def get_text_width_height_descent(self, tex, fontsize, renderer=None):\n        \"\"\"Return width, height and descent of the text.\"\"\"\n        if tex.strip() == '':\n            return 0, 0, 0\n\n        dpi_fraction = renderer.points_to_pixels(1.) if renderer else 1\n\n        if dict.__getitem__(rcParams, 'text.latex.preview'):\n            # use preview.sty\n            basefile = self.get_basefile(tex, fontsize)\n            baselinefile = '%s.baseline' % basefile\n\n            if not os.path.exists(baselinefile):\n                dvifile = self.make_dvi_preview(tex, fontsize)\n\n            with open(baselinefile) as fh:\n                l = fh.read().split()\n            height, depth, width = [float(l1) * dpi_fraction for l1 in l]\n            return width, height + depth, depth\n\n        else:\n            # use dviread.\n            dvifile = self.make_dvi(tex, fontsize)\n            with dviread.Dvi(dvifile, 72 * dpi_fraction) as dvi:\n                page, = dvi\n            # A total height (including the descent) needs to be returned.\n            return page.width, page.height + page.descent, page.descent\n"
    }
  ]
}