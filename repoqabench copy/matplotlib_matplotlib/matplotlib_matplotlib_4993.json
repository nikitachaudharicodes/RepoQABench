{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "4993",
  "issue_description": "# Version ~/.cache/matplotlib\n\nWhen upgrading matplotlib, it seems that sometimes the cache needs to be deleted. Otherwise, it becomes unusable and has to be regenerated on every import of matplotlib, which is painfully slow. So, it seems that the cache should be versioned.\n\nSee #3794. See also http://stackoverflow.com/questions/26421364/extremely-slow-import-of-matplotlib-afm\n",
  "issue_comments": [
    {
      "id": 135102632,
      "user": "mdboom",
      "body": "I feel we still haven't got to the bottom of the root cause.  If the cache is corrupted (or from an earlier version or matplotlib or Python), it is rebuilt and then saved to disk, with the next import using the rebuilt \"fixed\" cache.  (At least that's how it's supposed to work, and works in my experimentation when upgrading from 1.3.1 to 1.4.2 as in #3794).  So somehow the rebuilt cache is not getting written back out to disk properly, perhaps?  I don't think the cache needs to be versioned to accomplish this -- it's already effectively versioned by being a pickle -- we just need to make sure that rebuilding doesn't happen repeatedly.\n"
    },
    {
      "id": 135176289,
      "user": "tacaswell",
      "body": "The font caches is versioned, https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/font_manager.py#L1017  The question is more about why the `_rebuild` is not writing back out to disk on some systems.\n"
    },
    {
      "id": 135177868,
      "user": "WeatherGod",
      "body": "Possibly also related is that one report about slow imports showing the\ncache getting loaded, but then still going ahead and querying the system\nfor all of its fonts. I can't find the issue link at the moment, but it was\nfairly recent (in the past couple of months) and also raised the question\nabout the font cache being a pickle and it potentially being a security\nissue.\n\nOn Wed, Aug 26, 2015 at 5:31 PM, Thomas A Caswell notifications@github.com\nwrote:\n\n> The font caches is versioned,\n> https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/font_manager.py#L1017\n> The question is more about why the _rebuild is not writing back out to\n> disk on some systems.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-135176289\n> .\n"
    },
    {
      "id": 135191743,
      "user": "mspacek",
      "body": "@WeatherGod maybe you're thinking of #4756?\n"
    },
    {
      "id": 135232094,
      "user": "WeatherGod",
      "body": "yes, that is the one.\n\nOn Wed, Aug 26, 2015 at 6:11 PM, Martin Spacek notifications@github.com\nwrote:\n\n> @WeatherGod https://github.com/WeatherGod maybe you're thinking of #4756\n> https://github.com/matplotlib/matplotlib/issues/4756?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-135191743\n> .\n"
    },
    {
      "id": 137402108,
      "user": "jkseppan",
      "body": "Some thoughts:\n- if you have a [`TRAVIS` environment variable](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1388), the cache is always rebuilt\n- if your [`$MPLCONFIGDIR` is not writable](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L596) the font cache will be rebuilt and written to a temporary directory, which will not be reused later; similarly for [`$HOME/.matplotlib` or `$HOME/.cache/matplotlib`](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L609) if `$MPLCONFIGDIR` is unset\n- if a font file is found for which [`os.path.isfile` is false](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1305) (symlinked fonts?) the cache is rebuilt\n"
    },
    {
      "id": 137440058,
      "user": "WeatherGod",
      "body": "With regards to possibly symlinked fonts, maybe it makes sense to apply\n`os.path.abspath()` to font filenames that are discovered as the cache is\nbuilt?\n\nOn Thu, Sep 3, 2015 at 6:22 AM, Jouni K. Seppänen notifications@github.com\nwrote:\n\n> Some thoughts:\n> - if you have a TRAVIS environment variable\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1388,\n>   the cache is always rebuilt\n> - if your $MPLCONFIGDIR is not writable\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L596\n>   the font cache will be rebuilt and written to a temporary directory, which\n>   will not be reused later; similarly for $HOME/.matplotlib or\n>   $HOME/.cache/matplotlib\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L609\n>   if $MPLCONFIGDIR is unset\n> - if a font file is found for which os.path.isfile is false\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1305\n>   (symlinked fonts?) the cache is rebuilt\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-137402108\n> .\n"
    },
    {
      "id": 137477801,
      "user": "mdboom",
      "body": "The symlinked font thing may be the issue (and would explain why I couldn't reproduce).  I'll create a symlinked font on my system and see if that triggers this bug.  If that's what it is, it should be easy to resolve.\n"
    },
    {
      "id": 224517607,
      "user": "anntzer",
      "body": "Currently, switching between importing mpl 1.5 and mpl 2.0 repeatedly triggers a rebuilding of the font cache (as they keep overwriting each other).  Of course that was probably already the case \"in theory\" before, but this is probably going to happen more often in practice now that conda is widespread.  Plus, some git archeology suggests that all the changes to the font cache version so far occured between the release of 0.99 and 1.0 :-)\n\nSo perhaps matplotlib should keep its cache in ~/.cache/matplotlib/$cacheversion/... (or similar) instead?\n\nEDIT: I'm going to make this a 2.0 milestone, but I'm open to arguments that this is not such a big deal.  Another (simpler?) option would be to store the cache in a subfolder of the venv/conda env if one is active, so that at least the issue only appears when updating matplotlib in a given environment, not when switching from a mpl=1.5 env to a mpl=2.0 env.\n"
    },
    {
      "id": 264077010,
      "user": "NelleV",
      "body": "This is not release critical, so I am bumping it to 2.1 (thought I like @anntzer's idea to have a folder per version)."
    },
    {
      "id": 269051710,
      "user": "kadrlica",
      "body": "If the symlinked font thing is really an issue, I'd bump fixing it. I often set my `$MPLCONFIG` variable to point to a symlinked path and have been dealing with repeated warning about fc-list (#5836) for months now. I never guessed it could be related to symlinking until I saw this thread."
    },
    {
      "id": 269059053,
      "user": "tacaswell",
      "body": "The versioning of the cache should be straight forward:\r\n\r\n - find where the font cache path is created (around L1423 in font_manager.py)\r\n - add the version as part of the path\r\n\r\nStill not sure I understand the relation to the symlinks here.  @kadrlica Do you get the warning at import or the first time you draw some text?  On my system, symlinks report as files:\r\n\r\n```bash\r\ndd35) ✔ ~ \r\n19:06 $ touch /tmp/foo\r\n(dd35) ✔ ~ \r\n19:06 $ cd /tmp/\r\n(dd35) ✔ /tmp \r\n19:06 $ ln -s foo foo2\r\n(dd35) ✔ /tmp \r\n19:06 $ ipython\r\nPython 3.5.2 |Continuum Analytics, Inc.| (default, Jul  2 2016, 17:53:06) \r\nType \"copyright\", \"credits\" or \"license\" for more information.\r\n\r\nIPython 5.1.0 -- An enhanced Interactive Python.\r\n?         -> Introduction and overview of IPython's features.\r\n%quickref -> Quick reference.\r\nhelp      -> Python's own help system.\r\nobject?   -> Details about 'object', use 'object??' for extra details.\r\n\r\nIn [1]: res = '/tmp/foo2'\r\n\r\nIn [2]: import os.path\r\n\r\nIn [3]: os.path.isfile(res)\r\nOut[3]: True\r\n\r\nIn [4]: os.path.isfile('/tmp/foo')\r\nOut[4]: True\r\n```\r\n"
    },
    {
      "id": 269099778,
      "user": "kadrlica",
      "body": "Ok, I think that the symlink was a red herring (though I was surprised that MacOS Sierra has `\\tmp` point to `\\private\\tmp`). \r\n\r\nI think I was actually getting caught by the same font cache versioning issue. I was switching between `matplotlib v1.3.1` and `matplotlib v1.5.3`, which have different behaviors when overwriting the font cache. I think `v1.3.1` overwrites the font cache generated by `v1.5.3`, while `v1.5.3` creates a temporary font cache each time it finds font cache created by `v1.3.1`. Thus, when I used `v1.3.1` it was \"corrupting\" the font cache and when I switched to `v1.5.3` it was stuck making temporary font caches. The comments from @mdboom and @anntzer make me think that this is not the expected behavior for `v1.5.3` (they suggest that the font cache should be rebuilt *and* written to disk).\r\n\r\nHere's an example of this behavior\r\n```\r\n> export MPLCONFIGDIR=/tmp\r\n> export MATPLOTLIBRC=/tmp\r\n> rm -rf $MPLCONFIGDIR/fontList.cache $MPLCONFIGDIR/tex.cache\r\n\r\n> # Use matplotlib v1.5.3\r\n> source activate mpl_1.5.3\r\n> # This import builds the fontList for v1.5.3\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n> # And this one works as expected\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n\r\n> # Switch to matplotlib v1.3.1\r\n> source activate mpl_1.3.1\r\n> # This one builds a fontList for v1.3.1\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.3.1\r\n> # And this one works as expected\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.3.1\r\n\r\n> # Use matplotlib v1.5.3\r\n> source activate mpl_1.5.3\r\n> # This finds the fontList for v1.3.1 and creates a tmp version\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n> # ... and again\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n```\r\n"
    },
    {
      "id": 272612853,
      "user": "LevN0",
      "body": "Playing around with this, here is what I've found (if this has not already been discovered):\r\n\r\nWhen going from an older version of MPL to 1.5.3, pickle_load itself causes ``FontManager.__init__`` to be called. At least according to the debugger, it goes,\r\n\r\n-> `data = pickle.load(fh)` \r\n-> ``FontManager.__init__ called`` \r\n\r\nCalling ``FontManager.__init__`` eventually calls the method that rebuilds the cache (since init is intended to do that). However this never calls `_rebuild` to write this to file since no exception is generated because the font manager is successfully loaded via pickle.\r\n\r\nWhen using a cache generated originally by 1.5.3, pickle_load does not call init. Therefore everything works as expected.\r\n\r\nI think this explains why the cache is not re-written to file (it is because _rebuild is never called), while also explaining why it searches for cache again even though it can find it (sort of.. it does not explain why pickle calls __init__ here).  \r\n\r\nSince pickle is no longer used, a part of this problem should not occur in the future. In terms of versioning, there is already a check for font_manager version that rebuilds on change. If it turns out the reason this issue occurred is that the font_manager was modified in some way that caused pickle.load to call __init__ then 2.x does not have this specific issue: unlike MPL 1.3 -> 1.5, which retained font_manager version, 2.0 changes it, thus causing _rebuild to run. In terms of versioning for other reasons (e.g. conda justification/users constantly switching between MPL versions thus causing constant rebuilding), none of this reply is very relevant. "
    },
    {
      "id": 362243826,
      "user": "tgmiller5",
      "body": "is it possible to include me as a participant?"
    },
    {
      "id": 404444443,
      "user": "anntzer",
      "body": "Closed by https://github.com/matplotlib/matplotlib/pull/10245 (see https://github.com/matplotlib/matplotlib/pull/10245#issuecomment-403321167)."
    }
  ],
  "text_context": "# Version ~/.cache/matplotlib\n\nWhen upgrading matplotlib, it seems that sometimes the cache needs to be deleted. Otherwise, it becomes unusable and has to be regenerated on every import of matplotlib, which is painfully slow. So, it seems that the cache should be versioned.\n\nSee #3794. See also http://stackoverflow.com/questions/26421364/extremely-slow-import-of-matplotlib-afm\n\n\nI feel we still haven't got to the bottom of the root cause.  If the cache is corrupted (or from an earlier version or matplotlib or Python), it is rebuilt and then saved to disk, with the next import using the rebuilt \"fixed\" cache.  (At least that's how it's supposed to work, and works in my experimentation when upgrading from 1.3.1 to 1.4.2 as in #3794).  So somehow the rebuilt cache is not getting written back out to disk properly, perhaps?  I don't think the cache needs to be versioned to accomplish this -- it's already effectively versioned by being a pickle -- we just need to make sure that rebuilding doesn't happen repeatedly.\n\n\nThe font caches is versioned, https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/font_manager.py#L1017  The question is more about why the `_rebuild` is not writing back out to disk on some systems.\n\n\nPossibly also related is that one report about slow imports showing the\ncache getting loaded, but then still going ahead and querying the system\nfor all of its fonts. I can't find the issue link at the moment, but it was\nfairly recent (in the past couple of months) and also raised the question\nabout the font cache being a pickle and it potentially being a security\nissue.\n\nOn Wed, Aug 26, 2015 at 5:31 PM, Thomas A Caswell notifications@github.com\nwrote:\n\n> The font caches is versioned,\n> https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/font_manager.py#L1017\n> The question is more about why the _rebuild is not writing back out to\n> disk on some systems.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-135176289\n> .\n\n\n@WeatherGod maybe you're thinking of #4756?\n\n\nyes, that is the one.\n\nOn Wed, Aug 26, 2015 at 6:11 PM, Martin Spacek notifications@github.com\nwrote:\n\n> @WeatherGod https://github.com/WeatherGod maybe you're thinking of #4756\n> https://github.com/matplotlib/matplotlib/issues/4756?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-135191743\n> .\n\n\nSome thoughts:\n- if you have a [`TRAVIS` environment variable](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1388), the cache is always rebuilt\n- if your [`$MPLCONFIGDIR` is not writable](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L596) the font cache will be rebuilt and written to a temporary directory, which will not be reused later; similarly for [`$HOME/.matplotlib` or `$HOME/.cache/matplotlib`](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L609) if `$MPLCONFIGDIR` is unset\n- if a font file is found for which [`os.path.isfile` is false](https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1305) (symlinked fonts?) the cache is rebuilt\n\n\nWith regards to possibly symlinked fonts, maybe it makes sense to apply\n`os.path.abspath()` to font filenames that are discovered as the cache is\nbuilt?\n\nOn Thu, Sep 3, 2015 at 6:22 AM, Jouni K. Seppänen notifications@github.com\nwrote:\n\n> Some thoughts:\n> - if you have a TRAVIS environment variable\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1388,\n>   the cache is always rebuilt\n> - if your $MPLCONFIGDIR is not writable\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L596\n>   the font cache will be rebuilt and written to a temporary directory, which\n>   will not be reused later; similarly for $HOME/.matplotlib or\n>   $HOME/.cache/matplotlib\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/__init__.py#L609\n>   if $MPLCONFIGDIR is unset\n> - if a font file is found for which os.path.isfile is false\n>   https://github.com/matplotlib/matplotlib/blob/673feb09d3fa08e46615a46139227f2f4427688e/lib/matplotlib/font_manager.py#L1305\n>   (symlinked fonts?) the cache is rebuilt\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/matplotlib/matplotlib/issues/4993#issuecomment-137402108\n> .\n\n\nThe symlinked font thing may be the issue (and would explain why I couldn't reproduce).  I'll create a symlinked font on my system and see if that triggers this bug.  If that's what it is, it should be easy to resolve.\n\n\nCurrently, switching between importing mpl 1.5 and mpl 2.0 repeatedly triggers a rebuilding of the font cache (as they keep overwriting each other).  Of course that was probably already the case \"in theory\" before, but this is probably going to happen more often in practice now that conda is widespread.  Plus, some git archeology suggests that all the changes to the font cache version so far occured between the release of 0.99 and 1.0 :-)\n\nSo perhaps matplotlib should keep its cache in ~/.cache/matplotlib/$cacheversion/... (or similar) instead?\n\nEDIT: I'm going to make this a 2.0 milestone, but I'm open to arguments that this is not such a big deal.  Another (simpler?) option would be to store the cache in a subfolder of the venv/conda env if one is active, so that at least the issue only appears when updating matplotlib in a given environment, not when switching from a mpl=1.5 env to a mpl=2.0 env.\n\n\nThis is not release critical, so I am bumping it to 2.1 (thought I like @anntzer's idea to have a folder per version).\n\nIf the symlinked font thing is really an issue, I'd bump fixing it. I often set my `$MPLCONFIG` variable to point to a symlinked path and have been dealing with repeated warning about fc-list (#5836) for months now. I never guessed it could be related to symlinking until I saw this thread.\n\nThe versioning of the cache should be straight forward:\r\n\r\n - find where the font cache path is created (around L1423 in font_manager.py)\r\n - add the version as part of the path\r\n\r\nStill not sure I understand the relation to the symlinks here.  @kadrlica Do you get the warning at import or the first time you draw some text?  On my system, symlinks report as files:\r\n\r\n```bash\r\ndd35) ✔ ~ \r\n19:06 $ touch /tmp/foo\r\n(dd35) ✔ ~ \r\n19:06 $ cd /tmp/\r\n(dd35) ✔ /tmp \r\n19:06 $ ln -s foo foo2\r\n(dd35) ✔ /tmp \r\n19:06 $ ipython\r\nPython 3.5.2 |Continuum Analytics, Inc.| (default, Jul  2 2016, 17:53:06) \r\nType \"copyright\", \"credits\" or \"license\" for more information.\r\n\r\nIPython 5.1.0 -- An enhanced Interactive Python.\r\n?         -> Introduction and overview of IPython's features.\r\n%quickref -> Quick reference.\r\nhelp      -> Python's own help system.\r\nobject?   -> Details about 'object', use 'object??' for extra details.\r\n\r\nIn [1]: res = '/tmp/foo2'\r\n\r\nIn [2]: import os.path\r\n\r\nIn [3]: os.path.isfile(res)\r\nOut[3]: True\r\n\r\nIn [4]: os.path.isfile('/tmp/foo')\r\nOut[4]: True\r\n```\r\n\n\nOk, I think that the symlink was a red herring (though I was surprised that MacOS Sierra has `\\tmp` point to `\\private\\tmp`). \r\n\r\nI think I was actually getting caught by the same font cache versioning issue. I was switching between `matplotlib v1.3.1` and `matplotlib v1.5.3`, which have different behaviors when overwriting the font cache. I think `v1.3.1` overwrites the font cache generated by `v1.5.3`, while `v1.5.3` creates a temporary font cache each time it finds font cache created by `v1.3.1`. Thus, when I used `v1.3.1` it was \"corrupting\" the font cache and when I switched to `v1.5.3` it was stuck making temporary font caches. The comments from @mdboom and @anntzer make me think that this is not the expected behavior for `v1.5.3` (they suggest that the font cache should be rebuilt *and* written to disk).\r\n\r\nHere's an example of this behavior\r\n```\r\n> export MPLCONFIGDIR=/tmp\r\n> export MATPLOTLIBRC=/tmp\r\n> rm -rf $MPLCONFIGDIR/fontList.cache $MPLCONFIGDIR/tex.cache\r\n\r\n> # Use matplotlib v1.5.3\r\n> source activate mpl_1.5.3\r\n> # This import builds the fontList for v1.5.3\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n> # And this one works as expected\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n\r\n> # Switch to matplotlib v1.3.1\r\n> source activate mpl_1.3.1\r\n> # This one builds a fontList for v1.3.1\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.3.1\r\n> # And this one works as expected\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.3.1\r\n\r\n> # Use matplotlib v1.5.3\r\n> source activate mpl_1.5.3\r\n> # This finds the fontList for v1.3.1 and creates a tmp version\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n> # ... and again\r\n> python -c \"import matplotlib; print matplotlib.__version__; import pylab\"\r\n1.5.3\r\n/usr/local/anaconda2/envs/mpl_1.5.3/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\r\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\r\n```\r\n\n\nPlaying around with this, here is what I've found (if this has not already been discovered):\r\n\r\nWhen going from an older version of MPL to 1.5.3, pickle_load itself causes ``FontManager.__init__`` to be called. At least according to the debugger, it goes,\r\n\r\n-> `data = pickle.load(fh)` \r\n-> ``FontManager.__init__ called`` \r\n\r\nCalling ``FontManager.__init__`` eventually calls the method that rebuilds the cache (since init is intended to do that). However this never calls `_rebuild` to write this to file since no exception is generated because the font manager is successfully loaded via pickle.\r\n\r\nWhen using a cache generated originally by 1.5.3, pickle_load does not call init. Therefore everything works as expected.\r\n\r\nI think this explains why the cache is not re-written to file (it is because _rebuild is never called), while also explaining why it searches for cache again even though it can find it (sort of.. it does not explain why pickle calls __init__ here).  \r\n\r\nSince pickle is no longer used, a part of this problem should not occur in the future. In terms of versioning, there is already a check for font_manager version that rebuilds on change. If it turns out the reason this issue occurred is that the font_manager was modified in some way that caused pickle.load to call __init__ then 2.x does not have this specific issue: unlike MPL 1.3 -> 1.5, which retained font_manager version, 2.0 changes it, thus causing _rebuild to run. In terms of versioning for other reasons (e.g. conda justification/users constantly switching between MPL versions thus causing constant rebuilding), none of this reply is very relevant. \n\nis it possible to include me as a participant?\n\nClosed by https://github.com/matplotlib/matplotlib/pull/10245 (see https://github.com/matplotlib/matplotlib/pull/10245#issuecomment-403321167).",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/10245",
  "code_context": [
    {
      "filename": "lib/matplotlib/font_manager.py",
      "content": "\"\"\"\nA module for finding, managing, and using fonts across platforms.\n\nThis module provides a single :class:`FontManager` instance that can\nbe shared across backends and platforms.  The :func:`findfont`\nfunction returns the best TrueType (TTF) font file in the local or\nsystem font path that matches the specified :class:`FontProperties`\ninstance.  The :class:`FontManager` also handles Adobe Font Metrics\n(AFM) font files for use by the PostScript backend.\n\nThe design is based on the `W3C Cascading Style Sheet, Level 1 (CSS1)\nfont specification <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_.\nFuture versions may implement the Level 2 or 2.1 specifications.\n\nExperimental support is included for using `fontconfig` on Unix\nvariant platforms (Linux, OS X, Solaris).  To enable it, set the\nconstant ``USE_FONTCONFIG`` in this file to ``True``.  Fontconfig has\nthe advantage that it is the standard way to look up fonts on X11\nplatforms, so if a font is installed, it is much more likely to be\nfound.\n\"\"\"\n\n# KNOWN ISSUES\n#\n#   - documentation\n#   - font variant is untested\n#   - font stretch is incomplete\n#   - font size is incomplete\n#   - default font algorithm needs improvement and testing\n#   - setWeights function needs improvement\n#   - 'light' is an invalid weight value, remove it.\n#   - update_fonts not implemented\n\nfrom functools import lru_cache\nimport json\nimport logging\nimport os\nfrom pathlib import Path\nimport subprocess\nimport sys\ntry:\n    from threading import Timer\nexcept ImportError:\n    from dummy_threading import Timer\nimport warnings\n\nimport matplotlib as mpl\nfrom matplotlib import afm, cbook, ft2font, rcParams, get_cachedir\nfrom matplotlib.fontconfig_pattern import (\n    parse_fontconfig_pattern, generate_fontconfig_pattern)\n\n_log = logging.getLogger(__name__)\n\nUSE_FONTCONFIG = False\n\nfont_scalings = {\n    'xx-small' : 0.579,\n    'x-small'  : 0.694,\n    'small'    : 0.833,\n    'medium'   : 1.0,\n    'large'    : 1.200,\n    'x-large'  : 1.440,\n    'xx-large' : 1.728,\n    'larger'   : 1.2,\n    'smaller'  : 0.833,\n    None       : 1.0}\n\nstretch_dict = {\n    'ultra-condensed' : 100,\n    'extra-condensed' : 200,\n    'condensed'       : 300,\n    'semi-condensed'  : 400,\n    'normal'          : 500,\n    'semi-expanded'   : 600,\n    'expanded'        : 700,\n    'extra-expanded'  : 800,\n    'ultra-expanded'  : 900}\n\nweight_dict = {\n    'ultralight' : 100,\n    'light'      : 200,\n    'normal'     : 400,\n    'regular'    : 400,\n    'book'       : 400,\n    'medium'     : 500,\n    'roman'      : 500,\n    'semibold'   : 600,\n    'demibold'   : 600,\n    'demi'       : 600,\n    'bold'       : 700,\n    'heavy'      : 800,\n    'extra bold' : 800,\n    'black'      : 900}\n\nfont_family_aliases = {\n    'serif',\n    'sans-serif',\n    'sans serif',\n    'cursive',\n    'fantasy',\n    'monospace',\n    'sans'}\n\n#  OS Font paths\nMSFolders = \\\n    r'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders'\n\n\nMSFontDirectories = [\n    r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts',\n    r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts']\n\n\nX11FontDirectories = [\n    # an old standard installation point\n    \"/usr/X11R6/lib/X11/fonts/TTF/\",\n    \"/usr/X11/lib/X11/fonts\",\n    # here is the new standard location for fonts\n    \"/usr/share/fonts/\",\n    # documented as a good place to install new fonts\n    \"/usr/local/share/fonts/\",\n    # common application, not really useful\n    \"/usr/lib/openoffice/share/fonts/truetype/\",\n    ]\n\nOSXFontDirectories = [\n    \"/Library/Fonts/\",\n    \"/Network/Library/Fonts/\",\n    \"/System/Library/Fonts/\",\n    # fonts installed via MacPorts\n    \"/opt/local/share/fonts\"\n    \"\"\n]\n\nif not USE_FONTCONFIG and sys.platform != 'win32':\n    OSXFontDirectories.append(str(Path.home() / \"Library/Fonts\"))\n    X11FontDirectories.append(str(Path.home() / \".fonts\"))\n\n\ndef get_fontext_synonyms(fontext):\n    \"\"\"\n    Return a list of file extensions extensions that are synonyms for\n    the given file extension *fileext*.\n    \"\"\"\n    return {'ttf': ('ttf', 'otf'),\n            'otf': ('ttf', 'otf'),\n            'afm': ('afm',)}[fontext]\n\n\ndef list_fonts(directory, extensions):\n    \"\"\"\n    Return a list of all fonts matching any of the extensions, found\n    recursively under the directory.\n    \"\"\"\n    extensions = [\".\" + ext for ext in extensions]\n    return [str(path)\n            for path in filter(Path.is_file, Path(directory).glob(\"**/*.*\"))\n            if path.suffix in extensions]\n\n\ndef win32FontDirectory():\n    r\"\"\"\n    Return the user-specified font directory for Win32.  This is\n    looked up from the registry key::\n\n      \\\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Fonts\n\n    If the key is not found, $WINDIR/Fonts will be returned.\n    \"\"\"\n    import winreg\n    try:\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, MSFolders) as user:\n            return winreg.QueryValueEx(user, 'Fonts')[0]\n    except OSError:\n        return os.path.join(os.environ['WINDIR'], 'Fonts')\n\n\ndef win32InstalledFonts(directory=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font directory, or use the\n    system directories if none given.  A list of TrueType font\n    filenames are returned by default, or AFM fonts if *fontext* ==\n    'afm'.\n    \"\"\"\n\n    import winreg\n\n    if directory is None:\n        directory = win32FontDirectory()\n\n    fontext = get_fontext_synonyms(fontext)\n\n    items = set()\n    for fontdir in MSFontDirectories:\n        try:\n            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, fontdir) as local:\n                for j in range(winreg.QueryInfoKey(local)[1]):\n                    key, direc, tp = winreg.EnumValue(local, j)\n                    if not isinstance(direc, str):\n                        continue\n                    # Work around for https://bugs.python.org/issue25778, which\n                    # is fixed in Py>=3.6.1.\n                    direc = direc.split(\"\\0\", 1)[0]\n                    path = Path(directory, direc).resolve()\n                    if path.suffix.lower() in fontext:\n                        items.add(str(path))\n                return list(items)\n        except (OSError, MemoryError):\n            continue\n    return None\n\n\ndef OSXInstalledFonts(directories=None, fontext='ttf'):\n    \"\"\"Get list of font files on OS X.\"\"\"\n    if directories is None:\n        directories = OSXFontDirectories\n    return [path\n            for directory in directories\n            for ext in get_fontext_synonyms(fontext)\n            for path in list_fonts(directory, ext)]\n\n\n@lru_cache()\ndef _call_fc_list():\n    \"\"\"Cache and list the font filenames known to `fc-list`.\n    \"\"\"\n    # Delay the warning by 5s.\n    timer = Timer(5, lambda: warnings.warn(\n        'Matplotlib is building the font cache using fc-list. '\n        'This may take a moment.'))\n    timer.start()\n    try:\n        out = subprocess.check_output(['fc-list', '--format=%{file}\\\\n'])\n    except (OSError, subprocess.CalledProcessError):\n        return []\n    finally:\n        timer.cancel()\n    return [os.fsdecode(fname) for fname in out.split(b'\\n')]\n\n\ndef get_fontconfig_fonts(fontext='ttf'):\n    \"\"\"List the font filenames known to `fc-list` having the given extension.\n    \"\"\"\n    fontext = get_fontext_synonyms(fontext)\n    return [fname for fname in _call_fc_list()\n            if Path(fname).suffix[1:] in fontext]\n\n\ndef findSystemFonts(fontpaths=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font paths.  If no paths are\n    given, will use a standard set of system paths, as well as the\n    list of fonts tracked by fontconfig if fontconfig is installed and\n    available.  A list of TrueType fonts are returned by default with\n    AFM fonts as an option.\n    \"\"\"\n    fontfiles = set()\n    fontexts = get_fontext_synonyms(fontext)\n\n    if fontpaths is None:\n        if sys.platform == 'win32':\n            fontpaths = [win32FontDirectory()]\n            # now get all installed fonts directly...\n            fontfiles.update(win32InstalledFonts(fontext=fontext))\n        else:\n            fontpaths = X11FontDirectories\n            fontfiles.update(get_fontconfig_fonts(fontext))\n            # check for OS X & load its fonts if present\n            if sys.platform == 'darwin':\n                fontfiles.update(OSXInstalledFonts(fontext=fontext))\n\n    elif isinstance(fontpaths, str):\n        fontpaths = [fontpaths]\n\n    for path in fontpaths:\n        fontfiles.update(map(os.path.abspath, list_fonts(path, fontexts)))\n\n    return [fname for fname in fontfiles if os.path.exists(fname)]\n\n\nclass FontEntry(object):\n    \"\"\"\n    A class for storing Font properties.  It is used when populating\n    the font lookup dictionary.\n    \"\"\"\n    def __init__(self,\n                 fname  ='',\n                 name   ='',\n                 style  ='normal',\n                 variant='normal',\n                 weight ='normal',\n                 stretch='normal',\n                 size   ='medium',\n                 ):\n        self.fname   = fname\n        self.name    = name\n        self.style   = style\n        self.variant = variant\n        self.weight  = weight\n        self.stretch = stretch\n        try:\n            self.size = str(float(size))\n        except ValueError:\n            self.size = size\n\n    def __repr__(self):\n        return \"<Font '%s' (%s) %s %s %s %s>\" % (\n            self.name, os.path.basename(self.fname), self.style, self.variant,\n            self.weight, self.stretch)\n\n\ndef ttfFontProperty(font):\n    \"\"\"\n    Extract information from a TrueType font file.\n\n    Parameters\n    ----------\n    font : `.FT2Font`\n        The TrueType font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n\n    \"\"\"\n    name = font.family_name\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    sfnt = font.get_sfnt()\n    # These tables are actually mac_roman-encoded, but mac_roman support may be\n    # missing in some alternative Python implementations and we are only going\n    # to look for ASCII substrings, where any ASCII-compatible encoding works.\n    sfnt2 = sfnt.get((1, 0, 0, 2), b'').decode('latin-1').lower()\n    sfnt4 = sfnt.get((1, 0, 0, 4), b'').decode('latin-1').lower()\n    if sfnt4.find('oblique') >= 0:\n        style = 'oblique'\n    elif sfnt4.find('italic') >= 0:\n        style = 'italic'\n    elif sfnt2.find('regular') >= 0:\n        style = 'normal'\n    elif font.style_flags & ft2font.ITALIC:\n        style = 'italic'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    #  !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = next((w for w in weight_dict if sfnt4.find(w) >= 0), None)\n    if not weight:\n        if font.style_flags & ft2font.BOLD:\n            weight = 700\n        else:\n            weight = 400\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n\n    if (sfnt4.find('narrow') >= 0 or sfnt4.find('condensed') >= 0 or\n            sfnt4.find('cond') >= 0):\n        stretch = 'condensed'\n    elif sfnt4.find('demi cond') >= 0:\n        stretch = 'semi-condensed'\n    elif sfnt4.find('wide') >= 0 or sfnt4.find('expanded') >= 0:\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    if not font.scalable:\n        raise NotImplementedError(\"Non-scalable fonts are not supported\")\n    size = 'scalable'\n\n    return FontEntry(font.fname, name, style, variant, weight, stretch, size)\n\n\ndef afmFontProperty(fontpath, font):\n    \"\"\"\n    Extract information from an AFM font file.\n\n    Parameters\n    ----------\n    font : `.AFM`\n        The AFM font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n\n    \"\"\"\n\n    name = font.get_familyname()\n    fontname = font.get_fontname().lower()\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    if font.get_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif 'narrow' in fontname or 'cond' in fontname:\n        stretch = 'condensed'\n    elif 'wide' in fontname or 'expanded' in fontname:\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)\n\n\ndef createFontList(fontfiles, fontext='ttf'):\n    \"\"\"\n    A function to create a font lookup list.  The default is to create\n    a list of TrueType fonts.  An AFM font list can optionally be\n    created.\n    \"\"\"\n\n    fontlist = []\n    #  Add fonts from list of known font files.\n    seen = set()\n    for fpath in fontfiles:\n        _log.debug('createFontDict: %s', fpath)\n        fname = os.path.split(fpath)[1]\n        if fname in seen:\n            continue\n        else:\n            seen.add(fname)\n        if fontext == 'afm':\n            try:\n                with open(fpath, 'rb') as fh:\n                    font = afm.AFM(fh)\n            except EnvironmentError:\n                _log.info(\"Could not open font file %s\", fpath)\n                continue\n            except RuntimeError:\n                _log.info(\"Could not parse font file %s\", fpath)\n                continue\n            try:\n                prop = afmFontProperty(fpath, font)\n            except KeyError:\n                continue\n        else:\n            try:\n                font = ft2font.FT2Font(fpath)\n            except RuntimeError:\n                _log.info(\"Could not open font file %s\", fpath)\n                continue\n            except UnicodeError:\n                _log.info(\"Cannot handle unicode filenames\")\n                continue\n            except OSError:\n                _log.info(\"IO error - cannot open font file %s\", fpath)\n                continue\n            try:\n                prop = ttfFontProperty(font)\n            except (KeyError, RuntimeError, ValueError, NotImplementedError):\n                continue\n\n        fontlist.append(prop)\n    return fontlist\n\n\nclass FontProperties(object):\n    \"\"\"\n    A class for storing and manipulating font properties.\n\n    The font properties are those described in the `W3C Cascading\n    Style Sheet, Level 1\n    <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ font\n    specification.  The six properties are:\n\n      - family: A list of font names in decreasing order of priority.\n        The items may include a generic font family name, either\n        'serif', 'sans-serif', 'cursive', 'fantasy', or 'monospace'.\n        In that case, the actual font to be used will be looked up\n        from the associated rcParam.\n\n      - style: Either 'normal', 'italic' or 'oblique'.\n\n      - variant: Either 'normal' or 'small-caps'.\n\n      - stretch: A numeric value in the range 0-1000 or one of\n        'ultra-condensed', 'extra-condensed', 'condensed',\n        'semi-condensed', 'normal', 'semi-expanded', 'expanded',\n        'extra-expanded' or 'ultra-expanded'\n\n      - weight: A numeric value in the range 0-1000 or one of\n        'ultralight', 'light', 'normal', 'regular', 'book', 'medium',\n        'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy',\n        'extra bold', 'black'\n\n      - size: Either an relative value of 'xx-small', 'x-small',\n        'small', 'medium', 'large', 'x-large', 'xx-large' or an\n        absolute font size, e.g., 12\n\n    The default font property for TrueType fonts (as specified in the\n    default rcParams) is::\n\n      sans-serif, normal, normal, normal, normal, scalable.\n\n    Alternatively, a font may be specified using an absolute path to a\n    .ttf file, by using the *fname* kwarg.\n\n    The preferred usage of font sizes is to use the relative values,\n    e.g.,  'large', instead of absolute font sizes, e.g., 12.  This\n    approach allows all text sizes to be made larger or smaller based\n    on the font manager's default font size.\n\n    This class will also accept a `fontconfig\n    <https://www.freedesktop.org/wiki/Software/fontconfig/>`_ pattern, if it is\n    the only argument provided.  See the documentation on `fontconfig patterns\n    <https://www.freedesktop.org/software/fontconfig/fontconfig-user.html>`_.\n    This support does not require fontconfig to be installed.  We are merely\n    borrowing its pattern syntax for use here.\n\n    Note that Matplotlib's internal font manager and fontconfig use a\n    different algorithm to lookup fonts, so the results of the same pattern\n    may be different in Matplotlib than in other applications that use\n    fontconfig.\n    \"\"\"\n\n    def __init__(self,\n                 family = None,\n                 style  = None,\n                 variant= None,\n                 weight = None,\n                 stretch= None,\n                 size   = None,\n                 fname  = None, # if set, it's a hardcoded filename to use\n                 _init   = None  # used only by copy()\n                 ):\n        self._family = _normalize_font_family(rcParams['font.family'])\n        self._slant = rcParams['font.style']\n        self._variant = rcParams['font.variant']\n        self._weight = rcParams['font.weight']\n        self._stretch = rcParams['font.stretch']\n        self._size = rcParams['font.size']\n        self._file = None\n\n        # This is used only by copy()\n        if _init is not None:\n            self.__dict__.update(_init.__dict__)\n            return\n\n        if isinstance(family, str):\n            # Treat family as a fontconfig pattern if it is the only\n            # parameter provided.\n            if (style is None and\n                variant is None and\n                weight is None and\n                stretch is None and\n                size is None and\n                fname is None):\n                self.set_fontconfig_pattern(family)\n                return\n\n        self.set_family(family)\n        self.set_style(style)\n        self.set_variant(variant)\n        self.set_weight(weight)\n        self.set_stretch(stretch)\n        self.set_file(fname)\n        self.set_size(size)\n\n    def _parse_fontconfig_pattern(self, pattern):\n        return parse_fontconfig_pattern(pattern)\n\n    def __hash__(self):\n        l = (tuple(self.get_family()),\n             self.get_slant(),\n             self.get_variant(),\n             self.get_weight(),\n             self.get_stretch(),\n             self.get_size_in_points(),\n             self.get_file())\n        return hash(l)\n\n    def __eq__(self, other):\n        return hash(self) == hash(other)\n\n    def __str__(self):\n        return self.get_fontconfig_pattern()\n\n    def get_family(self):\n        \"\"\"\n        Return a list of font names that comprise the font family.\n        \"\"\"\n        return self._family\n\n    def get_name(self):\n        \"\"\"\n        Return the name of the font that best matches the font properties.\n        \"\"\"\n        return get_font(findfont(self)).family_name\n\n    def get_style(self):\n        \"\"\"\n        Return the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        return self._slant\n    get_slant = get_style\n\n    def get_variant(self):\n        \"\"\"\n        Return the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        return self._variant\n\n    def get_weight(self):\n        \"\"\"\n        Set the font weight.  Options are: A numeric value in the\n        range 0-1000 or one of 'light', 'normal', 'regular', 'book',\n        'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold',\n        'heavy', 'extra bold', 'black'\n        \"\"\"\n        return self._weight\n\n    def get_stretch(self):\n        \"\"\"\n        Return the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'.\n        \"\"\"\n        return self._stretch\n\n    def get_size(self):\n        \"\"\"\n        Return the font size.\n        \"\"\"\n        return self._size\n\n    def get_size_in_points(self):\n        return self._size\n\n    def get_file(self):\n        \"\"\"\n        Return the filename of the associated font.\n        \"\"\"\n        return self._file\n\n    def get_fontconfig_pattern(self):\n        \"\"\"\n        Get a fontconfig pattern suitable for looking up the font as\n        specified with fontconfig's ``fc-match`` utility.\n\n        See the documentation on `fontconfig patterns\n        <https://www.freedesktop.org/software/fontconfig/fontconfig-user.html>`_.\n\n        This support does not require fontconfig to be installed or\n        support for it to be enabled.  We are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        return generate_fontconfig_pattern(self)\n\n    def set_family(self, family):\n        \"\"\"\n        Change the font family.  May be either an alias (generic name\n        is CSS parlance), such as: 'serif', 'sans-serif', 'cursive',\n        'fantasy', or 'monospace', a real font name or a list of real\n        font names.  Real font names are not supported when\n        `text.usetex` is `True`.\n        \"\"\"\n        if family is None:\n            family = rcParams['font.family']\n        self._family = _normalize_font_family(family)\n    set_name = set_family\n\n    def set_style(self, style):\n        \"\"\"\n        Set the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        if style is None:\n            style = rcParams['font.style']\n        if style not in ('normal', 'italic', 'oblique'):\n            raise ValueError(\"style must be normal, italic or oblique\")\n        self._slant = style\n    set_slant = set_style\n\n    def set_variant(self, variant):\n        \"\"\"\n        Set the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        if variant is None:\n            variant = rcParams['font.variant']\n        if variant not in ('normal', 'small-caps'):\n            raise ValueError(\"variant must be normal or small-caps\")\n        self._variant = variant\n\n    def set_weight(self, weight):\n        \"\"\"\n        Set the font weight.  May be either a numeric value in the\n        range 0-1000 or one of 'ultralight', 'light', 'normal',\n        'regular', 'book', 'medium', 'roman', 'semibold', 'demibold',\n        'demi', 'bold', 'heavy', 'extra bold', 'black'\n        \"\"\"\n        if weight is None:\n            weight = rcParams['font.weight']\n        try:\n            weight = int(weight)\n            if weight < 0 or weight > 1000:\n                raise ValueError()\n        except ValueError:\n            if weight not in weight_dict:\n                raise ValueError(\"weight is invalid\")\n        self._weight = weight\n\n    def set_stretch(self, stretch):\n        \"\"\"\n        Set the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded' or\n        'ultra-expanded', or a numeric value in the range 0-1000.\n        \"\"\"\n        if stretch is None:\n            stretch = rcParams['font.stretch']\n        try:\n            stretch = int(stretch)\n            if stretch < 0 or stretch > 1000:\n                raise ValueError()\n        except ValueError:\n            if stretch not in stretch_dict:\n                raise ValueError(\"stretch is invalid\")\n        self._stretch = stretch\n\n    def set_size(self, size):\n        \"\"\"\n        Set the font size.  Either an relative value of 'xx-small',\n        'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'\n        or an absolute font size, e.g., 12.\n        \"\"\"\n        if size is None:\n            size = rcParams['font.size']\n        try:\n            size = float(size)\n        except ValueError:\n            try:\n                scale = font_scalings[size]\n            except KeyError:\n                raise ValueError(\n                    \"Size is invalid. Valid font size are \"\n                    + \", \".join(map(str, font_scalings)))\n            else:\n                size = scale * FontManager.get_default_size()\n        if size < 1.0:\n            _log.info('Fontsize %1.2f < 1.0 pt not allowed by FreeType. '\n                      'Setting fontsize = 1 pt', size)\n            size = 1.0\n        self._size = size\n\n    def set_file(self, file):\n        \"\"\"\n        Set the filename of the fontfile to use.  In this case, all\n        other properties will be ignored.\n        \"\"\"\n        self._file = file\n\n    def set_fontconfig_pattern(self, pattern):\n        \"\"\"\n        Set the properties by parsing a fontconfig *pattern*.\n\n        See the documentation on `fontconfig patterns\n        <https://www.freedesktop.org/software/fontconfig/fontconfig-user.html>`_.\n\n        This support does not require fontconfig to be installed or\n        support for it to be enabled.  We are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        for key, val in self._parse_fontconfig_pattern(pattern).items():\n            if type(val) == list:\n                getattr(self, \"set_\" + key)(val[0])\n            else:\n                getattr(self, \"set_\" + key)(val)\n\n    def copy(self):\n        \"\"\"Return a deep copy of self\"\"\"\n        return FontProperties(_init=self)\n\n\nclass JSONEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, FontManager):\n            return dict(o.__dict__, __class__='FontManager')\n        elif isinstance(o, FontEntry):\n            d = dict(o.__dict__, __class__='FontEntry')\n            try:\n                # Cache paths of fonts shipped with mpl relative to the mpl\n                # data path, which helps in the presence of venvs.\n                d[\"fname\"] = str(\n                    Path(d[\"fname\"]).relative_to(mpl.get_data_path()))\n            except ValueError:\n                pass\n            return d\n        else:\n            return super().default(o)\n\n\ndef _json_decode(o):\n    cls = o.pop('__class__', None)\n    if cls is None:\n        return o\n    elif cls == 'FontManager':\n        r = FontManager.__new__(FontManager)\n        r.__dict__.update(o)\n        return r\n    elif cls == 'FontEntry':\n        r = FontEntry.__new__(FontEntry)\n        r.__dict__.update(o)\n        if not os.path.isabs(r.fname):\n            r.fname = os.path.join(mpl.get_data_path(), r.fname)\n        return r\n    else:\n        raise ValueError(\"don't know how to deserialize __class__=%s\" % cls)\n\n\ndef json_dump(data, filename):\n    \"\"\"\n    Dumps a data structure as JSON in the named file.\n\n    Handles FontManager and its fields.  File paths that are children of the\n    Matplotlib data path (typically, fonts shipped with Matplotlib) are stored\n    relative to that data path (to remain valid across virtualenvs).\n    \"\"\"\n    with open(filename, 'w') as fh:\n        try:\n            json.dump(data, fh, cls=JSONEncoder, indent=2)\n        except OSError as e:\n            warnings.warn('Could not save font_manager cache {}'.format(e))\n\n\ndef json_load(filename):\n    \"\"\"\n    Loads a data structure as JSON from the named file.\n\n    Handles FontManager and its fields.  Relative file paths are interpreted\n    as being relative to the Matplotlib data path, and transformed into\n    absolute paths.\n    \"\"\"\n    with open(filename, 'r') as fh:\n        return json.load(fh, object_hook=_json_decode)\n\n\ndef _normalize_font_family(family):\n    if isinstance(family, str):\n        family = [family]\n    return family\n\n\n@cbook.deprecated(\"3.0\")\nclass TempCache(object):\n    \"\"\"\n    A class to store temporary caches that are (a) not saved to disk\n    and (b) invalidated whenever certain font-related\n    rcParams---namely the family lookup lists---are changed or the\n    font cache is reloaded.  This avoids the expensive linear search\n    through all fonts every time a font is looked up.\n    \"\"\"\n    # A list of rcparam names that, when changed, invalidated this\n    # cache.\n    invalidating_rcparams = (\n        'font.serif', 'font.sans-serif', 'font.cursive', 'font.fantasy',\n        'font.monospace')\n\n    def __init__(self):\n        self._lookup_cache = {}\n        self._last_rcParams = self.make_rcparams_key()\n\n    def make_rcparams_key(self):\n        return [id(fontManager)] + [\n            rcParams[param] for param in self.invalidating_rcparams]\n\n    def get(self, prop):\n        key = self.make_rcparams_key()\n        if key != self._last_rcParams:\n            self._lookup_cache = {}\n            self._last_rcParams = key\n        return self._lookup_cache.get(prop)\n\n    def set(self, prop, value):\n        key = self.make_rcparams_key()\n        if key != self._last_rcParams:\n            self._lookup_cache = {}\n            self._last_rcParams = key\n        self._lookup_cache[prop] = value\n\n\nclass FontManager(object):\n    \"\"\"\n    On import, the :class:`FontManager` singleton instance creates a\n    list of TrueType fonts based on the font properties: name, style,\n    variant, weight, stretch, and size.  The :meth:`findfont` method\n    does a nearest neighbor search to find the font that most closely\n    matches the specification.  If no good enough match is found, a\n    default font is returned.\n    \"\"\"\n    # Increment this version number whenever the font cache data\n    # format or behavior has changed and requires a existing font\n    # cache files to be rebuilt.\n    __version__ = 300\n\n    def __init__(self, size=None, weight='normal'):\n        self._version = self.__version__\n\n        self.__default_weight = weight\n        self.default_size = size\n\n        paths = [os.path.join(rcParams['datapath'], 'fonts', 'ttf'),\n                 os.path.join(rcParams['datapath'], 'fonts', 'afm'),\n                 os.path.join(rcParams['datapath'], 'fonts', 'pdfcorefonts')]\n\n        #  Create list of font paths\n        for pathname in ['TTFPATH', 'AFMPATH']:\n            if pathname in os.environ:\n                ttfpath = os.environ[pathname]\n                if ttfpath.find(';') >= 0: #win32 style\n                    paths.extend(ttfpath.split(';'))\n                elif ttfpath.find(':') >= 0: # unix style\n                    paths.extend(ttfpath.split(':'))\n                else:\n                    paths.append(ttfpath)\n        _log.debug('font search path %s', str(paths))\n        #  Load TrueType fonts and create font dictionary.\n\n        self.defaultFamily = {\n            'ttf': 'DejaVu Sans',\n            'afm': 'Helvetica'}\n        self.defaultFont = {}\n\n        ttffiles = findSystemFonts(paths) + findSystemFonts()\n        self.defaultFont['ttf'] = next(\n            (fname for fname in ttffiles\n             if fname.lower().endswith(\"dejavusans.ttf\")),\n            ttffiles[0])\n        self.ttflist = createFontList(ttffiles)\n\n        afmfiles = (findSystemFonts(paths, fontext='afm')\n                    + findSystemFonts(fontext='afm'))\n        self.afmlist = createFontList(afmfiles, fontext='afm')\n        self.defaultFont['afm'] = afmfiles[0] if afmfiles else None\n\n    @property\n    @cbook.deprecated(\"3.0\")\n    def ttffiles(self):\n        return [font.fname for font in self.ttflist]\n\n    @property\n    @cbook.deprecated(\"3.0\")\n    def afmfiles(self):\n        return [font.fname for font in self.afmlist]\n\n    def get_default_weight(self):\n        \"\"\"\n        Return the default font weight.\n        \"\"\"\n        return self.__default_weight\n\n    @staticmethod\n    def get_default_size():\n        \"\"\"\n        Return the default font size.\n        \"\"\"\n        return rcParams['font.size']\n\n    def set_default_weight(self, weight):\n        \"\"\"\n        Set the default font weight.  The initial value is 'normal'.\n        \"\"\"\n        self.__default_weight = weight\n\n    def update_fonts(self, filenames):\n        \"\"\"\n        Update the font dictionary with new font files.\n        Currently not implemented.\n        \"\"\"\n        #  !!!!  Needs implementing\n        raise NotImplementedError\n\n    # Each of the scoring functions below should return a value between\n    # 0.0 (perfect match) and 1.0 (terrible match)\n    def score_family(self, families, family2):\n        \"\"\"\n        Returns a match score between the list of font families in\n        *families* and the font family name *family2*.\n\n        An exact match at the head of the list returns 0.0.\n\n        A match further down the list will return between 0 and 1.\n\n        No match will return 1.0.\n        \"\"\"\n        if not isinstance(families, (list, tuple)):\n            families = [families]\n        elif len(families) == 0:\n            return 1.0\n        family2 = family2.lower()\n        step = 1 / len(families)\n        for i, family1 in enumerate(families):\n            family1 = family1.lower()\n            if family1 in font_family_aliases:\n                if family1 in ('sans', 'sans serif'):\n                    family1 = 'sans-serif'\n                options = rcParams['font.' + family1]\n                options = [x.lower() for x in options]\n                if family2 in options:\n                    idx = options.index(family2)\n                    return (i + (idx / len(options))) * step\n            elif family1 == family2:\n                # The score should be weighted by where in the\n                # list the font was found.\n                return i * step\n        return 1.0\n\n    def score_style(self, style1, style2):\n        \"\"\"\n        Returns a match score between *style1* and *style2*.\n\n        An exact match returns 0.0.\n\n        A match between 'italic' and 'oblique' returns 0.1.\n\n        No match returns 1.0.\n        \"\"\"\n        if style1 == style2:\n            return 0.0\n        elif style1 in ('italic', 'oblique') and \\\n                style2 in ('italic', 'oblique'):\n            return 0.1\n        return 1.0\n\n    def score_variant(self, variant1, variant2):\n        \"\"\"\n        Returns a match score between *variant1* and *variant2*.\n\n        An exact match returns 0.0, otherwise 1.0.\n        \"\"\"\n        if variant1 == variant2:\n            return 0.0\n        else:\n            return 1.0\n\n    def score_stretch(self, stretch1, stretch2):\n        \"\"\"\n        Returns a match score between *stretch1* and *stretch2*.\n\n        The result is the absolute value of the difference between the\n        CSS numeric values of *stretch1* and *stretch2*, normalized\n        between 0.0 and 1.0.\n        \"\"\"\n        try:\n            stretchval1 = int(stretch1)\n        except ValueError:\n            stretchval1 = stretch_dict.get(stretch1, 500)\n        try:\n            stretchval2 = int(stretch2)\n        except ValueError:\n            stretchval2 = stretch_dict.get(stretch2, 500)\n        return abs(stretchval1 - stretchval2) / 1000.0\n\n    def score_weight(self, weight1, weight2):\n        \"\"\"\n        Returns a match score between *weight1* and *weight2*.\n\n        The result is 0.0 if both weight1 and weight 2 are given as strings\n        and have the same value.\n\n        Otherwise, the result is the absolute value of the difference between\n        the CSS numeric values of *weight1* and *weight2*, normalized between\n        0.05 and 1.0.\n        \"\"\"\n\n        # exact match of the weight names, e.g. weight1 == weight2 == \"regular\"\n        if (isinstance(weight1, str) and\n                isinstance(weight2, str) and\n                weight1 == weight2):\n            return 0.0\n        try:\n            weightval1 = int(weight1)\n        except ValueError:\n            weightval1 = weight_dict.get(weight1, 500)\n        try:\n            weightval2 = int(weight2)\n        except ValueError:\n            weightval2 = weight_dict.get(weight2, 500)\n        return 0.95*(abs(weightval1 - weightval2) / 1000.0) + 0.05\n\n    def score_size(self, size1, size2):\n        \"\"\"\n        Returns a match score between *size1* and *size2*.\n\n        If *size2* (the size specified in the font file) is 'scalable', this\n        function always returns 0.0, since any font size can be generated.\n\n        Otherwise, the result is the absolute distance between *size1* and\n        *size2*, normalized so that the usual range of font sizes (6pt -\n        72pt) will lie between 0.0 and 1.0.\n        \"\"\"\n        if size2 == 'scalable':\n            return 0.0\n        # Size value should have already been\n        try:\n            sizeval1 = float(size1)\n        except ValueError:\n            sizeval1 = self.default_size * font_scalings[size1]\n        try:\n            sizeval2 = float(size2)\n        except ValueError:\n            return 1.0\n        return abs(sizeval1 - sizeval2) / 72.0\n\n    def findfont(self, prop, fontext='ttf', directory=None,\n                 fallback_to_default=True, rebuild_if_missing=True):\n        \"\"\"\n        Search the font list for the font that most closely matches\n        the :class:`FontProperties` *prop*.\n\n        :meth:`findfont` performs a nearest neighbor search.  Each\n        font is given a similarity score to the target font\n        properties.  The first font with the highest score is\n        returned.  If no matches below a certain threshold are found,\n        the default font (usually DejaVu Sans) is returned.\n\n        `directory`, is specified, will only return fonts from the\n        given directory (or subdirectory of that directory).\n\n        The result is cached, so subsequent lookups don't have to\n        perform the O(n) nearest neighbor search.\n\n        If `fallback_to_default` is True, will fallback to the default\n        font family (usually \"DejaVu Sans\" or \"Helvetica\") if\n        the first lookup hard-fails.\n\n        See the `W3C Cascading Style Sheet, Level 1\n        <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ documentation\n        for a description of the font finding algorithm.\n        \"\"\"\n        # Pass the relevant rcParams (and the font manager, as `self`) to\n        # _findfont_cached so to prevent using a stale cache entry after an\n        # rcParam was changed.\n        rc_params = tuple(tuple(rcParams[key]) for key in [\n            \"font.serif\", \"font.sans-serif\", \"font.cursive\", \"font.fantasy\",\n            \"font.monospace\"])\n        return self._findfont_cached(\n            prop, fontext, directory, fallback_to_default, rebuild_if_missing,\n            rc_params)\n\n    @lru_cache()\n    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        if not isinstance(prop, FontProperties):\n            prop = FontProperties(prop)\n        fname = prop.get_file()\n\n        if fname is not None:\n            _log.debug('findfont returning %s', fname)\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            # Matching family should have highest priority, so it is multiplied\n            # by 10.0\n            score = \\\n                self.score_family(prop.get_family(), font.name) * 10.0 + \\\n                self.score_style(prop.get_style(), font.style) + \\\n                self.score_variant(prop.get_variant(), font.variant) + \\\n                self.score_weight(prop.get_weight(), font.weight) + \\\n                self.score_stretch(prop.get_stretch(), font.stretch) + \\\n                self.score_size(prop.get_size(), font.size)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                warnings.warn(\n                    'findfont: Font family %s not found. Falling back to %s.' %\n                    (prop.get_family(), self.defaultFamily[fontext]))\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory, False)\n            else:\n                # This is a hard fail -- we can't find anything reasonable,\n                # so just return the DejuVuSans.ttf\n                warnings.warn('findfont: Could not match %s. Returning %s.' %\n                              (prop, self.defaultFont[fontext]),\n                              UserWarning)\n                result = self.defaultFont[fontext]\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                _rebuild()\n                return fontManager.findfont(\n                    prop, fontext, directory, True, False)\n            else:\n                raise ValueError(\"No valid font could be found\")\n\n        return result\n\n@lru_cache()\ndef is_opentype_cff_font(filename):\n    \"\"\"\n    Returns True if the given font is a Postscript Compact Font Format\n    Font embedded in an OpenType wrapper.  Used by the PostScript and\n    PDF backends that can not subset these fonts.\n    \"\"\"\n    if os.path.splitext(filename)[1].lower() == '.otf':\n        with open(filename, 'rb') as fd:\n            return fd.read(4) == b\"OTTO\"\n    else:\n        return False\n\nfontManager = None\n_fmcache = None\n\n\n_get_font = lru_cache(64)(ft2font.FT2Font)\n\ndef get_font(filename, hinting_factor=None):\n    if hinting_factor is None:\n        hinting_factor = rcParams['text.hinting_factor']\n    return _get_font(filename, hinting_factor)\n\n\n# The experimental fontconfig-based backend.\nif USE_FONTCONFIG and sys.platform != 'win32':\n\n    def fc_match(pattern, fontext):\n        fontexts = get_fontext_synonyms(fontext)\n        ext = \".\" + fontext\n        try:\n            pipe = subprocess.Popen(\n                ['fc-match', '-s', '--format=%{file}\\\\n', pattern],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n            output = pipe.communicate()[0]\n        except OSError:\n            return None\n\n        # The bulk of the output from fc-list is ascii, so we keep the\n        # result in bytes and parse it as bytes, until we extract the\n        # filename, which is in sys.filesystemencoding().\n        if pipe.returncode == 0:\n            for fname in map(os.fsdecode, output.split(b'\\n')):\n                if os.path.splitext(fname)[1][1:] in fontexts:\n                    return fname\n        return None\n\n    _fc_match_cache = {}\n\n    def findfont(prop, fontext='ttf'):\n        if not isinstance(prop, str):\n            prop = prop.get_fontconfig_pattern()\n        cached = _fc_match_cache.get(prop)\n        if cached is not None:\n            return cached\n\n        result = fc_match(prop, fontext)\n        if result is None:\n            result = fc_match(':', fontext)\n\n        _fc_match_cache[prop] = result\n        return result\n\nelse:\n    _fmcache = None\n\n    cachedir = get_cachedir()\n    if cachedir is not None:\n        _fmcache = os.path.join(\n            cachedir, 'fontlist-v{}.json'.format(FontManager.__version__))\n\n    fontManager = None\n\n    def _rebuild():\n        global fontManager\n\n        fontManager = FontManager()\n\n        if _fmcache:\n            with cbook._lock_path(_fmcache):\n                json_dump(fontManager, _fmcache)\n        _log.debug(\"generated new fontManager\")\n\n    if _fmcache:\n        try:\n            fontManager = json_load(_fmcache)\n            if (not hasattr(fontManager, '_version') or\n                fontManager._version != FontManager.__version__):\n                _rebuild()\n            else:\n                fontManager.default_size = None\n                _log.debug(\"Using fontManager instance from %s\", _fmcache)\n        except TimeoutError:\n            raise\n        except Exception:\n            _rebuild()\n    else:\n        _rebuild()\n\n    def findfont(prop, **kw):\n        global fontManager\n        font = fontManager.findfont(prop, **kw)\n        return font\n"
    }
  ]
}