{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "18039",
  "issue_description": "# Add `_repr_html_` for fonts\n\nI'm not totally sure which font object this would go on, but in the vein of colormaps (#15616), it be helpful if you could get a rendering of the font and pull up a font_list (realized I couldn't get a font working 'cause I spelled it wrong). \r\n\r\nWas inspired by this blog post that does this: jonathansoma.com/lede/data-studio/matplotlib/list-all-fonts-available-in-matplotlib-plus-samples/\r\n\r\nThe hard part here is deciding if it's something that would be accepted and on which object it should go. ",
  "issue_comments": [
    {
      "id": 663230891,
      "user": "timhoffm",
      "body": "Put no thought into this, but you could make it similar to `matplotlib.style.available`."
    },
    {
      "id": 830768144,
      "user": "aitikgupta",
      "body": "I'm not sure how IPython invokes the `__repr__` or `_repr_html_`, however this simple patch on class `FontEntry` _should_ work if we directly invoke it, i.e:\r\n```diff\r\ndiff --git a/lib/matplotlib/font_manager.py b/lib/matplotlib/font_manager.py\r\nindex a5fdc32b2..767b62020 100644\r\n--- a/lib/matplotlib/font_manager.py\r\n+++ b/lib/matplotlib/font_manager.py\r\n@@ -373,6 +373,9 @@ class FontEntry:\r\n             self.name, os.path.basename(self.fname), self.style, self.variant,\r\n             self.weight, self.stretch)\r\n \r\n+    def _repr_html_(self):\r\n+        return f\"<span style='font-family:{self.name}'>{self.name}</span>\"\r\n+\r\n \r\n def ttfFontProperty(font):\r\n     \"\"\"\r\n```\r\n\r\nInvoking it in IPython:\r\n```python\r\nimport matplotlib.font_manager\r\nfrom IPython.core.display import HTML\r\n\r\nfont = matplotlib.font_manager.fontManager.ttflist[0]       # any FontEntry\r\n\r\nHTML(font._repr_html_())\r\n```\r\n\r\nOnly direct invocation works, since if we do a `HTML(font)`->  `__repr__` is called and not `_repr_html_` (not sure why)"
    },
    {
      "id": 830773809,
      "user": "aitikgupta",
      "body": "Another issue is, if fonts have a `_repr_html_` using the above way (or even the way it's in the blog mentioned), we really just rely on browsers/notebooks/etc. to render that font (using font-family) - matplotlib would just provide it with the names of those fonts.\r\n\r\nLet's say someday someone wants to use a custom font, through matplotlib they'd be able to generate text via that font, but if we use this `_repr_html_` implementation, they won't get the same font on browsers, etc. (it'll fall back to some web-safe-font)\r\n<br>\r\nNow it _could_ be solved if we were to render the fonts as PNGs, but is it worth considering?"
    },
    {
      "id": 830779999,
      "user": "timhoffm",
      "body": "Rendering to png is not worth the added complexity. You'll run into HiDPI scaling issues.\r\n\r\nOverall, I consider this feature super-optional. There are various ways of showing fonts (without or with matplotlib). Rendering font examples is not a primary or necessary feature for Matplotlib. I'm ok if we add the two-line repr_html as a nicety, but anything beyond is overkill."
    },
    {
      "id": 843623944,
      "user": "aitikgupta",
      "body": "Uh, recent PR by @QuLogic converted the FontEntry to a dataclass.\r\nI'm not sure how they work, but https://github.com/matplotlib/matplotlib/pull/20118 removed even the `__repr__` function, not sure how a `_repr_html_` could be added. :p"
    },
    {
      "id": 843967742,
      "user": "story645",
      "body": "Yeah, I think the follow on to this then is probably deciding if there'd be interest/utility in a font.available type thing that prints everything to screen?"
    },
    {
      "id": 844078286,
      "user": "tacaswell",
      "body": "We dropped our own `__repr__` because data classes come with a nice one out of the box!\r\n\r\nWe can add a `_repr_html_` either by injecting it into the `namespace` dictionary to `make_dataclass` (https://docs.python.org/3/library/dataclasses.html#dataclasses.make_dataclass) or by subclassing the result of `make_dataclass`."
    },
    {
      "id": 845761451,
      "user": "anntzer",
      "body": "Adding `_repr_png_` (which as @aitikgupta mentioned would be more robust than `_repr_html_`) is easy enough\r\n```patch\r\ndiff --git i/lib/matplotlib/font_manager.py w/lib/matplotlib/font_manager.py\r\nindex 5a9ed79535..aa277ef0f7 100644\r\n--- i/lib/matplotlib/font_manager.py\r\n+++ w/lib/matplotlib/font_manager.py\r\n@@ -25,6 +25,7 @@ Future versions may implement the Level 2 or 2.1 specifications.\r\n \r\n import dataclasses\r\n from functools import lru_cache\r\n+from io import BytesIO\r\n import json\r\n import logging\r\n from numbers import Number\r\n@@ -343,8 +344,7 @@ def findSystemFonts(fontpaths=None, fontext='ttf'):\r\n     return [fname for fname in fontfiles if os.path.exists(fname)]\r\n \r\n \r\n-FontEntry = dataclasses.make_dataclass(\r\n-    'FontEntry', [\r\n+class FontEntry(dataclasses.make_dataclass('FontEntry', [\r\n         ('fname', str, dataclasses.field(default='')),\r\n         ('name', str, dataclasses.field(default='')),\r\n         ('style', str, dataclasses.field(default='normal')),\r\n@@ -352,13 +352,20 @@ FontEntry = dataclasses.make_dataclass(\r\n         ('weight', str, dataclasses.field(default='normal')),\r\n         ('stretch', str, dataclasses.field(default='normal')),\r\n         ('size', str, dataclasses.field(default='medium')),\r\n-    ],\r\n-    namespace={\r\n-        '__doc__': \"\"\"\r\n+])):\r\n+    \"\"\"\r\n     A class for storing Font properties.\r\n \r\n     It is used when populating the font lookup dictionary.\r\n-    \"\"\"})\r\n+    \"\"\"\r\n+\r\n+    def _repr_png_(self):\r\n+        from matplotlib.figure import Figure  # Circular import.\r\n+        fig = Figure()\r\n+        fig.text(0, 0, self.name, font=Path(self.fname))\r\n+        with BytesIO() as buf:\r\n+            fig.savefig(buf, bbox_inches=\"tight\", transparent=True)\r\n+            return buf.getvalue()\r\n \r\n \r\n def ttfFontProperty(font):\r\n```\r\nbut even then there's the problem that some of the fonts we ship (e.g. computer modern symbol) or some system fonts (wingdings-like fonts) don't even have all the glyphs to represent their own names..."
    },
    {
      "id": 845831179,
      "user": "aitikgupta",
      "body": "> some of the fonts we ship (e.g. computer modern symbol) or some system fonts (wingdings-like fonts) don't even have all the glyphs to represent their own names...\r\n\r\nBut should that be a problem?\r\nIf a certain font doesn't have req glyphs this would render incorrectly, whereas browsers should render something web-safe.\r\n\r\nI think `repr` of a font object should just stick to itself, even if it means it can't display its own name.\r\n(choice between incorrect and more-incorrect :p)\r\n\r\n"
    },
    {
      "id": 846591716,
      "user": "timhoffm",
      "body": "PNG has the problem of hidpi (more generally dpi scaling) handling. Without that the PNGs look ugly, particularly with detailed graphics such as fibers. Dpi scaling will become more and more common. I do don‘t think we want to get into that business just for font visualization. So, I recommend not to use PNG."
    },
    {
      "id": 1030864448,
      "user": "khurchla",
      "body": "Thanks again for this folks!"
    }
  ],
  "text_context": "# Add `_repr_html_` for fonts\n\nI'm not totally sure which font object this would go on, but in the vein of colormaps (#15616), it be helpful if you could get a rendering of the font and pull up a font_list (realized I couldn't get a font working 'cause I spelled it wrong). \r\n\r\nWas inspired by this blog post that does this: jonathansoma.com/lede/data-studio/matplotlib/list-all-fonts-available-in-matplotlib-plus-samples/\r\n\r\nThe hard part here is deciding if it's something that would be accepted and on which object it should go. \n\nPut no thought into this, but you could make it similar to `matplotlib.style.available`.\n\nI'm not sure how IPython invokes the `__repr__` or `_repr_html_`, however this simple patch on class `FontEntry` _should_ work if we directly invoke it, i.e:\r\n```diff\r\ndiff --git a/lib/matplotlib/font_manager.py b/lib/matplotlib/font_manager.py\r\nindex a5fdc32b2..767b62020 100644\r\n--- a/lib/matplotlib/font_manager.py\r\n+++ b/lib/matplotlib/font_manager.py\r\n@@ -373,6 +373,9 @@ class FontEntry:\r\n             self.name, os.path.basename(self.fname), self.style, self.variant,\r\n             self.weight, self.stretch)\r\n \r\n+    def _repr_html_(self):\r\n+        return f\"<span style='font-family:{self.name}'>{self.name}</span>\"\r\n+\r\n \r\n def ttfFontProperty(font):\r\n     \"\"\"\r\n```\r\n\r\nInvoking it in IPython:\r\n```python\r\nimport matplotlib.font_manager\r\nfrom IPython.core.display import HTML\r\n\r\nfont = matplotlib.font_manager.fontManager.ttflist[0]       # any FontEntry\r\n\r\nHTML(font._repr_html_())\r\n```\r\n\r\nOnly direct invocation works, since if we do a `HTML(font)`->  `__repr__` is called and not `_repr_html_` (not sure why)\n\nAnother issue is, if fonts have a `_repr_html_` using the above way (or even the way it's in the blog mentioned), we really just rely on browsers/notebooks/etc. to render that font (using font-family) - matplotlib would just provide it with the names of those fonts.\r\n\r\nLet's say someday someone wants to use a custom font, through matplotlib they'd be able to generate text via that font, but if we use this `_repr_html_` implementation, they won't get the same font on browsers, etc. (it'll fall back to some web-safe-font)\r\n<br>\r\nNow it _could_ be solved if we were to render the fonts as PNGs, but is it worth considering?\n\nRendering to png is not worth the added complexity. You'll run into HiDPI scaling issues.\r\n\r\nOverall, I consider this feature super-optional. There are various ways of showing fonts (without or with matplotlib). Rendering font examples is not a primary or necessary feature for Matplotlib. I'm ok if we add the two-line repr_html as a nicety, but anything beyond is overkill.\n\nUh, recent PR by @QuLogic converted the FontEntry to a dataclass.\r\nI'm not sure how they work, but https://github.com/matplotlib/matplotlib/pull/20118 removed even the `__repr__` function, not sure how a `_repr_html_` could be added. :p\n\nYeah, I think the follow on to this then is probably deciding if there'd be interest/utility in a font.available type thing that prints everything to screen?\n\nWe dropped our own `__repr__` because data classes come with a nice one out of the box!\r\n\r\nWe can add a `_repr_html_` either by injecting it into the `namespace` dictionary to `make_dataclass` (https://docs.python.org/3/library/dataclasses.html#dataclasses.make_dataclass) or by subclassing the result of `make_dataclass`.\n\nAdding `_repr_png_` (which as @aitikgupta mentioned would be more robust than `_repr_html_`) is easy enough\r\n```patch\r\ndiff --git i/lib/matplotlib/font_manager.py w/lib/matplotlib/font_manager.py\r\nindex 5a9ed79535..aa277ef0f7 100644\r\n--- i/lib/matplotlib/font_manager.py\r\n+++ w/lib/matplotlib/font_manager.py\r\n@@ -25,6 +25,7 @@ Future versions may implement the Level 2 or 2.1 specifications.\r\n \r\n import dataclasses\r\n from functools import lru_cache\r\n+from io import BytesIO\r\n import json\r\n import logging\r\n from numbers import Number\r\n@@ -343,8 +344,7 @@ def findSystemFonts(fontpaths=None, fontext='ttf'):\r\n     return [fname for fname in fontfiles if os.path.exists(fname)]\r\n \r\n \r\n-FontEntry = dataclasses.make_dataclass(\r\n-    'FontEntry', [\r\n+class FontEntry(dataclasses.make_dataclass('FontEntry', [\r\n         ('fname', str, dataclasses.field(default='')),\r\n         ('name', str, dataclasses.field(default='')),\r\n         ('style', str, dataclasses.field(default='normal')),\r\n@@ -352,13 +352,20 @@ FontEntry = dataclasses.make_dataclass(\r\n         ('weight', str, dataclasses.field(default='normal')),\r\n         ('stretch', str, dataclasses.field(default='normal')),\r\n         ('size', str, dataclasses.field(default='medium')),\r\n-    ],\r\n-    namespace={\r\n-        '__doc__': \"\"\"\r\n+])):\r\n+    \"\"\"\r\n     A class for storing Font properties.\r\n \r\n     It is used when populating the font lookup dictionary.\r\n-    \"\"\"})\r\n+    \"\"\"\r\n+\r\n+    def _repr_png_(self):\r\n+        from matplotlib.figure import Figure  # Circular import.\r\n+        fig = Figure()\r\n+        fig.text(0, 0, self.name, font=Path(self.fname))\r\n+        with BytesIO() as buf:\r\n+            fig.savefig(buf, bbox_inches=\"tight\", transparent=True)\r\n+            return buf.getvalue()\r\n \r\n \r\n def ttfFontProperty(font):\r\n```\r\nbut even then there's the problem that some of the fonts we ship (e.g. computer modern symbol) or some system fonts (wingdings-like fonts) don't even have all the glyphs to represent their own names...\n\n> some of the fonts we ship (e.g. computer modern symbol) or some system fonts (wingdings-like fonts) don't even have all the glyphs to represent their own names...\r\n\r\nBut should that be a problem?\r\nIf a certain font doesn't have req glyphs this would render incorrectly, whereas browsers should render something web-safe.\r\n\r\nI think `repr` of a font object should just stick to itself, even if it means it can't display its own name.\r\n(choice between incorrect and more-incorrect :p)\r\n\r\n\n\nPNG has the problem of hidpi (more generally dpi scaling) handling. Without that the PNGs look ugly, particularly with detailed graphics such as fibers. Dpi scaling will become more and more common. I do don‘t think we want to get into that business just for font visualization. So, I recommend not to use PNG.\n\nThanks again for this folks!",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/20118",
  "code_context": [
    {
      "filename": "lib/matplotlib/font_manager.py",
      "content": "\"\"\"\nA module for finding, managing, and using fonts across platforms.\n\nThis module provides a single `FontManager` instance that can\nbe shared across backends and platforms.  The `findfont`\nfunction returns the best TrueType (TTF) font file in the local or\nsystem font path that matches the specified `FontProperties`\ninstance.  The `FontManager` also handles Adobe Font Metrics\n(AFM) font files for use by the PostScript backend.\n\nThe design is based on the `W3C Cascading Style Sheet, Level 1 (CSS1)\nfont specification <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_.\nFuture versions may implement the Level 2 or 2.1 specifications.\n\"\"\"\n\n# KNOWN ISSUES\n#\n#   - documentation\n#   - font variant is untested\n#   - font stretch is incomplete\n#   - font size is incomplete\n#   - default font algorithm needs improvement and testing\n#   - setWeights function needs improvement\n#   - 'light' is an invalid weight value, remove it.\n\nimport dataclasses\nfrom functools import lru_cache\nimport json\nimport logging\nfrom numbers import Number\nimport os\nfrom pathlib import Path\nimport re\nimport subprocess\nimport sys\ntry:\n    import threading\n    from threading import Timer\nexcept ImportError:\n    import dummy_threading as threading\n    from dummy_threading import Timer\n\nimport matplotlib as mpl\nfrom matplotlib import _api, afm, cbook, ft2font, rcParams\nfrom matplotlib.fontconfig_pattern import (\n    parse_fontconfig_pattern, generate_fontconfig_pattern)\nfrom matplotlib.rcsetup import _validators\n\n_log = logging.getLogger(__name__)\n\nfont_scalings = {\n    'xx-small': 0.579,\n    'x-small':  0.694,\n    'small':    0.833,\n    'medium':   1.0,\n    'large':    1.200,\n    'x-large':  1.440,\n    'xx-large': 1.728,\n    'larger':   1.2,\n    'smaller':  0.833,\n    None:       1.0,\n}\nstretch_dict = {\n    'ultra-condensed': 100,\n    'extra-condensed': 200,\n    'condensed':       300,\n    'semi-condensed':  400,\n    'normal':          500,\n    'semi-expanded':   600,\n    'semi-extended':   600,\n    'expanded':        700,\n    'extended':        700,\n    'extra-expanded':  800,\n    'extra-extended':  800,\n    'ultra-expanded':  900,\n    'ultra-extended':  900,\n}\nweight_dict = {\n    'ultralight': 100,\n    'light':      200,\n    'normal':     400,\n    'regular':    400,\n    'book':       400,\n    'medium':     500,\n    'roman':      500,\n    'semibold':   600,\n    'demibold':   600,\n    'demi':       600,\n    'bold':       700,\n    'heavy':      800,\n    'extra bold': 800,\n    'black':      900,\n}\n_weight_regexes = [\n    # From fontconfig's FcFreeTypeQueryFaceInternal; not the same as\n    # weight_dict!\n    (\"thin\", 100),\n    (\"extralight\", 200),\n    (\"ultralight\", 200),\n    (\"demilight\", 350),\n    (\"semilight\", 350),\n    (\"light\", 300),  # Needs to come *after* demi/semilight!\n    (\"book\", 380),\n    (\"regular\", 400),\n    (\"normal\", 400),\n    (\"medium\", 500),\n    (\"demibold\", 600),\n    (\"demi\", 600),\n    (\"semibold\", 600),\n    (\"extrabold\", 800),\n    (\"superbold\", 800),\n    (\"ultrabold\", 800),\n    (\"bold\", 700),  # Needs to come *after* extra/super/ultrabold!\n    (\"ultrablack\", 1000),\n    (\"superblack\", 1000),\n    (\"extrablack\", 1000),\n    (r\"\\bultra\", 1000),\n    (\"black\", 900),  # Needs to come *after* ultra/super/extrablack!\n    (\"heavy\", 900),\n]\nfont_family_aliases = {\n    'serif',\n    'sans-serif',\n    'sans serif',\n    'cursive',\n    'fantasy',\n    'monospace',\n    'sans',\n}\n\n\n# OS Font paths\ntry:\n    _HOME = Path.home()\nexcept Exception:  # Exceptions thrown by home() are not specified...\n    _HOME = Path(os.devnull)  # Just an arbitrary path with no children.\nMSFolders = \\\n    r'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders'\nMSFontDirectories = [\n    r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts',\n    r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts']\nMSUserFontDirectories = [\n    str(_HOME / 'AppData/Local/Microsoft/Windows/Fonts'),\n    str(_HOME / 'AppData/Roaming/Microsoft/Windows/Fonts'),\n]\nX11FontDirectories = [\n    # an old standard installation point\n    \"/usr/X11R6/lib/X11/fonts/TTF/\",\n    \"/usr/X11/lib/X11/fonts\",\n    # here is the new standard location for fonts\n    \"/usr/share/fonts/\",\n    # documented as a good place to install new fonts\n    \"/usr/local/share/fonts/\",\n    # common application, not really useful\n    \"/usr/lib/openoffice/share/fonts/truetype/\",\n    # user fonts\n    str((Path(os.environ.get('XDG_DATA_HOME') or _HOME / \".local/share\"))\n        / \"fonts\"),\n    str(_HOME / \".fonts\"),\n]\nOSXFontDirectories = [\n    \"/Library/Fonts/\",\n    \"/Network/Library/Fonts/\",\n    \"/System/Library/Fonts/\",\n    # fonts installed via MacPorts\n    \"/opt/local/share/fonts\",\n    # user fonts\n    str(_HOME / \"Library/Fonts\"),\n]\n\n\n@lru_cache(64)\ndef _cached_realpath(path):\n    return os.path.realpath(path)\n\n\ndef get_fontext_synonyms(fontext):\n    \"\"\"\n    Return a list of file extensions extensions that are synonyms for\n    the given file extension *fileext*.\n    \"\"\"\n    return {\n        'afm': ['afm'],\n        'otf': ['otf', 'ttc', 'ttf'],\n        'ttc': ['otf', 'ttc', 'ttf'],\n        'ttf': ['otf', 'ttc', 'ttf'],\n    }[fontext]\n\n\ndef list_fonts(directory, extensions):\n    \"\"\"\n    Return a list of all fonts matching any of the extensions, found\n    recursively under the directory.\n    \"\"\"\n    extensions = [\".\" + ext for ext in extensions]\n    return [os.path.join(dirpath, filename)\n            # os.walk ignores access errors, unlike Path.glob.\n            for dirpath, _, filenames in os.walk(directory)\n            for filename in filenames\n            if Path(filename).suffix.lower() in extensions]\n\n\ndef win32FontDirectory():\n    r\"\"\"\n    Return the user-specified font directory for Win32.  This is\n    looked up from the registry key ::\n\n      \\\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Fonts\n\n    If the key is not found, ``%WINDIR%\\Fonts`` will be returned.\n    \"\"\"\n    import winreg\n    try:\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, MSFolders) as user:\n            return winreg.QueryValueEx(user, 'Fonts')[0]\n    except OSError:\n        return os.path.join(os.environ['WINDIR'], 'Fonts')\n\n\ndef _win32RegistryFonts(reg_domain, base_dir):\n    r\"\"\"\n    Search for fonts in the Windows registry.\n\n    Parameters\n    ----------\n    reg_domain : int\n        The top level registry domain (e.g. HKEY_LOCAL_MACHINE).\n\n    base_dir : str\n        The path to the folder where the font files are usually located (e.g.\n        C:\\Windows\\Fonts). If only the filename of the font is stored in the\n        registry, the absolute path is built relative to this base directory.\n\n    Returns\n    -------\n    `set`\n        `pathlib.Path` objects with the absolute path to the font files found.\n\n    \"\"\"\n    import winreg\n    items = set()\n\n    for reg_path in MSFontDirectories:\n        try:\n            with winreg.OpenKey(reg_domain, reg_path) as local:\n                for j in range(winreg.QueryInfoKey(local)[1]):\n                    # value may contain the filename of the font or its\n                    # absolute path.\n                    key, value, tp = winreg.EnumValue(local, j)\n                    if not isinstance(value, str):\n                        continue\n                    try:\n                        # If value contains already an absolute path, then it\n                        # is not changed further.\n                        path = Path(base_dir, value).resolve()\n                    except RuntimeError:\n                        # Don't fail with invalid entries.\n                        continue\n\n                    items.add(path)\n        except (OSError, MemoryError):\n            continue\n\n    return items\n\n\ndef win32InstalledFonts(directory=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font directory, or use the\n    system directories if none given. Additionally, it is searched for user\n    fonts installed. A list of TrueType font filenames are returned by default,\n    or AFM fonts if *fontext* == 'afm'.\n    \"\"\"\n    import winreg\n\n    if directory is None:\n        directory = win32FontDirectory()\n\n    fontext = ['.' + ext for ext in get_fontext_synonyms(fontext)]\n\n    items = set()\n\n    # System fonts\n    items.update(_win32RegistryFonts(winreg.HKEY_LOCAL_MACHINE, directory))\n\n    # User fonts\n    for userdir in MSUserFontDirectories:\n        items.update(_win32RegistryFonts(winreg.HKEY_CURRENT_USER, userdir))\n\n    # Keep only paths with matching file extension.\n    return [str(path) for path in items if path.suffix.lower() in fontext]\n\n\n@lru_cache()\ndef _call_fc_list():\n    \"\"\"Cache and list the font filenames known to `fc-list`.\"\"\"\n    try:\n        if b'--format' not in subprocess.check_output(['fc-list', '--help']):\n            _log.warning(  # fontconfig 2.7 implemented --format.\n                'Matplotlib needs fontconfig>=2.7 to query system fonts.')\n            return []\n        out = subprocess.check_output(['fc-list', '--format=%{file}\\\\n'])\n    except (OSError, subprocess.CalledProcessError):\n        return []\n    return [os.fsdecode(fname) for fname in out.split(b'\\n')]\n\n\ndef get_fontconfig_fonts(fontext='ttf'):\n    \"\"\"List font filenames known to `fc-list` having the given extension.\"\"\"\n    fontext = ['.' + ext for ext in get_fontext_synonyms(fontext)]\n    return [fname for fname in _call_fc_list()\n            if Path(fname).suffix.lower() in fontext]\n\n\ndef findSystemFonts(fontpaths=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font paths.  If no paths are\n    given, will use a standard set of system paths, as well as the\n    list of fonts tracked by fontconfig if fontconfig is installed and\n    available.  A list of TrueType fonts are returned by default with\n    AFM fonts as an option.\n    \"\"\"\n    fontfiles = set()\n    fontexts = get_fontext_synonyms(fontext)\n\n    if fontpaths is None:\n        if sys.platform == 'win32':\n            fontpaths = MSUserFontDirectories + [win32FontDirectory()]\n            # now get all installed fonts directly...\n            fontfiles.update(win32InstalledFonts(fontext=fontext))\n        else:\n            fontpaths = X11FontDirectories\n            if sys.platform == 'darwin':\n                fontpaths = [*X11FontDirectories, *OSXFontDirectories]\n            fontfiles.update(get_fontconfig_fonts(fontext))\n\n    elif isinstance(fontpaths, str):\n        fontpaths = [fontpaths]\n\n    for path in fontpaths:\n        fontfiles.update(map(os.path.abspath, list_fonts(path, fontexts)))\n\n    return [fname for fname in fontfiles if os.path.exists(fname)]\n\n\nFontEntry = dataclasses.make_dataclass(\n    'FontEntry', [\n        ('fname', str, dataclasses.field(default='')),\n        ('name', str, dataclasses.field(default='')),\n        ('style', str, dataclasses.field(default='normal')),\n        ('variant', str, dataclasses.field(default='normal')),\n        ('weight', str, dataclasses.field(default='normal')),\n        ('stretch', str, dataclasses.field(default='normal')),\n        ('size', str, dataclasses.field(default='medium')),\n    ],\n    namespace={\n        '__doc__': \"\"\"\n    A class for storing Font properties.\n\n    It is used when populating the font lookup dictionary.\n    \"\"\"})\n\n\ndef ttfFontProperty(font):\n    \"\"\"\n    Extract information from a TrueType font file.\n\n    Parameters\n    ----------\n    font : `.FT2Font`\n        The TrueType font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n\n    \"\"\"\n    name = font.family_name\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    sfnt = font.get_sfnt()\n    mac_key = (1,  # platform: macintosh\n               0,  # id: roman\n               0)  # langid: english\n    ms_key = (3,  # platform: microsoft\n              1,  # id: unicode_cs\n              0x0409)  # langid: english_united_states\n\n    # These tables are actually mac_roman-encoded, but mac_roman support may be\n    # missing in some alternative Python implementations and we are only going\n    # to look for ASCII substrings, where any ASCII-compatible encoding works\n    # - or big-endian UTF-16, since important Microsoft fonts use that.\n    sfnt2 = (sfnt.get((*mac_key, 2), b'').decode('latin-1').lower() or\n             sfnt.get((*ms_key, 2), b'').decode('utf_16_be').lower())\n    sfnt4 = (sfnt.get((*mac_key, 4), b'').decode('latin-1').lower() or\n             sfnt.get((*ms_key, 4), b'').decode('utf_16_be').lower())\n\n    if sfnt4.find('oblique') >= 0:\n        style = 'oblique'\n    elif sfnt4.find('italic') >= 0:\n        style = 'italic'\n    elif sfnt2.find('regular') >= 0:\n        style = 'normal'\n    elif font.style_flags & ft2font.ITALIC:\n        style = 'italic'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    #  !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    # The weight-guessing algorithm is directly translated from fontconfig\n    # 2.13.1's FcFreeTypeQueryFaceInternal (fcfreetype.c).\n    wws_subfamily = 22\n    typographic_subfamily = 16\n    font_subfamily = 2\n    styles = [\n        sfnt.get((*mac_key, wws_subfamily), b'').decode('latin-1'),\n        sfnt.get((*mac_key, typographic_subfamily), b'').decode('latin-1'),\n        sfnt.get((*mac_key, font_subfamily), b'').decode('latin-1'),\n        sfnt.get((*ms_key, wws_subfamily), b'').decode('utf-16-be'),\n        sfnt.get((*ms_key, typographic_subfamily), b'').decode('utf-16-be'),\n        sfnt.get((*ms_key, font_subfamily), b'').decode('utf-16-be'),\n    ]\n    styles = [*filter(None, styles)] or [font.style_name]\n\n    def get_weight():  # From fontconfig's FcFreeTypeQueryFaceInternal.\n        # OS/2 table weight.\n        os2 = font.get_sfnt_table(\"OS/2\")\n        if os2 and os2[\"version\"] != 0xffff:\n            return os2[\"usWeightClass\"]\n        # PostScript font info weight.\n        try:\n            ps_font_info_weight = (\n                font.get_ps_font_info()[\"weight\"].replace(\" \", \"\") or \"\")\n        except ValueError:\n            pass\n        else:\n            for regex, weight in _weight_regexes:\n                if re.fullmatch(regex, ps_font_info_weight, re.I):\n                    return weight\n        # Style name weight.\n        for style in styles:\n            style = style.replace(\" \", \"\")\n            for regex, weight in _weight_regexes:\n                if re.search(regex, style, re.I):\n                    return weight\n        if font.style_flags & ft2font.BOLD:\n            return 700  # \"bold\"\n        return 500  # \"medium\", not \"regular\"!\n\n    weight = int(get_weight())\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n\n    if any(word in sfnt4 for word in ['narrow', 'condensed', 'cond']):\n        stretch = 'condensed'\n    elif 'demi cond' in sfnt4:\n        stretch = 'semi-condensed'\n    elif any(word in sfnt4 for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    if not font.scalable:\n        raise NotImplementedError(\"Non-scalable fonts are not supported\")\n    size = 'scalable'\n\n    return FontEntry(font.fname, name, style, variant, weight, stretch, size)\n\n\ndef afmFontProperty(fontpath, font):\n    \"\"\"\n    Extract information from an AFM font file.\n\n    Parameters\n    ----------\n    font : `.AFM`\n        The AFM font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n    \"\"\"\n\n    name = font.get_familyname()\n    fontname = font.get_fontname().lower()\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    if font.get_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n    if weight not in weight_dict:\n        weight = 'normal'\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif any(word in fontname for word in ['narrow', 'cond']):\n        stretch = 'condensed'\n    elif any(word in fontname for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)\n\n\nclass FontProperties:\n    \"\"\"\n    A class for storing and manipulating font properties.\n\n    The font properties are the six properties described in the\n    `W3C Cascading Style Sheet, Level 1\n    <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ font\n    specification and *math_fontfamily* for math fonts:\n\n    - family: A list of font names in decreasing order of priority.\n      The items may include a generic font family name, either\n      'sans-serif' (default), 'serif', 'cursive', 'fantasy', or 'monospace'.\n      In that case, the actual font to be used will be looked up\n      from the associated rcParam.\n\n    - style: Either 'normal' (default), 'italic' or 'oblique'.\n\n    - variant: Either 'normal' (default) or 'small-caps'.\n\n    - stretch: A numeric value in the range 0-1000 or one of\n      'ultra-condensed', 'extra-condensed', 'condensed',\n      'semi-condensed', 'normal' (default), 'semi-expanded', 'expanded',\n      'extra-expanded' or 'ultra-expanded'.\n\n    - weight: A numeric value in the range 0-1000 or one of\n      'ultralight', 'light', 'normal' (default), 'regular', 'book', 'medium',\n      'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy',\n      'extra bold', 'black'.\n\n    - size: Either an relative value of 'xx-small', 'x-small',\n      'small', 'medium', 'large', 'x-large', 'xx-large' or an\n      absolute font size, e.g., 10 (default).\n\n    - math_fontfamily: The family of fonts used to render math text; overrides\n      :rc:`mathtext.fontset`. Supported values are the same as the ones\n      supported by :rc:`mathtext.fontset`: 'dejavusans', 'dejavuserif', 'cm',\n      'stix', 'stixsans' and 'custom'.\n\n    Alternatively, a font may be specified using the absolute path to a font\n    file, by using the *fname* kwarg.  However, in this case, it is typically\n    simpler to just pass the path (as a `pathlib.Path`, not a `str`) to the\n    *font* kwarg of the `.Text` object.\n\n    The preferred usage of font sizes is to use the relative values,\n    e.g.,  'large', instead of absolute font sizes, e.g., 12.  This\n    approach allows all text sizes to be made larger or smaller based\n    on the font manager's default font size.\n\n    This class will also accept a fontconfig_ pattern_, if it is the only\n    argument provided.  This support does not depend on fontconfig; we are\n    merely borrowing its pattern syntax for use here.\n\n    .. _fontconfig: https://www.freedesktop.org/wiki/Software/fontconfig/\n    .. _pattern:\n       https://www.freedesktop.org/software/fontconfig/fontconfig-user.html\n\n    Note that Matplotlib's internal font manager and fontconfig use a\n    different algorithm to lookup fonts, so the results of the same pattern\n    may be different in Matplotlib than in other applications that use\n    fontconfig.\n    \"\"\"\n\n    def __init__(self, family=None, style=None, variant=None, weight=None,\n                 stretch=None, size=None,\n                 fname=None,  # if set, it's a hardcoded filename to use\n                 math_fontfamily=None):\n        self._family = _normalize_font_family(rcParams['font.family'])\n        self._slant = rcParams['font.style']\n        self._variant = rcParams['font.variant']\n        self._weight = rcParams['font.weight']\n        self._stretch = rcParams['font.stretch']\n        self._size = rcParams['font.size']\n        self._file = None\n        self._math_fontfamily = None\n\n        if isinstance(family, str):\n            # Treat family as a fontconfig pattern if it is the only\n            # parameter provided.\n            if (style is None and variant is None and weight is None and\n                    stretch is None and size is None and fname is None):\n                self.set_fontconfig_pattern(family)\n                return\n\n        self.set_family(family)\n        self.set_style(style)\n        self.set_variant(variant)\n        self.set_weight(weight)\n        self.set_stretch(stretch)\n        self.set_file(fname)\n        self.set_size(size)\n        self.set_math_fontfamily(math_fontfamily)\n\n    @classmethod\n    def _from_any(cls, arg):\n        \"\"\"\n        Generic constructor which can build a `.FontProperties` from any of the\n        following:\n\n        - a `.FontProperties`: it is passed through as is;\n        - `None`: a `.FontProperties` using rc values is used;\n        - an `os.PathLike`: it is used as path to the font file;\n        - a `str`: it is parsed as a fontconfig pattern;\n        - a `dict`: it is passed as ``**kwargs`` to `.FontProperties`.\n        \"\"\"\n        if isinstance(arg, cls):\n            return arg\n        elif arg is None:\n            return cls()\n        elif isinstance(arg, os.PathLike):\n            return cls(fname=arg)\n        elif isinstance(arg, str):\n            return cls(arg)\n        else:\n            return cls(**arg)\n\n    def __hash__(self):\n        l = (tuple(self.get_family()),\n             self.get_slant(),\n             self.get_variant(),\n             self.get_weight(),\n             self.get_stretch(),\n             self.get_size_in_points(),\n             self.get_file(),\n             self.get_math_fontfamily())\n        return hash(l)\n\n    def __eq__(self, other):\n        return hash(self) == hash(other)\n\n    def __str__(self):\n        return self.get_fontconfig_pattern()\n\n    def get_family(self):\n        \"\"\"\n        Return a list of font names that comprise the font family.\n        \"\"\"\n        return self._family\n\n    def get_name(self):\n        \"\"\"\n        Return the name of the font that best matches the font properties.\n        \"\"\"\n        return get_font(findfont(self)).family_name\n\n    def get_style(self):\n        \"\"\"\n        Return the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        return self._slant\n    get_slant = get_style\n\n    def get_variant(self):\n        \"\"\"\n        Return the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        return self._variant\n\n    def get_weight(self):\n        \"\"\"\n        Set the font weight.  Options are: A numeric value in the\n        range 0-1000 or one of 'light', 'normal', 'regular', 'book',\n        'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold',\n        'heavy', 'extra bold', 'black'\n        \"\"\"\n        return self._weight\n\n    def get_stretch(self):\n        \"\"\"\n        Return the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'.\n        \"\"\"\n        return self._stretch\n\n    def get_size(self):\n        \"\"\"\n        Return the font size.\n        \"\"\"\n        return self._size\n\n    def get_size_in_points(self):\n        return self._size\n\n    def get_file(self):\n        \"\"\"\n        Return the filename of the associated font.\n        \"\"\"\n        return self._file\n\n    def get_fontconfig_pattern(self):\n        \"\"\"\n        Get a fontconfig_ pattern_ suitable for looking up the font as\n        specified with fontconfig's ``fc-match`` utility.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        return generate_fontconfig_pattern(self)\n\n    def set_family(self, family):\n        \"\"\"\n        Change the font family.  May be either an alias (generic name\n        is CSS parlance), such as: 'serif', 'sans-serif', 'cursive',\n        'fantasy', or 'monospace', a real font name or a list of real\n        font names.  Real font names are not supported when\n        :rc:`text.usetex` is `True`.\n        \"\"\"\n        if family is None:\n            family = rcParams['font.family']\n        self._family = _normalize_font_family(family)\n    set_name = set_family\n\n    def set_style(self, style):\n        \"\"\"\n        Set the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        if style is None:\n            style = rcParams['font.style']\n        _api.check_in_list(['normal', 'italic', 'oblique'], style=style)\n        self._slant = style\n    set_slant = set_style\n\n    def set_variant(self, variant):\n        \"\"\"\n        Set the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        if variant is None:\n            variant = rcParams['font.variant']\n        _api.check_in_list(['normal', 'small-caps'], variant=variant)\n        self._variant = variant\n\n    def set_weight(self, weight):\n        \"\"\"\n        Set the font weight.  May be either a numeric value in the\n        range 0-1000 or one of 'ultralight', 'light', 'normal',\n        'regular', 'book', 'medium', 'roman', 'semibold', 'demibold',\n        'demi', 'bold', 'heavy', 'extra bold', 'black'\n        \"\"\"\n        if weight is None:\n            weight = rcParams['font.weight']\n        try:\n            weight = int(weight)\n            if weight < 0 or weight > 1000:\n                raise ValueError()\n        except ValueError:\n            if weight not in weight_dict:\n                raise ValueError(\"weight is invalid\")\n        self._weight = weight\n\n    def set_stretch(self, stretch):\n        \"\"\"\n        Set the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded' or\n        'ultra-expanded', or a numeric value in the range 0-1000.\n        \"\"\"\n        if stretch is None:\n            stretch = rcParams['font.stretch']\n        try:\n            stretch = int(stretch)\n            if stretch < 0 or stretch > 1000:\n                raise ValueError()\n        except ValueError as err:\n            if stretch not in stretch_dict:\n                raise ValueError(\"stretch is invalid\") from err\n        self._stretch = stretch\n\n    def set_size(self, size):\n        \"\"\"\n        Set the font size.  Either an relative value of 'xx-small',\n        'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'\n        or an absolute font size, e.g., 12.\n        \"\"\"\n        if size is None:\n            size = rcParams['font.size']\n        try:\n            size = float(size)\n        except ValueError:\n            try:\n                scale = font_scalings[size]\n            except KeyError as err:\n                raise ValueError(\n                    \"Size is invalid. Valid font size are \"\n                    + \", \".join(map(str, font_scalings))) from err\n            else:\n                size = scale * FontManager.get_default_size()\n        if size < 1.0:\n            _log.info('Fontsize %1.2f < 1.0 pt not allowed by FreeType. '\n                      'Setting fontsize = 1 pt', size)\n            size = 1.0\n        self._size = size\n\n    def set_file(self, file):\n        \"\"\"\n        Set the filename of the fontfile to use.  In this case, all\n        other properties will be ignored.\n        \"\"\"\n        self._file = os.fspath(file) if file is not None else None\n\n    def set_fontconfig_pattern(self, pattern):\n        \"\"\"\n        Set the properties by parsing a fontconfig_ *pattern*.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        for key, val in parse_fontconfig_pattern(pattern).items():\n            if type(val) == list:\n                getattr(self, \"set_\" + key)(val[0])\n            else:\n                getattr(self, \"set_\" + key)(val)\n\n    def get_math_fontfamily(self):\n        \"\"\"\n        Return the name of the font family used for math text.\n\n        The default font is :rc:`mathtext.fontset`.\n        \"\"\"\n        return self._math_fontfamily\n\n    def set_math_fontfamily(self, fontfamily):\n        \"\"\"\n        Set the font family for text in math mode.\n\n        If not set explicitly, :rc:`mathtext.fontset` will be used.\n\n        Parameters\n        ----------\n        fontfamily : str\n            The name of the font family.\n\n            Available font families are defined in the\n            matplotlibrc.template file\n            :ref:`here <customizing-with-matplotlibrc-files>`\n\n        See Also\n        --------\n        .text.Text.get_math_fontfamily\n        \"\"\"\n        if fontfamily is None:\n            fontfamily = rcParams['mathtext.fontset']\n        else:\n            valid_fonts = _validators['mathtext.fontset'].valid.values()\n            # _check_in_list() Validates the parameter math_fontfamily as\n            # if it were passed to rcParams['mathtext.fontset']\n            _api.check_in_list(valid_fonts, math_fontfamily=fontfamily)\n        self._math_fontfamily = fontfamily\n\n    def copy(self):\n        \"\"\"Return a copy of self.\"\"\"\n        new = type(self)()\n        vars(new).update(vars(self))\n        return new\n\n\nclass _JSONEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, FontManager):\n            return dict(o.__dict__, __class__='FontManager')\n        elif isinstance(o, FontEntry):\n            d = dict(o.__dict__, __class__='FontEntry')\n            try:\n                # Cache paths of fonts shipped with Matplotlib relative to the\n                # Matplotlib data path, which helps in the presence of venvs.\n                d[\"fname\"] = str(\n                    Path(d[\"fname\"]).relative_to(mpl.get_data_path()))\n            except ValueError:\n                pass\n            return d\n        else:\n            return super().default(o)\n\n\ndef _json_decode(o):\n    cls = o.pop('__class__', None)\n    if cls is None:\n        return o\n    elif cls == 'FontManager':\n        r = FontManager.__new__(FontManager)\n        r.__dict__.update(o)\n        return r\n    elif cls == 'FontEntry':\n        r = FontEntry.__new__(FontEntry)\n        r.__dict__.update(o)\n        if not os.path.isabs(r.fname):\n            r.fname = os.path.join(mpl.get_data_path(), r.fname)\n        return r\n    else:\n        raise ValueError(\"Don't know how to deserialize __class__=%s\" % cls)\n\n\ndef json_dump(data, filename):\n    \"\"\"\n    Dump `FontManager` *data* as JSON to the file named *filename*.\n\n    See Also\n    --------\n    json_load\n\n    Notes\n    -----\n    File paths that are children of the Matplotlib data path (typically, fonts\n    shipped with Matplotlib) are stored relative to that data path (to remain\n    valid across virtualenvs).\n\n    This function temporarily locks the output file to prevent multiple\n    processes from overwriting one another's output.\n    \"\"\"\n    with cbook._lock_path(filename), open(filename, 'w') as fh:\n        try:\n            json.dump(data, fh, cls=_JSONEncoder, indent=2)\n        except OSError as e:\n            _log.warning('Could not save font_manager cache {}'.format(e))\n\n\ndef json_load(filename):\n    \"\"\"\n    Load a `FontManager` from the JSON file named *filename*.\n\n    See Also\n    --------\n    json_dump\n    \"\"\"\n    with open(filename, 'r') as fh:\n        return json.load(fh, object_hook=_json_decode)\n\n\ndef _normalize_font_family(family):\n    if isinstance(family, str):\n        family = [family]\n    return family\n\n\nclass FontManager:\n    \"\"\"\n    On import, the `FontManager` singleton instance creates a list of ttf and\n    afm fonts and caches their `FontProperties`.  The `FontManager.findfont`\n    method does a nearest neighbor search to find the font that most closely\n    matches the specification.  If no good enough match is found, the default\n    font is returned.\n    \"\"\"\n    # Increment this version number whenever the font cache data\n    # format or behavior has changed and requires a existing font\n    # cache files to be rebuilt.\n    __version__ = 330\n\n    def __init__(self, size=None, weight='normal'):\n        self._version = self.__version__\n\n        self.__default_weight = weight\n        self.default_size = size\n\n        # Create list of font paths.\n        paths = [cbook._get_data_path('fonts', subdir)\n                 for subdir in ['ttf', 'afm', 'pdfcorefonts']]\n        _log.debug('font search path %s', str(paths))\n\n        self.defaultFamily = {\n            'ttf': 'DejaVu Sans',\n            'afm': 'Helvetica'}\n\n        self.afmlist = []\n        self.ttflist = []\n\n        # Delay the warning by 5s.\n        timer = Timer(5, lambda: _log.warning(\n            'Matplotlib is building the font cache; this may take a moment.'))\n        timer.start()\n        try:\n            for fontext in [\"afm\", \"ttf\"]:\n                for path in [*findSystemFonts(paths, fontext=fontext),\n                             *findSystemFonts(fontext=fontext)]:\n                    try:\n                        self.addfont(path)\n                    except OSError as exc:\n                        _log.info(\"Failed to open font file %s: %s\", path, exc)\n                    except Exception as exc:\n                        _log.info(\"Failed to extract font properties from %s: \"\n                                  \"%s\", path, exc)\n        finally:\n            timer.cancel()\n\n    def addfont(self, path):\n        \"\"\"\n        Cache the properties of the font at *path* to make it available to the\n        `FontManager`.  The type of font is inferred from the path suffix.\n\n        Parameters\n        ----------\n        path : str or path-like\n        \"\"\"\n        if Path(path).suffix.lower() == \".afm\":\n            with open(path, \"rb\") as fh:\n                font = afm.AFM(fh)\n            prop = afmFontProperty(path, font)\n            self.afmlist.append(prop)\n        else:\n            font = ft2font.FT2Font(path)\n            prop = ttfFontProperty(font)\n            self.ttflist.append(prop)\n\n    @property\n    def defaultFont(self):\n        # Lazily evaluated (findfont then caches the result) to avoid including\n        # the venv path in the json serialization.\n        return {ext: self.findfont(family, fontext=ext)\n                for ext, family in self.defaultFamily.items()}\n\n    def get_default_weight(self):\n        \"\"\"\n        Return the default font weight.\n        \"\"\"\n        return self.__default_weight\n\n    @staticmethod\n    def get_default_size():\n        \"\"\"\n        Return the default font size.\n        \"\"\"\n        return rcParams['font.size']\n\n    def set_default_weight(self, weight):\n        \"\"\"\n        Set the default font weight.  The initial value is 'normal'.\n        \"\"\"\n        self.__default_weight = weight\n\n    @staticmethod\n    def _expand_aliases(family):\n        if family in ('sans', 'sans serif'):\n            family = 'sans-serif'\n        return rcParams['font.' + family]\n\n    # Each of the scoring functions below should return a value between\n    # 0.0 (perfect match) and 1.0 (terrible match)\n    def score_family(self, families, family2):\n        \"\"\"\n        Return a match score between the list of font families in\n        *families* and the font family name *family2*.\n\n        An exact match at the head of the list returns 0.0.\n\n        A match further down the list will return between 0 and 1.\n\n        No match will return 1.0.\n        \"\"\"\n        if not isinstance(families, (list, tuple)):\n            families = [families]\n        elif len(families) == 0:\n            return 1.0\n        family2 = family2.lower()\n        step = 1 / len(families)\n        for i, family1 in enumerate(families):\n            family1 = family1.lower()\n            if family1 in font_family_aliases:\n                options = [*map(str.lower, self._expand_aliases(family1))]\n                if family2 in options:\n                    idx = options.index(family2)\n                    return (i + (idx / len(options))) * step\n            elif family1 == family2:\n                # The score should be weighted by where in the\n                # list the font was found.\n                return i * step\n        return 1.0\n\n    def score_style(self, style1, style2):\n        \"\"\"\n        Return a match score between *style1* and *style2*.\n\n        An exact match returns 0.0.\n\n        A match between 'italic' and 'oblique' returns 0.1.\n\n        No match returns 1.0.\n        \"\"\"\n        if style1 == style2:\n            return 0.0\n        elif (style1 in ('italic', 'oblique')\n              and style2 in ('italic', 'oblique')):\n            return 0.1\n        return 1.0\n\n    def score_variant(self, variant1, variant2):\n        \"\"\"\n        Return a match score between *variant1* and *variant2*.\n\n        An exact match returns 0.0, otherwise 1.0.\n        \"\"\"\n        if variant1 == variant2:\n            return 0.0\n        else:\n            return 1.0\n\n    def score_stretch(self, stretch1, stretch2):\n        \"\"\"\n        Return a match score between *stretch1* and *stretch2*.\n\n        The result is the absolute value of the difference between the\n        CSS numeric values of *stretch1* and *stretch2*, normalized\n        between 0.0 and 1.0.\n        \"\"\"\n        try:\n            stretchval1 = int(stretch1)\n        except ValueError:\n            stretchval1 = stretch_dict.get(stretch1, 500)\n        try:\n            stretchval2 = int(stretch2)\n        except ValueError:\n            stretchval2 = stretch_dict.get(stretch2, 500)\n        return abs(stretchval1 - stretchval2) / 1000.0\n\n    def score_weight(self, weight1, weight2):\n        \"\"\"\n        Return a match score between *weight1* and *weight2*.\n\n        The result is 0.0 if both weight1 and weight 2 are given as strings\n        and have the same value.\n\n        Otherwise, the result is the absolute value of the difference between\n        the CSS numeric values of *weight1* and *weight2*, normalized between\n        0.05 and 1.0.\n        \"\"\"\n        # exact match of the weight names, e.g. weight1 == weight2 == \"regular\"\n        if cbook._str_equal(weight1, weight2):\n            return 0.0\n        w1 = weight1 if isinstance(weight1, Number) else weight_dict[weight1]\n        w2 = weight2 if isinstance(weight2, Number) else weight_dict[weight2]\n        return 0.95 * (abs(w1 - w2) / 1000) + 0.05\n\n    def score_size(self, size1, size2):\n        \"\"\"\n        Return a match score between *size1* and *size2*.\n\n        If *size2* (the size specified in the font file) is 'scalable', this\n        function always returns 0.0, since any font size can be generated.\n\n        Otherwise, the result is the absolute distance between *size1* and\n        *size2*, normalized so that the usual range of font sizes (6pt -\n        72pt) will lie between 0.0 and 1.0.\n        \"\"\"\n        if size2 == 'scalable':\n            return 0.0\n        # Size value should have already been\n        try:\n            sizeval1 = float(size1)\n        except ValueError:\n            sizeval1 = self.default_size * font_scalings[size1]\n        try:\n            sizeval2 = float(size2)\n        except ValueError:\n            return 1.0\n        return abs(sizeval1 - sizeval2) / 72\n\n    def findfont(self, prop, fontext='ttf', directory=None,\n                 fallback_to_default=True, rebuild_if_missing=True):\n        \"\"\"\n        Find a font that most closely matches the given font properties.\n\n        Parameters\n        ----------\n        prop : str or `~matplotlib.font_manager.FontProperties`\n            The font properties to search for. This can be either a\n            `.FontProperties` object or a string defining a\n            `fontconfig patterns`_.\n\n        fontext : {'ttf', 'afm'}, default: 'ttf'\n            The extension of the font file:\n\n            - 'ttf': TrueType and OpenType fonts (.ttf, .ttc, .otf)\n            - 'afm': Adobe Font Metrics (.afm)\n\n        directory : str, optional\n            If given, only search this directory and its subdirectories.\n\n        fallback_to_default : bool\n            If True, will fallback to the default font family (usually\n            \"DejaVu Sans\" or \"Helvetica\") if the first lookup hard-fails.\n\n        rebuild_if_missing : bool\n            Whether to rebuild the font cache and search again if the first\n            match appears to point to a nonexisting font (i.e., the font cache\n            contains outdated entries).\n\n        Returns\n        -------\n        str\n            The filename of the best matching font.\n\n        Notes\n        -----\n        This performs a nearest neighbor search.  Each font is given a\n        similarity score to the target font properties.  The first font with\n        the highest score is returned.  If no matches below a certain\n        threshold are found, the default font (usually DejaVu Sans) is\n        returned.\n\n        The result is cached, so subsequent lookups don't have to\n        perform the O(n) nearest neighbor search.\n\n        See the `W3C Cascading Style Sheet, Level 1\n        <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ documentation\n        for a description of the font finding algorithm.\n\n        .. _fontconfig patterns:\n           https://www.freedesktop.org/software/fontconfig/fontconfig-user.html\n        \"\"\"\n        # Pass the relevant rcParams (and the font manager, as `self`) to\n        # _findfont_cached so to prevent using a stale cache entry after an\n        # rcParam was changed.\n        rc_params = tuple(tuple(rcParams[key]) for key in [\n            \"font.serif\", \"font.sans-serif\", \"font.cursive\", \"font.fantasy\",\n            \"font.monospace\"])\n        return self._findfont_cached(\n            prop, fontext, directory, fallback_to_default, rebuild_if_missing,\n            rc_params)\n\n    @lru_cache()\n    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        prop = FontProperties._from_any(prop)\n\n        fname = prop.get_file()\n        if fname is not None:\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        _log.debug('findfont: Matching %s.', prop)\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            # Matching family should have top priority, so multiply it by 10.\n            score = (self.score_family(prop.get_family(), font.name) * 10\n                     + self.score_style(prop.get_style(), font.style)\n                     + self.score_variant(prop.get_variant(), font.variant)\n                     + self.score_weight(prop.get_weight(), font.weight)\n                     + self.score_stretch(prop.get_stretch(), font.stretch)\n                     + self.score_size(prop.get_size(), font.size))\n            _log.debug('findfont: score(%s) = %s', font, score)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                _log.warning(\n                    'findfont: Font family %s not found. Falling back to %s.',\n                    prop.get_family(), self.defaultFamily[fontext])\n                for family in map(str.lower, prop.get_family()):\n                    if family in font_family_aliases:\n                        _log.warning(\n                            \"findfont: Generic family %r not found because \"\n                            \"none of the following families were found: %s\",\n                            family, \", \".join(self._expand_aliases(family)))\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory,\n                                     fallback_to_default=False)\n            else:\n                raise ValueError(f\"Failed to find font {prop}, and fallback \"\n                                 f\"to the default font was disabled\")\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                new_fm = _load_fontmanager(try_read_cache=False)\n                # Replace self by the new fontmanager, because users may have\n                # a reference to this specific instance.\n                # TODO: _load_fontmanager should really be (used by) a method\n                # modifying the instance in place.\n                vars(self).update(vars(new_fm))\n                return self.findfont(\n                    prop, fontext, directory, rebuild_if_missing=False)\n            else:\n                raise ValueError(\"No valid font could be found\")\n\n        return _cached_realpath(result)\n\n\n@lru_cache()\ndef is_opentype_cff_font(filename):\n    \"\"\"\n    Return whether the given font is a Postscript Compact Font Format Font\n    embedded in an OpenType wrapper.  Used by the PostScript and PDF backends\n    that can not subset these fonts.\n    \"\"\"\n    if os.path.splitext(filename)[1].lower() == '.otf':\n        with open(filename, 'rb') as fd:\n            return fd.read(4) == b\"OTTO\"\n    else:\n        return False\n\n\n@lru_cache(64)\ndef _get_font(filename, hinting_factor, *, _kerning_factor, thread_id):\n    return ft2font.FT2Font(\n        filename, hinting_factor, _kerning_factor=_kerning_factor)\n\n\n# FT2Font objects cannot be used across fork()s because they reference the same\n# FT_Library object.  While invalidating *all* existing FT2Fonts after a fork\n# would be too complicated to be worth it, the main way FT2Fonts get reused is\n# via the cache of _get_font, which we can empty upon forking (in Py3.7+).\nif hasattr(os, \"register_at_fork\"):\n    os.register_at_fork(after_in_child=_get_font.cache_clear)\n\n\ndef get_font(filename, hinting_factor=None):\n    # Resolving the path avoids embedding the font twice in pdf/ps output if a\n    # single font is selected using two different relative paths.\n    filename = _cached_realpath(filename)\n    if hinting_factor is None:\n        hinting_factor = rcParams['text.hinting_factor']\n    # also key on the thread ID to prevent segfaults with multi-threading\n    return _get_font(filename, hinting_factor,\n                     _kerning_factor=rcParams['text.kerning_factor'],\n                     thread_id=threading.get_ident())\n\n\ndef _load_fontmanager(*, try_read_cache=True):\n    fm_path = Path(\n        mpl.get_cachedir(), f\"fontlist-v{FontManager.__version__}.json\")\n    if try_read_cache:\n        try:\n            fm = json_load(fm_path)\n        except Exception:\n            pass\n        else:\n            if getattr(fm, \"_version\", object()) == FontManager.__version__:\n                _log.debug(\"Using fontManager instance from %s\", fm_path)\n                return fm\n    fm = FontManager()\n    json_dump(fm, fm_path)\n    _log.info(\"generated new fontManager\")\n    return fm\n\n\nfontManager = _load_fontmanager()\nfindfont = fontManager.findfont\n"
    }
  ]
}