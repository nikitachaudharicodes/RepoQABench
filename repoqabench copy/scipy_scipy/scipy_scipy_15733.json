{
  "repo_name": "scipy_scipy",
  "issue_id": "15733",
  "issue_description": "# DEP: remove quiet parameter from fitpack\n\nIt's been deprecated for over 7 years, see https://github.com/scipy/scipy/pull/4003.",
  "issue_comments": [
    {
      "id": 1074173522,
      "user": "j-bowhay",
      "body": "As far as I can see this is only deprecated in documentation so needs a proper warning before it can be removed."
    },
    {
      "id": 1075687687,
      "user": "h-vetinari",
      "body": "I remember looking at the [code](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py) but forgot to comment then.\r\n\r\nThe deprecation is going to be a bit tricky, because the current default is `quiet=1`, and the number is then both used\r\nas an int:\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L225-L227\r\nand as a boolean\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L294-L297\r\n\r\nAt the same time, it _doesn't_ cover the following warning\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L298-L300\r\n... so `quiet` and `full_output` are somewhat working at odds.\r\n\r\nThe whole code there is not a small amount of baroque, like how the error messages are outsourced into a dict [`_iermess`](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py#L52-L69), but wait!, there's [`_iermess2`](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py#L71-L100) which is the same but more extensive? 🤔 \r\n\r\nI think that's why I ended up not commenting - the closer I looked, the more parts I discovered that need substantial attention. 😅 "
    },
    {
      "id": 1075688643,
      "user": "j-bowhay",
      "body": "yes that's why I deleted my comment, I realised it was more messy that I first thought!"
    },
    {
      "id": 1075690706,
      "user": "j-bowhay",
      "body": "This is also tricky because the default behaviour is also the deprecated behaviour"
    },
    {
      "id": 1080027290,
      "user": "h-vetinari",
      "body": "The only sensible thing IMO is to re-deprecate this properly (together with a clean-up of how it's used) and remove it in 1.11"
    },
    {
      "id": 1147761820,
      "user": "h-vetinari",
      "body": "Changing milestones after 1.9 branched"
    },
    {
      "id": 1184923917,
      "user": "j-bowhay",
      "body": "@h-vetinari @ev-br do either of you have a preference on how to do this? My thought is you change the default value to `quiet=0` and raise a deprecation warning for non-zero values saying quiet will be removed after two releases. Of course the other approach would be to leave the default value as is and raise a deprecation warning saying the default value will change to 0 and then another cycle to remove quiet completely. I dont see how it is going to be possible to do this without users seeing new warnings in their code (either runtime warnings for the first option or deprecation warning for the second) but the first option seems preferable to me at least as it gets this dealt with faster. "
    },
    {
      "id": 1185205651,
      "user": "ev-br",
      "body": "I've no preference on this. Whichever is faster and simpler?\r\n"
    },
    {
      "id": 1185241672,
      "user": "h-vetinari",
      "body": "I think the two most important rules are:\r\n* There must be a way to run the code without warnings \r\n* We strive not to break behaviour unannounced\r\n\r\nIt's debatable if a change in logging behaviour is a big enough break that it would really inconvenience anyone, so from that POV I'd be fine with just changing (and documenting) it. This is quite an exception though (and arguably it would be cleaner to go through the full deprecation cycle) - for any change affecting the result of a computation I wouldn't agree to do that."
    },
    {
      "id": 1185260767,
      "user": "j-bowhay",
      "body": "> * There must be a way to run the code without warnings\r\n\r\nJust to clarify, does this include the user filtering the warnings themselves?"
    },
    {
      "id": 1185263892,
      "user": "h-vetinari",
      "body": "> Just to clarify, does this include the user filtering the warnings themselves?\r\n\r\nIMO no (though it's clearly possible to do, it's not what we should impose on them)."
    },
    {
      "id": 1185276411,
      "user": "j-bowhay",
      "body": "I am beginning to think we should just remove the deprecation from the docstring as the deprecation is calling for the user to filter the warnings themselves:\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L174-L175\r\nSo following this through is just going to result in a load of logging appear in users code. Also use of arguments to suppress logging is used else where in scipy eg. https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lobpcg.html#scipy.sparse.linalg.lobpcg"
    },
    {
      "id": 1191809208,
      "user": "j-bowhay",
      "body": "> I am beginning to think we should just remove the deprecation from the docstring as the deprecation is calling for the user to filter the warnings themselves:\r\n> \r\n> https://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L174-L175\r\n> \r\n> \r\n> So following this through is just going to result in a load of logging appear in users code. Also use of arguments to suppress logging is used else where in scipy eg. https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lobpcg.html#scipy.sparse.linalg.lobpcg\r\n\r\n@h-vetinari any thoughts on this?"
    },
    {
      "id": 1191824183,
      "user": "h-vetinari",
      "body": "@ev-br is the better person to ask on the long-term plans for this, but I'm fine to remove the docstring deprecation. 👍 "
    }
  ],
  "text_context": "# DEP: remove quiet parameter from fitpack\n\nIt's been deprecated for over 7 years, see https://github.com/scipy/scipy/pull/4003.\n\nAs far as I can see this is only deprecated in documentation so needs a proper warning before it can be removed.\n\nI remember looking at the [code](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py) but forgot to comment then.\r\n\r\nThe deprecation is going to be a bit tricky, because the current default is `quiet=1`, and the number is then both used\r\nas an int:\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L225-L227\r\nand as a boolean\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L294-L297\r\n\r\nAt the same time, it _doesn't_ cover the following warning\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L298-L300\r\n... so `quiet` and `full_output` are somewhat working at odds.\r\n\r\nThe whole code there is not a small amount of baroque, like how the error messages are outsourced into a dict [`_iermess`](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py#L52-L69), but wait!, there's [`_iermess2`](https://github.com/scipy/scipy/blob/main/scipy/interpolate/_fitpack_impl.py#L71-L100) which is the same but more extensive? 🤔 \r\n\r\nI think that's why I ended up not commenting - the closer I looked, the more parts I discovered that need substantial attention. 😅 \n\nyes that's why I deleted my comment, I realised it was more messy that I first thought!\n\nThis is also tricky because the default behaviour is also the deprecated behaviour\n\nThe only sensible thing IMO is to re-deprecate this properly (together with a clean-up of how it's used) and remove it in 1.11\n\nChanging milestones after 1.9 branched\n\n@h-vetinari @ev-br do either of you have a preference on how to do this? My thought is you change the default value to `quiet=0` and raise a deprecation warning for non-zero values saying quiet will be removed after two releases. Of course the other approach would be to leave the default value as is and raise a deprecation warning saying the default value will change to 0 and then another cycle to remove quiet completely. I dont see how it is going to be possible to do this without users seeing new warnings in their code (either runtime warnings for the first option or deprecation warning for the second) but the first option seems preferable to me at least as it gets this dealt with faster. \n\nI've no preference on this. Whichever is faster and simpler?\r\n\n\nI think the two most important rules are:\r\n* There must be a way to run the code without warnings \r\n* We strive not to break behaviour unannounced\r\n\r\nIt's debatable if a change in logging behaviour is a big enough break that it would really inconvenience anyone, so from that POV I'd be fine with just changing (and documenting) it. This is quite an exception though (and arguably it would be cleaner to go through the full deprecation cycle) - for any change affecting the result of a computation I wouldn't agree to do that.\n\n> * There must be a way to run the code without warnings\r\n\r\nJust to clarify, does this include the user filtering the warnings themselves?\n\n> Just to clarify, does this include the user filtering the warnings themselves?\r\n\r\nIMO no (though it's clearly possible to do, it's not what we should impose on them).\n\nI am beginning to think we should just remove the deprecation from the docstring as the deprecation is calling for the user to filter the warnings themselves:\r\nhttps://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L174-L175\r\nSo following this through is just going to result in a load of logging appear in users code. Also use of arguments to suppress logging is used else where in scipy eg. https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lobpcg.html#scipy.sparse.linalg.lobpcg\n\n> I am beginning to think we should just remove the deprecation from the docstring as the deprecation is calling for the user to filter the warnings themselves:\r\n> \r\n> https://github.com/scipy/scipy/blob/59d974bf14ff8c82f3353e2d2a9282d9bda67db5/scipy/interpolate/_fitpack_impl.py#L174-L175\r\n> \r\n> \r\n> So following this through is just going to result in a load of logging appear in users code. Also use of arguments to suppress logging is used else where in scipy eg. https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lobpcg.html#scipy.sparse.linalg.lobpcg\r\n\r\n@h-vetinari any thoughts on this?\n\n@ev-br is the better person to ask on the long-term plans for this, but I'm fine to remove the docstring deprecation. 👍 ",
  "pr_link": "https://github.com/scipy/scipy/pull/4003",
  "code_context": [
    {
      "filename": "scipy/interpolate/fitpack.py",
      "content": "#!/usr/bin/env python\n\"\"\"\nfitpack (dierckx in netlib) --- A Python-C wrapper to FITPACK (by P. Dierckx).\n        FITPACK is a collection of FORTRAN programs for curve and surface\n        fitting with splines and tensor product splines.\n\nSee\n http://www.cs.kuleuven.ac.be/cwis/research/nalag/research/topics/fitpack.html\nor\n http://www.netlib.org/dierckx/index.html\n\nCopyright 2002 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@cens.ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the SciPy (BSD style) license.  See LICENSE.txt that came with\nthis distribution for specifics.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n\nTODO: Make interfaces to the following fitpack functions:\n    For univariate splines: cocosp, concon, fourco, insert\n    For bivariate splines: profil, regrid, parsur, surev\n\"\"\"\nfrom __future__ import division, print_function, absolute_import\n\n\n__all__ = ['splrep', 'splprep', 'splev', 'splint', 'sproot', 'spalde',\n    'bisplrep', 'bisplev', 'insert', 'splder', 'splantider']\n\nimport warnings\nimport numpy as np\nfrom . import _fitpack\nfrom numpy import atleast_1d, array, ones, zeros, sqrt, ravel, transpose, \\\n     dot, sin, cos, pi, arange, empty, iinfo, intc, asarray\nmyasarray = atleast_1d\n\n# Try to replace _fitpack interface with\n#  f2py-generated version\nfrom . import dfitpack\n\n\ndef _intc_overflow(x, msg=None):\n    \"\"\"Cast the value to an intc and raise an OverflowError if the value\n    cannot fit.\n    \"\"\"\n    if x > iinfo(intc).max:\n        if msg is None:\n            msg = '%r cannot fit into an intc' % x\n        raise OverflowError(msg)\n    return intc(x)\n\n\n_iermess = {0:[\"\"\"\\\n    The spline has a residual sum of squares fp such that abs(fp-s)/s<=0.001\"\"\",None],\n               -1:[\"\"\"\\\n    The spline is an interpolating spline (fp=0)\"\"\",None],\n               -2:[\"\"\"\\\n    The spline is weighted least-squares polynomial of degree k.\n    fp gives the upper bound fp0 for the smoothing factor s\"\"\",None],\n               1:[\"\"\"\\\n    The required storage space exceeds the available storage space.\n    Probable causes: data (x,y) size is too small or smoothing parameter s is too small (fp>s).\"\"\",ValueError],\n               2:[\"\"\"\\\n    A theoretically impossible results when finding a smoothin spline\n    with fp = s. Probably causes: s too small. (abs(fp-s)/s>0.001)\"\"\",ValueError],\n               3:[\"\"\"\\\n    The maximal number of iterations (20) allowed for finding smoothing\n    spline with fp=s has been reached. Probably causes: s too small.\n    (abs(fp-s)/s>0.001)\"\"\",ValueError],\n               10:[\"\"\"\\\n    Error on input data\"\"\",ValueError],\n               'unknown':[\"\"\"\\\n    An error occurred\"\"\",TypeError]}\n\n_iermess2 = {0:[\"\"\"\\\n    The spline has a residual sum of squares fp such that abs(fp-s)/s<=0.001\"\"\",None],\n            -1:[\"\"\"\\\n    The spline is an interpolating spline (fp=0)\"\"\",None],\n            -2:[\"\"\"\\\n    The spline is weighted least-squares polynomial of degree kx and ky.\n    fp gives the upper bound fp0 for the smoothing factor s\"\"\",None],\n            -3:[\"\"\"\\\n    Warning. The coefficients of the spline have been computed as the minimal\n    norm least-squares solution of a rank deficient system.\"\"\",None],\n            1:[\"\"\"\\\n    The required storage space exceeds the available storage space.\n    Probably causes: nxest or nyest too small or s is too small. (fp>s)\"\"\",ValueError],\n            2:[\"\"\"\\\n    A theoretically impossible results when finding a smoothin spline\n    with fp = s. Probably causes: s too small or badly chosen eps.\n    (abs(fp-s)/s>0.001)\"\"\",ValueError],\n            3:[\"\"\"\\\n    The maximal number of iterations (20) allowed for finding smoothing\n    spline with fp=s has been reached. Probably causes: s too small.\n    (abs(fp-s)/s>0.001)\"\"\",ValueError],\n            4:[\"\"\"\\\n    No more knots can be added because the number of B-spline coefficients\n    already exceeds the number of data points m. Probably causes: either\n    s or m too small. (fp>s)\"\"\",ValueError],\n            5:[\"\"\"\\\n    No more knots can be added because the additional knot would coincide\n    with an old one. Probably cause: s too small or too large a weight\n    to an inaccurate data point. (fp>s)\"\"\",ValueError],\n            10:[\"\"\"\\\n    Error on input data\"\"\",ValueError],\n            11:[\"\"\"\\\n    rwrk2 too small, i.e. there is not enough workspace for computing\n    the minimal least-squares solution of a rank deficient system of linear\n    equations.\"\"\",ValueError],\n            'unknown':[\"\"\"\\\n    An error occurred\"\"\",TypeError]}\n\n_parcur_cache = {'t': array([],float), 'wrk': array([],float),\n                 'iwrk':array([],intc), 'u': array([],float),'ub':0,'ue':1}\n\n\ndef splprep(x,w=None,u=None,ub=None,ue=None,k=3,task=0,s=None,t=None,\n            full_output=0,nest=None,per=0,quiet=1):\n    \"\"\"\n    Find the B-spline representation of an N-dimensional curve.\n\n    Given a list of N rank-1 arrays, `x`, which represent a curve in\n    N-dimensional space parametrized by `u`, find a smooth approximating\n    spline curve g(`u`). Uses the FORTRAN routine parcur from FITPACK.\n\n    Parameters\n    ----------\n    x : array_like\n        A list of sample vector arrays representing the curve.\n    w : array_like\n        Strictly positive rank-1 array of weights the same length as `x[0]`.\n        The weights are used in computing the weighted least-squares spline\n        fit. If the errors in the `x` values have standard-deviation given by\n        the vector d, then `w` should be 1/d. Default is ``ones(len(x[0]))``.\n    u : array_like, optional\n        An array of parameter values. If not given, these values are\n        calculated automatically as ``M = len(x[0])``, where\n\n            v[0] = 0\n\n            v[i] = v[i-1] + distance(`x[i]`, `x[i-1]`)\n\n            u[i] = v[i] / v[M-1]\n\n    ub, ue : int, optional\n        The end-points of the parameters interval.  Defaults to\n        u[0] and u[-1].\n    k : int, optional\n        Degree of the spline. Cubic splines are recommended.\n        Even values of `k` should be avoided especially with a small s-value.\n        ``1 <= k <= 5``, default is 3.\n    task : int, optional\n        If task==0 (default), find t and c for a given smoothing factor, s.\n        If task==1, find t and c for another value of the smoothing factor, s.\n        There must have been a previous call with task=0 or task=1\n        for the same set of data.\n        If task=-1 find the weighted least square spline for a given set of\n        knots, t.\n    s : float, optional\n        A smoothing condition.  The amount of smoothness is determined by\n        satisfying the conditions: ``sum((w * (y - g))**2,axis=0) <= s``,\n        where g(x) is the smoothed interpolation of (x,y).  The user can\n        use `s` to control the trade-off between closeness and smoothness\n        of fit.  Larger `s` means more smoothing while smaller values of `s`\n        indicate less smoothing. Recommended values of `s` depend on the\n        weights, w.  If the weights represent the inverse of the\n        standard-deviation of y, then a good `s` value should be found in\n        the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of\n        data points in x, y, and w.\n    t : int, optional\n        The knots needed for task=-1.\n    full_output : int, optional\n        If non-zero, then return optional outputs.\n    nest : int, optional\n        An over-estimate of the total number of knots of the spline to\n        help in determining the storage space.  By default nest=m/2.\n        Always large enough is nest=m+k+1.\n    per : int, optional\n       If non-zero, data points are considered periodic with period\n       ``x[m-1] - x[0]`` and a smooth periodic spline approximation is\n       returned.  Values of ``y[m-1]`` and ``w[m-1]`` are not used.\n    quiet : int, optional\n         Non-zero to suppress messages.\n         This parameter is deprecated; use standard Python warning filters\n         instead.\n\n    Returns\n    -------\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots, the B-spline\n        coefficients, and the degree of the spline.\n    u : array\n        An array of the values of the parameter.\n    fp : float\n        The weighted sum of squared residuals of the spline approximation.\n    ier : int\n        An integer flag about splrep success.  Success is indicated\n        if ier<=0. If ier in [1,2,3] an error occurred but was not raised.\n        Otherwise an error is raised.\n    msg : str\n        A message corresponding to the integer flag, ier.\n\n    See Also\n    --------\n    splrep, splev, sproot, spalde, splint,\n    bisplrep, bisplev\n    UnivariateSpline, BivariateSpline\n\n    Notes\n    -----\n    See `splev` for evaluation of the spline and its derivatives.\n\n    References\n    ----------\n    .. [1] P. Dierckx, \"Algorithms for smoothing data with periodic and\n        parametric splines, Computer Graphics and Image Processing\",\n        20 (1982) 171-184.\n    .. [2] P. Dierckx, \"Algorithms for smoothing data with periodic and\n        parametric splines\", report tw55, Dept. Computer Science,\n        K.U.Leuven, 1981.\n    .. [3] P. Dierckx, \"Curve and surface fitting with splines\", Monographs on\n        Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    if task <= 0:\n        _parcur_cache = {'t': array([],float), 'wrk': array([],float),\n                         'iwrk':array([],intc),'u': array([],float),\n                         'ub':0,'ue':1}\n    x = myasarray(x)\n    idim,m = x.shape\n    if per:\n        for i in range(idim):\n            if x[i][0] != x[i][-1]:\n                if quiet < 2:\n                    warnings.warn(RuntimeWarning('Setting x[%d][%d]=x[%d][0]' % (i,m,i)))\n                x[i][-1] = x[i][0]\n    if not 0 < idim < 11:\n        raise TypeError('0 < idim < 11 must hold')\n    if w is None:\n        w = ones(m, float)\n    else:\n        w = myasarray(w)\n    ipar = (u is not None)\n    if ipar:\n        _parcur_cache['u'] = u\n        if ub is None:\n            _parcur_cache['ub'] = u[0]\n        else:\n            _parcur_cache['ub'] = ub\n        if ue is None:\n            _parcur_cache['ue'] = u[-1]\n        else:\n            _parcur_cache['ue'] = ue\n    else:\n        _parcur_cache['u'] = zeros(m,float)\n    if not (1 <= k <= 5):\n        raise TypeError('1 <= k= %d <=5 must hold' % k)\n    if not (-1 <= task <= 1):\n        raise TypeError('task must be -1, 0 or 1')\n    if (not len(w) == m) or (ipar == 1 and (not len(u) == m)):\n        raise TypeError('Mismatch of input dimensions')\n    if s is None:\n        s = m-sqrt(2*m)\n    if t is None and task == -1:\n        raise TypeError('Knots must be given for task=-1')\n    if t is not None:\n        _parcur_cache['t'] = myasarray(t)\n    n = len(_parcur_cache['t'])\n    if task == -1 and n < 2*k+2:\n        raise TypeError('There must be at least 2*k+2 knots for task=-1')\n    if m <= k:\n        raise TypeError('m > k must hold')\n    if nest is None:\n        nest = m+2*k\n\n    if (task >= 0 and s == 0) or (nest < 0):\n        if per:\n            nest = m+2*k\n        else:\n            nest = m+k+1\n    nest = max(nest,2*k+3)\n    u = _parcur_cache['u']\n    ub = _parcur_cache['ub']\n    ue = _parcur_cache['ue']\n    t = _parcur_cache['t']\n    wrk = _parcur_cache['wrk']\n    iwrk = _parcur_cache['iwrk']\n    t,c,o = _fitpack._parcur(ravel(transpose(x)),w,u,ub,ue,k,task,ipar,s,t,\n                             nest,wrk,iwrk,per)\n    _parcur_cache['u'] = o['u']\n    _parcur_cache['ub'] = o['ub']\n    _parcur_cache['ue'] = o['ue']\n    _parcur_cache['t'] = t\n    _parcur_cache['wrk'] = o['wrk']\n    _parcur_cache['iwrk'] = o['iwrk']\n    ier,fp,n = o['ier'],o['fp'],len(t)\n    u = o['u']\n    c.shape = idim,n-k-1\n    tcku = [t,list(c),k],u\n    if ier <= 0 and not quiet:\n        warnings.warn(RuntimeWarning(_iermess[ier][0] +\n                                     \"\\tk=%d n=%d m=%d fp=%f s=%f\" %\n                                     (k, len(t), m, fp, s)))\n    if ier > 0 and not full_output:\n        if ier in [1,2,3]:\n            warnings.warn(RuntimeWarning(_iermess[ier][0]))\n        else:\n            try:\n                raise _iermess[ier][1](_iermess[ier][0])\n            except KeyError:\n                raise _iermess['unknown'][1](_iermess['unknown'][0])\n    if full_output:\n        try:\n            return tcku,fp,ier,_iermess[ier][0]\n        except KeyError:\n            return tcku,fp,ier,_iermess['unknown'][0]\n    else:\n        return tcku\n\n_curfit_cache = {'t': array([],float), 'wrk': array([],float),\n                 'iwrk':array([],intc)}\n\n\ndef splrep(x,y,w=None,xb=None,xe=None,k=3,task=0,s=None,t=None,\n           full_output=0,per=0,quiet=1):\n    \"\"\"\n    Find the B-spline representation of 1-D curve.\n\n    Given the set of data points ``(x[i], y[i])`` determine a smooth spline\n    approximation of degree k on the interval ``xb <= x <= xe``.\n\n    Parameters\n    ----------\n    x, y : array_like\n        The data points defining a curve y = f(x).\n    w : array_like\n        Strictly positive rank-1 array of weights the same length as x and y.\n        The weights are used in computing the weighted least-squares spline\n        fit. If the errors in the y values have standard-deviation given by the\n        vector d, then w should be 1/d. Default is ones(len(x)).\n    xb, xe : float\n        The interval to fit.  If None, these default to x[0] and x[-1]\n        respectively.\n    k : int\n        The order of the spline fit. It is recommended to use cubic splines.\n        Even order splines should be avoided especially with small s values.\n        1 <= k <= 5\n    task : {1, 0, -1}\n        If task==0 find t and c for a given smoothing factor, s.\n\n        If task==1 find t and c for another value of the smoothing factor, s.\n        There must have been a previous call with task=0 or task=1 for the same\n        set of data (t will be stored an used internally)\n\n        If task=-1 find the weighted least square spline for a given set of\n        knots, t. These should be interior knots as knots on the ends will be\n        added automatically.\n    s : float\n        A smoothing condition. The amount of smoothness is determined by\n        satisfying the conditions: sum((w * (y - g))**2,axis=0) <= s where g(x)\n        is the smoothed interpolation of (x,y). The user can use s to control\n        the tradeoff between closeness and smoothness of fit. Larger s means\n        more smoothing while smaller values of s indicate less smoothing.\n        Recommended values of s depend on the weights, w. If the weights\n        represent the inverse of the standard-deviation of y, then a good s\n        value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is\n        the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if\n        weights are supplied. s = 0.0 (interpolating) if no weights are\n        supplied.\n    t : array_like\n        The knots needed for task=-1. If given then task is automatically set\n        to -1.\n    full_output : bool\n        If non-zero, then return optional outputs.\n    per : bool\n        If non-zero, data points are considered periodic with period x[m-1] -\n        x[0] and a smooth periodic spline approximation is returned. Values of\n        y[m-1] and w[m-1] are not used.\n    quiet : bool\n        Non-zero to suppress messages.\n        This parameter is deprecated; use standard Python warning filters\n        instead.\n\n    Returns\n    -------\n    tck : tuple\n        (t,c,k) a tuple containing the vector of knots, the B-spline\n        coefficients, and the degree of the spline.\n    fp : array, optional\n        The weighted sum of squared residuals of the spline approximation.\n    ier : int, optional\n        An integer flag about splrep success. Success is indicated if ier<=0.\n        If ier in [1,2,3] an error occurred but was not raised. Otherwise an\n        error is raised.\n    msg : str, optional\n        A message corresponding to the integer flag, ier.\n\n    Notes\n    -----\n    See splev for evaluation of the spline and its derivatives.\n\n    The user is responsible for assuring that the values of *x* are unique.\n    Otherwise, *splrep* will not return sensible results.\n\n    See Also\n    --------\n    UnivariateSpline, BivariateSpline\n    splprep, splev, sproot, spalde, splint\n    bisplrep, bisplev\n\n    Notes\n    -----\n    See splev for evaluation of the spline and its derivatives. Uses the\n    FORTRAN routine curfit from FITPACK.\n\n    If provided, knots `t` must satisfy the Schoenberg-Whitney conditions,\n    i.e., there must be a subset of data points ``x[j]`` such that\n    ``t[j] < x[j] < t[j+k+1]``, for ``j=0, 1,...,n-k-2``.\n\n    References\n    ----------\n    Based on algorithms described in [1]_, [2]_, [3]_, and [4]_:\n\n    .. [1] P. Dierckx, \"An algorithm for smoothing, differentiation and\n       integration of experimental data using spline functions\",\n       J.Comp.Appl.Maths 1 (1975) 165-184.\n    .. [2] P. Dierckx, \"A fast algorithm for smoothing data on a rectangular\n       grid while using spline functions\", SIAM J.Numer.Anal. 19 (1982)\n       1286-1304.\n    .. [3] P. Dierckx, \"An improved algorithm for curve fitting with spline\n       functions\", report tw54, Dept. Computer Science,K.U. Leuven, 1981.\n    .. [4] P. Dierckx, \"Curve and surface fitting with splines\", Monographs on\n       Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n\n    >>> x = linspace(0, 10, 10)\n    >>> y = sin(x)\n    >>> tck = splrep(x, y)\n    >>> x2 = linspace(0, 10, 200)\n    >>> y2 = splev(x2, tck)\n    >>> plot(x, y, 'o', x2, y2)\n\n    \"\"\"\n    if task <= 0:\n        _curfit_cache = {}\n    x,y = map(myasarray,[x,y])\n    m = len(x)\n    if w is None:\n        w = ones(m,float)\n        if s is None:\n            s = 0.0\n    else:\n        w = myasarray(w)\n        if s is None:\n            s = m-sqrt(2*m)\n    if not len(w) == m:\n        raise TypeError('len(w)=%d is not equal to m=%d' % (len(w),m))\n    if (m != len(y)) or (m != len(w)):\n        raise TypeError('Lengths of the first three arguments (x,y,w) must be equal')\n    if not (1 <= k <= 5):\n        raise TypeError('Given degree of the spline (k=%d) is not supported. (1<=k<=5)' % k)\n    if m <= k:\n        raise TypeError('m > k must hold')\n    if xb is None:\n        xb = x[0]\n    if xe is None:\n        xe = x[-1]\n    if not (-1 <= task <= 1):\n        raise TypeError('task must be -1, 0 or 1')\n    if t is not None:\n        task = -1\n    if task == -1:\n        if t is None:\n            raise TypeError('Knots must be given for task=-1')\n        numknots = len(t)\n        _curfit_cache['t'] = empty((numknots + 2*k+2,),float)\n        _curfit_cache['t'][k+1:-k-1] = t\n        nest = len(_curfit_cache['t'])\n    elif task == 0:\n        if per:\n            nest = max(m+2*k,2*k+3)\n        else:\n            nest = max(m+k+1,2*k+3)\n        t = empty((nest,),float)\n        _curfit_cache['t'] = t\n    if task <= 0:\n        if per:\n            _curfit_cache['wrk'] = empty((m*(k+1)+nest*(8+5*k),),float)\n        else:\n            _curfit_cache['wrk'] = empty((m*(k+1)+nest*(7+3*k),),float)\n        _curfit_cache['iwrk'] = empty((nest,),intc)\n    try:\n        t = _curfit_cache['t']\n        wrk = _curfit_cache['wrk']\n        iwrk = _curfit_cache['iwrk']\n    except KeyError:\n        raise TypeError(\"must call with task=1 only after\"\n                        \" call with task=0,-1\")\n    if not per:\n        n,c,fp,ier = dfitpack.curfit(task, x, y, w, t, wrk, iwrk, xb, xe, k, s)\n    else:\n        n,c,fp,ier = dfitpack.percur(task, x, y, w, t, wrk, iwrk, k, s)\n    tck = (t[:n],c[:n],k)\n    if ier <= 0 and not quiet:\n        warnings.warn(RuntimeWarning(_iermess[ier][0]) +\n                               \"\\tk=%d n=%d m=%d fp=%f s=%f\" %\n                               (k, len(t), m, fp, s))\n    if ier > 0 and not full_output:\n        if ier in [1,2,3]:\n            warnings.warn(RuntimeWarning(+_iermess[ier][0]))\n        else:\n            try:\n                raise _iermess[ier][1](_iermess[ier][0])\n            except KeyError:\n                raise _iermess['unknown'][1](_iermess['unknown'][0])\n    if full_output:\n        try:\n            return tck,fp,ier,_iermess[ier][0]\n        except KeyError:\n            return tck,fp,ier,_iermess['unknown'][0]\n    else:\n        return tck\n\n\ndef _ntlist(l):  # return non-trivial list\n    return l\n    # if len(l)>1: return l\n    # return l[0]\n\n\ndef splev(x, tck, der=0, ext=0):\n    \"\"\"\n    Evaluate a B-spline or its derivatives.\n\n    Given the knots and coefficients of a B-spline representation, evaluate\n    the value of the smoothing polynomial and its derivatives.  This is a\n    wrapper around the FORTRAN routines splev and splder of FITPACK.\n\n    Parameters\n    ----------\n    x : array_like\n        A 1-D array of points at which to return the value of the smoothed\n        spline or its derivatives.  If `tck` was returned from `splprep`,\n        then the parameter values, u should be given.\n    tck : tuple\n        A sequence of length 3 returned by `splrep` or `splprep` containing\n        the knots, coefficients, and degree of the spline.\n    der : int\n        The order of derivative of the spline to compute (must be less than\n        or equal to k).\n    ext : int\n        Controls the value returned for elements of ``x`` not in the\n        interval defined by the knot sequence.\n\n        * if ext=0, return the extrapolated value.\n        * if ext=1, return 0\n        * if ext=2, raise a ValueError\n        * if ext=3, return the boundary value.\n\n        The default value is 0.\n\n    Returns\n    -------\n    y : ndarray or list of ndarrays\n        An array of values representing the spline function evaluated at\n        the points in ``x``.  If `tck` was returned from `splprep`, then this\n        is a list of arrays representing the curve in N-dimensional space.\n\n    See Also\n    --------\n    splprep, splrep, sproot, spalde, splint\n    bisplrep, bisplev\n\n    References\n    ----------\n    .. [1] C. de Boor, \"On calculating with b-splines\", J. Approximation\n        Theory, 6, p.50-62, 1972.\n    .. [2] M.G. Cox, \"The numerical evaluation of b-splines\", J. Inst. Maths\n        Applics, 10, p.134-149, 1972.\n    .. [3] P. Dierckx, \"Curve and surface fitting with splines\", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    t,c,k = tck\n    try:\n        c[0][0]\n        parametric = True\n    except:\n        parametric = False\n    if parametric:\n        return list(map(lambda c, x=x, t=t, k=k, der=der: splev(x, [t,c,k], der, ext), c))\n    else:\n        if not (0 <= der <= k):\n            raise ValueError(\"0<=der=%d<=k=%d must hold\" % (der,k))\n        if ext not in (0, 1, 2, 3):\n            raise ValueError(\"ext = %s not in (0, 1, 2, 3) \" % ext)\n\n        x = asarray(x)\n        shape = x.shape\n        x = atleast_1d(x)\n        y, ier = _fitpack._spl_(x, der, t, c, k, ext)\n\n        if ier == 10:\n            raise ValueError(\"Invalid input data\")\n        if ier == 1:\n            raise ValueError(\"Found x value not in the domain\")\n        if ier:\n            raise TypeError(\"An error occurred\")\n\n        return y.reshape(shape)\n\n\ndef splint(a,b,tck,full_output=0):\n    \"\"\"\n    Evaluate the definite integral of a B-spline.\n\n    Given the knots and coefficients of a B-spline, evaluate the definite\n    integral of the smoothing polynomial between two given points.\n\n    Parameters\n    ----------\n    a, b : float\n        The end-points of the integration interval.\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots, the B-spline\n        coefficients, and the degree of the spline (see `splev`).\n    full_output : int, optional\n        Non-zero to return optional output.\n\n    Returns\n    -------\n    integral : float\n        The resulting integral.\n    wrk : ndarray\n        An array containing the integrals of the normalized B-splines\n        defined on the set of knots.\n\n    Notes\n    -----\n    splint silently assumes that the spline function is zero outside the data\n    interval (a, b).\n\n    See Also\n    --------\n    splprep, splrep, sproot, spalde, splev\n    bisplrep, bisplev\n    UnivariateSpline, BivariateSpline\n\n    References\n    ----------\n    .. [1] P.W. Gaffney, The calculation of indefinite integrals of b-splines\",\n        J. Inst. Maths Applics, 17, p.37-41, 1976.\n    .. [2] P. Dierckx, \"Curve and surface fitting with splines\", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    t,c,k = tck\n    try:\n        c[0][0]\n        parametric = True\n    except:\n        parametric = False\n    if parametric:\n        return _ntlist(list(map(lambda c,a=a,b=b,t=t,k=k:splint(a,b,[t,c,k]),c)))\n    else:\n        aint,wrk = _fitpack._splint(t,c,k,a,b)\n        if full_output:\n            return aint,wrk\n        else:\n            return aint\n\n\ndef sproot(tck,mest=10):\n    \"\"\"\n    Find the roots of a cubic B-spline.\n\n    Given the knots (>=8) and coefficients of a cubic B-spline return the\n    roots of the spline.\n\n    Parameters\n    ----------\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots,\n        the B-spline coefficients, and the degree of the spline.\n        The number of knots must be >= 8, and the degree must be 3.\n        The knots must be a montonically increasing sequence.\n    mest : int\n        An estimate of the number of zeros (Default is 10).\n\n    Returns\n    -------\n    zeros : ndarray\n        An array giving the roots of the spline.\n\n    See also\n    --------\n    splprep, splrep, splint, spalde, splev\n    bisplrep, bisplev\n    UnivariateSpline, BivariateSpline\n\n\n    References\n    ----------\n    .. [1] C. de Boor, \"On calculating with b-splines\", J. Approximation\n        Theory, 6, p.50-62, 1972.\n    .. [2] M.G. Cox, \"The numerical evaluation of b-splines\", J. Inst. Maths\n        Applics, 10, p.134-149, 1972.\n    .. [3] P. Dierckx, \"Curve and surface fitting with splines\", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    t,c,k = tck\n    if k != 3:\n        raise ValueError(\"sproot works only for cubic (k=3) splines\")\n    try:\n        c[0][0]\n        parametric = True\n    except:\n        parametric = False\n    if parametric:\n        return _ntlist(list(map(lambda c,t=t,k=k,mest=mest:sproot([t,c,k],mest),c)))\n    else:\n        if len(t) < 8:\n            raise TypeError(\"The number of knots %d>=8\" % len(t))\n        z,ier = _fitpack._sproot(t,c,k,mest)\n        if ier == 10:\n            raise TypeError(\"Invalid input data. t1<=..<=t4<t5<..<tn-3<=..<=tn must hold.\")\n        if ier == 0:\n            return z\n        if ier == 1:\n            warnings.warn(RuntimeWarning(\"The number of zeros exceeds mest\"))\n            return z\n        raise TypeError(\"Unknown error\")\n\n\ndef spalde(x,tck):\n    \"\"\"\n    Evaluate all derivatives of a B-spline.\n\n    Given the knots and coefficients of a cubic B-spline compute all\n    derivatives up to order k at a point (or set of points).\n\n    Parameters\n    ----------\n    x : array_like\n        A point or a set of points at which to evaluate the derivatives.\n        Note that ``t(k) <= x <= t(n-k+1)`` must hold for each `x`.\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots,\n        the B-spline coefficients, and the degree of the spline.\n\n    Returns\n    -------\n    results : {ndarray, list of ndarrays}\n        An array (or a list of arrays) containing all derivatives\n        up to order k inclusive for each point `x`.\n\n    See Also\n    --------\n    splprep, splrep, splint, sproot, splev, bisplrep, bisplev,\n    UnivariateSpline, BivariateSpline\n\n    References\n    ----------\n    .. [1] de Boor C : On calculating with b-splines, J. Approximation Theory\n       6 (1972) 50-62.\n    .. [2] Cox M.G. : The numerical evaluation of b-splines, J. Inst. Maths\n       applics 10 (1972) 134-149.\n    .. [3] Dierckx P. : Curve and surface fitting with splines, Monographs on\n       Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    t,c,k = tck\n    try:\n        c[0][0]\n        parametric = True\n    except:\n        parametric = False\n    if parametric:\n        return _ntlist(list(map(lambda c,x=x,t=t,k=k:spalde(x,[t,c,k]),c)))\n    else:\n        x = myasarray(x)\n        if len(x) > 1:\n            return list(map(lambda x,tck=tck:spalde(x,tck),x))\n        d,ier = _fitpack._spalde(t,c,k,x[0])\n        if ier == 0:\n            return d\n        if ier == 10:\n            raise TypeError(\"Invalid input data. t(k)<=x<=t(n-k+1) must hold.\")\n        raise TypeError(\"Unknown error\")\n\n# def _curfit(x,y,w=None,xb=None,xe=None,k=3,task=0,s=None,t=None,\n#           full_output=0,nest=None,per=0,quiet=1):\n\n_surfit_cache = {'tx': array([],float),'ty': array([],float),\n                 'wrk': array([],float), 'iwrk':array([],intc)}\n\n\ndef bisplrep(x,y,z,w=None,xb=None,xe=None,yb=None,ye=None,kx=3,ky=3,task=0,\n             s=None,eps=1e-16,tx=None,ty=None,full_output=0,\n             nxest=None,nyest=None,quiet=1):\n    \"\"\"\n    Find a bivariate B-spline representation of a surface.\n\n    Given a set of data points (x[i], y[i], z[i]) representing a surface\n    z=f(x,y), compute a B-spline representation of the surface. Based on\n    the routine SURFIT from FITPACK.\n\n    Parameters\n    ----------\n    x, y, z : ndarray\n        Rank-1 arrays of data points.\n    w : ndarray, optional\n        Rank-1 array of weights. By default ``w=np.ones(len(x))``.\n    xb, xe : float, optional\n        End points of approximation interval in `x`.\n        By default ``xb = x.min(), xe=x.max()``.\n    yb, ye : float, optional\n        End points of approximation interval in `y`.\n        By default ``yb=y.min(), ye = y.max()``.\n    kx, ky : int, optional\n        The degrees of the spline (1 <= kx, ky <= 5).\n        Third order (kx=ky=3) is recommended.\n    task : int, optional\n        If task=0, find knots in x and y and coefficients for a given\n        smoothing factor, s.\n        If task=1, find knots and coefficients for another value of the\n        smoothing factor, s.  bisplrep must have been previously called\n        with task=0 or task=1.\n        If task=-1, find coefficients for a given set of knots tx, ty.\n    s : float, optional\n        A non-negative smoothing factor.  If weights correspond\n        to the inverse of the standard-deviation of the errors in z,\n        then a good s-value should be found in the range\n        ``(m-sqrt(2*m),m+sqrt(2*m))`` where m=len(x).\n    eps : float, optional\n        A threshold for determining the effective rank of an\n        over-determined linear system of equations (0 < eps < 1).\n        `eps` is not likely to need changing.\n    tx, ty : ndarray, optional\n        Rank-1 arrays of the knots of the spline for task=-1\n    full_output : int, optional\n        Non-zero to return optional outputs.\n    nxest, nyest : int, optional\n        Over-estimates of the total number of knots. If None then\n        ``nxest = max(kx+sqrt(m/2),2*kx+3)``,\n        ``nyest = max(ky+sqrt(m/2),2*ky+3)``.\n    quiet : int, optional\n        Non-zero to suppress printing of messages.\n        This parameter is deprecated; use standard Python warning filters\n        instead.\n\n    Returns\n    -------\n    tck : array_like\n        A list [tx, ty, c, kx, ky] containing the knots (tx, ty) and\n        coefficients (c) of the bivariate B-spline representation of the\n        surface along with the degree of the spline.\n    fp : ndarray\n        The weighted sum of squared residuals of the spline approximation.\n    ier : int\n        An integer flag about splrep success.  Success is indicated if\n        ier<=0. If ier in [1,2,3] an error occurred but was not raised.\n        Otherwise an error is raised.\n    msg : str\n        A message corresponding to the integer flag, ier.\n\n    See Also\n    --------\n    splprep, splrep, splint, sproot, splev\n    UnivariateSpline, BivariateSpline\n\n    Notes\n    -----\n    See `bisplev` to evaluate the value of the B-spline given its tck\n    representation.\n\n    References\n    ----------\n    .. [1] Dierckx P.:An algorithm for surface fitting with spline functions\n       Ima J. Numer. Anal. 1 (1981) 267-283.\n    .. [2] Dierckx P.:An algorithm for surface fitting with spline functions\n       report tw50, Dept. Computer Science,K.U.Leuven, 1980.\n    .. [3] Dierckx P.:Curve and surface fitting with splines, Monographs on\n       Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    x,y,z = map(myasarray,[x,y,z])\n    x,y,z = map(ravel,[x,y,z])  # ensure 1-d arrays.\n    m = len(x)\n    if not (m == len(y) == len(z)):\n        raise TypeError('len(x)==len(y)==len(z) must hold.')\n    if w is None:\n        w = ones(m,float)\n    else:\n        w = myasarray(w)\n    if not len(w) == m:\n        raise TypeError('len(w)=%d is not equal to m=%d' % (len(w), m))\n    if xb is None:\n        xb = x.min()\n    if xe is None:\n        xe = x.max()\n    if yb is None:\n        yb = y.min()\n    if ye is None:\n        ye = y.max()\n    if not (-1 <= task <= 1):\n        raise TypeError('task must be -1, 0 or 1')\n    if s is None:\n        s = m-sqrt(2*m)\n    if tx is None and task == -1:\n        raise TypeError('Knots_x must be given for task=-1')\n    if tx is not None:\n        _surfit_cache['tx'] = myasarray(tx)\n    nx = len(_surfit_cache['tx'])\n    if ty is None and task == -1:\n        raise TypeError('K nots_y must be given for task=-1')\n    if ty is not None:\n        _surfit_cache['ty'] = myasarray(ty)\n    ny = len(_surfit_cache['ty'])\n    if task == -1 and nx < 2*kx+2:\n        raise TypeError('There must be at least 2*kx+2 knots_x for task=-1')\n    if task == -1 and ny < 2*ky+2:\n        raise TypeError('There must be at least 2*ky+2 knots_x for task=-1')\n    if not ((1 <= kx <= 5) and (1 <= ky <= 5)):\n        raise TypeError('Given degree of the spline (kx,ky=%d,%d) is not supported. (1<=k<=5)' % (kx,ky))\n    if m < (kx+1)*(ky+1):\n        raise TypeError('m >= (kx+1)(ky+1) must hold')\n    if nxest is None:\n        nxest = int(kx+sqrt(m/2))\n    if nyest is None:\n        nyest = int(ky+sqrt(m/2))\n    nxest,nyest = max(nxest,2*kx+3),max(nyest,2*ky+3)\n    if task >= 0 and s == 0:\n        nxest = int(kx+sqrt(3*m))\n        nyest = int(ky+sqrt(3*m))\n    if task == -1:\n        _surfit_cache['tx'] = myasarray(tx)\n        _surfit_cache['ty'] = myasarray(ty)\n    tx,ty = _surfit_cache['tx'],_surfit_cache['ty']\n    wrk = _surfit_cache['wrk']\n    iwrk = _surfit_cache['iwrk']\n    u,v,km,ne = nxest-kx-1,nyest-ky-1,max(kx,ky)+1,max(nxest,nyest)\n    bx,by = kx*v+ky+1,ky*u+kx+1\n    b1,b2 = bx,bx+v-ky\n    if bx > by:\n        b1,b2 = by,by+u-kx\n    msg = \"Too many data points to interpolate\"\n    lwrk1 = _intc_overflow(u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1, msg=msg)\n    lwrk2 = _intc_overflow(u*v*(b2+1)+b2, msg=msg)\n    tx,ty,c,o = _fitpack._surfit(x,y,z,w,xb,xe,yb,ye,kx,ky,task,s,eps,\n                                   tx,ty,nxest,nyest,wrk,lwrk1,lwrk2)\n    _curfit_cache['tx'] = tx\n    _curfit_cache['ty'] = ty\n    _curfit_cache['wrk'] = o['wrk']\n    ier,fp = o['ier'],o['fp']\n    tck = [tx,ty,c,kx,ky]\n\n    ierm = min(11,max(-3,ier))\n    if ierm <= 0 and not quiet:\n        warnings.warn(RuntimeWarning(_iermess2[ierm][0]) +\n                                 \"\\tkx,ky=%d,%d nx,ny=%d,%d m=%d fp=%f s=%f\" %\n                                 (kx, ky, len(tx), len(ty), m, fp, s))\n    if ierm > 0 and not full_output:\n        if ier in [1,2,3,4,5]:\n            _mess = \"\\n\\tkx,ky=%d,%d nx,ny=%d,%d m=%d fp=%f s=%f\" % (kx,ky,len(tx),\n                                                                     len(ty),m,fp,s)\n            warnings.warn(RuntimeWarning(_iermess2[ierm][0] + _mess))\n        else:\n            try:\n                raise _iermess2[ierm][1](_iermess2[ierm][0])\n            except KeyError:\n                raise _iermess2['unknown'][1](_iermess2['unknown'][0])\n    if full_output:\n        try:\n            return tck,fp,ier,_iermess2[ierm][0]\n        except KeyError:\n            return tck,fp,ier,_iermess2['unknown'][0]\n    else:\n        return tck\n\n\ndef bisplev(x,y,tck,dx=0,dy=0):\n    \"\"\"\n    Evaluate a bivariate B-spline and its derivatives.\n\n    Return a rank-2 array of spline function values (or spline derivative\n    values) at points given by the cross-product of the rank-1 arrays `x` and\n    `y`.  In special cases, return an array or just a float if either `x` or\n    `y` or both are floats.  Based on BISPEV from FITPACK.\n\n    Parameters\n    ----------\n    x, y : ndarray\n        Rank-1 arrays specifying the domain over which to evaluate the\n        spline or its derivative.\n    tck : tuple\n        A sequence of length 5 returned by `bisplrep` containing the knot\n        locations, the coefficients, and the degree of the spline:\n        [tx, ty, c, kx, ky].\n    dx, dy : int, optional\n        The orders of the partial derivatives in `x` and `y` respectively.\n\n    Returns\n    -------\n    vals : ndarray\n        The B-spline or its derivative evaluated over the set formed by\n        the cross-product of `x` and `y`.\n\n    See Also\n    --------\n    splprep, splrep, splint, sproot, splev\n    UnivariateSpline, BivariateSpline\n\n    Notes\n    -----\n        See `bisplrep` to generate the `tck` representation.\n\n    References\n    ----------\n    .. [1] Dierckx P. : An algorithm for surface fitting\n       with spline functions\n       Ima J. Numer. Anal. 1 (1981) 267-283.\n    .. [2] Dierckx P. : An algorithm for surface fitting\n       with spline functions\n       report tw50, Dept. Computer Science,K.U.Leuven, 1980.\n    .. [3] Dierckx P. : Curve and surface fitting with splines,\n       Monographs on Numerical Analysis, Oxford University Press, 1993.\n\n    \"\"\"\n    tx,ty,c,kx,ky = tck\n    if not (0 <= dx < kx):\n        raise ValueError(\"0 <= dx = %d < kx = %d must hold\" % (dx,kx))\n    if not (0 <= dy < ky):\n        raise ValueError(\"0 <= dy = %d < ky = %d must hold\" % (dy,ky))\n    x,y = map(myasarray,[x,y])\n    if (len(x.shape) != 1) or (len(y.shape) != 1):\n        raise ValueError(\"First two entries should be rank-1 arrays.\")\n    z,ier = _fitpack._bispev(tx,ty,c,kx,ky,x,y,dx,dy)\n    if ier == 10:\n        raise ValueError(\"Invalid input data\")\n    if ier:\n        raise TypeError(\"An error occurred\")\n    z.shape = len(x),len(y)\n    if len(z) > 1:\n        return z\n    if len(z[0]) > 1:\n        return z[0]\n    return z[0][0]\n\n\ndef dblint(xa,xb,ya,yb,tck):\n    \"\"\"Evaluate the integral of a spline over area [xa,xb] x [ya,yb].\n\n    Parameters\n    ----------\n    xa, xb : float\n        The end-points of the x integration interval.\n    ya, yb : float\n        The end-points of the y integration interval.\n    tck : list [tx, ty, c, kx, ky]\n        A sequence of length 5 returned by bisplrep containing the knot\n        locations tx, ty, the coefficients c, and the degrees kx, ky\n        of the spline.\n\n    Returns\n    -------\n    integ : float\n        The value of the resulting integral.\n    \"\"\"\n    tx,ty,c,kx,ky = tck\n    return dfitpack.dblint(tx,ty,c,kx,ky,xa,xb,ya,yb)\n\n\ndef insert(x,tck,m=1,per=0):\n    \"\"\"\n    Insert knots into a B-spline.\n\n    Given the knots and coefficients of a B-spline representation, create a\n    new B-spline with a knot inserted `m` times at point `x`.\n    This is a wrapper around the FORTRAN routine insert of FITPACK.\n\n    Parameters\n    ----------\n    x (u) : array_like\n        A 1-D point at which to insert a new knot(s).  If `tck` was returned\n        from ``splprep``, then the parameter values, u should be given.\n    tck : tuple\n        A tuple (t,c,k) returned by ``splrep`` or ``splprep`` containing\n        the vector of knots, the B-spline coefficients,\n        and the degree of the spline.\n    m : int, optional\n        The number of times to insert the given knot (its multiplicity).\n        Default is 1.\n    per : int, optional\n        If non-zero, the input spline is considered periodic.\n\n    Returns\n    -------\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots, the B-spline\n        coefficients, and the degree of the new spline.\n        ``t(k+1) <= x <= t(n-k)``, where k is the degree of the spline.\n        In case of a periodic spline (``per != 0``) there must be\n        either at least k interior knots t(j) satisfying ``t(k+1)<t(j)<=x``\n        or at least k interior knots t(j) satisfying ``x<=t(j)<t(n-k)``.\n\n    Notes\n    -----\n    Based on algorithms from [1]_ and [2]_.\n\n    References\n    ----------\n    .. [1] W. Boehm, \"Inserting new knots into b-spline curves.\",\n        Computer Aided Design, 12, p.199-201, 1980.\n    .. [2] P. Dierckx, \"Curve and surface fitting with splines, Monographs on\n        Numerical Analysis\", Oxford University Press, 1993.\n\n    \"\"\"\n    t,c,k = tck\n    try:\n        c[0][0]\n        parametric = True\n    except:\n        parametric = False\n    if parametric:\n        cc = []\n        for c_vals in c:\n            tt, cc_val, kk = insert(x, [t, c_vals, k], m)\n            cc.append(cc_val)\n        return (tt, cc, kk)\n    else:\n        tt, cc, ier = _fitpack._insert(per, t, c, k, x, m)\n        if ier == 10:\n            raise ValueError(\"Invalid input data\")\n        if ier:\n            raise TypeError(\"An error occurred\")\n        return (tt, cc, k)\n\n\ndef splder(tck, n=1):\n    \"\"\"\n    Compute the spline representation of the derivative of a given spline\n\n    Parameters\n    ----------\n    tck : tuple of (t, c, k)\n        Spline whose derivative to compute\n    n : int, optional\n        Order of derivative to evaluate. Default: 1\n\n    Returns\n    -------\n    tck_der : tuple of (t2, c2, k2)\n        Spline of order k2=k-n representing the derivative\n        of the input spline.\n\n    Notes\n    -----\n\n    .. versionadded:: 0.13.0\n\n    See Also\n    --------\n    splantider, splev, spalde\n\n    Examples\n    --------\n    This can be used for finding maxima of a curve:\n\n    >>> from scipy.interpolate import splrep, splder, sproot\n    >>> x = np.linspace(0, 10, 70)\n    >>> y = np.sin(x)\n    >>> spl = splrep(x, y, k=4)\n\n    Now, differentiate the spline and find the zeros of the\n    derivative. (NB: `sproot` only works for order 3 splines, so we\n    fit an order 4 spline):\n\n    >>> dspl = splder(spl)\n    >>> sproot(dspl) / np.pi\n    array([ 0.50000001,  1.5       ,  2.49999998])\n\n    This agrees well with roots :math:`\\pi/2 + n\\pi` of\n    :math:`\\cos(x) = \\sin'(x)`.\n\n    \"\"\"\n    if n < 0:\n        return splantider(tck, -n)\n\n    t, c, k = tck\n\n    if n > k:\n        raise ValueError((\"Order of derivative (n = %r) must be <= \"\n                          \"order of spline (k = %r)\") % (n, tck[2]))\n\n    with np.errstate(invalid='raise', divide='raise'):\n        try:\n            for j in range(n):\n                # See e.g. Schumaker, Spline Functions: Basic Theory, Chapter 5\n\n                # Compute the denominator in the differentiation formula.\n                dt = t[k+1:-1] - t[1:-k-1]\n                # Compute the new coefficients\n                c = (c[1:-1-k] - c[:-2-k]) * k / dt\n                # Pad coefficient array to same size as knots (FITPACK convention)\n                c = np.r_[c, [0]*k]\n                # Adjust knots\n                t = t[1:-1]\n                k -= 1\n        except FloatingPointError:\n            raise ValueError((\"The spline has internal repeated knots \"\n                              \"and is not differentiable %d times\") % n)\n\n    return t, c, k\n\n\ndef splantider(tck, n=1):\n    \"\"\"\n    Compute the spline for the antiderivative (integral) of a given spline.\n\n    Parameters\n    ----------\n    tck : tuple of (t, c, k)\n        Spline whose antiderivative to compute\n    n : int, optional\n        Order of antiderivative to evaluate. Default: 1\n\n    Returns\n    -------\n    tck_ader : tuple of (t2, c2, k2)\n        Spline of order k2=k+n representing the antiderivative of the input\n        spline.\n\n    See Also\n    --------\n    splder, splev, spalde\n\n    Notes\n    -----\n    The `splder` function is the inverse operation of this function.\n    Namely, ``splder(splantider(tck))`` is identical to `tck`, modulo\n    rounding error.\n\n    .. versionadded:: 0.13.0\n\n    Examples\n    --------\n    >>> from scipy.interpolate import splrep, splder, splantider, splev\n    >>> x = np.linspace(0, np.pi/2, 70)\n    >>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n    >>> spl = splrep(x, y)\n\n    The derivative is the inverse operation of the antiderivative,\n    although some floating point error accumulates:\n\n    >>> splev(1.7, spl), splev(1.7, splder(splantider(spl)))\n    (array(2.1565429877197317), array(2.1565429877201865))\n\n    Antiderivative can be used to evaluate definite integrals:\n\n    >>> ispl = splantider(spl)\n    >>> splev(np.pi/2, ispl) - splev(0, ispl)\n    2.2572053588768486\n\n    This is indeed an approximation to the complete elliptic integral\n    :math:`K(m) = \\\\int_0^{\\\\pi/2} [1 - m\\\\sin^2 x]^{-1/2} dx`:\n\n    >>> from scipy.special import ellipk\n    >>> ellipk(0.8)\n    2.2572053268208538\n\n    \"\"\"\n    if n < 0:\n        return splder(tck, -n)\n\n    t, c, k = tck\n\n    for j in range(n):\n        # This is the inverse set of operations to splder.\n\n        # Compute the multiplier in the antiderivative formula.\n        dt = t[k+1:] - t[:-k-1]\n        # Compute the new coefficients\n        c = np.cumsum(c[:-k-1] * dt) / (k + 1)\n        c = np.r_[0, c, [c[-1]]*(k+2)]\n        # New knots\n        t = np.r_[t[0], t, t[-1]]\n        k += 1\n\n    return t, c, k\n"
    }
  ]
}