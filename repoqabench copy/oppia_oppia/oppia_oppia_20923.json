{
  "repo_name": "oppia_oppia",
  "issue_id": "20923",
  "issue_description": "# [BUG]: Chapter editor does not specify the number of characters required \n\n### Describe the bug\r\n\r\nChapter editor does not specify the number of characters required . It says \"Chapter title should be at most characters.\" but it's missing the number of characters \r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/story_editor/o0uT4VGw5zbW#/chapter_editor/node_1\r\n\r\n### Steps To Reproduce\r\n\r\n1. \r\n2. Log in\r\n3. Go to Topics and Skills Dashboard\r\n4. Locate Fractions\r\n5. Select a story\r\n6. Select a chapter\r\n7. Observe\r\n\r\n### Expected Behavior\r\n\r\n\"Chapter title should be at most 36 characters.\"\r\n\"Chapter description should be at most 156 characters.\" should be displayed\r\n\r\n### Screenshots/Videos\r\n\r\n<img width=\"1372\" alt=\"Screenshot 2024-08-30 at 4 40 13 PM\" src=\"https://github.com/user-attachments/assets/459f34da-d301-4f94-8bf5-e66a6cfdbf4d\">\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome, Firefox\r\n\r\n### Browser version\r\n\r\nChrome 126.0.6478.57, Firefox 127.0\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n",
  "issue_comments": [
    {
      "id": 2336593537,
      "user": "TARishabh",
      "body": "Hey @natashabag , I am facing an issue regarding the exploration id, can you suggest some dummy exploration id, so that i can replicate the issue?\r\n\r\n![image](https://github.com/user-attachments/assets/7f19185c-85d6-4aeb-9de6-f9fb05519cf2)\r\n"
    },
    {
      "id": 2351468799,
      "user": "TARishabh",
      "body": "Hey @seanlip @HardikGoyal2003 , can you please assign this issue to me?"
    },
    {
      "id": 2351477034,
      "user": "HardikGoyal2003",
      "body": "Hi @TARishabh  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue. Thanks!"
    },
    {
      "id": 2351498826,
      "user": "TARishabh",
      "body": "Hey @HardikGoyal2003, thank you so much for your guidance! I have gone through the wiki, and considering this issue has an \"Impact: Medium\" label, I feel confident about working on it.\r\n\r\nHere’s my proposed solution:\r\n\r\nSince the constants for the exploration title and chapter description lengths are already stored in constants.ts, I will import MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION into story-node-editor.component.ts.\r\n\r\nFiles to be changed:\r\nstory-node-editor.component.ts\r\n\r\nLet me know if this approach looks good!"
    },
    {
      "id": 2351556773,
      "user": "HardikGoyal2003",
      "body": "@TARishabh How will importing the constants fix this?"
    },
    {
      "id": 2351578685,
      "user": "TARishabh",
      "body": "@HardikGoyal2003 Currently, the story-node-editor.component.ts doesn't pass MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION to the story-node-editor.component.html. To resolve this, we need to import both constants from constants.ts and then bind them in the component so that the story-node-editor.component.html can display the character limits correctly.\r\n\r\nLet me know if that makes sense!\r\n\r\n"
    },
    {
      "id": 2351620521,
      "user": "HardikGoyal2003",
      "body": "@TARishabh Can you specify what do you mean by binding?\r\n"
    },
    {
      "id": 2351651147,
      "user": "TARishabh",
      "body": "@HardikGoyal2003 Currently, the story-node-editor.component.html expects MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION to be available, as shown in the attached image.\r\n\r\nHowever, these constants are not being passed from story-node-editor.component.ts. To resolve this, I propose importing both MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION from constants.ts into story-node-editor.component.ts, so they can be properly accessed and displayed in the HTML file.\r\n\r\n![image](https://github.com/user-attachments/assets/f25f7f6b-99c3-49a0-8dd1-b7c64a76abff)\r\n"
    },
    {
      "id": 2351957408,
      "user": "HardikGoyal2003",
      "body": "**Note:** This issue arose from the story editor migration [PR](https://github.com/oppia/oppia/pull/17968).\r\n\r\n@TARishabh Got it! The approach looks good! Thanks!!"
    },
    {
      "id": 2354690475,
      "user": "TARishabh",
      "body": "Hey @HardikGoyal2003 ,\r\n\r\nSince MAX_CHARS_IN_CHAPTER_DESCRIPTION is set to 152 in the constants.ts, I'll keep the description limit at 152 characters. The issue currently expects:\r\n\r\nTitle: max 36 characters.\r\nDescription: max 156 characters.\r\nLet me know if this works.\r\n\r\nThanks!"
    },
    {
      "id": 2354952636,
      "user": "TARishabh",
      "body": "Hey @HardikGoyal2003 , Let me know if this is working fine.\r\n\r\nhttps://github.com/user-attachments/assets/9523ceb9-80b8-496a-ab66-4b8c42ed43b3\r\n\r\n"
    },
    {
      "id": 2355160826,
      "user": "HardikGoyal2003",
      "body": "Hey @TARishabh, please verify if the MAX_CHARS_IN_CHAPTER_DESCRIPTION constant is utilized in any other files. Also, test it by entering a character count exceeding the specified limit."
    },
    {
      "id": 2355512093,
      "user": "TARishabh",
      "body": "@HardikGoyal2003 , I checked MAX_CHARS_IN_CHAPTER_DESCRIPTION, it used in:\r\nandroid_validation_constants.py\r\nstory-node-editor.component.html\r\nstory-node-editor.component.ts\r\n\r\nAnd yes, i have tested it by entering character counting more than 152, it's working fine."
    },
    {
      "id": 2355642787,
      "user": "HardikGoyal2003",
      "body": "@TARishabh, please adjust the UI to 152. Otherwise, the solution looks good; go ahead and create a PR!"
    }
  ],
  "text_context": "# [BUG]: Chapter editor does not specify the number of characters required \n\n### Describe the bug\r\n\r\nChapter editor does not specify the number of characters required . It says \"Chapter title should be at most characters.\" but it's missing the number of characters \r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/story_editor/o0uT4VGw5zbW#/chapter_editor/node_1\r\n\r\n### Steps To Reproduce\r\n\r\n1. \r\n2. Log in\r\n3. Go to Topics and Skills Dashboard\r\n4. Locate Fractions\r\n5. Select a story\r\n6. Select a chapter\r\n7. Observe\r\n\r\n### Expected Behavior\r\n\r\n\"Chapter title should be at most 36 characters.\"\r\n\"Chapter description should be at most 156 characters.\" should be displayed\r\n\r\n### Screenshots/Videos\r\n\r\n<img width=\"1372\" alt=\"Screenshot 2024-08-30 at 4 40 13 PM\" src=\"https://github.com/user-attachments/assets/459f34da-d301-4f94-8bf5-e66a6cfdbf4d\">\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome, Firefox\r\n\r\n### Browser version\r\n\r\nChrome 126.0.6478.57, Firefox 127.0\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n\n\nHey @natashabag , I am facing an issue regarding the exploration id, can you suggest some dummy exploration id, so that i can replicate the issue?\r\n\r\n![image](https://github.com/user-attachments/assets/7f19185c-85d6-4aeb-9de6-f9fb05519cf2)\r\n\n\nHey @seanlip @HardikGoyal2003 , can you please assign this issue to me?\n\nHi @TARishabh  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue. Thanks!\n\nHey @HardikGoyal2003, thank you so much for your guidance! I have gone through the wiki, and considering this issue has an \"Impact: Medium\" label, I feel confident about working on it.\r\n\r\nHere’s my proposed solution:\r\n\r\nSince the constants for the exploration title and chapter description lengths are already stored in constants.ts, I will import MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION into story-node-editor.component.ts.\r\n\r\nFiles to be changed:\r\nstory-node-editor.component.ts\r\n\r\nLet me know if this approach looks good!\n\n@TARishabh How will importing the constants fix this?\n\n@HardikGoyal2003 Currently, the story-node-editor.component.ts doesn't pass MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION to the story-node-editor.component.html. To resolve this, we need to import both constants from constants.ts and then bind them in the component so that the story-node-editor.component.html can display the character limits correctly.\r\n\r\nLet me know if that makes sense!\r\n\r\n\n\n@TARishabh Can you specify what do you mean by binding?\r\n\n\n@HardikGoyal2003 Currently, the story-node-editor.component.html expects MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION to be available, as shown in the attached image.\r\n\r\nHowever, these constants are not being passed from story-node-editor.component.ts. To resolve this, I propose importing both MAX_CHARS_IN_EXPLORATION_TITLE and MAX_CHARS_IN_CHAPTER_DESCRIPTION from constants.ts into story-node-editor.component.ts, so they can be properly accessed and displayed in the HTML file.\r\n\r\n![image](https://github.com/user-attachments/assets/f25f7f6b-99c3-49a0-8dd1-b7c64a76abff)\r\n\n\n**Note:** This issue arose from the story editor migration [PR](https://github.com/oppia/oppia/pull/17968).\r\n\r\n@TARishabh Got it! The approach looks good! Thanks!!\n\nHey @HardikGoyal2003 ,\r\n\r\nSince MAX_CHARS_IN_CHAPTER_DESCRIPTION is set to 152 in the constants.ts, I'll keep the description limit at 152 characters. The issue currently expects:\r\n\r\nTitle: max 36 characters.\r\nDescription: max 156 characters.\r\nLet me know if this works.\r\n\r\nThanks!\n\nHey @HardikGoyal2003 , Let me know if this is working fine.\r\n\r\nhttps://github.com/user-attachments/assets/9523ceb9-80b8-496a-ab66-4b8c42ed43b3\r\n\r\n\n\nHey @TARishabh, please verify if the MAX_CHARS_IN_CHAPTER_DESCRIPTION constant is utilized in any other files. Also, test it by entering a character count exceeding the specified limit.\n\n@HardikGoyal2003 , I checked MAX_CHARS_IN_CHAPTER_DESCRIPTION, it used in:\r\nandroid_validation_constants.py\r\nstory-node-editor.component.html\r\nstory-node-editor.component.ts\r\n\r\nAnd yes, i have tested it by entering character counting more than 152, it's working fine.\n\n@TARishabh, please adjust the UI to 152. Otherwise, the solution looks good; go ahead and create a PR!",
  "pr_link": "https://github.com/oppia/oppia/pull/17968",
  "code_context": [
    {
      "filename": "core/templates/components/forms/custom-forms-directives/thumbnail-uploader.component.spec.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @fileoverview Unit tests for ThumbnailUploaderComponent.\n */\n\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { NO_ERRORS_SCHEMA, SimpleChanges } from '@angular/core';\nimport { ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { of } from 'rxjs';\nimport { AlertsService } from 'services/alerts.service';\nimport { AssetsBackendApiService } from 'services/assets-backend-api.service';\nimport { ContextService } from 'services/context.service';\nimport { ImageLocalStorageService } from 'services/image-local-storage.service';\nimport { ImageUploadHelperService } from 'services/image-upload-helper.service';\nimport { MockTranslatePipe } from 'tests/unit-test-utils';\nimport { EditThumbnailModalComponent } from './edit-thumbnail-modal.component';\nimport { ThumbnailUploaderComponent } from './thumbnail-uploader.component';\n\ndescribe('ThumbnailUploaderComponent', () => {\n  let fixture: ComponentFixture<ThumbnailUploaderComponent>;\n  let component: ThumbnailUploaderComponent;\n  let contextService: ContextService;\n  let imageUploadHelperService: ImageUploadHelperService;\n  let assetsBackendApiService: AssetsBackendApiService;\n  let imageLocalStorageService: ImageLocalStorageService;\n  let alertsService: AlertsService;\n  let ngbModal: NgbModal;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        ThumbnailUploaderComponent,\n        EditThumbnailModalComponent,\n        MockTranslatePipe\n      ],\n      providers: [ImageUploadHelperService],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(ThumbnailUploaderComponent);\n    component = fixture.componentInstance;\n    contextService = TestBed.inject(ContextService);\n    imageUploadHelperService = TestBed.inject(ImageUploadHelperService);\n    assetsBackendApiService = TestBed.inject(AssetsBackendApiService);\n    imageLocalStorageService = TestBed.inject(ImageLocalStorageService);\n    alertsService = TestBed.inject(AlertsService);\n    ngbModal = TestBed.inject(NgbModal);\n  });\n\n  it('should set uploaded and editable thumbnail on initialization', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    component.filename = 'thumbnail-1';\n\n    expect(component.thumbnailIsLoading).toBeTrue();\n\n    component.ngOnInit();\n\n    expect(component.editableThumbnailDataUrl)\n      .toBe('/assetsdevhandler/exploration/expId/assets/thumbnail/thumbnail-1');\n    expect(component.uploadedImage)\n      .toBe('/assetsdevhandler/exploration/expId/assets/thumbnail/thumbnail-1');\n    expect(component.thumbnailIsLoading).toBeFalse();\n  });\n\n  it('should throw error if no image is present for a preview during file' +\n    ' changed', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue(undefined);\n    component.filename = 'thumbnail-1';\n\n    expect(() => {\n      component.ngOnInit();\n    }).toThrowError('No image present for preview');\n  });\n\n  it('should display placeholder image when filename is null', () => {\n    component.filename = '';\n\n    expect(component.hidePlaceholder).toBeTrue();\n\n    component.ngOnInit();\n\n    // Since a thumbnail is unavailable a placeholder will be used. Hence,\n    // the value of hidePlaceholder should not change.\n    expect(component.hidePlaceholder).toBeTrue();\n  });\n\n  it('should update the thumbnail image when thumbnail filename' +\n    ' changes', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    component.filename = 'thumbnail-1';\n    let changes: SimpleChanges = {\n      filename: {\n        currentValue: 'thumbnail-2',\n        previousValue: 'thumbnail-1',\n        firstChange: false,\n        isFirstChange: () => false\n      }\n    };\n    component.ngOnInit();\n\n    expect(component.editableThumbnailDataUrl)\n      .toBe('/assetsdevhandler/exploration/expId/assets/thumbnail/thumbnail-1');\n\n    component.ngOnChanges(changes);\n\n    expect(component.editableThumbnailDataUrl)\n      .toBe('/assetsdevhandler/exploration/expId/assets/thumbnail/thumbnail-2');\n    expect(component.thumbnailIsLoading).toBeFalse();\n  });\n\n  it('should not update the thumbnail image when new thumbnail is same as' +\n    ' the old one', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    spyOn(\n      imageUploadHelperService, 'getTrustedResourceUrlForThumbnailFilename');\n    component.filename = 'thumbnail-1';\n    let changes: SimpleChanges = {\n      filename: {\n        currentValue: 'thumbnail-1',\n        previousValue: 'thumbnail-1',\n        firstChange: true,\n        isFirstChange: () => true\n      }\n    };\n    component.thumbnailIsLoading = false;\n\n    component.ngOnChanges(changes);\n\n    expect(imageUploadHelperService.getTrustedResourceUrlForThumbnailFilename)\n      .not.toHaveBeenCalled();\n    expect(component.thumbnailIsLoading).toBeFalse();\n  });\n\n  it('should throw error if no image is present for a preview during file' +\n    ' changed', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue(undefined);\n\n    expect(() => {\n      component.filenameChanges('newFile', 'oldFile');\n    }).toThrowError('No image present for preview');\n  });\n\n  it('should not show edit thumbnail modal if editing thumbnail is' +\n    ' disabled', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    component.disabled = true;\n    spyOn(ngbModal, 'open');\n\n    expect(component.openInUploadMode).toBe(false);\n\n    component.showEditThumbnailModal();\n\n    // Here, openInUpload mode is not set as which means, showEditThumbnailModal\n    // returned as soon as the first check was executed.\n    expect(component.openInUploadMode).toBe(false);\n    expect(ngbModal.open).not.toHaveBeenCalled();\n  });\n\n  it('should show edit thumbnail modal when user clicks on edit button and' +\n    ' post thumbnail to server if local storage is not used and modal is' +\n    ' opened in upload mode', fakeAsync(() => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    class MockNgbModalRef {\n      result = Promise.resolve({\n        dimensions: {\n          height: 50,\n          width: 50\n        },\n        openInUploadMode: true,\n        newThumbnailDataUrl: 'data:image/png;base64,xyz',\n        newBgColor: '#newcol'\n      });\n\n      componentInstance = {\n        bgColor: null,\n        allowedBgColors: null,\n        aspectRatio: null,\n        dimensions: null,\n        previewDescription: null,\n        previewDescriptionBgColor: null,\n        previewFooter: null,\n        previewTitle: null,\n        uploadedImage: null,\n        uploadedImageMimeType: null,\n        tempBgColor: null,\n      };\n    }\n    let ngbModalRef = new MockNgbModalRef();\n\n    // Set useLocalStorage as false to trigger fetching.\n    component.useLocalStorage = false;\n    component.disabled = false;\n    component.bgColor = '#ff9933';\n    let promise = of({\n      filename: 'filename'\n    });\n\n    spyOn(ngbModal, 'open').and.returnValue(\n      ngbModalRef as NgbModalRef);\n    spyOn(imageUploadHelperService, 'generateImageFilename').and.returnValue(\n      'image_file_name.svg');\n    spyOn(imageUploadHelperService, 'convertImageDataToImageFile')\n      .and.returnValue(new File([''], 'filename', {type: 'image/jpeg'}));\n    spyOn(assetsBackendApiService, 'postThumbnailFile')\n      .and.returnValue(promise);\n    spyOn(promise.toPromise(), 'then').and.resolveTo({filename: 'filename'});\n\n    const updateFilenameSpy = spyOn(component.updateFilename, 'emit');\n    const updateBgColorSpy = spyOn(component.updateBgColor, 'emit');\n\n    expect(component.thumbnailIsLoading).toBe(true);\n\n    component.showEditThumbnailModal();\n    tick();\n\n    expect(ngbModal.open).toHaveBeenCalledWith(\n      EditThumbnailModalComponent,\n      {backdrop: 'static'});\n    expect(component.tempImageName).toBe('image_file_name.svg');\n    expect(component.uploadedImage).toBe('data:image/png;base64,xyz');\n    expect(component.thumbnailIsLoading).toBe(false);\n    expect(updateFilenameSpy).toHaveBeenCalledWith('image_file_name.svg');\n    expect(updateBgColorSpy).toHaveBeenCalledWith('#newcol');\n  }));\n\n  it('should show edit thumbnail modal when user clicks on edit button and' +\n    ' save background color if not opened in upload mode', fakeAsync(() => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    // Modal is not opened in upload mode.\n    class MockNgbModalRef {\n      result = Promise.resolve({\n        dimensions: {\n          height: 50,\n          width: 50\n        },\n        openInUploadMode: false,\n        newThumbnailDataUrl: 'data:image/png;base64,xyz',\n        newBgColor: '#newcol'\n      });\n\n      componentInstance = {\n        bgColor: null,\n        allowedBgColors: null,\n        aspectRatio: null,\n        dimensions: null,\n        previewDescription: null,\n        previewDescriptionBgColor: null,\n        previewFooter: null,\n        previewTitle: null,\n        uploadedImage: null,\n        uploadedImageMimeType: null,\n        tempBgColor: null,\n      };\n    }\n    let ngbModalRef = new MockNgbModalRef();\n\n    component.useLocalStorage = false;\n    component.disabled = false;\n    component.bgColor = '#ff9933';\n\n    spyOn(ngbModal, 'open').and.returnValue(\n      ngbModalRef as NgbModalRef);\n    spyOn(imageUploadHelperService, 'convertImageDataToImageFile')\n      .and.returnValue(new File([''], 'filename', {type: 'image/jpeg'}));\n\n    const updateFilenameSpy = spyOn(component.updateFilename, 'emit');\n    const updateBgColorSpy = spyOn(component.updateBgColor, 'emit');\n\n    expect(component.thumbnailIsLoading).toBe(true);\n\n    component.showEditThumbnailModal();\n    tick();\n\n    expect(ngbModal.open).toHaveBeenCalledWith(\n      EditThumbnailModalComponent,\n      {backdrop: 'static'});\n    expect(component.thumbnailIsLoading).toBe(false);\n    expect(updateFilenameSpy).not.toHaveBeenCalled();\n    expect(updateBgColorSpy).toHaveBeenCalledWith('#newcol');\n  }));\n\n  it('should show edit thumbnail modal when user clicks on edit button and' +\n    ' save uploaded thumbnail to local storage if local storage' +\n    ' is used', fakeAsync(() => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    class MockNgbModalRef {\n      result = Promise.resolve({\n        dimensions: {\n          height: 50,\n          width: 50\n        },\n        openInUploadMode: false,\n        newThumbnailDataUrl: 'data:image/png;base64,xyz',\n        newBgColor: '#newcol'\n      });\n\n      componentInstance = {\n        bgColor: null,\n        allowedBgColors: null,\n        aspectRatio: null,\n        dimensions: null,\n        previewDescription: null,\n        previewDescriptionBgColor: null,\n        previewFooter: null,\n        previewTitle: null,\n        uploadedImage: null,\n        uploadedImageMimeType: null,\n        tempBgColor: null,\n      };\n    }\n    let ngbModalRef = new MockNgbModalRef();\n\n    component.useLocalStorage = true;\n    component.disabled = false;\n    component.allowedBgColors = ['#ff9933'];\n\n    const imageSaveSpy = spyOn(component.imageSave, 'emit');\n\n    spyOn(ngbModal, 'open').and.returnValue(\n      ngbModalRef as NgbModalRef);\n    spyOn(imageUploadHelperService, 'generateImageFilename').and.returnValue(\n      'image_file_name.svg');\n    spyOn(imageLocalStorageService, 'saveImage');\n    spyOn(imageLocalStorageService, 'setThumbnailBgColor');\n\n    expect(component.thumbnailIsLoading).toBe(true);\n\n    component.showEditThumbnailModal();\n    tick();\n\n    expect(ngbModal.open).toHaveBeenCalledWith(\n      EditThumbnailModalComponent,\n      {backdrop: 'static'}\n    );\n    expect(component.thumbnailIsLoading).toBe(false);\n    expect(imageLocalStorageService.saveImage).toHaveBeenCalledWith(\n      'image_file_name.svg', 'data:image/png;base64,xyz');\n    expect(imageLocalStorageService.setThumbnailBgColor).toHaveBeenCalledWith(\n      '#newcol');\n    expect(imageSaveSpy).toHaveBeenCalled();\n  }));\n\n  it('should close edit thumbnail modal when cancel button' +\n    ' is clicked', fakeAsync(() => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    class MockNgbModalRef {\n      componentInstance = {\n        bgColor: null,\n        allowedBgColors: null,\n        aspectRatio: null,\n        dimensions: null,\n        previewDescription: null,\n        previewDescriptionBgColor: null,\n        previewFooter: null,\n        previewTitle: null,\n        uploadedImage: null,\n        uploadedImageMimeType: null,\n        tempBgColor: null,\n      };\n    }\n    let ngbModalRef = new MockNgbModalRef();\n\n    component.disabled = false;\n    component.allowedBgColors = ['#ff9933'];\n\n    spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n      return ({\n        componentInstance: ngbModalRef,\n        result: Promise.reject('cancel')\n      } as NgbModalRef);\n    });\n\n    component.showEditThumbnailModal();\n\n    expect(ngbModal.open).toHaveBeenCalledWith(\n      EditThumbnailModalComponent,\n      {backdrop: 'static'}\n    );\n  }));\n\n  it('should raise an alert if an empty file is uploaded', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue('exploration');\n    spyOn(contextService, 'getEntityId').and.returnValue('expId');\n    spyOn(alertsService, 'addWarning');\n    spyOn(imageUploadHelperService, 'convertImageDataToImageFile')\n      .and.returnValue(null);\n\n    component.saveThumbnailImageData('imageUrl', () => {});\n\n    expect(alertsService.addWarning).toHaveBeenCalledWith(\n      'Could not get resampled file.');\n  });\n\n  it('should throw error if no image is present for a preview', () => {\n    spyOn(contextService, 'getEntityType').and.returnValue(undefined);\n    // This is just a mock base 64 in order to test the FileReader event.\n    let dataBase64Mock = 'VEhJUyBJUyBUSEUgQU5TV0VSCg==';\n    const arrayBuffer = Uint8Array.from(\n      window.atob(dataBase64Mock), c => c.charCodeAt(0));\n    let file = new File([arrayBuffer], 'filename.mp3');\n\n    expect(() => {\n      component.postImageToServer(file, () => {});\n    }).toThrowError('No image present for preview');\n  });\n});\n"
    },
    {
      "filename": "core/templates/domain/story/story-update.service.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Tests for Story update service.\n */\n\nimport { HttpClientTestingModule } from\n  '@angular/common/http/testing';\nimport { TestBed } from '@angular/core/testing';\n\nimport { Story } from 'domain/story/story.model';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { EntityEditorBrowserTabsInfo } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info.model';\nimport { LocalStorageService } from 'services/local-storage.service';\n\ndescribe('Story update service', () => {\n  let storyUpdateService: StoryUpdateService;\n  let undoRedoService: UndoRedoService;\n  let localStorageService: LocalStorageService;\n  let _sampleStory: Story;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n    });\n\n    storyUpdateService = TestBed.inject(StoryUpdateService);\n    undoRedoService = TestBed.inject(UndoRedoService);\n    localStorageService = TestBed.inject(LocalStorageService);\n\n    let sampleStoryBackendObject = {\n      id: 'sample_story_id',\n      title: 'Story title',\n      description: 'Story description',\n      notes: 'Story notes',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      story_contents: {\n        initial_node_id: 'node_2',\n        nodes: [\n          {\n            id: 'node_1',\n            title: 'Title 1',\n            description: 'Description 1',\n            prerequisite_skill_ids: ['skill_1'],\n            acquired_skill_ids: ['skill_2'],\n            destination_node_ids: [],\n            outline: 'Outline',\n            exploration_id: 'exp_id',\n            outline_is_finalized: false,\n            thumbnail_filename: 'fileName',\n            thumbnail_bg_color: 'blue',\n          }, {\n            id: 'node_2',\n            title: 'Title 2',\n            description: 'Description 2',\n            prerequisite_skill_ids: ['skill_3'],\n            acquired_skill_ids: ['skill_4'],\n            destination_node_ids: ['node_1'],\n            outline: 'Outline 2',\n            exploration_id: 'exp_1',\n            outline_is_finalized: true,\n            thumbnail_filename: 'fileName',\n            thumbnail_bg_color: 'blue',\n          }],\n        next_node_id: 'node_3'\n      },\n      language_code: 'en',\n      thumbnail_filename: 'fileName',\n      thumbnail_bg_color: 'blue',\n      url_fragment: 'url',\n      meta_tag_content: 'meta'\n    };\n\n    spyOn(storyUpdateService.onStoryChapterUpdateEventEmitter, 'emit')\n      .and.stub();\n\n    _sampleStory = Story.createFromBackendDict(\n      sampleStoryBackendObject);\n  });\n\n  it('should add/remove a prerequisite skill id to/from a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual(['skill_1']);\n      storyUpdateService.addPrerequisiteSkillIdToNode(\n        _sampleStory, 'node_1', 'skill_3');\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual(['skill_1', 'skill_3']);\n      expect(storyUpdateService.onStoryChapterUpdateEventEmitter.emit)\n        .toHaveBeenCalled();\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual(['skill_1']);\n    }\n  );\n\n  it('should create a proper backend change dict for adding a prerequisite ' +\n    'skill id to a node',\n  () => {\n    storyUpdateService.addPrerequisiteSkillIdToNode(\n      _sampleStory, 'node_1', 'skill_3');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'prerequisite_skill_ids',\n      new_value: ['skill_1', 'skill_3'],\n      old_value: ['skill_1'],\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should add/remove an acquired skill id to/from a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual(['skill_2']);\n      storyUpdateService.addAcquiredSkillIdToNode(\n        _sampleStory, 'node_1', 'skill_4');\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual(['skill_2', 'skill_4']);\n      expect(storyUpdateService.onStoryChapterUpdateEventEmitter.emit)\n        .toHaveBeenCalled();\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual(['skill_2']);\n    }\n  );\n\n  it('should create a proper backend change dict for adding an acquired ' +\n    'skill id to a node',\n  () => {\n    storyUpdateService.addAcquiredSkillIdToNode(\n      _sampleStory, 'node_1', 'skill_4');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'acquired_skill_ids',\n      new_value: ['skill_2', 'skill_4'],\n      old_value: ['skill_2'],\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should add/remove a destination node id to/from a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getDestinationNodeIds()\n      ).toEqual([]);\n      storyUpdateService.addDestinationNodeIdToNode(\n        _sampleStory, 'node_1', 'node_2');\n\n      // Adding an invalid destination node id should throw an error.\n      expect(() => {\n        storyUpdateService.addDestinationNodeIdToNode(\n          _sampleStory, 'node_1', 'node_5');\n      }).toThrowError('The destination node with given id doesn\\'t exist');\n\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getDestinationNodeIds()\n      ).toEqual(['node_2']);\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getDestinationNodeIds()\n      ).toEqual([]);\n    }\n  );\n\n  it('should create a proper backend change dict for adding a destination ' +\n    'node id to a node',\n  () => {\n    storyUpdateService.addDestinationNodeIdToNode(\n      _sampleStory, 'node_1', 'node_2');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'destination_node_ids',\n      new_value: ['node_2'],\n      old_value: [],\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should remove/add a prerequisite skill id from/to a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual(['skill_1']);\n      storyUpdateService.removePrerequisiteSkillIdFromNode(\n        _sampleStory, 'node_1', 'skill_1');\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual([]);\n      expect(storyUpdateService.onStoryChapterUpdateEventEmitter.emit)\n        .toHaveBeenCalled();\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n      ).toEqual(['skill_1']);\n    }\n  );\n\n  it('should not remove a prerequisite skill ' +\n    'from a node if given id is invalid', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n    ).toEqual(['skill_1']);\n\n    expect(() => {\n      storyUpdateService.removePrerequisiteSkillIdFromNode(\n        _sampleStory, 'node_1', 'invalid_Id');\n    }).toThrowError('The given prerequisite skill is not part of the node');\n\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getPrerequisiteSkillIds()\n    ).toEqual(['skill_1']);\n  });\n\n  it('should create a proper backend change dict for removing a prerequisite ' +\n    'skill id from a node',\n  () => {\n    storyUpdateService.removePrerequisiteSkillIdFromNode(\n      _sampleStory, 'node_1', 'skill_1');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'prerequisite_skill_ids',\n      new_value: [],\n      old_value: ['skill_1'],\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should remove/add an acquired skill id from/to a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual(['skill_2']);\n      storyUpdateService.removeAcquiredSkillIdFromNode(\n        _sampleStory, 'node_1', 'skill_2');\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual([]);\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n      ).toEqual(['skill_2']);\n    }\n  );\n\n  it('should not remove an acquired skill id ' +\n    'from a node if given id is invalid', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n    ).toEqual(['skill_2']);\n\n    expect(() => {\n      storyUpdateService.removeAcquiredSkillIdFromNode(\n        _sampleStory, 'node_1', 'invalid_Id');\n    }).toThrowError('The given acquired skill id is not part of the node');\n\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getAcquiredSkillIds()\n    ).toEqual(['skill_2']);\n  });\n\n  it('should create a proper backend change dict for removing an acquired ' +\n    'skill id from a node',\n  () => {\n    storyUpdateService.removeAcquiredSkillIdFromNode(\n      _sampleStory, 'node_1', 'skill_2');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'acquired_skill_ids',\n      new_value: [],\n      old_value: ['skill_2'],\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should remove/add a destination node id from/to a node in the story',\n    () => {\n      expect(\n        _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n      ).toEqual(['node_1']);\n      storyUpdateService.removeDestinationNodeIdFromNode(\n        _sampleStory, 'node_2', 'node_1');\n\n      expect(\n        _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n      ).toEqual([]);\n\n      undoRedoService.undoChange(_sampleStory);\n      expect(\n        _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n      ).toEqual(['node_1']);\n    }\n  );\n\n  it('should not remove a destination node id from a node in the story ' +\n    'if given id is invalid', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n    ).toEqual(['node_1']);\n\n    expect(() => {\n      storyUpdateService.removeDestinationNodeIdFromNode(\n        _sampleStory, 'node_2', 'invalid_node2');\n    }).toThrowError('The given destination node is not part of the node');\n\n    expect(() => {\n      storyUpdateService.removeDestinationNodeIdFromNode(\n        _sampleStory, 'invalid_node1', 'invalid_node2');\n    }).toThrowError('The given node doesn\\'t exist');\n\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n    ).toEqual(['node_1']);\n  });\n\n  it('should create a proper backend change dict for removing a destination ' +\n    'node id from a node',\n  () => {\n    storyUpdateService.removeDestinationNodeIdFromNode(\n      _sampleStory, 'node_2', 'node_1');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'destination_node_ids',\n      new_value: [],\n      old_value: ['node_1'],\n      node_id: 'node_2'\n    }]);\n  });\n\n  it('should add/remove a story node', () => {\n    expect(_sampleStory.getStoryContents().getNodes().length).toEqual(2);\n    storyUpdateService.addStoryNode(_sampleStory, 'Title 2');\n    expect(_sampleStory.getStoryContents().getNodes().length).toEqual(3);\n    expect(_sampleStory.getStoryContents().getNextNodeId()).toEqual('node_4');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[2].getId()).toEqual('node_3');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[2].getTitle()).toEqual(\n      'Title 2');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getStoryContents().getNodes().length).toEqual(2);\n  });\n\n  it('should create a proper backend change dict for adding a story node',\n    () => {\n      storyUpdateService.addStoryNode(_sampleStory, 'Title 2');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'add_story_node',\n        node_id: 'node_3',\n        title: 'Title 2'\n      }]);\n    }\n  );\n\n  it('should remove/add a story node', () => {\n    expect(() => {\n      storyUpdateService.deleteStoryNode(_sampleStory, 'node_2');\n    }).toThrowError('Cannot delete initial story node');\n    expect(_sampleStory.getStoryContents().getNodes().length).toEqual(2);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getDestinationNodeIds()\n    ).toEqual(['node_1']);\n    storyUpdateService.deleteStoryNode(_sampleStory, 'node_1');\n    // Initial node should not be deleted.\n    storyUpdateService.deleteStoryNode(_sampleStory, 'node_2');\n    expect(_sampleStory.getStoryContents().getInitialNodeId()).toEqual(null);\n    expect(_sampleStory.getStoryContents().getNodes().length).toEqual(0);\n\n    expect(() => {\n      undoRedoService.undoChange(_sampleStory);\n    }).toThrowError('A deleted story node cannot be restored.');\n  });\n\n  it('should create a proper backend change dict for removing a story node',\n    () => {\n      storyUpdateService.deleteStoryNode(_sampleStory, 'node_1');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'delete_story_node',\n        node_id: 'node_1'\n      }]);\n    }\n  );\n\n  it('should finalize a story node outline', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutlineStatus()\n    ).toBe(false);\n    storyUpdateService.finalizeStoryNodeOutline(_sampleStory, 'node_1');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutlineStatus()\n    ).toBe(true);\n\n    expect(storyUpdateService.onStoryChapterUpdateEventEmitter.emit)\n      .toHaveBeenCalled();\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutlineStatus()\n    ).toBe(false);\n  });\n\n  it('should throw an error if we try to finalize a story ' +\n    'which is already finalized', () => {\n    storyUpdateService.finalizeStoryNodeOutline(_sampleStory, 'node_1');\n    expect(() => {\n      storyUpdateService.finalizeStoryNodeOutline(_sampleStory, 'node_1');\n    }).toThrowError('Node outline is already finalized.');\n  });\n\n  it('should create a proper backend change dict for finalizing a node outline',\n    () => {\n      storyUpdateService.finalizeStoryNodeOutline(_sampleStory, 'node_1');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_node_outline_status',\n        new_value: true,\n        old_value: false,\n        node_id: 'node_1'\n      }]);\n    }\n  );\n\n  it('should unfinalize a story node outline', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getOutlineStatus()\n    ).toBe(true);\n    storyUpdateService.unfinalizeStoryNodeOutline(_sampleStory, 'node_2');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getOutlineStatus()\n    ).toBe(false);\n    expect(storyUpdateService.onStoryChapterUpdateEventEmitter.emit)\n      .toHaveBeenCalled();\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[1].getOutlineStatus()\n    ).toBe(true);\n  });\n\n  it('should throw an error if we try to unfinalize a story ' +\n    'with an invalid story node', () => {\n    expect(() => {\n      storyUpdateService.unfinalizeStoryNodeOutline(_sampleStory, 'node_1');\n    }).toThrowError('Node outline is already not finalized.');\n  });\n\n  it('should create a proper backend change dict for unfinalizing a node ' +\n    'outline', () => {\n    storyUpdateService.unfinalizeStoryNodeOutline(_sampleStory, 'node_2');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_outline_status',\n      new_value: false,\n      old_value: true,\n      node_id: 'node_2'\n    }]);\n  });\n\n  it('should set a story node outline', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutline()\n    ).toBe('Outline');\n    storyUpdateService.setStoryNodeOutline(\n      _sampleStory, 'node_1', 'new outline');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutline()\n    ).toBe('new outline');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getOutline()\n    ).toBe('Outline');\n  });\n\n  it('should create a proper backend change dict for setting a node outline',\n    () => {\n      storyUpdateService.setStoryNodeOutline(\n        _sampleStory, 'node_1', 'new outline');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_node_property',\n        property_name: 'outline',\n        new_value: 'new outline',\n        old_value: 'Outline',\n        node_id: 'node_1'\n      }]);\n    }\n  );\n\n  it('should set a story node title', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getTitle()\n    ).toBe('Title 1');\n    storyUpdateService.setStoryNodeTitle(\n      _sampleStory, 'node_1', 'new title');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getTitle()\n    ).toBe('new title');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getTitle()\n    ).toBe('Title 1');\n  });\n\n  it('should create a proper backend change dict for setting a node title',\n    () => {\n      storyUpdateService.setStoryNodeTitle(\n        _sampleStory, 'node_1', 'new title');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_node_property',\n        property_name: 'title',\n        new_value: 'new title',\n        old_value: 'Title 1',\n        node_id: 'node_1'\n      }]);\n    }\n  );\n\n  it('should set a story node description', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getDescription()\n    ).toBe('Description 1');\n    storyUpdateService.setStoryNodeDescription(\n      _sampleStory, 'node_1', 'new description');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getDescription()\n    ).toBe('new description');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getDescription()\n    ).toBe('Description 1');\n  });\n\n  it('should create a backend change dict for setting a node description',\n    () => {\n      storyUpdateService.setStoryNodeDescription(\n        _sampleStory, 'node_1', 'new description');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_node_property',\n        property_name: 'description',\n        new_value: 'new description',\n        old_value: 'Description 1',\n        node_id: 'node_1'\n      }]);\n    }\n  );\n\n  it('should set the exploration id of a story node', () => {\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getExplorationId()\n    ).toBe('exp_id');\n    storyUpdateService.setStoryNodeExplorationId(\n      _sampleStory, 'node_1', 'exp_2');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getExplorationId()\n    ).toBe('exp_2');\n\n    // Adding an already existing exploration in the story should throw an\n    // error.\n    expect(() => {\n      storyUpdateService.setStoryNodeExplorationId(\n        _sampleStory, 'node_1', 'exp_1');\n    }).toThrowError('The given exploration already exists in the story.');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getExplorationId()\n    ).toBe('exp_id');\n  });\n\n  it('should create a proper backend change dict for setting the exploration ' +\n    'id of a node', () => {\n    storyUpdateService.setStoryNodeExplorationId(\n      _sampleStory, 'node_1', 'exp_2');\n    expect(undoRedoService.getCommittableChangeList()).toEqual([{\n      cmd: 'update_story_node_property',\n      property_name: 'exploration_id',\n      new_value: 'exp_2',\n      old_value: 'exp_id',\n      node_id: 'node_1'\n    }]);\n  });\n\n  it('should set/unset the initial node of the story', () => {\n    expect(\n      _sampleStory.getStoryContents().getInitialNodeId()).toEqual('node_2');\n    storyUpdateService.setInitialNodeId(_sampleStory, 'node_1');\n    expect(\n      _sampleStory.getStoryContents().getInitialNodeId()).toEqual('node_1');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getInitialNodeId()).toEqual('node_2');\n  });\n\n  it('should create a proper backend change dict for setting initial node',\n    () => {\n      storyUpdateService.setInitialNodeId(_sampleStory, 'node_1');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_contents_property',\n        property_name: 'initial_node_id',\n        new_value: 'node_1',\n        old_value: 'node_2'\n      }]);\n    }\n  );\n\n  it('should set/unset changes to a story\\'s title', () => {\n    expect(_sampleStory.getTitle()).toEqual('Story title');\n    storyUpdateService.setStoryTitle(_sampleStory, 'new title');\n    expect(_sampleStory.getTitle()).toEqual('new title');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getTitle()).toEqual('Story title');\n  });\n\n  it('should create a proper backend change dict for changing title',\n    () => {\n      storyUpdateService.setStoryTitle(_sampleStory, 'new title');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_property',\n        property_name: 'title',\n        new_value: 'new title',\n        old_value: 'Story title'\n      }]);\n    }\n  );\n\n  it('should set/unset changes to a story\\'s description', () => {\n    expect(_sampleStory.getDescription()).toEqual('Story description');\n    storyUpdateService.setStoryDescription(_sampleStory, 'new description');\n    expect(_sampleStory.getDescription()).toEqual('new description');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getDescription()).toEqual('Story description');\n  });\n\n  it('should create a proper backend change dict for changing descriptions',\n    () => {\n      storyUpdateService.setStoryDescription(_sampleStory, 'new description');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_property',\n        property_name: 'description',\n        new_value: 'new description',\n        old_value: 'Story description'\n      }]);\n    }\n  );\n\n  it('should set/unset changes to a story\\'s notes', () => {\n    expect(_sampleStory.getNotes()).toEqual('Story notes');\n    storyUpdateService.setStoryNotes(_sampleStory, 'new notes');\n    expect(_sampleStory.getNotes()).toEqual('new notes');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getNotes()).toEqual('Story notes');\n  });\n\n  it('should create a proper backend change dict for changing notes',\n    () => {\n      storyUpdateService.setStoryNotes(_sampleStory, 'new notes');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_property',\n        property_name: 'notes',\n        new_value: 'new notes',\n        old_value: 'Story notes'\n      }]);\n    }\n  );\n\n  it('should set/unset changes to a story\\'s language code', () => {\n    expect(_sampleStory.getLanguageCode()).toEqual('en');\n    storyUpdateService.setStoryLanguageCode(_sampleStory, 'fi');\n    expect(_sampleStory.getLanguageCode()).toEqual('fi');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getLanguageCode()).toEqual('en');\n  });\n\n  it('should create a proper backend change dict for changing language codes',\n    () => {\n      storyUpdateService.setStoryLanguageCode(_sampleStory, 'fi');\n      expect(undoRedoService.getCommittableChangeList()).toEqual([{\n        cmd: 'update_story_property',\n        property_name: 'language_code',\n        new_value: 'fi',\n        old_value: 'en'\n      }]);\n    }\n  );\n\n  it('should rearrange node in story when calling ' +\n    '\\'rearrangeNodeInStory\\'', () => {\n    storyUpdateService.rearrangeNodeInStory(\n      _sampleStory, 0, 1);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getId()).toBe('node_2');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getId()).toBe('node_1');\n  });\n\n  it('should set story node thumbnail background color when calling ' +\n    '\\'setStoryNodeThumbnailBgColor\\'', () => {\n    storyUpdateService.setStoryNodeThumbnailBgColor(\n      _sampleStory, 'node_1', 'red');\n    expect(_sampleStory.getStoryContents().getNodes()[0].getThumbnailBgColor())\n      .toBe('red');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getStoryContents().getNodes()[0].getThumbnailBgColor())\n      .toBe('blue');\n  });\n\n  it('should set story node thumbnail file name when calling ' +\n    '\\'setStoryNodeThumbnailFilename\\'', () => {\n    storyUpdateService.setStoryNodeThumbnailFilename(\n      _sampleStory, 'node_1', 'newName');\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getThumbnailFilename())\n      .toBe('newName');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(\n      _sampleStory.getStoryContents().getNodes()[0].getThumbnailFilename())\n      .toBe('fileName');\n  });\n\n  it('should set story meta tag content when calling ' +\n    '\\'setStoryMetaTagContent\\'', () => {\n    storyUpdateService.setStoryMetaTagContent(\n      _sampleStory, 'newTag');\n    expect(_sampleStory.getMetaTagContent()).toBe('newTag');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getMetaTagContent()).toBe('meta');\n  });\n\n  it('should set thumbnail background color when calling ' +\n    '\\'setThumbnailBgColor\\'', () => {\n    storyUpdateService.setThumbnailBgColor(\n      _sampleStory, 'red');\n    expect(_sampleStory.getThumbnailBgColor()).toBe('red');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getThumbnailBgColor()).toBe('blue');\n  });\n\n  it('should set thumbnail file name when calling ' +\n    '\\'setThumbnailFilename\\'', () => {\n    storyUpdateService.setThumbnailFilename(\n      _sampleStory, 'newName');\n    expect(_sampleStory.getThumbnailFilename()).toBe('newName');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getThumbnailFilename()).toBe('fileName');\n  });\n\n  it('should set story url fragment when calling ' +\n    '\\'setStoryUrlFragment\\'', () => {\n    storyUpdateService.setStoryUrlFragment(\n      _sampleStory, 'newUrl');\n    expect(_sampleStory.getUrlFragment()).toBe('newUrl');\n\n    undoRedoService.undoChange(_sampleStory);\n    expect(_sampleStory.getUrlFragment()).toBe('url');\n  });\n\n  it('should update story editor browser tabs unsaved changes status', () => {\n    let storyEditorBrowserTabsInfo = EntityEditorBrowserTabsInfo.create(\n      'story', 'story_id', 2, 1, false);\n    spyOn(\n      localStorageService, 'getEntityEditorBrowserTabsInfo'\n    ).and.returnValue(storyEditorBrowserTabsInfo);\n    spyOn(\n      localStorageService, 'updateEntityEditorBrowserTabsInfo'\n    ).and.callFake(() => {});\n\n    expect(\n      storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges()\n    ).toBeFalse();\n\n    storyUpdateService.setStoryDescription(_sampleStory, 'new description');\n\n    expect(\n      storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges()\n    ).toBeTrue();\n  });\n});\n"
    },
    {
      "filename": "core/templates/domain/story/story-update.service.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service to build changes to a story. These changes may\n * then be used by other services, such as a backend API service to update the\n * story in the backend. This service also registers all changes with the\n * undo/redo service.\n */\n\nimport { downgradeInjectable } from '@angular/upgrade/static';\nimport { Injectable, EventEmitter } from '@angular/core';\n\nimport { AlertsService } from 'services/alerts.service';\nimport { BackendChangeObject, Change, DomainObject } from 'domain/editor/undo_redo/change.model';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { StoryChange } from 'domain/editor/undo_redo/change.model';\nimport { StoryDomainConstants } from 'domain/story/story-domain.constants';\nimport { StoryEditorStateService } from 'pages/story-editor-page/services/story-editor-state.service';\nimport { Story } from 'domain/story/story.model';\nimport { StoryContents } from 'domain/story/story-contents-object.model';\nimport { StoryNode } from './story-node.model';\nimport { EntityEditorBrowserTabsInfo } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info.model';\nimport { LocalStorageService } from 'services/local-storage.service';\nimport { EntityEditorBrowserTabsInfoDomainConstants } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info-domain.constants';\n\ntype StoryUpdateApply = (storyChange: StoryChange, story: Story) => void;\ntype StoryUpdateReverse = (storyChange: StoryChange, story: Story) => void;\ntype ChangeBackendDict = (\n  backendChangeObject: BackendChangeObject,\n  domainObject: DomainObject\n) => void;\n\ninterface Params {\n  'node_id'?: string;\n  'title'?: string;\n  // For properties like initialNodeId, thumbnailBackdroundColor\n  // old value can be null.\n  'old_value'?: string | string[] | boolean | number | null;\n  'new_value'?: string | string[] | boolean | number;\n  'property_name'?: string;\n  'cmd'?: string;\n}\n\ntype Command = BackendChangeObject['cmd'];\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StoryUpdateService {\n  private _storyChapterUpdateEventEmitter = new EventEmitter<void>();\n\n  constructor(\n    private _undoRedoService: UndoRedoService,\n    private _alertsService: AlertsService,\n    private _storyEditorStateService: StoryEditorStateService,\n    private _localStorageService: LocalStorageService\n  ) {}\n\n  get onStoryChapterUpdateEventEmitter(): EventEmitter<void> {\n    return this._storyChapterUpdateEventEmitter;\n  }\n\n  // Creates a change using an apply function, reverse function, a change\n  // command and related parameters. The change is applied to a given\n  // story.\n  _applyChange(\n      story: Story, command: Command, params: Params,\n      apply: StoryUpdateApply, reverse: StoryUpdateReverse): void {\n    let changeDict = cloneDeep(params) as BackendChangeObject;\n    changeDict.cmd = command;\n    let changeObj = new Change(\n      changeDict, apply as ChangeBackendDict, reverse as ChangeBackendDict);\n    try {\n      this._undoRedoService.applyChange(changeObj, story);\n      this._updateStoryEditorBrowserTabsUnsavedChangesStatus(story);\n    // We use unknown type because we are unsure of the type of error\n    // that was thrown. Since the catch block cannot identify the\n    // specific type of error, we are unable to further optimise the\n    // code by introducing more types of errors.\n    } catch (err: unknown) {\n      if (err instanceof Error) {\n        this._alertsService.addWarning(err.message);\n      }\n      throw err;\n    }\n  }\n\n  private _updateStoryEditorBrowserTabsUnsavedChangesStatus(story: Story) {\n    var storyEditorBrowserTabsInfo:\n      EntityEditorBrowserTabsInfo | null = (\n        this._localStorageService.getEntityEditorBrowserTabsInfo(\n          EntityEditorBrowserTabsInfoDomainConstants\n            .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n    if (\n      this._undoRedoService.getChangeCount() > 0 &&\n      storyEditorBrowserTabsInfo &&\n      !storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges()\n    ) {\n      storyEditorBrowserTabsInfo.setSomeTabHasUnsavedChanges(true);\n      this._localStorageService.updateEntityEditorBrowserTabsInfo(\n        storyEditorBrowserTabsInfo,\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS);\n    }\n  }\n\n  _getParameterFromChangeDict(\n      changeDict: BackendChangeObject, paramName: string): string {\n    return changeDict[paramName as keyof BackendChangeObject];\n  }\n\n  _getNodeIdFromChangeDict(changeDict: BackendChangeObject): string {\n    return this._getParameterFromChangeDict(changeDict, 'node_id');\n  }\n\n  _getStoryNode(storyContents: StoryContents, nodeId: string): StoryNode {\n    let storyNodeIndex = storyContents.getNodeIndex(nodeId);\n    if (storyNodeIndex === -1) {\n      throw new Error('The given node doesn\\'t exist');\n    }\n    return storyContents.getNodes()[storyNodeIndex];\n  }\n\n  // Applies a story property change, specifically. See _applyChange()\n  // for details on the other behavior of this function.\n  _applyStoryPropertyChange(\n      story: Story, propertyName: string,\n      oldValue: string | null, newValue: string,\n      apply: StoryUpdateApply, reverse: StoryUpdateReverse): void {\n    this._applyChange(story, StoryDomainConstants.CMD_UPDATE_STORY_PROPERTY, {\n      property_name: propertyName,\n      new_value: cloneDeep(newValue),\n      old_value: cloneDeep(oldValue)\n    }, apply, reverse);\n  }\n\n  _applyStoryContentsPropertyChange(\n      story: Story, propertyName: string,\n      oldValue: string | number | null, newValue: string | number,\n      apply: StoryUpdateApply, reverse: StoryUpdateReverse): void {\n    this._applyChange(\n      story, StoryDomainConstants.CMD_UPDATE_STORY_CONTENTS_PROPERTY, {\n        property_name: propertyName,\n        new_value: cloneDeep(newValue),\n        old_value: cloneDeep(oldValue)\n      }, apply, reverse);\n  }\n\n  _applyStoryNodePropertyChange(\n      story: Story, propertyName: string,\n      nodeId: string, oldValue: string | string[] | null,\n      newValue: string | string[],\n      apply: StoryUpdateApply, reverse: StoryUpdateReverse): void {\n    this._applyChange(\n      story, StoryDomainConstants.CMD_UPDATE_STORY_NODE_PROPERTY, {\n        node_id: nodeId,\n        property_name: propertyName,\n        new_value: cloneDeep(newValue),\n        old_value: cloneDeep(oldValue)\n      }, apply, reverse);\n  }\n\n  _getNewPropertyValueFromChangeDict(changeDict: BackendChangeObject): string {\n    return this._getParameterFromChangeDict(changeDict, 'new_value');\n  }\n\n  // These functions are associated with updates available in\n  // core.domain.story_services.apply_change_list.\n\n  /**\n   * Changes the title of a story and records the change in the\n   * undo/redo service.\n   */\n  setStoryTitle(story: Story, title: string): void {\n    let oldTitle = cloneDeep(story.getTitle());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_TITLE, oldTitle, title,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let title = this._getNewPropertyValueFromChangeDict(changeDict);\n        story.setTitle(title);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setTitle(oldTitle);\n      });\n  }\n\n  /**\n   * Changes the url fragment of a story and records the change in the\n   * undo/redo service.\n   */\n  setStoryUrlFragment(story: Story, urlFragment: string): void {\n    let oldUrlFragment = cloneDeep(story.getUrlFragment());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_URL_FRAGMENT,\n      oldUrlFragment, urlFragment,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let newUrlFragment = (\n          this._getNewPropertyValueFromChangeDict(changeDict));\n        story.setUrlFragment(newUrlFragment);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setUrlFragment(oldUrlFragment);\n      });\n  }\n\n  /**\n   * Changes the thumbnail filename of a story and records the change\n   * in the undo/redo service.\n   */\n  setThumbnailFilename(story: Story, newThumbnailFilename: string): void {\n    let oldThumbnailFilename = cloneDeep(story.getThumbnailFilename());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_THUMBNAIL_FILENAME,\n      oldThumbnailFilename, newThumbnailFilename,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let thumbnailFilename = (\n          this._getNewPropertyValueFromChangeDict(changeDict));\n        story.setThumbnailFilename(thumbnailFilename);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setThumbnailFilename(oldThumbnailFilename);\n      });\n  }\n\n  /**\n   * Changes the thumbnail background color of a story and records the\n   * change in the undo/redo service.\n   */\n  setThumbnailBgColor(story: Story, newThumbnailBgColor: string): void {\n    let oldThumbnailBgColor = cloneDeep(story.getThumbnailBgColor());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_THUMBNAIL_BG_COLOR,\n      oldThumbnailBgColor, newThumbnailBgColor,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let thumbnailBgColor = (\n          this._getNewPropertyValueFromChangeDict(changeDict));\n        story.setThumbnailBgColor(thumbnailBgColor);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setThumbnailBgColor(oldThumbnailBgColor);\n      });\n  }\n\n  /**\n   * Changes the description of a story and records the change in the\n   * undo/redo service.\n   */\n  setStoryDescription(story: Story, description: string): void {\n    let oldDescription = cloneDeep(story.getDescription());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_DESCRIPTION,\n      oldDescription, description,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let description = this._getNewPropertyValueFromChangeDict(changeDict);\n        story.setDescription(description);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setDescription(oldDescription);\n      });\n  }\n\n  /**\n   * Changes the notes for a story and records the change in the\n   * undo/redo service.\n   */\n  setStoryNotes(story: Story, notes: string): void {\n    let oldNotes = cloneDeep(story.getNotes());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_NOTES, oldNotes, notes,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let notes = this._getNewPropertyValueFromChangeDict(changeDict);\n        story.setNotes(notes);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setNotes(oldNotes);\n      });\n  }\n\n  /**\n   * Changes the language code of a story and records the change in\n   * the undo/redo service.\n   */\n  setStoryLanguageCode(story: Story, languageCode: string): void {\n    let oldLanguageCode = cloneDeep(story.getLanguageCode());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_LANGUAGE_CODE,\n      oldLanguageCode, languageCode,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let languageCode = this._getNewPropertyValueFromChangeDict(changeDict);\n        story.setLanguageCode(languageCode);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setLanguageCode(oldLanguageCode);\n      });\n  }\n\n  /**\n   * Changes the meta tag content of a story and records the change in\n   * the undo/redo service.\n   */\n  setStoryMetaTagContent(story: Story, metaTagContent: string): void {\n    let oldMetaTagContent = cloneDeep(story.getMetaTagContent());\n    this._applyStoryPropertyChange(\n      story, StoryDomainConstants.STORY_PROPERTY_META_TAG_CONTENT,\n      oldMetaTagContent, metaTagContent,\n      (changeDict, story) => {\n        // ---- Apply ----\n        let metaTagContent = (\n          this._getNewPropertyValueFromChangeDict(changeDict));\n        story.setMetaTagContent(metaTagContent);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.setMetaTagContent(oldMetaTagContent);\n      });\n  }\n\n  /**\n   * Sets the initial node of the story and records the change in\n   * the undo/redo service.\n   */\n  setInitialNodeId(story: Story, newInitialNodeId: string): void {\n    let oldInitialNodeId =\n      cloneDeep(story.getStoryContents().getInitialNodeId());\n    this._applyStoryContentsPropertyChange(\n      story, StoryDomainConstants.INITIAL_NODE_ID, oldInitialNodeId,\n      newInitialNodeId,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().setInitialNodeId(newInitialNodeId);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().setInitialNodeId(oldInitialNodeId);\n      });\n  }\n\n  /**\n   * Creates a story node, adds it to the story and records the change in\n   * the undo/redo service.\n   */\n  addStoryNode(story: Story, nodeTitle: string): void {\n    let nextNodeId = story.getStoryContents().getNextNodeId();\n    this._applyChange(story, StoryDomainConstants.CMD_ADD_STORY_NODE, {\n      node_id: nextNodeId,\n      title: nodeTitle\n    }, (changeDict, story) => {\n      // ---- Apply ----\n      story.getStoryContents().addNode(nodeTitle);\n      this._storyEditorStateService.setExpIdsChanged();\n    }, (changeDict, story) => {\n      // ---- Undo ----\n      let nodeId = this._getNodeIdFromChangeDict(changeDict);\n      story.getStoryContents().deleteNode(nodeId);\n      this._storyEditorStateService.setExpIdsChanged();\n    });\n  }\n\n  /**\n   * Removes a story node, and records the change in the undo/redo service.\n   */\n  deleteStoryNode(story: Story, nodeId: string): void {\n    this._applyChange(story, StoryDomainConstants.CMD_DELETE_STORY_NODE, {\n      node_id: nodeId\n    }, (changeDict, story) => {\n      // ---- Apply ----\n      story.getStoryContents().deleteNode(nodeId);\n      this._storyEditorStateService.setExpIdsChanged();\n    }, (changeDict, story) => {\n      // ---- Undo ----\n      throw new Error('A deleted story node cannot be restored.');\n    });\n  }\n\n  /**\n   * Marks the node outline of a node as finalized and records the change\n   * in the undo/redo service.\n   */\n  finalizeStoryNodeOutline(story: Story, nodeId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    if (storyNode.getOutlineStatus()) {\n      throw new Error('Node outline is already finalized.');\n    }\n    this._applyChange(\n      story, StoryDomainConstants.CMD_UPDATE_STORY_NODE_OUTLINE_STATUS, {\n        node_id: nodeId,\n        old_value: false,\n        new_value: true\n      }, (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().markNodeOutlineAsFinalized(nodeId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().markNodeOutlineAsNotFinalized(nodeId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  /**\n   * Marks the node outline of a node as not finalized and records the\n   * change in the undo/redo service.\n   */\n  unfinalizeStoryNodeOutline(story: Story, nodeId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    if (!storyNode.getOutlineStatus()) {\n      throw new Error('Node outline is already not finalized.');\n    }\n    this._applyChange(\n      story, StoryDomainConstants.CMD_UPDATE_STORY_NODE_OUTLINE_STATUS, {\n        node_id: nodeId,\n        old_value: true,\n        new_value: false\n      }, (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().markNodeOutlineAsNotFinalized(nodeId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().markNodeOutlineAsFinalized(nodeId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  /**\n   * Sets the outline of a node of the story and records the change\n   * in the undo/redo service.\n   */\n  setStoryNodeOutline(story: Story, nodeId: string, newOutline: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldOutline = storyNode.getOutline();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_OUTLINE, nodeId,\n      oldOutline, newOutline,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().setNodeOutline(nodeId, newOutline);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().setNodeOutline(\n          nodeId, oldOutline);\n      });\n  }\n\n  /**\n   * Sets the title of a node of the story and records the change\n   * in the undo/redo service.\n   */\n  setStoryNodeTitle(story: Story, nodeId: string, newTitle: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldTitle = storyNode.getTitle();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_TITLE, nodeId,\n      oldTitle, newTitle,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().setNodeTitle(nodeId, newTitle);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().setNodeTitle(nodeId, oldTitle);\n      });\n  }\n\n  /**\n   * Sets the description of a node of the story and records the change\n   * in the undo/redo service.\n   */\n  setStoryNodeDescription(\n      story: Story, nodeId: string, newDescription: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldDescription = storyNode.getDescription();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_DESCRIPTION, nodeId,\n      oldDescription, newDescription,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().setNodeDescription(nodeId, newDescription);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().setNodeDescription(nodeId, oldDescription);\n      });\n  }\n\n  /**\n   * Sets the thumbnail filename of a node of the story and records the\n   * change in the undo/redo service.\n   */\n  setStoryNodeThumbnailFilename(\n      story: Story, nodeId: string, newThumbnailFilename: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldThumbnailFilename = storyNode.getThumbnailFilename();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_THUMBNAIL_FILENAME,\n      nodeId, oldThumbnailFilename, newThumbnailFilename,\n      (changeDict, story) => {\n        // ---- Apply ----\n        storyNode.setThumbnailFilename(newThumbnailFilename);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        storyNode.setThumbnailFilename(oldThumbnailFilename);\n      });\n  }\n\n  /**\n   * Sets the thumbnail background color of a node of the story and records\n   * the change in the undo/redo service.\n   */\n  setStoryNodeThumbnailBgColor(\n      story: Story, nodeId: string, newThumbnailBgColor: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldThumbnailBgColor = storyNode.getThumbnailBgColor();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_THUMBNAIL_BG_COLOR,\n      nodeId, oldThumbnailBgColor, newThumbnailBgColor,\n      (changeDict, story) => {\n        // ---- Apply ----\n        storyNode.setThumbnailBgColor(newThumbnailBgColor);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        storyNode.setThumbnailBgColor(oldThumbnailBgColor);\n      });\n  }\n\n  /**\n   * Sets the id of the exploration that of a node of the story is linked\n   * to and records the change in the undo/redo service.\n   */\n  setStoryNodeExplorationId(\n      story: Story, nodeId: string, newExplorationId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldExplorationId = storyNode.getExplorationId();\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_EXPLORATION_ID,\n      nodeId, oldExplorationId, newExplorationId,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().setNodeExplorationId(\n          nodeId, newExplorationId);\n        this._storyEditorStateService.setExpIdsChanged();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().setNodeExplorationId(\n          nodeId, oldExplorationId);\n        this._storyEditorStateService.setExpIdsChanged();\n      });\n  }\n\n  /**\n   * Adds a destination node id to a node of a story and records the change\n   * in the undo/redo service.\n   */\n  addDestinationNodeIdToNode(\n      story: Story, nodeId: string, destinationNodeId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldDestinationNodeIds = cloneDeep(\n      storyNode.getDestinationNodeIds());\n    let newDestinationNodeIds = cloneDeep(oldDestinationNodeIds);\n    newDestinationNodeIds.push(destinationNodeId);\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_DESTINATION_NODE_IDS,\n      nodeId, oldDestinationNodeIds, newDestinationNodeIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().addDestinationNodeIdToNode(\n          nodeId, destinationNodeId);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().removeDestinationNodeIdFromNode(\n          nodeId, destinationNodeId);\n      });\n  }\n\n  /**\n   * Removes a destination node id from a node of a story and records the\n   * change in the undo/redo service.\n   */\n  removeDestinationNodeIdFromNode(\n      story: Story, nodeId: string, destinationNodeId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldDestinationNodeIds = cloneDeep(\n      storyNode.getDestinationNodeIds());\n    let newDestinationNodeIds = cloneDeep(oldDestinationNodeIds);\n    let index = newDestinationNodeIds.indexOf(destinationNodeId);\n    if (index === -1) {\n      throw new Error('The given destination node is not part of the node');\n    }\n    newDestinationNodeIds.splice(index, 1);\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_DESTINATION_NODE_IDS,\n      nodeId, oldDestinationNodeIds, newDestinationNodeIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().removeDestinationNodeIdFromNode(\n          nodeId, destinationNodeId);\n        this._storyEditorStateService.setExpIdsChanged();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().addDestinationNodeIdToNode(\n          nodeId, destinationNodeId);\n        this._storyEditorStateService.setExpIdsChanged();\n      });\n  }\n\n  /**\n   * Removes a node of a story and records the change in the\n   * undo/redo service.\n   */\n  rearrangeNodeInStory(story: Story, fromIndex: number, toIndex: number): void {\n    this._applyStoryContentsPropertyChange(\n      story, StoryDomainConstants.NODE, fromIndex, toIndex,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().rearrangeNodeInStory(fromIndex, toIndex);\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().rearrangeNodeInStory(fromIndex, toIndex);\n      });\n  }\n\n  /**\n   * Adds a prerequisite skill id to a node of a story and records the\n   * change in the undo/redo service.\n   */\n  addPrerequisiteSkillIdToNode(\n      story: Story, nodeId: string, skillId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldPrerequisiteSkillIds = cloneDeep(\n      storyNode.getPrerequisiteSkillIds());\n    let newPrerequisiteSkillIds = cloneDeep(oldPrerequisiteSkillIds);\n    newPrerequisiteSkillIds.push(skillId);\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_PREREQUISITE_SKILL_IDS,\n      nodeId, oldPrerequisiteSkillIds, newPrerequisiteSkillIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().addPrerequisiteSkillIdToNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().removePrerequisiteSkillIdFromNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  /**\n   * Removes a prerequisite skill id from a node of a story and records the\n   * change in the undo/redo service.\n   */\n  removePrerequisiteSkillIdFromNode(\n      story: Story, nodeId: string, skillId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldPrerequisiteSkillIds = cloneDeep(\n      storyNode.getPrerequisiteSkillIds());\n    let newPrerequisiteSkillIds = cloneDeep(oldPrerequisiteSkillIds);\n    let index = newPrerequisiteSkillIds.indexOf(skillId);\n    if (index === -1) {\n      throw new Error(\n        'The given prerequisite skill is not part of the node');\n    }\n    newPrerequisiteSkillIds.splice(index, 1);\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_PREREQUISITE_SKILL_IDS,\n      nodeId, oldPrerequisiteSkillIds, newPrerequisiteSkillIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().removePrerequisiteSkillIdFromNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().addPrerequisiteSkillIdToNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  /**\n   * Adds an acquired skill id to a node of a story and records the change\n   * in the undo/redo service.\n   */\n  addAcquiredSkillIdToNode(\n      story: Story, nodeId: string, skillId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldAcquiredSkillIds = cloneDeep(\n      storyNode.getAcquiredSkillIds());\n    let newAcquiredSkillIds = cloneDeep(oldAcquiredSkillIds);\n    newAcquiredSkillIds.push(skillId);\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_ACQUIRED_SKILL_IDS,\n      nodeId, oldAcquiredSkillIds, newAcquiredSkillIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().addAcquiredSkillIdToNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().removeAcquiredSkillIdFromNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  /**\n   * Removes an acquired skill id from a node of a story and records the\n   * change in the undo/redo service.\n   */\n  removeAcquiredSkillIdFromNode(\n      story: Story, nodeId: string, skillId: string): void {\n    let storyNode = this._getStoryNode(story.getStoryContents(), nodeId);\n    let oldAcquiredSkillIds = cloneDeep(\n      storyNode.getAcquiredSkillIds());\n    let newAcquiredSkillIds = cloneDeep(oldAcquiredSkillIds);\n    let index = newAcquiredSkillIds.indexOf(skillId);\n    if (index === -1) {\n      throw new Error(\n        'The given acquired skill id is not part of the node');\n    }\n    newAcquiredSkillIds.splice(index, 1);\n\n    this._applyStoryNodePropertyChange(\n      story, StoryDomainConstants.STORY_NODE_PROPERTY_ACQUIRED_SKILL_IDS,\n      nodeId, oldAcquiredSkillIds, newAcquiredSkillIds,\n      (changeDict, story) => {\n        // ---- Apply ----\n        story.getStoryContents().removeAcquiredSkillIdFromNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      }, (changeDict, story) => {\n        // ---- Undo ----\n        story.getStoryContents().addAcquiredSkillIdToNode(\n          nodeId, skillId);\n        this._storyChapterUpdateEventEmitter.emit();\n      });\n  }\n\n  get storyChapterUpdateEventEmitter(): EventEmitter<void> {\n    return this._storyChapterUpdateEventEmitter;\n  }\n}\n\nangular.module('oppia').factory(\n  'StoryUpdateService', downgradeInjectable(StoryUpdateService));\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/chapter-editor/chapter-editor-tab.component.html",
      "content": "<p class=\"oppia-mobile-back-to-parent\" (click)=\"navigateToStoryEditor()\">\n  <i class=\"fa fa-angle-left\"></i>\n  <span>Back to Story</span>\n</p>\n<div class=\"story-chapter-name\">\n  <span class=\"story-name e2e-test-back-to-story-editor-button\" (click)=\"navigateToStoryEditor()\">\n    {{ story.getTitle() }} /\n  </span>\n  <span class=\"chapter-name\">\n    {{ node.getTitle() }}\n  </span>\n</div>\n<div *ngIf=\"node\">\n  <oppia-story-node-editor [nodeId]=\"node.getId()\"\n                           [thumbnailFilename]=\"node.getThumbnailFilename()\"\n                           [thumbnailBgColor]=\"node.getThumbnailBgColor()\"\n                           [outline]=\"node.getOutline()\"\n                           [description]=\"node.getDescription()\"\n                           [explorationId]=\"node.getExplorationId()\"\n                           [outlineIsFinalized]=\"node.getOutlineStatus()\"\n                           [destinationNodeIds]=\"node.getDestinationNodeIds()\"\n                           [prerequisiteSkillIds]=\"node.getPrerequisiteSkillIds()\"\n                           [acquiredSkillIds]=\"node.getAcquiredSkillIds()\">\n  </oppia-story-node-editor>\n</div>\n<style>\n  .story-chapter-name {\n    font-size: 15px;\n    margin-bottom: 35px;\n    margin-left: 4%;\n  }\n  .story-name {\n    color: #666;\n    cursor: pointer;\n  }\n  @media screen and (max-width: 768px) {\n    .story-chapter-name {\n      display: none;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/chapter-editor/chapter-editor-tab.component.spec.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for chapter editor tab component.\n */\n\nimport { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core';\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { StoryBackendDict, Story } from 'domain/story/story.model';\nimport { StoryEditorNavigationService } from '../services/story-editor-navigation.service';\nimport { EditableStoryBackendApiService } from '../../../domain/story/editable-story-backend-api.service';\nimport { ChapterEditorTabComponent } from './chapter-editor-tab.component';\n\ndescribe('Chapter Editor Tab Component', () => {\n  let component: ChapterEditorTabComponent;\n  let fixture: ComponentFixture<ChapterEditorTabComponent>;\n  let storyInitializedEventEmitter;\n  let storyReinitializedEventEmitter;\n  let storyEditorStateService: StoryEditorStateService;\n\n  class MockStoryEditorNavigationService {\n    activeTab: string = 'chapter';\n    getActiveTab(): string {\n      return this.activeTab;\n    }\n\n    getChapterId = () => 'node_1';\n    getChapterIndex = () => null;\n    navigateToStoryEditor(): void {\n      this.activeTab = 'story';\n    }\n  }\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [ChapterEditorTabComponent],\n      providers: [\n        StoryEditorNavigationService,\n        EditableStoryBackendApiService,\n        {\n          provide: StoryEditorNavigationService,\n          useClass: MockStoryEditorNavigationService\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n  });\n\n  beforeEach(() => {\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(ChapterEditorTabComponent);\n    component = fixture.componentInstance;\n    let newStory = Story.createFromBackendDict({\n      id: 'storyId_0',\n      title: 'Story title',\n      description: 'Story Description',\n      notes: '<p>Notes/p>',\n      story_contents: {\n        initial_node_id: 'node_1',\n        next_node_id: 'node_2',\n        nodes: [{\n          id: 'node_1',\n          prerequisite_skill_ids: [],\n          acquired_skill_ids: [],\n          destination_node_ids: [],\n          outline: 'Outline',\n          exploration_id: null,\n          outline_is_finalized: false\n        }],\n      },\n      language_code: 'en',\n      story_contents_schema_version: 1,\n      version: 1,\n      corresponding_topic_id: 'topic_id'\n    } as unknown as StoryBackendDict);\n\n    storyInitializedEventEmitter = new EventEmitter();\n    storyReinitializedEventEmitter = new EventEmitter();\n\n    spyOnProperty(storyEditorStateService, 'onStoryInitialized').and.callFake(\n      () => {\n        return storyInitializedEventEmitter;\n      });\n    spyOnProperty(storyEditorStateService, 'onStoryReinitialized').and.callFake(\n      () => {\n        return storyReinitializedEventEmitter;\n      });\n\n    storyEditorStateService.setStory(newStory);\n  });\n\n  afterEach(() => {\n    component.ngOnDestroy();\n  });\n\n  it('should set initialize chapter index from the story', () => {\n    component.ngOnInit();\n    expect(component.chapterId).toEqual('node_1');\n    expect(component.chapterIndex).toEqual(0);\n  });\n\n  it('should call StoryEditorNavigationService to navigate to story editor',\n    () => {\n      component.ngOnInit();\n      component.navigateToStoryEditor();\n    });\n\n  it('should called initEditor on calls from story being initialized',\n    () => {\n      spyOn(component, 'initEditor').and.callThrough();\n      component.ngOnInit();\n      storyInitializedEventEmitter.emit();\n      storyReinitializedEventEmitter.emit();\n      expect(component.initEditor).toHaveBeenCalledTimes(3);\n    });\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/chapter-editor/chapter-editor-tab.component.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the chapter editor tab.\n */\n\nimport { Component, OnDestroy, OnInit } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { StoryEditorNavigationService } from '../services/story-editor-navigation.service';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { Story } from 'domain/story/story.model';\nimport { StoryContents } from 'domain/story/story-contents-object.model';\nimport { StoryNode } from 'domain/story/story-node.model';\n\n@Component({\n  selector: 'oppia-chapter-editor-tab',\n  templateUrl: './chapter-editor-tab.component.html'\n})\nexport class ChapterEditorTabComponent implements OnInit, OnDestroy {\n  story: Story;\n  storyContents: StoryContents;\n  chapterIndex: number | null;\n  chapterId: string;\n  node: StoryNode;\n  nodes: StoryNode[];\n\n  constructor(\n    private storyUpdateService: StoryUpdateService,\n    private storyEditorStateService: StoryEditorStateService,\n    private storyEditorNavigationService: StoryEditorNavigationService\n\n  ) {}\n\n  directiveSubscriptions = new Subscription();\n\n  initEditor(): void {\n    this.story = this.storyEditorStateService.getStory();\n    this.storyContents = this.story.getStoryContents();\n    this.chapterIndex = this.storyEditorNavigationService.getChapterIndex();\n    this.chapterId = this.storyEditorNavigationService.getChapterId();\n    if (this.storyContents &&\n        this.storyContents.getNodes().length > 0) {\n      this.nodes = this.storyContents.getNodes();\n      if (!this.chapterIndex) {\n        this.storyContents.getNodes().map((node, index) => {\n          if (node.getId() === this.chapterId) {\n            this.chapterIndex = index;\n            return;\n          }\n        });\n      }\n      this.node = this.nodes[this.chapterIndex];\n    }\n  }\n\n  navigateToStoryEditor(): void {\n    this.storyEditorNavigationService.navigateToStoryEditor();\n  }\n\n  ngOnInit(): void {\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryInitialized.subscribe(\n        () => this.initEditor()\n      )\n    );\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryReinitialized.subscribe(\n        () => this.initEditor()\n      )\n    );\n    this.directiveSubscriptions.add(\n      this.storyUpdateService.storyChapterUpdateEventEmitter.subscribe(\n        () => {}\n      )\n    );\n    this.initEditor();\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n}\n\nangular.module('oppia').directive('oppiaChapterEditorTab', downgradeComponent({\n  component: ChapterEditorTabComponent\n}));\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-editor.component.html",
      "content": "<p class=\"oppia-mobile-back-to-parent e2e-test-mobile-back-to-topic\" (click)=\"returnToTopicEditorPage()\">\n  <i class=\"fa fa-angle-left\"></i>\n  <span>Back to Topic</span>\n</p>\n<div class=\"topic-story-name\">\n  <span class=\"topic-name e2e-test-return-to-topic-button\" (click)=\"returnToTopicEditorPage()\">\n    {{ getTopicName() }} /\n  </span>\n  <span class=\"chapter-name\">\n    {{ story.getTitle() }}\n  </span>\n</div>\n<div role=\"form\" class=\"form-horizontal\">\n  <div class=\"parent-container\">\n    <div class=\"content-container\">\n      <mat-card class=\"oppia-page-card oppia-long-text content-card story-content-card oppia-mobile-collapsible-card\">\n        <div class=\"chapter-list-card-header oppia-mobile-collapsible-card-header\" (click)=\"toggleStoryEditorCard()\">\n          <h3 class=\"story-card-header\">Story Card</h3>\n          <i class=\"fa fa-caret-down\"\n             *ngIf=\"!mainStoryCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n          <i class=\"fa fa-caret-up\"\n             *ngIf=\"mainStoryCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n        </div>\n        <div class=\"oppia-mobile-collapsible-card-content\" *ngIf=\"mainStoryCardIsShown\">\n          <div class=\"story-content\">\n            <div class=\"story-title\">\n              <label for=\"storyTitle\" class=\"form-heading\">Title*</label>\n              <input id=\"storyTitle\" type=\"text\" class=\"form-control e2e-test-story-title-field\"\n                     [(ngModel)]=\"editableTitle\" (blur)=\"updateStoryTitle(editableTitle)\"\n                     [ngModelOptions]=\"{standalone: true}\"\n                     placeholder=\"Enter a title for the story.\" maxlength=\"{{ MAX_CHARS_IN_STORY_TITLE }}\" ng-trim=\"false\">\n              <span class=\"oppia-input-box-subtitle\">\n                <em>\n                  Story title should be at most {{ MAX_CHARS_IN_STORY_TITLE }} characters.\n                </em>\n              </span>\n            </div>\n            <div class=\"story-description\" [ngClass]=\"{'has-error': editableDescriptionIsEmpty && storyDescriptionChanged}\">\n              <label for=\"storyDescription\" class=\"form-heading\">Description*</label>\n              <textarea type=\"text\" class=\"form-control e2e-test-story-description-field\"\n                        maxlength=\"{{ MAX_CHARS_IN_STORY_DESCRIPTION }}\"\n                        [(ngModel)]=\"editableDescription\"\n                        [ngModelOptions]=\"{standalone: true}\"\n                        (change)=\"updateStoryDescriptionStatus(editableDescription)\"\n                        (blur)=\"updateStoryDescription(editableDescription)\"\n                        placeholder=\"Enter the description of the story\">\n              </textarea>\n              <span class=\"oppia-input-box-subtitle\">\n                <em>\n                  Story description should be at most\n                  {{ MAX_CHARS_IN_STORY_DESCRIPTION }} characters.\n                </em>\n              </span>\n              <span *ngIf=\"editableDescriptionIsEmpty && storyDescriptionChanged\" class=\"form-text story-contain-text\">\n                What does this story contain?\n              </span>\n            </div>\n            <div class=\"story-meta-tag-content\" [ngClass]=\"{'has-error': editableMetaTagContent.length === 0}\">\n              <label for=\"storyMetaTagContent\" class=\"form-heading e2e-test-story-meta-tag-content-label\">Meta Tag Content</label>\n              <textarea type=\"text\" class=\"form-control e2e-test-story-meta-tag-content-field oppia-autofocus\"\n                        [(ngModel)]=\"editableMetaTagContent\"\n                        [ngModelOptions]=\"{standalone: true}\"\n                        (blur)=\"updateStoryMetaTagContent(editableMetaTagContent)\"\n                        placeholder=\"Enter the meta tag content for the story\"\n                        maxlength=\"{{ MAX_CHARS_IN_META_TAG_CONTENT }}\"\n                        [oppiaFocusOn]=\"metaTagInputField\">\n              </textarea>\n            </div>\n            <div class=\"story-url-fragment\">\n              <label for=\"storyUrlFragment\" class=\"form-heading\">Url Fragment*</label>\n              <input id=\"storyUrlFragment\" type=\"text\" class=\"form-control e2e-test-story-url-fragment-field\"\n                     [(ngModel)]=\"editableUrlFragment\" (blur)=\"updateStoryUrlFragment(editableUrlFragment)\"\n                     [ngModelOptions]=\"{standalone: true}\"\n                     placeholder=\"Enter url fragment for the story.\" maxlength=\"{{ MAX_CHARS_IN_STORY_URL_FRAGMENT }}\" ng-trim=\"true\"\n                     [ngClass]=\"{'is-invalid': storyUrlFragmentExists}\">\n              <span class=\"oppia-input-box-subtitle\">\n                <em>\n                  The story URL fragment is used to uniquely access the story viewer page. It should consist of one or more hyphen-separated words, all in lowercase, with at most {{ MAX_CHARS_IN_STORY_URL_FRAGMENT }} characters in total and must be unique across the topic. Please use meaningful keywords, and avoid using words like \"and\", \"of\", or \"the\".\n                  This story can be accessed at the following URL:<br>\n                  {{ hostname }}/learn/{{ getClassroomUrlFragment() }}/{{ getTopicUrlFragment() }}/story/{{ editableUrlFragment }}\n                </em>\n              </span>\n              <div *ngIf=\"storyUrlFragmentExists\" class=\"oppia-input-box-subtitle text-danger\">\n                <em>\n                  This story URL fragment already exists.\n                </em>\n              </div>\n            </div>\n            <div class=\"story-thumbnail e2e-test-story-thumbnail\">\n              <label class=\"form-heading\">Thumbnail Image*</label>\n              <oppia-thumbnail-uploader [filename]=\"story?.getThumbnailFilename()\"\n                                        [useLocalStorage]=\"false\"\n                                        (updateFilename)=\"updateStoryThumbnailFilename($event)\"\n                                        [bgColor]=\"story?.getThumbnailBgColor()\"\n                                        (updateBgColor)=\"updateStoryThumbnailBgColor($event)\"\n                                        [allowedBgColors]=\"allowedBgColors\"\n                                        [aspectRatio]=\"'4:3'\"\n                                        [previewTitle]=\"editableTitle\"\n                                        [previewDescription]=\"editableDescription\">\n              </oppia-thumbnail-uploader>\n            </div>\n            <div class=\"story-notes\">\n              <div class=\"oppia-editor-card-body\">\n                <label class=\"form-heading\">Notes</label>\n                <div *ngIf=\"!notesEditorIsShown\">\n                  <div (click)=\"openNotesEditor()\" class=\"oppia-editable-section e2e-test-open-story-notes-editor-button\">\n                    <i class=\"fas fa-pen oppia-editor-edit-icon float-right story-editor-notes-edit-icon\"\n                       title=\"Edit Story Notes\">\n                    </i>\n                    <div class=\"oppia-state-content-display oppia-transition-200 oppia-prevent-selection\"\n                         title=\"Story notes\">\n                      <span class=\"oppia-placeholder\" [hidden]=\"!(editableNotes === '')\">\n                          Add notes about the story to help other contributors.\n                      </span>\n                      <oppia-rte-output-display class=\"story-notes e2e-test-story-notes\" [rteString]=\"editableNotes\">\n                      </oppia-rte-output-display>\n                    </div>\n                    <!-- This is a dummy div created to mask the contents when the user hovers over the content. -->\n                    <div class=\"oppia-editable-section-mask\">\n                    </div>\n                  </div>\n                </div>\n\n                <div *ngIf=\"notesEditorIsShown\" class=\"e2e-test-story-notes-rte\">\n                  <schema-based-editor [schema]=\"NOTES_SCHEMA\" [(ngModel)]=\"editableNotes\">\n                  </schema-based-editor>\n                  <div *ngIf=\"editableNotes.length > 4000\" class=\"story-length-validation-error\">\n                    The notes length is too long. Please make it under 4000 characters.\n                  </div>\n                  <div class=\"editor-buttons\">\n                    <button type=\"button\"\n                            class=\"btn btn-success oppia-save-state-item-button float-right e2e-test-save-story-notes-button\"\n                            [disabled]=\"!editableNotes || editableNotes.length > 4000\"\n                            (click)=\"updateNotes(editableNotes)\">\n                      Save\n                    </button>\n                    <button type=\"button\" class=\"btn btn-secondary float-right\" (click)=\"closeNotesEditor()\">Cancel</button>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div *ngIf=\"story.getThumbnailFilename() && mainStoryCardIsShown\">\n          <div *ngIf=\"!storyPreviewCardIsShown\" >\n            <button class=\"btn btn-default show-story-preview-button\" (click)=\"togglePreview()\">\n              Expand Preview\n              <i class=\"fa fa-angle-down\"></i>\n            </button>\n          </div>\n          <div *ngIf=\"storyPreviewCardIsShown\">\n            <button class=\"btn btn-default show-story-preview-button\" (click)=\"togglePreview()\">\n              Collapse Preview\n              <i class=\"fa fa-angle-up\"></i>\n            </button>\n          </div>\n          <div *ngIf=\"storyPreviewCardIsShown\">\n            <oppia-preview-thumbnail [name]=\"editableTitle\"\n                                     [aspectRatio]=\"'16:9'\"\n                                     [description]=\"editableDescription\"\n                                     [filename]=\"story.getThumbnailFilename()\"\n                                     [thumbnailBgColor]=\"story.getThumbnailBgColor()\"\n                                     bgColor=\"#2F6687\">\n            </oppia-preview-thumbnail>\n          </div>\n        </div>\n      </mat-card>\n    </div>\n\n    <div class=\"chapter-list-container\">\n      <mat-card class=\"oppia-page-card oppia-long-text content-card oppia-mobile-collapsible-card\">\n        <div class=\"story-node-editor\">\n          <div class=\"chapter-list-card-header oppia-mobile-collapsible-card-header e2e-test-mobile-add-chapter\"\n               (click)=\"toggleChapterLists()\">\n            <span>Chapters</span>\n            <i class=\"fa fa-caret-down\"\n               *ngIf=\"!chaptersListIsShown\"\n               aria-hidden=\"true\">\n            </i>\n            <i class=\"fa fa-caret-up\"\n               *ngIf=\"chaptersListIsShown\"\n               aria-hidden=\"true\">\n            </i>\n          </div>\n        </div>\n        <div *ngIf=\"chaptersListIsShown\" class=\"oppia-mobile-collapsible-card-content\">\n          <div>\n            <button (click)=\"createNode()\" class=\"btn add-chapter-btn e2e-test-add-chapter-button\">\n              + ADD CHAPTER\n            </button>\n            <div *ngIf=\"!linearNodesList.length\">\n              <p class=\"no-chapters-message\">\n                This story has no chapters.\n              </p>\n            </div>\n            <div *ngIf=\"linearNodesList.length\">\n              <div class=\"chapter-list-card-heading\">\n                <span>Name</span>\n              </div>\n              <div class=\"story-nodes-container\" cdkDropList (cdkDropListDropped)=\"drop($event)\">\n                <div *ngFor=\"let node of linearNodesList;index as idx\"\n                     cdkDrag>\n                  <div class=\"story-editor-node\"\n                       [ngClass]=\"{'selected-node': (node.getId() === idOfNodeToEdit)}\"\n                       (click)=\"navigateToChapterWithId(node.getId(), idx)\">\n                    <div class=\"story-editor-node-title\">\n                      <span> {{ idx+1 }}. </span>\n                      <span class=\"e2e-test-chapter-title\">{{ node.getTitle() }}</span>\n                    </div>\n                    <div class=\"edit-options-container\">\n                      <i class=\"fa fa-ellipsis-v chapter-edit-toggle-button e2e-test-edit-options\"\n                         (click)=\"toggleChapterEditOptions(idx);$event.stopPropagation()\"\n                         aria-label=\"Chapter edit\">\n                      </i>\n                    </div>\n                    <div class=\"chapter-option-box\"\n                         *ngIf=\"selectedChapterIndex === idx\"\n                         (mouseleave)=\"toggleChapterEditOptions(-1)\"\n                         (click)=\"toggleChapterEditOptions(-1);$event.stopPropagation()\">\n                      <div class=\"chapter-edit-option e2e-test-delete-chapter-button\"\n                           (click)=\"deleteNode(node.getId())\">\n                        <i class=\"fa fa-trash\"></i>\n                        <span>Delete</span>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </mat-card>\n    </div>\n  </div>\n</div>\n\n<style>\n  .story-length-validation-error {\n    align-items: center;\n    background-color: #f8d7da;\n    border: 0.0625rem solid #dc3545;\n    border-radius: 0.25rem;\n    color: #dc3545;\n    display: flex;\n    justify-content: center;\n    padding: 0.25rem;\n  }\n\n  .no-chapters-message {\n    font-family: 'Capriola', 'Roboto', Arial, sans-serif;\n    font-size: 18px;\n    padding-top: 6px;\n    text-align: center;\n  }\n\n  .story-editor-node {\n    align-items: center;\n    border-bottom: 1px solid #dbdbdb;\n    cursor: pointer;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    padding: 15px 0;\n    position: relative;\n  }\n\n  .story-editor-node-title {\n    cursor: pointer;\n    text-align: left;\n    width: 95%;\n  }\n\n  story-editor-node:hover {\n    cursor: grab;\n  }\n\n  .topic-story-name {\n    font-size: 15px;\n    margin-bottom: 35px;\n    margin-left: 4%;\n  }\n\n  .topic-name {\n    color: #666;\n    cursor: pointer;\n  }\n\n  story-editor-node:active {\n    cursor: move;\n  }\n\n  .story-nodes-container {\n    background-color: #fff;\n    text-align: left;\n    white-space: initial;\n  }\n\n  .node-editor {\n    display: inline-block;\n    min-height: 25vh;\n    padding-left: 5%;\n    width: 65%;\n  }\n\n  .story-node-editor {\n    margin-top: 20px;\n  }\n\n  .form-heading {\n    font-size: 15px;\n  }\n\n  .story-title {\n    margin: 20px 0 15px;\n  }\n\n  .story-thumbnail {\n    margin: 25px 0;\n  }\n\n  .story-nodes-title {\n    margin-bottom: 2%;\n  }\n\n  .story-notes .save-button {\n    margin-top: 1.5vh;\n  }\n\n  .story-description textarea,\n  .story-meta-tag-content textarea {\n    height: 10vh;\n  }\n\n  .story-meta-tag-content {\n    margin-bottom: 25px;\n    margin-top: 32px;\n  }\n\n  .parent-container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin: 0 auto;\n    width: 85%;\n  }\n  .content-container {\n    margin-bottom: 40px;\n    margin-right: 3%;\n    width: 50%;\n  }\n  .chapter-list-container {\n    width: 35%;\n  }\n  .content-card {\n    margin: 0;\n  }\n  .chapter-editor-card {\n    width: 80%;\n  }\n  .show-story-preview-button {\n    border-top: 1px solid #c1c1c1;\n    color: #00645d;\n    font-size: 15px;\n    padding: 10px 0;\n    width: 100%;\n  }\n  .story-content-card {\n    padding: 0;\n  }\n  .story-content {\n    padding: 5px 55px 30px 45px;\n  }\n  .story-notes p {\n     margin: 0;\n  }\n  .story-card-header {\n    font-size: 20px;\n    margin: 40px 18px 5px;\n  }\n  .story-contain-text {\n    font-size: smaller;\n  }\n  .add-chapter-btn {\n    background-color: #008098;\n    color: #fff;\n    font-weight: bold;\n    margin: 15px 0 15px;\n    text-align: left;\n  }\n  .chapter-list-card-header {\n    align-items: center;\n    display: flex;\n    flex-wrap: wrap;\n    font-size: 20px;\n    font-weight: bold;\n    justify-content: space-between;\n  }\n  .chapter-list-card-heading {\n    border-bottom: 2px solid #000;\n    padding-left: 4%;\n  }\n  .chapter-list-card-heading span {\n    font-weight: bold;\n  }\n  .chapter-option-box {\n    background-color: #e1dcdc;\n    border: 1px solid #000;\n    padding: 0;\n    position: absolute;\n    right: -5px;\n    width: 140px;\n    z-index: 1;\n  }\n  .chapter-edit-option {\n    cursor: pointer;\n    font-size: 15px;\n    padding: 5px;\n    text-align: left;\n  }\n  .chapter-edit-option span {\n    margin-left: 5%;\n  }\n  .chapter-edit-toggle-button {\n    cursor: pointer;\n    position: relative;\n  }\n  .chapter-list-card-header i {\n    display: none;\n  }\n  .story-editor-notes-edit-icon {\n    padding-top: 4px;\n  }\n  .cdk-drag-placeholder {\n    opacity: 0;\n  }\n  @media screen and (max-width: 1150px) {\n    .content-container {\n        width: 55%;\n    }\n    .chapter-list-container {\n      margin-right: 2%;\n      width: 35%;\n    }\n  }\n  @media screen and (max-width: 1000px) {\n    .parent-container {\n        width: 100%;\n    }\n    .chapter-list-container {\n      margin-right: 0;\n      width: 40%;\n    }\n  }\n  @media screen and (max-width: 800px) {\n    .story-content {\n      padding: 0;\n    }\n  }\n  @media screen and (max-width: 768px) {\n    .content-container,\n    .chapter-list-container {\n      margin-bottom: 100px;\n      margin-right: 0;\n      width: 100%;\n    }\n\n    .content-container {\n      margin-bottom: 0;\n    }\n\n    .topic-story-name {\n      display: none;\n    }\n\n    .chapter-list-container {\n      margin-top: 40px;\n    }\n\n    .story-notes {\n      width: 95%;\n    }\n\n    .story-node-editor {\n      margin-top: 0;\n    }\n\n    .story-card-header {\n      margin: 0;\n    }\n\n    .chapter-option-box {\n      right: 20px;\n    }\n\n    .chapter-list-card-header i {\n      display: block;\n    }\n    .chapter-list-card-header div {\n      margin-top: 16px;\n      width: 100%;\n    }\n    .chapter-list-card-header {\n      margin-bottom: 0;\n      padding-bottom: 18px;\n    }\n    .chapter-list-card-heading {\n      padding-top: 15px;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-editor.component.spec.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the story editor component.\n */\n\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core';\nimport { ComponentFixture, TestBed, fakeAsync, tick, waitForAsync } from '@angular/core/testing';\nimport { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { WindowDimensionsService } from 'services/contextual/window-dimensions.service';\nimport { StoryEditorNavigationService } from '../services/story-editor-navigation.service';\nimport { StoryEditorComponent } from './story-editor.component';\nimport { WindowRef } from 'services/contextual/window-ref.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { Story } from 'domain/story/story.model';\nimport { NewChapterTitleModalComponent } from '../modal-templates/new-chapter-title-modal.component';\nimport { DeleteChapterModalComponent } from '../modal-templates/delete-chapter-modal.component';\nimport { CdkDragDrop } from '@angular/cdk/drag-drop';\nimport { StoryNode } from 'domain/story/story-node.model';\n\nclass MockNgbModalRef {\n  componentInstance: {\n    body: 'xyz';\n  };\n}\n\nclass MockNgbModal {\n  open() {\n    return {\n      result: Promise.resolve()\n    };\n  }\n}\n\ndescribe('Story Editor Component having two story nodes', () => {\n  let component: StoryEditorComponent;\n  let fixture: ComponentFixture<StoryEditorComponent>;\n  let ngbModal: NgbModal;\n  let story: Story;\n  let windowDimensionsService: WindowDimensionsService;\n  let undoRedoService: UndoRedoService;\n  let storyEditorNavigationService: StoryEditorNavigationService;\n  let storyUpdateService: StoryUpdateService;\n  let storyEditorStateService: StoryEditorStateService;\n  let windowRef: WindowRef;\n  let fetchSpy;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        StoryEditorComponent,\n        NewChapterTitleModalComponent,\n        DeleteChapterModalComponent\n      ],\n      providers: [\n        WindowDimensionsService,\n        UndoRedoService,\n        StoryEditorNavigationService,\n        StoryUpdateService,\n        StoryEditorStateService,\n        {\n          provide: NgbModal,\n          useClass: MockNgbModal\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    });\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(\n      StoryEditorComponent);\n    component = fixture.componentInstance;\n    ngbModal = TestBed.inject(NgbModal);\n    windowDimensionsService = TestBed.inject(WindowDimensionsService);\n    storyEditorNavigationService = TestBed.inject(\n      StoryEditorNavigationService);\n    undoRedoService = TestBed.inject(UndoRedoService);\n    windowRef = TestBed.inject(WindowRef);\n    storyUpdateService = TestBed.inject(StoryUpdateService);\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n\n\n    let sampleStoryBackendObject = {\n      id: 'sample_story_id',\n      title: 'Story title',\n      description: 'Story description',\n      notes: 'Story notes',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      url_fragment: 'story_title',\n      story_contents: {\n        initial_node_id: 'node_2',\n        nodes: [\n          {\n            id: 'node_1',\n            title: 'Title 1',\n            description: 'Description 1',\n            prerequisite_skill_ids: ['skill_1'],\n            acquired_skill_ids: ['skill_2'],\n            destination_node_ids: [],\n            outline: 'Outline',\n            exploration_id: null,\n            outline_is_finalized: false\n          }, {\n            id: 'node_2',\n            title: 'Title 2',\n            description: 'Description 2',\n            prerequisite_skill_ids: ['skill_3'],\n            acquired_skill_ids: ['skill_4'],\n            destination_node_ids: ['node_1'],\n            outline: 'Outline 2',\n            exploration_id: 'exp_1',\n            outline_is_finalized: true\n          }],\n        next_node_id: 'node_3'\n      },\n      language_code: 'en'\n    };\n    story = Story.createFromBackendDict(sampleStoryBackendObject);\n\n    spyOn(windowDimensionsService, 'isWindowNarrow').and.returnValue(true);\n    fetchSpy = spyOn(storyEditorStateService, 'getStory')\n      .and.returnValue(story);\n    spyOn(storyEditorStateService, 'getClassroomUrlFragment').and.returnValue(\n      'math');\n    spyOn(storyEditorStateService, 'getTopicUrlFragment').and.returnValue(\n      'fractions');\n    spyOn(storyEditorStateService, 'getTopicName').and.returnValue('addition');\n    component.ngOnInit();\n  });\n\n  afterEach(() => {\n    component.ngOnDestroy();\n  });\n\n  it('should change list oder', fakeAsync(() => {\n    spyOn(storyUpdateService, 'rearrangeNodeInStory').and.stub();\n    component.linearNodesList = [StoryNode.createFromBackendDict({\n      id: 'node_1',\n      thumbnail_filename: 'image.png',\n      title: 'Title 1',\n      description: 'Description 1',\n      prerequisite_skill_ids: ['skill_1'],\n      acquired_skill_ids: ['skill_2'],\n      destination_node_ids: ['node_2'],\n      outline: 'Outline',\n      exploration_id: null,\n      outline_is_finalized: false,\n      thumbnail_bg_color: '#a33f40'\n    }),\n    StoryNode.createFromBackendDict({\n      id: 'node_2',\n      thumbnail_filename: 'image.png',\n      title: 'Title 2',\n      description: 'Description 2',\n      prerequisite_skill_ids: ['skill_1'],\n      acquired_skill_ids: ['skill_2'],\n      destination_node_ids: ['node_2'],\n      outline: 'Outline',\n      exploration_id: null,\n      outline_is_finalized: false,\n      thumbnail_bg_color: '#a33f40'\n    }),\n    StoryNode.createFromBackendDict({\n      id: 'node_3',\n      thumbnail_filename: 'image.png',\n      title: 'Title 3',\n      description: 'Description 3',\n      prerequisite_skill_ids: ['skill_1'],\n      acquired_skill_ids: ['skill_2'],\n      destination_node_ids: ['node_2'],\n      outline: 'Outline',\n      exploration_id: null,\n      outline_is_finalized: false,\n      thumbnail_bg_color: '#a33f40'\n    })];\n\n    const event1 = {\n      previousIndex: 0,\n      currentIndex: 1,\n    } as CdkDragDrop<string[]>;\n    const event2 = {\n      previousIndex: 1,\n      currentIndex: 0,\n    } as CdkDragDrop<string[]>;\n\n    component.drop(event1);\n    tick();\n    component.drop(event2);\n    tick();\n\n    expect(storyUpdateService.rearrangeNodeInStory).toHaveBeenCalledTimes(2);\n  }));\n\n  it('should display topicname on main story card', () => {\n    expect(component.storyPreviewCardIsShown).toEqual(false);\n    expect(component.mainStoryCardIsShown).toEqual(true);\n    expect(component.getTopicName()).toEqual('addition');\n  });\n\n  it('should toggle story preview card', () => {\n    component.storyPreviewCardIsShown = false;\n\n    component.togglePreview();\n\n    expect(component.mainStoryCardIsShown).toEqual(true);\n  });\n\n  it('should toggle chapter edit options', () => {\n    component.toggleChapterEditOptions(10);\n\n    expect(component.selectedChapterIndex).toEqual(10);\n\n    component.toggleChapterEditOptions(10);\n\n    expect(component.selectedChapterIndex).toEqual(-1);\n  });\n\n  it('should toggle chapter lists', () => {\n    component.chaptersListIsShown = false;\n\n    component.toggleChapterLists();\n\n    expect(component.chaptersListIsShown).toEqual(true);\n\n    component.toggleChapterLists();\n    expect(component.chaptersListIsShown).toEqual(false);\n  });\n\n  it('should toggle main story card', () => {\n    component.mainStoryCardIsShown = false;\n\n    component.toggleStoryEditorCard();\n\n    expect(component.mainStoryCardIsShown).toEqual(true);\n\n    component.toggleStoryEditorCard();\n\n    expect(component.mainStoryCardIsShown).toEqual(false);\n  });\n\n  it('should open and close notes editor', () => {\n    component.notesEditorIsShown = false;\n\n    component.openNotesEditor();\n\n    expect(component.notesEditorIsShown).toEqual(true);\n\n    component.closeNotesEditor();\n\n    expect(component.notesEditorIsShown).toEqual(false);\n  });\n\n  it('should return when the node is the initial node', () => {\n    expect(component.isInitialNode('node_1')).toEqual(false);\n    expect(component.isInitialNode('node_2')).toEqual(true);\n  });\n\n  it('should call StoryUpdate to update story title', () => {\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setStoryTitle');\n\n    component.updateStoryTitle('title99');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should call StoryUpdate to update story thumbnail filename', () => {\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setThumbnailFilename');\n\n    component.updateStoryThumbnailFilename('abcd');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should call StoryUpdate to update story thumbnail bg color', () => {\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setThumbnailBgColor');\n\n    component.updateStoryThumbnailBgColor('abcd');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should return the classroom and topic url fragment', () => {\n    expect(component.getClassroomUrlFragment()).toEqual('math');\n    expect(component.getTopicUrlFragment()).toEqual('fractions');\n  });\n\n  it('should not open confirm or cancel modal if the initial node is' +\n      ' being deleted',\n  () => {\n    let modalSpy = spyOn(ngbModal, 'open');\n\n    component.deleteNode('node_2');\n\n    expect(modalSpy).not.toHaveBeenCalled();\n  });\n\n  it('should open confirm or cancel modal when a node is being deleted',\n    fakeAsync(() => {\n      let modalSpy = spyOn(ngbModal, 'open').and.returnValue({\n        result: Promise.resolve()\n      } as NgbModalRef);\n      let storyUpdateSpy = spyOn(\n        storyUpdateService, 'deleteStoryNode').and.stub();\n\n      component.deleteNode('node_1');\n      tick();\n\n      expect(storyUpdateSpy).toHaveBeenCalled();\n      expect(modalSpy).toHaveBeenCalled();\n    }));\n\n  it('should call storyUpdateService to add destination node id',\n    () => {\n      class MockComponentInstance {\n        compoenentInstance!: {\n          nodeTitles: null;\n        };\n      }\n\n      let modalSpy = spyOn(ngbModal, 'open').and.callFake(() => {\n        return ({\n          componentInstance: MockComponentInstance,\n          result: Promise.resolve()\n        }) as NgbModalRef;\n      });\n\n      component.createNode();\n\n      expect(modalSpy).toHaveBeenCalled();\n    });\n\n  it('should call storyUpdateService to add destination node id',\n    fakeAsync(() => {\n      class MockComponentInstance {\n        compoenentInstance!: {\n          nodeTitles: null;\n        };\n      }\n      let sampleStoryBackendObject = {\n        id: 'sample_story_id',\n        title: 'Story title',\n        description: 'Story description',\n        notes: 'Story notes',\n        version: 1,\n        corresponding_topic_id: 'topic_id',\n        story_contents: {\n          initial_node_id: 'node_1',\n          nodes: [\n            {\n              id: 'node_1',\n              title: 'Title 1',\n              description: 'Description 1',\n              prerequisite_skill_ids: ['skill_1'],\n              acquired_skill_ids: ['skill_2'],\n              destination_node_ids: [],\n              outline: 'Outline',\n              exploration_id: 'exp_id',\n              outline_is_finalized: false,\n              thumbnail_filename: 'fileName',\n              thumbnail_bg_color: 'blue',\n            }],\n          next_node_id: 'node_1'\n        },\n        language_code: 'en',\n        thumbnail_filename: 'fileName',\n        thumbnail_bg_color: 'blue',\n        url_fragment: 'url',\n        meta_tag_content: 'meta'\n      };\n      spyOn(component, '_initEditor').and.stub();\n      component.story = Story.createFromBackendDict(\n        sampleStoryBackendObject);\n      let modalSpy = spyOn(ngbModal, 'open').and.callFake(() => {\n        return ({\n          componentInstance: MockComponentInstance,\n          result: Promise.resolve()\n        }) as NgbModalRef;\n      });\n\n      component.createNode();\n      tick();\n\n      expect(modalSpy).toHaveBeenCalled();\n    }));\n\n  it('should call storyUpdateService to add destination node id',\n    fakeAsync(() => {\n      class MockComponentInstance {\n        compoenentInstance!: {\n          nodeTitles: null;\n        };\n      }\n      let storySpy = spyOn(storyUpdateService, 'addDestinationNodeIdToNode');\n      let modalSpy = spyOn(ngbModal, 'open').and.returnValue({\n        componentInstance: MockComponentInstance,\n        result: Promise.resolve()\n      } as NgbModalRef);\n\n      component.createNode();\n      tick();\n\n      expect(modalSpy).toHaveBeenCalled();\n      expect(storySpy).toHaveBeenCalled();\n    }));\n\n  it('should call storyUpdateService to update story notes', () => {\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setStoryNotes');\n\n    component.updateNotes('Updated the story notes');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should call storyUpdateService to update story notes', () => {\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setStoryMetaTagContent');\n\n    component.updateStoryMetaTagContent('storyone');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should call not update url fragment if it is unchanged', () => {\n    component.storyUrlFragmentExists = true;\n\n    component.updateStoryUrlFragment('story_title');\n\n    expect(component.storyUrlFragmentExists).toEqual(false);\n  });\n\n  it('should update the existence of story url fragment', () => {\n    let storyUpdateSpy = spyOn(\n      storyEditorStateService,\n      'updateExistenceOfStoryUrlFragment').and.callFake(\n      (urlFragment, callback) => callback());\n\n    component.updateStoryUrlFragment('story_second');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should set story url fragment', () => {\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryUrlFragment');\n\n    component.updateStoryUrlFragment('');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should call storyEditorNavigationService to navigate to chapters',\n    () => {\n      let navigationSpy = spyOn(\n        storyEditorNavigationService, 'navigateToChapterEditorWithId');\n\n      component.navigateToChapterWithId('chapter_1', 0);\n\n      expect(navigationSpy).toHaveBeenCalled();\n    });\n\n  it('should make story description status', () => {\n    component.editableDescriptionIsEmpty = true;\n    component.storyDescriptionChanged = false;\n    component.updateStoryDescriptionStatus('New description');\n    component.editableDescriptionIsEmpty = false;\n    component.storyDescriptionChanged = true;\n  });\n\n  it('should update the story description', () => {\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryDescription');\n\n    component.updateStoryDescription('New skill description');\n\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should show modal if there are unsaved changes on leaving', () => {\n    spyOn(undoRedoService, 'getChangeCount').and.returnValue(10);\n    const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n      return ({\n        componentInstance: MockNgbModalRef,\n        result: Promise.resolve()\n      }) as NgbModalRef;\n    });\n\n    component.returnToTopicEditorPage();\n\n    expect(modalSpy).toHaveBeenCalled();\n  });\n\n  it('should show modal if there are unsaved changes and click reject',\n    () => {\n      spyOn(undoRedoService, 'getChangeCount').and.returnValue(10);\n      const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n        return ({\n          componentInstance: MockNgbModalRef,\n          result: Promise.reject()\n        }) as NgbModalRef;\n      });\n\n      component.returnToTopicEditorPage();\n      expect(modalSpy).toHaveBeenCalled();\n    });\n\n  it('should call windowref to open a tab', () => {\n    spyOn(undoRedoService, 'getChangeCount').and.returnValue(0);\n    spyOnProperty(windowRef, 'nativeWindow').and.returnValue({\n      open: jasmine.createSpy('open', () => {})\n    });\n\n    component.returnToTopicEditorPage();\n\n    expect(windowRef.nativeWindow.open).toHaveBeenCalled();\n  });\n\n  it('should fetch story when story is initialized', () => {\n    let mockEventEmitter = new EventEmitter();\n    spyOnProperty(storyEditorStateService, 'onStoryInitialized')\n      .and.returnValue(mockEventEmitter);\n\n    component.ngOnInit();\n    mockEventEmitter.emit();\n\n    expect(fetchSpy).toHaveBeenCalled();\n  });\n\n  it('should fetch story when story is reinitialized', () => {\n    let mockEventEmitter = new EventEmitter();\n    spyOnProperty(storyEditorStateService, 'onStoryReinitialized')\n      .and.returnValue(mockEventEmitter);\n\n    component.ngOnInit();\n    mockEventEmitter.emit();\n\n    expect(fetchSpy).toHaveBeenCalled();\n  });\n\n  it('should fetch story node when story editor is opened', () => {\n    let mockEventEmitter = new EventEmitter();\n    spyOnProperty(storyEditorStateService, 'onViewStoryNodeEditor')\n      .and.returnValue(mockEventEmitter);\n\n    component.ngOnInit();\n    mockEventEmitter.emit();\n\n    expect(fetchSpy).toHaveBeenCalled();\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-editor.component.ts",
      "content": "// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controller for the main story editor.\n */\n\nimport { Subscription } from 'rxjs';\nimport { SavePendingChangesModalComponent } from 'components/save-pending-changes/save-pending-changes-modal.component';\nimport { Component, OnDestroy, OnInit } from '@angular/core';\nimport { AppConstants } from 'app.constants';\nimport { WindowRef } from 'services/contextual/window-ref.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { WindowDimensionsService } from 'services/contextual/window-dimensions.service';\nimport { AlertsService } from 'services/alerts.service';\nimport { FocusManagerService } from 'services/stateful/focus-manager.service';\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { StoryNode } from 'domain/story/story-node.model';\nimport { StoryEditorNavigationService } from '../services/story-editor-navigation.service';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';\nimport { NewChapterTitleModalComponent } from '../modal-templates/new-chapter-title-modal.component';\nimport { DeleteChapterModalComponent } from '../modal-templates/delete-chapter-modal.component';\nimport { Story } from 'domain/story/story.model';\nimport { StoryContents } from 'domain/story/story-contents-object.model';\nimport { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';\n\n@Component({\n  selector: 'oppia-story-editor',\n  templateUrl: './story-editor.component.html'\n})\nexport class StoryEditorComponent implements OnInit, OnDestroy {\n  story: Story;\n  storyContents: StoryContents;\n  disconnectedNodes: string[];\n  linearNodesList: StoryNode[];\n  nodes: StoryNode[];\n  allowedBgColors = (\n    AppConstants.ALLOWED_THUMBNAIL_BG_COLORS.story);\n\n  initialNodeId: string;\n  notesEditorIsShown: boolean;\n  storyTitleEditorIsShown: boolean;\n  editableTitle: string;\n  editableUrlFragment: string;\n  editableMetaTagContent: string;\n  initialStoryUrlFragment: string;\n  editableNotes: string;\n  editableDescription: string;\n  editableDescriptionIsEmpty: boolean;\n  storyDescriptionChanged: boolean;\n  storyUrlFragmentExists: boolean;\n  idOfNodeToEdit: string;\n  dragStartIndex: number;\n  nodeBeingDragged: StoryNode;\n  mainStoryCardIsShown: boolean;\n  storyPreviewCardIsShown: boolean;\n  chaptersListIsShown: boolean;\n  selectedChapterIndex: number;\n  NOTES_SCHEMA = {\n    type: 'html',\n    ui_config: {\n      startupFocusEnabled: false\n    }\n  };\n\n  constructor(\n    private alertsService: AlertsService,\n    private windowRef: WindowRef,\n    private focusManagerService: FocusManagerService,\n    private storyEditorStateService: StoryEditorStateService,\n    private ngbModal: NgbModal,\n    private storyUpdateService: StoryUpdateService,\n    private windowDimensionsService: WindowDimensionsService,\n    private storyEditorNavigationService: StoryEditorNavigationService,\n    private undoRedoService: UndoRedoService,\n    private urlInterpolationService: UrlInterpolationService\n  ) {}\n\n  directiveSubscriptions = new Subscription();\n  MAX_CHARS_IN_STORY_DESCRIPTION = (\n    AppConstants.MAX_CHARS_IN_STORY_DESCRIPTION);\n\n  MAX_CHARS_IN_STORY_TITLE = AppConstants.MAX_CHARS_IN_STORY_TITLE;\n\n  MAX_CHARS_IN_STORY_URL_FRAGMENT = (\n    AppConstants.MAX_CHARS_IN_STORY_URL_FRAGMENT);\n\n  MAX_CHARS_IN_META_TAG_CONTENT = AppConstants.MAX_CHARS_IN_META_TAG_CONTENT;\n\n  hostname = this.windowRef.nativeWindow.location.hostname;\n  TOPIC_EDITOR_URL_TEMPLATE = '/topic_editor/<topic_id>';\n\n  _init(): void {\n    this.story = this.storyEditorStateService.getStory();\n    if (this.story) {\n      this.storyContents = this.story.getStoryContents();\n    }\n    if (this.storyContents) {\n      this.setNodeToEdit(this.storyContents.getInitialNodeId());\n    }\n    this._initEditor();\n  }\n\n  drop(event: CdkDragDrop<string[]>): void {\n    moveItemInArray(\n      this.linearNodesList,\n      event.previousIndex, event.currentIndex);\n    if (event.previousIndex === 0) {\n      this.storyUpdateService.setInitialNodeId(\n        this.story, this.story.getStoryContents().getNodes()[\n          event.currentIndex].getId());\n    }\n    if (event.currentIndex === 0) {\n      this.storyUpdateService.setInitialNodeId(\n        this.story, this.story.getStoryContents().getNodes()[\n          event.previousIndex].getId());\n    }\n    this.storyUpdateService.rearrangeNodeInStory(\n      this.story, event.previousIndex, event.currentIndex);\n    this._initEditor();\n  }\n\n  _initEditor(): void {\n    this.story = this.storyEditorStateService.getStory();\n    if (this.story) {\n      this.storyContents = this.story.getStoryContents();\n      this.disconnectedNodes = [];\n      this.linearNodesList = [];\n      this.nodes = [];\n      if (this.storyContents &&\n          this.storyContents.getNodes().length > 0) {\n        this.nodes = this.storyContents.getNodes();\n        this.initialNodeId = this.storyContents.getInitialNodeId();\n        this.linearNodesList =\n          this.storyContents.getLinearNodesList();\n      }\n      this.notesEditorIsShown = false;\n      this.storyTitleEditorIsShown = false;\n      this.editableTitle = this.story.getTitle();\n      this.editableUrlFragment = this.story.getUrlFragment();\n      this.editableMetaTagContent = this.story.getMetaTagContent();\n      this.initialStoryUrlFragment = this.story.getUrlFragment();\n      this.editableNotes = this.story.getNotes();\n      this.editableDescription = this.story.getDescription();\n      this.editableDescriptionIsEmpty = (\n        this.editableDescription === '');\n      this.storyDescriptionChanged = false;\n      this.storyUrlFragmentExists = false;\n    }\n  }\n\n  setNodeToEdit(nodeId: string): void {\n    this.idOfNodeToEdit = nodeId;\n  }\n\n  openNotesEditor(): void {\n    this.notesEditorIsShown = true;\n  }\n\n  closeNotesEditor(): void {\n    this.notesEditorIsShown = false;\n  }\n\n  isInitialNode(nodeId: string): boolean {\n    return (\n      this.story.getStoryContents().getInitialNodeId() === nodeId);\n  }\n\n  deleteNode(nodeId: string): void {\n    if (this.isInitialNode(nodeId)) {\n      this.alertsService.addInfoMessage(\n        'Cannot delete the first chapter of a story.', 3000);\n      return;\n    }\n    this.ngbModal.open(DeleteChapterModalComponent, {\n      backdrop: true,\n    }).result.then(() => {\n      this.storyUpdateService.deleteStoryNode(this.story, nodeId);\n      this._initEditor();\n      this.storyEditorStateService.onRecalculateAvailableNodes.emit();\n    }, () => {\n      // Note to developers:\n      // This callback is triggered when the Cancel button is clicked.\n      // No further action is needed.\n    });\n  }\n\n  createNode(): void {\n    let nodeTitles = this.linearNodesList.map((node) => {\n      return node.getTitle();\n    });\n    const modalRef = this.ngbModal.open(NewChapterTitleModalComponent, {\n      backdrop: 'static',\n      windowClass: 'create-new-chapter',\n    });\n    modalRef.componentInstance.nodeTitles = nodeTitles;\n    modalRef.result.then(() => {\n      this._initEditor();\n      // If the first node is added, open it just after creation.\n      if (this.story.getStoryContents().getNodes().length === 1) {\n        this.setNodeToEdit(\n          this.story.getStoryContents().getInitialNodeId());\n      } else {\n        let nodesArray = this.story.getStoryContents().getNodes();\n        let nodesLength = nodesArray.length;\n        let secondLastNodeId = nodesArray[nodesLength - 2].getId();\n        let lastNodeId = nodesArray[nodesLength - 1].getId();\n        this.storyUpdateService.addDestinationNodeIdToNode(\n          this.story, secondLastNodeId, lastNodeId);\n      }\n      this.storyEditorStateService.onRecalculateAvailableNodes.emit();\n    }, () => {\n      // Note to developers:\n      // This callback is triggered when the Cancel button is clicked.\n      // No further action is needed.\n    });\n  }\n\n  updateNotes(newNotes: string): void {\n    if (newNotes !== this.story.getNotes()) {\n      this.storyUpdateService.setStoryNotes(this.story, newNotes);\n      this._initEditor();\n    }\n  }\n\n  navigateToChapterWithId(id: string, index: number): void {\n    this.storyEditorNavigationService.navigateToChapterEditorWithId(\n      id, index);\n  }\n\n  updateStoryDescriptionStatus(description: string): void {\n    this.editableDescriptionIsEmpty = (description === '');\n    this.storyDescriptionChanged = true;\n  }\n\n  updateStoryMetaTagContent(newMetaTagContent: string): void {\n    if (newMetaTagContent !== this.story.getMetaTagContent()) {\n      this.storyUpdateService.setStoryMetaTagContent(\n        this.story, newMetaTagContent);\n    }\n  }\n\n  returnToTopicEditorPage(): void {\n    if (this.undoRedoService.getChangeCount() > 0) {\n      const modalRef = this.ngbModal.open(\n        SavePendingChangesModalComponent, {\n          backdrop: true\n        });\n\n      modalRef.componentInstance.body = (\n        'Please save all pending changes ' +\n        'before returning to the topic.');\n\n      modalRef.result.then(() => {}, () => {\n        // Note to developers:\n        // This callback is triggered when the Cancel button is clicked.\n        // No further action is needed.\n      });\n    } else {\n      const topicId = (\n        this.storyEditorStateService.getStory().getCorrespondingTopicId());\n      this.windowRef.nativeWindow.open(\n        this.urlInterpolationService.interpolateUrl(\n          this.TOPIC_EDITOR_URL_TEMPLATE, {\n            topic_id: topicId\n          }\n        ), '_self');\n    }\n  }\n\n  getClassroomUrlFragment(): string {\n    return this.storyEditorStateService.getClassroomUrlFragment();\n  }\n\n  getTopicUrlFragment(): string {\n    return this.storyEditorStateService.getTopicUrlFragment();\n  }\n\n  getTopicName(): string {\n    return this.storyEditorStateService.getTopicName();\n  }\n\n  updateStoryTitle(newTitle: string): void {\n    if (newTitle !== this.story.getTitle()) {\n      this.storyUpdateService.setStoryTitle(this.story, newTitle);\n    }\n  }\n\n  updateStoryUrlFragment(newUrlFragment: string): void {\n    if (newUrlFragment === this.initialStoryUrlFragment) {\n      this.storyUrlFragmentExists = false;\n      return;\n    }\n    if (newUrlFragment) {\n      this.storyEditorStateService.updateExistenceOfStoryUrlFragment(\n        newUrlFragment, () => {\n          this.storyUrlFragmentExists = (\n            this.storyEditorStateService.getStoryWithUrlFragmentExists());\n          this.storyUpdateService.setStoryUrlFragment(\n            this.story, newUrlFragment);\n        });\n    } else {\n      this.storyUpdateService.setStoryUrlFragment(\n        this.story, newUrlFragment);\n    }\n  }\n\n  updateStoryThumbnailFilename(\n      newThumbnailFilename: string): void {\n    if (newThumbnailFilename !== this.story.getThumbnailFilename()) {\n      this.storyUpdateService.setThumbnailFilename(\n        this.story, newThumbnailFilename);\n    }\n  }\n\n  updateStoryThumbnailBgColor(\n      newThumbnailBgColor: string): void {\n    if (newThumbnailBgColor !== this.story.getThumbnailBgColor()) {\n      this.storyUpdateService.setThumbnailBgColor(\n        this.story, newThumbnailBgColor);\n    }\n  }\n\n  updateStoryDescription(newDescription: string): void {\n    if (newDescription !== this.story.getDescription()) {\n      this.storyUpdateService.setStoryDescription(\n        this.story, newDescription);\n    }\n  }\n\n  togglePreview(): void {\n    this.storyPreviewCardIsShown = !(this.storyPreviewCardIsShown);\n  }\n\n  toggleChapterEditOptions(chapterIndex: number): void {\n    this.selectedChapterIndex = (\n      this.selectedChapterIndex === chapterIndex) ? -1 : chapterIndex;\n  }\n\n  toggleChapterLists(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.chaptersListIsShown = !this.chaptersListIsShown;\n    }\n  }\n\n  toggleStoryEditorCard(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.mainStoryCardIsShown = !this.mainStoryCardIsShown;\n    }\n  }\n\n  ngOnInit(): void {\n    this.storyPreviewCardIsShown = false;\n    this.mainStoryCardIsShown = true;\n    this.chaptersListIsShown = (\n      !this.windowDimensionsService.isWindowNarrow());\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onViewStoryNodeEditor.subscribe(\n        (nodeId: string) => this.setNodeToEdit(nodeId)\n      )\n    );\n\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryInitialized.subscribe(\n        () =>{\n          this._init();\n          this.focusManagerService.setFocus('metaTagInputField');\n        }\n      ));\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryReinitialized.subscribe(\n        () => this._initEditor()\n      ));\n\n    this._init();\n    this._initEditor();\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n}\n\nangular.module('oppia').directive('oppiaStoryEditor', downgradeComponent({\n  component: StoryEditorComponent\n}));\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-node-editor.component.html",
      "content": "<div class=\"story-node\">\n  <div class=\"story-node-content-container\">\n    <div class=\"story-node-content\">\n      <mat-card class=\"oppia-page-card oppia-long-text story-node-card story-node-input-card oppia-mobile-collapsible-card\">\n        <div class=\"story-node-header oppia-mobile-collapsible-card-header\" (click)=\"toggleChapterCard()\">\n          <span>Chapter Card</span>\n          <i class=\"fa fa-caret-down\"\n             *ngIf=\"!mainChapterCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n          <i class=\"fa fa-caret-up\"\n             *ngIf=\"mainChapterCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n        </div>\n        <div class=\"chapter-card-inputs oppia-mobile-collapsible-card-content\" *ngIf=\"mainChapterCardIsShown\">\n          <div class=\"story-node-title\">\n            <label for=\"storyNodeTitle\" class=\"form-heading\">Title*</label>\n            <div>\n              <span class=\"oppia-input-box-subtitle\">\n                <i>\n                  This will be shown to the learner. It overrides the title of the linked exploration.\n                </i>\n              </span>\n            </div>\n            <input id=\"storyNodeTitle\" type=\"text\" class=\"form-control\"\n                   [(ngModel)]=\"editableTitle\" [ngModelOptions]=\"{standalone: true}\" (blur)=\"updateTitle(editableTitle)\"\n                   placeholder=\"Enter a title for the chapter.\" [maxlength]=\"MAX_CHARS_IN_EXPLORATION_TITLE\">\n            <span class=\"oppia-input-box-subtitle\">\n              <i>\n                Chapter title should be at most {{ MAX_CHARS_IN_EXPLORATION_TITLE }} characters.\n              </i>\n            </span>\n          </div>\n          <div class=\"story-node-description\">\n            <label for=\"storyNodeDescription\" class=\"form-heading\">Chapter description*</label>\n            <textarea id=\"storyNodeDescription\" type=\"text\" class=\"form-control e2e-test-add-chapter-description\"\n                      [(ngModel)]=\"editableDescription\" [ngModelOptions]=\"{standalone: true}\" (blur)=\"updateDescription(editableDescription)\" [oppiaFocusOn]=\"storyNodeDesc\"\n                      placeholder=\"Enter the description for the chapter.\" [maxlength]=\"MAX_CHARS_IN_CHAPTER_DESCRIPTION\">\n            </textarea>\n            <span class=\"oppia-input-box-subtitle\">\n              <i>\n                Chapter description should be at most {{ MAX_CHARS_IN_CHAPTER_DESCRIPTION }} characters.\n              </i>\n            </span>\n          </div>\n          <div class=\"story-node-exploration\">\n            <label class=\"form-heading\"> Exploration ID*</label>\n            <form class=\"form-horizontal\">\n              <input class=\"form-control e2e-test-exploration-id-input\" type=\"text\" [(ngModel)]=\"explorationId\" [ngModelOptions]=\"{standalone: true}\" (change)=\"checkCanSaveExpId()\"\n                     (focus)=\"toggleExplorationInputButtons()\">\n              <div class=\"save-button-container\" *ngIf=\"explorationInputButtonsAreShown\">\n                <span *ngIf=\"!isStoryPublished()\" (click)=\"updateExplorationId(null)\" class=\"fas fa-trash-alt list-summary\"></span>\n                <button class=\"btn btn-default\" (click)=\"toggleExplorationInputButtons()\">Cancel</button>\n                <button type=\"submit\"\n                        class=\"e2e-test-exploration-id-save-button btn btn-success btn-sm\"\n                        (click)=\"updateExplorationId(explorationId)\"\n                        [disabled]=\"!expIdCanBeSaved || (explorationId === currentExplorationId)\">\n                  Save\n                </button>\n              </div>\n              <span class=\"form-text error-message\" *ngIf=\"invalidExpErrorIsShown\">\n                <em>Please enter a valid exploration id.</em>\n              </span>\n            </form>\n          </div>\n          <div class=\"e2e-test-story-node-thumbnail\">\n            <label class=\"form-heading\">Thumbnail Image*</label>\n            <oppia-thumbnail-uploader [filename]=\"thumbnailFilename\"\n                                      [useLocalStorage]=\"false\"\n                                      (updateFilename)=\"updateThumbnailFilename($event)\"\n                                      [bgColor]=\"thumbnailBgColor\"\n                                      (updateBgColor)=\"updateThumbnailBgColor($event)\"\n                                      [allowedBgColors]=\"allowedBgColors\"\n                                      [aspectRatio]=\"'16:9'\"\n                                      [previewTitle]=\"editableTitle\"\n                                      [previewDescription]=\"editableDescription\">\n            </oppia-thumbnail-uploader>\n          </div>\n        </div>\n        <div *ngIf=\"mainChapterCardIsShown\">\n          <div *ngIf=\"!chapterPreviewCardIsShown\">\n            <button class=\"btn btn-default show-chapter-preview-button\" (click)=\"togglePreview()\">\n              Preview Chapter Card\n              <i class=\"fa fa-angle-down\"></i>\n            </button>\n          </div>\n          <div *ngIf=\"chapterPreviewCardIsShown\">\n            <button class=\"btn btn-default show-chapter-preview-button\" (click)=\"togglePreview()\">\n              Collapse Chapter Card\n              <i class=\"fa fa-angle-up\"></i>\n            </button>\n          </div>\n          <div *ngIf=\"chapterPreviewCardIsShown\">\n            <oppia-preview-thumbnail [name]=\"editableTitle\"\n                                     [aspectRatio]=\"'16:9'\"\n                                     [filename]=\"thumbnailFilename\"\n                                     [description]=\"editableDescription\"\n                                     [thumbnailBgColor]=\"thumbnailBgColor\"\n                                     [bgColor]=\"thumbnailBgColor\">\n            </oppia-preview-thumbnail>\n          </div>\n        </div>\n      </mat-card>\n      <mat-card class=\"oppia-page-card oppia-long-text story-node-card story-node-input-card oppia-mobile-collapsible-card\">\n        <div class=\"e2e-test-add-chapter-outline\">\n          <div class=\"story-node-header oppia-mobile-collapsible-card-header\" (click)=\"toggleChapterOutline()\">\n            <span>Chapter Outline</span>\n            <i class=\"fa fa-caret-down\"\n               *ngIf=\"!chapterOutlineIsShown\"\n               aria-hidden=\"true\">\n            </i>\n            <i class=\"fa fa-caret-up\"\n               *ngIf=\"chapterOutlineIsShown\"\n               aria-hidden=\"true\">\n            </i>\n          </div>\n          <div class=\"chapter-card-inputs oppia-mobile-collapsible-card-content\" *ngIf=\"chapterOutlineIsShown\">\n            Outline Finalized\n            <i *ngIf=\"!outlineIsFinalized\" (click)=\"finalizeOutline()\" class=\"far fa-square md-18 e2e-test-finalize-outline\" aria-label=\"Finalize outline\"></i>\n            <i *ngIf=\"outlineIsFinalized\" (click)=\"unfinalizeOutline()\" class=\"fas fa-check-square md-18\" aria-label=\"Unfinalize outline\"></i>\n            <div tabindex=\"-1\" (blur)=\"toggleChapterOutlineButtons()\" (click)=\"toggleChapterOutlineButtons()\">\n              <schema-based-editor id=\"storyNodeOutline\"\n                                   [schema]=\"OUTLINE_SCHEMA\"\n                                   [localValue]=\"editableOutline\"\n                                   (localValueChange)=\"updateLocalEditableOutline($event)\">\n              </schema-based-editor>\n              <div class=\"save-button-container\" *ngIf=\"chapterOutlineButtonsAreShown\">\n                <button class=\"btn btn-default\">Cancel</button>\n                <button type=\"button\"\n                        class=\"btn btn-success save-button e2e-test-node-outline-save-button\"\n                        [disabled]=\"!isOutlineModified(editableOutline)\"\n                        (click)=\"updateOutline(editableOutline)\">\n                  Save\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </mat-card>\n      <mat-card class=\"oppia-page-card oppia-long-text story-node-card skill-requirements-card story-skill-desktop\">\n        <div class=\"story-node-header skill-requirements-header\">\n          <span>Skill Requirements and Achievements</span>\n        </div>\n        <div>\n          <span class=\"oppia-input-box-subtitle\">\n            <i>\n              The skill should be one of the skills that are linked to this topic.\n            </i>\n          </span>\n        </div>\n        <div class=\"story-skill-requirements\">\n          <div class=\"prerequisite-skills\">\n            <div class=\"skill-header\">\n              <span>Prerequisite</span>\n            </div>\n            <div>\n              <div class=\"skills-card-item\" *ngFor=\"let skillId of prerequisiteSkillIds\">\n                <div class=\"skill-description-card e2e-test-prerequisite-skill-description-card\">\n                  <a [href]=\"getSkillEditorUrl(skillId)\" target=\"_blank\" rel=\"noopener\">{{ skillIdToSummaryMap[skillId] }}</a>\n                  <span class=\"e2e-test-remove-prerequisite-skill\" (click)=\"removePrerequisiteSkillId(skillId)\" aria-hidden=\"true\">\n                    <i class=\"fas fa-times md-18\"></i>\n                  </span>\n                </div>\n              </div>\n              <button class=\"btn add-skill-btn e2e-test-add-prerequisite-skill\" (click)=\"addPrerequisiteSkillId()\" [disabled]=\"!skillInfoHasLoaded\">+ ADD PREREQUISITE SKILL</button>\n            </div>\n          </div>\n          <div class=\"acquired-skills\">\n            <div class=\"skill-header\">\n              <span>Acquired</span>\n            </div>\n            <div>\n              <div class=\"skills-card-item\" *ngFor=\"let skillId of acquiredSkillIds\">\n                <div class=\"skill-description-card e2e-test-acquired-skill-description-card\">\n                  <a [href]=\"getSkillEditorUrl(skillId)\" target=\"_blank\" rel=\"noopener\">{{ skillIdToSummaryMap[skillId] }}</a>\n                  <span class=\"e2e-test-remove-acquired-skill\" (click)=\"removeAcquiredSkillId(skillId)\" aria-hidden=\"true\">\n                    <i class=\"fas fa-times md-18\"></i>\n                  </span>\n                </div>\n              </div>\n              <button class=\"btn add-skill-btn e2e-test-add-acquired-skill\" (click)=\"addAcquiredSkillId()\" [disabled]=\"!skillInfoHasLoaded\">+ ADD ACQUIRED SKILL</button>\n            </div>\n          </div>\n        </div>\n      </mat-card>\n\n      <div class=\"story-skill-mobile\">\n        <mat-card class=\"oppia-page-card oppia-long-text story-node-card skill-requirements-card oppia-mobile-collapsible-card\">\n          <div class=\"story-node-header skill-requirements-header oppia-mobile-collapsible-card-header\" (click)=\"togglePrerequisiteSkillsList()\">\n            <span>Prerequisite Skills</span>\n            <i class=\"fa fa-caret-down\"\n               *ngIf=\"!prerequisiteSkillIsShown\"\n               aria-hidden=\"true\">\n            </i>\n            <i class=\"fa fa-caret-up\"\n               *ngIf=\"prerequisiteSkillIsShown\"\n               aria-hidden=\"true\">\n            </i>\n          </div>\n          <div class=\"story-skill-requirements oppia-mobile-collapsible-card-content\" *ngIf=\"prerequisiteSkillIsShown\">\n            <div>\n              <span class=\"oppia-input-box-subtitle\">\n                <i>\n                  The skill should be one of the skills that are linked to this topic.\n                </i>\n              </span>\n            </div>\n            <div class=\"prerequisite-skills\">\n              <div>\n                <div class=\"skills-card-item\" *ngFor=\"let skillId of prerequisiteSkillIds\">\n                  <div class=\"skill-description-card\">\n                    <a [href]=\"getSkillEditorUrl(skillId)\" target=\"_blank\" rel=\"noopener\">{{ skillIdToSummaryMap[skillId] }}</a>\n                    <span class=\"e2e-test-remove-prerequisite-skill\" (click)=\"removePrerequisiteSkillId(skillId)\" aria-hidden=\"true\">\n                      <i class=\"fas fa-times md-18\"></i>\n                    </span>\n                  </div>\n                </div>\n                <button class=\"btn add-skill-btn e2e-test-add-prerequisite-skill\" (click)=\"addPrerequisiteSkillId()\" [disabled]=\"!skillInfoHasLoaded\">+ ADD PREREQUISITE SKILL</button>\n              </div>\n            </div>\n          </div>\n        </mat-card>\n\n        <mat-card class=\"oppia-page-card oppia-long-text story-node-card skill-requirements-card oppia-mobile-collapsible-card\">\n          <div class=\"story-node-header skill-requirements-header oppia-mobile-collapsible-card-header\" (click)=\"toggleAcquiredSkillsList()\">\n            <span>Acquired Skills</span>\n            <i class=\"fa fa-caret-down\"\n               *ngIf=\"!acquiredSkillIsShown\"\n               aria-hidden=\"true\">\n            </i>\n            <i class=\"fa fa-caret-up\"\n               *ngIf=\"acquiredSkillIsShown\"\n               aria-hidden=\"true\">\n            </i>\n          </div>\n          <div class=\"story-skill-requirements oppia-mobile-collapsible-card-content\" *ngIf=\"acquiredSkillIsShown\">\n            <div>\n              <span class=\"oppia-input-box-subtitle\">\n                <i>\n                  The skill should be one of the skills that are linked to this topic.\n                </i>\n              </span>\n            </div>\n            <div class=\"acquired-skills\">\n              <div>\n                <div class=\"skills-card-item\" *ngFor=\"let skillId of acquiredSkillIds\">\n                  <div class=\"skill-description-card\">\n                    <a [href]=\"getSkillEditorUrl(skillId)\" target=\"_blank\" rel=\"noopener\">{{ skillIdToSummaryMap[skillId] }}</a>\n                    <span class=\"e2e-test-remove-acquired-skill\" (click)=\"removeAcquiredSkillId(skillId)\" aria-hidden=\"true\">\n                      <i class=\"fas fa-times md-18\"></i>\n                    </span>\n                  </div>\n                </div>\n                <button class=\"btn add-skill-btn e2e-test-add-acquired-skill\" (click)=\"addAcquiredSkillId()\" [disabled]=\"!skillInfoHasLoaded\">+ ADD ACQUIRED SKILL</button>\n              </div>\n            </div>\n          </div>\n        </mat-card>\n      </div>\n    </div>\n    <div class=\"story-node-content-info\">\n      <mat-card class=\"oppia-page-card oppia-long-text story-node-card story-node-input-card oppia-mobile-collapsible-card\">\n        <div class=\"story-node-header oppia-mobile-collapsible-card-header\" (click)=\"toggleChapterTodoCard()\">\n          <span>To-Do List</span>\n          <i class=\"fa fa-caret-down\"\n             *ngIf=\"!chapterTodoCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n          <i class=\"fa fa-caret-up\"\n             *ngIf=\"chapterTodoCardIsShown\"\n             aria-hidden=\"true\">\n          </i>\n        </div>\n        <div class=\"chapter-card-inputs oppia-mobile-collapsible-card-content\" *ngIf=\"chapterTodoCardIsShown\">\n          <div class=\"todo-item-container\">\n            <i class=\"fa fa-minus\" *ngIf=\"!outlineIsFinalized\"></i>\n            <i class=\"fa fa-check todo-completed\" *ngIf=\"outlineIsFinalized\"></i>\n            <span>Complete Chapter Outline</span>\n          </div>\n          <div class=\"todo-item-container\">\n            <i class=\"fa fa-minus\" *ngIf=\"!explorationId\"></i>\n            <i class=\"fa fa-check todo-completed\" *ngIf=\"explorationId\"></i>\n            <span>Link Exploration ID</span>\n          </div>\n          <div class=\"todo-item-container\">\n            <i class=\"fa fa-minus\" *ngIf=\"!currentDescription\"></i>\n            <i class=\"fa fa-check todo-completed\" *ngIf=\"currentDescription\"></i>\n            <span>Create a chapter description</span>\n          </div>\n        </div>\n      </mat-card>\n    </div>\n  </div>\n</div>\n\n<style>\n  .story-node-content-container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin: 0 auto;\n    width: 85%;\n  }\n  .story-node-content {\n    margin-right: 3%;\n    width: 50%;\n  }\n  .story-node-content-info {\n    margin-right: 5%;\n    width: 30%;\n  }\n  .story-node-card {\n    margin-bottom: 25px;\n    margin-top: 0;\n  }\n  .story-node-input-card {\n    margin-bottom: 20px;\n    margin-top: 0;\n    padding: 0;\n  }\n  .chapter-card-inputs {\n    padding: 30px 55px 30px 45px;\n  }\n  .story-node-header {\n    margin-bottom: 0;\n    margin-left: 25px;\n    padding-top: 35px;\n  }\n  .story-node-header span {\n    font-size: 17px;\n    font-weight: bold;\n  }\n  .story-node-header i {\n    display: none;\n  }\n  .show-chapter-preview-button {\n    border-top: 1px solid #c1c1c1;\n    color: #419889;\n    font-size: 15px;\n    padding: 10px 0;\n    width: 100%;\n  }\n  .skill-requirements-card {\n    padding: 35px 25px;\n  }\n  .story-skill-requirements {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    margin-top: 10px;\n  }\n  .skill-requirements-header {\n    margin-left: 0;\n    margin-top: 0;\n  }\n  .story-node-header.skill-requirements-header {\n    padding-top: 0;\n  }\n  .prerequisite-skills,\n  .acquired-skills {\n    display: inline-block;\n    width: 48%;\n  }\n  .add-skill-btn {\n    background-color: #008098;\n    color: #fff;\n    font-weight: bold;\n    margin-top: 12px;\n    text-align: left;\n  }\n  .skill-header {\n    border-bottom: 2px solid #000;\n    margin: 8px 0;\n  }\n  .skill-description-card {\n    border-bottom: 1px solid #e6e6e6;\n    display: flex;\n    justify-content: space-between;\n    padding: 10px 0;\n  }\n  .skill-description-card a {\n    color: inherit;\n    text-decoration: none;\n  }\n  .skill-description-card a:hover {\n    font-weight: bold;\n  }\n  .todo-completed {\n    color: #00ff7f;\n  }\n  .story-node-title,\n  .story-node-description,\n  .story-node-exploration {\n    margin-bottom: 25px;\n  }\n  .todo-item-container {\n    margin-bottom: 5px;\n  }\n  .save-button-container {\n    text-align: right;\n  }\n  .save-button-container button {\n    margin-top: 2px;\n  }\n  .story-skill-mobile {\n    display: none;\n  }\n  @media screen and (max-width: 768px) {\n    .story-node-content-container {\n      width: 100%;\n    }\n    .story-node-content {\n      margin-right: 0;\n      order: 10;\n      width: 100%;\n    }\n    .story-node-header i {\n      display: block;\n    }\n    .chapter-card-inputs {\n      padding: 20px 26px 15px;\n    }\n    .story-node-content-info {\n      margin-right: 0;\n      order: 1;\n      width: 100%;\n    }\n    .story-skill-desktop {\n      display: none;\n    }\n    .story-skill-mobile {\n      display: block;\n    }\n    .prerequisite-skills,\n    .acquired-skills {\n      width: 100%;\n    }\n    .skill-requirements-header {\n      margin-left: 0;\n      margin-top: 0;\n    }\n    .story-node-header {\n      align-items: center;\n      display: flex;\n      justify-content: space-between;\n      margin-left: 0;\n      margin-top: 0;\n    }\n    .skill-requirements-card {\n      padding: 0;\n    }\n    .story-skill-requirements {\n      margin-top: 0;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-node-editor.component.spec.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the story node editor directive.\n */\nimport { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core';\nimport { ComponentFixture, fakeAsync, flush, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { RecordedVoiceovers } from 'domain/exploration/recorded-voiceovers.model';\nimport { SubtitledHtml } from 'domain/exploration/subtitled-html.model';\nimport { ConceptCard } from 'domain/skill/concept-card.model';\nimport { Skill } from 'domain/skill/SkillObjectFactory';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { Story } from 'domain/story/story.model';\nimport { AlertsService } from 'services/alerts.service';\nimport { FocusManagerService } from 'services/stateful/focus-manager.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { CuratedExplorationValidationService } from '../../../domain/exploration/curated-exploration-validation.service';\nimport { WindowDimensionsService } from '../../../services/contextual/window-dimensions.service';\nimport { StoryNodeEditorComponent } from './story-node-editor.component';\nimport { EditableStoryBackendApiService } from '../../../domain/story/editable-story-backend-api.service';\nimport { SkillBackendApiService } from '../../../domain/skill/skill-backend-api.service';\nimport { TopicsAndSkillsDashboardBackendApiService } from '../../../domain/topics_and_skills_dashboard/topics-and-skills-dashboard-backend-api.service';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\n\nclass MockNgbModalRef {\n  componentInstance: {\n    skillSummaries: null;\n    skillsInSameTopicCount: null;\n    categorizedSkills: null;\n    allowSkillsFromOtherTopics: null;\n    untriagedSkillSummaries: null;\n  };\n}\n\nclass MockTopicsAndSkillsDashboardBackendApiService {\n  fetchDashboardDataAsync = () => {\n    return Promise.resolve({\n      categorizedSkillsDict: {\n        addition: {}\n      },\n      untriagedSkillSummaries: {\n        addition: {}\n      }\n    });\n  };\n}\n\nclass MockSkillBackendApiService {\n  fetchMultiSkillsAsync = (skillIds) => {\n    // The skillId ='2' case is used to test the case when the\n    // SkillBackendApiService rejects the request.\n    if (skillIds[0] === '2') {\n      return Promise.reject();\n    } else {\n      return Promise.resolve([\n        new Skill(\n          '1', 'test', [], [],\n          new ConceptCard(\n            new SubtitledHtml(\n              '', '1'), [], RecordedVoiceovers.createEmpty()),\n          'en', 1, 1, '0', true, []),\n        new Skill(\n          '2', 'test2', [], [],\n          new ConceptCard(\n            new SubtitledHtml(\n              '', '1'), [], RecordedVoiceovers.createEmpty()),\n          'en', 1, 1, '0', true, []),\n        new Skill(\n          '3', 'test3', [], [],\n          new ConceptCard(\n            new SubtitledHtml(\n              '', '1'), [], RecordedVoiceovers.createEmpty()),\n          'en', 1, 1, '0', true, [])\n      ]);\n    }\n  };\n}\n\n\ndescribe('Story node editor component', () => {\n  let fixture: ComponentFixture<StoryNodeEditorComponent>;\n  let component: StoryNodeEditorComponent;\n  let ngbModal: NgbModal;\n  let story: Story;\n  let windowDimensionsService: WindowDimensionsService;\n  let storyUpdateService: StoryUpdateService;\n  let curatedExplorationValidationService:\n    CuratedExplorationValidationService;\n  let alertsService: AlertsService;\n  let storyEditorStateService: StoryEditorStateService;\n  let focusManagerService: FocusManagerService;\n  let mockEventEmitterLast = new EventEmitter();\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        StoryNodeEditorComponent\n      ],\n      providers: [\n        WindowDimensionsService,\n        StoryUpdateService,\n        AlertsService,\n        CuratedExplorationValidationService,\n        StoryEditorStateService,\n        FocusManagerService,\n        EditableStoryBackendApiService,\n        {\n          provide: SkillBackendApiService,\n          useClass: MockSkillBackendApiService\n        },\n        {\n          provide: TopicsAndSkillsDashboardBackendApiService,\n          useClass: MockTopicsAndSkillsDashboardBackendApiService\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(StoryNodeEditorComponent);\n    component = fixture.componentInstance;\n    ngbModal = TestBed.inject(NgbModal);\n    windowDimensionsService = TestBed.inject(WindowDimensionsService);\n    curatedExplorationValidationService = (\n      TestBed.inject(CuratedExplorationValidationService));\n    alertsService = TestBed.inject(AlertsService);\n    storyUpdateService = TestBed.inject(StoryUpdateService);\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n    focusManagerService = TestBed.inject(FocusManagerService);\n\n    let sampleStoryBackendObject = {\n      id: 'sample_story_id',\n      title: 'Story title',\n      description: 'Story description',\n      notes: 'Story notes',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      url_fragment: 'story_title',\n      story_contents: {\n        initial_node_id: 'node_2',\n        nodes: [\n          {\n            id: 'simple',\n            title: 'Title 1',\n            description: 'Description 1',\n            prerequisite_skill_ids: ['skill_1'],\n            acquired_skill_ids: ['skill_2'],\n            destination_node_ids: [],\n            outline: 'Outline',\n            exploration_id: null,\n            outline_is_finalized: false\n          },\n          {\n            id: 'node_1',\n            title: 'Title 1',\n            description: 'Description 1',\n            prerequisite_skill_ids: ['skill_1'],\n            acquired_skill_ids: ['skill_2'],\n            destination_node_ids: [],\n            outline: 'Outline',\n            exploration_id: null,\n            outline_is_finalized: false\n          }, {\n            id: 'node_2',\n            title: 'Title 2',\n            description: 'Description 2',\n            prerequisite_skill_ids: ['skill_3'],\n            acquired_skill_ids: ['skill_4'],\n            destination_node_ids: ['node_1'],\n            outline: 'Outline 2',\n            exploration_id: 'exp_1',\n            outline_is_finalized: true\n          }, {\n            id: 'break',\n            title: 'Title 2',\n            description: 'Description 2',\n            prerequisite_skill_ids: ['skill_3'],\n            acquired_skill_ids: ['skill_4'],\n            destination_node_ids: ['node_1'],\n            outline: 'Outline 2',\n            exploration_id: 'exp_1',\n            outline_is_finalized: true\n          }],\n        next_node_id: 'node_3'\n      },\n      language_code: 'en'\n    };\n    story = Story.createFromBackendDict(sampleStoryBackendObject);\n\n    spyOn(windowDimensionsService, 'isWindowNarrow').and.returnValue(true);\n    spyOn(storyEditorStateService, 'getSkillSummaries').and.returnValue(\n      [{ id: '1', description: 'Skill description' }]);\n    spyOn(storyEditorStateService, 'getStory').and.returnValue(story);\n    spyOn(storyEditorStateService, 'getClassroomUrlFragment').and.returnValue(\n      'math');\n    spyOn(storyEditorStateService, 'getTopicUrlFragment').and.returnValue(\n      'fractions');\n    spyOn(storyEditorStateService, 'getTopicName').and.returnValue('addition');\n    spyOnProperty(storyEditorStateService, 'onRecalculateAvailableNodes')\n      .and.returnValue(mockEventEmitterLast);\n\n    component.nodeId = 'node1';\n    component.storyNodeIds = ['node1', 'node_2', 'node_3', 'wroking'];\n    component.destinationNodeIds = ['node_2'];\n    component.ngOnInit();\n  });\n\n  afterEach(() => {\n    component.ngOnDestroy();\n  });\n\n  it('should init the controller', () => {\n    component.viewNodeEditor('node_1');\n\n    expect(component.chapterPreviewCardIsShown).toEqual(false);\n    expect(component.mainChapterCardIsShown).toEqual(true);\n    expect(component.explorationInputButtonsAreShown).toEqual(false);\n  });\n\n  it('should return skill editor URL', () => {\n    expect(component.getSkillEditorUrl('skill_1')).toEqual(\n      '/skill_editor/skill_1');\n  });\n\n  it('should fetch the descriptions for prerequisite skills', fakeAsync(() => {\n    component.prerequisiteSkillIds = ['1', '2', '3'];\n\n    component.getPrerequisiteSkillsDescription();\n    tick();\n\n    expect(component.skillIdToSummaryMap).toEqual(\n      { 1: 'test', 2: 'test2', 3: 'test3' }\n    );\n  }));\n\n  it('should call Alerts Service if getting skill desc. fails', fakeAsync(\n    () => {\n      component.prerequisiteSkillIds = ['2'];\n      let alertsSpy = spyOn(alertsService, 'addWarning').and.callThrough();\n\n      component.getPrerequisiteSkillsDescription();\n      tick();\n\n      expect(alertsSpy).toHaveBeenCalled();\n    }));\n\n  it('should check if exploration can be saved', () => {\n    component.checkCanSaveExpId();\n\n    expect(component.expIdCanBeSaved).toEqual(true);\n  });\n\n  it('should call StoryUpdate service remove prerequisite skill id',\n    () => {\n      let skillSpy = spyOn(\n        storyUpdateService, 'removePrerequisiteSkillIdFromNode');\n\n      component.removePrerequisiteSkillId('skill_3');\n\n      expect(skillSpy).toHaveBeenCalled();\n    });\n\n  it('should call StoryUpdate service remove acquired skill id', () => {\n    let skillSpy = spyOn(storyUpdateService, 'removeAcquiredSkillIdFromNode');\n\n    component.removeAcquiredSkillId('node_1');\n\n    expect(skillSpy).toHaveBeenCalled();\n  });\n\n  it('should toggle chapter preview card', () => {\n    component.chapterPreviewCardIsShown = false;\n\n    component.togglePreview();\n\n    expect(component.chapterPreviewCardIsShown).toBeTrue();\n  });\n\n  it('should untoggle chapter preview card', () => {\n    component.chapterPreviewCardIsShown = true;\n\n    component.togglePreview();\n\n    expect(component.chapterPreviewCardIsShown).toBeFalse();\n  });\n\n  it('should toggle prereq skill list', () => {\n    component.prerequisiteSkillIsShown = true;\n\n    component.togglePrerequisiteSkillsList();\n\n    expect(component.prerequisiteSkillIsShown).toBeFalse();\n  });\n\n  it('should call StoryUpdate service to set story thumbnail filename',\n    () => {\n      let storySpy = spyOn(storyUpdateService, 'setStoryNodeThumbnailFilename');\n\n      component.updateThumbnailFilename('new_file.png');\n\n      expect(storySpy).toHaveBeenCalled();\n    });\n\n  it('should call StoryUpdate service to set story thumbnail filename',\n    () => {\n      let storySpy = spyOn(storyUpdateService, 'setStoryNodeThumbnailBgColor');\n\n      component.updateThumbnailBgColor('#333');\n\n      expect(storySpy).toHaveBeenCalled();\n    });\n\n  it('should call StoryUpdate service to finalize story node outline',\n    () => {\n      let storySpy = spyOn(storyUpdateService, 'unfinalizeStoryNodeOutline');\n\n      component.unfinalizeOutline();\n\n      expect(storySpy).toHaveBeenCalled();\n    });\n\n  it('should call StoryUpdate service to finalize story node outline',\n    () => {\n      let storySpy = spyOn(storyUpdateService, 'finalizeStoryNodeOutline');\n\n      component.finalizeOutline();\n\n      expect(storySpy).toHaveBeenCalled();\n    });\n\n  it('should call StoryUpdate service to update outline', () => {\n    let storySpy = spyOn(storyUpdateService, 'setStoryNodeOutline');\n\n    component.updateOutline('New outline');\n\n    expect(storySpy).toHaveBeenCalled();\n  });\n\n  it('should call StoryUpdate service to update description', () => {\n    let storySpy = spyOn(storyUpdateService, 'setStoryNodeDescription');\n\n    component.updateDescription('New description');\n\n    expect(storySpy).toHaveBeenCalled();\n  });\n\n  it('should open and close node title editor', () => {\n    component.openNodeTitleEditor();\n\n    expect(component.nodeTitleEditorIsShown).toEqual(true);\n\n    component.closeNodeTitleEditor();\n\n    expect(component.nodeTitleEditorIsShown).toEqual(false);\n  });\n\n  it('should open add skill modal for adding prerequisite skill', () => {\n    const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n      return (\n        {\n          componentInstance: MockNgbModalRef,\n          result: Promise.resolve('success')\n        }) as NgbModalRef;\n    });\n\n    component.addPrerequisiteSkillId();\n\n    expect(modalSpy).toHaveBeenCalled();\n  });\n\n  it('should show alert message when we try to ' +\n    'add a prerequisite skill id which already exists', fakeAsync(() => {\n    spyOn(storyUpdateService, 'addPrerequisiteSkillIdToNode')\n      .and.callFake(() => {\n        throw new Error('Given skill is already a prerequisite skill');\n      });\n    let alertsSpy = spyOn(alertsService, 'addInfoMessage')\n      .and.returnValue(null);\n    spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n      return (\n          {\n            componentInstance: MockNgbModalRef,\n            result: Promise.resolve({\n              summary: {\n                id: 'id',\n                description: 'description'\n              }\n            })\n          }\n        ) as NgbModalRef;\n    });\n\n    component.addPrerequisiteSkillId();\n    tick();\n\n    expect(alertsSpy).toHaveBeenCalledWith(\n      'Given skill is already a prerequisite skill', 5000);\n  }));\n\n  it('should open add skill modal for adding acquired skill', fakeAsync(\n    () => {\n      spyOn(storyUpdateService, 'addAcquiredSkillIdToNode').and.callFake(\n        () => { });\n      const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n        return (\n          {\n            componentInstance: MockNgbModalRef,\n            result: Promise.resolve('success')\n          }) as NgbModalRef;\n      });\n\n      component.addAcquiredSkillId();\n      tick();\n\n      expect(modalSpy).toHaveBeenCalled();\n    }));\n\n  it('should show alert message when we try to ' +\n    'add a acquired skill id which already exists', fakeAsync(() => {\n    spyOn(storyUpdateService, 'addAcquiredSkillIdToNode')\n      .and.callFake(() => {\n        throw new Error('skill id already exist.');\n      });\n    let alertsSpy = spyOn(alertsService, 'addInfoMessage')\n      .and.returnValue(null);\n    spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n      return (\n          {\n            componentInstance: MockNgbModalRef,\n            result: Promise.resolve('success')\n          }) as NgbModalRef;\n    });\n\n    component.addAcquiredSkillId();\n    tick();\n\n    expect(alertsSpy).toHaveBeenCalledWith(\n      'Given skill is already an acquired skill', 5000);\n  }));\n\n  it('should toggle chapter outline', fakeAsync(() => {\n    component.chapterOutlineIsShown = false;\n\n    component.toggleChapterOutline();\n\n    expect(component.chapterOutlineIsShown).toBe(true);\n  }));\n\n  it('should toggle acquired skills list', () => {\n    component.acquiredSkillIsShown = false;\n\n    component.toggleAcquiredSkillsList();\n\n    expect(component.acquiredSkillIsShown).toBe(true);\n  });\n\n  it('should untoggle acquired skills list', () => {\n    component.acquiredSkillIsShown = true;\n\n    component.toggleAcquiredSkillsList();\n\n    expect(component.acquiredSkillIsShown).toBe(false);\n  });\n\n  it('should toggle chapter card', () => {\n    component.mainChapterCardIsShown = false;\n\n    component.toggleChapterCard();\n\n    expect(component.mainChapterCardIsShown).toBe(true);\n  });\n\n  it('should untoggle chapter card', () => {\n    component.mainChapterCardIsShown = true;\n\n    component.toggleChapterCard();\n\n    expect(component.mainChapterCardIsShown).toBe(false);\n  });\n\n  it('should toggle chapter todo card', () => {\n    component.chapterTodoCardIsShown = false;\n\n    component.toggleChapterTodoCard();\n\n    expect(component.chapterTodoCardIsShown).toBe(true);\n  });\n\n  it('should untoggle chapter todo card', () => {\n    component.chapterTodoCardIsShown = true;\n\n    component.toggleChapterTodoCard();\n\n    expect(component.chapterTodoCardIsShown).toBe(false);\n  });\n\n  it('should toggle exploration input buttons', () => {\n    component.explorationInputButtonsAreShown = false;\n\n    component.toggleExplorationInputButtons();\n\n    expect(component.explorationInputButtonsAreShown).toBe(true);\n  });\n\n  it('should untoggle exploration input buttons', () => {\n    component.explorationInputButtonsAreShown = true;\n\n    component.toggleExplorationInputButtons();\n\n    expect(component.explorationInputButtonsAreShown).toBe(false);\n  });\n\n  it('should toggle chapter outline buttons', () => {\n    component.chapterOutlineButtonsAreShown = false;\n    component.toggleChapterOutlineButtons();\n\n    expect(component.chapterOutlineButtonsAreShown).toBe(true);\n\n    component.toggleChapterOutlineButtons();\n\n    expect(component.chapterOutlineButtonsAreShown).toBe(false);\n\n    component.chapterOutlineButtonsAreShown = false;\n    component.editableOutline = '';\n    component.updateLocalEditableOutline('value');\n\n    expect(component.editableOutline).toBe('value');\n  });\n\n  it('should call StoryUpdateService and curatedExplorationValidationService' +\n    ' to set node exploration id if story is published',\n  fakeAsync(() => {\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(true);\n    let value = Promise.resolve(true);\n    let expSpy = spyOn(\n      curatedExplorationValidationService, 'isExpPublishedAsync'\n    ).and.returnValue(value);\n    let storyUpdateSpy = spyOn(storyUpdateService, 'setStoryNodeExplorationId');\n\n    component.updateExplorationId('exp10');\n    tick();\n\n    expect(expSpy).toHaveBeenCalled();\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  }));\n\n  it('should call StoryUpdateService to set node exploration id and set ' +\n    'invalid exp error if story is published and exp id is invalid',\n  fakeAsync(() => {\n    component.invalidExpErrorIsShown = false;\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(true);\n    let value = Promise.resolve(false);\n    let expSpy = spyOn(\n      curatedExplorationValidationService, 'isExpPublishedAsync'\n    ).and.returnValue(value);\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryNodeExplorationId');\n\n    component.updateExplorationId('exp10');\n    tick();\n\n    expect(expSpy).toHaveBeenCalled();\n    expect(storyUpdateSpy).not.toHaveBeenCalled();\n    expect(component.invalidExpErrorIsShown).toEqual(true);\n  }));\n\n  it('should show error if story is published and exp id is null', () => {\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(true);\n    let alertsSpy = spyOn(alertsService, 'addInfoMessage');\n\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryNodeExplorationId');\n\n    component.updateExplorationId(null as unknown as string);\n    expect(storyUpdateSpy).not.toHaveBeenCalled();\n    expect(alertsSpy).toHaveBeenCalled();\n  });\n\n  it('should call StoryUpdateService to set node exploration id and set ' +\n    'invalid exp error if story is published and exp id is invalid',\n  () => {\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(false);\n    Promise.resolve(false);\n\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryNodeExplorationId');\n\n    component.updateExplorationId(null as unknown as string);\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should show alert message if we try to update ' +\n    'exploration id with empty value', () => {\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(false);\n    Promise.resolve(false);\n    spyOn(storyUpdateService, 'setStoryNodeExplorationId');\n    let alertsSpy = spyOn(alertsService, 'addInfoMessage')\n      .and.returnValue(null);\n\n    component.updateExplorationId('');\n    expect(alertsSpy).toHaveBeenCalledWith(\n      'Please click the delete icon to remove an exploration ' +\n        'from the story.', 5000);\n  });\n\n  it('should call StoryUpdate service to set story node title', () => {\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryNodeTitle');\n    component.updateTitle('Title 10');\n    expect(storyUpdateSpy).toHaveBeenCalled();\n  });\n\n  it('should not call StoryUpdate service to set story node title and ' +\n    'call alertsService if the name is a duplicate', () => {\n    let storyUpdateSpy = spyOn(\n      storyUpdateService, 'setStoryNodeTitle');\n    let alertsSpy = spyOn(alertsService, 'addInfoMessage');\n    component.updateTitle('Title 2');\n    expect(storyUpdateSpy).not.toHaveBeenCalled();\n    expect(alertsSpy).toHaveBeenCalled();\n  });\n\n  it('should focus on story node when story is initialized', fakeAsync(() => {\n    let mockEventEmitter = new EventEmitter();\n    spyOnProperty(storyEditorStateService, 'onStoryInitialized')\n      .and.returnValue(mockEventEmitter);\n    let focusSpy = spyOn(focusManagerService, 'setFocusWithoutScroll')\n      .and.returnValue(null);\n\n    component.ngOnInit();\n    flush();\n    mockEventEmitter.emit();\n\n    expect(focusSpy).toHaveBeenCalled();\n  }));\n\n  it('should focus on story node when story is reinitialized', fakeAsync(\n    () => {\n      let mockEventEmitter = new EventEmitter();\n      spyOnProperty(storyEditorStateService, 'onStoryReinitialized')\n        .and.returnValue(mockEventEmitter);\n      let focusSpy = spyOn(focusManagerService, 'setFocusWithoutScroll')\n        .and.returnValue(null);\n\n      component.ngOnInit();\n      flush();\n\n      mockEventEmitter.emit();\n      tick();\n\n      expect(focusSpy).toHaveBeenCalled();\n    }));\n\n  it('should focus on story node after recalculation of available node',\n    fakeAsync(() => {\n      spyOn(component, '_recalculateAvailableNodes').and.callThrough();\n\n      component.nodeId = 'node1';\n      component.storyNodeIds = ['node1', 'node_2', 'working', 'duty'];\n      component.destinationNodeIds = ['node_2'];\n      component.story = {\n        getStoryContents: () => {\n          return {\n            getLinearNodesList: () => {\n              return [{\n                getId: () => {\n                  return 'NodeID_1';\n                }\n              },\n              {\n                getId: () => {\n                  return 'NodeID_2';\n                }\n              }];\n            }\n          };\n        }\n      };\n\n      mockEventEmitterLast.emit();\n      tick();\n\n      expect(component._recalculateAvailableNodes).toHaveBeenCalled();\n    }));\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/editor-tab/story-node-editor.component.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the story node editor.\n */\n\nimport { ChangeDetectorRef, Component, Input, OnDestroy, OnInit } from '@angular/core';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { AppConstants } from 'app.constants';\nimport { SelectSkillModalComponent } from 'components/skill-selector/select-skill-modal.component';\nimport { CuratedExplorationValidationService } from 'domain/exploration/curated-exploration-validation.service';\nimport { SkillBackendApiService } from 'domain/skill/skill-backend-api.service';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { Story } from 'domain/story/story.model';\nimport { TopicsAndSkillsDashboardBackendApiService } from 'domain/topics_and_skills_dashboard/topics-and-skills-dashboard-backend-api.service';\nimport { Subscription } from 'rxjs';\nimport { AlertsService } from 'services/alerts.service';\nimport { WindowDimensionsService } from 'services/contextual/window-dimensions.service';\nimport { PageTitleService } from 'services/page-title.service';\nimport { FocusManagerService } from 'services/stateful/focus-manager.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\n\n@Component({\n  selector: 'oppia-story-node-editor',\n  templateUrl: './story-node-editor.component.html'\n})\nexport class StoryNodeEditorComponent implements OnInit, OnDestroy {\n  @Input() nodeId: string;\n  @Input() outline: string;\n  @Input() description: string;\n  @Input() explorationId: string;\n  @Input() thumbnailFilename: string;\n  @Input() thumbnailBgColor: string;\n  @Input() outlineIsFinalized: boolean;\n  @Input() destinationNodeIds: string[];\n  @Input() prerequisiteSkillIds: string[];\n  @Input() acquiredSkillIds: string[];\n\n  chapterPreviewCardIsShown = false;\n  mainChapterCardIsShown = true;\n  explorationInputButtonsAreShown = false;\n  chapterOutlineButtonsAreShown = false;\n  skillIdToSummaryMap = {};\n  chapterOutlineIsShown: boolean = false;\n  chapterTodoCardIsShown: boolean = false;\n  prerequisiteSkillIsShown: boolean = false;\n  acquiredSkillIsShown = false;\n  explorationIdPattern = /^[a-zA-Z0-9_-]+$/;\n  expIdCanBeSaved = true;\n\n  story: Story;\n  storyNodeIds: string[];\n  nodeIdToTitleMap: Object;\n  skillInfoHasLoaded = false;\n  allowedBgColors = AppConstants.ALLOWED_THUMBNAIL_BG_COLORS.chapter;\n  isStoryPublished: () => boolean;\n  currentTitle: string;\n  editableTitle: string;\n  currentDescription: string;\n  editableDescription: string;\n  editableThumbnailFilename: string;\n  editableThumbnailBgColor: string;\n  oldOutline: string;\n  editableOutline: string;\n  currentExplorationId: string;\n  expIdIsValid: boolean;\n  invalidExpErrorIsShown: boolean;\n  nodeTitleEditorIsShown: boolean;\n\n  OUTLINE_SCHEMA = {\n    type: 'html',\n    ui_config: {\n      startupFocusEnabled: false,\n      rows: 100\n    }\n  };\n\n  private _categorizedSkills = {};\n  private _untriagedSkillSummaries = {};\n\n  subscriptions = new Subscription();\n  newNodeId: string;\n  availableNodes;\n\n  constructor(\n    private alertsService: AlertsService,\n    private curatedExplorationValidationService:\n    CuratedExplorationValidationService,\n    private changeDetectorRef: ChangeDetectorRef,\n    private focusManagerService: FocusManagerService,\n    private ngbModal: NgbModal,\n    private pageTitleService: PageTitleService,\n    private skillBackendApiService: SkillBackendApiService,\n    private storyEditorStateService: StoryEditorStateService,\n    private storyUpdateService: StoryUpdateService,\n    private topicsAndSkillsDashboardBackendApiService:\n    TopicsAndSkillsDashboardBackendApiService,\n    private windowDimensionsService: WindowDimensionsService\n  ) {}\n\n  private _init(): void {\n    this.story = this.storyEditorStateService.getStory();\n    this.storyNodeIds = this.story.getStoryContents().getNodeIds();\n    this.nodeIdToTitleMap = this.story.getStoryContents().getNodeIdsToTitleMap(\n      this.storyNodeIds);\n    this.skillInfoHasLoaded = false;\n\n    this._recalculateAvailableNodes();\n\n    let skillSummaries = this.storyEditorStateService.getSkillSummaries();\n\n    this.topicsAndSkillsDashboardBackendApiService.fetchDashboardDataAsync()\n      .then((response) => {\n        this._categorizedSkills = response.categorizedSkillsDict;\n        this._untriagedSkillSummaries = response.untriagedSkillSummaries;\n        this.skillInfoHasLoaded = true;\n      });\n\n    for (let idx in skillSummaries) {\n      this.skillIdToSummaryMap[skillSummaries[idx].id] =\n      skillSummaries[idx].description;\n    }\n\n    this.isStoryPublished = this.storyEditorStateService.isStoryPublished;\n    this.currentTitle = this.nodeIdToTitleMap[this.nodeId];\n    this.pageTitleService.setNavbarSubtitleForMobileView(this.currentTitle);\n    this.editableTitle = this.currentTitle;\n    this.currentDescription = this.description;\n    this.editableDescription = this.currentDescription;\n    this.editableThumbnailFilename = this.thumbnailFilename;\n    this.editableThumbnailBgColor = this.thumbnailBgColor;\n    this.oldOutline = this.outline;\n    this.editableOutline = this.outline;\n    this.currentExplorationId = this.explorationId;\n    this.expIdIsValid = true;\n    this.invalidExpErrorIsShown = false;\n    this.nodeTitleEditorIsShown = false;\n  }\n\n  getSkillEditorUrl(skillId: string): string {\n    return '/skill_editor/' + skillId;\n  }\n\n  getPrerequisiteSkillsDescription(): void {\n    const skills = this.prerequisiteSkillIds;\n\n    if (skills && skills.length > 0) {\n      this.skillBackendApiService.fetchMultiSkillsAsync(skills).then(\n        (response) => {\n          for (let idx in response) {\n            this.skillIdToSummaryMap[response[idx].getId()] = (\n              response[idx].getDescription());\n          }\n        }, (error) => {\n          this.alertsService.addWarning('');\n        });\n    }\n  }\n\n  checkCanSaveExpId(): void {\n    this.expIdCanBeSaved = this.explorationIdPattern.test(\n      this.explorationId) || !this.explorationId;\n    this.invalidExpErrorIsShown = false;\n  }\n\n  updateTitle(newTitle: string): void {\n    if (newTitle !== this.currentTitle) {\n      let titleIsValid = true;\n\n      for (let idx in this.story.getStoryContents().getNodes()) {\n        let node = this.story.getStoryContents().getNodes()[idx];\n        if (node.getTitle() === newTitle) {\n          titleIsValid = false;\n          this.alertsService.addInfoMessage(\n            'A chapter already exists with given title.', 5000\n          );\n        }\n      }\n\n      if (titleIsValid) {\n        this.storyUpdateService.setStoryNodeTitle(\n          this.story, this.nodeId, newTitle);\n        this.currentTitle = newTitle;\n      }\n    }\n  }\n\n  updateDescription(newDescription: string): void {\n    if (newDescription !== this.currentDescription) {\n      this.storyUpdateService.setStoryNodeDescription(\n        this.story, this.nodeId, newDescription);\n      this.currentDescription = newDescription;\n    }\n  }\n\n  updateThumbnailFilename(newThumbnailFilename: string): void {\n    if (newThumbnailFilename !== this.editableThumbnailFilename) {\n      this.storyUpdateService.setStoryNodeThumbnailFilename(\n        this.story, this.nodeId, newThumbnailFilename);\n    }\n  }\n\n  updateThumbnailBgColor(newThumbnailBgColor: string): void {\n    if (newThumbnailBgColor !== this.editableThumbnailBgColor) {\n      this.storyUpdateService.setStoryNodeThumbnailBgColor(\n        this.story, this.nodeId, newThumbnailBgColor);\n      this.editableThumbnailBgColor = newThumbnailBgColor;\n    }\n  }\n\n  viewNodeEditor(nodeId: string): void {\n    this.storyEditorStateService.onViewStoryNodeEditor.emit(nodeId);\n  }\n\n  finalizeOutline(): void {\n    this.storyUpdateService.finalizeStoryNodeOutline(this.story, this.nodeId);\n  }\n\n  updateExplorationId(explorationId: string): void {\n    this.toggleExplorationInputButtons();\n\n    if (this.storyEditorStateService.isStoryPublished()) {\n      if (explorationId === '' || explorationId === null) {\n        this.alertsService.addInfoMessage(\n          'You cannot remove an exploration from a published story.', 5000);\n        return;\n      }\n\n      this.curatedExplorationValidationService.isExpPublishedAsync(\n        explorationId)\n        .then((expIdIsValid) => {\n          this.expIdIsValid = expIdIsValid;\n\n          if (this.expIdIsValid) {\n            this.storyUpdateService.setStoryNodeExplorationId(\n              this.story, this.nodeId, explorationId);\n            this.currentExplorationId = explorationId;\n          } else {\n            this.invalidExpErrorIsShown = true;\n          }\n        });\n    } else {\n      if (explorationId === '') {\n        this.alertsService.addInfoMessage(\n          'Please click the delete icon to remove an exploration ' +\n          'from the story.', 5000);\n        return;\n      }\n\n      this.storyUpdateService.setStoryNodeExplorationId(\n        this.story, this.nodeId, explorationId);\n      this.currentExplorationId = explorationId;\n      if (explorationId === null) {\n        this.explorationId = null;\n      }\n    }\n  }\n\n  removePrerequisiteSkillId(skillId: string): void {\n    this.storyUpdateService.removePrerequisiteSkillIdFromNode(\n      this.story, this.nodeId, skillId);\n  }\n\n  addPrerequisiteSkillId(): void {\n    let sortedSkillSummaries = this.storyEditorStateService.getSkillSummaries();\n    let allowSkillsFromOtherTopics = true;\n    let skillsInSameTopicCount = 0;\n    let modalRef: NgbModalRef = this.ngbModal.open(\n      SelectSkillModalComponent, {\n        backdrop: 'static',\n        windowClass: 'skill-select-modal',\n        size: 'xl'\n      }\n    );\n\n    modalRef.componentInstance.skillSummaries = sortedSkillSummaries;\n    modalRef.componentInstance.skillsInSameTopicCount = (\n      skillsInSameTopicCount);\n    modalRef.componentInstance.categorizedSkills = this._categorizedSkills;\n    modalRef.componentInstance.allowSkillsFromOtherTopics = (\n      allowSkillsFromOtherTopics);\n    modalRef.componentInstance.untriagedSkillSummaries = (\n      this._untriagedSkillSummaries);\n\n    modalRef.result.then((summary) => {\n      try {\n        this.skillIdToSummaryMap[summary.id] = summary.description;\n        this.storyUpdateService.addPrerequisiteSkillIdToNode(\n          this.story, this.nodeId, summary.id);\n        // The catch parameter type can only be any or unknown. The type\n        // 'unknown' is safer than type 'any' because it reminds us\n        // that we need to performsome sorts of type-checks before\n        // operating on our values.\n      } catch (err: unknown) {\n        if (err instanceof Error) {\n          this.alertsService.addInfoMessage(\n            err.message, 5000);\n        }\n      }\n    }, () => {\n      // Note to developers:\n      // This callback is triggered when the Cancel button is clicked.\n      // No further action is needed.\n    });\n  }\n\n  addAcquiredSkillId(): void {\n    let sortedSkillSummaries = (\n      this.storyEditorStateService.getSkillSummaries());\n    let allowSkillsFromOtherTopics = false;\n    let skillsInSameTopicCount = 0;\n    let topicName = this.storyEditorStateService.getTopicName();\n    let categorizedSkillsInTopic = {};\n    categorizedSkillsInTopic[topicName] = this._categorizedSkills[topicName];\n    let modalRef: NgbModalRef = this.ngbModal.open(\n      SelectSkillModalComponent, {\n        backdrop: 'static',\n        windowClass: 'skill-select-modal',\n        size: 'xl'\n      });\n\n    modalRef.componentInstance.skillSummaries = sortedSkillSummaries;\n    modalRef.componentInstance.skillsInSameTopicCount = (\n      skillsInSameTopicCount);\n    modalRef.componentInstance.categorizedSkills = this._categorizedSkills;\n    modalRef.componentInstance.allowSkillsFromOtherTopics = (\n      allowSkillsFromOtherTopics);\n    modalRef.componentInstance.untriagedSkillSummaries = (\n      this._untriagedSkillSummaries);\n\n    modalRef.result.then((summary) => {\n      try {\n        this.storyUpdateService.addAcquiredSkillIdToNode(\n          this.story, this.nodeId, summary.id);\n      } catch (err) {\n        this.alertsService.addInfoMessage(\n          'Given skill is already an acquired skill', 5000);\n      }\n    }, () => {\n      // Note to developers:\n      // This callback is triggered when the Cancel button is clicked.\n      // No further action is needed.\n    });\n  }\n\n  removeAcquiredSkillId(skillId: string): void {\n    this.storyUpdateService.removeAcquiredSkillIdFromNode(\n      this.story, this.nodeId, skillId);\n  }\n\n  unfinalizeOutline(): void {\n    this.storyUpdateService.unfinalizeStoryNodeOutline(this.story, this.nodeId);\n  }\n\n  openNodeTitleEditor(): void {\n    this.nodeTitleEditorIsShown = true;\n  }\n\n  closeNodeTitleEditor(): void {\n    this.nodeTitleEditorIsShown = false;\n  }\n\n  isOutlineModified(outline: string): boolean {\n    return this.oldOutline !== outline;\n  }\n\n  updateOutline(newOutline: string): void {\n    if (this.isOutlineModified(newOutline)) {\n      this.storyUpdateService.setStoryNodeOutline(\n        this.story, this.nodeId, newOutline);\n      this.oldOutline = newOutline;\n    }\n  }\n\n  togglePreview(): void {\n    this.chapterPreviewCardIsShown = !this.chapterPreviewCardIsShown;\n  }\n\n  togglePrerequisiteSkillsList(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.prerequisiteSkillIsShown = !this.prerequisiteSkillIsShown;\n    }\n  }\n\n  toggleChapterOutline(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.chapterOutlineIsShown = !this.chapterOutlineButtonsAreShown;\n    }\n  }\n\n  toggleAcquiredSkillsList(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.acquiredSkillIsShown = !this.acquiredSkillIsShown;\n    }\n  }\n\n  toggleChapterCard(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.mainChapterCardIsShown = !this.mainChapterCardIsShown;\n    }\n  }\n\n  toggleChapterTodoCard(): void {\n    if (this.windowDimensionsService.isWindowNarrow()) {\n      this.chapterTodoCardIsShown = !this.chapterTodoCardIsShown;\n    }\n  }\n\n  toggleExplorationInputButtons(): void {\n    this.explorationInputButtonsAreShown = (\n      !this.explorationInputButtonsAreShown);\n  }\n\n  updateLocalEditableOutline($event: string): void {\n    if (this.editableOutline !== $event) {\n      this.editableOutline = $event;\n      if (!this.chapterOutlineButtonsAreShown && $event) {\n        this.toggleChapterOutlineButtons();\n      }\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  toggleChapterOutlineButtons(): void {\n    this.chapterOutlineButtonsAreShown = !this.chapterOutlineButtonsAreShown;\n  }\n\n  _recalculateAvailableNodes(): void {\n    this.newNodeId = null;\n    this.availableNodes = [];\n    let linearNodesList = this.story.getStoryContents().getLinearNodesList();\n\n    let linearNodeIds = linearNodesList.map((node) => node.getId());\n\n    for (let i = 0; i < this.storyNodeIds.length; i++) {\n      if (this.storyNodeIds[i] === this.nodeId) {\n        continue;\n      }\n\n      if (this.destinationNodeIds.indexOf(this.storyNodeIds[i])) {\n        continue;\n      }\n\n      if (linearNodeIds.indexOf(this.storyNodeIds[i]) === -1) {\n        this.availableNodes.push({\n          id: this.storyNodeIds[i],\n          text: this.nodeIdToTitleMap[this.storyNodeIds[i]]\n        });\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    this.pageTitleService.setNavbarTitleForMobileView('Chapter Editor');\n    this.chapterOutlineIsShown = !this.windowDimensionsService.isWindowNarrow();\n    this.chapterTodoCardIsShown = (\n      !this.windowDimensionsService.isWindowNarrow());\n    this.prerequisiteSkillIsShown = (\n      !this.windowDimensionsService.isWindowNarrow());\n    this.acquiredSkillIsShown = (\n      !this.windowDimensionsService.isWindowNarrow());\n\n    this.subscriptions.add(\n      this.storyEditorStateService.onStoryInitialized.subscribe(\n        () => this._init())\n    );\n\n    this.subscriptions.add(\n      this.storyEditorStateService.onStoryReinitialized.subscribe(\n        () => this._init())\n    );\n\n    this.subscriptions.add(\n      this.storyEditorStateService.onRecalculateAvailableNodes.subscribe(\n        () => this._recalculateAvailableNodes()\n      )\n    );\n\n    this._init();\n\n    // The setTimeout is required because at execution time,\n    // the element may not be present in the DOM yet.Thus it ensure\n    // that the element is visible before focussing.\n    setTimeout(() => {\n      this.focusManagerService.setFocusWithoutScroll('storyNodeDesc');\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.subscriptions.unsubscribe();\n  }\n}\n\nangular.module('oppia').directive('oppiaStoryNodeEditor', downgradeComponent({\n  component: StoryNodeEditorComponent\n}));\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/delete-chapter-modal.component.html",
      "content": "<div class=\"modal-header\">\n  <h3>\n    Are you sure you want to delete this chapter?\n  </h3>\n</div>\n<div class=\"modal-footer\">\n  <button class=\"btn btn-secondary\" (click)=\"cancel()\">Cancel</button>\n  <button class=\"btn btn-danger e2e-test-confirm-delete-chapter-button\" (click)=\"confirm()\">\n    <span>Delete Chapter</span>\n  </button>\n</div>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/delete-chapter-modal.component.spec.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for Delete Chapter Modal.\n */\n\nimport { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { DeleteChapterModalComponent } from './delete-chapter-modal.component';\n\ndescribe('Delete Topic Modal Component', () => {\n  let fixture: ComponentFixture<DeleteChapterModalComponent>;\n  let componentInstance: DeleteChapterModalComponent;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      declarations: [\n        DeleteChapterModalComponent\n      ],\n      providers: [\n        NgbActiveModal\n      ]\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(DeleteChapterModalComponent);\n    componentInstance = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(componentInstance).toBeDefined();\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/delete-chapter-modal.component.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for DeleteChapterModal modal.\n */\n\nimport { Component } from '@angular/core';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { ConfirmOrCancelModal } from 'components/common-layout-directives/common-elements/confirm-or-cancel-modal.component';\n\n@Component({\n  selector: 'oppia-delete-chapter-modal',\n  templateUrl: './delete-chapter-modal.component.html'\n})\nexport class DeleteChapterModalComponent extends ConfirmOrCancelModal {\n  constructor(\n    private ngbActiveModal: NgbActiveModal\n  ) {\n    super(ngbActiveModal);\n  }\n}\n\nangular.module('oppia').directive('oppiaDeleteChapterModal',\n  downgradeComponent({\n    component: DeleteChapterModalComponent\n  }) as angular.IDirectiveFactory);\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/new-chapter-title-modal.component.html",
      "content": "<div class=\"modal-header create-new-chapter-modal-header\">\n  <h3>\n    New Chapter\n  </h3>\n  <i class=\"fa fa-times modal-close-button\" (click)=\"cancel()\"></i>\n</div>\n<form (submit)=\"saveAsync()\">\n  <div class=\"modal-body create-new-chapter\">\n    <div class=\"chapter-input\">\n      <div class=\"chapter-input-header\">\n        <span>Title*</span>\n        <div class=\"oppia-input-box-subtitle\">\n          <i>\n            This will be shown to the learner. It overrides the title of the exploration.\n          </i>\n        </div>\n      </div>\n      <input class=\"form-control e2e-test-new-chapter-title-field oppia-new-chapter-title-field\"\n             placeholder=\"Enter the title for this chapter to be displayed to learners in the story viewer page (can be edited later)\"\n             [(ngModel)]=\"title\"\n             [ngModelOptions]=\"{standalone: true}\"\n             (change)=\"resetErrorMsg()\"\n             maxlength=\"MAX_CHARS_IN_EXPLORATION_TITLE\" autofocus>\n      <span class=\"oppia-input-box-subtitle\">\n        <i>\n          Chapter title should be at most {{ MAX_CHARS_IN_EXPLORATION_TITLE }} characters.\n        </i>\n      </span>\n      <span class=\"new-chapter-error-msg\" *ngIf=\"errorMsg\">\n        <span>{{ errorMsg }}</span>\n      </span>\n    </div>\n\n    <div class=\"chapter-input story-input-description\">\n      <div class=\"chapter-input-header\">\n        <span>Exploration ID*</span>\n      </div>\n      <input (change)=\"resetErrorMsg()\"\n             [(ngModel)]=\"explorationId\"\n             [ngModelOptions]=\"{standalone: true}\"\n             class=\"form-control e2e-test-chapter-exploration-input\">\n      <div *ngIf=\"invalidExpId || explorationId && !validateExplorationId()\">\n        <div *ngFor=\"let invalidExpErrorString of invalidExpErrorStrings\" class=\"new-chapter-error-msg e2e-test-invalid-exp-id\">\n          <span>{{ invalidExpErrorString }}</span>\n        </div>\n      </div>\n      <span class=\"new-chapter-error-msg\" *ngIf=\"correctnessFeedbackDisabled\">\n        <span>{{ correctnessFeedbackDisabledString }}</span>\n      </span>\n      <span class=\"new-chapter-error-msg\" *ngIf=\"!categoryIsDefault\">\n        <span>The category of this exploration is invalid. Curated lessons need to have their category to be one of the default categories.</span>\n      </span>\n      <span class=\"new-chapter-error-msg\" *ngIf=\"statesWithRestrictedInteractions.length > 0\">\n        <span>The states [{{ statesWithRestrictedInteractions.join(', ') }}] contain restricted interaction types.</span>\n      </span>\n      <span class=\"new-chapter-error-msg\" *ngIf=\"statesWithTooFewMultipleChoiceOptions.length > 0\">\n        <span>The states [{{ statesWithTooFewMultipleChoiceOptions.join(', ') }}] contain invalid multiple choice interactions. They must each have at least 4 options.</span>\n      </span>\n    </div>\n    <div class=\"chapter-input chapter-input-thumbnail e2e-test-chapter-input-thumbnail\">\n      <div class=\"chapter-input-header\">\n        <span>Thumbnail Image*</span>\n      </div>\n      <oppia-thumbnail-uploader [useLocalStorage]=\"false\"\n                                (updateFilename)=\"updateThumbnailFilename($event)\"\n                                [bgColor]=\"editableThumbnailBgColor\"\n                                (updateBgColor)=\"updateThumbnailBgColor($event)\"\n                                [allowedBgColors]=\"allowedBgColors\"\n                                [aspectRatio]=\"'16:9'\"\n                                [previewTitle]=\"title\"\n                                previewDescriptionBgColor=\"#BE563C\">\n      </oppia-thumbnail-uploader>\n    </div>\n  </div>\n  <div class=\"modal-footer\">\n    <button class=\"btn btn-secondary e2e-test-cancel-chapter-creation-button\" (click)=\"cancel()\" type=\"button\">Cancel</button>\n    <button class=\"btn btn-success e2e-test-confirm-chapter-creation-button\" type=\"submit\" [disabled]=\"!isValid()\">\n      <span>Create Chapter</span>\n    </button>\n  </div>\n</form>\n\n<style>\n  .chapter-input-header span {\n    font-weight: bold;\n  }\n  .chapter-input {\n    padding-bottom: 15px;\n  }\n  .chapter-input-thumbnail {\n    padding-bottom: 0;\n    padding-top: 10px;\n  }\n  .new-chapter-error-msg {\n    color: #f00;\n    font-size: small;\n  }\n  .modal-close-button {\n    display: none;\n  }\n  .oppia-new-chapter-title-field {\n    font-size: 12px;\n  }\n  @media screen and (max-width: 768px) {\n    .modal-dialog {\n      border: 0;\n      border-radius: 0;\n      margin: 0;\n      padding: 0;\n      width: 100vw;\n    }\n    .modal-content {\n      border: 0;\n      border-radius: 0;\n      height: 100vh;\n    }\n    .modal-header {\n      align-items: center;\n      background-color: #00609c;\n      display: flex;\n    }\n    .modal-header h3 {\n      color: #fff;\n    }\n    .chapter-input {\n      margin: 30px 10px;\n    }\n    .create-new-chapter-input-field {\n      margin: 25px 0;\n    }\n    .modal-close-button {\n      color: #fff;\n      display: block;\n      font-size: 20px;\n    }\n  }\n\n</style>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/new-chapter-title-modal.component.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for new chapter title modal.\n */\n\nimport { Component, Input, OnInit } from '@angular/core';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { AppConstants } from 'app.constants';\nimport newChapterConstants from 'assets/constants';\nimport { CuratedExplorationValidationService } from 'domain/exploration/curated-exploration-validation.service';\nimport { EditableStoryBackendApiService } from 'domain/story/editable-story-backend-api.service';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\nimport { Story } from 'domain/story/story.model';\nimport { ValidatorsService } from 'services/validators.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\n\n@Component({\n  selector: 'oppia-new-chapter-title-modal',\n  templateUrl: './new-chapter-title-modal.component.html'\n})\nexport class NewChapterTitleModalComponent implements OnInit {\n  @Input() nodeTitles!: string | string[];\n  title!: string;\n  explorationId!: string;\n  invalidExpId!: boolean;\n  errorMsg!: string | null;\n  invalidExpErrorStrings!: string[];\n  correctnessFeedbackDisabledString!: string;\n  MAX_CHARS_IN_EXPLORATION_TITLE = AppConstants.MAX_CHARS_IN_EXPLORATION_TITLE;\n  story!: Story;\n  nodeId!: string;\n  editableThumbnailBgColor!: string;\n  editableThumbnailFilename!: string;\n  correctnessFeedbackDisabled!: boolean;\n  categoryIsDefault!: boolean;\n  statesWithRestrictedInteractions!: string | string[];\n  statesWithTooFewMultipleChoiceOptions!: string | string[];\n  allowedBgColors = (\n    newChapterConstants.ALLOWED_THUMBNAIL_BG_COLORS.chapter);\n\n  constructor(\n    private curatedExplorationValidationService:\n     CuratedExplorationValidationService,\n    private editableStoryBackendApiService: EditableStoryBackendApiService,\n    private ngbActiveModal: NgbActiveModal,\n    private storyEditorStateService: StoryEditorStateService,\n    private storyUpdateService: StoryUpdateService,\n    private validatorsService: ValidatorsService\n  ) {}\n\n  ngOnInit(): void {\n    this.init();\n  }\n\n  addStoryNodeWithData(): void {\n    this.storyUpdateService.addStoryNode(this.story, this.title);\n    this.storyUpdateService.setStoryNodeTitle(\n      this.story, this.nodeId, this.title);\n    this.storyUpdateService.setStoryNodeThumbnailFilename(\n      this.story, this.nodeId, this.editableThumbnailFilename);\n    this.storyUpdateService.setStoryNodeThumbnailBgColor(\n      this.story, this.nodeId, this.editableThumbnailBgColor);\n  }\n\n  init(): void {\n    this.title = '';\n    this.explorationId = '';\n    this.editableThumbnailFilename = '';\n    this.invalidExpId = false;\n    this.errorMsg = null;\n    this.invalidExpErrorStrings = ['Please enter a valid exploration id.'];\n    this.correctnessFeedbackDisabledString = 'The correctness feedback ' +\n      'of this exploration is disabled. Explorations need to have their ' +\n      'correctness feedback enabled before they can be added to a story.';\n    this.story = this.storyEditorStateService.getStory();\n    this.nodeId = this.story.getStoryContents().getNextNodeId();\n    this.editableThumbnailBgColor = '';\n    this.correctnessFeedbackDisabled = false;\n    this.categoryIsDefault = true;\n    this.statesWithRestrictedInteractions = [];\n    this.statesWithTooFewMultipleChoiceOptions = [];\n  }\n\n  updateThumbnailFilename(newThumbnailFilename: string): void {\n    this.editableThumbnailFilename = newThumbnailFilename;\n  }\n\n  updateThumbnailBgColor(newThumbnailBgColor: string): void {\n    this.editableThumbnailBgColor = newThumbnailBgColor;\n  }\n\n  cancel(): void {\n    this.ngbActiveModal.dismiss();\n  }\n\n  updateExplorationId(): void {\n    var nodes = this.story.getStoryContents().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].getExplorationId() === this.explorationId) {\n        this.invalidExpErrorStrings = [\n          'The given exploration already exists in the story.'];\n        this.invalidExpId = true;\n        return;\n      }\n    }\n    this.storyUpdateService.setStoryNodeExplorationId(\n      this.story, this.nodeId, this.explorationId);\n\n    this.ngbActiveModal.close();\n  }\n\n  resetErrorMsg(): void {\n    this.errorMsg = null;\n    this.invalidExpId = false;\n    this.correctnessFeedbackDisabled = false;\n    this.categoryIsDefault = true;\n    this.invalidExpErrorStrings = ['Please enter a valid exploration id.'];\n  }\n\n  validateExplorationId(): boolean {\n    return this.validatorsService.isValidExplorationId(\n      this.explorationId, false);\n  }\n\n  isValid(): boolean {\n    return Boolean(\n      this.title &&\n      this.validatorsService.isValidExplorationId(this.explorationId, false) &&\n      this.editableThumbnailFilename);\n  }\n\n  async saveAsync(): Promise<void> {\n    if (this.nodeTitles.indexOf(this.title) !== -1) {\n      this.errorMsg = 'A chapter with this title already exists';\n      return;\n    }\n\n    const expIsPublished = (\n      await this.curatedExplorationValidationService.isExpPublishedAsync(\n        this.explorationId));\n    if (!expIsPublished) {\n      this.invalidExpErrorStrings = [\n        'This exploration does not exist or is not published yet.'\n      ];\n      this.invalidExpId = true;\n      return;\n    }\n\n    this.invalidExpId = false;\n    const correctnessFeedbackIsEnabled = (\n      await this.curatedExplorationValidationService\n        .isCorrectnessFeedbackEnabled(this.explorationId));\n    if (!correctnessFeedbackIsEnabled) {\n      this.correctnessFeedbackDisabled = true;\n      return;\n    }\n    this.correctnessFeedbackDisabled = false;\n\n    const categoryIsDefault = (\n      await this.curatedExplorationValidationService.isDefaultCategoryAsync(\n        this.explorationId));\n    if (!categoryIsDefault) {\n      this.categoryIsDefault = false;\n      return;\n    }\n    this.categoryIsDefault = true;\n\n    this.statesWithRestrictedInteractions = (\n      await this.curatedExplorationValidationService\n        .getStatesWithRestrictedInteractions(this.explorationId));\n    if (this.statesWithRestrictedInteractions.length > 0) {\n      return;\n    }\n\n    this.statesWithTooFewMultipleChoiceOptions = (\n      await this.curatedExplorationValidationService\n        .getStatesWithInvalidMultipleChoices(this.explorationId));\n    if (this.statesWithTooFewMultipleChoiceOptions.length > 0) {\n      return;\n    }\n\n    const validationErrorMessages = (\n      await this.editableStoryBackendApiService.validateExplorationsAsync(\n        this.story.getId(), [this.explorationId]\n      ));\n    if (validationErrorMessages.length > 0) {\n      this.invalidExpId = true;\n      this.invalidExpErrorStrings = validationErrorMessages;\n      return;\n    }\n    this.invalidExpId = false;\n\n    this.addStoryNodeWithData();\n    this.updateExplorationId();\n  }\n}\n\nangular.module('oppia').directive('oppiaNewChapterTitleModal',\n  downgradeComponent({\n    component: NewChapterTitleModalComponent\n  }) as angular.IDirectiveFactory);\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/modal-templates/new-chapter-title-modal.controller.spec.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for CreateNewChapterModalController.\n */\n\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { ComponentFixture, fakeAsync, flushMicrotasks, TestBed } from '@angular/core/testing';\nimport { Story } from 'domain/story/story.model';\nimport { CuratedExplorationValidationService } from 'domain/exploration/curated-exploration-validation.service';\nimport { NewChapterTitleModalComponent } from './new-chapter-title-modal.component';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { EditableStoryBackendApiService } from '../../../domain/story/editable-story-backend-api.service';\nimport { StoryEditorStateService } from '../services/story-editor-state.service';\nimport { StoryUpdateService } from '../../../domain/story/story-update.service';\nimport { NO_ERRORS_SCHEMA } from '@angular/core';\n\nclass MockActiveModal {\n  close(): void {\n    return;\n  }\n\n  dismiss(): void {\n    return;\n  }\n}\n\ndescribe('Create New Chapter Modal Component', () => {\n  let fixture: ComponentFixture<NewChapterTitleModalComponent>;\n  let component: NewChapterTitleModalComponent;\n  let storyEditorStateService: StoryEditorStateService;\n  let storyUpdateService: StoryUpdateService;\n  let curatedExplorationValidationService;\n  let nodeTitles = ['title 1', 'title 2', 'title 3'];\n  let editableStoryBackendApiService:\n    EditableStoryBackendApiService;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        NewChapterTitleModalComponent\n      ],\n      providers: [\n        StoryEditorStateService,\n        StoryUpdateService,\n        CuratedExplorationValidationService,\n        EditableStoryBackendApiService,\n        {\n          provide: NgbActiveModal,\n          useClass: MockActiveModal\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    });\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(NewChapterTitleModalComponent);\n    component = fixture.componentInstance;\n    curatedExplorationValidationService = (\n      TestBed.inject(CuratedExplorationValidationService));\n    editableStoryBackendApiService = (\n      TestBed.inject(EditableStoryBackendApiService));\n    storyUpdateService = TestBed.inject(StoryUpdateService);\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n    curatedExplorationValidationService = TestBed.inject(\n      CuratedExplorationValidationService);\n    component.nodeTitles = nodeTitles;\n\n    let sampleStoryBackendObject = {\n      id: 'sample_story_id',\n      title: 'Story title',\n      description: 'Story description',\n      notes: 'Story notes',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      story_contents: {\n        initial_node_id: 'node_2',\n        nodes: [\n          {\n            id: 'node_1',\n            title: 'Title 1',\n            description: 'Description 1',\n            prerequisite_skill_ids: ['skill_1'],\n            acquired_skill_ids: ['skill_2'],\n            destination_node_ids: [],\n            outline: 'Outline',\n            exploration_id: null,\n            outline_is_finalized: false\n          }, {\n            id: 'node_2',\n            title: 'Title 2',\n            description: 'Description 2',\n            prerequisite_skill_ids: ['skill_3'],\n            acquired_skill_ids: ['skill_4'],\n            destination_node_ids: ['node_1'],\n            outline: 'Outline 2',\n            exploration_id: 'exp_1',\n            outline_is_finalized: true\n          }],\n        next_node_id: 'node_3'\n      },\n      language_code: 'en'\n    };\n    let story = Story.createFromBackendDict(\n      sampleStoryBackendObject);\n    spyOn(storyEditorStateService, 'getStory').and.returnValue(story);\n\n    component.ngOnInit();\n  });\n\n  it('should add story node with data', () => {\n    let storyUpdateSpyThumbnailBgColor = spyOn(\n      storyUpdateService, 'setStoryNodeThumbnailBgColor');\n    let storyUpdateSpyThumbnailFilename = spyOn(\n      storyUpdateService, 'setStoryNodeThumbnailFilename');\n\n    component.addStoryNodeWithData();\n\n    expect(storyUpdateSpyThumbnailBgColor).toHaveBeenCalled();\n    expect(storyUpdateSpyThumbnailFilename).toHaveBeenCalled();\n  });\n\n  it('should initialize component properties after controller is initialized',\n    () => {\n      expect(component.nodeTitles).toEqual(nodeTitles);\n      expect(component.errorMsg).toBe(null);\n      expect(component.correctnessFeedbackDisabled).toBe(false);\n      expect(component.categoryIsDefault).toBe(true);\n    });\n\n  it('should validate explorationId correctly',\n    () => {\n      component.explorationId = 'validId';\n      expect(component.validateExplorationId()).toBeTrue();\n      component.explorationId = 'oppia.org/validId';\n      expect(component.validateExplorationId()).toBeFalse();\n    });\n\n  it('should update thumbnail filename when changing thumbnail file',\n    () => {\n      component.updateThumbnailFilename('abc');\n      expect(component.editableThumbnailFilename).toEqual('abc');\n    });\n\n  it('should update thumbnail bg color when changing thumbnail color',\n    () => {\n      component.updateThumbnailBgColor('abc');\n      component.cancel();\n      expect(component.editableThumbnailBgColor).toEqual('abc');\n    });\n\n  it('should check if chapter is valid when it has title, exploration id and' +\n    ' thumbnail file', () => {\n    expect(component.isValid()).toEqual(false);\n    component.title = 'title';\n    component.explorationId = '1';\n    expect(component.isValid()).toEqual(false);\n    component.editableThumbnailFilename = '1';\n    expect(component.isValid()).toEqual(true);\n    component.explorationId = '';\n    expect(component.isValid()).toEqual(false);\n  });\n\n  it('should show warning message when exploration cannot be curated',\n    fakeAsync(() => {\n      spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(true);\n      spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n        .and.resolveTo(true);\n      spyOn(curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled')\n        .and.resolveTo(true);\n      spyOn(curatedExplorationValidationService, 'isDefaultCategoryAsync')\n        .and.resolveTo(true);\n      spyOn(\n        curatedExplorationValidationService,\n        'getStatesWithRestrictedInteractions').and.resolveTo([]);\n      spyOn(\n        curatedExplorationValidationService,\n        'getStatesWithInvalidMultipleChoices').and.resolveTo([]);\n      spyOn(\n        editableStoryBackendApiService, 'validateExplorationsAsync'\n      ).and.resolveTo([\n        'Explorations in a story are not expected to contain ' +\n        'training data for any answer group. State Introduction of ' +\n        'exploration with ID 1 contains training data in one of ' +\n        'its answer groups.'\n      ]);\n      component.saveAsync();\n      flushMicrotasks();\n\n      expect(component.invalidExpId).toEqual(true);\n      expect(component.invalidExpErrorStrings).toEqual([\n        'Explorations in a story are not expected to contain ' +\n        'training data for any answer group. State Introduction of ' +\n        'exploration with ID 1 contains training data in one of ' +\n        'its answer groups.'\n      ]);\n    }));\n\n  it('should warn that the exploration is not published when trying to save' +\n    ' a chapter with an invalid exploration id', fakeAsync(() => {\n    spyOn(storyEditorStateService, 'isStoryPublished').and.returnValue(true);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.resolveTo(false);\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    component.saveAsync();\n    flushMicrotasks();\n\n    expect(component.invalidExpId).toEqual(true);\n  }));\n\n  it('should warn that the exploration already exists in the story when' +\n    ' trying to save a chapter with an already used exploration id',\n  () => {\n    component.explorationId = 'exp_1';\n    component.updateExplorationId();\n    expect(component.invalidExpErrorStrings).toEqual([\n      'The given exploration already exists in the story.'\n    ]);\n    expect(component.invalidExpId).toEqual(true);\n  });\n\n  it('should set story node exploration id when updating exploration id',\n    () => {\n      let storyUpdateSpy = spyOn(\n        storyUpdateService, 'setStoryNodeExplorationId');\n      component.updateExplorationId();\n      expect(storyUpdateSpy).toHaveBeenCalled();\n    });\n\n  it('should not save when the chapter title is already used', () => {\n    component.title = nodeTitles[0];\n    component.saveAsync();\n    expect(component.errorMsg).toBe('A chapter with this title already exists');\n  });\n\n  it('should prevent exploration from being added if it doesn\\'t exist ' +\n    'or isn\\'t published yet', fakeAsync(() => {\n    component.title = 'dummy_title';\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.returnValue(false);\n    const correctnessFeedbackSpy = spyOn(\n      curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled');\n    const categorySpy = spyOn(\n      curatedExplorationValidationService, 'isDefaultCategoryAsync');\n    component.saveAsync();\n    flushMicrotasks();\n    expect(component.invalidExpId).toEqual(true);\n    expect(correctnessFeedbackSpy).not.toHaveBeenCalled();\n    expect(categorySpy).not.toHaveBeenCalled();\n  }));\n\n  it('should prevent exploration from being added if its correctness ' +\n  'feedback is disabled', fakeAsync(() => {\n    component.title = 'dummy_title';\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled')\n      .and.resolveTo(false);\n    component.saveAsync();\n    flushMicrotasks();\n    expect(component.correctnessFeedbackDisabled).toBe(true);\n  }));\n\n  it('should prevent exploration from being added if its category ' +\n  'is not default', fakeAsync(() => {\n    component.title = 'dummy_title';\n\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isDefaultCategoryAsync')\n      .and.resolveTo(false);\n\n    component.saveAsync();\n    flushMicrotasks();\n\n    expect(component.categoryIsDefault).toBe(false);\n  }));\n\n  it('should prevent exploration from being added if it contains restricted ' +\n  'interaction types', fakeAsync(() => {\n    component.title = 'dummy_title';\n    const invalidStates = ['some_invalid_state'];\n\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isDefaultCategoryAsync')\n      .and.resolveTo(true);\n    spyOn(\n      curatedExplorationValidationService,\n      'getStatesWithRestrictedInteractions').and.resolveTo(invalidStates);\n\n    component.saveAsync();\n    flushMicrotasks();\n\n    expect(component.statesWithRestrictedInteractions).toBe(invalidStates);\n  }));\n\n  it('should prevent exploration from being added if it contains an invalid ' +\n  'multiple choice input', fakeAsync(() => {\n    component.title = 'dummy_title';\n    const invalidStates = ['some_invalid_state'];\n\n    spyOn(\n      editableStoryBackendApiService, 'validateExplorationsAsync'\n    ).and.resolveTo([]);\n    spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isCorrectnessFeedbackEnabled')\n      .and.resolveTo(true);\n    spyOn(curatedExplorationValidationService, 'isDefaultCategoryAsync')\n      .and.resolveTo(true);\n    spyOn(\n      curatedExplorationValidationService,\n      'getStatesWithRestrictedInteractions').and.resolveTo([]);\n    spyOn(\n      curatedExplorationValidationService,\n      'getStatesWithInvalidMultipleChoices').and.resolveTo(invalidStates);\n\n    component.saveAsync();\n    flushMicrotasks();\n\n    expect(component.statesWithTooFewMultipleChoiceOptions).toBe(invalidStates);\n  }));\n\n  it('should attempt to save exploration when all validation checks pass',\n    fakeAsync(() => {\n      component.title = 'dummy_title';\n      spyOn(\n        editableStoryBackendApiService, 'validateExplorationsAsync'\n      ).and.resolveTo([]);\n      spyOn(curatedExplorationValidationService, 'isExpPublishedAsync')\n        .and.resolveTo(true);\n      spyOn(\n        curatedExplorationValidationService,\n        'isCorrectnessFeedbackEnabled').and.resolveTo(true);\n      spyOn(curatedExplorationValidationService, 'isDefaultCategoryAsync')\n        .and.resolveTo(true);\n      spyOn(\n        curatedExplorationValidationService,\n        'getStatesWithRestrictedInteractions').and.resolveTo([]);\n      spyOn(\n        curatedExplorationValidationService,\n        'getStatesWithInvalidMultipleChoices').and.resolveTo([]);\n      const updateExplorationIdSpy = spyOn(component, 'updateExplorationId');\n      component.saveAsync();\n      flushMicrotasks();\n\n      expect(updateExplorationIdSpy).toHaveBeenCalled();\n    }));\n\n  it('should clear error message when changing exploration id', () => {\n    component.title = nodeTitles[0];\n    component.saveAsync();\n    expect(component.errorMsg).toBe('A chapter with this title already exists');\n\n    component.resetErrorMsg();\n    expect(component.errorMsg).toBe(null);\n    expect(component.invalidExpId).toBe(false);\n    expect(component.invalidExpErrorStrings).toEqual([\n      'Please enter a valid exploration id.'\n    ]);\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/services/story-editor-state.service.spec.ts",
      "content": "// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for StoryEditorStateService.\n */\n\nimport { fakeAsync, TestBed, tick } from '@angular/core/testing';\n\nimport { Subscription } from 'rxjs';\nimport { Story } from 'domain/story/story.model';\nimport { StoryBackendDict } from 'domain/story/story.model';\nimport { EditableStoryBackendApiService } from 'domain/story/editable-story-backend-api.service';\nimport { StoryEditorStateService } from 'pages/story-editor-page/services/story-editor-state.service';\nimport { importAllAngularServices } from 'tests/unit-test-utils.ajs';\nimport { AlertsService } from 'services/alerts.service';\nimport { StoryUpdateService } from 'domain/story/story-update.service';\n\nclass MockEditableStoryBackendApiService {\n  newBackendStoryObject!: StoryBackendDict;\n  failure: string | null = null;\n\n  async fetchStoryAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve({\n          story: this.newBackendStoryObject,\n          topicName: 'Topic Name',\n          storyIsPublished: false,\n          skillSummaries: [{\n            id: 'Skill 1',\n            description: 'Skill Description',\n            language_code: 'en',\n            version: 1,\n            misconception_count: 0,\n            worked_examples_count: 0,\n            skill_model_created_on: 0,\n            skill_model_last_updated: 0,\n          }],\n          classroomUrlFragment: 'classroomUrlFragment',\n          topicUrlFragment: 'topicUrlFragment'\n        });\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async updateStoryAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve(this.newBackendStoryObject);\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async changeStoryPublicationStatusAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve({});\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async doesStoryWithUrlFragmentExistAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        console.error('test');\n        resolve(false);\n      } else {\n        reject();\n      }\n    });\n  }\n}\n\ndescribe('Story editor state service', () => {\n  var alertsService: AlertsService;\n  var storyEditorStateService: StoryEditorStateService;\n  var storyUpdateService: StoryUpdateService;\n  var fakeEditableStoryBackendApiService: MockEditableStoryBackendApiService;\n  var secondBackendStoryObject: StoryBackendDict;\n  var testSubscriptions: Subscription;\n\n  importAllAngularServices();\n\n  const storyInitializedSpy = jasmine.createSpy('storyInitialized');\n  const storyReinitializedSpy = jasmine.createSpy('storyReinitialized');\n\n  beforeEach(() => {\n    fakeEditableStoryBackendApiService = (\n      new MockEditableStoryBackendApiService());\n\n    fakeEditableStoryBackendApiService.newBackendStoryObject = {\n      id: 'storyId_0',\n      title: 'Story title',\n      description: 'Story Description',\n      notes: '<p>Notes/p>',\n      story_contents: {\n        initial_node_id: 'node_1',\n        next_node_id: 'node_2',\n        nodes: []\n      },\n      language_code: 'en',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      thumbnail_filename: 'img.svg',\n      thumbnail_bg_color: '',\n      url_fragment: 'url_fragment1',\n      meta_tag_content: 'meta_content1'\n    };\n\n    secondBackendStoryObject = {\n      id: 'storyId_1',\n      title: 'Story title  2',\n      description: 'Story Description 2',\n      notes: '<p>Notes 2/p>',\n      story_contents: {\n        initial_node_id: 'node_2',\n        next_node_id: 'node_1',\n        nodes: []\n      },\n      language_code: 'en',\n      version: 1,\n      corresponding_topic_id: 'topic_id',\n      thumbnail_filename: 'img.svg',\n      thumbnail_bg_color: '',\n      url_fragment: 'url_fragment2',\n      meta_tag_content: 'meta_content2'\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: EditableStoryBackendApiService,\n          useValue: fakeEditableStoryBackendApiService\n        },\n        StoryUpdateService\n      ]\n    }).compileComponents();\n\n    alertsService = TestBed.inject(AlertsService);\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n    storyUpdateService = TestBed.inject(StoryUpdateService);\n  });\n\n  beforeEach(() => {\n    testSubscriptions = new Subscription();\n    testSubscriptions.add(storyEditorStateService.onStoryInitialized.subscribe(\n      storyInitializedSpy));\n    testSubscriptions.add(\n      storyEditorStateService.onStoryReinitialized.subscribe(\n        storyReinitializedSpy));\n  });\n\n  afterEach(() => {\n    testSubscriptions.unsubscribe();\n  });\n\n  it('should request to load the story from the backend', () => {\n    spyOn(\n      fakeEditableStoryBackendApiService, 'fetchStoryAsync').and.callThrough();\n\n    storyEditorStateService.loadStory('storyId_0');\n    expect(\n      fakeEditableStoryBackendApiService.fetchStoryAsync).toHaveBeenCalled();\n  });\n\n  it(\n    'should fire an init event and set the topic name after loading the ' +\n    'first story', fakeAsync(() => {\n      storyEditorStateService.loadStory('storyId_0');\n      tick(1000);\n      expect(storyEditorStateService.getTopicName()).toEqual('Topic Name');\n      expect(storyInitializedSpy).toHaveBeenCalled();\n    }));\n\n  it('should fire an update event after loading more stories', fakeAsync(() => {\n    // Load initial story.\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n\n    // Load a second story.\n    storyEditorStateService.loadStory('storyId_1');\n    tick(1000);\n    expect(storyReinitializedSpy).toHaveBeenCalled();\n  }));\n\n  it('should track whether it is currently loading the story', fakeAsync(() => {\n    expect(storyEditorStateService.isLoadingStory()).toBe(false);\n\n    storyEditorStateService.loadStory('storyId_0');\n    expect(storyEditorStateService.isLoadingStory()).toBe(true);\n\n    tick(1000);\n    expect(storyEditorStateService.isLoadingStory()).toBe(false);\n  }));\n\n  it('should indicate a story is no longer loading after an error',\n    fakeAsync(() => {\n      expect(storyEditorStateService.isLoadingStory()).toBe(false);\n      fakeEditableStoryBackendApiService.failure = 'Internal 500 error';\n\n      storyEditorStateService.loadStory('storyId_0');\n      expect(storyEditorStateService.isLoadingStory()).toBe(true);\n\n      tick(1000);\n      expect(storyEditorStateService.isLoadingStory()).toBe(false);\n    }));\n\n  it('should report that a story has loaded through loadStory()',\n    fakeAsync(() => {\n      expect(storyEditorStateService.hasLoadedStory()).toBe(false);\n\n      storyEditorStateService.loadStory('storyId_0');\n      expect(storyEditorStateService.hasLoadedStory()).toBe(false);\n\n      tick(1000);\n      expect(storyEditorStateService.hasLoadedStory()).toBe(true);\n    }));\n\n  it('should report that a story has loaded through setStory()', () => {\n    expect(storyEditorStateService.hasLoadedStory()).toBe(false);\n\n    var newStory = Story.createFromBackendDict(\n      secondBackendStoryObject);\n    storyEditorStateService.setStory(newStory);\n    expect(storyEditorStateService.hasLoadedStory()).toBe(true);\n  });\n\n  it('should be able to set a new story with an in-place copy',\n    fakeAsync(() => {\n      storyEditorStateService.loadStory('storyId_0');\n      tick(1000);\n\n      var previousStory = storyEditorStateService.getStory();\n      var expectedStory = Story.createFromBackendDict(\n        secondBackendStoryObject);\n      expect(previousStory).not.toEqual(expectedStory);\n\n      storyEditorStateService.setStory(expectedStory);\n\n      var actualStory = storyEditorStateService.getStory();\n      expect(actualStory).toEqual(expectedStory);\n\n      expect(actualStory).toBe(previousStory);\n      expect(actualStory).not.toBe(expectedStory);\n    }));\n\n  it('should fail to save the story without first loading one', () => {\n    expect(() => {\n      const successCallback = jasmine.createSpy('successCallback');\n      const errorCallback = jasmine.createSpy('errorCallback');\n\n      storyEditorStateService.saveStory(\n        'Commit message', successCallback, errorCallback);\n    }).toThrowError();\n  });\n\n  it('should not save the story if there are no pending changes',\n    fakeAsync(() => {\n      const successCallback = jasmine.createSpy('successCallback');\n      const errorCallback = jasmine.createSpy('errorCallback');\n\n      storyEditorStateService.loadStory('storyId_0');\n      tick(1000);\n\n      expect(storyEditorStateService.saveStory(\n        'Commit message', successCallback, errorCallback)).toBe(false);\n    }));\n\n  it('should be able to save the story and pending changes', fakeAsync(() => {\n    spyOn(\n      fakeEditableStoryBackendApiService,\n      'updateStoryAsync').and.callThrough();\n    var successCallback = jasmine.createSpy('successCallback');\n    var errorCallback = jasmine.createSpy('errorCallback');\n\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n    storyUpdateService.setStoryTitle(\n      storyEditorStateService.getStory(), 'New title');\n    tick(1000);\n\n    expect(storyEditorStateService.saveStory(\n      'Commit message', successCallback, errorCallback)).toBe(true);\n    tick(1000);\n\n    var expectedId = 'storyId_0';\n    var expectedVersion = 1;\n    var expectedCommitMessage = 'Commit message';\n    var expectedObject = {\n      property_name: 'title',\n      new_value: 'New title',\n      old_value: 'Story title',\n      cmd: 'update_story_property'\n    };\n    var updateStorySpy = (\n      fakeEditableStoryBackendApiService.updateStoryAsync);\n    expect(updateStorySpy).toHaveBeenCalledWith(\n      expectedId, expectedVersion,\n      expectedCommitMessage, [expectedObject]);\n    expect(successCallback).toHaveBeenCalled();\n  }));\n\n  it('should be able to publish the story', fakeAsync(() => {\n    spyOn(\n      fakeEditableStoryBackendApiService,\n      'changeStoryPublicationStatusAsync').and.callThrough();\n    var successCallback = jasmine.createSpy('successCallback');\n\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n\n    expect(storyEditorStateService.isStoryPublished()).toBe(false);\n    expect(\n      storyEditorStateService.changeStoryPublicationStatus(\n        true, successCallback)).toBe(true);\n    tick(1000);\n\n    var expectedId = 'storyId_0';\n    var publishStorySpy = (\n      fakeEditableStoryBackendApiService.changeStoryPublicationStatusAsync);\n    expect(publishStorySpy).toHaveBeenCalledWith(\n      expectedId, true);\n    expect(storyEditorStateService.isStoryPublished()).toBe(true);\n    expect(successCallback).toHaveBeenCalled();\n  }));\n\n  it('should warn user when story is not published', fakeAsync(() => {\n    const successCallback = jasmine.createSpy('successCallback');\n    spyOn(\n      fakeEditableStoryBackendApiService,\n      'changeStoryPublicationStatusAsync').and.callThrough();\n    spyOn(alertsService, 'addWarning');\n\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n    fakeEditableStoryBackendApiService.failure = 'Internal 500 error';\n\n    expect(storyEditorStateService.isStoryPublished()).toBe(false);\n    expect(\n      storyEditorStateService.changeStoryPublicationStatus(\n        true, successCallback)).toBe(true);\n    tick(1000);\n\n    var expectedId = 'storyId_0';\n    var publishStorySpy = (\n      fakeEditableStoryBackendApiService.changeStoryPublicationStatusAsync);\n    expect(publishStorySpy).toHaveBeenCalledWith(\n      expectedId, true);\n    expect(storyEditorStateService.isStoryPublished()).toBe(false);\n    expect(alertsService.addWarning).toHaveBeenCalledWith(\n      'There was an error when publishing/unpublishing the story.'\n    );\n  }));\n\n  it('should warn user when user attepts to publish story before it loads',\n    fakeAsync(() => {\n      storyEditorStateService.loadStory('storyId_0');\n      tick(1000);\n\n      const successCallback = jasmine.createSpy('successCallback');\n      spyOn(alertsService, 'fatalWarning');\n      storyEditorStateService._storyIsInitialized = false;\n\n      storyEditorStateService.changeStoryPublicationStatus(\n        true, successCallback);\n\n      expect(alertsService.fatalWarning)\n        .toHaveBeenCalledWith('Cannot publish a story before one is loaded.');\n    }));\n\n  it('should fire an update event after saving the story', fakeAsync(() => {\n    const successCallback = jasmine.createSpy('successCallback');\n    const errorCallback = jasmine.createSpy('errorCallback');\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n    storyUpdateService.setStoryTitle(\n      storyEditorStateService.getStory(), 'New title');\n    tick(1000);\n\n    storyEditorStateService.saveStory(\n      'Commit message', successCallback, errorCallback);\n    tick(1000);\n    expect(storyReinitializedSpy).toHaveBeenCalled();\n  }));\n\n  it('should track whether it is currently saving the story', fakeAsync(() => {\n    const successCallback = jasmine.createSpy('successCallback');\n    const errorCallback = jasmine.createSpy('errorCallback');\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n    storyUpdateService.setStoryTitle(\n      storyEditorStateService.getStory(), 'New title');\n    tick(1000);\n\n    expect(storyEditorStateService.isSavingStory()).toBe(false);\n    storyEditorStateService.saveStory(\n      'Commit message', successCallback, errorCallback);\n    expect(storyEditorStateService.isSavingStory()).toBe(true);\n\n    tick(1000);\n    expect(storyEditorStateService.isSavingStory()).toBe(false);\n  }));\n\n  it('should warn user when story fails to save', fakeAsync(() => {\n    spyOn(alertsService, 'addWarning');\n    var successCallback = jasmine.createSpy('successCallback');\n    var errorCallback = jasmine.createSpy('errorCallback');\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n    storyUpdateService.setStoryTitle(\n      storyEditorStateService.getStory(), 'New title');\n    tick(1000);\n    fakeEditableStoryBackendApiService.failure = 'Internal 500 error';\n\n    storyEditorStateService.saveStory(\n      'Commit message', successCallback, errorCallback);\n    tick(1000);\n\n    expect(alertsService.addWarning)\n      .toHaveBeenCalledWith('There was an error when saving the story.');\n    expect(errorCallback)\n      .toHaveBeenCalledWith('There was an error when saving the story.');\n  }));\n\n  it('should indicate a story is no longer saving after an error',\n    fakeAsync(() => {\n      const successCallback = jasmine.createSpy('successCallback');\n      const errorCallback = jasmine.createSpy('errorCallback');\n      storyEditorStateService.loadStory('storyId_0');\n      tick(1000);\n      storyUpdateService.setStoryTitle(\n        storyEditorStateService.getStory(), 'New title');\n      tick(1000);\n\n      expect(storyEditorStateService.isSavingStory()).toBe(false);\n      fakeEditableStoryBackendApiService.failure = 'Internal 500 error';\n\n      storyEditorStateService.saveStory(\n        'Commit message', successCallback, errorCallback);\n      expect(storyEditorStateService.isSavingStory()).toBe(true);\n\n      tick(1000);\n      expect(storyEditorStateService.isSavingStory()).toBe(false);\n    }));\n\n  it('should update stories URL when user updates the storie\\'s URL',\n    fakeAsync(() => {\n      var newStory = Story.createFromBackendDict(\n        secondBackendStoryObject);\n      storyEditorStateService.setStory(newStory);\n\n      fakeEditableStoryBackendApiService.failure = '';\n      storyEditorStateService._storyWithUrlFragmentExists = true;\n\n      storyEditorStateService.updateExistenceOfStoryUrlFragment(\n        'test_url', () =>{});\n      tick(1000);\n\n      expect(storyEditorStateService.getStoryWithUrlFragmentExists())\n        .toBe(false);\n    }));\n\n  it('should warn user when user updates the storie\\'s URL to an URL' +\n  ' that already exits', fakeAsync(() => {\n    spyOn(alertsService, 'addWarning');\n    var newStory = Story.createFromBackendDict(\n      secondBackendStoryObject);\n    storyEditorStateService.setStory(newStory);\n\n    fakeEditableStoryBackendApiService.failure = 'Story URL exists';\n    storyEditorStateService._storyWithUrlFragmentExists = false;\n\n    storyEditorStateService.updateExistenceOfStoryUrlFragment(\n      'test_url', () =>{});\n    tick(1000);\n\n    expect(alertsService.addWarning).toHaveBeenCalledWith(\n      'There was an error when checking if the story url fragment ' +\n      'exists for another story.');\n  }));\n\n  it('should return classroom url fragment when called', fakeAsync(() => {\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n\n    expect(storyEditorStateService.getClassroomUrlFragment())\n      .toBe('classroomUrlFragment');\n  }));\n\n  it('should return topic url fragment when called', fakeAsync(() => {\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n\n    expect(storyEditorStateService.getTopicUrlFragment())\n      .toBe('topicUrlFragment');\n  }));\n\n  it('should return event emitters when called', () => {\n    expect(storyEditorStateService.onStoryInitialized).toBe(\n      storyEditorStateService._storyInitializedEventEmitter);\n    expect(storyEditorStateService.onStoryReinitialized).toBe(\n      storyEditorStateService._storyReinitializedEventEmitter);\n    expect(storyEditorStateService.onViewStoryNodeEditor).toBe(\n      storyEditorStateService._viewStoryNodeEditorEventEmitter);\n    expect(storyEditorStateService.onRecalculateAvailableNodes).toBe(\n      storyEditorStateService._recalculateAvailableNodesEventEmitter);\n  });\n\n  it('should set _expIdsChanged to true when setExpIdsChanged is ' +\n  'called', () => {\n    expect(storyEditorStateService.areAnyExpIdsChanged()).toBeFalse();\n\n    storyEditorStateService.setExpIdsChanged();\n\n    expect(storyEditorStateService.areAnyExpIdsChanged()).toBeTrue();\n  });\n\n  it('should set _expIdsChanged to false when resetExpIdsChanged is ' +\n  'called', () => {\n    storyEditorStateService.setExpIdsChanged();\n\n    expect(storyEditorStateService.areAnyExpIdsChanged()).toBeTrue();\n\n    storyEditorStateService.resetExpIdsChanged();\n\n    expect(storyEditorStateService.areAnyExpIdsChanged()).toBeFalse();\n  });\n\n  it('should return skill summaries when called', fakeAsync(() => {\n    storyEditorStateService.loadStory('storyId_0');\n    tick(1000);\n\n    expect(storyEditorStateService.getSkillSummaries()).toEqual([{\n      id: 'Skill 1',\n      description: 'Skill Description',\n      language_code: 'en',\n      version: 1,\n      misconception_count: 0,\n      worked_examples_count: 0,\n      skill_model_created_on: 0,\n      skill_model_last_updated: 0,\n    }]);\n  }));\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/story-editor-page.component.html",
      "content": "<div class=\"story-editor\">\n  <div class=\"navbar-helper\">\n    <div class=\"navbar-tabs\">\n      <div class=\"navbar-text\">\n        {{ getNavbarText() }}\n      </div>\n      <div class=\"navbar-icons\">\n        <li [ngClass]=\"{'navbar-tab-active': isMainEditorTabSelected(), 'dropdown': getTotalWarningsCount()}\"\n            [attr.dropdown]=\"getTotalWarningsCount()\"\n            class=\"nav-item icon nav-list-item\"\n            (click)=\"navigateToStoryEditor()\">\n          <a ngbTooltip=\"Main Editor\" placement=\"bottom\" class=\"nav-link navbar-tab\">\n            <i class=\"fas fa-pen navbar-tab-icon\" [ngClass]=\"{'navbar-tab-active-icon': isMainEditorTabSelected()}\"></i>\n          </a>\n          <div [hidden]=\"!getTotalWarningsCount()\"\n               class=\"oppia-editor-warnings-indicator oppia-editor-warnings-error-color\"\n               (mouseover)=\"isWarningsAreShown(true)\" (mouseleave)=\"isWarningsAreShown(false)\">\n            <span class=\"oppia-editor-warnings-count e2e-test-warning-indicator\">\n              {{ getTotalWarningsCount() }}\n            </span>\n            <ul class=\"uib-dropdown-menu dropdown-menu oppia-editor-warnings-box story-editor-warning-box\" *ngIf=\"warningsAreShown\">\n              <span class=\"oppia-editor-warnings-header\">Warnings</span>\n              <li class=\"oppia-editor-warnings-text e2e-test-warnings-text\"\n                  *ngFor=\"let issue of validationIssues.concat(explorationValidationIssues);trackBy: $index\">\n                <hr class=\"oppia-editor-warnings-separator\">\n                {{ issue }}\n              </li>\n              <li class=\"oppia-editor-warnings-text e2e-test-warnings-text\"\n                  *ngFor=\"let issue of prepublishValidationIssues;trackBy: $index\">\n                <hr class=\"oppia-editor-warnings-separator\">\n                {{ issue }}\n              </li>\n            </ul>\n          </div>\n        </li>\n\n        <li *ngIf=\"!(getActiveTab() === 'chapter_editor')\" [ngClass]=\"{'navbar-tab-active': getActiveTab() === 'story_preview'}\" class=\"nav-item icon nav-list-item\" (click)=\"navigateToStoryPreviewTab()\">\n          <a class=\"nav-link navbar-tab\" ngbTooltip=\"Preview\" aria-label=\"Preview\" placement=\"bottom\">\n            <i class=\"fas fa-play navbar-tab-icon\" [ngClass]=\"{'navbar-tab-active-icon': getActiveTab() === 'story_preview'}\"></i>\n          </a>\n        </li>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"story\" class=\"story-editor-parent\">\n    <div *ngIf=\"getActiveTab() === 'story_editor'\">\n      <oppia-story-editor></oppia-story-editor>\n    </div>\n    <div *ngIf=\"getActiveTab() === 'chapter_editor'\">\n      <oppia-chapter-editor-tab></oppia-chapter-editor-tab>\n    </div>\n    <div *ngIf=\"getActiveTab() === 'story_preview'\">\n      <oppia-story-preview-tab></oppia-story-preview-tab>\n    </div>\n  </div>\n</div>\n\n<style>\n  .story-editor .back-to-topic-button {\n    margin-bottom: 10px;\n    margin-left: 9%;\n    margin-top: 1.5%;\n  }\n  .story-editor {\n    margin-bottom: 80px;\n  }\n  .navbar-helper {\n    background-color: #00609c;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.14), 0 2px 4px rgba(0, 0, 0, 0.23);\n    height: 70px;\n    margin-bottom: 20px;\n    position: fixed;\n    text-align: center;\n    top: 56px;\n    width: 100%;\n    z-index: 10;\n  }\n  .navbar-tabs {\n    display: flex;\n    flex-wrap: wrap;\n    height: 100%;\n    justify-content: flex-start;\n    text-align: center;\n  }\n  .navbar-tab-icon {\n    color: #fff;\n    display: block;\n    font-size: 22px;\n    width: 100%;\n  }\n  .navbar-tab span {\n    color: #fff;\n    font-size: 12px;\n  }\n  .oppia-editor-warnings-box {\n    cursor: default;\n    max-width: none;\n  }\n  .navbar-tab-active {\n    background-color: #e6e6e6;\n    box-shadow: 0 3px 2px 0 #e6e6e6;\n  }\n  .navbar-tab-active-icon {\n    color: #00609c;\n  }\n  .topic-warning-container {\n    display: block;\n  }\n  .story-editor-parent {\n    margin-top: 100px;\n  }\n\n  @media screen and (max-width: 800px) {\n    .story-editor-parent {\n      margin-top: 40px;\n    }\n  }\n\n  @media screen and (max-width: 768px) {\n    .navbar-helper {\n      display: none;\n    }\n  }\n  .navbar-text {\n    align-items: center;\n    color: #fff;\n    display: flex;\n    font-family: Capriola, Roboto, Arial, sans-serif;\n    font-size: 20px;\n    margin-left: 4%;\n    width: 35%;\n  }\n  .navbar-icons {\n    display: flex;\n  }\n  .nav-list-item {\n    align-items: center;\n    cursor: pointer;\n    display: flex;\n    justify-content: center;\n    width: 90px;\n  }\n  .navbar-icons .nav-list-item:hover {\n    background-color: #4eb0c0;\n  }\n  .story-editor-warning-box {\n    cursor: default;\n    display: block;\n    max-width: none;\n  }\n  .story-warning-count {\n    display: inline-block;\n    height: 20px;\n    margin-left: -10px;\n    width: 20px;\n  }\n\n  @media screen and (max-width: 800px) {\n    .navbar-helper {\n      position: inherit;\n    }\n    .navbar-tabs {\n      justify-content: center;\n    }\n    .navbar-text {\n      display: none;\n    }\n    .topic-editor-main {\n      margin-top: 16px;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/story-editor-page.component.spec.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for story editor page component.\n */\n\nimport { EventEmitter } from '@angular/core';\nimport { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { NO_ERRORS_SCHEMA } from '@angular/core';\nimport { EntityEditorBrowserTabsInfo } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info.model';\nimport { EntityEditorBrowserTabsInfoDomainConstants } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info-domain.constants';\nimport { StoryEditorPageComponent } from './story-editor-page.component';\nimport { PageTitleService } from '../../services/page-title.service';\nimport { ComponentFixture, TestBed, fakeAsync, flush, tick } from '@angular/core/testing';\nimport { PreventPageUnloadEventService } from 'services/prevent-page-unload-event.service';\nimport { StoryEditorStateService } from './services/story-editor-state.service';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { UrlService } from 'services/contextual/url.service';\nimport { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';\nimport { LocalStorageService } from 'services/local-storage.service';\nimport { StoryEditorStalenessDetectionService } from './services/story-editor-staleness-detection.service';\nimport { Story, StoryBackendDict } from 'domain/story/story.model';\nimport { EditableStoryBackendApiService } from '../../domain/story/editable-story-backend-api.service';\nimport { StoryEditorNavigationService } from './services/story-editor-navigation.service';\nimport { WindowRef } from 'services/contextual/window-ref.service';\n\nclass MockNgbModalRef {\n  componentInstance: {\n    body: 'xyz';\n  };\n}\n\nclass MockStoryEditorNavigationService {\n  activeTab: string = 'story_editor';\n  checkIfPresentInChapterEditor = () => this.activeTab === 'chapter_editor';\n  checkIfPresentInStoryPreviewTab = () => this.activeTab === 'story_preview';\n  getActiveTab = () => this.activeTab;\n  navigateToChapterEditor = () => {\n    this.activeTab = 'chapter_editor';\n  };\n\n  navigateToStoryEditor = () => {\n    this.activeTab = 'story_editor';\n  };\n\n  navigateToStoryPreviewTab = () => {\n    this.activeTab = 'story_preview';\n  };\n}\n\n\nclass MockEditableStoryBackendApiService {\n  newBackendStoryObject!: StoryBackendDict;\n  failure: string | null = null;\n\n  async validateExplorationsAsync() {\n    return Promise.resolve('');\n  }\n\n  async fetchStoryAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve({\n          story: this.newBackendStoryObject,\n          topicName: 'Topic Name',\n          storyIsPublished: false,\n          skillSummaries: [{\n            id: 'Skill 1',\n            description: 'Skill Description',\n            language_code: 'en',\n            version: 1,\n            misconception_count: 0,\n            worked_examples_count: 0,\n            skill_model_created_on: 0,\n            skill_model_last_updated: 0,\n          }],\n          classroomUrlFragment: 'classroomUrlFragment',\n          topicUrlFragment: 'topicUrlFragment'\n        });\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async updateStoryAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve(this.newBackendStoryObject);\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async changeStoryPublicationStatusAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        resolve({});\n      } else {\n        reject();\n      }\n    });\n  }\n\n  async doesStoryWithUrlFragmentExistAsync() {\n    return new Promise((resolve, reject) => {\n      if (!this.failure) {\n        console.error('test');\n        resolve(false);\n      } else {\n        reject();\n      }\n    });\n  }\n}\n\ndescribe('Story Editor Page Component', () => {\n  let component: StoryEditorPageComponent;\n  let fixture: ComponentFixture<StoryEditorPageComponent>;\n  let ngbModal: NgbModal;\n  let pageTitleService: PageTitleService;\n  let preventPageUnloadEventService: PreventPageUnloadEventService;\n  let storyEditorStateService: StoryEditorStateService;\n  let undoRedoService: UndoRedoService;\n  let urlInterpolationService: UrlInterpolationService;\n  let localStorageService: LocalStorageService;\n  let storyEditorStalenessDetectionService:\n    StoryEditorStalenessDetectionService;\n  let urlService: UrlService;\n  let storyEditorNavigationService: StoryEditorNavigationService;\n  let story: Story;\n  let windowRef: WindowRef;\n\n  class MockWindowRef {\n    nativeWindow = {\n      open: (url: string) => {},\n      addEventListener: (value1, value2) => {}\n    };\n  }\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [StoryEditorPageComponent],\n      providers: [\n        PageTitleService,\n        PreventPageUnloadEventService,\n        StoryEditorStateService,\n        UndoRedoService,\n        LocalStorageService,\n        StoryEditorStalenessDetectionService,\n        UrlService,\n        UrlInterpolationService,\n        {\n          provide: EditableStoryBackendApiService,\n          useClass: MockEditableStoryBackendApiService\n        },\n        {\n          provide: StoryEditorNavigationService,\n          useClass: MockStoryEditorNavigationService\n        },\n        {\n          provide: WindowRef,\n          useClass: MockWindowRef\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(StoryEditorPageComponent);\n    component = fixture.componentInstance;\n\n    storyEditorNavigationService = TestBed.inject(StoryEditorNavigationService);\n    ngbModal = TestBed.inject(NgbModal);\n    pageTitleService = TestBed.inject(PageTitleService);\n    preventPageUnloadEventService = TestBed.inject(\n      PreventPageUnloadEventService);\n    storyEditorStateService = TestBed.inject(StoryEditorStateService);\n    undoRedoService = TestBed.inject(UndoRedoService);\n    urlService = TestBed.inject(UrlService);\n    urlInterpolationService = TestBed.inject(UrlInterpolationService);\n    localStorageService = TestBed.inject(LocalStorageService);\n    storyEditorStalenessDetectionService = TestBed.inject(\n      StoryEditorStalenessDetectionService);\n    windowRef = TestBed.inject(WindowRef);\n\n    story = Story.createFromBackendDict({\n      id: '2',\n      title: 'Story title',\n      description: 'Story description',\n      notes: 'Story notes',\n      story_contents: {\n        initial_node_id: 'node_2',\n        nodes: [{\n          id: 'node_2',\n          title: 'Title 2',\n          prerequisite_skill_ids: [],\n          acquired_skill_ids: [],\n          destination_node_ids: [],\n          outline: 'Outline',\n          exploration_id: 'asd4242',\n          outline_is_finalized: false,\n          description: 'Description',\n          thumbnail_filename: 'img.png',\n          thumbnail_bg_color: '#a33f40'\n        }, {\n          id: 'node_3',\n          title: 'Title 3',\n          prerequisite_skill_ids: [],\n          acquired_skill_ids: [],\n          destination_node_ids: [],\n          outline: 'Outline',\n          exploration_id: null,\n          outline_is_finalized: false,\n          description: 'Description',\n          thumbnail_filename: 'img.png',\n          thumbnail_bg_color: '#a33f40'\n        }],\n        next_node_id: 'node_4'\n      },\n      language_code: 'en',\n      version: 1,\n      corresponding_topic_id: '2',\n      thumbnail_bg_color: null,\n      thumbnail_filename: null,\n      url_fragment: 'story-url-fragment'\n    } as StoryBackendDict);\n\n    spyOn(storyEditorStateService, 'getStory').and.returnValue(story);\n    localStorageService.removeOpenedEntityEditorBrowserTabsInfo(\n      EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS);\n  });\n\n  afterEach(() => {\n    component.ngOnDestroy();\n  });\n\n  it('should load story based on its id on url when component is initialized' +\n    ' and set page title', () => {\n    let storyInitializedEventEmitter = new EventEmitter();\n    let storyReinitializedEventEmitter = new EventEmitter();\n    spyOn(storyEditorStateService, 'loadStory').and.callFake(() => {\n      storyInitializedEventEmitter.emit();\n      storyReinitializedEventEmitter.emit();\n    });\n    spyOnProperty(\n      storyEditorStateService, 'onStoryInitialized').and.returnValue(\n      storyInitializedEventEmitter);\n    spyOnProperty(\n      storyEditorStateService, 'onStoryReinitialized').and.returnValue(\n      storyReinitializedEventEmitter);\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle').and.callThrough();\n    storyEditorNavigationService\n      .checkIfPresentInChapterEditor = () => true;\n\n    component.ngOnInit();\n\n    expect(storyEditorStateService.loadStory).toHaveBeenCalledWith('story_1');\n    expect(pageTitleService.setDocumentTitle).toHaveBeenCalledTimes(2);\n  });\n\n  it('should addListener by passing getChangeCount to ' +\n  'PreventPageUnloadEventService', () => {\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle');\n    spyOn(undoRedoService, 'getChangeCount').and.returnValue(10);\n    spyOn(preventPageUnloadEventService, 'addListener').and\n      .callFake((callback) => callback());\n\n    component.ngOnInit();\n\n    expect(preventPageUnloadEventService.addListener)\n      .toHaveBeenCalledWith(jasmine.any(Function));\n  });\n\n  it('should return to topic editor page when closing confirmation modal',\n    () => {\n      spyOn(undoRedoService, 'getChangeCount').and.returnValue(1);\n      const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n        return ({\n          componentInstance: MockNgbModalRef,\n          result: Promise.resolve()\n        }) as NgbModalRef;\n      });\n\n      component.returnToTopicEditorPage();\n\n      expect(modalSpy).toHaveBeenCalled();\n    });\n\n  it('should return to topic editor page when dismissing confirmation modal',\n    () => {\n      spyOn(undoRedoService, 'getChangeCount').and.returnValue(1);\n      const modalSpy = spyOn(ngbModal, 'open').and.callFake((dlg, opt) => {\n        return ({\n          componentInstance: MockNgbModalRef,\n          result: Promise.reject()\n        }) as NgbModalRef;\n      });\n\n      component.returnToTopicEditorPage();\n\n      expect(modalSpy).toHaveBeenCalled();\n    });\n\n  it('should open topic editor page when there is no change',\n    fakeAsync(() => {\n      spyOn(undoRedoService, 'getChangeCount').and.returnValue(0);\n      spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('/url');\n      spyOn(windowRef.nativeWindow, 'open');\n\n      component.returnToTopicEditorPage();\n\n      flush();\n      tick();\n\n      expect(windowRef.nativeWindow.open).toHaveBeenCalledWith('/url', '_self');\n    }));\n\n  it('should return the active tab', () => {\n    storyEditorNavigationService.activeTab = 'story_editor';\n    storyEditorNavigationService.getActiveTab = () => 'story_editor';\n\n    storyEditorNavigationService.navigateToStoryEditor();\n\n    expect(component.getActiveTab()).toEqual('story_editor');\n  });\n\n  it('should return warning count', () => {\n    spyOn(storyEditorStateService, 'loadStory').and.stub();\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle').and.callThrough();\n\n    storyEditorNavigationService.navigateToStoryEditor();\n    component.ngOnInit();\n\n    expect(component.getTotalWarningsCount()).toEqual(0);\n  });\n\n  it('should report if story fragment already exists', () => {\n    let storyInitializedEventEmitter = new EventEmitter();\n    let storyReinitializedEventEmitter = new EventEmitter();\n    spyOn(storyEditorStateService, 'loadStory').and.callFake(() => {\n      storyInitializedEventEmitter.emit();\n      storyReinitializedEventEmitter.emit();\n    });\n    spyOnProperty(\n      storyEditorStateService, 'onStoryInitialized').and.returnValue(\n      storyInitializedEventEmitter);\n    spyOnProperty(\n      storyEditorStateService, 'onStoryReinitialized').and.returnValue(\n      storyReinitializedEventEmitter);\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle').and.callThrough();\n    spyOn(\n      storyEditorStateService,\n      'getStoryWithUrlFragmentExists').and.returnValue(true);\n    spyOn(storyEditorStateService, 'getSkillSummaries').and.returnValue([{\n      id: 'skill_id'\n    }]);\n    storyEditorNavigationService.checkIfPresentInChapterEditor = () => true;\n\n    component.ngOnInit();\n\n    expect(component.validationIssues).toEqual(\n      ['Story URL fragment already exists.']);\n  });\n\n  it('should toggle the display of warnings', () => {\n    component.isWarningsAreShown(true);\n\n    expect(component.warningsAreShown).toEqual(true);\n\n    component.isWarningsAreShown(false);\n\n    expect(component.warningsAreShown).toEqual(false);\n\n    component.isWarningsAreShown(true);\n\n    expect(component.warningsAreShown).toEqual(true);\n  });\n\n  it('should return true if the main editor tab is select', fakeAsync(() => {\n    storyEditorNavigationService.activeTab = 'story_editor';\n    tick();\n    expect(component.isMainEditorTabSelected()).toEqual(true);\n\n    storyEditorNavigationService.activeTab = 'story_preview';\n    tick();\n    expect(component.isMainEditorTabSelected()).toEqual(false);\n  }));\n\n  it('should check if url contains story preview', fakeAsync(() => {\n    spyOn(storyEditorStateService, 'loadStory').and.stub();\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle').and.callThrough();\n    storyEditorNavigationService.activeTab = 'story_preview';\n    storyEditorNavigationService.checkIfPresentInChapterEditor = (\n      () => false);\n    storyEditorNavigationService.checkIfPresentInStoryPreviewTab = (\n      () => true);\n    storyEditorNavigationService.getActiveTab = (\n      () => 'story_preview');\n\n    component.ngOnInit();\n    tick();\n\n    expect(component.isMainEditorTabSelected()).toEqual(false);\n\n    storyEditorNavigationService.activeTab = 'story_editor';\n    storyEditorNavigationService.getActiveTab = () => 'story_editor';\n  }));\n\n  it('should navigate to story editor', () => {\n    storyEditorNavigationService.activeTab = 'story_editor';\n    storyEditorNavigationService.getActiveTab = () => 'story_editor';\n\n    component.navigateToStoryEditor();\n\n    expect(component.getActiveTab()).toEqual('story_editor');\n  });\n\n  it('should navigate to story preview tab', () => {\n    storyEditorNavigationService.activeTab = 'story_preview';\n    storyEditorNavigationService.getActiveTab = () => 'story_preview';\n\n    component.navigateToStoryPreviewTab();\n\n    expect(component.getActiveTab()).toEqual('story_preview');\n  });\n\n  it('should return the navbar helper text', fakeAsync(() => {\n    storyEditorNavigationService.activeTab = 'chapter_editor';\n    tick();\n    expect(component.getNavbarText()).toEqual('Chapter Editor');\n\n    storyEditorNavigationService.activeTab = 'story_preview';\n    tick();\n    expect(component.getNavbarText()).toEqual('Story Preview');\n\n    storyEditorNavigationService.activeTab = 'story_editor';\n    tick();\n    expect(component.getNavbarText()).toEqual('Story Editor');\n  }));\n\n  it('should init page on undo redo change applied', () => {\n    let mockUndoRedoChangeEventEmitter = new EventEmitter();\n    spyOn(undoRedoService, 'getUndoRedoChangeEventEmitter')\n      .and.returnValue(\n        mockUndoRedoChangeEventEmitter);\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle');\n\n    component.ngOnInit();\n    mockUndoRedoChangeEventEmitter.emit();\n\n    expect(pageTitleService.setDocumentTitle).toHaveBeenCalled();\n  });\n\n  it('should create story editor browser tabs info on ' +\n  'local storage when a new tab opens', () => {\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle');\n    component.ngOnInit();\n\n    let storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo).toBeNull();\n\n    // Opening the first tab.\n    storyEditorStateService.onStoryInitialized.emit();\n    storyEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo).toBeDefined();\n    expect(storyEditorBrowserTabsInfo.getNumberOfOpenedTabs()).toEqual(1);\n\n    // Opening the second tab.\n    storyEditorStateService.onStoryInitialized.emit();\n    storyEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo.getNumberOfOpenedTabs()).toEqual(2);\n  });\n\n  it('should update story editor browser tabs info on local storage when ' +\n  'some new changes are saved', () => {\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle');\n    component.ngOnInit();\n\n    let storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo).toBeNull();\n\n    // First time opening of the tab.\n    storyEditorStateService.onStoryInitialized.emit();\n    storyEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo.getLatestVersion()).toEqual(1);\n\n    // Save some changes on the story and increasing its version.\n    story._version = 2;\n    storyEditorStateService.onStoryReinitialized.emit();\n    storyEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo.getLatestVersion()).toEqual(2);\n  });\n\n  it('should decrement number of opened story editor tabs when ' +\n  'a tab is closed', () => {\n    spyOn(undoRedoService, 'getChangeCount').and.returnValue(1);\n    spyOn(urlService, 'getStoryIdFromUrl').and.returnValue('story_1');\n    spyOn(pageTitleService, 'setDocumentTitle');\n    component.ngOnInit();\n\n    // Opening of the first tab.\n    storyEditorStateService.onStoryInitialized.emit();\n    // Opening of the second tab.\n    storyEditorStateService.onStoryInitialized.emit();\n\n    let storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    // Making some unsaved changes on the editor page.\n    storyEditorBrowserTabsInfo.setSomeTabHasUnsavedChanges(true);\n    localStorageService.updateEntityEditorBrowserTabsInfo(\n      storyEditorBrowserTabsInfo, EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS);\n\n    expect(\n      storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges()\n    ).toBeTrue();\n    expect(storyEditorBrowserTabsInfo.getNumberOfOpenedTabs()).toEqual(2);\n\n    component.onClosingStoryEditorBrowserTab();\n    storyEditorBrowserTabsInfo = (\n      localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    expect(storyEditorBrowserTabsInfo.getNumberOfOpenedTabs()).toEqual(1);\n\n    // Since the tab containing unsaved changes is closed, the value of\n    // unsaved changes status will become false.\n    expect(\n      storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges()\n    ).toBeFalse();\n  });\n\n  it('should emit the stale tab and presence of unsaved changes events ' +\n  'when the \\'storage\\' event is triggered', () => {\n    spyOn(\n      storyEditorStalenessDetectionService.staleTabEventEmitter, 'emit'\n    ).and.callThrough();\n    spyOn(\n      storyEditorStalenessDetectionService\n        .presenceOfUnsavedChangesEventEmitter, 'emit'\n    ).and.callThrough();\n\n    component.onCreateOrUpdateStoryEditorBrowserTabsInfo(\n      {key: 'opened_story_editor_browser_tabs'});\n\n    expect(\n      storyEditorStalenessDetectionService.staleTabEventEmitter.emit\n    ).toHaveBeenCalled();\n    expect(\n      storyEditorStalenessDetectionService\n        .presenceOfUnsavedChangesEventEmitter.emit\n    ).toHaveBeenCalled();\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/story-editor-page.component.ts",
      "content": "// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the story editor page.\n */\n\nimport { Subscription } from 'rxjs';\nimport { SavePendingChangesModalComponent } from 'components/save-pending-changes/save-pending-changes-modal.component';\nimport { EntityEditorBrowserTabsInfo } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info.model';\nimport { EntityEditorBrowserTabsInfoDomainConstants } from 'domain/entity_editor_browser_tabs_info/entity-editor-browser-tabs-info-domain.constants';\nimport { Component, OnDestroy, OnInit } from '@angular/core';\nimport { AppConstants } from 'app.constants';\nimport { UndoRedoService } from 'domain/editor/undo_redo/undo-redo.service';\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\nimport { WindowRef } from 'services/contextual/window-ref.service';\nimport { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';\nimport { StoryEditorStateService } from './services/story-editor-state.service';\nimport { PageTitleService } from 'services/page-title.service';\nimport { StoryEditorNavigationService } from './services/story-editor-navigation.service';\nimport { LocalStorageService } from 'services/local-storage.service';\nimport { LoaderService } from 'services/loader.service';\nimport { StoryValidationService } from 'domain/story/story-validation.service';\nimport { EditableStoryBackendApiService } from 'domain/story/editable-story-backend-api.service';\nimport { StoryEditorStalenessDetectionService } from './services/story-editor-staleness-detection.service';\nimport { BottomNavbarStatusService } from 'services/bottom-navbar-status.service';\nimport { PreventPageUnloadEventService } from 'services/prevent-page-unload-event.service';\nimport { UrlService } from 'services/contextual/url.service';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { Story } from 'domain/story/story.model';\n\n@Component({\n  selector: 'oppia-story-editor-page',\n  templateUrl: './story-editor-page.component.html'\n})\nexport class StoryEditorPageComponent implements OnInit, OnDestroy {\n  warningsAreShown: boolean;\n  validationIssues: string[];\n  story: Story;\n  prepublishValidationIssues: string[];\n  forceValidateExplorations: boolean;\n  explorationValidationIssues: string[];\n\n  constructor(\n    private undoRedoService: UndoRedoService,\n    private ngbModal: NgbModal,\n    private windowRef: WindowRef,\n    private urlInterpolationService: UrlInterpolationService,\n    private storyEditorStateService: StoryEditorStateService,\n    private pageTitleService: PageTitleService,\n    private storyEditorNavigationService: StoryEditorNavigationService,\n    private localStorageService: LocalStorageService,\n    private loaderService: LoaderService,\n    private storyValidationService: StoryValidationService,\n    private editableStoryBackendApiService: EditableStoryBackendApiService,\n    private storyEditorStalenessDetectionService:\n      StoryEditorStalenessDetectionService,\n    private bottomNavbarStatusService: BottomNavbarStatusService,\n    private preventPageUnloadEventService: PreventPageUnloadEventService,\n    private urlService: UrlService\n  ) {}\n\n  directiveSubscriptions = new Subscription();\n\n  MAX_COMMIT_MESSAGE_LENGTH = AppConstants.MAX_COMMIT_MESSAGE_LENGTH;\n\n  TOPIC_EDITOR_URL_TEMPLATE = '/topic_editor/<topicId>';\n\n  returnToTopicEditorPage(): void {\n    if (this.undoRedoService.getChangeCount() > 0) {\n      const modalRef = this.ngbModal.open(\n        SavePendingChangesModalComponent, {\n          backdrop: true\n        });\n\n      modalRef.componentInstance.body = (\n        'Please save all pending changes before returning to the topic.');\n\n      modalRef.result.then(() => {}, () => {\n        // Note to developers:\n        // This callback is triggered when the Cancel button is clicked.\n        // No further action is needed.\n      });\n    } else {\n      this.windowRef.nativeWindow.open(\n        this.urlInterpolationService.interpolateUrl(\n          this.TOPIC_EDITOR_URL_TEMPLATE, {\n            topicId:\n              this.storyEditorStateService.\n                getStory().getCorrespondingTopicId()\n          }\n        ), '_self');\n    }\n  }\n\n  setDocumentTitle(): void {\n    this.pageTitleService.setDocumentTitle(\n      this.storyEditorStateService.getStory().getTitle() + ' - Oppia');\n    this.pageTitleService.setNavbarSubtitleForMobileView(\n      this.storyEditorStateService.getStory().getTitle());\n  }\n\n  getActiveTab(): string {\n    return this.storyEditorNavigationService.getActiveTab();\n  }\n\n  getNavbarText(): string {\n    const activeTab = this.storyEditorNavigationService.getActiveTab();\n    if (activeTab === 'story_editor') {\n      return 'Story Editor';\n    } else if (activeTab === 'story_preview') {\n      return 'Story Preview';\n    } else if (activeTab === 'chapter_editor') {\n      return 'Chapter Editor';\n    }\n  }\n\n  isWarningsAreShown(value: boolean): void {\n    this.warningsAreShown = value;\n  }\n\n  isMainEditorTabSelected(): boolean {\n    const activeTab = this.storyEditorNavigationService.getActiveTab();\n    return activeTab === 'story_editor' || activeTab === 'chapter_editor';\n  }\n\n  _validateStory(): void {\n    this.validationIssues = this.story.validate();\n    let nodes = this.story.getStoryContents().getNodes();\n    let skillIdsInTopic = this.storyEditorStateService.getSkillSummaries().map(\n      skill => skill.id);\n    if (this.validationIssues.length === 0 && nodes.length > 0) {\n      let prerequisiteSkillValidationIssues = (\n        this.storyValidationService.validatePrerequisiteSkillsInStoryContents(\n          skillIdsInTopic, this.story.getStoryContents()));\n      this.validationIssues = (\n        this.validationIssues.concat(prerequisiteSkillValidationIssues));\n    }\n    if (this.storyEditorStateService.getStoryWithUrlFragmentExists()) {\n      this.validationIssues.push(\n        'Story URL fragment already exists.');\n    }\n    this._validateExplorations();\n    let storyPrepublishValidationIssues = (\n      this.story.prepublishValidate());\n    let nodePrepublishValidationIssues = (\n      [].concat.apply([], nodes.map(\n        (node) => node.prepublishValidate())));\n    this.prepublishValidationIssues = (\n      storyPrepublishValidationIssues.concat(\n        nodePrepublishValidationIssues));\n  }\n\n  _validateExplorations(): void {\n    let nodes = this.story.getStoryContents().getNodes();\n    let explorationIds = [];\n\n    if (\n      this.storyEditorStateService.areAnyExpIdsChanged() ||\n        this.forceValidateExplorations) {\n      this.explorationValidationIssues = [];\n      for (let i = 0; i < nodes.length; i++) {\n        if (nodes[i].getExplorationId() !== null) {\n          explorationIds.push(nodes[i].getExplorationId());\n        } else {\n          this.explorationValidationIssues.push(\n            'Some chapters don\\'t have exploration IDs provided.');\n        }\n      }\n      this.forceValidateExplorations = false;\n      if (explorationIds.length > 0) {\n        this.editableStoryBackendApiService.validateExplorationsAsync(\n          this.story.getId(), explorationIds\n        ).then((validationIssues) => {\n          this.explorationValidationIssues =\n              this.explorationValidationIssues.concat(validationIssues);\n        });\n      }\n    }\n    this.storyEditorStateService.resetExpIdsChanged();\n  }\n\n  getTotalWarningsCount(): number {\n    return (\n      this.validationIssues.length +\n        this.explorationValidationIssues.length +\n        this.prepublishValidationIssues.length);\n  }\n\n  _initPage(): void {\n    this.story = this.storyEditorStateService.getStory();\n    this.setDocumentTitle();\n    this._validateStory();\n  }\n\n  navigateToStoryPreviewTab(): void {\n    this.storyEditorNavigationService.navigateToStoryPreviewTab();\n  }\n\n  navigateToStoryEditor(): void {\n    this.storyEditorNavigationService.navigateToStoryEditor();\n  }\n\n  onClosingStoryEditorBrowserTab(): void {\n    const story = this.storyEditorStateService.getStory();\n\n    const storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      this.localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    if (storyEditorBrowserTabsInfo.doesSomeTabHaveUnsavedChanges() &&\n        this.undoRedoService.getChangeCount() > 0) {\n      storyEditorBrowserTabsInfo.setSomeTabHasUnsavedChanges(false);\n    }\n    storyEditorBrowserTabsInfo.decrementNumberOfOpenedTabs();\n\n    this.localStorageService.updateEntityEditorBrowserTabsInfo(\n      storyEditorBrowserTabsInfo,\n      EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS);\n  }\n\n  createStoryEditorBrowserTabsInfo(): void {\n    const story = this.storyEditorStateService.getStory();\n\n    let storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      this.localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    if (storyEditorBrowserTabsInfo) {\n      storyEditorBrowserTabsInfo.setLatestVersion(story.getVersion());\n      storyEditorBrowserTabsInfo.incrementNumberOfOpenedTabs();\n    } else {\n      storyEditorBrowserTabsInfo = EntityEditorBrowserTabsInfo.create(\n        'story', story.getId(), story.getVersion(), 1, false);\n    }\n\n    this.localStorageService.updateEntityEditorBrowserTabsInfo(\n      storyEditorBrowserTabsInfo,\n      EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS);\n  }\n\n  updateStoryEditorBrowserTabsInfo(): void {\n    const story = this.storyEditorStateService.getStory();\n\n    const storyEditorBrowserTabsInfo: EntityEditorBrowserTabsInfo = (\n      this.localStorageService.getEntityEditorBrowserTabsInfo(\n        EntityEditorBrowserTabsInfoDomainConstants\n          .OPENED_STORY_EDITOR_BROWSER_TABS, story.getId()));\n\n    storyEditorBrowserTabsInfo.setLatestVersion(story.getVersion());\n    storyEditorBrowserTabsInfo.setSomeTabHasUnsavedChanges(false);\n\n    this.localStorageService.updateEntityEditorBrowserTabsInfo(\n      storyEditorBrowserTabsInfo,\n      EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS);\n  }\n\n  onCreateOrUpdateStoryEditorBrowserTabsInfo(event: { key: string }): void {\n    if (event.key === (\n      EntityEditorBrowserTabsInfoDomainConstants\n        .OPENED_STORY_EDITOR_BROWSER_TABS)\n    ) {\n      this.storyEditorStalenessDetectionService\n        .staleTabEventEmitter.emit();\n      this.storyEditorStalenessDetectionService\n        .presenceOfUnsavedChangesEventEmitter.emit();\n    }\n  }\n\n  ngOnInit(): void {\n    this.loaderService.showLoadingScreen('Loading Story');\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryInitialized.subscribe(\n        () => {\n          this._initPage();\n          this.createStoryEditorBrowserTabsInfo();\n          this.loaderService.hideLoadingScreen();\n        }\n      ));\n    this.directiveSubscriptions.add(\n      this.storyEditorStateService.onStoryReinitialized.subscribe(\n        () => {\n          this._initPage();\n          this.updateStoryEditorBrowserTabsInfo();\n        }\n      ));\n    this.validationIssues = [];\n    this.prepublishValidationIssues = [];\n    this.explorationValidationIssues = [];\n    this.forceValidateExplorations = true;\n    this.warningsAreShown = false;\n    this.bottomNavbarStatusService.markBottomNavbarStatus(true);\n    this.preventPageUnloadEventService.addListener(\n      this.undoRedoService.getChangeCount.bind(this.undoRedoService));\n    this.storyEditorStateService.loadStory(this.urlService.getStoryIdFromUrl());\n    this.story = this.storyEditorStateService.getStory();\n\n    this.pageTitleService.setNavbarTitleForMobileView('Story Editor');\n\n    if (this.storyEditorNavigationService.checkIfPresentInChapterEditor()) {\n      this.storyEditorNavigationService.navigateToChapterEditor();\n    } else if (\n      this.storyEditorNavigationService.checkIfPresentInStoryPreviewTab()) {\n      this.storyEditorNavigationService.navigateToStoryPreviewTab();\n    }\n    this.directiveSubscriptions.add(\n      this.undoRedoService.getUndoRedoChangeEventEmitter().subscribe(\n        () => this._initPage()\n      )\n    );\n\n    this.storyEditorStalenessDetectionService.init();\n    this.windowRef.nativeWindow.addEventListener(\n      'beforeunload', this.onClosingStoryEditorBrowserTab);\n    this.localStorageService.registerNewStorageEventListener(\n      this.onCreateOrUpdateStoryEditorBrowserTabsInfo);\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n}\n\nangular.module('oppia').directive('oppiaStoryEditorPage', downgradeComponent({\n  component: StoryEditorPageComponent\n}));\n"
    },
    {
      "filename": "core/templates/pages/story-editor-page/story-editor-page.mainpage.html",
      "content": "<!DOCTYPE html>\n<html ng-app=\"oppia\" itemscope itemtype=\"http://schema.org/Organization\">\n  <head>\n    @load('base-components/header.template.html', {\"title\": \"Oppia\"})\n  </head>\n\n  <body>\n    <oppia-root>\n      <div ng-controller=\"Base\">\n        <oppia-base-content>\n          <navbar-breadcrumb>\n            <oppia-story-editor-navbar-breadcrumb>\n            </oppia-story-editor-navbar-breadcrumb>\n          </navbar-breadcrumb>\n\n          <nav-options>\n            <oppia-story-editor-navbar>\n            </oppia-story-editor-navbar>\n          </nav-options>\n\n          <mobile-nav-options>\n            <oppia-story-editor-navbar>\n            </oppia-story-editor-navbar>\n          </mobile-nav-options>\n\n          <content>\n            <oppia-story-editor-page></oppia-story-editor-page>\n          </content>\n\n          <page-footer></page-footer>\n        </oppia-base-content>\n      </div>\n\n    </oppia-root>\n    @load('pages/footer_js_libs.html')\n    <script src=\"/third_party/static/MathJax-2.7.5/MathJax.js?config=default\"></script>\n\n  </body>\n</html>\n"
    }
  ]
}