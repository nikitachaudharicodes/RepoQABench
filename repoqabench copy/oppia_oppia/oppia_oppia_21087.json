{
  "repo_name": "oppia_oppia",
  "issue_id": "21087",
  "issue_description": "# [BUG]: Removing picture is allowed when reviewing translation\n\n### Describe the bug\r\n\r\nRemoving picture is allowed when reviewing translation\r\nWhen submitting translation, users are required to keep the original picture in their translation, however, when reviewers edit the transition, they can remove the picture and no error will appear\r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/contributor-dashboard\r\n\r\n### Steps To Reproduce\r\n\r\n**Preconditions:**\r\nuser has to have translation reviewer permissions, a translation with picture is submitted to review\r\n\r\n- Steps:\r\n\r\n1. Log in to Oppia as a Contributor\r\n2. Navigate to Contributor dashboard\r\n3. Select Review Translation Tab\r\n4. Open a translation to review (with picture)\r\n5. Click \"Edit\"\r\n6. Remove picture\r\n7. Click \"Update\"\r\n8. Click \"Accept and review next\"\r\n\r\n\r\n### Expected Behavior\r\n\r\nError message should appear saying that removing picture is not allowed\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/user-attachments/assets/38641e4f-5d02-4c1a-93ca-a3948f305362\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome, Firefox\r\n\r\n### Browser version\r\n\r\nChrome 126.0.6478.57, Firefox 127.0\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n",
  "issue_comments": [
    {
      "id": 2413457577,
      "user": "sksingh2005",
      "body": "Is  this issue open?\r\nI would like to work on this issue "
    },
    {
      "id": 2413933347,
      "user": "HardikGoyal2003",
      "body": "Hey @sksingh2005 This issue is open to work but as per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 2417044756,
      "user": "sahilkumar100",
      "body": "I Want to work on this issues please assign me this issues."
    },
    {
      "id": 2417101365,
      "user": "mon4our",
      "body": "Hey @sahilkumar100  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 2422874049,
      "user": "Kanav-1822",
      "body": "Hey @mon4our  , @HardikGoyal2003 can you please guide how can I as user have translation reviewer permissions , as it is one of the precondition\r\n\r\n"
    },
    {
      "id": 2424673357,
      "user": "Devil1104",
      "body": "\r\nI've seen the issue, but edit option is not available in on the page now. I hope you have removed it.\r\n![Screenshot 2024-10-20 121511](https://github.com/user-attachments/assets/d92acbfc-a8de-43d6-a258-3f273784f5b5)\r\n\r\n\r\nApproach- 1\r\nTo solve the issue, my approach would be to  set the image option default to the image in the to be translated section, and if there's no image added then the default image would be displayed.\r\n\r\nApproach -2\r\nIf the user adds a image and removes it in the edit tab then the edit tab would produce an alert to add the image, and the edit option would not work until the image is added.\r\n\r\n"
    },
    {
      "id": 2425521712,
      "user": "HardikGoyal2003",
      "body": "@masterboy376 PTAL!! Thanks!"
    },
    {
      "id": 2425657691,
      "user": "Devil1104",
      "body": "> @masterboy376 PTAL!! Thanks!\r\n\r\nMay I get the issue to solve?"
    },
    {
      "id": 2426175434,
      "user": "masterboy376",
      "body": "Hey @Devil1104, from the screenshot you provided above it seems like you are viewing the translation suggestion, as a submitter. Edit options only show up during translation review, by translation reviewer. You can try to reproduce the error locally.\r\n![Screenshot (233)](https://github.com/user-attachments/assets/1217e7a9-72d7-41f3-98e0-3d1b13cebd09)\r\n\r\nAlso, could you please elaborate on the approach you are willing to choose. Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue."
    },
    {
      "id": 2451283911,
      "user": "masterboy376",
      "body": "Steps to reproduce:\r\n1. login as an admin user let us call it \"a\",\r\n2. go to roll tab in admin page and give \"a\" curriculum admin and translation admin roll.\r\n3. go to activities tab and generate dummy topic.\r\n4. go to rolls tab and give \"a\" topic editor role for recently generated dummy topic.\r\n5. now go to creator dashboard and create an exploration with an image and copy it is.\r\n6. now go to topic and skill dashboard.\r\n7. open generated dummy topic.\r\n8. create a new story in it and a lesson inside this story, add the exploration id to the lesson, and the publish/save the story.\r\n9. logout as \"a\".\r\n10. login as a user \"u\".\r\n11. go to contributor dashboard and submit a translation suggestion, in Akan language, for the lesson you added previously.\r\n12. now logout as \"u\".\r\n13. login as \"a\".\r\n14. go to contributor admin dashboard and give \"a\" translation reviewer right in Akan language.\r\n15. go to contributor dashboard and translation reviews tab and select Akan language in language drop down.\r\n16. try to review the translation suggestion review which has an image.\r\n17. while reviewing click the edit button.\r\n18. now remove the image and click save. (this is the issue)"
    },
    {
      "id": 2452409490,
      "user": "TARishabh",
      "body": "Thanks @masterboy376 for the steps. I reproduced the steps. Here are a few possible approaches we could consider:\r\n\r\n**1.** **Disable the Save/Update Button:**\r\n\r\n  - Approach: If the reviewer removes the image, we keep the \"Save/Update\" button disabled.\r\n  - Pros: Gives immediate feedback to the reviewer without backend calls\r\n  - Cons: It may not clearly communicate why the button is disabled, so additional hints in the UI might be helpful.\r\n  \r\n **2.** **Show an Error Modal Prompt on Save:**\r\n\r\n-  Approach: When the reviewer tries to save without an image, a modal appears explaining that removing the image is not allowed.\r\n- Pros: Clearly informs the reviewer why saving isn’t possible without an image.\r\n- Cons: Adds an extra step but provides clarity on the issue.\r\n\r\n**3.** **Backend Validation with Error Message:**\r\n\r\n- Approach: If the reviewer submits the edit without an image, the backend responds with an error message indicating that the image is required.\r\n- Pros: Ensures validation happens server-side, which helps keep things consistent if frontend constraints are bypassed.\r\n- Cons: May lead to a slower response as feedback only appears after submission.\r\n\r\n**4. Automatic Placeholder Enforcement:**\r\n\r\n- Approach: If the image is removed, automatically replace it with a default image.\r\n- Pros: Keeps submissions consistent without needing reviewer action.\r\n- Cons: Could lead to confusion if reviewers aren’t aware why a placeholder is used.\r\n\r\n**5. Warning Tooltip/Message:**\r\n\r\n- Approach: Display a tooltip or warning message in the editor if the image is removed, reminding reviewers that the image is required.\r\n- Pros: Non-intrusive and provides immediate feedback.\r\n- Cons: Relies on the reviewer noticing the warning.\r\n\r\ncc - @masterboy376 \r\n\r\n\r\n\r\n"
    },
    {
      "id": 2452988490,
      "user": "masterboy376",
      "body": "Thanks @TARishabh, \nI would have preferred approach 1 since it is less invasive and it can also clearly convey the issue to the suggestion editors, given we show a clear message in red to the users along with a disabled save button. \nAlso, I am not really sure how approach 4 will look in practice, is it like the editor deletes the image and  saves but actually the image was not deleted. In this case it might give a false assurance to the editor that he/she successfully deleted the image. \nWe can also think about the backend validation, but we need to verify whether we use backend validation in such scenarios somewhere in the codebase or not. \n\nIn conclusion, we can use either the approach 1 or 3 based on what we already prefer to use in the codebase. So, it would be great if you could take a look into it. "
    },
    {
      "id": 2463153500,
      "user": "TARishabh",
      "body": "Thanks for sharing your thoughts, @masterboy376! I agree that approach 1 makes the most sense—disabling the button with a clear red message would give reviewers immediate feedback without being too intrusive.\r\n\r\nI'll also take a look into whether we use backend validation (approach 3) in similar cases, as it could be useful to have that extra safety net.\r\n\r\nFor now, I'll start by working on approach 1 and keep approach 3 as a backup, depending on what I find. Let me know if you have any other suggestions!\""
    },
    {
      "id": 2464349418,
      "user": "seanlip",
      "body": "Just a note, generally we try to have both frontend and backend validation for something like this. The frontend validation is so that the user experience is smooth (it is a bit jarring to get everything ready for the backend and only then learn that the submission is not valid) and the backend validation is for defense-in-depth. So I would recommend doing both, with the priority being approach 1."
    },
    {
      "id": 2523898488,
      "user": "yuanzhew-um",
      "body": "@seanlip Hi, Is this issue still open? Can I work on this?"
    },
    {
      "id": 2525718852,
      "user": "masterboy376",
      "body": "Hey @yuanzhew-um, this issue is already assigned. You can try to find other issues. Thanks!\r\n"
    },
    {
      "id": 2692127958,
      "user": "ShivankXD",
      "body": "Hi ! is this issue still open?"
    },
    {
      "id": 2692151285,
      "user": "masterboy376",
      "body": "Hey @ShivankXD, this issue is already assigned. You can try to find other issues that are available. Thanks!"
    },
    {
      "id": 2816513217,
      "user": "masterboy376",
      "body": "closing as completed https://github.com/oppia/oppia/pull/21241"
    }
  ],
  "text_context": "# [BUG]: Removing picture is allowed when reviewing translation\n\n### Describe the bug\r\n\r\nRemoving picture is allowed when reviewing translation\r\nWhen submitting translation, users are required to keep the original picture in their translation, however, when reviewers edit the transition, they can remove the picture and no error will appear\r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/contributor-dashboard\r\n\r\n### Steps To Reproduce\r\n\r\n**Preconditions:**\r\nuser has to have translation reviewer permissions, a translation with picture is submitted to review\r\n\r\n- Steps:\r\n\r\n1. Log in to Oppia as a Contributor\r\n2. Navigate to Contributor dashboard\r\n3. Select Review Translation Tab\r\n4. Open a translation to review (with picture)\r\n5. Click \"Edit\"\r\n6. Remove picture\r\n7. Click \"Update\"\r\n8. Click \"Accept and review next\"\r\n\r\n\r\n### Expected Behavior\r\n\r\nError message should appear saying that removing picture is not allowed\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/user-attachments/assets/38641e4f-5d02-4c1a-93ca-a3948f305362\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome, Firefox\r\n\r\n### Browser version\r\n\r\nChrome 126.0.6478.57, Firefox 127.0\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n\n\nIs  this issue open?\r\nI would like to work on this issue \n\nHey @sksingh2005 This issue is open to work but as per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nI Want to work on this issues please assign me this issues.\n\nHey @sahilkumar100  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nHey @mon4our  , @HardikGoyal2003 can you please guide how can I as user have translation reviewer permissions , as it is one of the precondition\r\n\r\n\n\n\r\nI've seen the issue, but edit option is not available in on the page now. I hope you have removed it.\r\n![Screenshot 2024-10-20 121511](https://github.com/user-attachments/assets/d92acbfc-a8de-43d6-a258-3f273784f5b5)\r\n\r\n\r\nApproach- 1\r\nTo solve the issue, my approach would be to  set the image option default to the image in the to be translated section, and if there's no image added then the default image would be displayed.\r\n\r\nApproach -2\r\nIf the user adds a image and removes it in the edit tab then the edit tab would produce an alert to add the image, and the edit option would not work until the image is added.\r\n\r\n\n\n@masterboy376 PTAL!! Thanks!\n\n> @masterboy376 PTAL!! Thanks!\r\n\r\nMay I get the issue to solve?\n\nHey @Devil1104, from the screenshot you provided above it seems like you are viewing the translation suggestion, as a submitter. Edit options only show up during translation review, by translation reviewer. You can try to reproduce the error locally.\r\n![Screenshot (233)](https://github.com/user-attachments/assets/1217e7a9-72d7-41f3-98e0-3d1b13cebd09)\r\n\r\nAlso, could you please elaborate on the approach you are willing to choose. Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\n\nSteps to reproduce:\r\n1. login as an admin user let us call it \"a\",\r\n2. go to roll tab in admin page and give \"a\" curriculum admin and translation admin roll.\r\n3. go to activities tab and generate dummy topic.\r\n4. go to rolls tab and give \"a\" topic editor role for recently generated dummy topic.\r\n5. now go to creator dashboard and create an exploration with an image and copy it is.\r\n6. now go to topic and skill dashboard.\r\n7. open generated dummy topic.\r\n8. create a new story in it and a lesson inside this story, add the exploration id to the lesson, and the publish/save the story.\r\n9. logout as \"a\".\r\n10. login as a user \"u\".\r\n11. go to contributor dashboard and submit a translation suggestion, in Akan language, for the lesson you added previously.\r\n12. now logout as \"u\".\r\n13. login as \"a\".\r\n14. go to contributor admin dashboard and give \"a\" translation reviewer right in Akan language.\r\n15. go to contributor dashboard and translation reviews tab and select Akan language in language drop down.\r\n16. try to review the translation suggestion review which has an image.\r\n17. while reviewing click the edit button.\r\n18. now remove the image and click save. (this is the issue)\n\nThanks @masterboy376 for the steps. I reproduced the steps. Here are a few possible approaches we could consider:\r\n\r\n**1.** **Disable the Save/Update Button:**\r\n\r\n  - Approach: If the reviewer removes the image, we keep the \"Save/Update\" button disabled.\r\n  - Pros: Gives immediate feedback to the reviewer without backend calls\r\n  - Cons: It may not clearly communicate why the button is disabled, so additional hints in the UI might be helpful.\r\n  \r\n **2.** **Show an Error Modal Prompt on Save:**\r\n\r\n-  Approach: When the reviewer tries to save without an image, a modal appears explaining that removing the image is not allowed.\r\n- Pros: Clearly informs the reviewer why saving isn’t possible without an image.\r\n- Cons: Adds an extra step but provides clarity on the issue.\r\n\r\n**3.** **Backend Validation with Error Message:**\r\n\r\n- Approach: If the reviewer submits the edit without an image, the backend responds with an error message indicating that the image is required.\r\n- Pros: Ensures validation happens server-side, which helps keep things consistent if frontend constraints are bypassed.\r\n- Cons: May lead to a slower response as feedback only appears after submission.\r\n\r\n**4. Automatic Placeholder Enforcement:**\r\n\r\n- Approach: If the image is removed, automatically replace it with a default image.\r\n- Pros: Keeps submissions consistent without needing reviewer action.\r\n- Cons: Could lead to confusion if reviewers aren’t aware why a placeholder is used.\r\n\r\n**5. Warning Tooltip/Message:**\r\n\r\n- Approach: Display a tooltip or warning message in the editor if the image is removed, reminding reviewers that the image is required.\r\n- Pros: Non-intrusive and provides immediate feedback.\r\n- Cons: Relies on the reviewer noticing the warning.\r\n\r\ncc - @masterboy376 \r\n\r\n\r\n\r\n\n\nThanks @TARishabh, \nI would have preferred approach 1 since it is less invasive and it can also clearly convey the issue to the suggestion editors, given we show a clear message in red to the users along with a disabled save button. \nAlso, I am not really sure how approach 4 will look in practice, is it like the editor deletes the image and  saves but actually the image was not deleted. In this case it might give a false assurance to the editor that he/she successfully deleted the image. \nWe can also think about the backend validation, but we need to verify whether we use backend validation in such scenarios somewhere in the codebase or not. \n\nIn conclusion, we can use either the approach 1 or 3 based on what we already prefer to use in the codebase. So, it would be great if you could take a look into it. \n\nThanks for sharing your thoughts, @masterboy376! I agree that approach 1 makes the most sense—disabling the button with a clear red message would give reviewers immediate feedback without being too intrusive.\r\n\r\nI'll also take a look into whether we use backend validation (approach 3) in similar cases, as it could be useful to have that extra safety net.\r\n\r\nFor now, I'll start by working on approach 1 and keep approach 3 as a backup, depending on what I find. Let me know if you have any other suggestions!\"\n\nJust a note, generally we try to have both frontend and backend validation for something like this. The frontend validation is so that the user experience is smooth (it is a bit jarring to get everything ready for the backend and only then learn that the submission is not valid) and the backend validation is for defense-in-depth. So I would recommend doing both, with the priority being approach 1.\n\n@seanlip Hi, Is this issue still open? Can I work on this?\n\nHey @yuanzhew-um, this issue is already assigned. You can try to find other issues. Thanks!\r\n\n\nHi ! is this issue still open?\n\nHey @ShivankXD, this issue is already assigned. You can try to find other issues that are available. Thanks!\n\nclosing as completed https://github.com/oppia/oppia/pull/21241",
  "pr_link": "https://github.com/oppia/oppia/pull/21241",
  "code_context": [
    {
      "filename": "core/domain/suggestion_services.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Funtions to create, accept, reject, update and perform other operations on\nsuggestions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport heapq\nimport logging\nimport re\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import contribution_stats_services\nfrom core.domain import email_manager\nfrom core.domain import exp_fetchers\nfrom core.domain import feedback_services\nfrom core.domain import html_cleaner\nfrom core.domain import html_validation_service\nfrom core.domain import opportunity_services\nfrom core.domain import question_domain\nfrom core.domain import rte_component_registry\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import suggestion_registry\nfrom core.domain import taskqueue_services\nfrom core.domain import translation_domain\nfrom core.domain import user_domain\nfrom core.domain import user_services\nfrom core.platform import models\n\nimport bs4\nfrom typing import (\n    Callable, Dict, Final, List, Literal, Mapping, Match,\n    Optional, Sequence, Set, Tuple, Union, cast, overload\n)\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    # Here, change domain is imported only for type checking.\n    from core.domain import change_domain\n    from mypy_imports import feedback_models\n    from mypy_imports import suggestion_models\n    from mypy_imports import transaction_services\n    from mypy_imports import user_models\n\n    AllowedSuggestionClasses = Union[\n        suggestion_registry.SuggestionEditStateContent,\n        suggestion_registry.SuggestionTranslateContent,\n        suggestion_registry.SuggestionAddQuestion\n    ]\n\n(feedback_models, suggestion_models, user_models) = (\n    models.Registry.import_models([\n        models.Names.FEEDBACK, models.Names.SUGGESTION, models.Names.USER\n    ])\n)\n\ntransaction_services = models.Registry.import_transaction_services()\n\nDEFAULT_SUGGESTION_THREAD_SUBJECT: Final = 'Suggestion from a user'\nDEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE: Final = ''\n\n# The maximum number of suggestions to recommend to a reviewer to review in an\n# email.\nMAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER: Final = 5\n\nSUGGESTION_TRANSLATE_CONTENT_HTML: Callable[\n    [suggestion_registry.SuggestionTranslateContent], str\n] = lambda suggestion: suggestion.change_cmd.translation_html\n\nSUGGESTION_ADD_QUESTION_HTML: Callable[\n    [suggestion_registry.SuggestionAddQuestion], str\n] = lambda suggestion: suggestion.change_cmd.question_dict[\n    'question_state_data']['content']['html']\n\n# A dictionary that maps the suggestion type to a lambda function, which is\n# used to retrieve the html content that corresponds to the suggestion's\n# emphasized text on the Contributor Dashboard. From a UI perspective, the\n# emphasized content makes it easier for users to identify the different\n# suggestion opportunities. For instance, for translation suggestions the\n# emphasized text is the translation. Similarly, for question suggestions the\n# emphasized text is the question being asked.\nSUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS: Dict[str, Callable[..., str]] = {\n    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: SUGGESTION_TRANSLATE_CONTENT_HTML,\n    feconf.SUGGESTION_TYPE_ADD_QUESTION: SUGGESTION_ADD_QUESTION_HTML\n}\n\nRECENT_REVIEW_OUTCOMES_LIMIT: Final = 100\nMAX_CONTENT_LENGTH_WITHOUT_TRUNCATION: Final = 100\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['add_question'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change_cmd: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionAddQuestion: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['translate_content'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change_cmd: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionTranslateContent: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['edit_exploration_state_content'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change_cmd: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionEditStateContent: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: str,\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change_cmd: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.BaseSuggestion: ...\n\n\ndef create_suggestion(\n    suggestion_type: str,\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change_cmd: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.BaseSuggestion:\n    \"\"\"Creates a new SuggestionModel and the corresponding FeedbackThread.\n\n    Args:\n        suggestion_type: str. The type of the suggestion. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_type: str. The target entity being edited. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_id: str. The ID of the target entity being suggested to.\n        target_version_at_submission: int. The version number of the target\n            entity at the time of creation of the suggestion.\n        author_id: str. The ID of the user who submitted the suggestion.\n        change_cmd: dict. The details of the suggestion.\n        description: str|None. The description of the changes provided by the\n            author or None, if no description is provided.\n\n    Returns:\n        Suggestion. The newly created suggestion domain object.\n\n    Raises:\n        Exception. Invalid suggestion type.\n    \"\"\"\n    if description is None:\n        description = DEFAULT_SUGGESTION_THREAD_SUBJECT\n    thread_id = feedback_services.create_thread(\n        target_type, target_id, author_id, description,\n        DEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE, has_suggestion=True)\n\n    status = suggestion_models.STATUS_IN_REVIEW\n\n    if target_type == feconf.ENTITY_TYPE_EXPLORATION:\n        exploration = exp_fetchers.get_exploration_by_id(target_id)\n    if suggestion_type == feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT:\n        score_category = ('%s%s%s' % (\n            suggestion_models.SCORE_TYPE_CONTENT,\n            suggestion_models.SCORE_CATEGORY_DELIMITER, exploration.category\n            ))\n        # Suggestions of this type do not have an associated language code,\n        # since they are not queryable by language.\n        language_code = None\n        suggestion: AllowedSuggestionClasses = (\n            suggestion_registry.SuggestionEditStateContent(\n                thread_id, target_id, target_version_at_submission, status,\n                author_id, None, change_cmd, score_category, language_code,\n                False, datetime.datetime.utcnow(),\n                datetime.datetime.utcnow()\n            )\n        )\n    elif suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n        score_category = ('%s%s%s' % (\n            suggestion_models.SCORE_TYPE_TRANSLATION,\n            suggestion_models.SCORE_CATEGORY_DELIMITER, exploration.category)\n        )\n        # The language code of the translation, used for querying purposes.\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change_cmd['language_code'], str)\n        language_code = change_cmd['language_code']\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change_cmd['state_name'], str)\n        assert isinstance(change_cmd['content_id'], str)\n        content_html = exploration.get_content_html(\n            change_cmd['state_name'], change_cmd['content_id'])\n        if content_html != change_cmd['content_html']:\n            raise Exception(\n                'The Exploration content has changed since this translation '\n                'was submitted.')\n        suggestion = suggestion_registry.SuggestionTranslateContent(\n            thread_id, target_id, target_version_at_submission, status,\n            author_id, None, change_cmd, score_category, language_code, False,\n            datetime.datetime.utcnow(), datetime.datetime.utcnow())\n    elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n        score_category = ('%s%s%s' % (\n            suggestion_models.SCORE_TYPE_QUESTION,\n            suggestion_models.SCORE_CATEGORY_DELIMITER, target_id)\n        )\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change_cmd['question_dict'], dict)\n        # Here we use cast because we are narrowing down the type from\n        # various Dict types that are present in AcceptableChangeDictTypes\n        # to QuestionDict type.\n        question_dict = cast(\n            question_domain.QuestionDict,\n            change_cmd['question_dict']\n        )\n        question_dict['language_code'] = (\n            constants.DEFAULT_LANGUAGE_CODE)\n        question_dict['question_state_data_schema_version'] = (\n            feconf.CURRENT_STATE_SCHEMA_VERSION)\n        # The language code of the question, used for querying purposes.\n        add_question_language_code = constants.DEFAULT_LANGUAGE_CODE\n        suggestion = suggestion_registry.SuggestionAddQuestion(\n            thread_id, target_id, target_version_at_submission, status,\n            author_id, None, change_cmd, score_category,\n            add_question_language_code, False,\n            datetime.datetime.utcnow(), datetime.datetime.utcnow()\n        )\n    else:\n        raise Exception('Invalid suggestion type %s' % suggestion_type)\n    suggestion.validate()\n\n    suggestion_models.GeneralSuggestionModel.create(\n        suggestion_type, target_type, target_id,\n        target_version_at_submission, status, author_id,\n        None, change_cmd, score_category, thread_id, suggestion.language_code)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    return get_suggestion_by_id(thread_id)\n\n\ndef get_suggestion_from_model(\n    suggestion_model: suggestion_models.GeneralSuggestionModel\n) -> suggestion_registry.BaseSuggestion:\n    \"\"\"Converts the given SuggestionModel to a Suggestion domain object\n\n    Args:\n        suggestion_model: SuggestionModel. SuggestionModel object to be\n            converted to Suggestion domain object.\n\n    Returns:\n        Suggestion. The corresponding Suggestion domain object.\n    \"\"\"\n    suggestion_domain_class = (\n        suggestion_registry.SUGGESTION_TYPES_TO_DOMAIN_CLASSES[\n            suggestion_model.suggestion_type])\n    return suggestion_domain_class(\n        suggestion_model.id, suggestion_model.target_id,\n        suggestion_model.target_version_at_submission,\n        suggestion_model.status, suggestion_model.author_id,\n        suggestion_model.final_reviewer_id, suggestion_model.change_cmd,\n        suggestion_model.score_category, suggestion_model.language_code,\n        suggestion_model.edited_by_reviewer, suggestion_model.last_updated,\n        suggestion_model.created_on)\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str\n) -> suggestion_registry.BaseSuggestion: ...\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str, *, strict: Literal[True]\n) -> suggestion_registry.BaseSuggestion: ...\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str, *, strict: Literal[False]\n) -> Optional[suggestion_registry.BaseSuggestion]: ...\n\n\ndef get_suggestion_by_id(\n    suggestion_id: str, strict: bool = True\n) -> Optional[suggestion_registry.BaseSuggestion]:\n    \"\"\"Finds a suggestion by the suggestion ID.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n        strict: bool. Whether to fail noisily if no suggestion with a given id\n            exists.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n\n    Raises:\n        Exception. The suggestion model does not exists for the given id.\n    \"\"\"\n    model = suggestion_models.GeneralSuggestionModel.get_by_id(suggestion_id)\n\n    if strict and model is None:\n        raise Exception(\n            'No suggestion model exists for the corresponding suggestion id: %s'\n            % suggestion_id\n        )\n\n    return get_suggestion_from_model(model) if model else None\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.TranslationContributionStatsModel]: ...\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.TranslationContributionStatsModel]: ...\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.TranslationContributionStatsModel]]: ...\n\n\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.TranslationContributionStatsModel]]:\n    \"\"\"Finds translation contribution stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(TranslationContributionStatsModel|None). The corresponding\n        translation contribution stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.TranslationContributionStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.TranslationReviewStatsModel]: ...\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.TranslationReviewStatsModel]: ...\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.TranslationReviewStatsModel]]: ...\n\n\ndef get_translation_review_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.TranslationReviewStatsModel]]:\n    \"\"\"Finds translation review stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(TranslationReviewStatsModel|None). The corresponding translation\n        review stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.TranslationReviewStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.QuestionContributionStatsModel]: ...\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.QuestionContributionStatsModel]: ...\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.QuestionContributionStatsModel]]: ...\n\n\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.QuestionContributionStatsModel]]:\n    \"\"\"Finds question contribution stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(QuestionContributionStatsModel|None). The corresponding question\n        contribution stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.QuestionContributionStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.QuestionReviewStatsModel]: ...\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.QuestionReviewStatsModel]: ...\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.QuestionReviewStatsModel]]: ...\n\n\ndef get_question_review_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.QuestionReviewStatsModel]]:\n    \"\"\"Finds question review stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(QuestionReviewStatsModel|None). The corresponding question review\n        stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.QuestionReviewStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\ndef get_suggestions_by_ids(\n    suggestion_ids: List[str]\n) -> List[Optional[suggestion_registry.BaseSuggestion]]:\n    \"\"\"Finds suggestions using the given suggestion IDs.\n\n    Args:\n        suggestion_ids: list(str). The IDs of the suggestions.\n\n    Returns:\n        list(Suggestion|None). A list of the corresponding suggestions. The\n        list will contain None elements if no suggestion is found with the\n        corresponding suggestion id.\n    \"\"\"\n    general_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n\n    return [\n        get_suggestion_from_model(suggestion_model) if suggestion_model\n        else None for suggestion_model in general_suggestion_models\n    ]\n\n\ndef query_suggestions(\n    query_fields_and_values: List[Tuple[str, str]]\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Queries for suggestions.\n\n    Args:\n        query_fields_and_values: list(tuple(str, str)). A list of queries. The\n            first element in each tuple is the field to be queried, and the\n            second element is its value.\n\n    Returns:\n        list(Suggestion). A list of suggestions that match the given query\n        values, up to a maximum of feconf.DEFAULT_QUERY_LIMIT suggestions.\n    \"\"\"\n    return [\n        get_suggestion_from_model(s) for s in\n        suggestion_models.GeneralSuggestionModel.query_suggestions(\n            query_fields_and_values)\n    ]\n\n\ndef get_translation_suggestion_ids_with_exp_ids(\n    exp_ids: List[str]\n) -> List[str]:\n    \"\"\"Gets the ids of the translation suggestions corresponding to\n    explorations with the given exploration ids.\n\n    Args:\n        exp_ids: list(str). List of exploration ids to query for.\n\n    Returns:\n        list(str). A list of the ids of translation suggestions that\n        correspond to the given exploration ids. Note: it is not\n        guaranteed that the suggestion ids returned are ordered by the\n        exploration ids in exp_ids.\n    \"\"\"\n    if len(exp_ids) == 0:\n        return []\n\n    return (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestion_ids_with_exp_ids(exp_ids)\n    )\n\n\ndef get_all_stale_suggestion_ids() -> List[str]:\n    \"\"\"Gets a list of the suggestion ids corresponding to suggestions that have\n    not had any activity on them for THRESHOLD_TIME_BEFORE_ACCEPT time.\n\n    Returns:\n        list(str). A list of suggestion ids that correspond to stale\n        suggestions.\n    \"\"\"\n\n    return (\n        suggestion_models.GeneralSuggestionModel.get_all_stale_suggestion_ids()\n    )\n\n\ndef _update_suggestion(\n    suggestion: suggestion_registry.BaseSuggestion,\n    validate_suggestion: bool = True\n) -> None:\n    \"\"\"Updates the given suggestion.\n\n    Args:\n        suggestion: Suggestion. The suggestion to be updated.\n        validate_suggestion: bool. Whether to validate the suggestion before\n            saving it.\n    \"\"\"\n    _update_suggestions([suggestion], validate_suggestion=validate_suggestion)\n\n\ndef _update_suggestions(\n    suggestions: List[suggestion_registry.BaseSuggestion],\n    update_last_updated_time: bool = True,\n    validate_suggestion: bool = True\n) -> None:\n    \"\"\"Updates the given suggestions.\n\n    Args:\n        suggestions: list(Suggestion). The suggestions to be updated.\n        update_last_updated_time: bool. Whether to update the last_updated\n            field of the suggestions.\n        validate_suggestion: bool. Whether to validate the suggestions before\n            saving them.\n    \"\"\"\n    suggestion_ids = []\n\n    if validate_suggestion:\n        for suggestion in suggestions:\n            suggestion.validate()\n            suggestion_ids.append(suggestion.suggestion_id)\n    else:\n        suggestion_ids = [\n            suggestion.suggestion_id for suggestion in suggestions\n        ]\n\n    suggestion_models_to_update_with_none = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n    suggestion_models_to_update = []\n\n    for index, suggestion_model in enumerate(\n        suggestion_models_to_update_with_none\n    ):\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestion_model is not None\n        suggestion = suggestions[index]\n        suggestion_models_to_update.append(suggestion_model)\n        suggestion_model.status = suggestion.status\n        suggestion_model.final_reviewer_id = suggestion.final_reviewer_id\n        suggestion_model.change_cmd = suggestion.change_cmd.to_dict()\n        suggestion_model.score_category = suggestion.score_category\n        suggestion_model.language_code = suggestion.language_code\n        suggestion_model.edited_by_reviewer = suggestion.edited_by_reviewer\n\n    suggestion_models.GeneralSuggestionModel.update_timestamps_multi(\n        suggestion_models_to_update,\n        update_last_updated_time=update_last_updated_time)\n    suggestion_models.GeneralSuggestionModel.put_multi(\n        suggestion_models_to_update)\n\n\ndef get_commit_message_for_suggestion(\n    author_username: str, commit_message: str\n) -> str:\n    \"\"\"Returns a modified commit message for an accepted suggestion.\n\n    Args:\n        author_username: str. Username of the suggestion author.\n        commit_message: str. The original commit message submitted by the\n            suggestion author.\n\n    Returns:\n        str. The modified commit message to be used in the exploration commit\n        logs.\n    \"\"\"\n    return '%s %s: %s' % (\n        feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX,\n        author_username, commit_message)\n\n\ndef accept_suggestion(\n    suggestion_id: str,\n    reviewer_id: str,\n    commit_message: str,\n    review_message: str\n) -> None:\n    \"\"\"Accepts the suggestion with the given suggestion_id after validating it.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be accepted.\n        reviewer_id: str. The ID of the reviewer accepting the suggestion.\n        commit_message: str. The commit message.\n        review_message: str. The message provided by the reviewer while\n            accepting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n        Exception. The suggestion is not valid.\n        Exception. The commit message is empty.\n    \"\"\"\n    if not commit_message or not commit_message.strip():\n        raise Exception('Commit message cannot be empty.')\n\n    suggestion = get_suggestion_by_id(suggestion_id, strict=False)\n\n    if suggestion is None:\n        raise Exception(\n            'You cannot accept the suggestion with id %s because it does '\n            'not exist.' % (suggestion_id)\n        )\n    if suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s has already been accepted/'\n            'rejected.' % (suggestion_id)\n        )\n    suggestion.pre_accept_validate()\n    html_string = ''.join(suggestion.get_all_html_content_strings())\n    error_list = (\n        html_validation_service.\n        validate_math_tags_in_html_with_attribute_math_content(\n            html_string))\n    if len(error_list) > 0:\n        raise Exception(\n            'Invalid math tags found in the suggestion with id %s.' % (\n                suggestion.suggestion_id)\n        )\n\n    if suggestion.edited_by_reviewer:\n        commit_message = '%s (with edits)' % commit_message\n\n    suggestion.set_suggestion_status_to_accepted()\n    suggestion.set_final_reviewer_id(reviewer_id)\n\n    author_name = user_services.get_username(suggestion.author_id)\n    commit_message = get_commit_message_for_suggestion(\n        author_name, commit_message)\n    suggestion.accept(commit_message)\n\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review decreases by one, since this\n    # suggestion is no longer in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], -1)\n\n    feedback_services.create_message(\n        suggestion_id, reviewer_id, feedback_models.STATUS_CHOICES_FIXED,\n        None, review_message, should_send_email=False)\n\n    # When recording of scores is enabled, the author of the suggestion gets an\n    # increase in their score for the suggestion category.\n    if feconf.ENABLE_RECORDING_OF_SCORES:\n        user_id = suggestion.author_id\n        score_category = suggestion.score_category\n\n        # Get user proficiency domain object.\n        user_proficiency = _get_user_proficiency(user_id, score_category)\n\n        # Increment the score of the author due to their suggestion being\n        # accepted.\n        user_proficiency.increment_score(\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY\n        )\n\n        # Emails are sent to onboard new reviewers. These new reviewers are\n        # created when the score of the user passes the minimum score required\n        # to review.\n        if feconf.SEND_SUGGESTION_REVIEW_RELATED_EMAILS:\n            if user_proficiency.can_user_review_category() and (\n                    not user_proficiency.onboarding_email_sent):\n                email_manager.send_mail_to_onboard_new_reviewers(\n                    user_id, score_category\n                )\n                user_proficiency.mark_onboarding_email_as_sent()\n\n        # Need to update the corresponding user proficiency model after we\n        # updated the domain object.\n        _update_user_proficiency(user_proficiency)\n\n\ndef reject_suggestion(\n    suggestion_id: str, reviewer_id: str, review_message: str\n) -> None:\n    \"\"\"Rejects the suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestion.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n    \"\"\"\n\n    reject_suggestions([suggestion_id], reviewer_id, review_message)\n\n\ndef reject_suggestions(\n    suggestion_ids: List[str], reviewer_id: str, review_message: str\n) -> None:\n    \"\"\"Rejects the suggestions with the given suggestion_ids.\n\n    Args:\n        suggestion_ids: list(str). The ids of the suggestions to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestions.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestions.\n\n    Raises:\n        Exception. One or more of the suggestions has already been handled.\n    \"\"\"\n    suggestions_with_none = get_suggestions_by_ids(suggestion_ids)\n    suggestions = []\n\n    for index, suggestion in enumerate(suggestions_with_none):\n        if suggestion is None:\n            raise Exception(\n                'You cannot reject the suggestion with id %s because it does '\n                'not exist.' % (suggestion_ids[index])\n            )\n        suggestions.append(suggestion)\n        if suggestion.is_handled:\n            raise Exception(\n                'The suggestion with id %s has already been accepted/'\n                'rejected.' % (suggestion.suggestion_id)\n            )\n    if not review_message:\n        raise Exception('Review message cannot be empty.')\n\n    for suggestion in suggestions:\n        suggestion.set_suggestion_status_to_rejected()\n        suggestion.set_final_reviewer_id(reviewer_id)\n\n    _update_suggestions(suggestions, validate_suggestion=False)\n\n    # Update the community contribution stats so that the number of suggestions\n    # that are in review decreases, since these suggestions are no longer in\n    # review.\n    _update_suggestion_counts_in_community_contribution_stats(suggestions, -1)\n\n    feedback_services.create_messages(\n        suggestion_ids, reviewer_id, feedback_models.STATUS_CHOICES_IGNORED,\n        None, review_message, should_send_email=False\n    )\n\n\ndef auto_reject_question_suggestions_for_skill_id(skill_id: str) -> None:\n    \"\"\"Rejects all SuggestionAddQuestions with target ID matching the supplied\n    skill ID. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        skill_id: str. The skill ID corresponding to the target ID of the\n            SuggestionAddQuestion.\n    \"\"\"\n    suggestions = query_suggestions(\n        [\n            (\n                'suggestion_type',\n                feconf.SUGGESTION_TYPE_ADD_QUESTION),\n            ('target_id', skill_id)\n        ]\n    )\n\n    suggestion_ids: List[str] = []\n    for suggestion in suggestions:\n        # Narrowing down the type from BaseSuggestion to SuggestionAddQuestion.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionAddQuestion\n        )\n        suggestion_ids.append(suggestion.suggestion_id)\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.DELETED_SKILL_REJECT_MESSAGE)\n\n\ndef auto_reject_translation_suggestions_for_exp_ids(exp_ids: List[str]) -> None:\n    \"\"\"Rejects all translation suggestions with target IDs matching the\n    supplied exploration IDs. These suggestions are being rejected because\n    their corresponding exploration was removed from a story or the story was\n    deleted. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        exp_ids: list(str). The exploration IDs corresponding to the target IDs\n            of the translation suggestions.\n    \"\"\"\n    suggestion_ids = get_translation_suggestion_ids_with_exp_ids(exp_ids)\n\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.INVALID_STORY_REJECT_TRANSLATION_SUGGESTIONS_MSG)\n\n\ndef auto_reject_translation_suggestions_for_content_ids(\n    exp_id: str,\n    content_ids: Set[str]\n) -> None:\n    \"\"\"Rejects all translation suggestions with target ID matching the supplied\n    exploration ID and change_cmd content ID matching one of the supplied\n    content IDs. These suggestions are being rejected because their\n    corresponding exploration content was deleted. Reviewer ID is set to\n    SUGGESTION_BOT_USER_ID.\n\n    Args:\n        exp_id: str. The exploration ID.\n        content_ids: list(str). The list of exploration content IDs.\n    \"\"\"\n    obsolete_suggestion_ids = [\n        suggestion.suggestion_id\n        for suggestion in get_translation_suggestions_in_review(exp_id)\n        if suggestion.change_cmd.content_id in content_ids]\n    reject_suggestions(\n        obsolete_suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        constants.OBSOLETE_TRANSLATION_SUGGESTION_REVIEW_MSG)\n\n\ndef resubmit_rejected_suggestion(\n    suggestion_id: str,\n    summary_message: str,\n    author_id: str,\n    change_cmd: change_domain.BaseChange\n) -> None:\n    \"\"\"Resubmit a rejected suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the rejected suggestion.\n        summary_message: str. The message provided by the author to\n            summarize new suggestion.\n        author_id: str. The ID of the author creating the suggestion.\n        change_cmd: BaseChange. The new change to apply to the suggestion.\n\n    Raises:\n        Exception. The summary message is empty.\n        Exception. The suggestion has not been handled yet.\n        Exception. The suggestion has already been accepted.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not summary_message:\n        raise Exception('Summary message cannot be empty.')\n    if not suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s is not yet handled.' % (suggestion_id)\n        )\n    if suggestion.status == suggestion_models.STATUS_ACCEPTED:\n        raise Exception(\n            'The suggestion with id %s was accepted. '\n            'Only rejected suggestions can be resubmitted.' % (suggestion_id)\n        )\n\n    suggestion.pre_update_validate(change_cmd)\n    suggestion.change_cmd = change_cmd\n    suggestion.set_suggestion_status_to_in_review()\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one, since this suggestion is\n    # now back in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    feedback_services.create_message(\n        suggestion_id, author_id, feedback_models.STATUS_CHOICES_OPEN,\n        None, summary_message)\n\n\ndef get_all_suggestions_that_can_be_reviewed_by_user(\n    user_id: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns a list of suggestions which need to be reviewed, in categories\n    where the user has crossed the minimum score to review.\n\n    Args:\n        user_id: str. The ID of the user.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user is allowed\n        to review.\n    \"\"\"\n    score_categories = (\n        user_models.UserContributionProficiencyModel\n        .get_all_categories_where_user_can_review(user_id))\n\n    if len(score_categories) == 0:\n        return []\n\n    return ([\n        get_suggestion_from_model(s)\n        for s in suggestion_models.GeneralSuggestionModel\n        .get_in_review_suggestions_in_score_categories(\n            score_categories, user_id)\n    ])\n\n\ndef get_reviewable_translation_suggestions_by_offset(\n    user_id: str,\n    opportunity_summary_exp_ids: Optional[List[str]],\n    limit: Optional[int],\n    offset: int,\n    sort_key: Optional[str],\n    language: Optional[str] = None\n) -> Tuple[List[suggestion_registry.SuggestionTranslateContent], int]:\n    \"\"\"Returns a list of translation suggestions matching the\n     passed opportunity IDs which the user can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        opportunity_summary_exp_ids: list(str) or None.\n            The list of exploration IDs for which suggestions\n            are fetched. If the list is empty, no suggestions are\n            fetched. If the value is None, all reviewable\n            suggestions are fetched. If the list consists of some\n            valid number of ids, suggestions corresponding to the\n            IDs are fetched.\n        limit: int|None. The maximum number of results to return. If None,\n            all available results are returned.\n        sort_key: str|None. The key to sort the suggestions by.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n        language: str. ISO 639-1 language code for which to filter. If it is\n            None, all available languages will be returned.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of translation suggestions\n            which the supplied user is permitted to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    contribution_rights = user_services.get_user_contribution_rights(\n        user_id)\n    language_codes = (\n        contribution_rights.can_review_translation_for_language_codes)\n\n    # No language means all languages.\n    if language is not None:\n        language_codes = [language] if language in language_codes else []\n\n    # The user cannot review any translations, so return early.\n    if len(language_codes) == 0:\n        return [], offset\n\n    in_review_translation_suggestions: Sequence[\n        suggestion_models.GeneralSuggestionModel\n    ] = []\n    next_offset = offset\n    if opportunity_summary_exp_ids is None:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit,\n                offset,\n                user_id,\n                sort_key,\n                language_codes))\n    elif len(opportunity_summary_exp_ids) > 0:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit,\n                offset,\n                user_id,\n                sort_key,\n                language_codes,\n                opportunity_summary_exp_ids))\n\n    translation_suggestions = []\n    for suggestion_model in in_review_translation_suggestions:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionTranslateContent.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionTranslateContent\n        )\n        translation_suggestions.append(suggestion)\n\n    return translation_suggestions, next_offset\n\n\ndef get_reviewable_translation_suggestion_target_ids(\n    user_id: str,\n    language_code: Optional[str] = None\n) -> List[str]:\n    \"\"\"Returns a list of translation suggestions matching the\n    passed opportunity IDs which the user can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        language_code: str|None. ISO 639-1 language code for which to filter.\n            If it is None, all available languages will be returned.\n\n    Returns:\n        list(str). A list of translation suggestion target ids\n        which the supplied user is permitted to review.\n    \"\"\"\n    contribution_rights = user_services.get_user_contribution_rights(\n        user_id\n    )\n    allowed_language_codes_for_review = (\n        contribution_rights.can_review_translation_for_language_codes\n    )\n\n    filtering_by_language_code = language_code is not None\n    language_codes = (\n        allowed_language_codes_for_review if not filtering_by_language_code\n        else [language_code]\n        if language_code in allowed_language_codes_for_review\n        else []\n    )\n\n    user_can_review_translations = len(language_codes) != 0\n    if not user_can_review_translations:\n        return []\n\n    return (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_translation_suggestion_target_ids(\n            user_id,\n            language_codes\n        )\n    )\n\n\ndef get_reviewable_translation_suggestions_for_single_exp(\n    user_id: str,\n    opportunity_summary_exp_id: str,\n    language_code: str\n) -> Tuple[List[suggestion_registry.SuggestionTranslateContent], int]:\n    \"\"\"Returns a list of translation suggestions matching the\n     passed opportunity ID which the user can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        opportunity_summary_exp_id: str.\n            The exploration ID for which suggestions\n            are fetched. If exp id is empty, no suggestions are\n            fetched.\n        language_code: str. The language code to get results for.\n\n    Returns:\n        Tuple of (results, next_offset). where:\n            results: list(Suggestion). A list of translation suggestions\n            which the supplied user is permitted to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    contribution_rights = user_services.get_user_contribution_rights(\n        user_id)\n    language_codes = (\n        contribution_rights.can_review_translation_for_language_codes)\n\n    # The user doesn't have rights to review in any languages, or the user\n    # doesn't have right to review in the chosen language so return early.\n    if language_codes is None or (\n        language_code not in language_codes):\n        return [], 0\n\n    in_review_translation_suggestions, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n        .get_reviewable_translation_suggestions(\n            user_id,\n            language_code,\n            opportunity_summary_exp_id))\n\n    translation_suggestions = []\n    for suggestion_model in in_review_translation_suggestions:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionTranslateContent.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionTranslateContent\n        )\n        translation_suggestions.append(suggestion)\n\n    return translation_suggestions, next_offset\n\n\ndef get_reviewable_question_suggestions_by_offset(\n    user_id: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str],\n    skill_ids: Optional[List[str]],\n) -> Tuple[List[suggestion_registry.SuggestionAddQuestion], int]:\n    \"\"\"Returns a list of question suggestions which the user\n       can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n        sort_key: str|None. The key to sort the suggestions by.\n        skill_ids: List[str]|None. The skills for which to return question\n            suggestions. None for returning all suggestions.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of question suggestions which\n            the given user is allowed to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    suggestions, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_question_suggestions_by_offset(\n            limit, offset, user_id, sort_key, skill_ids))\n\n    question_suggestions = []\n    for suggestion_model in suggestions:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionAddQuestion.\n        assert isinstance(suggestion, suggestion_registry.SuggestionAddQuestion)\n        question_suggestions.append(suggestion)\n\n    return question_suggestions, next_offset\n\n\ndef get_question_suggestions_waiting_longest_for_review() -> List[\n    suggestion_registry.SuggestionAddQuestion\n]:\n    \"\"\"Returns MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS number\n    of question suggestions, sorted in descending order by review wait time.\n\n    Returns:\n        list(Suggestion). A list of question suggestions, sorted in descending\n        order based on how long the suggestions have been waiting for review.\n    \"\"\"\n    question_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_waiting_longest_for_review()\n    )\n\n    question_suggestion = []\n    for suggestion_model in question_suggestion_models:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionAddQuestion.\n        assert isinstance(suggestion, suggestion_registry.SuggestionAddQuestion)\n        question_suggestion.append(suggestion)\n    return question_suggestion\n\n\ndef get_translation_suggestions_waiting_longest_for_review(\n    language_code: str\n) -> List[suggestion_registry.SuggestionTranslateContent]:\n    \"\"\"Returns MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS\n    number of translation suggestions in the specified language code,\n    sorted in descending order by review wait time.\n\n    Args:\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions, sorted in\n        descending order based on how long the suggestions have been waiting\n        for review.\n    \"\"\"\n    translation_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                language_code)\n    )\n\n    translation_suggestions = []\n    for suggestion_model in translation_suggestion_models:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion\n        # to SuggestionTranslateContent.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionTranslateContent\n        )\n        translation_suggestions.append(suggestion)\n\n    return translation_suggestions\n\n\ndef get_translation_suggestions_in_review(\n    exp_id: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns translation suggestions in-review by exploration ID.\n\n    Args:\n        exp_id: str. Exploration ID.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in-review with\n        target_id == exp_id.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_translation_suggestions_by_exp_id(\n            exp_id)\n    )\n    return [\n        get_suggestion_from_model(model)\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_translation_suggestions_in_review_by_exploration(\n    exp_id: str, language_code: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns translation suggestions in review by exploration ID.\n\n    Args:\n        exp_id: str. Exploration ID.\n        language_code: str. Language code.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id == exp_id.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestions_in_review_with_exp_id(\n            exp_id, language_code)\n    )\n    return [\n        get_suggestion_from_model(model)\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_translation_suggestions_in_review_by_exp_ids(\n    exp_ids: List[str], language_code: str\n) -> List[Optional[suggestion_registry.BaseSuggestion]]:\n    \"\"\"Returns translation suggestions in review by exploration ID and language\n    code.\n\n    Args:\n        exp_ids: list(str). Exploration IDs matching the target ID of the\n            translation suggestions.\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id in exp_ids and language_code == language_code, or None if\n        suggestion model does not exists.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_translation_suggestions_by_exp_ids(\n            exp_ids, language_code)\n    )\n    return [\n        get_suggestion_from_model(model) if model else None\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_suggestions_with_editable_explorations(\n    suggestions: Sequence[suggestion_registry.SuggestionTranslateContent]\n) -> Sequence[suggestion_registry.SuggestionTranslateContent]:\n    \"\"\"Filters the supplied suggestions for those suggestions that have\n    explorations that allow edits.\n\n    Args:\n        suggestions: list(Suggestion). List of translation suggestions to\n            filter.\n\n    Returns:\n        list(Suggestion). List of filtered translation suggestions.\n    \"\"\"\n    suggestion_exp_ids = {\n        suggestion.target_id for suggestion in suggestions}\n    suggestion_exp_id_to_exp = exp_fetchers.get_multiple_explorations_by_id(\n        list(suggestion_exp_ids))\n    return list(filter(\n        lambda suggestion: suggestion_exp_id_to_exp[\n            suggestion.target_id].edits_allowed,\n        suggestions))\n\n\ndef _get_plain_text_from_html_content_string(html_content_string: str) -> str:\n    \"\"\"Retrieves the plain text from the given html content string. RTE element\n    occurrences in the html are replaced by their corresponding rte component\n    name, capitalized in square brackets.\n    eg: <p>Sample1 <oppia-noninteractive-math></oppia-noninteractive-math>\n        Sample2 </p> will give as output: Sample1 [Math] Sample2.\n    Note: similar logic exists in the frontend in format-rte-preview.filter.ts.\n\n    Args:\n        html_content_string: str. The content html string to convert to plain\n            text.\n\n    Returns:\n        str. The plain text string from the given html content string.\n    \"\"\"\n\n    def _replace_rte_tag(rte_tag: Match[str]) -> str:\n        \"\"\"Replaces all of the <oppia-noninteractive-**> tags with their\n        corresponding rte component name in square brackets.\n\n        Args:\n            rte_tag: MatchObject. A matched object that contins the\n                oppia-noninteractive rte tags.\n\n        Returns:\n            str. The string to replace the rte tags with.\n        \"\"\"\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_string = rte_tag.group(0)\n        # Get the name of the rte tag. The hyphen is there as an optional\n        # matching character to cover the case where the name of the rte\n        # component is more than one word.\n        rte_tag_name = re.search(\n            r'oppia-noninteractive-(\\w|-)+', rte_tag_string)\n        # Here, rte_tag_name is always going to exists because the string\n        # that was passed in this function is always going to contain\n        # `<oppia-noninteractive>` substring. So, to just rule out the\n        # possibility of None for mypy type checking. we used assertion here.\n        assert rte_tag_name is not None\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_name_string = rte_tag_name.group(0)\n        # Get the name of the rte component.\n        rte_component_name_string_list = rte_tag_name_string.split('-')[2:]\n        # If the component name is more than word, connect the words with spaces\n        # to create a single string.\n        rte_component_name_string = ' '.join(rte_component_name_string_list)\n        # Captialize each word in the string.\n        capitalized_rte_component_name_string = (\n            rte_component_name_string.title())\n        formatted_rte_component_name_string = ' [%s] ' % (\n            capitalized_rte_component_name_string)\n        return formatted_rte_component_name_string\n\n    # Replace all the <oppia-noninteractive-**> tags with their rte component\n    # names capitalized in square brackets.\n    html_content_string_with_rte_tags_replaced = re.sub(\n        r'<oppia-noninteractive-[^>]+>(.*?)</oppia-noninteractive-[^>]+>',\n        _replace_rte_tag, html_content_string)\n    # Get rid of all of the other html tags.\n    plain_text = html_cleaner.strip_html_tags(\n        html_content_string_with_rte_tags_replaced)\n    # Remove trailing and leading whitespace and ensure that all words are\n    # separated by a single space.\n    plain_text_without_contiguous_whitespace = ' '.join(plain_text.split())\n    return plain_text_without_contiguous_whitespace\n\n\ndef create_reviewable_suggestion_email_info_from_suggestion(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> suggestion_registry.ReviewableSuggestionEmailInfo:\n    \"\"\"Creates an object with the key information needed to notify reviewers or\n    admins that the given suggestion needs review.\n\n    Args:\n        suggestion: Suggestion. The suggestion used to create the\n            ReviewableSuggestionEmailInfo object. Note that the suggestion's\n            status must be in review.\n\n    Returns:\n        ReviewableSuggestionEmailInfo. The corresponding reviewable suggestion\n        email info.\n\n    Raises:\n        Exception. The suggestion type must be offered on the Contributor\n            Dashboard.\n    \"\"\"\n    if suggestion.suggestion_type not in (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS):\n        raise Exception(\n            'Expected suggestion type to be offered on the Contributor '\n            'Dashboard, received: %s.' % suggestion.suggestion_type)\n\n    # Retrieve the html content that is emphasized on the Contributor Dashboard\n    # pages. This content is what stands out for each suggestion when a user\n    # views a list of suggestions.\n    get_html_representing_suggestion = (\n        SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n            suggestion.suggestion_type]\n    )\n    plain_text = _get_plain_text_from_html_content_string(\n        get_html_representing_suggestion(suggestion))\n    # Here, suggestion can only be of `translate_content` or `add_question`\n    # type and in both suggestions language_code cannot be None. So, to\n    # just narrow down type from Optional[str] to str we used assertion here.\n    assert suggestion.language_code is not None\n    return suggestion_registry.ReviewableSuggestionEmailInfo(\n        suggestion.suggestion_type, suggestion.language_code, plain_text,\n        suggestion.last_updated\n    )\n\n\ndef get_suggestions_waiting_for_review_info_to_notify_reviewers(\n    reviewer_ids: List[str]\n) -> List[List[suggestion_registry.ReviewableSuggestionEmailInfo]]:\n    \"\"\"For each user, returns information that will be used to notify reviewers\n    about the suggestions waiting longest for review, that the reviewer has\n    permissions to review.\n\n    Args:\n        reviewer_ids: list(str). A list of the reviewer user ids to notify.\n\n    Returns:\n        list(list(ReviewableSuggestionEmailInfo)). A list of suggestion\n        email content info objects for each reviewer. Each suggestion email\n        content info object contains the type of the suggestion, the language\n        of the suggestion, the suggestion content (question/translation) and\n        the date that the suggestion was submitted for review. For each user\n        the suggestion email content info objects are sorted in descending order\n        based on review wait time.\n    \"\"\"\n    # Get each reviewer's review permissions.\n    users_contribution_rights = user_services.get_users_contribution_rights(\n        reviewer_ids\n    )\n\n    # Get the question suggestions that have been waiting longest for review.\n    question_suggestions = (\n        get_question_suggestions_waiting_longest_for_review()\n    )\n\n    # Create a dictionary to keep track of the translation suggestions that\n    # have been waiting longest for review for each language code.\n    translation_suggestions_by_lang_code_dict = {}\n\n    reviewers_reviewable_suggestion_infos = []\n\n    for user_contribution_rights in users_contribution_rights:\n        # Use a min heap because then the suggestions that have been waiting the\n        # longest for review (earliest review submission date) are automatically\n        # efficiently sorted.\n        suggestions_waiting_longest_heap: List[\n            Tuple[datetime.datetime, suggestion_registry.BaseSuggestion]\n        ] = []\n        if user_contribution_rights.can_review_questions:\n            for question_suggestion in question_suggestions:\n                # Break early because we only want the top\n                # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER number of\n                # suggestions.\n                if len(suggestions_waiting_longest_heap) == (\n                        MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                    break\n                # We can't include suggestions that were authored by the\n                # reviewer because reviewers aren't allowed to review their own\n                # suggestions.\n                if question_suggestion.author_id != user_contribution_rights.id:\n                    heapq.heappush(suggestions_waiting_longest_heap, (\n                        question_suggestion.last_updated, question_suggestion))\n\n        if user_contribution_rights.can_review_translation_for_language_codes:\n            for language_code in (\n                    user_contribution_rights\n                    .can_review_translation_for_language_codes):\n                # Get a list of the translation suggestions in the language code\n                # from the datastore if we haven't already gotten them.\n                if language_code not in (\n                        translation_suggestions_by_lang_code_dict):\n                    translation_suggestions_by_lang_code_dict[language_code] = (\n                        get_translation_suggestions_waiting_longest_for_review(\n                            language_code\n                        )\n                    )\n\n                translation_suggestions = (\n                    translation_suggestions_by_lang_code_dict[language_code]\n                )\n                for translation_suggestion in translation_suggestions:\n                    if len(suggestions_waiting_longest_heap) == (\n                            MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                        # The shortest review wait time corresponds to the most\n                        # recent review submission date, which is the max of\n                        # the heap.\n                        most_recent_review_submission = max(\n                            suggestions_waiting_longest_heap)[0]\n                        # If the review submission date for the translation\n                        # suggestion is more recent than the most recent\n                        # submission date so far, we can exit early.\n                        if translation_suggestion.last_updated > (\n                                most_recent_review_submission):\n                            break\n                    # Reviewers can never review their own suggestions.\n                    if translation_suggestion.author_id != (\n                            user_contribution_rights.id):\n                        heapq.heappush(suggestions_waiting_longest_heap, (\n                            translation_suggestion.last_updated,\n                            translation_suggestion))\n\n        # Get the key information from each suggestion that will be used to\n        # email reviewers.\n        reviewer_reviewable_suggestion_infos = []\n        for _ in range(MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n            if len(suggestions_waiting_longest_heap) == 0:\n                break\n            _, suggestion = heapq.heappop(suggestions_waiting_longest_heap)\n            reviewer_reviewable_suggestion_infos.append(\n                create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            )\n        reviewers_reviewable_suggestion_infos.append(\n            reviewer_reviewable_suggestion_infos\n        )\n\n    return reviewers_reviewable_suggestion_infos\n\n\ndef get_submitted_suggestions(\n    user_id: str, suggestion_type: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of the suggestion.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user has\n        submitted.\n    \"\"\"\n    return ([\n        get_suggestion_from_model(s) for s in (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_of_suggestion_type(\n                suggestion_type, user_id))\n    ])\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: Literal['add_question'],\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[\n    Sequence[suggestion_registry.SuggestionAddQuestion], int\n]: ...\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: Literal['translate_content'],\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[\n    Sequence[suggestion_registry.SuggestionTranslateContent], int\n]: ...\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[Sequence[suggestion_registry.BaseSuggestion], int]: ...\n\n\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[Sequence[suggestion_registry.BaseSuggestion], int]:\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of suggestion.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning\n            of all results matching the query.\n        sort_key: str|None. The key to sort the suggestions by.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of suggestions of the supplied\n                type which the supplied user has submitted.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    submitted_suggestion_models, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit,\n                offset,\n                suggestion_type,\n                user_id,\n                sort_key))\n    suggestions = ([\n        get_suggestion_from_model(s) for s in submitted_suggestion_models\n    ])\n    return suggestions, next_offset\n\n\ndef get_info_about_suggestions_waiting_too_long_for_review() -> List[\n    suggestion_registry.ReviewableSuggestionEmailInfo\n]:\n    \"\"\"Gets the information about the suggestions that have been waiting longer\n    than suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days\n    for a review on the Contributor Dashboard. There can be information about at\n    most suggestion_models.MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN suggestions.\n    The information about the suggestions are returned in descending order by\n    the suggestion's review wait time.\n\n    Returns:\n        list(ReviewableSuggestionEmailContentInfo). A list of reviewable\n        suggestion email content info objects that represent suggestions that\n        have been waiting too long for a review. Each object contains the type\n        of the suggestion, the language of the suggestion, the suggestion\n        content (question/translation), and the date that the suggestion was\n        submitted for review. The objects are sorted in descending order based\n        on review wait time.\n    \"\"\"\n    suggestions_waiting_too_long_for_review = [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_suggestions_waiting_too_long_for_review())\n    ]\n    return [\n        create_reviewable_suggestion_email_info_from_suggestion(\n            suggestion) for suggestion in\n        suggestions_waiting_too_long_for_review\n    ]\n\n\ndef get_new_suggestions_for_reviewer_notifications() -> List[\n    suggestion_registry.ReviewableSuggestionEmailInfo\n]:\n    \"\"\"Retrieves and organizes new suggestions for reviewer email notifications.\n\n    Returns:\n        list[ReviewableSuggestionEmailInfo]. A list of email content info\n        objects for new suggestions.\n    \"\"\"\n    new_suggestions = [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_new_suggestions_waiting_for_review()\n        )\n    ]\n\n    email_content_info = []\n\n    for suggestion in new_suggestions:\n        suggestion_info = (\n            create_reviewable_suggestion_email_info_from_suggestion(\n                suggestion\n        ))\n        email_content_info.append(suggestion_info)\n    return email_content_info\n\n\ndef get_user_proficiency_from_model(\n    user_proficiency_model: user_models.UserContributionProficiencyModel\n) -> user_domain.UserContributionProficiency:\n    \"\"\"Converts the given UserContributionProficiencyModel to a\n    UserContributionProficiency domain object.\n\n    Args:\n        user_proficiency_model: UserContributionProficiencyModel.\n            UserContributionProficiencyModel to be converted to\n            a UserContributionProficiency domain object.\n\n    Returns:\n        UserContributionProficiency. The corresponding\n        UserContributionProficiency domain object.\n    \"\"\"\n    return user_domain.UserContributionProficiency(\n        user_proficiency_model.user_id, user_proficiency_model.score_category,\n        user_proficiency_model.score,\n        user_proficiency_model.onboarding_email_sent\n    )\n\n\ndef _update_user_proficiency(\n    user_proficiency: user_domain.UserContributionProficiency\n) -> None:\n    \"\"\"Updates the user_proficiency.\n\n    Args:\n        user_proficiency: UserContributionProficiency. The user proficiency to\n            be updated.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_proficiency.user_id, user_proficiency.score_category\n    )\n\n    if user_proficiency_model is not None:\n        user_proficiency_model.user_id = user_proficiency.user_id\n        user_proficiency_model.score_category = user_proficiency.score_category\n        user_proficiency_model.score = user_proficiency.score\n        user_proficiency_model.onboarding_email_sent = (\n            user_proficiency.onboarding_email_sent\n        )\n\n        user_proficiency_model.update_timestamps()\n        user_proficiency_model.put()\n\n    else:\n        user_models.UserContributionProficiencyModel.create(\n            user_proficiency.user_id, user_proficiency.score_category,\n            user_proficiency.score, user_proficiency.onboarding_email_sent)\n\n\ndef get_all_scores_of_user(user_id: str) -> Dict[str, int]:\n    \"\"\"Gets all scores for a given user.\n\n    Args:\n        user_id: str. The id of the user.\n\n    Returns:\n        dict. A dict containing all the scores of the user. The keys of the dict\n        are the score categories and the values are the scores.\n    \"\"\"\n    scores = {}\n    for model in (\n            user_models.UserContributionProficiencyModel.get_all_scores_of_user(\n                user_id)):\n        scores[model.score_category] = model.score\n\n    return scores\n\n\ndef can_user_review_category(\n    user_id: str, score_category: str\n) -> bool:\n    \"\"\"Checks if user can review suggestions in category score_category.\n    If the user has score above the minimum required score, then the user is\n    allowed to review.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category to check the user's score.\n\n    Returns:\n        bool. Whether the user can review suggestions under category\n        score_category.\n    \"\"\"\n    user_proficiency = _get_user_proficiency(user_id, score_category)\n    return user_proficiency.can_user_review_category()\n\n\ndef get_all_user_ids_who_are_allowed_to_review(\n    score_category: str\n) -> List[str]:\n    \"\"\"Gets all user_ids of users who are allowed to review (as per their\n    scores) suggestions to a particular category.\n\n    Args:\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        list(str). All user_ids of users who are allowed to review in the given\n        category.\n    \"\"\"\n    return [\n        model.user_id for model in user_models.UserContributionProficiencyModel\n        .get_all_users_with_score_above_minimum_for_category(score_category)\n    ]\n\n\ndef _get_user_proficiency(\n    user_id: str, score_category: str\n) -> user_domain.UserContributionProficiency:\n    \"\"\"Gets the user proficiency model from storage and creates the\n    corresponding user proficiency domain object if the model exists. If the\n    model does not exist a user proficiency domain object with the given\n    user_id and score category is created with the initial score and email\n    values.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        UserContributionProficiency. The user proficiency object.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_id, score_category)\n\n    if user_proficiency_model is not None:\n        return get_user_proficiency_from_model(user_proficiency_model)\n\n    return user_domain.UserContributionProficiency(\n        user_id, score_category, 0, False)\n\n\ndef check_can_resubmit_suggestion(suggestion_id: str, user_id: str) -> bool:\n    \"\"\"Checks whether the given user can resubmit the suggestion.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n        user_id: str. The ID of the user.\n\n    Returns:\n        bool. Whether the user can resubmit the suggestion.\n    \"\"\"\n\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    return suggestion.author_id == user_id\n\n\ndef create_community_contribution_stats_from_model(\n    community_contribution_stats_model: (\n        suggestion_models.CommunityContributionStatsModel\n    )\n) -> suggestion_registry.CommunityContributionStats:\n    \"\"\"Creates a domain object that represents the community contribution\n    stats from the model given. Note that each call to this function returns\n    a new domain object, but the data copied into the domain object comes from\n    a single, shared source.\n\n    Args:\n        community_contribution_stats_model: CommunityContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.CommunityContributionStats(\n        (\n            community_contribution_stats_model\n            .translation_reviewer_counts_by_lang_code\n        ),\n        (\n            community_contribution_stats_model\n            .translation_suggestion_counts_by_lang_code\n        ),\n        community_contribution_stats_model.question_reviewer_count,\n        community_contribution_stats_model.question_suggestion_count\n    )\n\n\ndef get_community_contribution_stats(\n) -> suggestion_registry.CommunityContributionStats:\n    \"\"\"Gets the CommunityContributionStatsModel and converts it into the\n    corresponding domain object that represents the community contribution\n    stats. Note that there is only ever one instance of this model and if the\n    model doesn't exist yet, it will be created.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    community_contribution_stats_model = (\n        suggestion_models.CommunityContributionStatsModel.get()\n    )\n\n    return create_community_contribution_stats_from_model(\n        community_contribution_stats_model)\n\n\ndef create_translation_contribution_stats_from_model(\n    translation_contribution_stats_model: (\n        suggestion_models.TranslationContributionStatsModel\n    )\n) -> suggestion_registry.TranslationContributionStats:\n    \"\"\"Creates a domain object representing the supplied\n    TranslationContributionStatsModel.\n\n    Args:\n        translation_contribution_stats_model: TranslationContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        TranslationContributionStats. The corresponding\n        TranslationContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.TranslationContributionStats(\n        translation_contribution_stats_model.language_code,\n        translation_contribution_stats_model.contributor_user_id,\n        translation_contribution_stats_model.topic_id,\n        translation_contribution_stats_model.submitted_translations_count,\n        translation_contribution_stats_model.submitted_translation_word_count,\n        translation_contribution_stats_model.accepted_translations_count,\n        (\n            translation_contribution_stats_model\n            .accepted_translations_without_reviewer_edits_count\n        ),\n        translation_contribution_stats_model.accepted_translation_word_count,\n        translation_contribution_stats_model.rejected_translations_count,\n        translation_contribution_stats_model.rejected_translation_word_count,\n        set(translation_contribution_stats_model.contribution_dates)\n    )\n\n\ndef get_all_translation_contribution_stats(\n    user_id: str\n) -> List[suggestion_registry.TranslationContributionStats]:\n    \"\"\"Gets all TranslationContributionStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(TranslationContributionStats). TranslationContributionStats domain\n        objects corresponding to the supplied user.\n    \"\"\"\n    translation_contribution_stats_models = (\n        suggestion_models.TranslationContributionStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        create_translation_contribution_stats_from_model(model)\n        for model in translation_contribution_stats_models\n    ]\n\n\ndef get_suggestion_types_that_need_reviewers() -> Dict[str, Set[str]]:\n    \"\"\"Uses the community contribution stats to determine which suggestion\n    types need more reviewers. Suggestion types need more reviewers if the\n    number of suggestions in that type divided by the number of reviewers is\n    greater than ParamName.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n    Returns:\n        dict. A dictionary that uses the presence of its keys to indicate which\n        suggestion types need more reviewers. The possible key values are the\n        suggestion types listed in\n        feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES. The dictionary\n        values for each suggestion type are the following:\n        - for question suggestions the value is an empty set\n        - for translation suggestions the value is a nonempty set containing the\n            language codes of the translation suggestions that need more\n            reviewers.\n    \"\"\"\n    suggestion_types_needing_reviewers: Dict[str, Set[str]] = {}\n    stats = get_community_contribution_stats()\n\n    language_codes_that_need_reviewers = (\n        stats.get_translation_language_codes_that_need_reviewers()\n    )\n    if len(language_codes_that_need_reviewers) != 0:\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT] = (\n                language_codes_that_need_reviewers\n            )\n\n    if stats.are_question_reviewers_needed():\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_ADD_QUESTION] = set()\n\n    return suggestion_types_needing_reviewers\n\n\n@transaction_services.run_in_transaction_wrapper\ndef _update_suggestion_counts_in_community_contribution_stats_transactional(\n    suggestions: List[suggestion_registry.BaseSuggestion], amount: int\n) -> None:\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. Note that this method should only ever be\n    called in a transaction.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    stats_model = suggestion_models.CommunityContributionStatsModel.get()\n    for suggestion in suggestions:\n        if suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT):\n            if suggestion.language_code not in (\n                    stats_model.translation_suggestion_counts_by_lang_code):\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] = amount\n            else:\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] += amount\n                # Remove the language code from the dict if the count reaches\n                # zero.\n                if stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code] == 0:\n                    del stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code]\n        elif suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_ADD_QUESTION):\n            stats_model.question_suggestion_count += amount\n\n    # Create a community contribution stats object to validate the updates.\n    stats = create_community_contribution_stats_from_model(stats_model)\n    stats.validate()\n\n    stats_model.update_timestamps()\n    stats_model.put()\n\n    logging.info('Updated translation_suggestion_counts_by_lang_code: %s' % (\n        stats_model.translation_suggestion_counts_by_lang_code))\n\n\ndef _update_suggestion_counts_in_community_contribution_stats(\n    suggestions: Sequence[suggestion_registry.BaseSuggestion], amount: int\n) -> None:\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. The GET and PUT is done in a single\n    transaction to avoid loss of updates that come in rapid succession.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    _update_suggestion_counts_in_community_contribution_stats_transactional(\n        suggestions, amount)\n\n\ndef _strip_prefix(component_name: str) -> str:\n    \"\"\"Removes the 'oppia-noninteractive-' prefix from component names.\n\n    Args:\n        component_name: str. The full component name.\n\n    Returns:\n        str. The component name without the prefix.\n    \"\"\"\n    return component_name.removeprefix('oppia-noninteractive-')\n\n\ndef highlight_differences(\n        original: str,\n        updated: str,\n        truncation_limit: int = MAX_CONTENT_LENGTH_WITHOUT_TRUNCATION\n) -> Tuple[str, str]:\n    \"\"\"Finds the first difference between two strings and truncates accordingly.\n\n    Args:\n        original: str. The original string.\n        updated: str. The updated string.\n        truncation_limit: int. Maximum length of the returned snippets.\n\n    Returns:\n        tuple. A pair of truncated strings highlighting where they differ.\n    \"\"\"\n    # If the strings are identical, simply return truncated versions.\n    if original == updated:\n        return original[:truncation_limit], updated[:truncation_limit]\n\n    min_length = min(len(original), len(updated))\n\n    # Find the first index where the strings differ.\n    diff_index = min_length\n    for i in range(min_length):\n        if original[i] != updated[i]:\n            diff_index = i\n            break\n    # Calculate start_index with 10 characters before the first difference.\n    start_index = max(0, diff_index - 10)\n\n    # Truncate both original and updated strings.\n    truncated_original = original[start_index:start_index + truncation_limit]\n    truncated_updated = updated[start_index:start_index + truncation_limit]\n\n    # Apply '...' at the start if truncation happens and it's not\n    # already at the start of the string.\n    if len(truncated_original) < truncation_limit and start_index > 0:\n        truncated_original = '...' + truncated_original\n    if len(truncated_updated) < truncation_limit and start_index > 0:\n        truncated_updated = '...' + truncated_updated\n\n    truncated_original = truncated_original[:truncation_limit]\n    truncated_updated = truncated_updated[:truncation_limit]\n\n    return truncated_original, truncated_updated\n\n\ndef count_rte_components(html_content: str) -> Dict[str, int]:\n    \"\"\"Counts the number of each RTE component in the provided HTML content.\n\n    Args:\n        html_content: str. The HTML content to analyze.\n\n    Returns:\n        Dict[str, int]. A dictionary where keys are RTE component names\n        (e.g., 'oppia-noninteractive-image') and values are their counts.\n    \"\"\"\n    soup = bs4.BeautifulSoup(html_content, 'html.parser')\n    component_counts = {}\n    rte_tags_with_attrs = (\n        rte_component_registry.Registry.get_tag_list_with_attrs()\n    )\n    rte_tags = list(rte_tags_with_attrs.keys())\n\n    for tag in rte_tags:\n        component_counts[tag] = len(soup.find_all(tag))\n\n    return component_counts\n\n\ndef update_translation_suggestion(\n    suggestion_id: str,\n    translation_html: str\n) -> None:\n    \"\"\"Updates the translation_html of a suggestion with the given\n    suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        translation_html: str. The new translation_html string.\n\n    Raises:\n        InvalidInputException. The RTE component counts in\n            the updated translation do not match the original content.\n        Exception. The suggestion is not of type\n            SuggestionTranslateContent.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    if not isinstance(\n        suggestion, suggestion_registry.SuggestionTranslateContent\n    ):\n        raise Exception(\n            'Expected SuggestionTranslateContent suggestion but found: %s.'\n            % type(suggestion).__name__\n        )\n\n    original_text_html = suggestion.change_cmd.content_html\n    original_rte_counts = count_rte_components(original_text_html)\n    updated_rte_counts = count_rte_components(translation_html)\n\n    # We use a sorted approach to compare component counts because it ensures\n    # consistency in comparison regardless of the order components appear.\n    all_component_names = sorted(\n        {_strip_prefix(name)\n        for name in original_rte_counts.keys() | updated_rte_counts.keys()}\n    )\n\n    discrepancy_components = []\n\n    for component_name in all_component_names:\n        full_name = f'oppia-noninteractive-{component_name}'\n        original_count = original_rte_counts.get(full_name, 0)\n        updated_count = updated_rte_counts.get(full_name, 0)\n\n        if original_count != updated_count:\n            discrepancy_components.append((\n                component_name, original_count, updated_count\n            ))\n\n    if discrepancy_components:\n        # Create the component differences summary.\n        original_summary = [\n            f'{count} {name}' for name, count, _ in discrepancy_components\n        ]\n        updated_summary = [\n            f'{count} {name}' for name, _, count in discrepancy_components\n        ]\n\n        original_summary_text = (\n            f'Components in original text: {\", \".join(original_summary)}.'\n        )\n        updated_summary_text = (\n            f'Components in translated text: {\", \".join(updated_summary)}.'\n        )\n\n        # Get truncated versions of both original and translated\n        # text for the error message.\n        original_text_preview, translation_text_preview = (\n            highlight_differences(\n                original_text_html,\n                translation_html,\n                truncation_limit=MAX_CONTENT_LENGTH_WITHOUT_TRUNCATION\n            )\n        )\n\n        # Raise the error with detailed information.\n        raise utils.InvalidInputException(\n            f'{original_summary_text} {updated_summary_text}\\n'\n            f'Original text preview: {original_text_preview}\\n'\n            f'Translated text preview: {translation_text_preview}'\n        )\n\n    # Store the full translation HTML without truncation.\n    suggestion.change_cmd.translation_html = (\n        html_cleaner.clean(translation_html)\n        if isinstance(translation_html, str)\n        else translation_html\n    )\n    suggestion.edited_by_reviewer = True\n    suggestion.pre_update_validate(suggestion.change_cmd)\n    _update_suggestion(suggestion)\n\n\ndef update_question_suggestion(\n    suggestion_id: str,\n    skill_difficulty: float,\n    question_state_data: state_domain.StateDict,\n    next_content_id_index: int\n) -> Optional[suggestion_registry.BaseSuggestion]:\n    \"\"\"Updates skill_difficulty and question_state_data of a suggestion with\n    the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        skill_difficulty: double. The difficulty level of the question.\n        question_state_data: obj. Details of the question.\n        next_content_id_index: int. The next content Id index for the question's\n            content.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n\n    Raises:\n        Exception. Expected SuggestionAddQuestion suggestion but found\n            different suggestion.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not isinstance(\n        suggestion, suggestion_registry.SuggestionAddQuestion\n    ):\n        raise Exception(\n            'Expected SuggestionAddQuestion suggestion but found: %s.'\n            % type(suggestion).__name__\n        )\n    question_dict = suggestion.change_cmd.question_dict\n    new_change_obj = (\n        question_domain.CreateNewFullySpecifiedQuestionSuggestionCmd(\n            {\n                'cmd': suggestion.change_cmd.cmd,\n                'question_dict': {\n                    'question_state_data': question_state_data,\n                    'language_code': question_dict['language_code'],\n                    'question_state_data_schema_version': (\n                        question_dict[\n                            'question_state_data_schema_version']),\n                    'linked_skill_ids': question_dict['linked_skill_ids'],\n                    'inapplicable_skill_misconception_ids': (\n                        suggestion.change_cmd.question_dict[\n                            'inapplicable_skill_misconception_ids']),\n                    'next_content_id_index': next_content_id_index\n                },\n                'skill_id': suggestion.change_cmd.skill_id,\n                'skill_difficulty': skill_difficulty\n            }\n        )\n    )\n    suggestion.pre_update_validate(new_change_obj)\n    suggestion.edited_by_reviewer = True\n    suggestion.change_cmd = new_change_obj\n\n    _update_suggestion(suggestion)\n\n    return suggestion\n\n\ndef _create_translation_review_stats_from_model(\n    translation_review_stats_model: (\n        suggestion_models.TranslationReviewStatsModel\n    )\n) -> suggestion_registry.TranslationReviewStats:\n    \"\"\"Creates a domain object representing the supplied\n    TranslationReviewStatsModel.\n\n    Args:\n        translation_review_stats_model: TranslationReviewStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        TranslationReviewStats. The corresponding TranslationReviewStats domain\n        object.\n    \"\"\"\n    return suggestion_registry.TranslationReviewStats(\n        translation_review_stats_model.language_code,\n        translation_review_stats_model.reviewer_user_id,\n        translation_review_stats_model.topic_id,\n        translation_review_stats_model.reviewed_translations_count,\n        translation_review_stats_model.reviewed_translation_word_count,\n        translation_review_stats_model.accepted_translations_count,\n        translation_review_stats_model.accepted_translation_word_count,\n        (\n            translation_review_stats_model\n            .accepted_translations_with_reviewer_edits_count),\n        translation_review_stats_model.first_contribution_date,\n        translation_review_stats_model.last_contribution_date\n    )\n\n\ndef _create_question_contribution_stats_from_model(\n    question_contribution_stats_model: (\n        suggestion_models.QuestionContributionStatsModel\n    )\n) -> suggestion_registry.QuestionContributionStats:\n    \"\"\"Creates a domain object representing the supplied\n    QuestionContributionStatsModel.\n\n    Args:\n        question_contribution_stats_model: QuestionContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        QuestionContributionStats. The corresponding QuestionContributionStats\n        domain object.\n    \"\"\"\n    return suggestion_registry.QuestionContributionStats(\n        question_contribution_stats_model.contributor_user_id,\n        question_contribution_stats_model.topic_id,\n        question_contribution_stats_model.submitted_questions_count,\n        question_contribution_stats_model.accepted_questions_count,\n        (\n            question_contribution_stats_model\n            .accepted_questions_without_reviewer_edits_count),\n        question_contribution_stats_model.first_contribution_date,\n        question_contribution_stats_model.last_contribution_date\n    )\n\n\ndef _create_question_review_stats_from_model(\n    question_review_stats_model: (\n        suggestion_models.QuestionReviewStatsModel\n    )\n) -> suggestion_registry.QuestionReviewStats:\n    \"\"\"Creates a domain object representing the supplied\n    QuestionReviewStatsModel.\n\n    Args:\n        question_review_stats_model: QuestionReviewStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        QuestionReviewStats. The corresponding QuestionReviewStats domain\n        object.\n    \"\"\"\n    return suggestion_registry.QuestionReviewStats(\n        question_review_stats_model.reviewer_user_id,\n        question_review_stats_model.topic_id,\n        question_review_stats_model.reviewed_questions_count,\n        question_review_stats_model.accepted_questions_count,\n        (\n            question_review_stats_model\n            .accepted_questions_with_reviewer_edits_count),\n        question_review_stats_model.first_contribution_date,\n        question_review_stats_model.last_contribution_date\n    )\n\n\ndef get_all_translation_review_stats(\n    user_id: str\n) -> List[suggestion_registry.TranslationReviewStats]:\n    \"\"\"Gets all TranslationReviewStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(TranslationReviewStats). TranslationReviewStats domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    translation_review_stats_models = (\n        suggestion_models.TranslationReviewStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_translation_review_stats_from_model(model)\n        for model in translation_review_stats_models\n    ]\n\n\ndef get_all_question_contribution_stats(\n    user_id: str\n) -> List[suggestion_registry.QuestionContributionStats]:\n    \"\"\"Gets all QuestionContributionStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(QuestionContributionStats). QuestionContributionStats domain\n        objects corresponding to the supplied user.\n    \"\"\"\n    question_contribution_stats_models = (\n        suggestion_models.QuestionContributionStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_question_contribution_stats_from_model(model)\n        for model in question_contribution_stats_models\n    ]\n\n\ndef get_all_question_review_stats(\n    user_id: str\n) -> List[suggestion_registry.QuestionReviewStats]:\n    \"\"\"Gets all QuestionReviewStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(QuestionReviewStats). QuestionReviewStats domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    question_review_stats_models = (\n        suggestion_models.QuestionReviewStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_question_review_stats_from_model(model)\n        for model in question_review_stats_models\n    ]\n\n\n# TODO(#16019): Pre-fetching and caching of stats data should be done.\ndef get_all_contributor_stats(\n    user_id: str\n) -> suggestion_registry.ContributorStatsSummary:\n    \"\"\"Gets ContributorStatsSummary corresponding to the supplied user.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        ContributorStatsSummary. ContributorStatsSummary domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    translation_contribution_stats = get_all_translation_contribution_stats(\n        user_id)\n    translation_review_stats = get_all_translation_review_stats(user_id)\n    question_contribution_stats = get_all_question_contribution_stats(user_id)\n    question_review_stats = get_all_question_review_stats(user_id)\n\n    return suggestion_registry.ContributorStatsSummary(\n        user_id,\n        translation_contribution_stats,\n        question_contribution_stats,\n        translation_review_stats,\n        question_review_stats)\n\n\ndef _update_translation_contribution_stats_models(\n    translation_contribution_stats: List[\n        suggestion_registry.TranslationContributionStats\n    ]\n) -> None:\n    \"\"\"Updates TranslationContributionStatsModel models for given translation\n    contribution stats.\n\n    Args:\n        translation_contribution_stats: list(TranslationContributionStats).\n            A list of TranslationContributionStats domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in translation_contribution_stats:\n        stat_id = (\n            suggestion_models.TranslationContributionStatsModel.construct_id(\n                stat.language_code,\n                stat.contributor_user_id,\n                stat.topic_id)\n        )\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_translation_contribution_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.TranslationContributionStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.submitted_translations_count = (\n            stat.submitted_translations_count)\n        stats_model.submitted_translation_word_count = (\n            stat.submitted_translation_word_count)\n        stats_model.accepted_translations_count = (\n            stat.accepted_translations_count)\n        stats_model.accepted_translations_without_reviewer_edits_count = (\n            stat.accepted_translations_without_reviewer_edits_count)\n        stats_model.accepted_translation_word_count = (\n            stat.accepted_translation_word_count)\n        stats_model.rejected_translations_count = (\n            stat.rejected_translations_count)\n        stats_model.rejected_translation_word_count = (\n            stat.rejected_translation_word_count)\n        stats_model.contribution_dates = sorted(stat.contribution_dates)\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.TranslationContributionStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.TranslationContributionStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_translation_review_stats_models(\n    translation_review_stats: List[\n        suggestion_registry.TranslationReviewStats\n    ]\n) -> None:\n    \"\"\"Updates TranslationReviewStatsModel models for given translation\n    review stats.\n\n    Args:\n        translation_review_stats: list(TranslationReviewStats). A list of\n            TranslationReviewStats domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in translation_review_stats:\n        stat_id = suggestion_models.TranslationReviewStatsModel.construct_id(\n            stat.language_code, stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_translation_review_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.TranslationReviewStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.reviewed_translations_count = (\n            stat.reviewed_translations_count)\n        stats_model.reviewed_translation_word_count = (\n            stat.reviewed_translation_word_count)\n        stats_model.accepted_translations_count = (\n            stat.accepted_translations_count)\n        stats_model.accepted_translation_word_count = (\n            stat.accepted_translation_word_count)\n        stats_model.accepted_translations_with_reviewer_edits_count = (\n            stat.accepted_translations_with_reviewer_edits_count)\n        stats_model.first_contribution_date = (\n            stat.first_contribution_date)\n        stats_model.last_contribution_date = (\n            stat.last_contribution_date)\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.TranslationReviewStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.TranslationReviewStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_question_contribution_stats_models(\n    question_contribution_stats: List[\n        suggestion_registry.QuestionContributionStats\n    ]\n) -> None:\n    \"\"\"Updates QuestionContributionStatsModel models for given question\n    contribution stats.\n\n    Args:\n        question_contribution_stats: list(QuestionContributionStats). A list of\n            QuestionContribution domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in question_contribution_stats:\n        stat_id = suggestion_models.QuestionContributionStatsModel.construct_id(\n            stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_question_contribution_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.QuestionContributionStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.submitted_questions_count = (\n            stat.submitted_questions_count)\n        stats_model.accepted_questions_count = (\n            stat.accepted_questions_count)\n        stats_model.accepted_questions_without_reviewer_edits_count = (\n            stat.accepted_questions_without_reviewer_edits_count)\n        stats_model.first_contribution_date = stat.first_contribution_date\n        stats_model.last_contribution_date = stat.last_contribution_date\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.QuestionContributionStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.QuestionContributionStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_question_review_stats_models(\n    question_review_stats: List[\n        suggestion_registry.QuestionReviewStats\n    ]\n) -> None:\n    \"\"\"Updates QuestionReviewStatsModel models for given question\n    review stats.\n\n    Args:\n        question_review_stats: list(QuestionReviewStats). A list of\n            QuestionReviewStats domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in question_review_stats:\n        stat_id = suggestion_models.QuestionReviewStatsModel.construct_id(\n            stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_question_review_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.QuestionReviewStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.reviewed_questions_count = (\n            stat.reviewed_questions_count)\n        stats_model.accepted_questions_count = (\n            stat.accepted_questions_count)\n        stats_model.accepted_questions_with_reviewer_edits_count = (\n            stat.accepted_questions_with_reviewer_edits_count)\n        stats_model.first_contribution_date = stat.first_contribution_date\n        stats_model.last_contribution_date = stat.last_contribution_date\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.QuestionReviewStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.QuestionReviewStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_translation_submitter_total_stats_model(\n    translation_submitter_total_stats:\n        suggestion_registry.TranslationSubmitterTotalContributionStats\n) -> None:\n    \"\"\"Updates TranslationSubmitterTotalContributionStats\n    model for given translation submitter stats.\n\n    Args:\n        translation_submitter_total_stats:\n            TranslationSubmitterTotalContributionStats.\n            TranslationSubmitterTotalContributionStats domain object.\n\n    Raises:\n        Exception. Language is None.\n        Exception. Contributor user ID is None.\n    \"\"\"\n\n    stats_model = suggestion_models.TranslationSubmitterTotalContributionStatsModel.get( # pylint: disable=line-too-long\n            translation_submitter_total_stats.language_code,\n            translation_submitter_total_stats.contributor_id)\n\n    # We assert here because we are calling this method only when the model\n    # exists. If model doesn't exist we create a new model in\n    # update_translation_contribution_stats_at_submission or\n    # update_translation_contribution_stats_at_review.\n    assert stats_model is not None\n    stats_model.topic_ids_with_translation_submissions = (\n        translation_submitter_total_stats\n        .topic_ids_with_translation_submissions)\n    stats_model.recent_review_outcomes = (\n        translation_submitter_total_stats.recent_review_outcomes)\n    stats_model.recent_performance = (\n        translation_submitter_total_stats.recent_performance)\n    stats_model.overall_accuracy = (\n        translation_submitter_total_stats.overall_accuracy)\n    stats_model.submitted_translations_count = (\n        translation_submitter_total_stats.submitted_translations_count)\n    stats_model.submitted_translation_word_count = (\n        translation_submitter_total_stats.submitted_translation_word_count)\n    stats_model.accepted_translations_count = (\n        translation_submitter_total_stats.accepted_translations_count)\n    stats_model.accepted_translations_without_reviewer_edits_count = (\n        translation_submitter_total_stats\n        .accepted_translations_without_reviewer_edits_count)\n    stats_model.accepted_translation_word_count = (\n        translation_submitter_total_stats.accepted_translation_word_count)\n    stats_model.rejected_translations_count = (\n        translation_submitter_total_stats.rejected_translations_count)\n    stats_model.rejected_translation_word_count = (\n        translation_submitter_total_stats.rejected_translation_word_count)\n    stats_model.first_contribution_date = (\n        translation_submitter_total_stats.first_contribution_date)\n    stats_model.last_contribution_date = (\n        translation_submitter_total_stats.last_contribution_date)\n\n    suggestion_models.TranslationSubmitterTotalContributionStatsModel.update_timestamps( # pylint: disable=line-too-long\n        stats_model,\n        update_last_updated_time=True)\n    suggestion_models.TranslationSubmitterTotalContributionStatsModel.put(\n        stats_model)\n\n\ndef _update_translation_reviewer_total_stats_models(\n    translation_reviewer_total_stat:\n        suggestion_registry.TranslationReviewerTotalContributionStats\n) -> None:\n    \"\"\"Updates TranslationReviewerTotalContributionStats\n    models for given translation review stats.\n\n    Args:\n        translation_reviewer_total_stat:\n            TranslationReviewerTotalContributionStats.\n            TranslationReviewerTotalContributionStats domain object.\n    \"\"\"\n\n    stats_model = suggestion_models.TranslationReviewerTotalContributionStatsModel.get( # pylint: disable=line-too-long\n        translation_reviewer_total_stat.language_code,\n        translation_reviewer_total_stat.contributor_id)\n\n    # We assert here because we are calling this method only when the model\n    # exists. If model doesn't exist we create a new model in\n    # update_translation_review_stats.\n    assert stats_model is not None\n    stats_model.topic_ids_with_translation_reviews = (\n        translation_reviewer_total_stat.topic_ids_with_translation_reviews)\n    stats_model.reviewed_translations_count = (\n        translation_reviewer_total_stat.reviewed_translations_count)\n    stats_model.accepted_translations_count = (\n        translation_reviewer_total_stat.accepted_translations_count)\n    stats_model.accepted_translations_with_reviewer_edits_count = (\n        translation_reviewer_total_stat\n        .accepted_translations_with_reviewer_edits_count)\n    stats_model.accepted_translation_word_count = (\n        translation_reviewer_total_stat.accepted_translation_word_count)\n    stats_model.rejected_translations_count = (\n        translation_reviewer_total_stat.rejected_translations_count)\n    stats_model.first_contribution_date = (\n        translation_reviewer_total_stat.first_contribution_date)\n    stats_model.last_contribution_date = (\n        translation_reviewer_total_stat.last_contribution_date)\n\n    suggestion_models.TranslationReviewerTotalContributionStatsModel.update_timestamps( # pylint: disable=line-too-long\n        stats_model,\n        update_last_updated_time=True)\n    suggestion_models.TranslationReviewerTotalContributionStatsModel.put(\n        stats_model)\n\n\ndef _update_question_submitter_total_stats_models(\n    question_submitter_total_stats:\n        suggestion_registry.QuestionSubmitterTotalContributionStats\n) -> None:\n    \"\"\"Updates QuestionSubmitterTotalContributionStatsModel for given question\n    contribution stats.\n\n    Args:\n        question_submitter_total_stats: QuestionSubmitterTotalContributionStats.\n            A QuestionSubmitterTotalContributionStats domain object.\n    \"\"\"\n    stats_model = suggestion_models.QuestionSubmitterTotalContributionStatsModel.get( # pylint: disable=line-too-long\n            question_submitter_total_stats.contributor_id)\n    stats_model.topic_ids_with_question_submissions = (\n        question_submitter_total_stats.topic_ids_with_question_submissions)\n    stats_model.recent_review_outcomes = (\n        question_submitter_total_stats.recent_review_outcomes)\n    stats_model.recent_performance = (\n        question_submitter_total_stats.recent_performance)\n    stats_model.overall_accuracy = (\n        question_submitter_total_stats.overall_accuracy)\n    stats_model.submitted_questions_count = (\n        question_submitter_total_stats.submitted_questions_count)\n    stats_model.accepted_questions_count = (\n        question_submitter_total_stats.accepted_questions_count)\n    stats_model.accepted_questions_without_reviewer_edits_count = (\n        question_submitter_total_stats\n        .accepted_questions_without_reviewer_edits_count)\n    stats_model.rejected_questions_count = (\n        question_submitter_total_stats.rejected_questions_count)\n    stats_model.first_contribution_date = (\n        question_submitter_total_stats.first_contribution_date)\n    stats_model.last_contribution_date = (\n        question_submitter_total_stats.last_contribution_date)\n\n    suggestion_models.QuestionSubmitterTotalContributionStatsModel.update_timestamps( # pylint: disable=line-too-long\n        stats_model,\n        update_last_updated_time=True)\n    suggestion_models.QuestionSubmitterTotalContributionStatsModel.put(\n        stats_model)\n\n\ndef _update_question_reviewer_total_stats_models(\n    question_reviewer_total_stats:\n        suggestion_registry.QuestionReviewerTotalContributionStats\n) -> None:\n    \"\"\"Updates QuestionReviewerTotalContributionStatsModel for given question\n    contribution stats.\n\n    Args:\n        question_reviewer_total_stats: QuestionReviewerTotalContributionStats.\n            A QuestionreviewerTotalContributionStats domain object.\n    \"\"\"\n    stats_model = suggestion_models.QuestionReviewerTotalContributionStatsModel.get( # pylint: disable=line-too-long\n            question_reviewer_total_stats.contributor_id)\n    stats_model.topic_ids_with_question_reviews = (\n        question_reviewer_total_stats.topic_ids_with_question_reviews)\n    stats_model.reviewed_questions_count = (\n        question_reviewer_total_stats.reviewed_questions_count)\n    stats_model.accepted_questions_count = (\n        question_reviewer_total_stats.accepted_questions_count)\n    stats_model.accepted_questions_with_reviewer_edits_count = (\n        question_reviewer_total_stats\n        .accepted_questions_with_reviewer_edits_count)\n    stats_model.rejected_questions_count = (\n        question_reviewer_total_stats.rejected_questions_count)\n    stats_model.first_contribution_date = (\n        question_reviewer_total_stats.first_contribution_date)\n    stats_model.last_contribution_date = (\n        question_reviewer_total_stats.last_contribution_date)\n\n    suggestion_models.QuestionReviewerTotalContributionStatsModel.update_timestamps( # pylint: disable=line-too-long\n        stats_model,\n        update_last_updated_time=True)\n    suggestion_models.QuestionReviewerTotalContributionStatsModel.put(\n        stats_model)\n\n\ndef update_translation_contribution_stats_at_submission(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationContributionStatsModel and\n    TranslationSubmitterTotalContributionStatsModel model for\n    given translation submitter when a translation is submitted.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            submitted.\n    \"\"\"\n    content_word_count = 0\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n\n    if isinstance(suggestion.change_cmd.translation_html, list):\n        for content in suggestion.change_cmd.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change_cmd.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    translation_contribution_stat_model = (\n        suggestion_models.TranslationContributionStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.author_id, topic_id\n        ))\n\n    translation_submitter_total_stat_model = (\n        suggestion_models.TranslationSubmitterTotalContributionStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.author_id\n        )\n    )\n\n    if translation_submitter_total_stat_model is None:\n        suggestion_models.TranslationSubmitterTotalContributionStatsModel.create( # pylint: disable=line-too-long\n            language_code=suggestion.change_cmd.language_code,\n            contributor_id=suggestion.author_id,\n            topic_ids_with_translation_submissions=[topic_id],\n            recent_review_outcomes=[],\n            recent_performance=0,\n            overall_accuracy=0.0,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=0,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=0,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            first_contribution_date=suggestion.last_updated.date(),\n            last_contribution_date=suggestion.last_updated.date()\n        )\n    else:\n        translation_submitter_total_stat = (\n            contribution_stats_services\n            .get_translation_submitter_total_stats_from_model(\n                translation_submitter_total_stat_model\n             )\n         )\n\n        if topic_id not in (\n            translation_submitter_total_stat\n            .topic_ids_with_translation_submissions):\n            (\n                translation_submitter_total_stat\n                .topic_ids_with_translation_submissions).append(topic_id)\n        translation_submitter_total_stat.submitted_translations_count += 1\n        translation_submitter_total_stat.submitted_translation_word_count += (\n            content_word_count)\n        translation_submitter_total_stat.last_contribution_date = (\n            suggestion.last_updated.date())\n\n        _update_translation_submitter_total_stats_model(\n            translation_submitter_total_stat)\n\n    if translation_contribution_stat_model is None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=suggestion.change_cmd.language_code,\n            contributor_user_id=suggestion.author_id,\n            topic_id=topic_id,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=0,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=0,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[suggestion.last_updated.date()]\n        )\n    else:\n        translation_contribution_stat = (\n            create_translation_contribution_stats_from_model(\n                translation_contribution_stat_model))\n\n        translation_contribution_stat.submitted_translations_count += 1\n        translation_contribution_stat.submitted_translation_word_count += (\n            content_word_count)\n        translation_contribution_stat.contribution_dates.add(\n            suggestion.last_updated.date())\n\n        _update_translation_contribution_stats_models(\n            [translation_contribution_stat])\n\n\ndef create_stats_for_new_translation_models(\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool,\n    content_word_count: int\n) -> Tuple[int, int, int, int, int, List[str], int, float]:\n    \"\"\"Creates stats data to be used to create a new\n    TranslationContributionStatsModel and\n    TranslationSubmitterTotalContributionStatsModel.\n\n    Args:\n        suggestion_is_accepted: bool. Whether the suggestion is\n            accepted or rejected.\n        edited_by_reviewer: bool. If the suggestion is accepted with\n            reviewers edits.\n        content_word_count: int. Word count of the suggestion.\n\n    Returns:\n        tuple[int, int, int, int, int, list[str], int, float]. A tuple\n        consisting of the stats data required to create a new model.\n    \"\"\"\n    accepted_translations_count = 0\n    accepted_translation_word_count = 0\n    rejected_translations_count = 0\n    rejected_translation_word_count = 0\n    accepted_translations_without_reviewer_edits_count = 0\n\n    if suggestion_is_accepted:\n        accepted_translations_count += 1\n        accepted_translation_word_count += content_word_count\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED_WITH_EDITS]\n        recent_performance = 1\n        overall_accuracy = 100.0\n    else:\n        rejected_translations_count += 1\n        rejected_translation_word_count += content_word_count\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_REJECTED]\n        recent_performance = -2\n        overall_accuracy = 0.0\n    if suggestion_is_accepted and not edited_by_reviewer:\n        accepted_translations_without_reviewer_edits_count += 1\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED]\n\n    return (\n        accepted_translations_count,\n        accepted_translation_word_count,\n        rejected_translations_count,\n        rejected_translation_word_count,\n        accepted_translations_without_reviewer_edits_count,\n        recent_review_outcomes,\n        recent_performance,\n        overall_accuracy\n    )\n\n\ndef update_translation_contribution_stats_at_review(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationContributionStatsModel and\n    TranslationSubmitterTotalContributionStatsModel model for\n    given translation submitter when a translation is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n    \"\"\"\n    content_word_count = 0\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n\n    if isinstance(suggestion.change_cmd.translation_html, list):\n        for content in suggestion.change_cmd.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change_cmd.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    translation_contribution_stat_model = (\n        suggestion_models.TranslationContributionStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.author_id, topic_id\n        ))\n\n    translation_submitter_total_stat_model = (\n        suggestion_models.TranslationSubmitterTotalContributionStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.author_id\n        ))\n\n    if translation_submitter_total_stat_model is None:\n        (\n            accepted_translations_count,\n            accepted_translation_word_count,\n            rejected_translations_count,\n            rejected_translation_word_count,\n            accepted_translations_without_reviewer_edits_count,\n            recent_review_outcomes,\n            recent_performance,\n            overall_accuracy\n        ) = create_stats_for_new_translation_models(\n            suggestion_is_accepted,\n            suggestion.edited_by_reviewer,\n            content_word_count)\n        suggestion_models.TranslationSubmitterTotalContributionStatsModel.create( # pylint: disable=line-too-long\n            language_code=suggestion.change_cmd.language_code,\n            contributor_id=suggestion.author_id,\n            topic_ids_with_translation_submissions=[topic_id],\n            recent_review_outcomes=recent_review_outcomes,\n            recent_performance=recent_performance,\n            overall_accuracy=overall_accuracy,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_without_reviewer_edits_count=(\n                accepted_translations_without_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translations_count,\n            rejected_translation_word_count=rejected_translation_word_count,\n            first_contribution_date=suggestion.last_updated.date(),\n            last_contribution_date=suggestion.last_updated.date()\n        )\n    else:\n        translation_submitter_total_stat = (\n            contribution_stats_services\n            .get_translation_submitter_total_stats_from_model(\n                translation_submitter_total_stat_model)\n        )\n\n        if topic_id not in (\n            translation_submitter_total_stat\n            .topic_ids_with_translation_submissions):\n            (\n                translation_submitter_total_stat\n                .topic_ids_with_translation_submissions).append(topic_id)\n\n        increment_translation_submitter_total_stats_at_review(\n            translation_submitter_total_stat, content_word_count,\n            suggestion_is_accepted, suggestion.edited_by_reviewer)\n        _update_translation_submitter_total_stats_model(\n            translation_submitter_total_stat)\n\n    if translation_contribution_stat_model is None:\n        (\n            accepted_translations_count,\n            accepted_translation_word_count,\n            rejected_translations_count,\n            rejected_translation_word_count,\n            accepted_translations_without_reviewer_edits_count,\n            recent_review_outcomes,\n            recent_performance,\n            overall_accuracy\n        ) = create_stats_for_new_translation_models(\n            suggestion_is_accepted,\n            suggestion.edited_by_reviewer,\n            content_word_count)\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=suggestion.change_cmd.language_code,\n            contributor_user_id=suggestion.author_id,\n            topic_id=topic_id,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_without_reviewer_edits_count=(\n                accepted_translations_without_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translations_count,\n            rejected_translation_word_count=rejected_translation_word_count,\n            contribution_dates=[suggestion.last_updated.date()]\n        )\n    else:\n        translation_contribution_stat = (\n            create_translation_contribution_stats_from_model(\n                translation_contribution_stat_model))\n\n        increment_translation_contribution_stats_at_review(\n            translation_contribution_stat, content_word_count,\n            suggestion_is_accepted, suggestion.edited_by_reviewer)\n        _update_translation_contribution_stats_models(\n            [translation_contribution_stat])\n\n\ndef update_translation_review_stats(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationReviewStatsModel\n    TranslationReviewerTotalContributionStatsModel model for given translation\n    reviewer when a translation is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n\n    Raises:\n        Exception. The final_reviewer_id of the suggestion should not be None.\n    \"\"\"\n    content_word_count = 0\n    if suggestion.final_reviewer_id is None:\n        raise Exception(\n            'The final_reviewer_id in the suggestion should not be None.'\n        )\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    if isinstance(suggestion.change_cmd.translation_html, list):\n        for content in suggestion.change_cmd.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change_cmd.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    translation_review_stat_model = (\n        # This function is called when reviewing a translation and hence\n        # final_reviewer_id should not be None when the suggestion is\n        # up-to-date.\n        suggestion_models.TranslationReviewStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.final_reviewer_id,\n            topic_id\n        ))\n\n    translation_reviewer_total_stat_model = (\n        suggestion_models.TranslationReviewerTotalContributionStatsModel.get(\n            suggestion.change_cmd.language_code, suggestion.final_reviewer_id\n        ))\n\n    if translation_reviewer_total_stat_model is None:\n        # This function is called when reviewing a translation and hence\n        # final_reviewer_id should not be None when the suggestion is\n        # up-to-date.\n        accepted_translations_count = 0\n        accepted_translations_with_reviewer_edits_count = 0\n        rejected_translation_count = 0\n        accepted_translation_word_count = 0\n        if suggestion_is_accepted:\n            accepted_translations_count += 1\n            accepted_translation_word_count = content_word_count\n        else:\n            rejected_translation_count += 1\n        if suggestion_is_accepted and suggestion.edited_by_reviewer:\n            accepted_translations_with_reviewer_edits_count += 1\n        suggestion_models.TranslationReviewerTotalContributionStatsModel.create(\n            language_code=suggestion.change_cmd.language_code,\n            contributor_id=suggestion.final_reviewer_id,\n            topic_ids_with_translation_reviews=[topic_id],\n            reviewed_translations_count=1,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_with_reviewer_edits_count=(\n                accepted_translations_with_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translation_count,\n            first_contribution_date=suggestion.last_updated.date(),\n            last_contribution_date=suggestion.last_updated.date()\n        )\n    else:\n        translation_reviewer_total_stat = (\n            contribution_stats_services\n            .get_translation_reviewer_total_stats_from_model(\n                translation_reviewer_total_stat_model))\n\n        if topic_id not in (\n            translation_reviewer_total_stat\n            .topic_ids_with_translation_reviews):\n            (\n                translation_reviewer_total_stat\n                .topic_ids_with_translation_reviews\n            ).append(topic_id)\n\n        increment_translation_reviewer_total_stats(\n            translation_reviewer_total_stat, content_word_count,\n            suggestion.last_updated, suggestion_is_accepted,\n            suggestion.edited_by_reviewer\n        )\n        _update_translation_reviewer_total_stats_models(\n            translation_reviewer_total_stat)\n\n    if translation_review_stat_model is None:\n        # This function is called when reviewing a translation and hence\n        # final_reviewer_id should not be None when the suggestion is\n        # up-to-date.\n        accepted_translations_count = 0\n        accepted_translations_with_reviewer_edits_count = 0\n        accepted_translation_word_count = 0\n        if suggestion_is_accepted:\n            accepted_translations_count += 1\n            accepted_translation_word_count = content_word_count\n        if suggestion_is_accepted and suggestion.edited_by_reviewer:\n            accepted_translations_with_reviewer_edits_count += 1\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code=suggestion.change_cmd.language_code,\n            reviewer_user_id=suggestion.final_reviewer_id,\n            topic_id=topic_id,\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=content_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_with_reviewer_edits_count=(\n                accepted_translations_with_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            first_contribution_date=suggestion.last_updated.date(),\n            last_contribution_date=suggestion.last_updated.date()\n        )\n    else:\n        translation_review_stat = (\n            _create_translation_review_stats_from_model(\n                translation_review_stat_model))\n\n        increment_translation_review_stats(\n            translation_review_stat, content_word_count,\n            suggestion.last_updated, suggestion_is_accepted,\n            suggestion.edited_by_reviewer\n        )\n        _update_translation_review_stats_models([translation_review_stat])\n\n    update_translation_contribution_stats_at_review(suggestion)\n\n\ndef update_question_contribution_stats_at_submission(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionContributionStatsModel and\n    QuestionSubmitterTotalContributionStatsModel models for given question\n    submitter when a question is submitted.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            submitted.\n    \"\"\"\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_contribution_stat_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                suggestion.author_id, topic.topic_id\n            ))\n\n        if question_contribution_stat_model is None:\n            suggestion_models.QuestionContributionStatsModel.create(\n                contributor_user_id=suggestion.author_id,\n                topic_id=topic.topic_id,\n                submitted_questions_count=1,\n                accepted_questions_count=0,\n                accepted_questions_without_reviewer_edits_count=0,\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_contribution_stat = (\n            _create_question_contribution_stats_from_model(\n                question_contribution_stat_model))\n\n        question_contribution_stat.submitted_questions_count += 1\n        question_contribution_stat.last_contribution_date = (\n            suggestion.last_updated.date())\n        _update_question_contribution_stats_models(\n            [question_contribution_stat])\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_submitter_total_stat_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                suggestion.author_id\n            ))\n\n        if question_submitter_total_stat_model is None:\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel.create( # pylint: disable=line-too-long\n                contributor_id=suggestion.author_id,\n                topic_ids_with_question_submissions=[topic.topic_id],\n                recent_review_outcomes=[],\n                recent_performance=0,\n                overall_accuracy=0.0,\n                submitted_questions_count=1,\n                accepted_questions_count=0,\n                accepted_questions_without_reviewer_edits_count=0,\n                rejected_questions_count=0,\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_submitter_total_stat = (\n            contribution_stats_services\n            .get_question_submitter_total_stats_from_model(\n                question_submitter_total_stat_model))\n\n        if topic.topic_id not in (\n            question_submitter_total_stat\n            .topic_ids_with_question_submissions):\n            (\n                question_submitter_total_stat\n                .topic_ids_with_question_submissions\n            ).append(topic.topic_id)\n        question_submitter_total_stat.submitted_questions_count += 1\n        question_submitter_total_stat.last_contribution_date = (\n            suggestion.last_updated.date())\n\n        _update_question_submitter_total_stats_models(\n            question_submitter_total_stat)\n\n\ndef update_question_contribution_stats_at_review(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionContributionStatsModel\n    QuestionSubmitterTotalContributionStatsModel models for given question\n    submitter when a question is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n    \"\"\"\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    accepted_questions_count = 0\n    accepted_questions_without_reviewer_edits_count = 0\n    rejected_questions_count = 0\n    if suggestion_is_accepted:\n        accepted_questions_count += 1\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED_WITH_EDITS]\n        recent_performance = 1\n        overall_accuracy = 100.0\n    else:\n        rejected_questions_count += 1\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_REJECTED]\n        recent_performance = -2\n        overall_accuracy = 0.0\n    if suggestion_is_accepted and not suggestion.edited_by_reviewer:\n        accepted_questions_without_reviewer_edits_count += 1\n        recent_review_outcomes = [\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED]\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_contribution_stat_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                suggestion.author_id, topic.topic_id\n            ))\n\n        if question_contribution_stat_model is None:\n            suggestion_models.QuestionContributionStatsModel.create(\n                contributor_user_id=suggestion.author_id,\n                topic_id=topic.topic_id,\n                submitted_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_without_reviewer_edits_count=(\n                    accepted_questions_without_reviewer_edits_count),\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_contribution_stat = (\n            _create_question_contribution_stats_from_model(\n                question_contribution_stat_model))\n\n        if suggestion_is_accepted:\n            question_contribution_stat.accepted_questions_count += 1\n        if suggestion_is_accepted and not suggestion.edited_by_reviewer:\n            (\n                question_contribution_stat\n                .accepted_questions_without_reviewer_edits_count\n            ) += 1\n        _update_question_contribution_stats_models(\n            [question_contribution_stat])\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_submitter_total_stat_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                suggestion.author_id\n            ))\n\n        if question_submitter_total_stat_model is None:\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel.create( # pylint: disable=line-too-long\n                contributor_id=suggestion.author_id,\n                topic_ids_with_question_submissions=[topic.topic_id],\n                recent_review_outcomes=recent_review_outcomes,\n                recent_performance=recent_performance,\n                overall_accuracy=overall_accuracy,\n                submitted_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_without_reviewer_edits_count=(\n                    accepted_questions_without_reviewer_edits_count),\n                rejected_questions_count=rejected_questions_count,\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_submitter_total_stat = (\n            contribution_stats_services\n            .get_question_submitter_total_stats_from_model(\n                question_submitter_total_stat_model))\n\n        increment_question_submitter_total_stats_at_review(\n            question_submitter_total_stat,\n            suggestion_is_accepted, suggestion.edited_by_reviewer)\n\n        _update_question_submitter_total_stats_models(\n            question_submitter_total_stat)\n\n\ndef update_question_review_stats(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionReviewStatsModel and\n    QuestionReviewerTotalContributionStatsModel model for given question\n    reviewer when a question is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n\n    Raises:\n        Exception. The final_reviewer_id of the suggestion should not be None.\n    \"\"\"\n    if suggestion.final_reviewer_id is None:\n        raise Exception(\n            'The final_reviewer_id in the suggestion should not be None.'\n        )\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_review_stat_model = (\n            # This function is called when reviewing a question suggestion and\n            # hence final_reviewer_id should not be None when the suggestion is\n            # up-to-date.\n            suggestion_models.QuestionReviewStatsModel.get(\n                suggestion.final_reviewer_id, topic.topic_id\n            ))\n\n        if question_review_stat_model is None:\n            # This function is called when reviewing a question suggestion and\n            # hence final_reviewer_id should not be None when the suggestion is\n            # up-to-date.\n            accepted_questions_count = 0\n            accepted_questions_with_reviewer_edits_count = 0\n            if suggestion_is_accepted:\n                accepted_questions_count += 1\n            if suggestion_is_accepted and suggestion.edited_by_reviewer:\n                accepted_questions_with_reviewer_edits_count += 1\n            suggestion_models.QuestionReviewStatsModel.create(\n                reviewer_user_id=suggestion.final_reviewer_id,\n                topic_id=topic.topic_id,\n                reviewed_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_with_reviewer_edits_count=(\n                    accepted_questions_with_reviewer_edits_count),\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_review_stat = (\n            _create_question_review_stats_from_model(\n                question_review_stat_model))\n\n        increment_question_review_stats(\n            question_review_stat, suggestion.last_updated,\n            suggestion_is_accepted,\n            suggestion.edited_by_reviewer)\n        _update_question_review_stats_models([question_review_stat])\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_reviewer_total_stat_model = (\n            suggestion_models.QuestionReviewerTotalContributionStatsModel\n            .get_by_id(\n                suggestion.final_reviewer_id\n            ))\n\n        if question_reviewer_total_stat_model is None:\n            accepted_questions_count = 0\n            accepted_questions_with_reviewer_edits_count = 0\n            rejected_questions_count = 0\n            if suggestion_is_accepted:\n                accepted_questions_count += 1\n            else:\n                rejected_questions_count += 1\n            if suggestion_is_accepted and suggestion.edited_by_reviewer:\n                accepted_questions_with_reviewer_edits_count += 1\n            suggestion_models.QuestionReviewerTotalContributionStatsModel.create( # pylint: disable=line-too-long\n                contributor_id=suggestion.final_reviewer_id,\n                topic_ids_with_question_reviews=[topic.topic_id],\n                reviewed_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_with_reviewer_edits_count=(\n                    accepted_questions_with_reviewer_edits_count),\n                rejected_questions_count=rejected_questions_count,\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_reviewer_total_stat = (\n            contribution_stats_services\n            .get_question_reviewer_total_stats_from_model(\n                question_reviewer_total_stat_model))\n\n        if topic.topic_id not in (\n            question_reviewer_total_stat\n            .topic_ids_with_question_reviews):\n            (\n                question_reviewer_total_stat\n                .topic_ids_with_question_reviews\n            ).append(topic.topic_id)\n\n        increment_question_reviewer_total_stats(\n            question_reviewer_total_stat, suggestion.last_updated,\n            suggestion_is_accepted,\n            suggestion.edited_by_reviewer)\n        _update_question_reviewer_total_stats_models(\n            question_reviewer_total_stat)\n\n    update_question_contribution_stats_at_review(suggestion)\n\n\ndef increment_translation_contribution_stats_at_review(\n    translation_contribution_stat: (\n        suggestion_registry.TranslationContributionStats),\n    content_word_count: int,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationContributionStats object.\n\n    Args:\n        translation_contribution_stat: TranslationContributionStats. The stats\n            object to update.\n        content_word_count: int. The number of words in the translation.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    if suggestion_is_accepted:\n        translation_contribution_stat.accepted_translations_count += 1\n        translation_contribution_stat.accepted_translation_word_count += (\n            content_word_count)\n    else:\n        translation_contribution_stat.rejected_translations_count += 1\n        translation_contribution_stat.rejected_translation_word_count += (\n            content_word_count)\n    if suggestion_is_accepted and not edited_by_reviewer:\n        translation_contribution_stat.accepted_translations_without_reviewer_edits_count += 1 # pylint: disable=line-too-long\n\n\ndef increment_translation_review_stats(\n    translation_review_stat: suggestion_registry.TranslationReviewStats,\n    content_word_count: int,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationReviewStats object.\n\n    Args:\n        translation_review_stat: TranslationReviewStats. The stats\n            object to update.\n        content_word_count: int. The number of words in the translation.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    translation_review_stat.reviewed_translations_count += 1\n    translation_review_stat.reviewed_translation_word_count += (\n        content_word_count)\n    if suggestion_is_accepted:\n        translation_review_stat.accepted_translations_count += 1\n        translation_review_stat.accepted_translation_word_count += (\n            content_word_count)\n    if suggestion_is_accepted and edited_by_reviewer:\n        (\n            translation_review_stat\n            .accepted_translations_with_reviewer_edits_count\n        ) += 1\n    translation_review_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef increment_question_review_stats(\n    question_review_stat: suggestion_registry.QuestionReviewStats,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates QuestionReviewStats object.\n\n    Args:\n        question_review_stat: QuestionReviewStats. The stats object to update.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    question_review_stat.reviewed_questions_count += 1\n    if suggestion_is_accepted:\n        question_review_stat.accepted_questions_count += 1\n    if suggestion_is_accepted and edited_by_reviewer:\n        question_review_stat.accepted_questions_with_reviewer_edits_count += 1\n    question_review_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef increment_translation_submitter_total_stats_at_review(\n    translation_submitter_total_stat: (\n        suggestion_registry.TranslationSubmitterTotalContributionStats),\n    content_word_count: int,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationSubmitterTotalContributionStats object.\n\n    Args:\n        translation_submitter_total_stat:\n            TranslationSubmitterTotalContributionStats. The stats object to\n            update.\n        content_word_count: int. The number of words in the translation.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    # Weights for calculating performance.\n    # recent_performance = accepted cards - 2 (rejected cards) in last\n    # 100 contributions.\n    if suggestion_is_accepted:\n        translation_submitter_total_stat.accepted_translations_count += 1\n        translation_submitter_total_stat.accepted_translation_word_count += (\n            content_word_count)\n        translation_submitter_total_stat.overall_accuracy = round((\n            translation_submitter_total_stat.accepted_translations_count\n            / translation_submitter_total_stat.submitted_translations_count\n        ), 3) * 100\n\n        if (\n                len(translation_submitter_total_stat\n                    .recent_review_outcomes)\n                >= RECENT_REVIEW_OUTCOMES_LIMIT\n            ):\n            oldest_outcome = (\n                translation_submitter_total_stat\n                .recent_review_outcomes).pop(0)\n            if oldest_outcome == suggestion_models.REVIEW_OUTCOME_REJECTED:\n                translation_submitter_total_stat.recent_performance += 3\n        else:\n            translation_submitter_total_stat.recent_performance += 1\n\n        translation_submitter_total_stat.recent_review_outcomes.append(\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED_WITH_EDITS)\n\n    else:\n        translation_submitter_total_stat.rejected_translations_count += 1\n        translation_submitter_total_stat.rejected_translation_word_count += (\n            content_word_count)\n\n        if (\n                len(translation_submitter_total_stat\n                    .recent_review_outcomes)\n                >= RECENT_REVIEW_OUTCOMES_LIMIT\n            ):\n            oldest_outcome = (\n                translation_submitter_total_stat\n                .recent_review_outcomes).pop(0)\n            if oldest_outcome != suggestion_models.REVIEW_OUTCOME_REJECTED:\n                translation_submitter_total_stat.recent_performance -= 3\n        else:\n            translation_submitter_total_stat.recent_performance -= 2\n\n        translation_submitter_total_stat.recent_review_outcomes.append(\n            suggestion_models.REVIEW_OUTCOME_REJECTED)\n\n    if suggestion_is_accepted and not edited_by_reviewer:\n        translation_submitter_total_stat.accepted_translations_without_reviewer_edits_count += 1 # pylint: disable=line-too-long\n        (\n            translation_submitter_total_stat\n            .recent_review_outcomes\n        ).pop()\n        translation_submitter_total_stat.recent_review_outcomes.append(\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED)\n\n\ndef increment_translation_reviewer_total_stats(\n    translation_reviewer_total_stat:\n        suggestion_registry.TranslationReviewerTotalContributionStats,\n    content_word_count: int,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationReviewerTotalContributionStats object.\n\n    Args:\n        translation_reviewer_total_stat:\n            TranslationReviewerTotalContributionStats. The stats object to\n            update.\n        content_word_count: int. The number of words in the translation.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    translation_reviewer_total_stat.reviewed_translations_count += 1\n    if suggestion_is_accepted:\n        translation_reviewer_total_stat.accepted_translations_count += 1\n        translation_reviewer_total_stat.accepted_translation_word_count += (\n            content_word_count)\n    else:\n        translation_reviewer_total_stat.rejected_translations_count += 1\n    if suggestion_is_accepted and edited_by_reviewer:\n        (\n            translation_reviewer_total_stat\n            .accepted_translations_with_reviewer_edits_count\n        ) += 1\n    translation_reviewer_total_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef increment_question_submitter_total_stats_at_review(\n    question_submitter_total_stat: (\n        suggestion_registry.QuestionSubmitterTotalContributionStats),\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates QuestionSubmitterTotalContributionStats object.\n\n    Args:\n        question_submitter_total_stat:\n            QuestionSubmitterTotalContributionStats. The stats object to\n            update.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    # Weights for calculating performance.\n    # recent_performance = accepted cards - 2 (rejected cards) in last\n    # 100 contributions.\n    if suggestion_is_accepted:\n        question_submitter_total_stat.accepted_questions_count += 1\n        question_submitter_total_stat.overall_accuracy = round((\n            question_submitter_total_stat.accepted_questions_count\n            / question_submitter_total_stat.submitted_questions_count\n        ), 3) * 100\n\n        if (\n                len(question_submitter_total_stat\n                    .recent_review_outcomes)\n                >= RECENT_REVIEW_OUTCOMES_LIMIT\n            ):\n            oldest_outcome = (\n                question_submitter_total_stat\n                .recent_review_outcomes).pop(0)\n            if oldest_outcome == suggestion_models.REVIEW_OUTCOME_REJECTED:\n                question_submitter_total_stat.recent_performance += 3\n        else:\n            question_submitter_total_stat.recent_performance += 1\n\n        question_submitter_total_stat.recent_review_outcomes.append(\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED_WITH_EDITS)\n\n    else:\n        question_submitter_total_stat.rejected_questions_count += 1\n\n        if (\n                len(question_submitter_total_stat\n                    .recent_review_outcomes)\n                >= RECENT_REVIEW_OUTCOMES_LIMIT\n            ):\n            oldest_outcome = (\n                question_submitter_total_stat\n                .recent_review_outcomes).pop(0)\n            if oldest_outcome != suggestion_models.REVIEW_OUTCOME_REJECTED:\n                question_submitter_total_stat.recent_performance -= 3\n        else:\n            question_submitter_total_stat.recent_performance -= 2\n\n        question_submitter_total_stat.recent_review_outcomes.append(\n            suggestion_models.REVIEW_OUTCOME_REJECTED)\n\n    if suggestion_is_accepted and not edited_by_reviewer:\n        question_submitter_total_stat.accepted_questions_without_reviewer_edits_count += 1 # pylint: disable=line-too-long\n        (question_submitter_total_stat.recent_review_outcomes).pop()\n        (question_submitter_total_stat.recent_review_outcomes).append(\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED)\n\n\ndef increment_question_reviewer_total_stats(\n    question_reviewer_total_stat:\n        suggestion_registry.QuestionReviewerTotalContributionStats,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates QuestionReviewerTotalContributionStats object.\n\n    Args:\n        question_reviewer_total_stat: QuestionReviewerTotalContributionStats.\n            The stats object to update.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    question_reviewer_total_stat.reviewed_questions_count += 1\n    if suggestion_is_accepted:\n        question_reviewer_total_stat.accepted_questions_count += 1\n    else:\n        question_reviewer_total_stat.rejected_questions_count += 1\n    if suggestion_is_accepted and edited_by_reviewer:\n        (\n            question_reviewer_total_stat\n            .accepted_questions_with_reviewer_edits_count) += 1\n    question_reviewer_total_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef enqueue_contributor_ranking_notification_email_task(\n    contributor_user_id: str, contribution_type: str,\n    contribution_sub_type: str, language_code: str, rank_name: str,\n) -> None:\n    \"\"\"Adds a 'send feedback email' (instant) task into the task queue.\n\n    Args:\n        contributor_user_id: str. The ID of the contributor.\n        contribution_type: str. The type of the contribution i.e.\n            translation or question.\n        contribution_sub_type: str. The sub type of the contribution\n            i.e. submissions/acceptances/reviews/edits.\n        language_code: str. The language code of the suggestion.\n        rank_name: str. The name of the rank that the contributor achieved.\n\n    Raises:\n        Exception. The contribution type must be offered on the Contributor\n            Dashboard.\n        Exception. The contribution subtype must be offered on the Contributor\n            Dashboard.\n    \"\"\"\n    # contributor_user_id is alrerady validated in the controller layer.\n    # TODO(#16062): Rank name should be valid to send notification emails.\n    if language_code not in [language['id'] for language in (\n            constants.SUPPORTED_AUDIO_LANGUAGES)]:\n        raise Exception(\n            'Not supported language code: %s' % language_code)\n    if contribution_type not in [\n        feconf.CONTRIBUTION_TYPE_TRANSLATION,\n        feconf.CONTRIBUTION_TYPE_QUESTION\n    ]:\n        raise Exception(\n            'Invalid contribution type: %s' % contribution_type)\n    if contribution_sub_type not in [\n        feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE,\n        feconf.CONTRIBUTION_SUBTYPE_REVIEW,\n        feconf.CONTRIBUTION_SUBTYPE_EDIT,\n    ]:\n        raise Exception(\n            'Invalid contribution subtype: %s' % contribution_sub_type)\n\n    payload = {\n        'contributor_user_id': contributor_user_id,\n        'contribution_type': contribution_type,\n        'contribution_sub_type': contribution_sub_type,\n        'language_code': language_code,\n        'rank_name': rank_name,\n    }\n\n    taskqueue_services.enqueue_task(\n        feconf.TASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS,\n        payload, 0)\n\n\ndef generate_contributor_certificate_data(\n    username: str,\n    suggestion_type: str,\n    language_code: Optional[str],\n    from_date: datetime.datetime,\n    to_date: datetime.datetime\n) -> Optional[suggestion_registry.ContributorCertificateInfoDict]:\n    \"\"\"Returns data to generate the certificate.\n\n    Args:\n        username: str. The username of the contributor.\n        language_code: str|None. The language for which the contributions should\n            be considered.\n        suggestion_type: str. The type of suggestion that the certificate\n            needs to generate.\n        from_date: datetime.datetime. The start of the date range for which the\n            contributions were created.\n        to_date: datetime.datetime. The end of the date range for which the\n            contributions were created.\n\n    Returns:\n        ContributorCertificateInfoDict|None. Data to generate the certificate,\n        or None if no data is found.\n\n    Raises:\n        Exception. The suggestion type is invalid.\n        Exception. There is no user for the given username.\n    \"\"\"\n    user_id = user_services.get_user_id_from_username(username)\n    if user_id is None:\n        raise Exception('There is no user for the given username.')\n\n    if suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n        # For the suggestion_type translate_content, there should be a\n        # corresponding language_code.\n        assert isinstance(language_code, str)\n        data = _generate_translation_contributor_certificate_data(\n            language_code, from_date, to_date, user_id)\n\n    elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n        data = _generate_question_contributor_certificate_data(\n            from_date, to_date, user_id)\n\n    else:\n        raise Exception('The suggestion type is invalid.')\n\n    return data.to_dict() if data is not None else None\n\n\ndef _generate_translation_contributor_certificate_data(\n    language_code: str,\n    from_date: datetime.datetime,\n    to_date: datetime.datetime,\n    user_id: str\n) -> Optional[suggestion_registry.ContributorCertificateInfo]:\n    \"\"\"Returns data to generate translation submitter certificate.\n\n    Args:\n        language_code: str. The language for which the contributions should\n            be considered.\n        from_date: datetime.datetime. The start of the date range for which\n            the contributions were created.\n        to_date: datetime.datetime. The end of the date range for which\n            the contributions were created.\n        user_id: str. The user ID of the contributor.\n\n    Returns:\n        ContributorCertificateInfo|None. Data to generate translation submitter\n        certificate, or None if no data is found.\n\n    Raises:\n        Exception. The language is invalid.\n    \"\"\"\n    signature = feconf.TRANSLATION_TEAM_LEAD\n\n    # Adds one date to the to_date to make sure the contributions within\n    # the to_date are also counted for the certificate.\n    to_date_to_fetch_contributions = to_date + datetime.timedelta(days=1)\n\n    language = next(filter(\n        lambda lang: lang['id'] == language_code,\n        constants.SUPPORTED_AUDIO_LANGUAGES), None)\n    if language is None:\n        raise Exception('The provided language is invalid.')\n    language_description = language['description']\n    if ' (' in language_description:\n        language_description = language_description[\n            language_description.find('(') + 1:language_description.find(')')]\n\n    suggestions = (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestions_submitted_within_given_dates(\n            from_date,\n            to_date_to_fetch_contributions,\n            user_id,\n            language_code\n        )\n    )\n\n    words_count = 0\n    for model in suggestions:\n        suggestion = get_suggestion_from_model(model)\n        suggestion_change = suggestion.change_cmd\n        data_is_list = (\n            translation_domain.TranslatableContentFormat\n            .is_data_format_list(suggestion_change.data_format)\n        )\n        if (\n                suggestion_change.cmd == 'add_written_translation' and\n                data_is_list\n        ):\n            words_count += sum(\n                len(item.split()) for item in suggestion_change.translation_html\n            )\n        else:\n            # Retrieve the html content that is emphasized on the\n            # Contributor Dashboard pages. This content is what stands\n            # out for each suggestion when a user views a list of\n            # suggestions.\n            get_html_representing_suggestion = (\n                SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n                    suggestion.suggestion_type]\n            )\n            plain_text = _get_plain_text_from_html_content_string(\n                get_html_representing_suggestion(suggestion))\n\n            words = plain_text.split(' ')\n            words_without_empty_strings = [\n                word for word in words if word != '']\n            words_count += len(words_without_empty_strings)\n    # Go to the below link for more information about how we count hours\n    # contributed.# Goto the below link for more information.\n    # https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit?usp=sharing\n    hours_contributed = round(words_count / 300, 2)\n\n    if words_count == 0:\n        return None\n\n    return suggestion_registry.ContributorCertificateInfo(\n        from_date.strftime('%d %b %Y'), to_date.strftime('%d %b %Y'),\n        signature, str(hours_contributed), language_description\n    )\n\n\ndef _generate_question_contributor_certificate_data(\n    from_date: datetime.datetime,\n    to_date: datetime.datetime,\n    user_id: str\n) -> Optional[suggestion_registry.ContributorCertificateInfo]:\n    \"\"\"Returns data to generate question submitter certificate.\n\n    Args:\n        from_date: datetime.datetime. The start of the date range for which\n            the contributions were created.\n        to_date: datetime.datetime. The end of the date range for which\n            the contributions were created.\n        user_id: str. The user ID of the contributor.\n\n    Returns:\n        ContributorCertificateInfo|None. Data to generate question submitter\n        certificate, or None if no data is found.\n\n    Raises:\n        Exception. The suggestion type given to generate the certificate is\n            invalid.\n    \"\"\"\n    signature = feconf.QUESTION_TEAM_LEAD\n\n    # Adds one date to the to_date to make sure the contributions within\n    # the to_date are also counted for the certificate.\n    to_date_to_fetch_contributions = to_date + datetime.timedelta(days=1)\n\n    suggestions = (\n        suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_submitted_within_given_dates(\n                from_date, to_date_to_fetch_contributions, user_id))\n\n    minutes_contributed = 0\n    for model in suggestions:\n        suggestion = get_suggestion_from_model(model)\n        # Retrieve the html content that is emphasized on the\n        # Contributor Dashboard pages. This content is what stands\n        # out for each suggestion when a user views a list of\n        # suggestions.\n        get_html_representing_suggestion = (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n                suggestion.suggestion_type]\n        )\n        html_content = get_html_representing_suggestion(suggestion)\n\n        if 'oppia-noninteractive-image' in html_content:\n            minutes_contributed += 20\n        else:\n            minutes_contributed += 12\n    # Go to the below link for more information about how we count hours\n    # contributed.\n    # https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit?usp=sharing\n    hours_contributed = round(minutes_contributed / 60, 2)\n\n    if minutes_contributed == 0:\n        return None\n\n    return suggestion_registry.ContributorCertificateInfo(\n        from_date.strftime('%d %b %Y'), to_date.strftime('%d %b %Y'),\n        signature, str(hours_contributed), None\n    )\n"
    },
    {
      "filename": "core/domain/suggestion_services_test.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for suggestion related services.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport random\nimport string\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import feedback_services\nfrom core.domain import question_domain\nfrom core.domain import rights_domain\nfrom core.domain import rights_manager\nfrom core.domain import rte_component_registry\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_domain\nfrom core.domain import subtopic_page_services\nfrom core.domain import suggestion_registry\nfrom core.domain import suggestion_services\nfrom core.domain import taskqueue_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_fetchers\nfrom core.domain import topic_services\nfrom core.domain import translation_domain\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\nfrom typing import Dict, Final, List, Mapping, Union\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from core.domain import change_domain\n    from mypy_imports import feedback_models\n    from mypy_imports import opportunity_models\n    from mypy_imports import suggestion_models\n    from mypy_imports import user_models\n\n(suggestion_models, feedback_models, opportunity_models, user_models) = (\n    models.Registry.import_models(\n        [\n            models.Names.SUGGESTION,\n            models.Names.FEEDBACK,\n            models.Names.OPPORTUNITY,\n            models.Names.USER\n        ]\n    )\n)\n\n\nclass SuggestionServicesUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functions in suggestion_services.\"\"\"\n\n    score_category: str = ('%s%sAlgebra' % (\n        suggestion_models.SCORE_TYPE_CONTENT,\n        suggestion_models.SCORE_CATEGORY_DELIMITER)\n    )\n\n    target_id: str = 'exp1'\n    target_id_2: str = 'exp2'\n    target_id_3: str = 'exp3'\n    target_version_at_submission: int = 1\n    change_cmd: Dict[str, Union[str, Dict[str, str]]] = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': {\n            'content_id': 'content_0',\n            'html': 'new suggestion content'\n        }\n    }\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@example.com'\n    NORMAL_USER_EMAIL: Final = 'normal@example.com'\n\n    THREAD_ID: Final = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE: Final = 'commit message'\n    EMPTY_COMMIT_MESSAGE: Final = ' '\n\n    suggestion_id: str = THREAD_ID\n    suggestion_id_2: str = 'exploration.exp2.thread_2'\n    suggestion_id_3: str = 'exploration.exp3.thread_3'\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.signup(self.NORMAL_USER_EMAIL, 'normaluser')\n        self.normal_user_id = self.get_user_id_from_email(\n            self.NORMAL_USER_EMAIL)\n        self.exploration = self.save_new_valid_exploration(\n            self.target_id, self.author_id, category='Algebra')\n\n    def assert_suggestion_status(self, suggestion_id: str, status: str) -> None:\n        \"\"\"Assert the status of the suggestion with suggestion_id.\"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, status)\n\n    def mock_accept_suggestion(\n        self,\n        suggestion_id: str,\n        reviewer_id: str,\n        commit_message: str,\n        review_message: str\n    ) -> None:\n        \"\"\"Sets up the appropriate mocks to successfully call\n        accept_suggestion.\n        \"\"\"\n        with self.swap(\n            exp_services, 'update_exploration', self.mock_update_exploration):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                with self.swap(\n                    suggestion_registry.SuggestionEditStateContent,\n                    'pre_accept_validate',\n                    self.mock_pre_accept_validate_does_nothing):\n                    with self.swap(\n                        suggestion_registry.SuggestionEditStateContent,\n                        '_get_change_list_for_accepting_edit_state_content_suggestion',  # pylint: disable=line-too-long\n                        self.mock_get_change_list_does_nothing\n                    ):\n                        suggestion_services.accept_suggestion(\n                            suggestion_id, reviewer_id,\n                            commit_message, review_message)\n\n    def mock_create_suggestion(self, target_id: str) -> None:\n        \"\"\"Sets up the appropriate mocks to successfully call\n        create_suggestion.\n        \"\"\"\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    target_id, self.target_version_at_submission,\n                    self.author_id, self.change_cmd, 'test description')\n\n    def mock_generate_new_thread_id(\n        self, entity_type: str, exp_id: str\n    ) -> str:\n        thread_id = 'thread_%s' % exp_id[-1]\n        return '.'.join([entity_type, exp_id, thread_id])\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(\n            self, exploration_id: str, states: Dict[str, Dict[str, str]]\n        ) -> None:\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}})\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id: str) -> MockExploration:\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                mock_exp = exp\n        return mock_exp\n\n    def mock_pre_accept_validate_does_nothing(self) -> None:\n        pass\n\n    def mock_get_change_list_does_nothing(self) -> None:\n        pass\n\n    def mock_accept_does_nothing(self, unused_arg: str) -> None:\n        pass\n\n    def edit_before_pre_accept_validate(\n        self, suggestion: suggestion_registry.BaseSuggestion\n    ) -> None:\n        \"\"\"Edits suggestion immediately before pre-accept validation.\"\"\"\n        suggestion.score_category = 'invalid_score_category'\n        suggestion.pre_accept_validate()\n\n    def test_create_new_suggestion_successfully(self) -> None:\n        expected_suggestion_dict = {\n            'suggestion_id': 'exploration.exp1.thread_1',\n            'suggestion_type': (\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT),\n            'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n            'target_id': self.target_id,\n            'target_version_at_submission': self.target_version_at_submission,\n            'status': suggestion_models.STATUS_IN_REVIEW,\n            'author_name': 'author',\n            'change_cmd': {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': {\n                    'content_id': 'content_0',\n                    'html': 'new suggestion content'\n                },\n                'old_value': None\n            },\n            'score_category': self.score_category,\n            'language_code': None\n        }\n        self.mock_create_suggestion(self.target_id)\n\n        observed_suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertDictContainsSubset(\n            expected_suggestion_dict, observed_suggestion.to_dict())\n\n    def test_cannot_create_suggestion_with_invalid_suggestion_type(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(Exception, 'Invalid suggestion type'):\n            suggestion_services.create_suggestion(\n                'invalid_suggestion_type',\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, self.change_cmd, 'test description')\n\n    def test_cannot_create_suggestion_with_invalid_author_id(self) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'Expected author_id to be in a valid user ID format'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                'invalid author ID', self.change_cmd, 'test description')\n\n    def test_cannot_create_translation_suggestion_with_invalid_content_html_raise_error(  # pylint: disable=line-too-long\n        self\n    ) -> None:\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'Introduction',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>The invalid content html</p>',\n            'translation_html': '<p>Translation for invalid content.</p>',\n            'data_format': 'html'\n        }\n        with self.assertRaisesRegex(\n            Exception,\n            'The Exploration content has changed since this translation '\n            'was submitted.'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, add_translation_change_dict, 'test description')\n\n    def test_get_submitted_submissions(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change_cmd, '')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change_cmd, 'test_description')\n        suggestions = suggestion_services.get_submitted_suggestions(\n            self.author_id, feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].author_id, self.author_id)\n        self.assertEqual(suggestions[1].author_id, self.author_id)\n\n    def test_get_all_stale_suggestion_ids(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change_cmd, 'test description')\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS', 0):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 1)\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS',\n            7 * 24 * 60 * 60 * 1000):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 0)\n\n    def mock_update_exploration(\n        self,\n        unused_user_id: str,\n        unused_exploration_id: str,\n        unused_change_list: str,\n        commit_message: str,\n    ) -> None:\n        self.assertEqual(\n            commit_message, 'Accepted suggestion by %s: %s' % (\n                'author', self.COMMIT_MESSAGE))\n\n    def test_cannot_reject_suggestion_with_empty_review_message(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change_cmd, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Review message cannot be empty.'):\n            suggestion_services.reject_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, '')\n\n        # Assert that the suggestion was not rejected.\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_accept_suggestion_and_send_email_to_author(self) -> None:\n        new_suggestion_content = state_domain.SubtitledHtml(\n            'content', '<p>new suggestion content html</p>').to_dict()\n        change_dict: Dict[str, Union[str, state_domain.SubtitledHtmlDict]] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': new_suggestion_content\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, change_dict, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create a user proficiency model to verify that the\n        # score and onboarding_email_sent fields have changed after the\n        # suggestion has been accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, suggestion.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. Therefore,\n        # by setting that increment to minimum score required to review, we can\n        # ensure that the email is sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                with self.swap(\n                    suggestion_models, 'INCREMENT_SCORE_OF_AUTHOR_BY',\n                    feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW):\n                    suggestion_services.accept_suggestion(\n                        suggestion.suggestion_id, self.reviewer_id,\n                        self.COMMIT_MESSAGE, 'review message')\n\n        # Assert that the suggestion is now accepted.\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        # Assert that the email was sent and that the score increased by the\n        # correct amount.\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, suggestion.score_category\n            )\n        )\n        # Ruling out the possibility of None for mypy type checking.\n        assert user_proficiency_model is not None\n        self.assertTrue(user_proficiency_model.onboarding_email_sent)\n        self.assertEqual(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n\n    def test_accept_suggestion_does_not_send_email_if_users_score_is_too_low(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create the user proficiency model to verify the score and\n        # that the onboarding_email_sent field does not change after the\n        # suggestion is accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, self.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. This is\n        # less than the minimum score required to review so an email should not\n        # be sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                self.mock_accept_suggestion(\n                    self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                    'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, self.score_category\n            )\n        )\n        # Assert that the users score was updated correctly.\n        # Ruling out the possibility of None for mypy type checking.\n        assert user_proficiency_model is not None\n        self.assertEqual(\n            user_proficiency_model.score,\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY)\n        # Assert that their score is not high enough to review the category.\n        self.assertLess(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        # Assert that the onboarding new reviewer email was not sent.\n        self.assertFalse(user_proficiency_model.onboarding_email_sent)\n\n    def test_accept_suggestion_creates_user_proficiency_model_if_it_is_none(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        # Verify that a user proficiency model does not exist.\n        self.assertIsNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Verify that a user proficiency model now exists.\n        self.assertIsNotNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n    def test_accept_suggestion_successfully(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'review message')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_does_not_exist(\n        self\n    ) -> None:\n        expected_exception_regexp = (\n            'You cannot accept the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n    def test_accept_suggestion_with_invalid_math_fails(self) -> None:\n        \"\"\"Test that the method for accepting suggestions raises error when\n        a suggestion with invalid math-tags is tried to be accepted.\n        \"\"\"\n        change_dict: Dict[str, Union[str, state_domain.SubtitledHtmlDict]] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state_1',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': (\n                    '<oppia-noninteractive-math raw_latex-with-value=\"&am'\n                    'p;quot;(x - a_1)(x - a_2)(x - a_3)...(x - a_n)&amp;q'\n                    'uot;\"></oppia-noninteractive-math>')\n            }\n        }\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id, self.target_version_at_submission,\n                    self.author_id, change_dict, 'test description')\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        expected_exception_regexp = (\n            'Invalid math tags found in the suggestion with id %s.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Assert that the status of the suggestion hasn't changed.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_raises_exception_for_invalid_suggestion_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(Exception, 'No suggestion model exists'):\n            suggestion_services.get_suggestion_by_id('invalid_id')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_accepted(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_rejected(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message'\n        )\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n        # Assert that the suggestion is still rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n    def test_accept_suggestion_invalid_suggestion_failure(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n\n        with self.assertRaisesRegex(\n            utils.ValidationError, 'Expected score_category to be of the form '\n                                   'score_type.score_sub_type, received '\n                                   'invalid_score_category'):\n            self.edit_before_pre_accept_validate(suggestion)\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id,\n                self.COMMIT_MESSAGE, '')\n\n    def test_accept_suggestion_no_commit_message_failure(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Commit message cannot be empty.'):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id,\n                self.EMPTY_COMMIT_MESSAGE, '')\n\n        # Assert that the status of the suggestion didn't change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_reject_suggestion_successfully(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(last_message.text, 'reject review message')\n\n    def test_reject_suggestions_successfully(self) -> None:\n        # Create the first suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_2)\n        self.assert_suggestion_status(\n            self.suggestion_id_2, suggestion_models.STATUS_IN_REVIEW)\n        # Create another suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_3)\n        self.assert_suggestion_status(\n            self.suggestion_id_3, suggestion_models.STATUS_IN_REVIEW)\n        suggestion_ids = [self.suggestion_id_2, self.suggestion_id_3]\n\n        suggestion_services.reject_suggestions(\n            suggestion_ids, self.reviewer_id, 'reject review message')\n\n        for suggestion_id in suggestion_ids:\n            # Assert that the statuses changed to rejected.\n            self.assert_suggestion_status(\n                suggestion_id, suggestion_models.STATUS_REJECTED)\n            # Assert that the final reviewer id was updated.\n            suggestion = suggestion_services.get_suggestion_by_id(\n                suggestion_id)\n            self.assertEqual(\n                suggestion.final_reviewer_id, self.reviewer_id)\n            # Assert that the messages were updated.\n            thread_messages = feedback_services.get_messages(suggestion_id)\n            last_message = thread_messages[len(thread_messages) - 1]\n            self.assertEqual(\n                last_message.text, 'reject review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_does_not_exist(\n        self\n    ) -> None:\n        expected_exception_regexp = (\n            'You cannot reject the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_accepted(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion's status did not change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_rejected(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been rejected.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n    def test_resubmit_rejected_suggestion_success(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        # Create the new change for the resubmitted suggestion.\n        resubmit_change_content = state_domain.SubtitledHtml(\n            'content', '<p>resubmit change content html</p>').to_dict()\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': resubmit_change_content,\n                'old_value': self.change_cmd['new_value']\n            }\n        )\n\n        # Resubmit rejected suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            self.suggestion_id, 'resubmit summary message', self.author_id,\n            resubmit_change)\n\n        # The suggestion's status should now be in review instead of rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # The suggestion's change should be updated.\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        new_value = suggestion.change_cmd.new_value\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(new_value, dict)\n        self.assertEqual(new_value['html'], resubmit_change_content['html'])\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_empty_message(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n\n        # Can't resubmit a rejected suggestion if the summary message is empty.\n        with self.assertRaisesRegex(\n            Exception, 'Summary message cannot be empty.'):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, '', self.author_id, resubmit_change)\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_unhandled_input(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n\n        # Can't resubmit a rejected suggestion if the suggestion hasn't been\n        # rejected yet.\n        expected_exception_regexp = (\n            'The suggestion with id %s is not yet handled.' % (\n                self.suggestion_id)\n        )\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, resubmit_change\n            )\n\n    def test_resubmit_rejected_suggestion_raises_excep_for_accepted_suggestion(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n        # Verfiy that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Can't resubmit the suggestion if it's already accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s was accepted. Only rejected '\n            'suggestions can be resubmitted.' % (\n                self.suggestion_id)\n        )\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n        with self.assertRaisesRegex(\n            Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, resubmit_change\n            )\n\n        # Verfiy that the suggestion is still accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_check_can_resubmit_suggestion(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.author_id)\n        self.assertEqual(can_resubmit, True)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.normal_user_id)\n        self.assertEqual(can_resubmit, False)\n\n    def test_update_translation_suggestion_to_change_translation_html(\n        self\n    ) -> None:\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': '<p>old content html</p>'\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, '<p>Updated translation</p>'\n        )\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change_cmd.translation_html,\n            '<p>Updated translation</p>')\n\n    def test_update_question_suggestion_to_change_question_state(self) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        content_id_generator = translation_domain.ContentIdGenerator()\n        state = self._create_valid_question_data(\n            'default_state', content_id_generator)\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': state.to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        new_solution_dict: state_domain.SolutionDict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution_2',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content']['html'] = '<p>Updated question</p>'\n        question_state_data['interaction']['solution'] = new_solution_dict\n        question_state_data['recorded_voiceovers'] = (\n            state.recorded_voiceovers.to_dict())\n\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion.change_cmd.skill_difficulty, float)\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            suggestion.change_cmd.skill_difficulty,\n            question_state_data,\n            content_id_generator.next_content_id_index)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(updated_suggestion.change_cmd.question_dict, dict)\n        question_dict: question_domain.QuestionDict = (\n            updated_suggestion.change_cmd.question_dict\n        )\n        new_question_state_data = question_dict[\n            'question_state_data']\n\n        self.assertEqual(\n            new_question_state_data['content'][\n                'html'],\n            '<p>Updated question</p>')\n        self.assertEqual(\n            new_question_state_data['interaction'][\n                'solution'],\n            new_solution_dict)\n\n    def test_wrong_suggestion_raise_error_while_updating_translation_suggestion(\n        self\n    ) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index),\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'Expected SuggestionTranslateContent suggestion'\n            ' but found: SuggestionAddQuestion.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id, 'test_translation'\n            )\n\n    def create_translation_suggestion(\n            self, content_html: str, translation_html: str\n        ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion for testing purposes.\"\"\"\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', content_html).to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': content_html\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': content_html,\n            'translation_html': translation_html,\n            'data_format': 'html'\n        }\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n    def test_update_translation_suggestion_error_on_rte_removal(self) -> None:\n        \"\"\"Tests that an InvalidInputException is raised when a translation\n        suggestion update removes an RTE component.\n        \"\"\"\n        content_html_with_rte_components = (\n            '<p>Original content with image.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n        translation_html_with_rte_components = (\n            '<p>Original content with image.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n        suggestion = self.create_translation_suggestion(\n            content_html=content_html_with_rte_components,\n            translation_html=translation_html_with_rte_components\n        )\n\n        updated_translation_without_image = (\n            '<p>Updated translation without image</p>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            'Components in original text: 1 image. '\n            'Components in translated text: 0 image.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id,\n                updated_translation_without_image\n            )\n\n    def test_update_translation_suggestion_error_when_component_is_added(\n        self\n    ) -> None:\n        content_html_without_image = (\n            '<p>Original content without image.</p>'\n        )\n        translation_html_without_image = (\n            '<p>Translation for original content without image.</p>'\n        )\n\n        suggestion = self.create_translation_suggestion(\n            content_html_without_image,\n            translation_html_without_image\n        )\n        new_translation_html_with_image = (\n            '<p><oppia-noninteractive-image '\n            'alt-with-value=\"Another description\" '\n            'caption-with-value=\"Another caption\" ' \n            'filepath-with-value=\"another_img.svg\">'\n            '</oppia-noninteractive-image> '\n            'Updated translation with image</p>'\n        )\n\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            'Components in original text: 0 image. '\n            'Components in translated text: 1 image.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id,\n                new_translation_html_with_image\n            )\n\n    def test_update_translation_suggestion_error_when_component_count_changes(\n        self\n    ) -> None:\n        content_html_with_multiple_images = (\n            '<p>Original content with multiple images.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description 1\" '\n            'caption-with-value=\"Sample Caption 1\" '\n            'filepath-with-value=\"img1.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description 2\" '\n            'caption-with-value=\"Sample Caption 2\" '\n            'filepath-with-value=\"img2.svg\"> '\n            '</oppia-noninteractive-image>'\n        )\n        translation_html_with_multiple_images = (\n            '<p>Translation with multiple images.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description 1\" '\n            'caption-with-value=\"Sample Caption 1\" '\n            'filepath-with-value=\"img1.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description 2\" '\n            'caption-with-value=\"Sample Caption 2\" '\n            'filepath-with-value=\"img2.svg\"> '\n            '</oppia-noninteractive-image>'\n        )\n        suggestion = self.create_translation_suggestion(\n            content_html_with_multiple_images,\n            translation_html_with_multiple_images\n        )\n        updated_translation = (\n            '<p>Updated translation with an extra video.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description 1\" '\n            'caption-with-value=\"Sample Caption 1\" '\n            'filepath-with-value=\"img1.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            'Components in original text: 2 image, 0 math. '\n            'Components in translated text: 1 image, 2 math.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id,\n                updated_translation\n            )\n\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n        original_component_counts = suggestion_services.count_rte_components(\n            updated_suggestion.change_cmd.translation_html\n        )\n\n        rte_tags_with_attrs = (\n            rte_component_registry.Registry.get_tag_list_with_attrs()\n        )\n        rte_tags = list(rte_tags_with_attrs.keys())\n\n        expected_counts = {tag: 0 for tag in rte_tags}\n\n        expected_counts['oppia-noninteractive-image'] = 2\n\n        self.assertEqual(expected_counts, original_component_counts)\n\n    def test_update_translation_suggestion_error_when_component_types_mismatch(\n        self\n    ) -> None:\n        content_html_with_image = (\n            '<p>Original content with image.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample Caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n        )\n        translation_html_with_image = (\n            '<p>Translation with image.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample Caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n        )\n        suggestion = self.create_translation_suggestion(\n            content_html_with_image,\n            translation_html_with_image\n        )\n        updated_translation_with_math = (\n            '<p>Updated translation with math instead of image.</p>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            'Components in original text: 1 image, 0 math. '\n            'Components in translated text: 0 image, 1 math.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id,\n                updated_translation_with_math\n            )\n\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n        self.assertEqual(\n            updated_suggestion.change_cmd.translation_html,\n            translation_html_with_image\n        )\n\n    def test_update_translation_suggestion_with_extra_characters(self) -> None:\n        original = 'This is a test string.'\n        updated = 'This is a test string. Extra text.'\n\n        suggestion = self.create_translation_suggestion(original, original)\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated\n        )\n\n        suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n\n        truncated_original, truncated_updated = (\n            suggestion_services.highlight_differences(\n                original, updated\n            )\n        )\n\n        self.assertTrue(truncated_original.startswith('...'))\n        self.assertTrue(truncated_updated.startswith('...'))\n        self.assertTrue(truncated_updated.endswith('Extra text.'))\n\n    def test_update_translation_suggestion_with_long_text(self) -> None:\n        original = f'{\"A\" * 50}DIFFERENT{\"B\" * 50}'\n        updated = f'{\"A\" * 50}CHANGED{\"B\" * 50}'\n\n        suggestion = self.create_translation_suggestion(original, original)\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated\n        )\n\n        suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n\n        truncated_original, truncated_updated = (\n            suggestion_services.highlight_differences(\n                original, updated\n            )\n        )\n\n        self.assertTrue(truncated_original.startswith('...'))\n        self.assertTrue(truncated_updated.startswith('...'))\n\n        self.assertIn('DIFFERENT', truncated_original)\n        self.assertIn('CHANGED', truncated_updated)\n\n    def test_highlight_differences_identical_strings(self) -> None:\n        original_string = 'This is the same string.'\n        updated_string = 'This is the same string.'\n\n        suggestion = self.create_translation_suggestion(\n            original_string, original_string\n        )\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated_string\n        )\n\n        suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n\n        truncated_original, truncated_updated = (\n            suggestion_services.highlight_differences(\n                original_string, updated_string\n            )\n        )\n\n        self.assertEqual(truncated_original, original_string)\n        self.assertEqual(truncated_updated, updated_string)\n\n    def test_update_translation_suggestion_with_change_in_middle(self) -> None:\n        original = 'This is a test string.'\n        updated = 'This is a best string.'\n\n        suggestion = self.create_translation_suggestion(original, original)\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated\n        )\n\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n\n        self.assertIn('test', original)\n        self.assertIn('best', updated_suggestion.change_cmd.translation_html)\n\n    def test_update_translation_suggestion_with_change_at_start(self) -> None:\n        original = 'Alpha test string.'\n        updated = 'Beta test string.'\n\n        suggestion = self.create_translation_suggestion(original, original)\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated\n        )\n\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id\n        )\n\n        self.assertIn('Alpha', original)\n        self.assertIn('Beta', updated_suggestion.change_cmd.translation_html)\n\n    def test_update_translation_suggestion_error_with_two_discrepancies(\n        self\n    ) -> None:\n        content_html_with_image = (\n            '<p>Original content with image.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample Caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-math '\n            'math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)&amp;quot;, '\n            '&amp;quot;svg_filename&amp;quot;: &amp;quot;file.svg&amp;quot;}\">'\n            '</oppia-noninteractive-math>'\n        )\n        translation_html_without_math = (\n            '<p>Translation without math.</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample Caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Image description\" '\n            'caption-with-value=\"Sample Caption\" '\n            'filepath-with-value=\"img.svg\"> '\n            '</oppia-noninteractive-image>'\n        )\n        suggestion = self.create_translation_suggestion(\n            content_html_with_image, content_html_with_image\n        )\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            'Components in original text: 1 image, 1 math. '\n            'Components in translated text: 2 image, 0 math.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id, translation_html_without_math\n            )\n\n    def test_update_translation_suggestion_no_rte_components(self) -> None:\n        original = 'This is a test string.'\n        updated = 'This is a best string.'\n\n        suggestion = self.create_translation_suggestion(original, original)\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, updated)\n\n    def test_update_translation_suggestion_error_with_truncated_text(\n        self\n    ) -> None:\n        truncation_limit = (\n            suggestion_services.MAX_CONTENT_LENGTH_WITHOUT_TRUNCATION\n        )\n        long_original_html = (\n            f'<p>{\"a\" * 250}</p>'\n            '<oppia-noninteractive-image '\n            'alt-with-value=\"Original Alt\" '\n            'caption-with-value=\"Original Caption\" '\n            'filepath-with-value=\"original.svg\">'\n            '</oppia-noninteractive-image>'\n        )\n        long_updated_html = f'<p>{\"b\" * 250}</p>'\n        suggestion = self.create_translation_suggestion(\n            long_original_html, long_original_html\n        )\n\n        original_preview_start = long_original_html.find('<p>')\n        original_preview_end = original_preview_start + truncation_limit\n        truncated_original_expected = long_original_html[\n            original_preview_start:original_preview_end\n        ]\n\n        updated_preview_start = long_updated_html.find('<p>')\n        updated_preview_end = updated_preview_start + truncation_limit\n        truncated_updated_expected = long_updated_html[\n            updated_preview_start:updated_preview_end\n        ]\n\n        with self.assertRaisesRegex(\n            utils.InvalidInputException,\n            (\n                f'Components in original text: 1 image. '\n                f'Components in translated text: 0 image.\\n'\n                f'Original text preview: {truncated_original_expected}\\n'\n                f'Translated text preview: {truncated_updated_expected}'\n            )\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id, long_updated_html\n            )\n\n    def test_wrong_suggestion_raise_error_when_updating_add_question_suggestion(\n        self\n    ) -> None:\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        audio_language_codes = set(\n            language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES)\n        model = opportunity_models.ExplorationOpportunitySummaryModel(\n            id='exploration1',\n            topic_id='topic_id',\n            topic_name='topic_name',\n            story_id='story_id',\n            story_title='story_title',\n            chapter_title='chapter_title',\n            content_count=2,\n            incomplete_translation_language_codes=(\n                audio_language_codes - set(['en'])),\n            translation_counts={},\n            language_codes_needing_voice_artists=audio_language_codes,\n            language_codes_with_assigned_voice_artists=[]\n        )\n        model.update_timestamps()\n        model.put()\n\n        old_content = state_domain.SubtitledHtml(\n            'content_0', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': '<p>old content html</p>'\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'Expected SuggestionAddQuestion suggestion but '\n            'found: SuggestionTranslateContent.'\n        ):\n            suggestion_services.update_question_suggestion(\n                suggestion.suggestion_id,\n                0.1,\n                exploration.states['state 1'].to_dict(),\n                5\n            )\n\n    def test_update_question_suggestion_to_change_skill_difficulty(\n        self\n    ) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index\n                )\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion.change_cmd.question_dict, dict)\n        change_question_dict = suggestion.change_cmd.question_dict\n        question_state_data = change_question_dict[\n            'question_state_data']\n\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            0.6,\n            question_state_data,\n            content_id_generator.next_content_id_index)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change_cmd.skill_difficulty,\n            0.6)\n\n\nclass SuggestionGetServicesUnitTests(test_utils.GenericTestBase):\n    score_category: str = '%s%sEnglish' % (\n        suggestion_models.SCORE_TYPE_TRANSLATION,\n        suggestion_models.SCORE_CATEGORY_DELIMITER\n    )\n\n    target_id_1: str = 'exp1'\n    target_id_2: str = 'exp2'\n    target_id_3: str = 'exp3'\n    target_version_at_submission: int = 1\n    change_cmd: Dict[str, str] = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': 'new suggestion content'\n    }\n\n    AUTHOR_EMAIL_1: Final = 'author1@example.com'\n    REVIEWER_EMAIL_1: Final = 'reviewer1@example.com'\n\n    AUTHOR_EMAIL_2: Final = 'author2@example.com'\n    REVIEWER_EMAIL_2: Final = 'reviewer2@example.com'\n\n    add_translation_change_dict: Dict[str, str] = {\n        'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n        'state_name': 'state_1',\n        'content_id': 'content_0',\n        'language_code': 'hi',\n        'content_html': '<p>State name: state_1, Content id: content_0</p>',\n        'translation_html': '<p>This is translated html.</p>',\n        'data_format': 'html'\n    }\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(\n            self, exploration_id: str, states: Dict[str, Dict[str, str]]\n        ) -> None:\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n        def get_content_html(self, state_name: str, content_id: str) -> str:\n            \"\"\"Used to mock the get_content_html method for explorations.\"\"\"\n            # state_name and content_id are used here to suppress the unused\n            # arguments warning. The main goal of this method is to just\n            # produce content html for the tests.\n            return '<p>State name: %s, Content id: %s</p>' % (\n                state_name, content_id\n            )\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}}),\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id: str) -> MockExploration:\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                mock_exp = exp\n        return mock_exp\n\n    def _create_question_suggestion_with_skill_id(\n        self, skill_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id_1, suggestion_change, 'test description'\n        )\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion with the language code given.\"\"\"\n        return self._create_translation_suggestion(\n            language_code, self.target_id_1)\n\n    def _create_translation_suggestion(\n        self, language_code: str, target_id: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion for the supplied language code and\n        target ID.\n        \"\"\"\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state_1',\n            'content_id': 'content_0',\n            'language_code': language_code,\n            'content_html': (\n                '<p>State name: state_1, Content id: content_0</p>'),\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html\n            ):\n                translation_suggestion = suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    target_id, 1, self.author_id_1,\n                    add_translation_change_dict, 'test description')\n\n        return translation_suggestion\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL_1, 'author1')\n        self.author_id_1 = self.get_user_id_from_email(self.AUTHOR_EMAIL_1)\n        self.signup(self.REVIEWER_EMAIL_1, 'reviewer1')\n        self.reviewer_id_1 = self.get_user_id_from_email(self.REVIEWER_EMAIL_1)\n\n        self.signup(self.AUTHOR_EMAIL_2, 'author2')\n        self.author_id_2 = self.get_user_id_from_email(self.AUTHOR_EMAIL_2)\n        self.signup(self.REVIEWER_EMAIL_2, 'reviewer2')\n        self.reviewer_id_2 = self.get_user_id_from_email(self.REVIEWER_EMAIL_2)\n        self.opportunity_summary_ids = [\n            self.explorations[0].id, self.explorations[1].id,\n            self.explorations[2].id]\n        self.topic_name = 'topic'\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change_cmd, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change_cmd, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change_cmd, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_2, self.change_cmd, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_2, self.target_version_at_submission,\n                self.author_id_2, self.change_cmd, 'test description')\n\n    def test_get_by_author(self) -> None:\n        queries = [('author_id', self.author_id_1)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n        queries = [('author_id', self.author_id_2)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 2)\n\n    def test_get_translation_suggestions_in_review_by_exp_ids(self) -> None:\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [\n                    self.target_id_1,\n                    self.target_id_2,\n                    self.target_id_3\n                ],\n                'en'\n            )\n        )\n        self.assertEqual(len(suggestions), 0)\n        self._create_translation_suggestion_with_language_code('en')\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [self.target_id_1],\n                'en'\n            )\n        )\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[0] is not None\n        self.assertEqual(suggestions[0].author_id, self.author_id_1)\n        self.assertEqual(suggestions[0].language_code, 'en')\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n\n    def test_get_by_target_id(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 4)\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n    def test_get_by_status(self) -> None:\n        queries = [('status', suggestion_models.STATUS_IN_REVIEW)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_get_by_type(self) -> None:\n        queries = [(\n            'suggestion_type',\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_query_suggestions(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_1),\n            ('status', suggestion_models.STATUS_IN_REVIEW)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('invalid_field', 'value')\n        ]\n        with self.assertRaisesRegex(\n            Exception, 'Not allowed to query on field invalid_field'):\n            suggestion_services.query_suggestions(queries)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_one_exp(\n        self\n    ) -> None:\n        # Create the translation suggestion associated with exploration id\n        # target_id_1.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_1, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there is one translation suggestion with the given\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_1])), 1)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_multiple_exps(\n        self\n    ) -> None:\n        # Create the translation suggestion associated with exploration id\n        # target_id_2.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_2, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n        # Create the translation suggestion associated with exploration id\n        # target_id_3.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_3, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_2, self.target_id_3])), 2)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_invalid_exp(\n        self\n    ) -> None:\n        # Assert that there are no translation suggestions with an invalid\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    ['invalid_exp_id'])), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_empty_exp_list(\n        self\n    ) -> None:\n        # Assert that there are no translation suggestions found when we\n        # use an empty exp_ids list.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids([])), 0)\n\n    def test_get_submitted_suggestions_by_offset(self) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        question_1_skill_id = 'skill1'\n        question_2_skill_id = 'skill2'\n        self._create_question_suggestion_with_skill_id(question_1_skill_id)\n        self._create_question_suggestion_with_skill_id(question_2_skill_id)\n\n        # Fetch submitted translation suggestions.\n        translatable_suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n\n        self.assertEqual(len(translatable_suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(\n            translatable_suggestions[0].target_id, self.target_id_1\n        )\n        self.assertEqual(\n            translatable_suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            translatable_suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(\n            translatable_suggestions[1].target_id, self.target_id_1\n        )\n        self.assertEqual(\n            translatable_suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            translatable_suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n        # Fetch submitted question suggestions.\n        question_suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n\n        self.assertEqual(len(question_suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(\n            question_suggestions[0].target_id, question_2_skill_id\n        )\n        self.assertEqual(\n            question_suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            question_suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(\n            question_suggestions[1].target_id, question_1_skill_id\n        )\n        self.assertEqual(\n            question_suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            question_suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review(self) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review(self.target_id_1))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[0] is not None\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[1] is not None\n        self.assertEqual(suggestions[1].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration(self) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'hi'))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[0] is not None\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[1] is not None\n        self.assertEqual(suggestions[1].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration_returns_only_suggestions_with_supplied_language_code(  # pylint: disable=line-too-long\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'pt'))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_reviewable_translation_suggestions_with_valid_exp_ids(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change_cmd.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_translation_suggestions_for_single_exploration( # pylint: disable=line-too-long\n        self\n    ) -> None:\n         # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_settings = user_services.get_user_settings(self.reviewer_id_1)\n        user_settings.preferred_translation_language_code = 'hi'\n        user_services.save_user_settings(user_settings)\n       # Get all reviewable translation suggestions.\n        opportunity_summary_id = self.opportunity_summary_ids[0]\n        suggestions, _ = suggestion_services.get_reviewable_translation_suggestions_for_single_exp( # pylint: disable=line-too-long\n            self.reviewer_id_1, opportunity_summary_id, 'hi')\n        self.assertEqual(len(suggestions), 2)\n\n    def test_get_reviewable_translation_suggestions_for_single_exploration__with_no_reviewable_languages( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n\n        # Get all reviewable translation suggestions.\n        opportunity_summary_id = self.opportunity_summary_ids[0]\n        suggestions, _ = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_for_single_exp(\n                self.reviewer_id_1, opportunity_summary_id, 'hi'))\n\n        # The user does not have rights to review any languages, so expect an\n        # empty result.\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_reviewable_translation_suggestions_with_empty_exp_ids( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = suggestion_services.get_reviewable_translation_suggestions_by_offset(\n            self.reviewer_id_1, [],\n            constants.OPPORTUNITIES_PAGE_SIZE, 0, None)\n\n        self.assertEqual(offset, 0)\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_reviewable_translation_suggestions_with_none_exp_ids(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, None,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change_cmd.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_translation_suggestions_with_no_reviewable_languages( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, None,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        # The user does not have rights to review any languages, so expect an\n        # empty result.\n        self.assertEqual(len(suggestions), 0)\n        self.assertEqual(offset, 0)\n\n    def test_get_reviewable_translation_suggestions_with_language_filter(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get reviewable translation suggestions in Hindi.\n        language_to_filter = 'hi'\n        suggestions, _ = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None, language_to_filter))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].change_cmd.language_code, 'hi')\n        self.assertEqual(suggestions[1].change_cmd.language_code, 'hi')\n\n        # Get reviewable translation suggestions in Spanish (there are none).\n        language_to_filter = 'es'\n        suggestions, _ = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None, language_to_filter))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 0)\n        actual_language_code_list = [\n            suggestion.change_cmd.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list: List[str] = []\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_target_ids_of_reviewable_translation_suggestions_for_user(\n        self\n    ) -> None:\n        language_code = 'hi'\n        fetched_target_id_1, fetched_target_id_2 = ('exp1', 'exp2')\n        self._create_translation_suggestion(language_code, fetched_target_id_1)\n        self._create_translation_suggestion(language_code, fetched_target_id_2)\n        self._create_translation_suggestion(language_code, fetched_target_id_2)\n        self._create_translation_suggestion('bn', 'exp3')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi'\n        )\n\n        target_ids = (\n            suggestion_services.\n            get_reviewable_translation_suggestion_target_ids(\n                self.reviewer_id_1, language_code\n            )\n        )\n\n        self.assertCountEqual(\n            target_ids, [fetched_target_id_1, fetched_target_id_2]\n        )\n\n    def test_get_target_ids_of_translations_in_user_reviewable_languages_when_not_filtering_by_language( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        fetched_target_id_1, fetched_target_id_2 = ('exp1', 'exp2')\n        self._create_translation_suggestion('hi', fetched_target_id_1)\n        self._create_translation_suggestion('fr', fetched_target_id_2)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi'\n        )\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'fr'\n        )\n        language_code = None\n\n        target_ids = (\n            suggestion_services.\n            get_reviewable_translation_suggestion_target_ids(\n                self.reviewer_id_1, language_code\n            )\n        )\n\n        self.assertCountEqual(\n            target_ids, [\n                fetched_target_id_1,\n                fetched_target_id_2\n            ]\n        )\n\n    def test_get_no_translation_target_ids_when_user_cannot_review_in_given_language( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        language_code = 'cs'\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi'\n        )\n\n        target_ids = (\n            suggestion_services.\n            get_reviewable_translation_suggestion_target_ids(\n                self.reviewer_id_1, language_code\n            )\n        )\n\n        self.assertCountEqual(target_ids, [])\n\n    def test_get_reviewable_question_suggestions(self) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add a few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        self._create_question_suggestion_with_skill_id('skill3')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n        # Provide the user permission to review question suggestions.\n        user_services.allow_user_to_review_question(self.reviewer_id_1)\n\n        # Get all reviewable question suggestions.\n        suggestions, offset = (\n            suggestion_services.get_reviewable_question_suggestions_by_offset(\n                self.reviewer_id_1,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                skill_ids=['skill1', 'skill2']))\n\n        # Expect that the results correspond to question suggestions.\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(offset, 3)\n        expected_suggestion_type_list = ['skill2', 'skill1']\n        actual_suggestion_type_list = [\n            suggestion.change_cmd.skill_id\n            for suggestion in suggestions\n        ]\n        self.assertEqual(\n            actual_suggestion_type_list, expected_suggestion_type_list)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_per_lang(\n        self\n    ) -> None:\n        suggestion_1 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_2 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_3 = self._create_translation_suggestion_with_language_code(\n            'hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'hi'))\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_wrong_lang(\n        self\n    ) -> None:\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'wrong_language_code'))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_question_suggestions_waiting_longest_for_review_keeps_order(\n        self\n    ) -> None:\n        \"\"\"This test makes sure that if a suggestion is rejected and is then\n        resubmitted, we count the time that the suggestion has been waiting for\n        review from when it was resubmitted, not from when it was first\n        submitted.\n        \"\"\"\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        # Verify that both suggestions are returned and in the right order.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n        # Reject the suggestion that was created first since it is the one that\n        # has been waiting the longest for review.\n        suggestion_services.reject_suggestion(\n            suggestion_1.suggestion_id, self.reviewer_id_1, 'Reject message')\n\n        # Verify that only the suggestion that was created second is returned.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = suggestion_1.change_cmd\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_question_change.question_dict, dict)\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            suggestion_1.suggestion_id, 'resubmit summary message',\n            self.author_id_1, resubmit_question_change\n        )\n\n        # Verify that both suggestions are returned again and the suggestion\n        # that was created second is now the first suggestion in the returned\n        # list, since it has been waiting longer (due to it not being updated).\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_1.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n    def test_get_question_suggestions_waiting_longest_for_review(self) -> None:\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        suggestion_3 = self._create_question_suggestion_with_skill_id('skill3')\n\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_query_suggestions_that_can_be_reviewed_by_user(self) -> None:\n        # User proficiency models for user1.\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category1', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category2', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category3', 5)\n        # User proficiency models for user2.\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category1', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category2', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category3', 5)\n\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_1', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_2', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category3',\n            'exploration.exp1.thread_3', None)\n        # This suggestion does not count as a suggestion that can be reviewed\n        # by a user because it has already been rejected.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_4', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_5', None)\n\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user1')), 3)\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user2')), 0)\n\n\nclass SuggestionIntegrationTests(test_utils.GenericTestBase):\n\n    EXP_ID: Final = 'exp1'\n    TOPIC_ID: Final = 'topic1'\n    STORY_ID: Final = 'story1'\n    TRANSLATION_LANGUAGE_CODE: Final = 'en'\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n\n    score_category: str = ('%s%s%s' % (\n        suggestion_models.SCORE_TYPE_CONTENT,\n        suggestion_models.SCORE_CATEGORY_DELIMITER, 'Algebra')\n    )\n\n    THREAD_ID: Final = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def mock_generate_new_thread_id(\n        self, unused_entity_type: str, unused_entity_id: str\n    ) -> str:\n        return self.THREAD_ID\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.editor_id\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        # Login and create exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n\n        # Create exploration.\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                self.EXP_ID, self.editor_id,\n                ['State 1', 'State 2', 'End State'],\n                ['TextInput'], category='Algebra'))\n\n        self.old_content = state_domain.SubtitledHtml(\n            'content_0', '<p>old content</p>').to_dict()\n        recorded_voiceovers_dict: state_domain.RecordedVoiceoversDict = {\n            'voiceovers_mapping': {\n                'content_0': {\n                    self.TRANSLATION_LANGUAGE_CODE: {\n                        'filename': 'filename3.mp3',\n                        'file_size_bytes': 3000,\n                        'needs_update': False,\n                        'duration_secs': 42.43\n                    }\n                },\n                'default_outcome_1': {},\n                'ca_placeholder_6': {}\n            }\n        }\n        self.old_recorded_voiceovers = (\n            state_domain.RecordedVoiceovers.from_dict(recorded_voiceovers_dict))\n        # Create content in State A with a single audio subtitle.\n        content_change = exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.old_content,\n        })\n        exp_services.update_exploration(\n            self.editor_id, exploration.id,\n            [content_change], '')\n\n        rights_manager.publish_exploration(self.editor, self.EXP_ID)\n        rights_manager.assign_role_for_exploration(\n            self.editor, self.EXP_ID, self.owner_id,\n            rights_domain.ROLE_EDITOR)\n\n        self.new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content</p>').to_dict()\n\n        self.change_cmd: Dict[\n            str, Union[str, state_domain.SubtitledHtmlDict]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.new_content\n        }\n\n        self.target_version_at_submission = exploration.version\n\n        # Set up for testing translation suggestions. Translation suggestions\n        # correspond to a given topic, story and exploration.\n\n        self.save_new_topic(self.TOPIC_ID, self.owner_id)\n\n        self.save_new_story(\n            self.STORY_ID, self.owner_id, self.TOPIC_ID, title='A story',\n            description='Description', notes='Notes')\n\n        # Adds the story to the topic.\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n\n        # Adds the exploration to the story.\n        story_change_list_to_add_an_exp = [\n            story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': self.EXP_ID\n            })\n        ]\n        story_services.update_story(\n            self.owner_id, self.STORY_ID,\n            story_change_list_to_add_an_exp, 'Added exploration.')\n\n    def create_translation_suggestion_associated_with_exp(\n        self, exp_id: str, author_id: str\n    ) -> None:\n        \"\"\"Creates a translation suggestion that is associated with an\n        exploration with id exp_id. The author of the created suggestion is\n        author_id.\n        \"\"\"\n        # Gets the html content in the exploration to be translated.\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        content_html = exploration.states['State 1'].content.html\n        content_id = exploration.states['State 1'].content.content_id\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'State 1',\n            'content_id': content_id,\n            'language_code': 'hi',\n            'content_html': content_html,\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_id, 1, author_id, add_translation_change_dict,\n            'test description')\n\n    def assert_created_suggestion_is_valid(\n        self, target_id: str, author_id: str\n    ) -> None:\n        \"\"\"Assert that the created suggestion is in review and that only one\n        suggestion with the given target_id and author_id exists.\n        \"\"\"\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', author_id), ('target_id', target_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_create_and_accept_suggestion(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change_cmd, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_create_translation_contribution_stats_from_model(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836),\n                datetime.date.fromtimestamp(1616173837)\n            ]\n        )\n        translation_suggestion = suggestion_services.get_all_translation_contribution_stats( # pylint: disable=line-too-long\n            'user_id')\n        self.assertEqual(len(translation_suggestion), 1)\n        self.assertEqual(translation_suggestion[0].language_code, 'es')\n        self.assertEqual(\n            translation_suggestion[0].contributor_user_id,\n            'user_id'\n        )\n\n    def test_fetch_all_contribution_stats(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836),\n                datetime.date.fromtimestamp(1616173837)\n            ]\n        )\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code='es',\n            reviewer_user_id='user_id',\n            topic_id='topic_id',\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=1,\n            accepted_translations_count=1,\n            accepted_translations_with_reviewer_edits_count=0,\n            accepted_translation_word_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_without_reviewer_edits_count=0,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id='user_id',\n            topic_id='topic_id',\n            reviewed_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_with_reviewer_edits_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n\n        stats = suggestion_services.get_all_contributor_stats( # pylint: disable=line-too-long\n            'user_id')\n\n        self.assertEqual(stats.contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.translation_contribution_stats), 1)\n        self.assertEqual(\n            stats.translation_contribution_stats[0].language_code, 'es')\n        self.assertEqual(len(stats.question_contribution_stats), 1)\n        self.assertEqual(\n            stats.question_contribution_stats[0].contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.translation_review_stats), 1)\n        self.assertEqual(\n            stats.translation_review_stats[0].contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.question_review_stats), 1)\n        self.assertEqual(\n            stats.question_review_stats[0].contributor_user_id, 'user_id')\n\n    def _publish_valid_topic(\n        self, topic: topic_domain.Topic,\n        uncategorized_skill_ids: List[str]) -> None:\n        \"\"\"Saves and publishes a valid topic with linked skills and subtopic.\n\n        Args:\n            topic: Topic. The topic to be saved and published.\n            uncategorized_skill_ids: list(str). List of uncategorized skills IDs\n                to add to the supplied topic.\n        \"\"\"\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        subtopic_id = 1\n        subtopic_skill_id = 'subtopic_skill_id' + topic.id\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                subtopic_id, 'Title', [subtopic_skill_id], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = [subtopic_skill_id]\n        subtopic_page = (\n            subtopic_page_domain.SubtopicPage.create_default_subtopic_page(\n                subtopic_id, topic.id))\n        subtopic_page_services.save_subtopic_page(\n            self.owner_id, subtopic_page, 'Added subtopic',\n            [topic_domain.TopicChange({\n                'cmd': topic_domain.CMD_ADD_SUBTOPIC,\n                'subtopic_id': 1,\n                'title': 'Sample',\n                'url_fragment': 'sample-fragment'\n            })]\n        )\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(topic.id, self.admin_id)\n\n        for skill_id in uncategorized_skill_ids:\n            self.save_new_skill(\n                skill_id, self.admin_id, description='skill_description')\n            topic_services.add_uncategorized_skill(\n                self.admin_id, topic.id, skill_id)\n\n    def _set_up_topics_and_stories_for_translations(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Sets up required topics and stories for translations. It does the\n        following.\n        1. Create 2 explorations and publish them.\n        2. Create a default topic.\n        3. Publish the topic with two story IDs.\n        4. Create 2 stories for translation opportunities.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change_cmd object for the translations.\n        \"\"\"\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category=constants.ALL_CATEGORIES[i],\n            end_state_name='End State'\n        ) for i in range(3)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n            exp_services.update_exploration(\n                self.owner_id, exp.id, [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'content_id': 'content_0',\n                        'html': '<p>A content to translate.</p>'\n                    }\n                })], 'Changes content.')\n\n        topic_id = '0'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic_name', 'abbrev', 'description', 'fragm')\n        skill_id_0 = 'skill_id_0'\n        skill_id_1 = 'skill_id_1'\n        self._publish_valid_topic(topic, [skill_id_0, skill_id_1])\n\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_01', topic_id, '0')\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_02', topic_id, '1')\n\n        return {\n            'cmd': 'add_written_translation',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>A content to translate.</p>',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n\n    def _set_up_topics_and_100_stories_for_translations(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Sets up required topics and stories for translations. It does the\n        following.\n        1. Create 2 explorations and publish them.\n        2. Create a default topic.\n        3. Publish the topic with two story IDs.\n        4. Create 100 stories for translation opportunities.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change_cmd object for the translations.\n        \"\"\"\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category='Algebra',\n            end_state_name='End State'\n        ) for i in range(103)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n            exp_services.update_exploration(\n                self.owner_id, exp.id, [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'content_id': 'content_0',\n                        'html': '<p>A content to translate.</p>'\n                    }\n                })], 'Changes content.')\n\n        topic_id = '0'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic_name', 'abbrev', 'description', 'fragm')\n        skill_id_0 = 'skill_id_0'\n        skill_id_1 = 'skill_id_1'\n        self._publish_valid_topic(topic, [skill_id_0, skill_id_1])\n\n        for i in range(103):\n            self.create_story_for_translation_opportunity(\n                self.owner_id, self.admin_id, ('story_id_%s' % (i)), topic_id,\n                '%s' % i)\n\n        return {\n            'cmd': 'add_written_translation',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>A content to translate.</p>',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n\n    def _set_up_a_topic_and_stories_for_translations(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Sets up required topics and stories for translations. It does the\n        following.\n        1. Create 2 explorations and publish them.\n        2. Create a topic with topic_id A.\n        3. Publish the topic with one story ID.\n        4. Create 1 story for translation opportunities.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change_cmd object for the translations.\n        \"\"\"\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category=constants.ALL_CATEGORIES[i],\n            end_state_name='End State'\n        ) for i in range(2, 4)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n            exp_services.update_exploration(\n                self.owner_id, exp.id, [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'content_id': 'content_0',\n                        'html': '<p>A content to translate.</p>'\n                    }\n                })], 'Changes content.')\n\n        topic_id = 'A'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic_name_a', 'abbrev-a', 'description', 'fragm-a')\n        skill_id_2 = 'skill_id_2'\n        skill_id_3 = 'skill_id_3'\n        self._publish_valid_topic(topic, [skill_id_2, skill_id_3])\n\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_03', topic_id, '2')\n\n        return {\n            'cmd': 'add_written_translation',\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>A content to translate.</p>',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n\n    def _get_change_with_normalized_string(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Provides change_cmd dictionary with normalized translation html.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change_cmd object for the translations.\n        \"\"\"\n        return {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>A content to translate.</p>',\n            'state_name': 'Introduction',\n            'translation_html': ['translated text1', 'translated text2'],\n            'data_format': 'set_of_normalized_string'\n        }\n\n    def test_get_translation_contribution_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_translation_contribution_stats_models(\n                ['invalid_id'])\n\n    def test_get_translation_contribution_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services\n            .get_translation_contribution_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_translation_review_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services\n            .get_translation_review_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_question_contribution_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services.get_question_contribution_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_question_review_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = suggestion_services.get_question_review_stats_models(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_translation_review_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_translation_review_stats_models(\n                ['invalid_id'])\n\n    def test_get_question_contribution_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_question_contribution_stats_models(\n                ['invalid_id'])\n\n    def test_get_question_review_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_question_review_stats_models(\n                ['invalid_id'])\n\n    def test_update_translation_contribution_stats_when_submitting(\n        self) -> None:\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, new_change_dict, 'description')\n\n        change_dict_for_a_topic = (\n            self._set_up_a_topic_and_stories_for_translations())\n        topic_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '2', 1, self.author_id, change_dict_for_a_topic, 'description')\n\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            latest_suggestion\n        )\n\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation contribution stats.\n        # At this point we can confirm that there should be an associated\n        # translation contribution stat object for the given IDs since we have\n        # called update_translation_contribution_stats_at_submission function\n        # to create/update translation contribution stats.\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            0\n        )\n\n        translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .submitted_translations_count\n            ),\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .submitted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .accepted_translations_count\n            ),\n            0\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .topic_ids_with_translation_submissions\n            ),\n            ['0']\n        )\n\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            topic_suggestion\n        )\n        updated_translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert updated_translation_submitter_total_stats_model is not None\n        self.assertItemsEqual(\n            (\n                updated_translation_submitter_total_stats_model\n                .topic_ids_with_translation_submissions\n            ),\n            ['0', 'A']\n        )\n\n    def test_update_translation_review_stats_when_suggestion_is_accepted(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is accepted.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, new_change_dict, 'description')\n        change_dict_for_a_topic = (\n            self._set_up_a_topic_and_stories_for_translations())\n        topic_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '2', 1, self.author_id, change_dict_for_a_topic, 'description')\n\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            7\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            2\n        )\n\n        translation_reviewer_total_stats_model = (\n            suggestion_models.TranslationReviewerTotalContributionStatsModel\n            .get(\n                'hi', self.reviewer_id\n            )\n        )\n        translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_reviewer_total_stats_model is not None\n        self.assertEqual(\n            translation_reviewer_total_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_reviewer_total_stats_model\n                .reviewed_translations_count\n            ),\n            2\n        )\n        assert translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .accepted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            translation_submitter_total_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .recent_review_outcomes\n            ),\n            ['accepted', 'accepted']\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .recent_performance\n            ),\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .overall_accuracy\n            ),\n            100.0\n        )\n\n        suggestion_services.accept_suggestion(\n            topic_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                topic_suggestion.suggestion_id)\n        )\n        translation_reviewer_total_stats_model_for_a_topic = (\n            suggestion_models.TranslationReviewerTotalContributionStatsModel\n            .get(\n                'hi', self.reviewer_id\n            )\n        )\n        translation_submitter_total_stats_model_for_a_topic = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert translation_reviewer_total_stats_model_for_a_topic is not None\n        assert translation_submitter_total_stats_model_for_a_topic is not None\n        self.assertItemsEqual(\n            translation_reviewer_total_stats_model_for_a_topic.\n            topic_ids_with_translation_reviews,\n            ['0', 'A']\n        )\n\n        self.assertItemsEqual(\n            translation_submitter_total_stats_model_for_a_topic.\n            topic_ids_with_translation_submissions,\n            ['0', 'A']\n        )\n\n    def test_update_translation_review_stats_when_suggestion_is_rejected(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is rejected.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, change_dict, 'description')\n        suggestion_services.reject_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.reviewed_translations_count,\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            0\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translation_word_count,\n            0\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            6\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.rejected_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .rejected_translations_count\n            ),\n            2\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            0\n        )\n\n        translation_reviewer_total_stats_model = (\n            suggestion_models.TranslationReviewerTotalContributionStatsModel\n            .get(\n                'hi', self.reviewer_id\n            )\n        )\n        translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_reviewer_total_stats_model is not None\n        self.assertEqual(\n            translation_reviewer_total_stats_model.reviewed_translations_count,\n            2\n        )\n        self.assertEqual(\n            translation_reviewer_total_stats_model.accepted_translations_count,\n            0\n        )\n        self.assertEqual(\n            (\n                translation_reviewer_total_stats_model\n                .accepted_translation_word_count\n            ),\n            0\n        )\n        assert translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            translation_submitter_total_stats_model.rejected_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .rejected_translations_count\n            ),\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .accepted_translations_count\n            ),\n            0\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .recent_review_outcomes\n            ),\n            ['rejected', 'rejected']\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .recent_performance\n            ),\n            -4\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .overall_accuracy\n            ),\n            0.0\n        )\n\n    def test_update_translation_review_stats_without_a_reviewer_id(\n        self) -> None:\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        translation_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'The final_reviewer_id in the suggestion should not be None.'):\n            suggestion_services.update_translation_review_stats(\n                translation_suggestion)\n\n    def test_update_question_review_stats_without_a_reviewer_id(\n        self) -> None:\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        suggestion_services.update_question_contribution_stats_at_submission(\n            initial_suggestion\n        )\n\n        with self.assertRaisesRegex(\n            Exception,\n            'The final_reviewer_id in the suggestion should not be None.'):\n            suggestion_services.update_question_review_stats(\n                initial_suggestion\n            )\n\n    def test_update_translation_review_stats_when_suggestion_is_edited(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is accepted with reviewer edits.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, change_dict, 'description')\n        # Contributor's stats are updated manually since contributor's stats are\n        # checked later.\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            latest_suggestion\n        )\n        suggestion_services.update_translation_suggestion(\n            initial_suggestion.suggestion_id, 'Edited')\n        suggestion_services.update_translation_suggestion(\n            latest_suggestion.suggestion_id, 'Edited')\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translation_word_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model\n            .accepted_translations_with_reviewer_edits_count,\n            2\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            6\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translations_without_reviewer_edits_count\n            ),\n            0\n        )\n\n        translation_reviewer_total_stats_model = (\n            suggestion_models.TranslationReviewerTotalContributionStatsModel\n            .get(\n                'hi', self.reviewer_id\n            )\n        )\n        translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_reviewer_total_stats_model is not None\n        self.assertEqual(\n            translation_reviewer_total_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_reviewer_total_stats_model\n                .accepted_translation_word_count\n            ),\n            2\n        )\n        self.assertEqual(\n            translation_reviewer_total_stats_model\n            .accepted_translations_with_reviewer_edits_count,\n            2\n        )\n        assert translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .submitted_translations_count\n            ),\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .submitted_translation_word_count\n            ),\n            6\n        )\n        self.assertEqual(\n            translation_submitter_total_stats_model.recent_performance,\n            2\n        )\n        self.assertEqual(\n            translation_submitter_total_stats_model.overall_accuracy,\n            100.0\n        )\n        self.assertEqual(\n            translation_submitter_total_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_submitter_total_stats_model\n                .accepted_translations_without_reviewer_edits_count\n            ),\n            0\n        )\n\n    def test_increment_translation_stats_for_than_100_suggestions_accepted(\n        self) -> None:\n\n        change_dict = self._set_up_topics_and_100_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 0, self.author_id, change_dict, 'description')\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        for i in range(1, 102):\n            common_change_dict = self._get_change_with_normalized_string()\n            suggestion = suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                ('%s' % (i)), i, self.author_id, common_change_dict,\n                'description')\n            suggestion_services.update_translation_contribution_stats_at_submission( # pylint: disable=line-too-long\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id))\n            suggestion_services.accept_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n                'Accepted')\n            suggestion_services.update_translation_review_stats(\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id)\n            )\n\n        updated_translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert updated_translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            len(\n                updated_translation_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '102', 102, self.author_id, new_change_dict, 'description')\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected'\n        )\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        rejected_translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert rejected_translation_submitter_total_stats_model is not None\n\n        self.assertEqual(\n            len(\n                rejected_translation_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        self.assertEqual(\n            rejected_translation_submitter_total_stats_model\n            .recent_review_outcomes[99],\n            suggestion_models.REVIEW_OUTCOME_REJECTED\n        )\n\n    def test_increment_translation_stats_for_than_100_suggestions_rejected(\n        self) -> None:\n\n        change_dict = self._set_up_topics_and_100_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 0, self.author_id, change_dict, 'description')\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        for i in range(1, 102):\n            common_change_dict = self._get_change_with_normalized_string()\n            suggestion = suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                ('%s' % (i)), i, self.author_id, common_change_dict,\n                'description')\n            suggestion_services.update_translation_contribution_stats_at_submission( # pylint: disable=line-too-long\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id))\n            suggestion_services.reject_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n            suggestion_services.update_translation_review_stats(\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id)\n            )\n\n        updated_translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert updated_translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            len(\n                updated_translation_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '102', 102, self.author_id, new_change_dict, 'description')\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted'\n        )\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        accepted_translation_submitter_total_stats_model = (\n            suggestion_models.TranslationSubmitterTotalContributionStatsModel\n            .get(\n                'hi', self.author_id\n            )\n        )\n        assert accepted_translation_submitter_total_stats_model is not None\n        self.assertEqual(\n            len(\n                accepted_translation_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        self.assertEqual(\n            accepted_translation_submitter_total_stats_model\n            .recent_review_outcomes[99],\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED\n        )\n\n    def _create_question_suggestion(\n        self,\n        skill_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion corresponding to the supplied skill.\n\n        Args:\n            skill_id: str. ID of the skill.\n\n        Returns:\n            SuggestionAddQuestion. A new question suggestion.\n        \"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str,\n            Union[str, float, Dict[str, Union[\n                str, List[str], int, state_domain.StateDict]]]] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_2'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index\n                ),\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n    def _create_skill(self) -> str:\n        \"\"\"Creates a skill for a question.\n\n        Returns:\n            str. A skill ID.\n        \"\"\"\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        return skill_id\n\n    def _create_topic(self, first_skill_id: str, second_skill_id: str) -> str:\n        \"\"\"Creates a topic for a question.\n\n        Args:\n            first_skill_id: str. ID of the first skill.\n            second_skill_id: str. ID of the second skill.\n\n        Returns:\n            str. A topic ID.\n        \"\"\"\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, 'topic_admin', name='Topic1',\n            abbreviated_name='topic-three', url_fragment='topic-three',\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[first_skill_id, second_skill_id],\n            subtopics=[], next_subtopic_id=1)\n        return topic_id\n\n    def test_update_question_contribution_stats_when_submitting(self) -> None:\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        skill_id_3 = self._create_skill()\n        skill_id_4 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        topic_id_2 = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id_2, 'topic_admin', name='Topic2',\n            abbreviated_name='topic-three-1', url_fragment='topic-three-a',\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[skill_id_3, skill_id_4],\n            subtopics=[], next_subtopic_id=1)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        topic_id_2_suggestion = self._create_question_suggestion(skill_id_3)\n\n        # Action to update question contribution stats.\n        suggestion_services.update_question_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_question_contribution_stats_at_submission(\n            latest_suggestion\n        )\n\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question contribution stats before the review.\n        # At this point we can confirm that there should be an associated\n        # question contribution stat object for the given IDs since we have\n        # called update_question_contribution_stats_at_submission function to\n        # create/update question contribution stats.\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.submitted_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            0\n        )\n\n        question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                self.author_id\n            )\n        )\n        # Assert question contribution stats before the review.\n        # At this point we can confirm that there should be an associated\n        # question contribution stat object for the given IDs since we have\n        # called update_question_contribution_stats_at_submission function to\n        # create/update question contribution stats.\n        assert question_submitter_total_stats_model is not None\n        self.assertEqual(\n            question_submitter_total_stats_model.submitted_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.recent_review_outcomes,\n            []\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.recent_performance,\n            0\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.overall_accuracy,\n            0.0\n        )\n\n        suggestion_services.update_question_contribution_stats_at_submission(\n            topic_id_2_suggestion\n        )\n        question_submitter_total_stats_model_with_topic_id_2 = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                self.author_id\n            )\n        )\n\n        self.assertItemsEqual(\n            (\n                question_submitter_total_stats_model_with_topic_id_2.\n                topic_ids_with_question_submissions\n            ),\n            [topic_id, topic_id_2]\n        )\n\n    def test_update_question_stats_when_suggestion_is_accepted(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is accepted.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        skill_id_3 = self._create_skill()\n        skill_id_4 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        topic_id_2 = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id_2, 'topic_admin', name='Topic2',\n            abbreviated_name='topic-three-1', url_fragment='topic-three-a',\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[skill_id_3, skill_id_4],\n            subtopics=[], next_subtopic_id=1)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id\n            )\n        )\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id\n            )\n        )\n\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        # Action to update stats when reviewing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            2\n        )\n\n        question_reviewer_total_stats_model = (\n            suggestion_models.QuestionReviewerTotalContributionStatsModel\n            .get_by_id(\n                self.reviewer_id\n            )\n        )\n        question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                self.author_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_reviewer_total_stats_model is not None\n        self.assertEqual(\n            question_reviewer_total_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_reviewer_total_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_submitter_total_stats_model is not None\n        self.assertEqual(\n            question_submitter_total_stats_model.submitted_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_submitter_total_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            2\n        )\n        self.assertEqual(\n            (\n                question_submitter_total_stats_model\n                .recent_review_outcomes\n            ),\n            ['accepted', 'accepted']\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.recent_performance,\n            2\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.overall_accuracy,\n            100.0\n        )\n\n        topic_id_2_suggestion = self._create_question_suggestion(skill_id_3)\n        suggestion_services.accept_suggestion(\n            topic_id_2_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                topic_id_2_suggestion.suggestion_id)\n        )\n        question_reviewer_total_stats_model_with_topic_id_2 = (\n            suggestion_models.QuestionReviewerTotalContributionStatsModel\n            .get_by_id(\n                self.reviewer_id\n            )\n        )\n\n        self.assertItemsEqual(\n            (\n                question_reviewer_total_stats_model_with_topic_id_2\n                .topic_ids_with_question_reviews\n            ),\n            [topic_id, topic_id_2]\n        )\n\n    def test_update_question_stats_when_suggestion_is_rejected(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is rejected.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        suggestion_services.reject_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n\n        # Action to update stats when revieweing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n\n        question_reviewer_total_stats_model = (\n            suggestion_models.QuestionReviewerTotalContributionStatsModel\n            .get_by_id(\n                self.reviewer_id\n            )\n        )\n        question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                self.author_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_reviewer_total_stats_model is not None\n        self.assertEqual(\n            question_reviewer_total_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_reviewer_total_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            question_reviewer_total_stats_model.rejected_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_reviewer_total_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_submitter_total_stats_model is not None\n        self.assertEqual(\n            question_submitter_total_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.rejected_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_submitter_total_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.recent_performance,\n            -4\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.overall_accuracy,\n            0.0\n        )\n\n    def test_update_question_stats_when_suggestion_is_edited(\n        self\n    ) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is accepted with reviewer edits.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        content_id_generator = translation_domain.ContentIdGenerator()\n        question_state_data = self._create_valid_question_data(\n            'default_state', content_id_generator).to_dict()\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.update_question_suggestion(\n            initial_suggestion.suggestion_id, 0.6, question_state_data,\n            content_id_generator.next_content_id_index)\n        suggestion_services.update_question_suggestion(\n            latest_suggestion.suggestion_id, 0.6, question_state_data,\n            content_id_generator.next_content_id_index)\n\n        # Actual action to update stats when reviewing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .accepted_questions_with_reviewer_edits_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n\n        question_reviewer_total_stats_model = (\n            suggestion_models.QuestionReviewerTotalContributionStatsModel\n            .get_by_id(\n                self.reviewer_id\n            )\n        )\n        question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(\n                self.author_id\n            )\n        )\n        # Assert question review stats.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_reviewer_total_stats_model is not None\n        self.assertEqual(\n            question_reviewer_total_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_reviewer_total_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_reviewer_total_stats_model\n                .accepted_questions_with_reviewer_edits_count\n            ),\n            2\n        )\n        assert question_submitter_total_stats_model is not None\n        self.assertEqual(\n            question_submitter_total_stats_model.submitted_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_submitter_total_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n        self.assertEqual(\n            (\n                question_submitter_total_stats_model\n                .recent_review_outcomes\n            ),\n            ['accepted_with_edits', 'accepted_with_edits']\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.recent_performance,\n            2\n        )\n        self.assertEqual(\n            question_submitter_total_stats_model.overall_accuracy,\n            100.0\n        )\n\n    def generate_random_string(self, length: int) -> str:\n        \"\"\"Generate a random string of given length.\n\n        Args:\n            length: int. Length of the string to be generated.\n\n        Returns:\n            str. Generated string.\n        \"\"\"\n        letters = string.ascii_letters\n        return (''.join(random.choice(letters) for _ in range(length))).lower()\n\n    def test_increment_question_stats_for_than_100_suggestions_accepted(\n        self) -> None:\n\n        for i in range(102):\n            skill_id = self._create_skill()\n            topic_id = topic_fetchers.get_new_topic_id()\n            self.save_new_topic(\n                topic_id, 'topic_admin', name='Topic %s' % (i),\n                abbreviated_name='topic-three-1',\n                url_fragment=self.generate_random_string(20),\n                description='Description',\n                canonical_story_ids=[],\n                additional_story_ids=[],\n                uncategorized_skill_ids=[skill_id],\n                subtopics=[], next_subtopic_id=i)\n            suggestion = self._create_question_suggestion(skill_id)\n            suggestion_services.update_question_contribution_stats_at_submission( # pylint: disable=line-too-long\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id\n                )\n            )\n            suggestion_services.accept_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n                'Accepted')\n            suggestion_services.update_question_review_stats(\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id)\n            )\n\n        updated_question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(self.author_id)\n        )\n\n        self.assertEqual(\n            len(\n                updated_question_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        new_skill_id = self._create_skill()\n        new_topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            new_topic_id, 'topic_admin', name='New Topic Rejected',\n            abbreviated_name='topic-three-1',\n            url_fragment=self.generate_random_string(20),\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[new_skill_id],\n            subtopics=[], next_subtopic_id=102)\n        latest_suggestion = self._create_question_suggestion(new_skill_id)\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id\n            )\n        )\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        rejected_question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(self.author_id)\n        )\n\n        self.assertEqual(\n            len(\n                rejected_question_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        self.assertEqual(\n            rejected_question_submitter_total_stats_model\n            .recent_review_outcomes[99],\n            suggestion_models.REVIEW_OUTCOME_REJECTED\n        )\n\n    def test_increment_question_stats_for_than_100_suggestions_rejected(\n        self) -> None:\n\n        for i in range(102):\n            skill_id = self._create_skill()\n            topic_id = topic_fetchers.get_new_topic_id()\n            self.save_new_topic(\n                topic_id, 'topic_admin', name='Topic %s' % (i),\n                abbreviated_name='topic-three-1',\n                url_fragment=self.generate_random_string(20),\n                description='Description',\n                canonical_story_ids=[],\n                additional_story_ids=[],\n                uncategorized_skill_ids=[skill_id],\n                subtopics=[], next_subtopic_id=i)\n            suggestion = self._create_question_suggestion(skill_id)\n            suggestion_services.update_question_contribution_stats_at_submission( # pylint: disable=line-too-long\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id\n                )\n            )\n            suggestion_services.reject_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n            suggestion_services.update_question_review_stats(\n                suggestion_services.get_suggestion_by_id(\n                    suggestion.suggestion_id)\n            )\n\n        updated_question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(self.author_id)\n        )\n\n        self.assertEqual(\n            len(\n                updated_question_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        new_skill_id = self._create_skill()\n        new_topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            new_topic_id, 'topic_admin', name='New Topic Rejected',\n            abbreviated_name='topic-three-1',\n            url_fragment=self.generate_random_string(20),\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[new_skill_id],\n            subtopics=[], next_subtopic_id=102)\n        latest_suggestion = self._create_question_suggestion(new_skill_id)\n        suggestion_services.update_question_contribution_stats_at_submission(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id\n            )\n        )\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        accepted_question_submitter_total_stats_model = (\n            suggestion_models.QuestionSubmitterTotalContributionStatsModel\n            .get_by_id(self.author_id)\n        )\n\n        self.assertEqual(\n            len(\n                accepted_question_submitter_total_stats_model\n                .recent_review_outcomes),\n            100\n        )\n\n        self.assertEqual(\n            accepted_question_submitter_total_stats_model\n            .recent_review_outcomes[99],\n            suggestion_models.REVIEW_OUTCOME_ACCEPTED\n        )\n\n    def test_create_and_reject_suggestion(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change_cmd, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.reject_suggestion(\n            suggestion_id, self.reviewer_id, 'Reject message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Reject message')\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>old content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_REJECTED)\n\n    def test_create_and_accept_suggestion_with_message(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change_cmd, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'Accept message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Accept message')\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_auto_reject_translation_suggestions_for_content_ids(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            self.create_translation_suggestion_associated_with_exp(\n                self.EXP_ID, self.author_id)\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.auto_reject_translation_suggestions_for_content_ids(\n            self.EXP_ID, {'content_0'})\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text,\n            constants.OBSOLETE_TRANSLATION_SUGGESTION_REVIEW_MSG)\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, feconf.SUGGESTION_BOT_USER_ID)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_skill_rejects_question_suggestion(self) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        self.assert_created_suggestion_is_valid(skill_id, self.author_id)\n\n        skill_services.delete_skill(self.author_id, skill_id)\n\n        # Suggestion should be rejected after corresponding skill is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', skill_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_topic_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        topic_services.delete_topic(self.author_id, self.TOPIC_ID)\n\n        # Suggestion should be rejected after the topic is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_story_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        story_services.delete_story(self.author_id, self.STORY_ID)\n\n        # Suggestion should be rejected after the story is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_swap_exp_from_story_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        # Swaps the exploration from the story.\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': self.EXP_ID,\n                'new_value': 'another_exp_id'\n            })], 'Changed exploration.')\n\n        # Suggestion should be rejected after exploration is swapped in the\n        # story.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_get_suggestions_with_translatable_explorations(self) -> None:\n        # Create a translation suggestion for (state_name, content_id) =\n        # (State 2, content).\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        state_name = 'State 2'\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': state_name,\n            'content_id': exploration.states[state_name].content.content_id,\n            'language_code': 'hi',\n            'content_html': exploration.states[state_name].content.html,\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.EXP_ID, 1, self.author_id, add_translation_change_dict,\n            'test description')\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n\n        translatable_suggestions = []\n        for suggestion in suggestions:\n            assert isinstance(\n                suggestion, suggestion_registry.SuggestionTranslateContent\n            )\n            translatable_suggestions.append(suggestion)\n\n        # Should return the created translation suggestion.\n        filtered_translatable_suggestions = (\n            suggestion_services.get_suggestions_with_editable_explorations(\n                translatable_suggestions\n            )\n        )\n        self.assertEqual(len(filtered_translatable_suggestions), 1)\n\n        # Disable exploration editing.\n        exp_services.set_exploration_edits_allowed(self.EXP_ID, False)\n\n        # Should not return the created translation suggestion.\n        filtered_translatable_suggestions = (\n            suggestion_services.get_suggestions_with_editable_explorations(\n                translatable_suggestions\n            )\n        )\n        self.assertEqual(len(filtered_translatable_suggestions), 0)\n\n\nclass UserContributionProficiencyUnitTests(test_utils.GenericTestBase):\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup('user1@example.com', 'user1')\n        self.signup('user2@example.com', 'user2')\n        self.user_1_id = self.get_user_id_from_email('user1@example.com')\n        self.user_2_id = self.get_user_id_from_email('user2@example.com')\n\n    def test_get_all_user_ids_who_are_allowed_to_review(self) -> None:\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2',\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category2', 0)\n\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category1'))\n        self.assertEqual(user_ids, [])\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category2'))\n        self.assertEqual(user_ids, [self.user_1_id])\n\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category1'))\n        self.assertTrue(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category2'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n\n    def test_get_all_scores_of_the_user_with_multiple_scores(self) -> None:\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 1)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2', 2)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category3', 3)\n\n        expected_scores_dict = {}\n        for index in range(1, 4):\n            key = 'category%s' % str(index)\n            expected_scores_dict[key] = index\n\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 3)\n        self.assertDictEqual(scores_dict, expected_scores_dict)\n\n    def test_get_all_scores_of_the_user_when_no_scores_exist(self) -> None:\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 0)\n        self.assertDictEqual(scores_dict, {})\n\n\nclass ReviewableSuggestionEmailInfoUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Tests the methods related to the ReviewableSuggestionEmailInfo class.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill1'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author1@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_translation_html(\n        self, translation_html: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion with the given translation_html.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': 'content_0',\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_STATE_CONTENT_STR,\n            'translation_html': translation_html,\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_question_html_content(\n        self, question_html_content: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the html content used for the\n        question in the question suggestion.\n        \"\"\"\n        with self.swap(\n            feconf, 'DEFAULT_STATE_CONTENT_STR', question_html_content):\n            content_id_generator = translation_domain.ContentIdGenerator()\n            add_question_change_dict: Dict[\n                str, Union[str, float, question_domain.QuestionDict]\n            ] = {\n                'cmd': (\n                    question_domain\n                    .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                'question_dict': {\n                    'id': 'test_id',\n                    'version': 12,\n                    'question_state_data': self._create_valid_question_data(\n                        'default_state', content_id_generator).to_dict(),\n                    'language_code': self.language_code,\n                    'question_state_data_schema_version': (\n                        feconf.CURRENT_STATE_SCHEMA_VERSION),\n                    'linked_skill_ids': ['skill_1'],\n                    'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                    'next_content_id_index': (\n                        content_id_generator.next_content_id_index)\n                },\n                'skill_id': self.skill_id,\n                'skill_difficulty': 0.3\n            }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionEditStateContent:\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict: Dict[\n            str, Union[str, Dict[str, str]]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content_0',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            None)\n\n    def _assert_reviewable_suggestion_email_infos_are_equal(\n        self,\n        reviewable_suggestion_email_info: (\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ),\n        expected_reviewable_suggestion_email_info: (\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        )\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email info is equal to the\n        expected reviewable suggestion email info.\n        \"\"\"\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_type,\n            expected_reviewable_suggestion_email_info.suggestion_type)\n        self.assertEqual(\n            reviewable_suggestion_email_info.language_code,\n            expected_reviewable_suggestion_email_info.language_code)\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_content,\n            expected_reviewable_suggestion_email_info.suggestion_content)\n        self.assertEqual(\n            reviewable_suggestion_email_info.submission_datetime,\n            expected_reviewable_suggestion_email_info.submission_datetime)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n\n    def test_create_raises_for_suggestion_type_not_on_contributor_dashboard(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        # Mocking the SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS dict in\n        # suggestion services so that this test still passes if the\n        # \"edit state content\" suggestion type is added to the Contributor\n        # Dashboard in the future.\n        suggestion_emphasized_text_getter_functions_mock: Dict[str, str] = {}\n\n        with self.swap(\n            suggestion_services, 'SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS',\n            suggestion_emphasized_text_getter_functions_mock):\n            with self.assertRaisesRegex(\n                Exception,\n                'Expected suggestion type to be offered on the Contributor '\n                'Dashboard, received: %s.' % (\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)):\n                (\n                    suggestion_services\n                    .create_reviewable_suggestion_email_info_from_suggestion(\n                        edit_state_content_suggestion)\n                )\n\n    def test_contributor_suggestion_types_are_in_suggestion_text_getter_dict(\n        self\n    ) -> None:\n        # This test will fail if a new suggestion type is added to the\n        # Contributor Dashboard but hasn't been added to\n        # SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.\n        sorted_text_getter_dict_suggestion_types = sorted(\n            suggestion_services\n            .SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.keys())\n        sorted_contributor_dashboard_suggestion_types = sorted(\n            feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES)\n\n        self.assertListEqual(\n            sorted_text_getter_dict_suggestion_types,\n            sorted_contributor_dashboard_suggestion_types)\n\n    def test_create_from_suggestion_returns_info_for_question_suggestion(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p>default question content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'default question content',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_translation_suggestion(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p>default translation content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'default translation content',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_empty_html(self) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ''))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code, '',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_with_no_trailing_whitespace(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ' <p>          test whitespace     </p>    '))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'test whitespace',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_math_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_image_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-image alt-with-value=\\'&amp;quot;'\n                'test&amp;quot;\\' caption-with-value=\\'&amp;quot;&amp;'\n                'quot;\\' filepath-with-value=\\'&amp;quot;img.svg&amp;quot;'\n                '\\'></oppia-noninteractive-image></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Image]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_link_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_repeats(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_multi_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_value(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                '[Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_math_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_image_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-image alt-with-value=\\'&amp;quot;'\n                'testing&amp;quot;\\' caption-with-value=\\'&amp;quot;&amp;'\n                'quot;\\' filepath-with-value=\\'&amp;quot;img.svg&amp;quot;'\n                '\\'></oppia-noninteractive-image></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Image]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info)\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_link_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_repeat_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_multi_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_rte_value(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_text(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\">text</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_html(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"><p>text</p></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_multi_word(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link-test text-with-value='\n                '\"&amp;quot;Test a tag&amp;quot;\" url-with-value=\"&amp;quot;'\n                'somelink&amp;quot;\"><p>text</p>'\n                '</oppia-noninteractive-link-test></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link Test]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n\nclass GetSuggestionsWaitingForReviewInfoToNotifyReviewersUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_suggestions_waitng_for_review_info_to_notify_reviewers method\n    in suggestion services, which is used to retrieve the information required\n    to notify reviewers that there are suggestions that need review.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author1@example.com'\n    REVIEWER_1_EMAIL: Final = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL: Final = 'reviewer2@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_language_code_and_author(\n        self, language_code: str, author_id: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code with the\n        given author id.\n        \"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': 'content_0',\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_skill_id_and_author_id(\n        self, skill_id: str, author_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n        self, suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> List[suggestion_registry.ReviewableSuggestionEmailInfo]:\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n        self,\n        reviewable_suggestion_email_infos: (\n            List[suggestion_registry.ReviewableSuggestionEmailInfo]\n        ),\n        expected_reviewable_suggestion_email_infos: (\n            List[suggestion_registry.ReviewableSuggestionEmailInfo]\n        )\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        exploration = self.save_new_valid_exploration(\n            self.target_id, self.author_id)\n        audio_language_codes = set(\n            language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES)\n        model = opportunity_models.ExplorationOpportunitySummaryModel(\n            id=exploration.id,\n            topic_id='topic_id',\n            topic_name='topic_name',\n            story_id='story_id',\n            story_title='story_title',\n            chapter_title='chapter_title',\n            content_count=2,\n            incomplete_translation_language_codes=(\n                audio_language_codes - set(['en'])),\n            translation_counts={},\n            language_codes_needing_voice_artists=audio_language_codes,\n            language_codes_with_assigned_voice_artists=[]\n        )\n        model.update_timestamps()\n        model.put()\n\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_get_returns_empty_for_reviewers_who_authored_the_suggestions(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_question_reviewers_if_only_translation_exist(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_translation_reviewers_if_only_question_exist(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_accepted_suggestions(self) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_rejected_suggestions(self) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_a_translation_reviewer_same_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_empty_for_a_translation_reviewer_with_diff_lang_rights(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_translation_reviewer_multi_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_same_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create another translation suggestion so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit.\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_diff_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        # Create another hindi and english translation suggestion so that we\n        # reach the MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit for each\n        # language code but continue to update which suggestions have been\n        # waiting the longest (since the top two suggestions waiting the\n        # longest are from different language codes).\n        self._create_translation_suggestion_with_language_code_and_author(\n            'en', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 2):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multiple_translation_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_suggestion_infos_for_reviewer_with_multi_review_rights(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_4 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_a_question_reviewer(self) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_question_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_question_reviewer_past_limit(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_2', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]\n                )\n            )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_reviewers_with_multi_rights(\n        self\n    ) -> None:\n        # Reviewer 1's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        # Reviewer 2's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'fr')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'fr', self.author_id))\n        suggestion_4 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_6 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_4, suggestion_5,\n                    suggestion_6]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_infos_for_reviewer_with_multi_rights_past_limit(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create additional suggestions so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit regardless of\n        # suggestion type.\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n\nclass CommunityContributionStatsUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functionality related to updating the community contribution\n    stats.\n\n    TODO(#10957): It is currently not possible to resubmit a rejected\n    translation suggestion for review. As a result, there isn't a test for\n    that case in this test class. If the functionality is added, a new test\n    should be added here to cover that case. If the functionality is not going\n    to be added then this can be removed. See issue #10957 for more context.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': 'content_0',\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionEditStateContent:\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict: Dict[\n            str, Union[str, Dict[str, str]]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content_0',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(self) -> None:\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats()\n        )\n\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        exploration = self.save_new_valid_exploration(\n            self.target_id, self.author_id)\n        audio_language_codes = set(\n            language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES)\n        model = opportunity_models.ExplorationOpportunitySummaryModel(\n            id=exploration.id,\n            topic_id='topic_id',\n            topic_name='topic_name',\n            story_id='story_id',\n            story_title='story_title',\n            chapter_title='chapter_title',\n            content_count=2,\n            incomplete_translation_language_codes=(\n                audio_language_codes - set(['en'])),\n            translation_counts={},\n            language_codes_needing_voice_artists=audio_language_codes,\n            language_codes_with_assigned_voice_artists=[]\n        )\n        model.update_timestamps()\n        model.put()\n\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_create_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        self._create_edit_state_content_suggestion()\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_accept_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.accept_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestions_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion_1 = (\n            self._create_edit_state_content_suggestion())\n        edit_state_content_suggestion_2 = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestions(\n            [\n                edit_state_content_suggestion_1.suggestion_id,\n                edit_state_content_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the new_value of the html of the suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_suggestion_change = edit_state_content_suggestion.change_cmd\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_suggestion_change.new_value, dict)\n        resubmit_suggestion_change.new_value['html'] = 'new html to resubmit'\n\n        # Resubmit the rejected \"edit state content\" suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            edit_state_content_suggestion.suggestion_id,\n            'resubmit summary message', self.author_id,\n            resubmit_suggestion_change)\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_question_suggestion_increases_question_suggestion_count(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_multi_question_suggestions_increases_question_count(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_accept_question_suggestion_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.accept_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestion_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestions_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion_1 = self._create_question_suggestion()\n        question_suggestion_2 = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestions(\n            [\n                question_suggestion_1.suggestion_id,\n                question_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_question_suggestion_increases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        # Assert that the question suggestion decreased because the suggestion\n        # was rejected.\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = question_suggestion.change_cmd\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_question_change.question_dict, dict)\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            question_suggestion.suggestion_id, 'resubmit summary message',\n            self.author_id, resubmit_question_change\n        )\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_translation_suggestion_raises_translation_suggestion_count(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code(\n            self.language_code)\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n    def test_create_translation_suggestions_diff_lang_raises_translation_counts(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n    def test_create_translation_suggestions_eq_lang_increases_translation_count(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'hi': 2})\n\n    def test_accept_translation_suggestion_lowers_translation_suggestion_count(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n                self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestion_lowers_translation_suggestion_count(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_one_translation_suggestion_diff_lang_lowers_only_one_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        # Create a translation suggestion in a different language that won't be\n        # rejected.\n        self._create_translation_suggestion_with_language_code('en')\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion_1.suggestion_id, self.reviewer_id,\n            'review message')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'en': 1})\n\n    def test_reject_translation_suggestions_diff_lang_lowers_translation_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestions_same_lang_lowers_translation_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 2})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_suggestions_diff_type_decreases_suggestion_counts(\n        self\n    ) -> None:\n        suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        suggestion_3 = self._create_edit_state_content_suggestion()\n        suggestion_4 = self._create_question_suggestion()\n        # Assert that the suggestion counts increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                suggestion_1.suggestion_id, suggestion_2.suggestion_id,\n                suggestion_3.suggestion_id, suggestion_4.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_suggestions_diff_type_increases_suggestion_counts(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n\nclass GetSuggestionsWaitingTooLongForReviewInfoForAdminsUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_info_about_suggestions_waiting_too_long_for_review method in suggestion\n    services, which is used to retrieve the information required to notify\n    admins if there are suggestions that have waited longer than\n    suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days for a\n    review on the Contributor Dashboard.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: str = 'author@example.com'\n    REVIEWER_1_EMAIL: str = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL: str = 'reviewer2@community.org'\n    COMMIT_MESSAGE: str = 'commit message'\n    mocked_datetime_utcnow: datetime.datetime = (\n        datetime.datetime(2020, 6, 15, 5)\n    )\n\n    def _create_translation_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': 'content_0',\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n        self, suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> List[suggestion_registry.ReviewableSuggestionEmailInfo]:\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n        self, reviewable_suggestion_email_infos: List[\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ],\n        expected_reviewable_suggestion_email_infos: List[\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ]\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_get_returns_empty_for_suggestion_type_not_on_contributor_dashboard(\n        self\n    ) -> None:\n        self._create_translation_suggestion()\n        # This mocked list cannot be empty because then the storage query in the\n        # get_suggestions_waiting_too_long_for_review method will fail.\n        mocked_contributor_dashboard_suggestion_types = [\n            feconf.SUGGESTION_TYPE_ADD_QUESTION]\n\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES',\n            mocked_contributor_dashboard_suggestion_types):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestion_review_wait_time_diff_is_negative(\n        self\n    ) -> None:\n        self._create_translation_suggestion()\n\n        # Make sure the threshold is nonzero.\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 1):\n            info_about_suggestions_waiting_too_long_for_review = (\n                suggestion_services\n                .get_info_about_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestions_have_waited_less_than_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n            self._create_question_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_less_than_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=1))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_less_than_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_new_suggestions_for_reviewer_notifications_past_threshold(\n        self) -> None:\n        max_suggestions = 3\n        threshold_days = 2\n        creation_time = datetime.datetime(2020, 6, 14, 5)\n        creation_time_in_millisecs = int(creation_time.timestamp() * 1000)\n        mock_value = creation_time_in_millisecs\n\n        mock_get_current_time_in_millisecs = lambda: mock_value\n\n        with self.swap(\n            utils, 'get_current_time_in_millisecs',\n            mock_get_current_time_in_millisecs):\n            with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n\n                # Create and save new suggestion models.\n                suggestions = []\n                for _ in range(1, max_suggestions + 1):\n                    suggestion = self._create_translation_suggestion()\n                    suggestions.append(suggestion)\n\n                # Set the review wait time threshold.\n                with self.swap(\n                    suggestion_models,\n                    'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                    threshold_days):\n                    suggestion_info = (\n                        suggestion_services.\n                            get_new_suggestions_for_reviewer_notifications())\n\n                # Assert that the correct number of suggestions is returned.\n                self.assertEqual(len(suggestion_info), 3)\n\n    def test_get_returns_empty_if_suggestions_have_waited_threshold_review_time(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_eq_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(\n                days=mocked_threshold_review_wait_time_in_days))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_eq_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_suggestion_waited_long_if_their_wait_is_past_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        # Give the question suggestion a slightly different review submission\n        # time so that the suggestions are not indistinguishable, in terms of\n        # their review submission time.\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(minutes=5)):\n            question_suggestion = self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion, question_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 1\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n    def test_get_only_returns_suggestions_that_have_waited_past_wait_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2)):\n            self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 3\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=4))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        # The question suggestion was created 2 days after the translation\n        # suggestion, so it has only waited 1 day for a review, which is less\n        # than 3, the mocked review wait time threshold. Therefore, only the\n        # translation suggestion has waited too long for review.\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n\nclass GetSuggestionTypesThatNeedReviewersUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the get_suggestion_types_that_need_reviewers method.\"\"\"\n\n    sample_language_code: str = 'en'\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': 'content_0',\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': constants.DEFAULT_LANGUAGE_CODE,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(\n        self\n    ) -> None:\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats())\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n\n    def test_get_returns_no_reviewers_needed_if_no_suggestions_exist(\n        self\n    ) -> None:\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_question_reviewer_no_question(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_not_needed_if_translation_reviewers_but_no_translation(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_translation_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_question_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_reviewers_needed_if_question_but_no_reviewers(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_ADD_QUESTION: set()})\n\n    def test_get_returns_reviewers_needed_if_translation_for_a_lang_no_reviewer(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code(\n            self.sample_language_code)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                self.sample_language_code: 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                self.sample_language_code}})\n\n    def test_get_returns_reviewers_needed_if_translation_for_langs_no_reviewers(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {'en', 'fr'}})\n\n    def test_get_returns_reviewers_needed_if_multi_suggestion_types_no_reviewer(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                    'en', 'fr'},\n                feconf.SUGGESTION_TYPE_ADD_QUESTION: set()\n            })\n\n\nclass EmailsTaskqueueTests(test_utils.GenericTestBase):\n    \"\"\"Tests for tasks in emails taskqueue.\"\"\"\n\n    def test_create_new_instant_task(self) -> None:\n        user_id = 'user'\n        (\n            suggestion_services\n            .enqueue_contributor_ranking_notification_email_task(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'hi',\n                'Initial Contributor'\n            ))\n\n        self.assertEqual(\n            self.count_jobs_in_taskqueue(\n                taskqueue_services.QUEUE_NAME_EMAILS),\n            1)\n\n        tasks = self.get_pending_tasks(\n            queue_name=taskqueue_services.QUEUE_NAME_EMAILS)\n        self.assertEqual(\n            tasks[0].url,\n            feconf\n            .TASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS)\n        # Ruling out the possibility of None for mypy type checking.\n        assert tasks[0].payload is not None\n        self.assertEqual(\n            tasks[0].payload['contributor_user_id'], user_id)\n        self.assertEqual(\n            tasks[0].payload['contribution_type'],\n            feconf.CONTRIBUTION_TYPE_TRANSLATION)\n        self.assertEqual(\n            tasks[0].payload['contribution_sub_type'],\n            feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE)\n        self.assertEqual(tasks[0].payload['language_code'], 'hi')\n        self.assertEqual(\n            tasks[0].payload['rank_name'], 'Initial Contributor')\n\n    def test_create_email_task_raises_exception_for_invalid_language_code(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Not supported language code: error'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'error',\n                'Initial Contributor'\n            )\n\n    def test_create_email_task_raises_exception_for_invalid_contribution_type(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Invalid contribution type: test'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, 'test',\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'hi',\n                'Initial Contributor'\n            )\n\n    def test_create_email_task_raises_exception_for_wrong_contribution_subtype(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Invalid contribution subtype: test'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                'test', 'hi',\n                'Initial Contributor'\n            )\n\n\nclass ContributorCertificateTests(test_utils.GenericTestBase):\n    \"\"\"Tests for contributor certificate generation.\"\"\"\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.username = user_services.get_username(self.author_id)\n        self.from_date = datetime.datetime.today() - datetime.timedelta(days=1)\n        self.to_date = datetime.datetime.today() + datetime.timedelta(days=1)\n\n    def _get_change_with_normalized_string(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Provides change_cmd dictionary with normalized translation html.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change_cmd object for the translations.\n        \"\"\"\n        return {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content_0',\n            'language_code': 'hi',\n            'content_html': '<p>A content to translate.</p>',\n            'state_name': 'Introduction',\n            'translation_html': ['translated text1', 'translated text2'],\n            'data_format': 'set_of_normalized_string'\n        }\n\n    def _calculate_translation_contribution_hours(\n        self, numer_of_words: int\n    ) -> str:\n        \"\"\"Provides translatoin contribution hours when number of translated\n        words are provided. We calculate the time taken to translate\n        a word according to the following document.\n        https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit#gid=0\n\n        Args:\n            numer_of_words: int. The number of translated words.\n\n        Returns:\n            str. A string that represent the translatoin contribution hours.\n        \"\"\"\n        return str(round(numer_of_words / 300, 2))\n\n    def _calculate_question_contribution_hours(\n        self, images_included: bool\n    ) -> str:\n        \"\"\"Provides question contribution hours when number of questions\n        are provided. We calculate the time taken to submit\n        a question according to the following document.\n        https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit#gid=0\n\n        Args:\n            images_included: bool. A flag that says whether the question\n                contains images.\n\n        Returns:\n            str. A string that represent the question contribution hours.\n        \"\"\"\n        minutes_contributed = 0\n\n        if images_included:\n            minutes_contributed += 20\n        else:\n            minutes_contributed += 12\n        return str(round(minutes_contributed / 60, 2))\n\n    def test_create_translation_contributor_certificate(self) -> None:\n        score_category: str = ('%s%sEnglish' % (\n            suggestion_models.SCORE_TYPE_TRANSLATION,\n            suggestion_models.SCORE_CATEGORY_DELIMITER)\n        )\n        change_cmd = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_1', change_cmd, score_category,\n            'exploration.exp1.thread_6', 'hi')\n\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            ))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert certificate_data is not None\n\n        self.assertEqual(\n            certificate_data['contribution_hours'],\n            self._calculate_translation_contribution_hours(3)\n        )\n        self.assertEqual(certificate_data['language'], 'Hindi')\n\n    def test_create_translation_contributor_certificate_for_rule_translation(\n        self\n    ) -> None:\n        score_category: str = '%s%sEnglish' % (\n            suggestion_models.SCORE_TYPE_TRANSLATION,\n            suggestion_models.SCORE_CATEGORY_DELIMITER\n        )\n\n        change_cmd = self._get_change_with_normalized_string()\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_1', change_cmd, score_category,\n            'exploration.exp1.thread_6', 'hi')\n\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            ))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert certificate_data is not None\n\n        self.assertEqual(\n            certificate_data['contribution_hours'],\n            self._calculate_translation_contribution_hours(4)\n        )\n        self.assertEqual(certificate_data['language'], 'Hindi')\n\n    def test_create_translation_contributor_certificate_for_english(\n        self\n    ) -> None:\n        score_category: str = '%s%sEnglish' % (\n            suggestion_models.SCORE_TYPE_TRANSLATION,\n            suggestion_models.SCORE_CATEGORY_DELIMITER\n        )\n\n        change_cmd = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content',\n            'language_code': 'en',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_1', change_cmd, score_category,\n            'exploration.exp1.thread_6', 'en')\n\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'en',\n                self.from_date,\n                self.to_date,\n            ))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert certificate_data is not None\n\n        self.assertEqual(\n            certificate_data['contribution_hours'],\n            self._calculate_translation_contribution_hours(3)\n        )\n        self.assertEqual(certificate_data['language'], 'English')\n\n    def test_create_question_contributor_certificate(self) -> None:\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': 1,\n            'skill_difficulty': 0.3\n        }\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content']['html'] = '<p>No image content</p>'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', 1,\n            suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_2', suggestion_change, 'category1',\n            'thread_1', 'en')\n\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                None,\n                self.from_date,\n                self.to_date,\n            ))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert certificate_data is not None\n\n        self.assertEqual(\n            certificate_data['contribution_hours'],\n            self._calculate_question_contribution_hours(False)\n        )\n\n    def test_create_question_contributor_certificate_with_image_content(\n        self\n    ) -> None:\n        content_id_generator = translation_domain.ContentIdGenerator()\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state', content_id_generator).to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1'],\n                'next_content_id_index': (\n                    content_id_generator.next_content_id_index)\n            },\n            'skill_id': 1,\n            'skill_difficulty': 0.3\n        }\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content']['html'] = (\n            '<oppia-noninteractive-image></oppia-noninteractive-image>')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', 1,\n            suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_2', suggestion_change, 'category1',\n            'thread_1', 'en')\n\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                None,\n                self.from_date,\n                self.to_date,\n            ))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert certificate_data is not None\n\n        self.assertEqual(\n            certificate_data['contribution_hours'],\n            self._calculate_question_contribution_hours(True)\n        )\n\n    def test_create_certificate_returns_none_for_no_translation_suggestions(\n        self\n    ) -> None:\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            ))\n\n        self.assertIsNone(certificate_data)\n\n    def test_create_certificate_returns_none_for_no_question_suggestions(\n        self\n    ) -> None:\n        certificate_data = (\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                None,\n                self.from_date,\n                self.to_date,\n            ))\n\n        self.assertIsNone(certificate_data)\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_language(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'The provided language is invalid.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'test',\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_username(\n        self\n    ) -> None:\n        username = 'wrong_user'\n\n        with self.assertRaisesRegex(\n            Exception, 'There is no user for the given username.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_type(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'The suggestion type is invalid.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                'test',\n                self.from_date,\n                self.to_date,\n            )\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/translation-modal.component.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for TranslationModalComponent.\n */\n\nimport {\n  HttpClientTestingModule,\n  HttpTestingController,\n} from '@angular/common/http/testing';\nimport {ChangeDetectorRef, ElementRef, NO_ERRORS_SCHEMA} from '@angular/core';\n\nimport {\n  ComponentFixture,\n  fakeAsync,\n  flushMicrotasks,\n  TestBed,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {NgbModal, NgbActiveModal} from '@ng-bootstrap/ng-bootstrap';\nimport {AppConstants} from 'app.constants';\nimport {CkEditorCopyContentService} from 'components/ck-editor-helpers/ck-editor-copy-content.service';\nimport {OppiaAngularRootComponent} from 'components/oppia-angular-root.component';\nimport {\n  TranslationModalComponent,\n  TranslationOpportunity,\n} from 'pages/contributor-dashboard-page/modal-templates/translation-modal.component';\nimport {TranslationLanguageService} from 'pages/exploration-editor-page/translation-tab/services/translation-language.service';\nimport {ContextService} from 'services/context.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {\n  ImageLocalStorageService,\n  ImagesData,\n} from 'services/image-local-storage.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {UserService} from 'services/user.service';\nimport {TranslateTextService} from '../services/translate-text.service';\nimport {WrapTextWithEllipsisPipe} from 'filters/string-utility-filters/wrap-text-with-ellipsis.pipe';\n// This throws \"TS2307\". We need to\n// suppress this error because rte-text-components are not strictly typed yet.\n// @ts-ignore\nimport {RteOutputDisplayComponent} from 'rich_text_components/rte-output-display.component';\nimport {TranslatedContent} from 'domain/exploration/TranslatedContentObjectFactory';\nimport {ConfirmTranslationExitModalComponent} from 'components/translation-suggestion-page/confirm-translation-exit-modal/confirm-translation-exit-modal.component';\nimport {WindowRef} from 'services/contextual/window-ref.service';\n\nenum ExpansionTabType {\n  CONTENT,\n  TRANSLATION,\n}\n\nclass MockChangeDetectorRef {\n  detectChanges(): void {}\n}\n\nclass MockConfirmTranslationExitModal {\n  componentInstance = {};\n  result = Promise.resolve();\n  close(): void {}\n  dismiss(): void {}\n}\n\nclass MockImageLocalStorageService {\n  private storedImages: Map<string, ImagesData> = new Map();\n\n  getStoredImagesData(): ImagesData[] {\n    return Array.from(this.storedImages.values());\n  }\n\n  flushStoredImagesData(): void {\n    this.storedImages.clear();\n  }\n\n  getFilenameToBase64MappingAsync(): Promise<Record<string, string>> {\n    return Promise.resolve({});\n  }\n}\n\ndescribe('Translation Modal Component', () => {\n  let contextService: ContextService;\n  let translateTextService: TranslateTextService;\n  let translationLanguageService: TranslationLanguageService;\n  let ckEditorCopyContentService: CkEditorCopyContentService;\n  let siteAnalyticsService: SiteAnalyticsService;\n  let imageLocalStorageService: ImageLocalStorageService;\n  let getUserContributionRightsDataAsyncSpy: jasmine.Spy;\n  let userService: UserService;\n  let activeModal: NgbActiveModal;\n  let httpTestingController: HttpTestingController;\n  let fixture: ComponentFixture<TranslationModalComponent>;\n  let component: TranslationModalComponent;\n  let changeDetectorRef: MockChangeDetectorRef = new MockChangeDetectorRef();\n  let wds: WindowDimensionsService;\n  let ngbModal: NgbModal;\n  let mockModalRef: MockConfirmTranslationExitModal;\n  let windowRef: WindowRef;\n  let mockWindow: {\n    addEventListener: jasmine.Spy;\n    removeEventListener: jasmine.Spy;\n    gtag: jasmine.Spy;\n  };\n\n  const opportunity: TranslationOpportunity = {\n    id: '1',\n    heading: 'Heading',\n    subheading: 'subheading',\n    progressPercentage: '20',\n    actionButtonTitle: 'Action Button',\n    inReviewCount: 12,\n    totalCount: 50,\n    translationsCount: 20,\n  };\n  const getContentTranslatableItemWithText = (text: string) => {\n    return {\n      content_format: 'html',\n      content_value: text,\n      content_type: 'content',\n      interaction_id: null,\n      rule_type: null,\n    };\n  };\n\n  beforeEach(waitForAsync(() => {\n    mockModalRef = new MockConfirmTranslationExitModal();\n    mockWindow = {\n      addEventListener: jasmine.createSpy('addEventListener'),\n      removeEventListener: jasmine.createSpy('removeEventListener'),\n      gtag: jasmine.createSpy('gtag'),\n    };\n\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        TranslationModalComponent,\n        WrapTextWithEllipsisPipe,\n        ConfirmTranslationExitModalComponent,\n      ],\n      providers: [\n        NgbActiveModal,\n        {\n          provide: ChangeDetectorRef,\n          useValue: changeDetectorRef,\n        },\n        {\n          provide: NgbModal,\n          useValue: {\n            open: () => mockModalRef,\n          },\n        },\n        {\n          provide: ConfirmTranslationExitModalComponent,\n          useClass: MockConfirmTranslationExitModal,\n        },\n        {\n          provide: WindowRef,\n          useValue: {nativeWindow: mockWindow},\n        },\n        {\n          provide: ImageLocalStorageService,\n          useClass: MockImageLocalStorageService,\n        },\n      ],\n      schemas: [NO_ERRORS_SCHEMA],\n    }).compileComponents();\n    OppiaAngularRootComponent.contextService = TestBed.inject(ContextService);\n    contextService = OppiaAngularRootComponent.contextService;\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(TranslationModalComponent);\n    component = fixture.componentInstance;\n    component.opportunity = opportunity;\n    httpTestingController = TestBed.inject(HttpTestingController);\n    ckEditorCopyContentService = TestBed.inject(CkEditorCopyContentService);\n    activeModal = TestBed.inject(NgbActiveModal);\n    translateTextService = TestBed.inject(TranslateTextService);\n    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);\n    imageLocalStorageService = TestBed.inject(ImageLocalStorageService);\n    translationLanguageService = TestBed.inject(TranslationLanguageService);\n    translationLanguageService.setActiveLanguageCode('es');\n    userService = TestBed.inject(UserService);\n    wds = TestBed.inject(WindowDimensionsService);\n    ngbModal = TestBed.inject(NgbModal);\n    component.contentContainer = new ElementRef({offsetHeight: 150});\n    component.translationContainer = new ElementRef({offsetHeight: 150});\n    component.contentPanel = new RteOutputDisplayComponent(\n      // This throws \"Argument of type 'null' is not assignable to parameter of\n      // type 'ViewContainerRef'.\" We need to suppress this error because of\n      // the need to test validations. This is because the component is not\n      // strictly typed yet.\n      // @ts-ignore\n      null,\n      null,\n      new ElementRef({offsetHeight: 200}),\n      null\n    );\n    getUserContributionRightsDataAsyncSpy = spyOn(\n      userService,\n      'getUserContributionRightsDataAsync'\n    );\n    getUserContributionRightsDataAsyncSpy.and.returnValue(\n      Promise.resolve({\n        can_suggest_questions: false,\n        can_review_translation_for_language_codes: ['ar'],\n        can_review_voiceover_for_language_codes: [],\n        can_review_questions: false,\n      })\n    );\n    windowRef = TestBed.inject(WindowRef);\n    mockWindow = windowRef.nativeWindow;\n  });\n\n  it('should invoke change detection when html is updated', () => {\n    component.activeWrittenTranslation = 'old';\n    spyOn(changeDetectorRef, 'detectChanges').and.callThrough();\n    component.updateHtml('new');\n    expect(component.activeWrittenTranslation).toEqual('new');\n  });\n\n  it('should not invoke change detection when html is not updated', () => {\n    component.activeWrittenTranslation = 'old';\n    spyOn(changeDetectorRef, 'detectChanges').and.callThrough();\n    component.updateHtml('old');\n    expect(component.activeWrittenTranslation).toEqual('old');\n    expect(changeDetectorRef.detectChanges).toHaveBeenCalledTimes(0);\n  });\n\n  it('should return the ExoansionTabType enum', () => {\n    let enumVariable = component.expansionTabType;\n    expect(typeof enumVariable === typeof ExpansionTabType);\n  });\n\n  it('should expand the content area', () => {\n    spyOn(component, 'toggleExpansionState').and.callThrough();\n    // The content area is contracted by default.\n    expect(component.isContentExpanded).toBeFalse();\n\n    // The content area should expand when the users clicks\n    // on the 'View More' button.\n    component.toggleExpansionState(ExpansionTabType.CONTENT);\n\n    expect(component.isContentExpanded).toBeTrue();\n  });\n\n  it('should contract the content area', () => {\n    spyOn(component, 'toggleExpansionState').and.callThrough();\n    component.isContentExpanded = true;\n\n    // The content area should contract when the users clicks\n    // on the 'View Less' button.\n    component.toggleExpansionState(ExpansionTabType.CONTENT);\n\n    expect(component.isContentExpanded).toBeFalse();\n  });\n\n  it('should expand the translation area', () => {\n    spyOn(component, 'toggleExpansionState').and.callThrough();\n    // The translation area is contracted by default.\n    expect(component.isTranslationExpanded).toBeTrue();\n\n    // The translation area should expand when the users clicks\n    // on the 'View More' button.\n    component.toggleExpansionState(ExpansionTabType.TRANSLATION);\n\n    expect(component.isTranslationExpanded).toBeFalse();\n  });\n\n  it('should contract the translation area', () => {\n    spyOn(component, 'toggleExpansionState').and.callThrough();\n    component.isTranslationExpanded = false;\n\n    // The translation area should contract when the users clicks\n    // on the 'View Less' button.\n    component.toggleExpansionState(ExpansionTabType.TRANSLATION);\n\n    expect(component.isTranslationExpanded).toBeTrue();\n  });\n\n  it('should correctly determine whether the content data is overflowing', fakeAsync(() => {\n    // Pre-check.\n    // The default values for the overflow states are false.\n    expect(component.isContentOverflowing).toBeFalse();\n\n    // Setup.\n    component.contentPanel.elementRef.nativeElement.offsetHeight = 100;\n    component.contentContainer.nativeElement.offsetHeight = 150;\n\n    // Action.\n    component.computePanelOverflowState();\n    tick(501);\n\n    // Expectations.\n    expect(component.isContentOverflowing).toBeFalse();\n    // Change panel height to simulate changing of the modal data.\n    component.contentPanel.elementRef.nativeElement.offsetHeight = 300;\n\n    // Action.\n    component.computePanelOverflowState();\n    tick(501);\n\n    // Expectations.\n    expect(component.isContentOverflowing).toBeTrue();\n  }));\n\n  it('should correctly determine whether the editor is overflowing', fakeAsync(() => {\n    // Pre-check.\n    // The default values for the overflow states are false.\n    expect(component.isTranslationOverflowing).toBeFalse();\n\n    // Setup.\n    spyOn(wds, 'getHeight').and.returnValue(100);\n    component.translationContainer.nativeElement.offsetHeight = 25;\n\n    // Action.\n    component.computeTranslationEditorOverflowState();\n    tick(501);\n\n    // Expectations.\n    expect(component.isTranslationOverflowing).toBeFalse();\n    // Change panel height to simulate changing of the modal data.\n    component.translationContainer.nativeElement.offsetHeight = 300;\n\n    // Action.\n    component.computeTranslationEditorOverflowState();\n    tick(501);\n\n    // Expectations.\n    expect(component.isTranslationOverflowing).toBeTrue();\n  }));\n\n  afterEach(() => {\n    httpTestingController.verify();\n  });\n\n  it('should close', () => {\n    spyOn(activeModal, 'close');\n    component.close();\n    expect(activeModal.close).toHaveBeenCalled();\n  });\n\n  describe('when initialized', () => {\n    describe('with an rtl language', () => {\n      beforeEach(fakeAsync(() => {\n        translationLanguageService.setActiveLanguageCode('ar');\n        spyOn(translateTextService, 'init').and.callFake(\n          (expId, languageCode, successCallback) => successCallback()\n        );\n        component.ngOnInit();\n      }));\n\n      it('should set the schema constant correctly', () => {\n        expect(component.getHtmlSchema().ui_config.languageDirection).toBe(\n          'rtl'\n        );\n      });\n    });\n\n    describe('with an ltr language', () => {\n      beforeEach(fakeAsync(() => {\n        translationLanguageService.setActiveLanguageCode('es');\n        spyOn(translateTextService, 'init').and.callFake(\n          (expId, languageCode, successCallback) => successCallback()\n        );\n        component.ngOnInit();\n      }));\n\n      it('should set the schema constant correctly', () => {\n        expect(component.getHtmlSchema().ui_config.languageDirection).toBe(\n          'ltr'\n        );\n      });\n\n      it('should throw error if contribution rights is null', fakeAsync(() => {\n        getUserContributionRightsDataAsyncSpy.and.returnValue(\n          Promise.resolve(null)\n        );\n        expect(() => {\n          component.ngOnInit();\n          tick();\n        }).toThrowError();\n      }));\n    });\n\n    it('should set context correctly', fakeAsync(() => {\n      contextService.removeCustomEntityContext();\n      contextService.resetImageSaveDestination();\n      spyOn(translateTextService, 'init').and.callFake(\n        (expId, languageCode, successCallback) => successCallback()\n      );\n      component.ngOnInit();\n      expect(contextService.getEntityType()).toBe(\n        AppConstants.ENTITY_TYPE.EXPLORATION\n      );\n      expect(contextService.getEntityId()).toBe('1');\n      expect(contextService.getImageSaveDestination()).toBe(\n        AppConstants.IMAGE_SAVE_DESTINATION_LOCAL_STORAGE\n      );\n    }));\n\n    it('should compute panel overflow after the view has initialized', () => {\n      spyOn(component, 'computePanelOverflowState');\n\n      component.ngAfterViewInit();\n\n      expect(component.computePanelOverflowState).toHaveBeenCalled();\n    });\n\n    it('should compute editor overflow after the view has changed', () => {\n      spyOn(component, 'computeTranslationEditorOverflowState');\n\n      component.ngAfterContentChecked();\n\n      expect(\n        component.computeTranslationEditorOverflowState\n      ).toHaveBeenCalled();\n    });\n\n    it('should initialize translateTextService', fakeAsync(() => {\n      spyOn(translateTextService, 'init').and.callThrough();\n      spyOn(translateTextService, 'getTextToTranslate').and.callThrough();\n      spyOn(\n        translateTextService,\n        'getPreviousTextToTranslate'\n      ).and.callThrough();\n      component.ngOnInit();\n      expect(component.loadingData).toBeTrue();\n      expect(translateTextService.init).toHaveBeenCalled();\n\n      const sampleStateWiseContentMapping = {\n        stateName1: {contentId1: getContentTranslatableItemWithText('text1')},\n        stateName2: {contentId2: getContentTranslatableItemWithText('text2')},\n      };\n\n      const req = httpTestingController.expectOne(\n        '/gettranslatabletexthandler?exp_id=1&language_code=es'\n      );\n      expect(req.request.method).toEqual('GET');\n      req.flush({\n        state_names_to_content_id_mapping: sampleStateWiseContentMapping,\n        version: 1,\n      });\n      flushMicrotasks();\n      expect(component.loadingData).toBeFalse();\n      expect(translateTextService.getTextToTranslate).toHaveBeenCalled();\n\n      expect(component.textToTranslate).toBe('text1');\n      expect(component.moreAvailable).toBeTrue();\n      component.skipActiveTranslation();\n      component.returnToPreviousTranslation();\n      expect(\n        translateTextService.getPreviousTextToTranslate\n      ).toHaveBeenCalled();\n      expect(component.textToTranslate).toBe('text1');\n      // The value of moreAvailable will be set to true when the operation\n      // is viewing a previous translation. If the value is false, the\n      // 'save and close' button is shown. This should happen only on the\n      // last translation.\n      expect(component.moreAvailable).toBeTrue();\n    }));\n\n    it('should set the schema constant based on the active language', fakeAsync(() => {\n      translationLanguageService.setActiveLanguageCode('ar');\n      spyOn(translateTextService, 'init').and.callFake(\n        (expId, languageCode, successCallback) => successCallback()\n      );\n      component.ngOnInit();\n      expect(component.getHtmlSchema().ui_config.language).toBe('ar');\n    }));\n\n    it('should get the unicode schema', () => {\n      expect(component.getUnicodeSchema()).toEqual({type: 'unicode'});\n    });\n\n    it('should get the set of strings schema', () => {\n      expect(component.getSetOfStringsSchema()).toEqual({\n        type: 'list',\n        items: {\n          type: 'unicode',\n        },\n      });\n    });\n\n    it('should utilize the modify translations opportunity when available', () => {\n      let translationContent = TranslatedContent.createFromBackendDict({\n        content_value: 'Current translated content.',\n        content_format: 'html',\n        needs_update: false,\n      });\n      component.modifyTranslationOpportunity = {\n        id: 'expId',\n        contentId: 'content_0',\n        heading: 'Update Translation',\n        subheading: 'Introduction',\n        textToTranslate: 'Current content in English.',\n        currentContentTranslation: translationContent,\n      };\n      component.opportunity = null;\n\n      component.ngOnInit();\n\n      expect(component.subheading).toBe('Introduction');\n      expect(component.heading).toBe('Update Translation');\n      expect(component.textToTranslate).toBe('Current content in English.');\n      expect(component.activeContentType).toBe('content');\n      expect(component.activeWrittenTranslation).toBe(\n        'Current translated content.'\n      );\n      expect(component.activeDataFormat).toBe('html');\n    });\n  });\n\n  describe('when clicking on the translatable content', () => {\n    const nonParagraphTarget: HTMLElement = document.createElement('div');\n    const mathTarget: HTMLElement = document.createElement(\n      'oppia-noninteractive-math'\n    );\n    let paragraphTarget: HTMLElement;\n    let broadcastSpy: jasmine.Spy<(target: HTMLElement) => void>;\n    let propagationSpy: jasmine.Spy<() => void>;\n    beforeEach(fakeAsync(() => {\n      paragraphTarget = document.createElement('p');\n      spyOn(translateTextService, 'init').and.callFake(\n        (expId, languageCode, successCallback) => successCallback()\n      );\n      broadcastSpy = spyOn(\n        ckEditorCopyContentService,\n        'broadcastCopy'\n      ).and.stub();\n\n      component.ngOnInit();\n      nonParagraphTarget.onclick = function (this, ev) {\n        propagationSpy = spyOn(ev, 'stopPropagation').and.stub();\n        component.onContentClick(ev);\n      };\n      paragraphTarget.onclick = function (this, ev) {\n        propagationSpy = spyOn(ev, 'stopPropagation').and.stub();\n        component.onContentClick(ev);\n      };\n    }));\n\n    it('should not broadcast the clicked paragraph element', () => {\n      paragraphTarget.click();\n      expect(broadcastSpy).not.toHaveBeenCalledWith(paragraphTarget);\n    });\n\n    it('should broadcast the clicked non paragraph element', () => {\n      nonParagraphTarget.click();\n      expect(broadcastSpy).toHaveBeenCalledWith(nonParagraphTarget);\n    });\n\n    it('should broadcast the clicked math element', () => {\n      paragraphTarget.append(mathTarget);\n      paragraphTarget.click();\n      expect(broadcastSpy).toHaveBeenCalledWith(paragraphTarget);\n    });\n\n    describe('when copy mode is active', () => {\n      beforeEach(() => {\n        ckEditorCopyContentService.toggleCopyMode();\n      });\n\n      it('should prevent default behavior', () => {\n        nonParagraphTarget.click();\n        expect(propagationSpy).toHaveBeenCalled();\n      });\n    });\n\n    describe('when copy mode is inactive', () => {\n      it('should not prevent default behavior', () => {\n        nonParagraphTarget.click();\n        expect(propagationSpy).not.toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('when skipping the active translation', () => {\n    describe('when there is available text', () => {\n      beforeEach(fakeAsync(() => {\n        component.ngOnInit();\n\n        const sampleStateWiseContentMapping = {\n          stateName1: {contentId1: getContentTranslatableItemWithText('text1')},\n          stateName2: {contentId2: getContentTranslatableItemWithText('text2')},\n        };\n\n        const req = httpTestingController.expectOne(\n          '/gettranslatabletexthandler?exp_id=1&language_code=es'\n        );\n        expect(req.request.method).toEqual('GET');\n        req.flush({\n          state_names_to_content_id_mapping: sampleStateWiseContentMapping,\n          version: 1,\n        });\n        flushMicrotasks();\n        component.skipActiveTranslation();\n      }));\n\n      it('should retrieve remaining text and availability', () => {\n        expect(component.textToTranslate).toBe('text2');\n        expect(component.moreAvailable).toBeFalse();\n      });\n    });\n  });\n\n  describe('when suggesting translated text', () => {\n    let expectedPayload: Object;\n    let imagesData: ImagesData[];\n    beforeEach(fakeAsync(() => {\n      expectedPayload = {\n        suggestion_type: 'translate_content',\n        target_type: 'exploration',\n        description: 'Adds translation',\n        target_id: '1',\n        target_version_at_submission: 1,\n        change_cmd: {\n          cmd: 'add_written_translation',\n          content_id: 'contentId1',\n          state_name: 'stateName1',\n          language_code: 'es',\n          content_html: 'text1',\n          translation_html: 'texto1',\n          data_format: 'html',\n        },\n        files: {},\n      };\n      component.ngOnInit();\n      tick();\n\n      const sampleStateWiseContentMapping = {\n        stateName1: {contentId1: getContentTranslatableItemWithText('text1')},\n        stateName2: {\n          contentId2: {\n            content_format: 'unicode',\n            content_value: 'input',\n            content_type: 'interaction',\n            interaction_id: 'TextInput',\n            rule_type: null,\n          },\n          contentId3: {\n            content_format: 'unicode',\n            content_value: 'Continue',\n            content_type: 'ca',\n            interaction_id: 'Continue',\n            rule_type: null,\n          },\n          contentId4: {\n            content_format: 'set_of_normalized_string',\n            content_value: ['answer1', 'answer2', 'answer3'],\n            content_type: 'rule',\n            interaction_id: 'TextInput',\n            rule_type: 'Contains',\n          },\n        },\n      };\n\n      const req = httpTestingController.expectOne(\n        '/gettranslatabletexthandler?exp_id=1&language_code=es'\n      );\n      expect(req.request.method).toEqual('GET');\n      req.flush({\n        state_names_to_content_id_mapping: sampleStateWiseContentMapping,\n        version: 1,\n      });\n      flushMicrotasks();\n      component.activeWrittenTranslation = 'texto1';\n    }));\n\n    it('should remove paragraph error', fakeAsync(() => {\n      component.hadCopyParagraphError = true;\n\n      component.suggestTranslatedText();\n      tick();\n\n      const req = httpTestingController.expectOne('/suggestionhandler/');\n      expect(component.hadCopyParagraphError).toEqual(false);\n      expect(req.request.method).toEqual('POST');\n      expect(req.request.body.getAll('payload')[0]).toEqual(\n        JSON.stringify(expectedPayload)\n      );\n      req.flush({});\n      flushMicrotasks();\n    }));\n\n    it('should correctly submit a translation suggestion', fakeAsync(() => {\n      component.suggestTranslatedText();\n      tick();\n\n      const req = httpTestingController.expectOne('/suggestionhandler/');\n      expect(req.request.method).toEqual('POST');\n      expect(req.request.body.getAll('payload')[0]).toEqual(\n        JSON.stringify(expectedPayload)\n      );\n      req.flush({});\n      flushMicrotasks();\n    }));\n\n    describe('when already uploading a translation', () => {\n      it('should not submit the translation', fakeAsync(() => {\n        spyOn(translateTextService, 'suggestTranslatedText').and.callThrough();\n        spyOn(\n          imageLocalStorageService,\n          'getFilenameToBase64MappingAsync'\n        ).and.returnValue(Promise.resolve({}));\n\n        component.suggestTranslatedText();\n        component.uploadingTranslation = true;\n        component.suggestTranslatedText();\n        tick();\n\n        const req = httpTestingController.expectOne('/suggestionhandler/');\n        expect(req.request.method).toEqual('POST');\n        expect(req.request.body.getAll('payload')[0]).toEqual(\n          JSON.stringify(expectedPayload)\n        );\n        req.flush({});\n        flushMicrotasks();\n        expect(\n          translateTextService.suggestTranslatedText\n        ).toHaveBeenCalledTimes(1);\n      }));\n    });\n\n    describe('when skipping translations', () => {\n      it('should update activeContentType', fakeAsync(() => {\n        component.skipActiveTranslation();\n        tick();\n        expect(component.activeContentType).toBe('TextInput interaction');\n        component.skipActiveTranslation();\n        tick();\n        expect(component.activeContentType).toBe('label');\n        component.skipActiveTranslation();\n        tick();\n        expect(component.activeContentType).toBe('input rule');\n      }));\n    });\n\n    describe('when suggesting the last available text', () => {\n      beforeEach(fakeAsync(() => {\n        expectedPayload = {\n          suggestion_type: 'translate_content',\n          target_type: 'exploration',\n          description: 'Adds translation',\n          target_id: '1',\n          target_version_at_submission: 1,\n          change_cmd: {\n            cmd: 'add_written_translation',\n            content_id: 'contentId4',\n            state_name: 'stateName2',\n            language_code: 'es',\n            content_html: ['answer1', 'answer2', 'answer3'],\n            translation_html: ['answero1', 'answero2', 'answero3'],\n            data_format: 'set_of_normalized_string',\n          },\n          files: {},\n        };\n\n        mockModalRef.result = Promise.resolve();\n\n        component.skipActiveTranslation();\n        tick();\n        component.skipActiveTranslation();\n        tick();\n        component.skipActiveTranslation();\n        tick();\n\n        component.activeWrittenTranslation = [\n          'answero1',\n          'answero2',\n          'answero3',\n        ];\n        component.moreAvailable = false;\n      }));\n\n      it('should close the modal', fakeAsync(() => {\n        spyOn(component.activeModal, 'close');\n        spyOn(\n          imageLocalStorageService,\n          'getFilenameToBase64MappingAsync'\n        ).and.returnValue(Promise.resolve({}));\n\n        mockModalRef.result = Promise.resolve();\n\n        component.suggestTranslatedText();\n        tick();\n\n        const req = httpTestingController.expectOne('/suggestionhandler/');\n        expect(req.request.method).toEqual('POST');\n        expect(req.request.body.getAll('payload')[0]).toEqual(\n          JSON.stringify(expectedPayload)\n        );\n        req.flush({});\n        flushMicrotasks();\n\n        expect(component.activeModal.close).toHaveBeenCalled();\n      }));\n    });\n\n    it('should flush stored image data', fakeAsync(() => {\n      imagesData = [\n        {\n          filename: 'imageFilename1',\n          imageBlob: new Blob(['imageBlob1']),\n        },\n        {\n          filename: 'imageFilename2',\n          imageBlob: new Blob(['imageBlob2']),\n        },\n      ];\n      const imageToBase64Mapping = {\n        imageFilename1: 'img1Base64',\n        imageFilename2: 'img2Base64',\n      };\n      spyOn(imageLocalStorageService, 'getStoredImagesData').and.returnValue(\n        imagesData\n      );\n      spyOn(\n        imageLocalStorageService,\n        'getFilenameToBase64MappingAsync'\n      ).and.returnValue(Promise.resolve(imageToBase64Mapping));\n\n      mockModalRef.result = Promise.resolve();\n\n      component.suggestTranslatedText();\n      tick();\n      flushMicrotasks();\n\n      const req = httpTestingController.expectOne('/suggestionhandler/');\n      const files = JSON.parse(req.request.body.getAll('payload')[0]).files;\n      expect(req.request.method).toEqual('POST');\n      expect(files.imageFilename1).toContain('img1Base64');\n      expect(files.imageFilename2).toContain('img2Base64');\n      req.flush({});\n      flushMicrotasks();\n    }));\n\n    it('should reset the image save destination', fakeAsync(() => {\n      spyOn(\n        imageLocalStorageService,\n        'getFilenameToBase64MappingAsync'\n      ).and.returnValue(Promise.resolve({}));\n      component.suggestTranslatedText();\n      tick();\n      const req = httpTestingController.expectOne('/suggestionhandler/');\n      expect(req.request.method).toEqual('POST');\n      expect(req.request.body.getAll('payload')[0]).toEqual(\n        JSON.stringify(expectedPayload)\n      );\n      req.flush(\n        {\n          error: 'Error',\n        },\n        {\n          status: 500,\n          statusText: 'Internal Server Error',\n        }\n      );\n      flushMicrotasks();\n      component.suggestTranslatedText();\n      expect(contextService.getImageSaveDestination()).toBe(\n        AppConstants.IMAGE_SAVE_DESTINATION_SERVER\n      );\n    }));\n\n    it('should not reset the image save destination', fakeAsync(() => {\n      spyOn(translateTextService, 'suggestTranslatedText').and.stub();\n      spyOn(\n        imageLocalStorageService,\n        'getFilenameToBase64MappingAsync'\n      ).and.returnValue(Promise.resolve({}));\n      expect(contextService.getImageSaveDestination()).toBe(\n        AppConstants.IMAGE_SAVE_DESTINATION_LOCAL_STORAGE\n      );\n\n      mockModalRef.result = Promise.resolve();\n\n      component.suggestTranslatedText();\n      tick();\n      expect(contextService.getImageSaveDestination()).toBe(\n        AppConstants.IMAGE_SAVE_DESTINATION_LOCAL_STORAGE\n      );\n    }));\n\n    it('should register a contributor dashboard submit suggestion event', fakeAsync(() => {\n      spyOn(\n        siteAnalyticsService,\n        'registerContributorDashboardSubmitSuggestionEvent'\n      );\n      spyOn(translateTextService, 'suggestTranslatedText').and.stub();\n\n      mockModalRef.result = Promise.resolve();\n\n      component.suggestTranslatedText();\n      tick();\n\n      expect(\n        siteAnalyticsService.registerContributorDashboardSubmitSuggestionEvent\n      ).toHaveBeenCalledWith('Translation');\n    }));\n\n    describe('when currently loading data', () => {\n      it('should not submit the translation', () => {\n        component.loadingData = true;\n        spyOn(translateTextService, 'suggestTranslatedText').and.callThrough();\n\n        component.suggestTranslatedText();\n\n        expect(\n          translateTextService.suggestTranslatedText\n        ).toHaveBeenCalledTimes(0);\n      });\n    });\n\n    describe('when alt text is not changed in copied images', () => {\n      it('should not submit the translation', () => {\n        component.textToTranslate =\n          '<oppia-noninteractive-image alt-with-' +\n          'value=\"&amp;quot;Image description&amp;quot;\" caption-with-value=' +\n          '\"&amp;quot;Image caption&amp;quot;\" filepath-with-value=\"&amp;quot' +\n          ';img_20210129_210552_zbv0mdty94_height_54_width_490.png&amp;quot;\"' +\n          '></oppia-noninteractive-image>';\n        component.activeWrittenTranslation =\n          '<oppia-noninteractive-' +\n          'image alt-with-value=\"&amp;quot;Image description&amp;quot;' +\n          '\" caption-with-value=\"&amp;quot;New caption&amp;quot;\"' +\n          ' filepath-with-value=\"&amp;quot;img_20210129_210552_zbv0mdty9' +\n          '4_height_54_width_490.png&amp;quot;\"></oppia-noninteractive-image>';\n        spyOn(translateTextService, 'suggestTranslatedText').and.callThrough();\n\n        component.suggestTranslatedText();\n\n        expect(\n          translateTextService.suggestTranslatedText\n        ).toHaveBeenCalledTimes(0);\n      });\n    });\n\n    describe('when caption is not changed in copied images', () => {\n      it('should not submit the translation', () => {\n        component.textToTranslate =\n          '<oppia-noninteractive-image alt-with-' +\n          'value=\"&amp;quot;Image description&amp;quot;\" caption-with-value=' +\n          '\"&amp;quot;Image caption&amp;quot;\" filepath-with-value=\"&amp;quot' +\n          ';img_20210129_210552_zbv0mdty94_height_54_width_490.png&amp;quot;\"' +\n          '></oppia-noninteractive-image>';\n        component.activeWrittenTranslation =\n          '<oppia-noninteractive' +\n          '-image alt-with-value=\"&amp;quot;New description&amp;quot;\"' +\n          ' caption-with-value=\"&amp;quot;Image caption&amp;quot;\"' +\n          ' filepath-with-value=\"&amp;quot:img_20210129_210552_zbv0mdty9' +\n          '4_height_54_width_490.png&amp;quot;\"></oppia-noninteractive-image>';\n        spyOn(translateTextService, 'suggestTranslatedText').and.callThrough();\n\n        component.suggestTranslatedText();\n\n        expect(\n          translateTextService.suggestTranslatedText\n        ).toHaveBeenCalledTimes(0);\n      });\n    });\n\n    describe(\n      'when translation elements are not matching with the elements ' +\n        'of the text to translate',\n      () => {\n        it('should not submit the translation', () => {\n          component.textToTranslate =\n            '<p>First para</p><p>Second para</p><oppia-noninteractive-math>' +\n            '</oppia-noninteractive-math><oppia-noninteractive-skillreview>' +\n            '</oppia-noninteractive-skillreview>';\n          component.activeWrittenTranslation =\n            '<p>First para</p>' +\n            '<p><oppia-noninteractive-math></oppia-noninteractive-math></p>';\n          spyOn(\n            translateTextService,\n            'suggestTranslatedText'\n          ).and.callThrough();\n\n          component.suggestTranslatedText();\n\n          expect(\n            translateTextService.suggestTranslatedText\n          ).toHaveBeenCalledTimes(0);\n        });\n      }\n    );\n  });\n\n  it('should close modal and return the new translation when updating translated text', () => {\n    spyOn(activeModal, 'close');\n    spyOn(component, 'canTranslatedTextBeSubmitted').and.returnValue(true);\n    component.activeWrittenTranslation = 'Test translation';\n    component.updateTranslatedText();\n\n    expect(activeModal.close).toHaveBeenCalledWith('Test translation');\n  });\n\n  it('should not close modal if new translated text cannot be submitted', () => {\n    spyOn(activeModal, 'close');\n    component.activeWrittenTranslation = 'Test translation';\n    component.updateTranslatedText();\n\n    expect(activeModal.close).not.toHaveBeenCalled();\n  });\n\n  describe('when handling unsaved changes', () => {\n    beforeEach(() => {\n      component.activeWrittenTranslation = 'Some unsaved text';\n    });\n\n    describe('when skipping translation', () => {\n      it('should open confirmation modal and skip on confirm', fakeAsync(() => {\n        spyOn(ngbModal, 'open').and.callThrough();\n        spyOn(translateTextService, 'getTextToTranslate').and.returnValue({\n          text: 'next text',\n          more: true,\n          status: 'active',\n          translation: '',\n          dataFormat: 'html',\n          contentType: 'content',\n        });\n\n        component.skipActiveTranslation();\n        tick();\n\n        expect(ngbModal.open).toHaveBeenCalledWith(\n          ConfirmTranslationExitModalComponent,\n          {backdrop: 'static'}\n        );\n\n        mockModalRef.result = Promise.resolve();\n        tick();\n        flushMicrotasks();\n\n        expect(component.activeWrittenTranslation).toBe('');\n        expect(translateTextService.getTextToTranslate).toHaveBeenCalled();\n      }));\n\n      it('should open confirmation modal and not skip on cancel', fakeAsync(() => {\n        const originalText = 'Some unsaved text';\n        component.activeWrittenTranslation = originalText;\n\n        spyOn(ngbModal, 'open').and.returnValue(mockModalRef);\n        const getTextSpy = spyOn(translateTextService, 'getTextToTranslate');\n\n        mockModalRef.result = Promise.reject();\n\n        component.skipActiveTranslation();\n        tick();\n\n        expect(ngbModal.open).toHaveBeenCalledWith(\n          ConfirmTranslationExitModalComponent,\n          {backdrop: 'static'}\n        );\n\n        tick();\n        flushMicrotasks();\n\n        expect(component.activeWrittenTranslation).toBe(originalText);\n        expect(getTextSpy).not.toHaveBeenCalled();\n      }));\n    });\n\n    describe('when closing modal', () => {\n      it('should open confirmation modal and close on confirm', fakeAsync(() => {\n        spyOn(ngbModal, 'open').and.callThrough();\n        spyOn(component.activeModal, 'close');\n\n        component.close();\n        tick();\n\n        expect(ngbModal.open).toHaveBeenCalledWith(\n          ConfirmTranslationExitModalComponent,\n          {backdrop: 'static'}\n        );\n\n        mockModalRef.result = Promise.resolve();\n        tick();\n        flushMicrotasks();\n\n        expect(component.activeModal.close).toHaveBeenCalled();\n      }));\n\n      it('should open confirmation modal and not close on cancel', fakeAsync(() => {\n        component.activeWrittenTranslation = 'Unsaved text';\n\n        spyOn(ngbModal, 'open').and.returnValue(mockModalRef);\n        const closeSpy = spyOn(component.activeModal, 'close');\n\n        mockModalRef.result = Promise.reject();\n\n        component.close();\n        tick();\n\n        expect(ngbModal.open).toHaveBeenCalledWith(\n          ConfirmTranslationExitModalComponent,\n          {backdrop: 'static'}\n        );\n\n        tick();\n        flushMicrotasks();\n\n        expect(closeSpy).not.toHaveBeenCalled();\n      }));\n    });\n\n    describe('when handling unsaved changes when browser tab/window is closed', () => {\n      interface MockWindow {\n        addEventListener: jasmine.Spy;\n        removeEventListener: jasmine.Spy;\n      }\n\n      let mockWindow: MockWindow;\n      let mockEvent: BeforeUnloadEvent;\n      let preventDefaultSpy: jasmine.Spy;\n      let translationLanguageService: TranslationLanguageService;\n\n      beforeEach(() => {\n        TestBed.resetTestingModule();\n        mockWindow = {\n          addEventListener: jasmine.createSpy('addEventListener'),\n          removeEventListener: jasmine.createSpy('removeEventListener'),\n        };\n\n        preventDefaultSpy = jasmine.createSpy('preventDefault');\n        mockEvent = {\n          preventDefault: preventDefaultSpy,\n          returnValue: '',\n        } as unknown as BeforeUnloadEvent;\n\n        TestBed.configureTestingModule({\n          imports: [HttpClientTestingModule],\n          declarations: [\n            TranslationModalComponent,\n            WrapTextWithEllipsisPipe,\n            ConfirmTranslationExitModalComponent,\n          ],\n          providers: [\n            NgbActiveModal,\n            TranslationLanguageService,\n            {\n              provide: ChangeDetectorRef,\n              useValue: changeDetectorRef,\n            },\n            {\n              provide: NgbModal,\n              useValue: {\n                open: () => mockModalRef,\n              },\n            },\n            {\n              provide: ConfirmTranslationExitModalComponent,\n              useClass: MockConfirmTranslationExitModal,\n            },\n            {\n              provide: WindowRef,\n              useValue: {nativeWindow: mockWindow},\n            },\n            {\n              provide: TranslateTextService,\n              useValue: {\n                init: (\n                  expId: string,\n                  languageCode: string,\n                  successCallback: () => void\n                ) => {\n                  successCallback();\n                },\n                getTextToTranslate: () => ({\n                  text: 'Sample text',\n                  more: true,\n                  status: 'active',\n                  translation: '',\n                  dataFormat: 'html',\n                  contentType: 'content',\n                }),\n                getPreviousTextToTranslate: () => ({\n                  text: 'Previous text',\n                  more: true,\n                  status: 'active',\n                  translation: '',\n                  dataFormat: 'html',\n                  contentType: 'content',\n                }),\n              },\n            },\n            {\n              provide: UserService,\n              useValue: {\n                getUserContributionRightsDataAsync: () =>\n                  Promise.resolve({\n                    can_review_translation_for_language_codes: ['ar'],\n                  }),\n              },\n            },\n            {\n              provide: ContextService,\n              useValue: {\n                setImageSaveDestinationToLocalStorage: () => {},\n                setCustomEntityContext: () => {},\n                getEntityType: () => 'exploration',\n                getEntityId: () => '1',\n                getImageSaveDestination: () => 'localStorage',\n              },\n            },\n          ],\n          schemas: [NO_ERRORS_SCHEMA],\n        });\n\n        fixture = TestBed.createComponent(TranslationModalComponent);\n        component = fixture.componentInstance;\n        component.opportunity = opportunity;\n        translationLanguageService = TestBed.inject(TranslationLanguageService);\n        translationLanguageService.setActiveLanguageCode('es');\n      });\n\n      it('should have beforeUnloadHandler initialized as a function returning undefined', () => {\n        const mockEvent = {\n          preventDefault: () => {},\n          returnValue: '',\n        } as BeforeUnloadEvent;\n\n        interface ComponentWithPrivateMembers\n          extends TranslationModalComponent {\n          beforeUnloadHandler: (e: BeforeUnloadEvent) => string | undefined;\n        }\n\n        const componentWithPrivateAccess =\n          component as ComponentWithPrivateMembers;\n        expect(\n          componentWithPrivateAccess.beforeUnloadHandler(mockEvent)\n        ).toBeUndefined();\n      });\n\n      it('should initialize beforeUnloadHandler to return undefined by default', fakeAsync(() => {\n        component.ngOnInit();\n        tick();\n\n        const handler = mockWindow.addEventListener.calls.argsFor(0)[1];\n        const mockEvent = {\n          preventDefault: () => {},\n          returnValue: '',\n        } as BeforeUnloadEvent;\n\n        component.activeWrittenTranslation = '';\n        expect(handler(mockEvent)).toBeUndefined();\n      }));\n\n      it('should add beforeunload event listener on init', fakeAsync(() => {\n        component.ngOnInit();\n        tick();\n        expect(mockWindow.addEventListener).toHaveBeenCalledWith(\n          'beforeunload',\n          jasmine.any(Function)\n        );\n      }));\n\n      it('should remove beforeunload event listener on destroy', fakeAsync(() => {\n        component.ngOnInit();\n        tick();\n        const handler = mockWindow.addEventListener.calls.argsFor(0)[1];\n        component.ngOnDestroy();\n        expect(mockWindow.removeEventListener).toHaveBeenCalledWith(\n          'beforeunload',\n          handler\n        );\n      }));\n\n      it('should not show confirmation dialog when there are no unsaved changes', fakeAsync(() => {\n        component.ngOnInit();\n        tick();\n        const handler = mockWindow.addEventListener.calls.argsFor(0)[1];\n        component.activeWrittenTranslation = '';\n        handler(mockEvent);\n        expect(preventDefaultSpy).not.toHaveBeenCalled();\n        expect(mockEvent.returnValue).toBe('');\n      }));\n\n      it('should show confirmation dialog when there are unsaved changes', fakeAsync(() => {\n        component.ngOnInit();\n        tick();\n        const handler = mockWindow.addEventListener.calls.argsFor(0)[1];\n        component.activeWrittenTranslation = 'Some unsaved text';\n        handler(mockEvent);\n        expect(preventDefaultSpy).toHaveBeenCalled();\n        expect(mockEvent.returnValue).toBe('');\n      }));\n    });\n\n    describe('when no unsaved changes', () => {\n      beforeEach(() => {\n        component.activeWrittenTranslation = '';\n      });\n\n      it('should skip without showing confirmation modal', fakeAsync(() => {\n        spyOn(ngbModal, 'open');\n        spyOn(translateTextService, 'getTextToTranslate').and.returnValue({\n          text: 'next text',\n          more: true,\n          status: 'active',\n          translation: '',\n          dataFormat: 'html',\n          contentType: 'content',\n        });\n\n        component.skipActiveTranslation();\n        tick();\n\n        expect(ngbModal.open).not.toHaveBeenCalled();\n        expect(translateTextService.getTextToTranslate).toHaveBeenCalled();\n      }));\n\n      it('should close without showing confirmation modal', fakeAsync(() => {\n        spyOn(ngbModal, 'open');\n        spyOn(component.activeModal, 'close');\n\n        component.close();\n        tick();\n\n        expect(ngbModal.open).not.toHaveBeenCalled();\n        expect(component.activeModal.close).toHaveBeenCalled();\n      }));\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/translation-modal.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the translation modal.\n */\n\nimport {\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  Input,\n  ViewChild,\n} from '@angular/core';\nimport {NgbActiveModal, NgbModal} from '@ng-bootstrap/ng-bootstrap';\n\nimport {AlertsService} from 'services/alerts.service';\nimport {CkEditorCopyContentService} from 'components/ck-editor-helpers/ck-editor-copy-content.service';\nimport {ContextService} from 'services/context.service';\nimport {ImageLocalStorageService} from 'services/image-local-storage.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {\n  Status,\n  TranslatableItem,\n  TranslateTextService,\n} from 'pages/contributor-dashboard-page/services/translate-text.service';\nimport {TranslationLanguageService} from 'pages/exploration-editor-page/translation-tab/services/translation-language.service';\nimport {UserService} from 'services/user.service';\nimport {TranslationValidationService} from 'services/translation-validation.service';\nimport {AppConstants} from 'app.constants';\nimport {ListSchema, UnicodeSchema} from 'services/schema-default-value.service';\nimport {\n  TRANSLATION_DATA_FORMAT_SET_OF_NORMALIZED_STRING,\n  TRANSLATION_DATA_FORMAT_SET_OF_UNICODE_STRING,\n} from 'domain/exploration/WrittenTranslationObjectFactory';\n// This throws \"TS2307\". We need to\n// suppress this error because rte-output-display is not strictly typed yet.\n// @ts-ignore\nimport {RteOutputDisplayComponent} from 'rich_text_components/rte-output-display.component';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {TranslatedContent} from 'domain/exploration/TranslatedContentObjectFactory';\nimport {ConfirmTranslationExitModalComponent} from 'components/translation-suggestion-page/confirm-translation-exit-modal/confirm-translation-exit-modal.component';\nimport {WindowRef} from 'services/contextual/window-ref.service';\n\nconst INTERACTION_SPECS = require('interactions/interaction_specs.json');\n\nclass UiConfig {\n  'hide_complex_extensions': boolean;\n  'startupFocusEnabled'?: boolean;\n  'language'?: string;\n  'languageDirection'?: string;\n}\n\nenum ExpansionTabType {\n  CONTENT,\n  TRANSLATION,\n}\n\nexport interface TranslationOpportunity {\n  id: string;\n  heading: string;\n  subheading: string;\n  progressPercentage: string;\n  actionButtonTitle: string;\n  inReviewCount: number;\n  totalCount: number;\n  translationsCount: number;\n}\nexport interface ModifyTranslationOpportunity {\n  id: string;\n  contentId: string;\n  heading: string;\n  subheading: string;\n  textToTranslate: string;\n  currentContentTranslation: TranslatedContent;\n  interactionId?: string;\n}\nexport interface HTMLSchema {\n  type: string;\n  ui_config: UiConfig;\n}\nexport interface ImageDetails {\n  filePaths: string[];\n  alts: string[];\n  descriptions: string[];\n}\n\n@Component({\n  selector: 'oppia-translation-modal',\n  templateUrl: './translation-modal.component.html',\n})\nexport class TranslationModalComponent {\n  // These properties below are initialized using Angular lifecycle hooks\n  // where we need to do non-null assertion. For more information see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  @Input() opportunity!: TranslationOpportunity;\n  @Input() modifyTranslationOpportunity!: ModifyTranslationOpportunity;\n  activeDataFormat!: string;\n  activeWrittenTranslation: string | string[] = '';\n  activeContentType!: string;\n  activeRuleDescription!: string;\n  uploadingTranslation: boolean = false;\n  subheading!: string;\n  heading!: string;\n  loadingData: boolean = true;\n  moreAvailable: boolean = false;\n  textToTranslate: string | string[] = '';\n  activeStatus!: Status;\n  activeLanguageCode!: string;\n  HTML_SCHEMA!: {\n    type: string;\n    ui_config: UiConfig;\n  };\n\n  // Language description is null when active language code is invalid.\n  languageDescription: string | null = null;\n  UNICODE_SCHEMA: UnicodeSchema = {type: 'unicode'};\n  SET_OF_STRINGS_SCHEMA: ListSchema = {\n    type: 'list',\n    items: {\n      type: 'unicode',\n    },\n  };\n\n  TRANSLATION_TIPS = AppConstants.TRANSLATION_TIPS;\n  isActiveLanguageReviewer: boolean = false;\n  hadCopyParagraphError: boolean = false;\n  hasImgTextError: boolean = false;\n  hasIncompleteTranslationError: boolean = false;\n  editorIsShown: boolean = true;\n  isContentExpanded: boolean = false;\n  isTranslationExpanded: boolean = true;\n  isContentOverflowing: boolean = false;\n  isTranslationOverflowing: boolean = false;\n  textWhenExpanded: string = 'View Less';\n  textWhenContracted: string = 'View More';\n  // The value of cutoff must be equal to 'max-height' - 1 set in the\n  // class '.oppia-container-contracted' in 'translation-modal.component.html'.\n  cutoff_height: number = 29;\n  ALLOWED_CUSTOM_TAGS_IN_TRANSLATION_SUGGESTION = [\n    'oppia-noninteractive-image',\n    'oppia-noninteractive-link',\n    'oppia-noninteractive-math',\n    'oppia-noninteractive-skillreview',\n  ];\n\n  @ViewChild('contentPanel')\n  contentPanel!: RteOutputDisplayComponent;\n\n  @ViewChild('contentContainer')\n  contentContainer!: ElementRef;\n\n  @ViewChild('translationContainer')\n  translationContainer!: ElementRef;\n\n  private beforeUnloadHandler: (e: BeforeUnloadEvent) => string | undefined =\n    () => undefined;\n\n  constructor(\n    public readonly activeModal: NgbActiveModal,\n    private readonly alertsService: AlertsService,\n    private readonly ckEditorCopyContentService: CkEditorCopyContentService,\n    private readonly contextService: ContextService,\n    private readonly imageLocalStorageService: ImageLocalStorageService,\n    private readonly ngbModal: NgbModal,\n    private readonly siteAnalyticsService: SiteAnalyticsService,\n    private readonly translateTextService: TranslateTextService,\n    private readonly translationLanguageService: TranslationLanguageService,\n    private readonly userService: UserService,\n    private readonly changeDetectorRef: ChangeDetectorRef,\n    private readonly wds: WindowDimensionsService,\n    private readonly translationValidationService: TranslationValidationService,\n    private readonly windowRef: WindowRef\n  ) {}\n\n  public get expansionTabType(): typeof ExpansionTabType {\n    return ExpansionTabType;\n  }\n\n  ngOnInit(): void {\n    this.activeLanguageCode =\n      this.translationLanguageService.getActiveLanguageCode();\n    this.subheading = this.opportunity\n      ? this.opportunity.subheading\n      : this.modifyTranslationOpportunity.subheading;\n    this.heading = this.opportunity\n      ? this.opportunity.heading\n      : this.modifyTranslationOpportunity.heading;\n    this.contextService.setImageSaveDestinationToLocalStorage();\n    this.languageDescription =\n      this.translationLanguageService.getActiveLanguageDescription();\n\n    if (!this.modifyTranslationOpportunity) {\n      // We need to set the context here so that the rte fetches\n      // images for the given ENTITY_TYPE and targetId.\n      this.contextService.setCustomEntityContext(\n        AppConstants.ENTITY_TYPE.EXPLORATION,\n        this.opportunity.id\n      );\n\n      this.translateTextService.init(\n        this.opportunity.id,\n        this.translationLanguageService.getActiveLanguageCode(),\n        () => {\n          const translatableItem =\n            this.translateTextService.getTextToTranslate();\n          this.updateActiveState(translatableItem);\n          ({more: this.moreAvailable} = translatableItem);\n          this.loadingData = false;\n        }\n      );\n    } else {\n      // Initialize the translation modal with the \"modify translation\" opportunity\n      // in case it was called from the exploration editor page for modifying\n      // a particular translation.\n      this.textToTranslate = this.modifyTranslationOpportunity.textToTranslate;\n      const contentType =\n        this.modifyTranslationOpportunity.contentId.split('_')[0];\n      this.activeContentType = this.getFormattedContentType(\n        contentType,\n        this.modifyTranslationOpportunity.interactionId\n      );\n      this.activeWrittenTranslation =\n        this.modifyTranslationOpportunity.currentContentTranslation.translation;\n      this.activeDataFormat =\n        this.modifyTranslationOpportunity.currentContentTranslation.dataFormat;\n      this.loadingData = false;\n    }\n\n    this.userService\n      .getUserContributionRightsDataAsync()\n      .then(userContributionRights => {\n        if (!userContributionRights) {\n          throw new Error('User contribution rights not found.');\n        }\n        const reviewableLanguageCodes =\n          userContributionRights.can_review_translation_for_language_codes;\n        if (reviewableLanguageCodes.includes(this.activeLanguageCode)) {\n          this.isActiveLanguageReviewer = true;\n        }\n      });\n    this.HTML_SCHEMA = {\n      type: 'html',\n      ui_config: {\n        // If this is made true, then the translation cannot be validated\n        // properly since contributors will not be able to view and translate\n        // complex extensions.\n        hide_complex_extensions: false,\n        language: this.translationLanguageService.getActiveLanguageCode(),\n        languageDirection:\n          this.translationLanguageService.getActiveLanguageDirection(),\n      },\n    };\n\n    this.beforeUnloadHandler = (e: BeforeUnloadEvent) => {\n      if (\n        this.activeWrittenTranslation &&\n        this.activeWrittenTranslation.length > 0\n      ) {\n        e.preventDefault();\n        e.returnValue = '';\n        return '';\n      }\n    };\n    this.windowRef.nativeWindow.addEventListener(\n      'beforeunload',\n      this.beforeUnloadHandler\n    );\n  }\n\n  ngAfterViewInit(): void {\n    this.computePanelOverflowState();\n  }\n\n  ngAfterContentChecked(): void {\n    this.computeTranslationEditorOverflowState();\n  }\n\n  computeTranslationEditorOverflowState(): void {\n    const windowHeight = this.wds.getHeight();\n    const heightLimit = (windowHeight * this.cutoff_height) / 100;\n\n    this.isTranslationOverflowing =\n      this.translationContainer?.nativeElement.offsetHeight >= heightLimit;\n  }\n\n  computePanelOverflowState(): void {\n    // The delay of 500ms is required to allow the content to load\n    // before the overflow status is calculated. Values less than\n    // 500ms also work but they sometimes lead to unexpected results.\n    setTimeout(() => {\n      this.isContentOverflowing =\n        this.contentPanel?.elementRef.nativeElement.offsetHeight >\n        this.contentContainer?.nativeElement.offsetHeight;\n    }, 500);\n  }\n\n  // TODO(#13221): Remove this method completely after the change detection\n  // issues in schema-based-editor have been resolved. The current workaround\n  // used is to destroy and re-render the component in the view.\n  resetEditor(): void {\n    this.editorIsShown = false;\n    this.changeDetectorRef.detectChanges();\n    this.editorIsShown = true;\n  }\n\n  private checkForUnsavedChanges(action: () => void): void {\n    if (\n      this.activeWrittenTranslation &&\n      this.activeWrittenTranslation.length > 0\n    ) {\n      const modalRef = this.ngbModal.open(\n        ConfirmTranslationExitModalComponent,\n        {\n          backdrop: 'static',\n        }\n      );\n\n      modalRef.result.then(\n        () => {\n          // If user confirms, execute the passed action.\n          action();\n        },\n        () => {\n          // If user cancels or closes, no action is needed.\n        }\n      );\n    } else {\n      // No unsaved changes, directly execute the action.\n      action();\n    }\n  }\n\n  close(): void {\n    this.checkForUnsavedChanges(() => {\n      this.activeModal.close();\n      // Reset copyMode to the default value and avoid console errors.\n      this.ckEditorCopyContentService.copyModeActive = false;\n    });\n  }\n\n  getHtmlSchema(): HTMLSchema {\n    return this.HTML_SCHEMA;\n  }\n\n  getUnicodeSchema(): UnicodeSchema {\n    return this.UNICODE_SCHEMA;\n  }\n\n  getSetOfStringsSchema(): ListSchema {\n    return this.SET_OF_STRINGS_SCHEMA;\n  }\n\n  updateActiveState(translatableItem: TranslatableItem): void {\n    ({\n      text: this.textToTranslate,\n      more: this.moreAvailable,\n      status: this.activeStatus,\n      translation: this.activeWrittenTranslation,\n      dataFormat: this.activeDataFormat,\n    } = translatableItem);\n    const {contentType, ruleType, interactionId} = translatableItem;\n    this.activeContentType = this.getFormattedContentType(\n      contentType,\n      interactionId\n    );\n    this.activeRuleDescription = this.getRuleDescription(\n      ruleType,\n      interactionId\n    );\n  }\n\n  toggleExpansionState(tab: ExpansionTabType): void {\n    if (tab === ExpansionTabType.CONTENT) {\n      this.isContentExpanded = !this.isContentExpanded;\n    } else if (tab === ExpansionTabType.TRANSLATION) {\n      this.isTranslationExpanded = !this.isTranslationExpanded;\n    }\n  }\n\n  onContentClick(event: MouseEvent): boolean | void {\n    if (this.triedToCopyParagraph(event)) {\n      return (this.hadCopyParagraphError = true);\n    }\n    this.hadCopyParagraphError = false;\n    if (this.isCopyModeActive()) {\n      event.stopPropagation();\n    }\n    this.ckEditorCopyContentService.broadcastCopy(event.target as HTMLElement);\n  }\n\n  triedToCopyParagraph($event: MouseEvent): boolean {\n    // Mathematical equations are also wrapped by <p> elements.\n    // Hence, math elements should be allowed to be copied.\n    // See issue #11683.\n    const target = $event.target as HTMLElement;\n    const paragraphChildrenElements: Element[] =\n      target.localName === 'p' ? Array.from(target.children) : [];\n    const mathElementsIncluded = paragraphChildrenElements.some(\n      child => child.localName === 'oppia-noninteractive-math'\n    );\n    return target.localName === 'p' && !mathElementsIncluded;\n  }\n\n  isCopyModeActive(): boolean {\n    return this.ckEditorCopyContentService.copyModeActive;\n  }\n\n  updateHtml($event: string): void {\n    if ($event !== this.activeWrittenTranslation) {\n      this.activeWrittenTranslation = $event;\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  hasPreviousTranslations(): boolean {\n    return this.translateTextService.getActiveIndex() > 0;\n  }\n\n  skipActiveTranslation(): void {\n    this.checkForUnsavedChanges(() => {\n      const translatableItem = this.translateTextService.getTextToTranslate();\n      this.updateActiveState(translatableItem);\n      ({more: this.moreAvailable} = translatableItem);\n      this.resetEditor();\n    });\n  }\n\n  isSubmitted(): boolean {\n    return this.activeStatus === 'submitted';\n  }\n\n  returnToPreviousTranslation(): void {\n    this.checkForUnsavedChanges(() => {\n      const translatableItem =\n        this.translateTextService.getPreviousTextToTranslate();\n      this.updateActiveState(translatableItem);\n      this.moreAvailable = true;\n      this.resetEditor();\n    });\n  }\n\n  isSetOfStringDataFormat(): boolean {\n    return (\n      this.activeDataFormat ===\n        TRANSLATION_DATA_FORMAT_SET_OF_NORMALIZED_STRING ||\n      this.activeDataFormat === TRANSLATION_DATA_FORMAT_SET_OF_UNICODE_STRING\n    );\n  }\n\n  getFormattedContentType(\n    contentType: string,\n    interactionId: string | undefined\n  ): string {\n    switch (contentType) {\n      case 'interaction':\n        return interactionId + ' interaction';\n      case 'ca':\n        // Customization_arg. This is typically a button label, input\n        // placeholder text, or a multiple choice option.\n        return 'label';\n      case 'rule':\n        return 'input rule';\n    }\n    return contentType;\n  }\n\n  getRuleDescription(ruleType?: string, interactionId?: string): string {\n    if (!ruleType || !interactionId) {\n      return '';\n    }\n    // To match, e.g. \"{{x|TranslatableSetOfNormalizedString}},\".\n    const descriptionPattern = /\\{\\{\\s*(\\w+)\\s*(\\|\\s*\\w+\\s*)?\\}\\}/;\n    const ruleDescription =\n      INTERACTION_SPECS[interactionId].rule_descriptions[ruleType];\n    return (\n      'Answer ' +\n      ruleDescription.replace(descriptionPattern, 'the following choices:')\n    );\n  }\n\n  canTranslatedTextBeSubmitted(): boolean {\n    if (!this.isSetOfStringDataFormat()) {\n      const translationError =\n        this.translationValidationService.validateTranslationFromHtmlStrings(\n          this.textToTranslate as string,\n          this.activeWrittenTranslation as string\n        );\n\n      this.hasImgTextError =\n        translationError.hasDuplicateAltTexts ||\n        translationError.hasDuplicateDescriptions;\n      this.hasIncompleteTranslationError =\n        translationError.hasUntranslatedElements;\n\n      if (\n        this.hasImgTextError ||\n        this.hasIncompleteTranslationError ||\n        this.uploadingTranslation ||\n        this.loadingData\n      ) {\n        return false;\n      }\n\n      if (this.hadCopyParagraphError) {\n        this.hadCopyParagraphError = false;\n      }\n    }\n    return true;\n  }\n\n  suggestTranslatedText(): void {\n    if (!this.canTranslatedTextBeSubmitted()) {\n      return;\n    }\n\n    if (!this.uploadingTranslation && !this.loadingData) {\n      this.siteAnalyticsService.registerContributorDashboardSubmitSuggestionEvent(\n        'Translation'\n      );\n      this.uploadingTranslation = true;\n      const imagesData = this.imageLocalStorageService.getStoredImagesData();\n      this.imageLocalStorageService.flushStoredImagesData();\n      this.translateTextService.suggestTranslatedText(\n        this.activeWrittenTranslation,\n        this.translationLanguageService.getActiveLanguageCode(),\n        imagesData,\n        this.activeDataFormat,\n        () => {\n          this.alertsService.addSuccessMessage(\n            'Submitted translation for review.'\n          );\n          this.uploadingTranslation = false;\n          if (this.moreAvailable) {\n            this.skipActiveTranslation();\n            this.resetEditor();\n          } else {\n            this.activeWrittenTranslation = '';\n          }\n        },\n        (errorReason: string) => {\n          this.contextService.resetImageSaveDestination();\n          this.alertsService.clearWarnings();\n          this.alertsService.addWarning(errorReason);\n          this.close();\n        }\n      );\n    }\n    if (!this.moreAvailable) {\n      this.contextService.resetImageSaveDestination();\n      this.close();\n    }\n  }\n  updateTranslatedText(): void {\n    if (!this.canTranslatedTextBeSubmitted()) {\n      return;\n    }\n    this.activeModal.close(this.activeWrittenTranslation);\n  }\n\n  ngOnDestroy(): void {\n    this.windowRef.nativeWindow.removeEventListener(\n      'beforeunload',\n      this.beforeUnloadHandler\n    );\n  }\n}\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/translation-suggestion-review-modal.component.html",
      "content": "<div class=\"modal-header\">\n  <div class=\"oppia-modal-info\" tabindex=\"0\">\n    <h1 title=\"{{ heading }}\"\n        class=\"oppia-modal-info-header\">\n      {{ heading }}\n    </h1>\n    <span title=\"{{ subheading }}\"\n          class=\"oppia-translation-modal-subheading e2e-translation-suggestion-review-subheading\"\n          aria-hidden=\"false\">\n      {{ subheading }}\n    </span>\n    <span title=\"{{ activeContribution.details.chapter_title }}\"\n          class=\"oppia-translation-modal-subheading-lesson protractor-translation-suggestion-review-subheading\"\n          aria-hidden=\"false\">\n      {{ activeContribution.details.chapter_title }}\n    </span>\n    <button type=\"button\"\n            class=\"close oppia-close-button-position\"\n            (click)=\"cancel()\"\n            aria-label=\"Close\">\n      <span aria-hidden=\"true\">&times;</span>\n    </button>\n    <h4 class=\"oppia-translation-modal-author-header\">\n      Submitted by {{ authorName }} in {{ languageDescription }} language\n    </h4>\n  </div>\n</div>\n\n\n<div *ngIf=\"updateIsDisabled\" tabindex=\"0\" class=\"alert alert-danger oppia-input-error\">\n  <strong>Warning:</strong> Please ensure all components (images, math formulas, concept cards) in your translation match\n  the original content to proceed.\n</div>\n\n<div class=\"modal-body\">\n  <div *ngIf=\"status == 'rejected'\" class=\"translation-suggestion-review-message alert alert-danger\">\n    <p>See your submitted translation below. Please submit a new translation to address the requested revisions.</p>\n  </div>\n  <section class=\"oppia-suggestion-review-container\">\n    <div class=\"oppia-suggestion-review-panel-container float-left\">\n      <div class=\"oppia-suggestion-review-panel-header-container\">\n        <strong>Content to translate:</strong>\n      </div>\n      <div class=\"oppia-suggestion-review-panel\"\n           [ngClass]=\"isContentExpanded ? 'oppia-content-expanded' : 'oppia-content-collapsed'\"\n           #contentContainer>\n        <ul *ngIf=\"contentTypeIsSetOfStrings\">\n          <li *ngFor=\"let item of contentHtml; index as idx\">\n            {{ item }}\n          </li>\n        </ul>\n        <oppia-rte-output-display *ngIf=\"!contentTypeIsSetOfStrings\"\n                                  [rteString]=\"contentHtml\"\n                                  #contentPanel>\n        </oppia-rte-output-display>\n      </div>\n      <div class=\"oppia-collapse-content\"\n           *ngIf=\"isContentOverflowing\"\n           (click)=\"toggleExpansionState(0)\">\n        {{ isContentExpanded ? \"View Less\" : \"View More\" }}\n      </div>\n    </div>\n    <div class=\"oppia-suggestion-review-panel-container float-right\">\n      <div dir=\"auto\"\n           class=\"oppia-suggestion-review-panel-header-container oppia-translation-panel\">\n        <strong> Translation:</strong>\n        <button class=\"btn btn-sm btn-secondary float-right\"\n                *ngIf=\"!startedEditing && status === 'review' && canEditTranslation\"\n                (click)=\"editSuggestion()\">\n          Edit\n        </button>\n      </div>\n      <div class=\"oppia-suggestion-review-panel oppia-content\"\n           [ngClass]=\"isTranslationExpanded ? 'oppia-content-expanded' : 'oppia-content-collapsed'\"\n           #translationContainer>\n        <div dir=\"auto\">\n          <oppia-rte-output-display [rteString]=\"translationHtml\"\n                                    *ngIf=\"!startedEditing\"\n                                    #translationPanel>\n          </oppia-rte-output-display>\n          <ul *ngIf=\"contentTypeIsSetOfStrings\">\n            <li *ngFor=\"let item of translationHtml; index as idx\">\n              {{ item }}\n            </li>\n          </ul>\n          <schema-based-editor [schema]=\"HTML_SCHEMA\"\n                               *ngIf=\"startedEditing && contentTypeIsHtml\"\n                               [(ngModel)]=\"editedContent.html\">\n          </schema-based-editor>\n          <schema-based-editor [schema]=\"UNICODE_SCHEMA\"\n                               *ngIf=\"startedEditing && contentTypeIsUnicode\"\n                               [(ngModel)]=\"editedContent.html\">\n          </schema-based-editor>\n          <schema-based-editor [schema]=\"SET_OF_STRINGS_SCHEMA\"\n                               *ngIf=\"startedEditing && contentTypeIsSetOfStrings\"\n                               [(ngModel)]=\"editedContent.html\">\n          </schema-based-editor>\n        </div>\n        <div class=\"oppia-translation-error-section\"\n             *ngIf=\"startedEditing && errorFound\">\n          <p>\n            {{ errorMessage }}\n          </p>\n        </div>\n      </div>\n      <div class=\"oppia-translation-review-edit-buttons\">\n        <button class=\"btn btn-secondary mr-2\"\n                *ngIf=\"startedEditing\"\n                (click)=\"cancelEdit()\">\n          Cancel\n        </button>\n        <button class=\"btn btn-success ml-2\"\n                *ngIf=\"startedEditing\"\n                (click)=\"updateSuggestion()\"\n                [disabled]=\"updateIsDisabled\">\n          Update\n        </button>\n      </div>\n      <div class=\"oppia-collapse-content\"\n           *ngIf=\"isTranslationOverflowing\"\n           (click)=\"toggleExpansionState(1)\">\n        {{ isTranslationExpanded ? \"View Less\" : \"View More\" }}\n      </div>\n    </div>\n  </section>\n  <section class=\"oppia-suggestion-review-exploration-change\"\n           *ngIf=\"reviewable && hasExplorationContentChanged()\">\n    <p class=\"oppia-suggestion-review-exploration-change-note\">\n      <strong>\n        NOTE: The content has been modified since this translation has been submitted.\n        Please edit the translation as necessary.\n        The current content is:\n      </strong>\n    </p>\n    <div class=\"oppia-suggestion-review-panel\">\n      <ul *ngIf=\"contentTypeIsSetOfStrings\">\n        <li *ngFor=\"let item of explorationContentHtml; index as idx\">\n          {{ item }}\n        </li>\n      </ul>\n      <oppia-rte-output-display *ngIf=\"!contentTypeIsSetOfStrings\"\n                                [rteString]=\"explorationContentHtml\">\n      </oppia-rte-output-display>\n    </div>\n  </section>\n  <a [href]=\"'/create/' + activeSuggestion.target_id + '#/translation/' + activeSuggestion.change_cmd.state_name + '/'+ activeSuggestion.change_cmd.content_id + '/' + languageCode\" target=\"_blank\" rel=\"noopener\">\n    See Lesson Card\n  </a>\n  <section [hidden]=\"!reviewable\"\n           class=\"oppia-image-review-panel\"\n           *ngIf=\"explorationImagesString\">\n    <div class=\"oppia-common-scroll-container\">\n      <div class=\"oppia-exploration-image-container float-left\">\n        <oppia-rte-output-display *ngIf=\"!contentTypeIsSetOfStrings\"\n                                    [rteString]=\"explorationImagesString\"\n                                    [altTextIsDisplayed]=\"altTextIsDisplayed\"\n                                    #contentPanelWithAltText>\n        </oppia-rte-output-display>\n      </div>\n      <div class=\"oppia-suggestion-image-container float-right\">\n        <oppia-rte-output-display *ngIf=\"!contentTypeIsSetOfStrings\"\n                                    [rteString]=\"suggestionImagesString\"\n                                    [altTextIsDisplayed]=\"altTextIsDisplayed\"\n                                    #contentPanelWithAltText>\n        </oppia-rte-output-display>\n      </div>\n    </div>\n  </section>\n  <div [hidden]=\"!reviewable\"\n       class=\"oppia-suggestion-review-message\">\n    <label for=\"reviewMessage\">Review message (required if rejecting):</label>\n    <textarea id=\"reviewMessage\"\n              class=\"e2e-test-suggestion-review-message w-100\"\n              rows=\"3\"\n              [(ngModel)]=\"reviewMessage\"\n              [attr.maxlength]=\"MAX_REVIEW_MESSAGE_LENGTH\">\n    </textarea>\n    <div class=\"alert alert-danger\"\n         [hidden]=\"!(reviewMessage.length > MAX_REVIEW_MESSAGE_LENGTH)\">\n      Review message should be at most {{ MAX_REVIEW_MESSAGE_LENGTH }} characters.\n    </div>\n  </div>\n  <div [hidden]=\"reviewable || !reviewMessage || !reviewer\"\n       class=\"oppia-suggestion-review-message\">\n    <strong>Reviewer:</strong>\n    {{reviewer}}\n    <br>\n    <strong>Review message: </strong>\n    <div class=\"oppia-review-message\"\n         [ngClass]=\"{ 'oppia-reviewable-message': reviewable }\">\n      {{ reviewMessage }}\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <div class=\"oppia-review-buttons\">\n    <span ngbTooltip=\"Enter review message before rejecting\"\n          placement=\"bottom\"\n          [disableTooltip]=\"reviewMessage.length !== 0\">\n      <button class=\"btn btn-danger oppia-suggestion-resolve-button\"\n              *ngIf=\"reviewable\"\n              [disabled]=\"reviewMessage.length == 0 || reviewMessage.length > MAX_REVIEW_MESSAGE_LENGTH || resolvingSuggestion || startedEditing\"\n              (click)=\"rejectAndReviewNext(reviewMessage)\">\n        <i [hidden]=\"!resolvingSuggestion\"\n           class=\"fa fa-spinner\">\n        </i>\n        <span [hidden]=\"resolvingSuggestion\">\n          {{ lastSuggestionToReview || isLastItem ? 'Reject' : 'Reject and review next' }}\n        </span>\n      </button>\n    </span>\n    <span>\n      <button class=\"btn btn-success oppia-suggestion-resolve-button e2e-test-translation-accept-button\"\n              [disabled]=\"resolvingSuggestion || reviewMessage.length > MAX_REVIEW_MESSAGE_LENGTH || startedEditing\"\n              *ngIf=\"reviewable\"\n              (click)=\"acceptAndReviewNext()\">\n        <i [hidden]=\"!resolvingSuggestion\"\n           class=\"fa fa-spinner\">\n        </i>\n        <span [hidden]=\"resolvingSuggestion\">\n          {{ lastSuggestionToReview || isLastItem ? 'Accept' : 'Accept and review next' }}\n        </span>\n      </button>\n    </span>\n  </div>\n  <div class=\"oppia-pagination-container\">\n    <button type=\"button\"\n            class=\"oppia-pagination-button\"\n            (click)=\"goToPreviousItem()\"\n            [disabled]=\"isFirstItem\">\n      <span class=\"material-icons\">navigate_before</span>Previous\n    </button>\n    <button type=\"button\"\n            class=\"oppia-pagination-button\"\n            (click)=\"goToNextItem()\"\n            [disabled]=\"isLastItem\">\n      Next<span class=\"material-icons\">navigate_next</span>\n    </button>\n  </div>\n</div>\n\n<style>\n  .oppia-common-scroll-container {\n    border: 1px solid #ccc;\n    display: flex;\n    flex-direction: row;\n    gap: 1px;\n    overflow-x: auto;\n    width: 100%;\n  }\n  .oppia-image-review-panel {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    overflow-x: auto;\n    padding: 10px;\n  }\n  .oppia-exploration-image-container,\n  .oppia-suggestion-image-container {\n    max-height: 250px;\n    padding: 8px;\n    width: 49%;\n  }\n  oppia-rte-output-display oppia-noninteractive-image {\n    max-height: 50px;\n    max-width: 50px;\n  }\n  .oppia-reviewable-message {\n    border: 1px solid #ccc;\n  }\n  .oppia-review-message {\n    margin-top: 10px;\n    padding: 10px;\n  }\n  .oppia-review-buttons {\n    display: flex;\n    justify-content: flex-end;\n    width: 100%;\n  }\n  .modal-footer {\n    display: flex;\n    flex-direction: column;\n  }\n  .oppia-pagination-container {\n    display: flex;\n    justify-content: space-between;\n    margin: 10px 0;\n    width: 100%;\n  }\n  .oppia-pagination-button {\n    background-color: transparent;\n    border: none;\n    box-sizing: border-box;\n    color: #000;\n    font-size: 18px;\n    font-weight: bold;\n    min-height: 40px;\n    min-width: 100px;\n    text-align: center;\n  }\n  .oppia-pagination-button:hover {\n    border: 2px solid #000;\n    border-radius: 5px;\n  }\n  .oppia-pagination-button[disabled] {\n    color: #000;\n    opacity: 0.239;\n  }\n  .oppia-pagination-button[disabled]:hover {\n    border: none;\n  }\n  .oppia-collapse-content {\n    display: none;\n  }\n  .modal-body {\n    height: fit-content;\n  }\n  .oppia-modal-info {\n    display: flex;\n    flex-direction: column;\n  }\n  .oppia-translation-modal-subheading {\n    display: block;\n    margin: 0;\n  }\n  .oppia-translation-modal-subheading-lesson {\n    display: none;\n  }\n  .oppia-translation-modal-author-header {\n    margin-top: 12px;\n  }\n  .oppia-suggestion-review-panel {\n    border: 1px solid #ccc;\n    height: 88%;\n    max-height: none;\n    padding: 10px;\n    position: relative;\n  }\n  .oppia-suggestion-review-message {\n    margin-top: 20px;\n  }\n  .oppia-suggestion-resolve-button {\n    margin-left: 10px;\n    min-width: 130px;\n  }\n  .oppia-suggestion-review-panel-header-container {\n    height: 12%;\n    text-align: left;\n  }\n  .oppia-suggestion-review-exploration-change {\n    padding: 0 10px;\n  }\n  .oppia-suggestion-review-exploration-change-note {\n    margin-top: 18px;\n  }\n  .oppia-translation-review-edit-buttons {\n    margin-bottom: 10px;\n    margin-top: 10px;\n  }\n  .oppia-translation-error-section {\n    bottom: 10px;\n    color: red;\n    position: absolute;\n  }\n  .oppia-close-button-position {\n    font-size: 2.5rem;\n    height: fit-content;\n    position: absolute;\n    right: 12px;\n    top: 12px;\n  }\n  .oppia-suggestion-review-container {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n  }\n  .oppia-suggestion-review-panel-container {\n    height: 100%;\n    padding: auto 10px;\n    width: 49%;\n  }\n  /* From 1023px onwards, the modal text branches to the next line.\n     The use of line height ensures that alternate lines of the\n     heading stay close together.\n  */\n  @media only screen and (max-width: 1023px) {\n    .oppia-translation-modal-subheading {\n      line-height: 1.1;\n    }\n  }\n\n  @media only screen and (max-width: 700px) {\n    .oppia-exploration-image-container,\n    .oppia-suggestion-image-container {\n      padding: 1px;\n      width: 50%;\n    }\n    .oppia-translation-panel {\n      margin-top: 12px;\n    }\n    .oppia-content-expanded {\n      height: fit-content;\n      max-height: none;\n      overflow-y: hidden;\n    }\n    .oppia-content-collapsed {\n      max-height: 30vh;\n      overflow-y: scroll;\n    }\n    .oppia-cancel-button {\n      display: none;\n    }\n    .oppia-collapse-content {\n      background-color: #016a5d;\n      color: white;\n      cursor: pointer;\n      display: block;\n      font-size: 12px;\n      font-weight: bold;\n      margin: auto;\n      padding: 5px 10px;\n      position: relative;\n      text-align: center;\n      text-transform: uppercase;\n      top: -13px;\n      width: 85px;\n    }\n    .modal-body {\n      height: fit-content;\n    }\n\n    .oppia-suggestion-review-panel {\n      margin-top: 10px;\n      overflow-x: hidden;\n      padding-bottom: 16px;\n    }\n    .oppia-suggestion-review-panel-container {\n      margin-bottom: 0;\n      width: 100%;\n    }\n    .modal-header {\n      border-bottom: 1px solid #ccc;\n      padding-bottom: 10px;\n    }\n    .oppia-suggestion-review-container {\n      display: flex;\n      flex-direction: column;\n      height: fit-content;\n      padding: 0;\n    }\n    .oppia-image-review-panel {\n      padding: 0;\n    }\n    .oppia-modal-info-header {\n      font-size: 16px;\n      font-weight: normal;\n      margin-bottom: 18.7px;\n      margin-top: 18.7px;\n    }\n    .oppia-translation-modal-subheading {\n      display: none;\n    }\n    .oppia-translation-modal-subheading-lesson {\n      display: block;\n      font-size: 24px;\n      font-weight: bold;\n    }\n    .oppia-content {\n      padding-bottom: 6px;\n    }\n  }\n  @media only screen and (max-width: 450px) {\n    .oppia-suggestion-resolve-button {\n      margin-left: 4px;\n      margin-right: 0;\n      min-width: 40vw;\n    }\n    .oppia-review-buttons {\n      justify-content: center;\n    }\n    .oppia-suggestion-review-message {\n      font-size: 16px;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/translation-suggestion-review-modal.component.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for TranslationSuggestionReviewModalComponent.\n */\n\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\nimport {\n  ComponentFixture,\n  fakeAsync,\n  flush,\n  TestBed,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {TranslationSuggestionReviewModalComponent} from './translation-suggestion-review-modal.component';\nimport {ChangeDetectorRef, ElementRef, NO_ERRORS_SCHEMA} from '@angular/core';\nimport {NgbActiveModal} from '@ng-bootstrap/ng-bootstrap';\nimport {AppConstants} from 'app.constants';\nimport {AlertsService} from 'services/alerts.service';\nimport {ContributionAndReviewService} from '../services/contribution-and-review.service';\nimport {LanguageUtilService} from 'domain/utilities/language-util.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {ThreadDataBackendApiService} from 'pages/exploration-editor-page/feedback-tab/services/thread-data-backend-api.service';\nimport {UserService} from 'services/user.service';\nimport {UserInfo} from 'domain/user/user-info.model';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {\n  MatSnackBar,\n  MatSnackBarModule,\n  MatSnackBarRef,\n} from '@angular/material/snack-bar';\nimport {of, Subject} from 'rxjs';\n// This throws \"TS2307\". We need to\n// suppress this error because rte-output-display is not strictly typed yet.\n// @ts-ignore\nimport {RteOutputDisplayComponent} from 'rich_text_components/rte-output-display.component';\nimport {UndoSnackbarComponent} from 'components/custom-snackbar/undo-snackbar.component';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\nimport cloneDeep from 'lodash/cloneDeep';\n\nclass MockChangeDetectorRef {\n  detectChanges(): void {}\n}\n\nclass MockMatSnackBarRef {\n  instance = {message: ''};\n  afterDismissed = () => of({action: '', dismissedByAction: false});\n  onAction = () => of(undefined);\n  dismiss = () => of(undefined);\n}\n\nclass MockPlatformFeatureService {\n  status = {\n    CdAllowUndoingTranslationReview: {\n      isEnabled: false,\n    },\n  };\n}\n\ndescribe('Translation Suggestion Review Modal Component', function () {\n  let fixture: ComponentFixture<TranslationSuggestionReviewModalComponent>;\n  let component: TranslationSuggestionReviewModalComponent;\n  let alertsService: AlertsService;\n  let contributionAndReviewService: ContributionAndReviewService;\n  let languageUtilService: LanguageUtilService;\n  let siteAnalyticsService: SiteAnalyticsService;\n  let threadDataBackendApiService: ThreadDataBackendApiService;\n  let userService: UserService;\n  let activeModal: NgbActiveModal;\n  let changeDetectorRef: MockChangeDetectorRef = new MockChangeDetectorRef();\n  let snackBarSpy: jasmine.Spy;\n  let snackBar: MatSnackBar;\n  let mockPlatformFeatureService = new MockPlatformFeatureService();\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule, OverlayModule, MatSnackBarModule],\n      declarations: [\n        TranslationSuggestionReviewModalComponent,\n        UndoSnackbarComponent,\n      ],\n      providers: [\n        NgbActiveModal,\n        AlertsService,\n        ContributionAndReviewService,\n        LanguageUtilService,\n        SiteAnalyticsService,\n        ThreadDataBackendApiService,\n        UserService,\n        {\n          provide: ChangeDetectorRef,\n          useValue: changeDetectorRef,\n        },\n        MatSnackBar,\n        {\n          provide: PlatformFeatureService,\n          useValue: mockPlatformFeatureService,\n        },\n      ],\n      schemas: [NO_ERRORS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(\n      TranslationSuggestionReviewModalComponent\n    );\n    snackBar = TestBed.inject(MatSnackBar);\n    component = fixture.componentInstance;\n    activeModal = TestBed.inject(NgbActiveModal);\n    alertsService = TestBed.inject(AlertsService);\n    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);\n    threadDataBackendApiService = TestBed.inject(ThreadDataBackendApiService);\n    userService = TestBed.inject(UserService);\n    contributionAndReviewService = TestBed.inject(ContributionAndReviewService);\n    languageUtilService = TestBed.inject(LanguageUtilService);\n\n    spyOn(\n      siteAnalyticsService,\n      'registerContributorDashboardViewSuggestionForReview'\n    );\n    spyOn(languageUtilService, 'getAudioLanguageDescription').and.returnValue(\n      'audio_language_description'\n    );\n\n    snackBarSpy = spyOn(snackBar, 'openFromComponent').and.returnValue(\n      new MockMatSnackBarRef() as unknown as MatSnackBarRef<unknown>\n    );\n\n    component.contentContainer = new ElementRef({offsetHeight: 150});\n    component.translationContainer = new ElementRef({offsetHeight: 150});\n    component.contentPanel = new RteOutputDisplayComponent(\n      null,\n      null,\n      new ElementRef({offsetHeight: 200}),\n      null\n    );\n    component.translationPanel = new RteOutputDisplayComponent(\n      null,\n      null,\n      new ElementRef({offsetHeight: 200}),\n      null\n    );\n    component.initialSuggestionId = 'suggestion_1';\n    component.suggestionIdToContribution = {\n      suggestion_1: {\n        suggestion: {\n          author_name: 'author_name',\n          language_code: 'language_code',\n          last_updated_msecs: 1559074000000,\n          status: 'status',\n          suggestion_id: 'suggestion_1',\n          target_id: '1',\n          target_type: 'target_type',\n          suggestion_type: 'translate_content',\n          change_cmd: {\n            content_id: 'hint_1',\n            content_html: '<p>content</p>',\n            translation_html: 'Translation content',\n            state_name: 'StateName',\n            cmd: 'edit_state_property',\n            data_format: 'html',\n            language_code: 'language_code',\n          },\n          exploration_content_html: '<p>content</p>',\n        },\n        details: {\n          topic_name: 'topic_1',\n          story_title: 'story_1',\n          chapter_title: 'chapter_1',\n        },\n      },\n    };\n  });\n\n  describe('when initializing the modal ', () => {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p><p>&nbsp;</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content</p><p>&nbsp;</p>',\n    };\n    const suggestion2 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content CHANGED</p>',\n    };\n    const suggestion3 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_3',\n      target_id: '3',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content CHANGED</p>',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n    const contribution3 = {\n      suggestion: suggestion3,\n      details: {\n        topic_name: 'topic_3',\n        story_title: 'story_3',\n        chapter_title: 'chapter_3',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n      suggestion_3: contribution3,\n    };\n    const editedContent = {\n      html: '<p>In Hindi</p>',\n    };\n\n    beforeEach(() => {\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n      component.editedContent = editedContent;\n    });\n\n    it(\n      'should be able to navigate to both previous suggestion and ' +\n        'next suggestion if initial suggestion is in middle of list',\n      () => {\n        component.initialSuggestionId = 'suggestion_2';\n        component.ngOnInit();\n\n        expect(component.activeSuggestionId).toBe('suggestion_2');\n        expect(component.skippedContributionIds).toEqual(['suggestion_1']);\n        expect(component.remainingContributionIds).toEqual(['suggestion_3']);\n      }\n    );\n\n    it(\n      'should be able to navigate to only previous suggestion ' +\n        'if initial suggestion is the last suggestion of the list',\n      () => {\n        component.initialSuggestionId = 'suggestion_3';\n        component.ngOnInit();\n\n        expect(component.activeSuggestionId).toBe('suggestion_3');\n        expect(component.skippedContributionIds.sort()).toEqual([\n          'suggestion_1',\n          'suggestion_2',\n        ]);\n        expect(component.remainingContributionIds).toEqual([]);\n      }\n    );\n\n    it(\n      'should be able to navigate to only next suggestion ' +\n        'if initial suggestion is in first suggestion of the list',\n      () => {\n        component.initialSuggestionId = 'suggestion_1';\n        component.ngOnInit();\n\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.skippedContributionIds).toEqual([]);\n        expect(component.remainingContributionIds.sort()).toEqual([\n          'suggestion_2',\n          'suggestion_3',\n        ]);\n      }\n    );\n  });\n\n  describe('when reviewing suggestion when flag CdAllowUndoingTranslationReview is enabled', function () {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n    const suggestion1 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p><p>&nbsp;</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content</p><p>&nbsp;</p>',\n    };\n\n    const suggestion2 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content CHANGED</p>',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n    };\n\n    const editedContent = {\n      html: '<p>In Hindi</p>',\n    };\n\n    const userInfo = new UserInfo(\n      ['USER_ROLE'],\n      true,\n      false,\n      false,\n      false,\n      true,\n      'en',\n      'username1',\n      'tester@example.com',\n      true\n    );\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n      component.editedContent = editedContent;\n      mockPlatformFeatureService.status.CdAllowUndoingTranslationReview.isEnabled =\n        true;\n    });\n\n    it('should call user service at initialization.', function () {\n      const userInfoSpy = spyOn(\n        userService,\n        'getUserInfoAsync'\n      ).and.returnValue(Promise.resolve(userInfo));\n\n      const contributionRightsDataSpy = spyOn(\n        userService,\n        'getUserContributionRightsDataAsync'\n      ).and.returnValue(\n        Promise.resolve({\n          can_review_translation_for_language_codes: ['ar'],\n          can_review_voiceover_for_language_codes: [],\n          can_review_questions: false,\n          can_suggest_questions: false,\n        })\n      );\n      component.ngOnInit();\n      expect(userInfoSpy).toHaveBeenCalled();\n      expect(contributionRightsDataSpy).toHaveBeenCalled();\n    });\n\n    it('should throw error if username is invalid', fakeAsync(() => {\n      const defaultUserInfo = new UserInfo(\n        ['GUEST'],\n        false,\n        false,\n        false,\n        false,\n        false,\n        null,\n        null,\n        null,\n        false\n      );\n      spyOn(userService, 'getUserInfoAsync').and.returnValue(\n        Promise.resolve(defaultUserInfo)\n      );\n\n      expect(() => {\n        component.ngOnInit();\n        tick();\n      }).toThrowError();\n      flush();\n    }));\n\n    it('should initialize component properties after component is initialized', function () {\n      component.ngOnInit();\n      expect(component.subheading).toBe(subheading);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewMessage).toBe('');\n    });\n\n    it(\n      'should register Contributor Dashboard view suggestion for review ' +\n        'event after controller is initialized',\n      function () {\n        component.ngOnInit();\n        expect(\n          siteAnalyticsService.registerContributorDashboardViewSuggestionForReview\n        ).toHaveBeenCalledWith('Translation');\n      }\n    );\n\n    it('should notify user on failed suggestion update', function () {\n      component.ngOnInit();\n      const error = new Error('Error');\n      expect(component.errorFound).toBeFalse();\n      expect(component.errorMessage).toBe('');\n\n      component.showTranslationSuggestionUpdateError(error);\n\n      expect(component.errorFound).toBeTrue();\n      expect(component.errorMessage).toBe('Invalid Suggestion: Error');\n    });\n\n    it(\n      'should accept suggestion in suggestion modal service when clicking' +\n        ' on accept and review next suggestion button',\n      function () {\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        // Suggestion 1's exploration_content_html matches its content_html.\n        expect(component.hasExplorationContentChanged()).toBe(false);\n\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n        spyOn(component, 'showSnackbar');\n        spyOn(component, 'startCommitTimeout');\n\n        component.reviewMessage = 'Review message example';\n        component.translationUpdated = true;\n        component.acceptAndReviewNext();\n\n        expect(component.activeSuggestionId).toBe('suggestion_2');\n        expect(component.activeSuggestion).toEqual(suggestion2);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        component.commitQueuedSuggestion();\n\n        // Suggestion 2's exploration_content_html does not match its\n        // content_html.\n        expect(component.hasExplorationContentChanged()).toBe(true);\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'accept',\n          'Review message example: ' +\n            '(Note: This suggestion was submitted with reviewer edits.)',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n\n        component.reviewMessage = 'Review message example 2';\n        component.translationUpdated = false;\n        component.acceptAndReviewNext();\n\n        component.commitQueuedSuggestion();\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '2',\n          'suggestion_2',\n          'accept',\n          'Review message example 2',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n        expect(activeModal.close).toHaveBeenCalledWith([\n          'suggestion_1',\n          'suggestion_2',\n        ]);\n      }\n    );\n\n    it(\n      'should set suggestion review message to auto-generated note when ' +\n        'suggestion is accepted with edits and no user-supplied review message',\n      fakeAsync(() => {\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(component, 'resolveSuggestionAndUpdateModal');\n        spyOn(component, 'startCommitTimeout');\n        spyOn(component, 'showSnackbar');\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(alertsService, 'addSuccessMessage');\n\n        component.translationUpdated = true;\n        component.acceptAndReviewNext();\n\n        tick();\n\n        expect(component.hasQueuedSuggestion).toBeTrue();\n        expect(component.queuedSuggestion).toEqual({\n          target_id: '1',\n          suggestion_id: 'suggestion_1',\n          action_status: 'accept',\n          commit_message: 'hint section of \"StateName\" card',\n          reviewer_message:\n            '(Note: This suggestion was submitted with ' + 'reviewer edits.)',\n        });\n      })\n    );\n\n    it(\n      'should accept the queued suggestion when the timer has expired' +\n        'review button',\n      () => {\n        component.ngOnInit();\n\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n        spyOn(component, 'resolveSuggestionAndUpdateModal').and.stub();\n        spyOn(component, 'startCommitTimeout').and.stub();\n        spyOn(component, 'showSnackbar').and.stub();\n\n        component.acceptAndReviewNext();\n\n        expect(component.hasQueuedSuggestion).toBeTrue();\n        expect(component.queuedSuggestion).toEqual({\n          target_id: '1',\n          suggestion_id: 'suggestion_1',\n          action_status: AppConstants.ACTION_ACCEPT_SUGGESTION,\n          reviewer_message: '',\n          commit_message: 'hint section of \"StateName\" card',\n        });\n\n        component.commitQueuedSuggestion();\n      }\n    );\n\n    it('should reject the queued suggestion when the timer has expired', () => {\n      component.ngOnInit();\n\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.reviewMessage).toBe('');\n      expect(component.isUndoFeatureEnabled).toBeTrue();\n\n      spyOn(\n        siteAnalyticsService,\n        'registerContributorDashboardAcceptSuggestion'\n      );\n      spyOn(\n        contributionAndReviewService,\n        'reviewExplorationSuggestion'\n      ).and.callFake(\n        (\n          targetId,\n          suggestionId,\n          action,\n          reviewMessage,\n          commitMessage,\n          successCallback,\n          errorCallback\n        ) => {\n          return Promise.resolve(successCallback(suggestionId));\n        }\n      );\n      spyOn(activeModal, 'close');\n      spyOn(alertsService, 'addSuccessMessage');\n      spyOn(component, 'resolveSuggestionAndUpdateModal').and.stub();\n      spyOn(component, 'startCommitTimeout').and.stub();\n      spyOn(component, 'showSnackbar').and.stub();\n\n      component.rejectAndReviewNext('rejected');\n\n      expect(component.hasQueuedSuggestion).toBeTrue();\n      expect(component.queuedSuggestion).toEqual({\n        target_id: '1',\n        suggestion_id: 'suggestion_1',\n        action_status: AppConstants.ACTION_REJECT_SUGGESTION,\n        reviewer_message: 'rejected',\n      });\n\n      component.commitQueuedSuggestion();\n    });\n\n    it('should undo the queued suggestion when clicked on undo button', () => {\n      component.ngOnInit();\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.reviewMessage).toBe('');\n      component.resolvedSuggestionIds = ['suggestion_1'];\n\n      component.hasQueuedSuggestion = true;\n      component.queuedSuggestion = {\n        target_id: '1',\n        suggestion_id: 'suggestion_1',\n        action_status: 'accept',\n        commit_message: 'hint section of \"StateName\" card',\n        reviewer_message:\n          '(Note: This suggestion was submitted with' + 'reviewer edits.)',\n      };\n      component.removedSuggestion = contribution1;\n      component.undoReviewAction();\n\n      expect(component.hasQueuedSuggestion).toBeFalse();\n      expect(component.queuedSuggestion).toBe(undefined);\n    });\n\n    it(\n      'should allow the reviewer to fix the suggestion if the backend pre' +\n        ' accept/reject validation failed',\n      function () {\n        const responseMessage = 'Pre accept validation failed.';\n\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        spyOn(component, 'revertSuggestionResolution');\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardRejectSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.reject(errorCallback(responseMessage));\n          }\n        );\n        spyOn(alertsService, 'addWarning');\n\n        component.reviewMessage = 'Review message example';\n        component.queuedSuggestion = {\n          target_id: '1',\n          suggestion_id: 'suggestion_1',\n          action_status: 'accept',\n          commit_message: 'hint section of \"StateName\" card',\n          reviewer_message:\n            '(Note: This suggestion was submitted with' + 'reviewer edits.)',\n        };\n        component.hasQueuedSuggestion = true;\n        component.commitQueuedSuggestion();\n\n        expect(component.revertSuggestionResolution).toHaveBeenCalled();\n      }\n    );\n\n    it('should show the pop up bar when suggestion is queued', () => {\n      spyOn(component, 'commitQueuedSuggestion').and.callThrough();\n      component.hasQueuedSuggestion = true;\n      component.showSnackbar();\n\n      expect(snackBarSpy.calls.mostRecent().returnValue.instance.message).toBe(\n        'Suggestion queued'\n      );\n    });\n\n    it(\n      'should commit the queued suggestion when' + ' the snackbar is dismissed',\n      () => {\n        const commitQueuedSuggestionSpy = spyOn(\n          component,\n          'commitQueuedSuggestion'\n        ).and.callThrough();\n\n        let afterDismissedObservable = new Subject<void>();\n        let snackBarRefMock = {\n          instance: {message: ''},\n          afterDismissed: () => afterDismissedObservable.asObservable(),\n          onAction: () => of(null),\n        };\n\n        snackBarSpy.and.returnValue(snackBarRefMock);\n\n        component.showSnackbar();\n        component.hasQueuedSuggestion = true;\n\n        afterDismissedObservable.next();\n        afterDismissedObservable.complete();\n\n        expect(commitQueuedSuggestionSpy).toHaveBeenCalled();\n      }\n    );\n\n    it(\n      'should start commit timeout when clicking on accept and review' +\n        'next suggestion button',\n      () => {\n        spyOn(window, 'setTimeout');\n        spyOn(component, 'commitQueuedSuggestion');\n        component.commitTimeout = undefined;\n\n        component.startCommitTimeout();\n\n        expect(window.setTimeout).toHaveBeenCalled();\n        const timeoutCallback = (\n          window.setTimeout as unknown as jasmine.Spy\n        ).calls.mostRecent().args[0];\n        expect(typeof timeoutCallback).toBe('function');\n\n        timeoutCallback();\n\n        expect(component.commitQueuedSuggestion).toHaveBeenCalled();\n      }\n    );\n\n    it('should remove suggestion_id from resolvedSuggestionIds if it exists', () => {\n      component.ngOnInit();\n      component.resolvedSuggestionIds = ['suggestion_1', 'suggestion_2'];\n      component.queuedSuggestion = {\n        suggestion_id: 'suggestion_1',\n        action_status: 'accept',\n        target_id: '1',\n        reviewer_message: '',\n      };\n      component.removedSuggestion = contribution1;\n\n      component.revertSuggestionResolution();\n\n      expect(component.resolvedSuggestionIds).toEqual(['suggestion_2']);\n    });\n\n    it(\n      'should cancel suggestion in suggestion modal service when clicking ' +\n        'on cancel suggestion button',\n      function () {\n        spyOn(activeModal, 'close');\n        component.cancel();\n        expect(activeModal.close).toHaveBeenCalledWith([]);\n      }\n    );\n\n    it('should open the translation editor when the edit button is clicked', function () {\n      component.editSuggestion();\n      expect(component.startedEditing).toBe(true);\n    });\n\n    it('should close the translation editor when the cancel button is clicked', function () {\n      component.cancelEdit();\n      expect(component.startedEditing).toBe(false);\n    });\n\n    it('should expand the content area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      // The content area is contracted by default.\n      expect(component.isContentExpanded).toBeFalse();\n      // The content area should expand when the users clicks\n      // on the 'View More' button.\n      component.toggleExpansionState(0);\n\n      expect(component.isContentExpanded).toBeTrue();\n    });\n\n    it('should contract the content area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      component.isContentExpanded = true;\n      // The content area should contract when the users clicks\n      // on the 'View Less' button.\n      component.toggleExpansionState(0);\n\n      expect(component.isContentExpanded).toBeFalse();\n    });\n\n    it('should expand the translation area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      // The translation area is contracted by default.\n      expect(component.isTranslationExpanded).toBeFalse();\n      // The translation area should expand when the users clicks\n      // on the 'View More' button.\n      component.toggleExpansionState(1);\n\n      expect(component.isTranslationExpanded).toBeTrue();\n    });\n\n    it('should contract the translation area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      component.isTranslationExpanded = true;\n      // The translation area should contract when the users clicks\n      // on the 'View Less' button.\n      component.toggleExpansionState(1);\n\n      expect(component.isTranslationExpanded).toBeFalse();\n    });\n\n    it('should update translation when the update button is clicked', function () {\n      component.ngOnInit();\n      spyOn(\n        contributionAndReviewService,\n        'updateTranslationSuggestionAsync'\n      ).and.callFake(\n        (suggestionId, translationHtml, successCallback, errorCallback) => {\n          return Promise.resolve(successCallback());\n        }\n      );\n\n      component.updateSuggestion();\n\n      expect(\n        contributionAndReviewService.updateTranslationSuggestionAsync\n      ).toHaveBeenCalledWith(\n        'suggestion_1',\n        component.editedContent.html,\n        jasmine.any(Function),\n        jasmine.any(Function)\n      );\n    });\n\n    describe('isHtmlContentEqual', function () {\n      it('should return true regardless of &nbsp; differences', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p><p>&nbsp;&nbsp;</p>',\n            '<p>content</p><p> </p>'\n          )\n        ).toBe(true);\n      });\n\n      it('should return true regardless of new line differences', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p>\\r\\n\\n<p>content2</p>',\n            '<p>content</p><p>content2</p>'\n          )\n        ).toBe(true);\n      });\n\n      it('should return false if html content differ', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p>',\n            '<p>content CHANGED</p>'\n          )\n        ).toBe(false);\n      });\n\n      it('should return false if array contents differ', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            ['<p>content1</p>', '<p>content2 CHANGED</p>']\n          )\n        ).toBe(false);\n      });\n\n      it('should return true if array contents are equal', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            ['<p>content1</p>', '<p>content2</p>']\n          )\n        ).toBe(true);\n      });\n\n      it('should return false if type is different', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            '<p>content2</p>'\n          )\n        ).toBe(false);\n      });\n    });\n  });\n\n  describe('when reviewing suggestions with deleted opportunites when flag CdAllowUndoingTranslationReview is enabled', function () {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: ['Translation1', 'Translation2'],\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: ['Translation1', 'Translation2 CHANGED'],\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: 'Translation',\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n\n    const deletedContribution = {\n      suggestion: suggestion2,\n      details: null,\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_deleted: deletedContribution,\n    };\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n      mockPlatformFeatureService.status.CdAllowUndoingTranslationReview.isEnabled =\n        true;\n      component.ngOnInit();\n    });\n\n    it(\n      'should reject suggestion in suggestion modal service when clicking ' +\n        'on reject and review next suggestion button',\n      function () {\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardRejectSuggestion'\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n\n        spyOn(component, 'startCommitTimeout');\n        spyOn(component, 'showSnackbar');\n        spyOn(component, 'resolveSuggestionAndUpdateModal');\n\n        component.reviewMessage = 'Review message example';\n        component.rejectAndReviewNext(component.reviewMessage);\n        component.commitQueuedSuggestion();\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardRejectSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'reject',\n          'Review message example',\n          null,\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalledWith(\n          'Suggestion rejected.'\n        );\n      }\n    );\n  });\n\n  describe('when reviewing suggestion when flag CdAllowUndoingTranslationReview is disabled', function () {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n    const suggestion1 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p><p>&nbsp;</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content</p><p>&nbsp;</p>',\n    };\n\n    const suggestion2 = {\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      target_type: 'target_type',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content CHANGED</p>',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n    };\n\n    const editedContent = {\n      html: '<p>In Hindi</p>',\n    };\n\n    const userInfo = new UserInfo(\n      ['USER_ROLE'],\n      true,\n      false,\n      false,\n      false,\n      true,\n      'en',\n      'username1',\n      'tester@example.com',\n      true\n    );\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n\n      component.editedContent = editedContent;\n      mockPlatformFeatureService.status.CdAllowUndoingTranslationReview.isEnabled =\n        false;\n    });\n\n    it('should call user service at initialization.', function () {\n      const userInfoSpy = spyOn(\n        userService,\n        'getUserInfoAsync'\n      ).and.returnValue(Promise.resolve(userInfo));\n\n      const contributionRightsDataSpy = spyOn(\n        userService,\n        'getUserContributionRightsDataAsync'\n      ).and.returnValue(\n        Promise.resolve({\n          can_review_translation_for_language_codes: ['ar'],\n          can_review_voiceover_for_language_codes: [],\n          can_review_questions: false,\n          can_suggest_questions: false,\n        })\n      );\n      component.ngOnInit();\n      expect(userInfoSpy).toHaveBeenCalled();\n      expect(contributionRightsDataSpy).toHaveBeenCalled();\n    });\n\n    it('should throw error if username is invalid', fakeAsync(() => {\n      const defaultUserInfo = new UserInfo(\n        ['GUEST'],\n        false,\n        false,\n        false,\n        false,\n        false,\n        null,\n        null,\n        null,\n        false\n      );\n      spyOn(userService, 'getUserInfoAsync').and.returnValue(\n        Promise.resolve(defaultUserInfo)\n      );\n\n      expect(() => {\n        component.ngOnInit();\n        tick();\n      }).toThrowError();\n      flush();\n    }));\n\n    it('should initialize component properties after component is initialized', function () {\n      component.ngOnInit();\n      expect(component.subheading).toBe(subheading);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewMessage).toBe('');\n    });\n\n    it(\n      'should register Contributor Dashboard view suggestion for review ' +\n        'event after controller is initialized',\n      function () {\n        component.ngOnInit();\n        expect(\n          siteAnalyticsService.registerContributorDashboardViewSuggestionForReview\n        ).toHaveBeenCalledWith('Translation');\n      }\n    );\n\n    it('should notify user on failed suggestion update', function () {\n      component.ngOnInit();\n      const error = new Error('Error');\n      expect(component.errorFound).toBeFalse();\n      expect(component.errorMessage).toBe('');\n\n      component.showTranslationSuggestionUpdateError(error);\n\n      expect(component.errorFound).toBeTrue();\n      expect(component.errorMessage).toBe('Invalid Suggestion: Error');\n    });\n\n    it(\n      'should accept suggestion in suggestion modal service when clicking' +\n        ' on accept and review next suggestion button',\n      function () {\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        // Suggestion 1's exploration_content_html matches its content_html.\n        expect(component.hasExplorationContentChanged()).toBe(false);\n\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n\n        component.reviewMessage = 'Review message example';\n        component.translationUpdated = true;\n        component.acceptAndReviewNext();\n\n        expect(component.activeSuggestionId).toBe('suggestion_2');\n        expect(component.activeSuggestion).toEqual(suggestion2);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        // Suggestion 2's exploration_content_html does not match its\n        // content_html.\n        expect(component.hasExplorationContentChanged()).toBe(true);\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'accept',\n          'Review message example: ' +\n            '(Note: This suggestion was submitted with reviewer edits.)',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n\n        component.reviewMessage = 'Review message example 2';\n        component.translationUpdated = false;\n        component.acceptAndReviewNext();\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '2',\n          'suggestion_2',\n          'accept',\n          'Review message example 2',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n        expect(activeModal.close).toHaveBeenCalledWith([\n          'suggestion_1',\n          'suggestion_2',\n        ]);\n      }\n    );\n\n    it(\n      'should set suggestion review message to auto-generated note when ' +\n        'suggestion is accepted with edits and no user-supplied review message',\n      function () {\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(alertsService, 'addSuccessMessage');\n\n        component.translationUpdated = true;\n        component.acceptAndReviewNext();\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'accept',\n          '(Note: This suggestion was submitted with reviewer edits.)',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n      }\n    );\n\n    it(\n      'should reject suggestion in suggestion modal service when clicking ' +\n        'on reject and review next suggestion button',\n      function () {\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardRejectSuggestion'\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n\n        component.reviewMessage = 'Review message example';\n        component.translationUpdated = true;\n        component.rejectAndReviewNext(component.reviewMessage);\n\n        expect(component.activeSuggestionId).toBe('suggestion_2');\n        expect(component.activeSuggestion).toEqual(suggestion2);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        expect(\n          siteAnalyticsService.registerContributorDashboardRejectSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'reject',\n          'Review message example',\n          null,\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n\n        component.reviewMessage = 'Review message example 2';\n        component.translationUpdated = false;\n        component.rejectAndReviewNext(component.reviewMessage);\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardRejectSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n        expect(activeModal.close).toHaveBeenCalledWith([\n          'suggestion_1',\n          'suggestion_2',\n        ]);\n      }\n    );\n\n    it(\n      'should allow the reviewer to fix the suggestion if the backend pre' +\n        ' accept/reject validation failed',\n      function () {\n        const responseMessage = 'Pre accept validation failed.';\n\n        component.ngOnInit();\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardAcceptSuggestion'\n        );\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardRejectSuggestion'\n        );\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.reject(errorCallback(responseMessage));\n          }\n        );\n        spyOn(alertsService, 'addWarning');\n\n        component.reviewMessage = 'Review message example';\n        component.acceptAndReviewNext();\n\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('Review message example');\n        expect(\n          siteAnalyticsService.registerContributorDashboardAcceptSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'accept',\n          'Review message example',\n          'hint section of \"StateName\" card',\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addWarning).toHaveBeenCalledWith(\n          jasmine.stringContaining(responseMessage)\n        );\n\n        component.reviewMessage = 'Edited review message example';\n        component.rejectAndReviewNext(component.reviewMessage);\n\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('Edited review message example');\n        expect(\n          siteAnalyticsService.registerContributorDashboardRejectSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'reject',\n          'Edited review message example',\n          null,\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addWarning).toHaveBeenCalledWith(\n          jasmine.stringContaining(responseMessage)\n        );\n      }\n    );\n\n    it(\n      'should cancel suggestion in suggestion modal service when clicking ' +\n        'on cancel suggestion button',\n      function () {\n        spyOn(activeModal, 'close');\n        component.cancel();\n        expect(activeModal.close).toHaveBeenCalledWith([]);\n      }\n    );\n\n    it('should open the translation editor when the edit button is clicked', function () {\n      component.editSuggestion();\n      expect(component.startedEditing).toBe(true);\n    });\n\n    it('should close the translation editor when the cancel button is clicked', function () {\n      component.cancelEdit();\n      expect(component.startedEditing).toBe(false);\n    });\n\n    it('should expand the content area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      // The content area is contracted by default.\n      expect(component.isContentExpanded).toBeFalse();\n      // The content area should expand when the users clicks\n      // on the 'View More' button.\n      component.toggleExpansionState(0);\n\n      expect(component.isContentExpanded).toBeTrue();\n    });\n\n    it('should contract the content area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      component.isContentExpanded = true;\n      // The content area should contract when the users clicks\n      // on the 'View Less' button.\n      component.toggleExpansionState(0);\n\n      expect(component.isContentExpanded).toBeFalse();\n    });\n\n    it('should expand the translation area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      // The translation area is contracted by default.\n      expect(component.isTranslationExpanded).toBeFalse();\n      // The translation area should expand when the users clicks\n      // on the 'View More' button.\n      component.toggleExpansionState(1);\n\n      expect(component.isTranslationExpanded).toBeTrue();\n    });\n\n    it('should contract the translation area', () => {\n      spyOn(component, 'toggleExpansionState').and.callThrough();\n      component.isTranslationExpanded = true;\n      // The translation area should contract when the users clicks\n      // on the 'View Less' button.\n      component.toggleExpansionState(1);\n\n      expect(component.isTranslationExpanded).toBeFalse();\n    });\n\n    it('should update translation when the update button is clicked', function () {\n      component.ngOnInit();\n      spyOn(\n        contributionAndReviewService,\n        'updateTranslationSuggestionAsync'\n      ).and.callFake(\n        (suggestionId, translationHtml, successCallback, errorCallback) => {\n          return Promise.resolve(successCallback());\n        }\n      );\n\n      component.updateSuggestion();\n\n      expect(\n        contributionAndReviewService.updateTranslationSuggestionAsync\n      ).toHaveBeenCalledWith(\n        'suggestion_1',\n        component.editedContent.html,\n        jasmine.any(Function),\n        jasmine.any(Function)\n      );\n    });\n\n    describe('isHtmlContentEqual', function () {\n      it('should return true regardless of &nbsp; differences', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p><p>&nbsp;&nbsp;</p>',\n            '<p>content</p><p> </p>'\n          )\n        ).toBe(true);\n      });\n\n      it('should return true regardless of new line differences', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p>\\r\\n\\n<p>content2</p>',\n            '<p>content</p><p>content2</p>'\n          )\n        ).toBe(true);\n      });\n\n      it('should return false if html content differ', function () {\n        expect(\n          component.isHtmlContentEqual(\n            '<p>content</p>',\n            '<p>content CHANGED</p>'\n          )\n        ).toBe(false);\n      });\n\n      it('should return false if array contents differ', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            ['<p>content1</p>', '<p>content2 CHANGED</p>']\n          )\n        ).toBe(false);\n      });\n\n      it('should return true if array contents are equal', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            ['<p>content1</p>', '<p>content2</p>']\n          )\n        ).toBe(true);\n      });\n\n      it('should return false if type is different', function () {\n        expect(\n          component.isHtmlContentEqual(\n            ['<p>content1</p>', '<p>content2</p>'],\n            '<p>content2</p>'\n          )\n        ).toBe(false);\n      });\n    });\n  });\n\n  describe('when reviewing suggestions with deleted opportunites when flag CdAllowUndoingTranslationReview is disabled', function () {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: ['Translation1', 'Translation2'],\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: ['Translation1', 'Translation2 CHANGED'],\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: 'Translation',\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n\n    const deletedContribution = {\n      suggestion: suggestion2,\n      details: null,\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_deleted: deletedContribution,\n    };\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n\n      mockPlatformFeatureService.status.CdAllowUndoingTranslationReview.isEnabled =\n        false;\n      component.ngOnInit();\n    });\n\n    it(\n      'should reject suggestion in suggestion modal service when clicking ' +\n        'on reject and review next suggestion button',\n      function () {\n        expect(component.activeSuggestionId).toBe('suggestion_1');\n        expect(component.activeSuggestion).toEqual(suggestion1);\n        expect(component.reviewable).toBe(reviewable);\n        expect(component.reviewMessage).toBe('');\n\n        spyOn(\n          contributionAndReviewService,\n          'reviewExplorationSuggestion'\n        ).and.callFake(\n          (\n            targetId,\n            suggestionId,\n            action,\n            reviewMessage,\n            commitMessage,\n            successCallback,\n            errorCallback\n          ) => {\n            return Promise.resolve(successCallback(suggestionId));\n          }\n        );\n        spyOn(\n          siteAnalyticsService,\n          'registerContributorDashboardRejectSuggestion'\n        );\n        spyOn(activeModal, 'close');\n        spyOn(alertsService, 'addSuccessMessage');\n\n        component.reviewMessage = 'Review message example';\n        component.rejectAndReviewNext(component.reviewMessage);\n\n        expect(\n          siteAnalyticsService.registerContributorDashboardRejectSuggestion\n        ).toHaveBeenCalledWith('Translation');\n        expect(\n          contributionAndReviewService.reviewExplorationSuggestion\n        ).toHaveBeenCalledWith(\n          '1',\n          'suggestion_1',\n          'reject',\n          'Review message example',\n          null,\n          jasmine.any(Function),\n          jasmine.any(Function)\n        );\n        expect(alertsService.addSuccessMessage).toHaveBeenCalledWith(\n          'Suggestion rejected.'\n        );\n        expect(activeModal.close).toHaveBeenCalledWith(['suggestion_1']);\n      }\n    );\n  });\n\n  describe('when viewing suggestion', function () {\n    const reviewable = false;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: ['Translation1', 'Translation2'],\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: ['Translation1', 'Translation2 CHANGED'],\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: 'Translation',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      target_type: 'target_type',\n    };\n    const obsoleteSuggestion = {\n      suggestion_id: 'suggestion_3',\n      target_id: '3',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      // This suggestion is obsolete.\n      exploration_content_html: null,\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n    const contribution3 = {\n      suggestion: obsoleteSuggestion,\n      details: {\n        topic_name: 'topic_3',\n        story_title: 'story_3',\n        chapter_title: 'chapter_3',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n      suggestion_3: contribution3,\n    };\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n    });\n\n    it('should initialize component properties after component is initialized', fakeAsync(function () {\n      const messages = [\n        {\n          author_username: '',\n          created_on_msecs: 0,\n          entity_type: '',\n          entity_id: '',\n          message_id: 0,\n          text: '',\n          updated_status: '',\n          updated_subject: '',\n        },\n        {\n          author_username: 'Reviewer',\n          created_on_msecs: 0,\n          entity_type: '',\n          entity_id: '',\n          message_id: 0,\n          text: 'Review Message',\n          updated_status: 'fixed',\n          updated_subject: null,\n        },\n      ];\n\n      const fetchMessagesAsyncSpy = spyOn(\n        threadDataBackendApiService,\n        'fetchMessagesAsync'\n      ).and.returnValue(Promise.resolve({messages: messages}));\n\n      component.ngOnInit();\n      component.refreshActiveContributionState();\n      tick();\n\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.subheading).toBe('topic_1 / story_1 / chapter_1');\n      // Suggestion 1's exploration_content_html does not match its\n      // content_html.\n      expect(component.hasExplorationContentChanged()).toBe(true);\n      expect(fetchMessagesAsyncSpy).toHaveBeenCalledWith('suggestion_1');\n      expect(component.reviewMessage).toBe('Review Message');\n      expect(component.reviewer).toBe('Reviewer');\n    }));\n\n    it('should correctly determine whether the panel data is overflowing', fakeAsync(() => {\n      // Pre-check.\n      // The default values for the overflow states are false.\n      expect(component.isContentOverflowing).toBeFalse();\n      expect(component.isTranslationOverflowing).toBeFalse();\n      // Setup.\n      component.contentPanel.elementRef.nativeElement.offsetHeight = 100;\n      component.translationPanel.elementRef.nativeElement.offsetHeight = 200;\n      component.contentContainer.nativeElement.offsetHeight = 150;\n      component.translationContainer.nativeElement.offsetHeight = 150;\n      // Action.\n      component.computePanelOverflowState();\n      tick(0);\n      // Expectations.\n      expect(component.isContentOverflowing).toBeFalse();\n      expect(component.isTranslationOverflowing).toBeTrue();\n      // Change panel height to simulate changing of the modal data.\n      component.contentPanel.elementRef.nativeElement.offsetHeight = 300;\n      // Action.\n      component.computePanelOverflowState();\n      tick(0);\n      // Expectations.\n      expect(component.isContentOverflowing).toBeTrue();\n      expect(component.isTranslationOverflowing).toBeTrue();\n    }));\n\n    it('should determine panel height after view initialization', () => {\n      spyOn(component, 'computePanelOverflowState').and.callFake(() => {});\n\n      component.ngAfterViewInit();\n\n      expect(component.computePanelOverflowState).toHaveBeenCalled();\n    });\n\n    it('should set Obsolete review message for obsolete suggestions', fakeAsync(function () {\n      const fetchMessagesAsyncSpy = spyOn(\n        threadDataBackendApiService,\n        'fetchMessagesAsync'\n      ).and.returnValue(Promise.resolve({messages: []}));\n      component.initialSuggestionId = 'suggestion_3';\n\n      component.ngOnInit();\n      component.refreshActiveContributionState();\n      tick();\n\n      expect(component.activeSuggestionId).toBe('suggestion_3');\n      expect(component.activeSuggestion).toEqual(obsoleteSuggestion);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.subheading).toBe('topic_3 / story_3 / chapter_3');\n      // Suggestion 3's exploration_content_html does not match its\n      // content_html.\n      expect(component.hasExplorationContentChanged()).toBe(true);\n      expect(fetchMessagesAsyncSpy).toHaveBeenCalledWith('suggestion_3');\n      expect(component.reviewMessage).toBe(\n        AppConstants.OBSOLETE_TRANSLATION_SUGGESTION_REVIEW_MSG\n      );\n    }));\n  });\n\n  describe('when viewing suggestion', function () {\n    const reviewable = false;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: ['Translation1', 'Translation2'],\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: ['Translation1', 'Translation2 CHANGED'],\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: 'Translation',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      target_type: 'target_type',\n    };\n    const obsoleteSuggestion = {\n      suggestion_id: 'suggestion_3',\n      target_id: '3',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      // This suggestion is obsolete.\n      exploration_content_html: null,\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n    const contribution3 = {\n      suggestion: obsoleteSuggestion,\n      details: {\n        topic_name: 'topic_3',\n        story_title: 'story_3',\n        chapter_title: 'chapter_3',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n      suggestion_3: contribution3,\n    };\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n    });\n\n    it('should initialize component properties after component is initialized', fakeAsync(function () {\n      const messages = [\n        {\n          author_username: '',\n          created_on_msecs: 0,\n          entity_type: '',\n          entity_id: '',\n          message_id: 0,\n          text: '',\n          updated_status: '',\n          updated_subject: '',\n        },\n        {\n          author_username: 'Reviewer',\n          created_on_msecs: 0,\n          entity_type: '',\n          entity_id: '',\n          message_id: 0,\n          text: 'Review Message',\n          updated_status: 'fixed',\n          updated_subject: null,\n        },\n      ];\n\n      const fetchMessagesAsyncSpy = spyOn(\n        threadDataBackendApiService,\n        'fetchMessagesAsync'\n      ).and.returnValue(Promise.resolve({messages: messages}));\n\n      component.ngOnInit();\n      component.refreshActiveContributionState();\n      tick();\n\n      expect(component.activeSuggestionId).toBe('suggestion_1');\n      expect(component.activeSuggestion).toEqual(suggestion1);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.subheading).toBe('topic_1 / story_1 / chapter_1');\n      // Suggestion 1's exploration_content_html does not match its\n      // content_html.\n      expect(component.hasExplorationContentChanged()).toBe(true);\n      expect(fetchMessagesAsyncSpy).toHaveBeenCalledWith('suggestion_1');\n      expect(component.reviewMessage).toBe('Review Message');\n      expect(component.reviewer).toBe('Reviewer');\n    }));\n\n    it('should correctly determine whether the panel data is overflowing', fakeAsync(() => {\n      // Pre-check.\n      // The default values for the overflow states are false.\n      expect(component.isContentOverflowing).toBeFalse();\n      expect(component.isTranslationOverflowing).toBeFalse();\n      // Setup.\n      component.contentPanel.elementRef.nativeElement.offsetHeight = 100;\n      component.translationPanel.elementRef.nativeElement.offsetHeight = 200;\n      component.contentContainer.nativeElement.offsetHeight = 150;\n      component.translationContainer.nativeElement.offsetHeight = 150;\n      // Action.\n      component.computePanelOverflowState();\n      tick(0);\n      // Expectations.\n      expect(component.isContentOverflowing).toBeFalse();\n      expect(component.isTranslationOverflowing).toBeTrue();\n      // Change panel height to simulate changing of the modal data.\n      component.contentPanel.elementRef.nativeElement.offsetHeight = 300;\n      // Action.\n      component.computePanelOverflowState();\n      tick(0);\n      // Expectations.\n      expect(component.isContentOverflowing).toBeTrue();\n      expect(component.isTranslationOverflowing).toBeTrue();\n    }));\n\n    it('should determine panel height after view initialization', () => {\n      spyOn(component, 'computePanelOverflowState').and.callFake(() => {});\n\n      component.ngAfterViewInit();\n\n      expect(component.computePanelOverflowState).toHaveBeenCalled();\n    });\n\n    it('should set Obsolete review message for obsolete suggestions', fakeAsync(function () {\n      const fetchMessagesAsyncSpy = spyOn(\n        threadDataBackendApiService,\n        'fetchMessagesAsync'\n      ).and.returnValue(Promise.resolve({messages: []}));\n      component.initialSuggestionId = 'suggestion_3';\n\n      component.ngOnInit();\n      component.refreshActiveContributionState();\n      tick();\n\n      expect(component.activeSuggestionId).toBe('suggestion_3');\n      expect(component.activeSuggestion).toEqual(obsoleteSuggestion);\n      expect(component.reviewable).toBe(reviewable);\n      expect(component.subheading).toBe('topic_3 / story_3 / chapter_3');\n      // Suggestion 3's exploration_content_html does not match its\n      // content_html.\n      expect(component.hasExplorationContentChanged()).toBe(true);\n      expect(fetchMessagesAsyncSpy).toHaveBeenCalledWith('suggestion_3');\n      expect(component.reviewMessage).toBe(\n        AppConstants.OBSOLETE_TRANSLATION_SUGGESTION_REVIEW_MSG\n      );\n    }));\n  });\n\n  describe('when navigating through suggestions', function () {\n    const reviewable = false;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: ['Translation1', 'Translation2'],\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: ['Translation1', 'Translation2 CHANGED'],\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: 'Translation',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: 'Translation',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      status: 'status',\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n    };\n\n    const suggestionIdToContributionOne = {\n      suggestion_1: contribution1,\n    };\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n    });\n\n    it('should correctly set variables if there is only one item', () => {\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContributionOne\n      );\n      component.ngOnInit();\n\n      expect(component.isFirstItem).toBeTrue();\n      expect(component.isLastItem).toBeTrue();\n      expect(component.remainingContributionIds.length).toEqual(0);\n      expect(component.skippedContributionIds.length).toEqual(0);\n    });\n\n    it('should correctly set variables if there are multiple items', () => {\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n\n      component.ngOnInit();\n\n      expect(component.isFirstItem).toBeTrue();\n      expect(component.isLastItem).toBeFalse();\n      expect(component.remainingContributionIds.length).toEqual(1);\n      expect(component.skippedContributionIds.length).toEqual(0);\n    });\n\n    it('should successfully navigate between items', () => {\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n\n      component.ngOnInit();\n      spyOn(component, 'refreshActiveContributionState').and.callThrough();\n\n      expect(component.isFirstItem).toBeTrue();\n      expect(component.isLastItem).toBeFalse();\n      expect(component.remainingContributionIds).toEqual(['suggestion_2']);\n      expect(component.skippedContributionIds.length).toEqual(0);\n      expect(component.activeSuggestionId).toEqual('suggestion_1');\n\n      component.goToPreviousItem();\n      // As we are on the first item, goToPreviousItem shouldn't navigate.\n      expect(component.isFirstItem).toBeTrue();\n      expect(component.isLastItem).toBeFalse();\n      expect(component.remainingContributionIds).toEqual(['suggestion_2']);\n      expect(component.skippedContributionIds.length).toEqual(0);\n      expect(component.activeSuggestionId).toEqual('suggestion_1');\n\n      component.goToNextItem();\n\n      expect(component.isFirstItem).toBeFalse();\n      expect(component.isLastItem).toBeTrue();\n      expect(component.remainingContributionIds.length).toEqual(0);\n      expect(component.skippedContributionIds).toEqual(['suggestion_1']);\n      expect(component.activeSuggestionId).toEqual('suggestion_2');\n      expect(component.refreshActiveContributionState).toHaveBeenCalled();\n\n      component.goToNextItem();\n      // As we are on the last item, goToNextItem shoudn't navigate.\n      expect(component.isFirstItem).toBeFalse();\n      expect(component.isLastItem).toBeTrue();\n      expect(component.remainingContributionIds.length).toEqual(0);\n      expect(component.skippedContributionIds).toEqual(['suggestion_1']);\n      expect(component.activeSuggestionId).toEqual('suggestion_2');\n\n      component.goToPreviousItem();\n\n      expect(component.isFirstItem).toBeTrue();\n      expect(component.isLastItem).toBeFalse();\n      expect(component.remainingContributionIds).toEqual(['suggestion_2']);\n      expect(component.skippedContributionIds.length).toEqual(0);\n      expect(component.activeSuggestionId).toEqual('suggestion_1');\n      expect(component.refreshActiveContributionState).toHaveBeenCalled();\n    });\n\n    it(\n      'should close the modal if the opportunity is' +\n        ' deleted when navigating forward',\n      () => {\n        component.suggestionIdToContribution = cloneDeep(\n          suggestionIdToContribution\n        );\n        component.ngOnInit();\n        spyOn(activeModal, 'close');\n        component.allContributions.suggestion_2.details = null;\n\n        component.goToNextItem();\n\n        expect(activeModal.close).toHaveBeenCalledWith([]);\n      }\n    );\n\n    it(\n      'should close the modal if the opportunity is' +\n        ' deleted when navigating backward',\n      () => {\n        component.suggestionIdToContribution = cloneDeep(\n          suggestionIdToContribution\n        );\n        component.ngOnInit();\n        spyOn(activeModal, 'close');\n\n        component.goToNextItem();\n\n        expect(component.activeSuggestionId).toEqual('suggestion_2');\n        // Delete the opportunity of the previous item.\n        component.allContributions.suggestion_1.details = null;\n\n        component.goToPreviousItem();\n\n        expect(activeModal.close).toHaveBeenCalledWith([]);\n      }\n    );\n  });\n\n  describe('when set the schema constant', function () {\n    const reviewable = true;\n    const subheading = 'topic_1 / story_1 / chapter_1';\n    const suggestion1 = {\n      suggestion_id: 'suggestion_1',\n      target_id: '1',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p><p>&nbsp;</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content</p><p>&nbsp;</p>',\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n    const suggestion2 = {\n      suggestion_id: 'suggestion_2',\n      target_id: '2',\n      suggestion_type: 'translate_content',\n      change_cmd: {\n        content_id: 'hint_1',\n        content_html: '<p>content</p>',\n        translation_html: 'Tradução',\n        state_name: 'StateName',\n        cmd: 'edit_state_property',\n        data_format: 'html',\n        language_code: 'language_code',\n      },\n      exploration_content_html: '<p>content CHANGED</p>',\n      status: 'rejected',\n      author_name: 'author_name',\n      language_code: 'language_code',\n      last_updated_msecs: 1559074000000,\n      target_type: 'target_type',\n    };\n\n    const contribution1 = {\n      suggestion: suggestion1,\n      details: {\n        topic_name: 'topic_1',\n        story_title: 'story_1',\n        chapter_title: 'chapter_1',\n      },\n    };\n    const contribution2 = {\n      suggestion: suggestion2,\n      details: {\n        topic_name: 'topic_2',\n        story_title: 'story_2',\n        chapter_title: 'chapter_2',\n      },\n    };\n\n    const suggestionIdToContribution = {\n      suggestion_1: contribution1,\n      suggestion_2: contribution2,\n    };\n\n    const editedContent = {\n      html: '<p>In Hindi</p>',\n    };\n\n    beforeEach(fakeAsync(() => {\n      component.initialSuggestionId = 'suggestion_2';\n      component.subheading = subheading;\n      component.reviewable = reviewable;\n      component.suggestionIdToContribution = cloneDeep(\n        suggestionIdToContribution\n      );\n      component.editedContent = editedContent;\n      component.ngOnInit();\n      tick();\n    }));\n\n    it('should get html schema', () => {\n      expect(component.getHtmlSchema()).toEqual({\n        type: 'html',\n      });\n    });\n\n    it('should get unicode schema', () => {\n      expect(component.getUnicodeSchema()).toEqual({\n        type: 'unicode',\n      });\n    });\n\n    it('should get set of strings schema', () => {\n      expect(component.getSetOfStringsSchema()).toEqual({\n        type: 'list',\n        items: {\n          type: 'unicode',\n        },\n      });\n    });\n\n    it('should invoke change detection when html is updated', () => {\n      component.editedContent.html = 'old';\n      spyOn(changeDetectorRef, 'detectChanges').and.callThrough();\n      component.updateHtml('new');\n      expect(component.editedContent.html).toEqual('new');\n    });\n\n    it('should not invoke change detection when html is not updated', () => {\n      component.editedContent.html = 'old';\n      spyOn(changeDetectorRef, 'detectChanges').and.callThrough();\n      component.updateHtml('old');\n      expect(component.editedContent.html).toEqual('old');\n      expect(changeDetectorRef.detectChanges).toHaveBeenCalledTimes(0);\n    });\n\n    it('should check if the change cmd is deprecated', () => {\n      const deprecatedCmd = 'add_translation';\n      const validCmd = 'add_written_translation';\n\n      component.activeSuggestion.change_cmd.cmd = validCmd;\n      expect(component.isDeprecatedTranslationSuggestionCommand()).toBeFalse();\n\n      component.activeSuggestion.change_cmd.cmd = deprecatedCmd;\n      expect(component.isDeprecatedTranslationSuggestionCommand()).toBeTrue();\n    });\n\n    it('should check if translation contains HTML tags', () => {\n      const translationWithTags = '<p>translation with tags</p>';\n      const translationWithoutTags = 'translation without tags';\n\n      component.translationHtml = translationWithTags;\n      expect(component.doesTranslationContainTags()).toBeTrue();\n\n      component.translationHtml = translationWithoutTags;\n      expect(component.doesTranslationContainTags()).toBeFalse();\n    });\n  });\n\n  it('should extract html related to images', () => {\n    const content =\n      '<oppia-noninteractive-image src=\"image1.jpg\">' +\n      'something</oppia-noninteractive-image>' +\n      '<another-tag value=\"a\"></another-tag>' +\n      '<oppia-noninteractive-image src=\"image2.jpg\"></oppia-noninteractive-image>';\n    const expectedHtmlString =\n      '<oppia-noninteractive-image src=\"image1.jpg\">' +\n      'something</oppia-noninteractive-image>' +\n      '<oppia-noninteractive-image src=\"image2.jpg\"></oppia-noninteractive-image>';\n\n    const result = component.getImageInfoForSuggestion(content);\n\n    expect(result).toEqual(expectedHtmlString);\n  });\n\n  describe('Translation Suggestion Review Modal - Component Validation', () => {\n    const htmlWithComponents = `\n    <p>Content with components</p>\n    <oppia-noninteractive-image\n      alt-with-value=\"&amp;quot;Image description&amp;quot;\"\n      caption-with-value=\"&amp;quot;Image caption&amp;quot;\"\n      filepath-with-value=\"&amp;quot;img_20241109_030945_oc195e5356_height_350_width_450.svg&amp;quot;\">\n    </oppia-noninteractive-image>\n    <oppia-noninteractive-math \n      math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{x}{y}\\u0026amp;quot;,\\u0026amp;quot;svg_filename\\u0026amp;quot;:\\u0026amp;quot;mathImg_20250126_225215_x5vy0sjj6v_height_3d205_width_1d784_vertical_1d306.svg\\u0026amp;quot;}\">\n    </oppia-noninteractive-math>\n    <oppia-noninteractive-skillreview \n      skill_id-with-value=\"&amp;quot;wfLsQD3CTfrI&amp;quot;\" \n      text-with-value=\"&amp;quot;concept card&amp;quot;\">\n    </oppia-noninteractive-skillreview>\n  `;\n    const htmlWithoutComponents = '<p>Content without components</p>';\n    const htmlWithMultipleComponents = `\n  <p>Content with multiple components</p>\n  <oppia-noninteractive-image\n    alt-with-value=\"&amp;quot;Image 1&amp;quot;\"\n    caption-with-value=\"&amp;quot;Image 1 caption&amp;quot;\"\n    filepath-with-value=\"&amp;quot;img1.svg&amp;quot;\">\n  </oppia-noninteractive-image>\n  <oppia-noninteractive-image\n    alt-with-value=\"&amp;quot;Image 2&amp;quot;\"\n    caption-with-value=\"&amp;quot;Image 2 caption&amp;quot;\"\n    filepath-with-value=\"&amp;quot;img2.svg&amp;quot;\">\n  </oppia-noninteractive-image>\n  <oppia-noninteractive-math \n    math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{x}{y}\\u0026amp;quot;}\">\n  </oppia-noninteractive-math>\n  <oppia-noninteractive-math \n    math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{a}{b}\\u0026amp;quot;}\">\n  </oppia-noninteractive-math>\n  <oppia-noninteractive-skillreview \n    skill_id-with-value=\"&amp;quot;skill1&amp;quot;\"\n    text-with-value=\"&amp;quot;concept card 1&amp;quot;\">\n  </oppia-noninteractive-skillreview>\n  <oppia-noninteractive-skillreview \n    skill_id-with-value=\"&amp;quot;skill2&amp;quot;\"\n    text-with-value=\"&amp;quot;concept card 2&amp;quot;\">\n  </oppia-noninteractive-skillreview>\n`;\n\n    beforeEach(() => {\n      component.initialSuggestionId = 'suggestion_1';\n      component.suggestionIdToContribution = {\n        suggestion_1: {\n          suggestion: {\n            author_name: 'author_name',\n            language_code: 'language_code',\n            last_updated_msecs: 1559074000000,\n            status: 'status',\n            suggestion_id: 'suggestion_1',\n            target_id: '1',\n            target_type: 'target_type',\n            suggestion_type: 'translate_content',\n            change_cmd: {\n              content_id: 'hint_1',\n              content_html: htmlWithComponents,\n              translation_html: htmlWithComponents,\n              state_name: 'StateName',\n              cmd: 'edit_state_property',\n              data_format: 'html',\n              language_code: 'language_code',\n            },\n            exploration_content_html: '<p>content</p>',\n          },\n          details: {\n            topic_name: 'topic_1',\n            story_title: 'story_1',\n            chapter_title: 'chapter_1',\n          },\n        },\n        suggestion_2: {\n          suggestion: {\n            author_name: 'author_name',\n            language_code: 'language_code',\n            last_updated_msecs: 1559074000000,\n            status: 'status',\n            suggestion_id: 'suggestion_2',\n            target_id: '2',\n            target_type: 'target_type',\n            suggestion_type: 'translate_content',\n            change_cmd: {\n              content_id: 'hint_2',\n              content_html: htmlWithoutComponents,\n              translation_html: htmlWithoutComponents,\n              state_name: 'StateName',\n              cmd: 'edit_state_property',\n              data_format: 'html',\n              language_code: 'language_code',\n            },\n            exploration_content_html: '<p>content</p>',\n          },\n          details: {\n            topic_name: 'topic_2',\n            story_title: 'story_2',\n            chapter_title: 'chapter_2',\n          },\n        },\n        suggestion_3: {\n          suggestion: {\n            author_name: 'author_name',\n            language_code: 'language_code',\n            last_updated_msecs: 1559074000000,\n            status: 'status',\n            suggestion_id: 'suggestion_3',\n            target_id: '3',\n            target_type: 'target_type',\n            suggestion_type: 'translate_content',\n            change_cmd: {\n              content_id: 'hint_3',\n              content_html: htmlWithMultipleComponents,\n              translation_html: htmlWithMultipleComponents,\n              state_name: 'StateName',\n              cmd: 'edit_state_property',\n              data_format: 'html',\n              language_code: 'language_code',\n            },\n            exploration_content_html: '<p>content</p>',\n          },\n          details: {\n            topic_name: 'topic_3',\n            story_title: 'story_3',\n            chapter_title: 'chapter_3',\n          },\n        },\n      };\n    });\n\n    it('should initialize validation state correctly from original content', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(component.suggestionIdToContribution.suggestion_1).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion\n      ).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n      ).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.ngOnInit();\n\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      expect(component.translationHtml).toBe(htmlWithComponents);\n    });\n\n    it('should detect component mismatch when removing components', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.ngOnInit();\n\n      component.editedContent = {html: htmlWithoutComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithoutComponents);\n\n      expect(component.areComponentsMismatched()).toBeTrue();\n      expect(component.incompleteTranslationErrorIsShown).toBeTrue();\n    });\n\n    it('should detect component mismatch when adding components', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n\n      component.initialSuggestionId = 'suggestion_2';\n      expect(\n        component.suggestionIdToContribution.suggestion_2.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithoutComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.ngOnInit();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.editedContent = {html: htmlWithComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithComponents);\n\n      expect(component.areComponentsMismatched()).toBeTrue();\n      expect(component.incompleteTranslationErrorIsShown).toBeTrue();\n    });\n\n    it('should detect no mismatch when components match', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.ngOnInit();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.editedContent = {html: htmlWithComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithComponents);\n\n      expect(component.areComponentsMismatched()).toBeFalse();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n    });\n\n    it('should handle multiple components correctly', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n\n      component.initialSuggestionId = 'suggestion_3';\n      expect(\n        component.suggestionIdToContribution.suggestion_3.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithMultipleComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.ngOnInit();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.editedContent = {html: htmlWithMultipleComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithMultipleComponents);\n\n      expect(component.areComponentsMismatched()).toBeFalse();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n    });\n\n    it('should disable update button when components mismatch', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n      expect(component.startedEditing).toBeFalse();\n\n      component.ngOnInit();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.startedEditing = true;\n      expect(component.startedEditing).toBeTrue();\n\n      component.editedContent = {html: htmlWithoutComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithoutComponents);\n\n      expect(component.updateIsDisabled).toBeTrue();\n      expect(component.incompleteTranslationErrorIsShown).toBeTrue();\n    });\n\n    it('should handle successful update when components match', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n      expect(component.errorFound).toBeFalse();\n\n      const updateSpy = spyOn(\n        contributionAndReviewService,\n        'updateTranslationSuggestionAsync'\n      );\n      expect(updateSpy).not.toHaveBeenCalled();\n\n      component.ngOnInit();\n      expect(component.incompleteTranslationErrorIsShown).toBeFalse();\n\n      component.editedContent = {html: htmlWithComponents};\n      expect(component.editedContent).toBeDefined();\n      expect(component.editedContent.html).toBe(htmlWithComponents);\n\n      component.updateSuggestion();\n      expect(component.errorFound).toBeFalse();\n      expect(updateSpy).toHaveBeenCalledWith(\n        component.initialSuggestionId,\n        htmlWithComponents,\n        jasmine.any(Function),\n        jasmine.any(Function)\n      );\n    });\n\n    it('should show error message when attempting update with mismatched components', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n      expect(\n        component.suggestionIdToContribution.suggestion_1.suggestion.change_cmd\n          .content_html\n      ).toBe(htmlWithComponents);\n\n      component.translationHtml = htmlWithComponents;\n      component.ngOnInit();\n\n      component.editedContent = {html: htmlWithoutComponents};\n      component.updateSuggestion();\n\n      expect(component.errorMessage).toBe(\n        'Please ensure all components (images, math formulas, concept cards, videos) in your translation match the original content.'\n      );\n      expect(component.errorFound).toBeTrue();\n    });\n\n    it('should clear error when no component mismatch', () => {\n      component.errorMessage = 'Some error';\n      component.errorFound = true;\n      component.incompleteTranslationErrorIsShown = false;\n\n      component.activeSuggestion = {\n        author_name: 'author_name',\n        change_cmd: {\n          cmd: 'edit_state_property',\n          content_html: htmlWithComponents,\n          content_id: 'content_1',\n          data_format: 'html',\n          language_code: 'en',\n          state_name: 'Introduction',\n          translation_html: htmlWithComponents,\n        },\n        exploration_content_html: '<p>content</p>',\n        language_code: 'en',\n        last_updated_msecs: 1559074000000,\n        status: 'review',\n        suggestion_id: 'suggestion_1',\n        suggestion_type: 'translate_content',\n        target_id: '1',\n        target_type: 'exploration',\n      };\n\n      component.editedContent = {html: htmlWithComponents};\n\n      component.ngOnChanges({\n        editedContent: {\n          currentValue: {html: htmlWithComponents},\n          previousValue: undefined,\n          firstChange: true,\n          isFirstChange: () => true,\n        },\n      });\n\n      expect(component.errorMessage).toBe('');\n      expect(component.errorFound).toBeFalse();\n    });\n\n    it('should keep error when component mismatch exists', () => {\n      component.errorMessage = 'Some error';\n      component.errorFound = true;\n      component.incompleteTranslationErrorIsShown = true;\n\n      component.activeSuggestion = {\n        author_name: 'author_name',\n        change_cmd: {\n          cmd: 'edit_state_property',\n          content_html: htmlWithComponents,\n          content_id: 'content_1',\n          data_format: 'html',\n          language_code: 'en',\n          state_name: 'Introduction',\n          translation_html: htmlWithComponents,\n        },\n        exploration_content_html: '<p>content</p>',\n        language_code: 'en',\n        last_updated_msecs: 1559074000000,\n        status: 'review',\n        suggestion_id: 'suggestion_1',\n        suggestion_type: 'translate_content',\n        target_id: '1',\n        target_type: 'exploration',\n      };\n\n      component.editedContent = {html: htmlWithoutComponents};\n\n      component.ngOnChanges({\n        editedContent: {\n          currentValue: {html: htmlWithoutComponents},\n          previousValue: undefined,\n          firstChange: true,\n          isFirstChange: () => true,\n        },\n      });\n\n      expect(component.errorMessage).toBe('Some error');\n      expect(component.errorFound).toBeTrue();\n    });\n\n    it('should not process when editedContent is null', () => {\n      component.errorMessage = 'Some error';\n      component.errorFound = true;\n      component.editedContent = {html: ''};\n\n      component.activeSuggestion = {\n        author_name: 'author_name',\n        change_cmd: {\n          cmd: 'edit_state_property',\n          content_html: htmlWithComponents,\n          content_id: 'content_1',\n          data_format: 'html',\n          language_code: 'en',\n          state_name: 'Introduction',\n          translation_html: htmlWithComponents,\n        },\n        exploration_content_html: '<p>content</p>',\n        language_code: 'en',\n        last_updated_msecs: 1559074000000,\n        status: 'review',\n        suggestion_id: 'suggestion_1',\n        suggestion_type: 'translate_content',\n        target_id: '1',\n        target_type: 'exploration',\n      };\n\n      component.ngOnChanges({\n        editedContent: {\n          currentValue: null,\n          previousValue: {html: htmlWithComponents},\n          firstChange: false,\n          isFirstChange: () => false,\n        },\n      });\n\n      expect(component.errorMessage).toBe('Some error');\n      expect(component.errorFound).toBeTrue();\n    });\n\n    it('should not update when an image is replaced with a math formula', () => {\n      expect(component.initialSuggestionId).toBeDefined();\n      expect(component.suggestionIdToContribution).toBeDefined();\n\n      component.translationHtml = `\n        <p>Content with components</p>\n        <oppia-noninteractive-image\n          alt-with-value=\"&amp;quot;Image description&amp;quot;\"\n          caption-with-value=\"&amp;quot;Image caption&amp;quot;\"\n          filepath-with-value=\"&amp;quot;img_20241109_030945_oc195e5356_height_350_width_450.svg&amp;quot;\">\n        </oppia-noninteractive-image>\n      `;\n      component.ngOnInit();\n      const updatedHtml = `\n        <p>Content with components</p>\n        <oppia-noninteractive-math\n          math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{x}{y}\\u0026amp;quot;,\\u0026amp;quot;svg_filename\\u0026amp;quot;:\\u0026amp;quot;mathImg_20250126_225215_x5vy0sjj6v_height_3d205_width_1d784_vertical_1d306.svg\\u0026amp;quot;}\">\n        </oppia-noninteractive-math>\n      `;\n      component.editedContent = {\n        html: updatedHtml,\n      };\n\n      component.updateSuggestion();\n\n      expect(component.errorMessage).toBe(\n        'Please ensure all components (images, math formulas, concept cards, videos) in your translation match the original content.'\n      );\n      expect(component.errorFound).toBeTrue();\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/translation-suggestion-review-modal.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for translation suggestion review modal.\n */\n\nimport {\n  Component,\n  OnInit,\n  ChangeDetectorRef,\n  ViewChild,\n  ElementRef,\n  Input,\n  SimpleChanges,\n} from '@angular/core';\nimport {NgbActiveModal} from '@ng-bootstrap/ng-bootstrap';\nimport {AlertsService} from 'services/alerts.service';\nimport {ContextService} from 'services/context.service';\nimport {ContributionAndReviewService} from '../services/contribution-and-review.service';\nimport {ContributionOpportunitiesService} from '../services/contribution-opportunities.service';\nimport {LanguageUtilService} from 'domain/utilities/language-util.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {ThreadDataBackendApiService} from 'pages/exploration-editor-page/feedback-tab/services/thread-data-backend-api.service';\nimport {UserService} from 'services/user.service';\nimport {TranslationValidationService} from 'services/translation-validation.service';\nimport {ValidatorsService} from 'services/validators.service';\nimport {ThreadMessage} from 'domain/feedback_message/ThreadMessage.model';\nimport {AppConstants} from 'app.constants';\nimport {ListSchema, UnicodeSchema} from 'services/schema-default-value.service';\nimport {UserContributionRightsDataBackendDict} from 'services/user-backend-api.service';\n// This throws \"TS2307\". We need to\n// suppress this error because rte-output-display is not strictly typed yet.\n// @ts-ignore\nimport {RteOutputDisplayComponent} from 'rich_text_components/rte-output-display.component';\nimport {UndoSnackbarComponent} from 'components/custom-snackbar/undo-snackbar.component';\nimport {MatSnackBar, MatSnackBarRef} from '@angular/material/snack-bar';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\n\ninterface HTMLSchema {\n  type: string;\n}\n\ninterface EditedContentDict {\n  html: string;\n}\n\ninterface ActiveContributionDetailsDict {\n  chapter_title: string;\n  story_title: string;\n  topic_name: string;\n}\n\nexport interface SuggestionChangeDict {\n  cmd: string;\n  content_html: string | string[];\n  content_id: string;\n  data_format: string;\n  language_code: string;\n  state_name: string;\n  translation_html: string;\n}\n\nexport interface ActiveSuggestionDict {\n  author_name: string;\n  change_cmd: SuggestionChangeDict;\n  exploration_content_html: string | string[] | null;\n  language_code: string;\n  last_updated_msecs: number;\n  status: string;\n  suggestion_id: string;\n  suggestion_type: string;\n  target_id: string;\n  target_type: string;\n}\n\n// Details are null if suggestion's corresponding opportunity is deleted.\n// See issue #14234.\nexport interface ActiveContributionDict {\n  details: ActiveContributionDetailsDict | null;\n  suggestion: ActiveSuggestionDict;\n}\n\ninterface PendingSuggestionDict {\n  target_id: string;\n  suggestion_id: string;\n  action_status: string;\n  reviewer_message: string;\n  commit_message?: string;\n}\n\nenum ExpansionTabType {\n  CONTENT,\n  TRANSLATION,\n}\n\nconst COMMIT_TIMEOUT_DURATION = 30000; // 30 seconds in milliseconds.\n\n@Component({\n  selector: 'oppia-translation-suggestion-review-modal',\n  templateUrl: './translation-suggestion-review-modal.component.html',\n})\nexport class TranslationSuggestionReviewModalComponent implements OnInit {\n  // These properties are initialized using Angular lifecycle hooks\n  // and we need to do non-null assertion. For more information, see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  activeContribution!: ActiveContributionDict;\n  authorName!: string;\n  activeSuggestion!: ActiveSuggestionDict;\n  activeSuggestionId!: string;\n  contentHtml!: string | string[];\n  editedContent!: EditedContentDict;\n  errorMessage!: string;\n  explorationContentHtml!: string | string[] | null;\n  finalCommitMessage!: string;\n  initialSuggestionId!: string;\n  languageCode!: string;\n  languageDescription!: string;\n  preEditTranslationHtml!: string;\n  remainingContributionIds!: string[];\n  skippedContributionIds: string[] = [];\n  allContributions!: Record<string, ActiveContributionDict>;\n  isLastItem!: boolean;\n  isFirstItem: boolean = true;\n  reviewMessage!: string;\n  reviewer!: string;\n  status!: string;\n  heading: string = 'Your Translation Contributions';\n  subheading!: string;\n  suggestionIdToContribution!: Record<string, ActiveContributionDict>;\n  translationHtml!: string;\n  userCanReviewTranslationSuggestionsInLanguages!: string[];\n  username!: string;\n  resolvedSuggestionIds: string[] = [];\n  errorFound: boolean = false;\n  contentTypeIsHtml: boolean = false;\n  contentTypeIsSetOfStrings: boolean = false;\n  contentTypeIsUnicode: boolean = false;\n  lastSuggestionToReview: boolean = false;\n  firstSuggestionToReview: boolean = true;\n  resolvingSuggestion: boolean = false;\n  reviewable: boolean = false;\n  canEditTranslation: boolean = false;\n  userIsCurriculumAdmin: boolean = false;\n  isContentExpanded: boolean = false;\n  isContentOverflowing: boolean = false;\n  isTranslationExpanded: boolean = false;\n  isTranslationOverflowing: boolean = false;\n  explorationImagesString: string = '';\n  suggestionImagesString: string = '';\n  queuedSuggestion?: PendingSuggestionDict;\n  commitTimeout?: NodeJS.Timeout;\n  removedSuggestion?: ActiveContributionDict;\n  hasQueuedSuggestion: boolean = false;\n  currentSnackbarRef?: MatSnackBarRef<UndoSnackbarComponent>;\n  isUndoFeatureEnabled: boolean = false;\n  incompleteTranslationErrorIsShown: boolean = false;\n\n  @Input() altTextIsDisplayed: boolean = false;\n\n  @ViewChild('contentPanel')\n  contentPanel!: RteOutputDisplayComponent;\n\n  @ViewChild('translationPanel')\n  translationPanel!: RteOutputDisplayComponent;\n\n  @ViewChild('contentContainer')\n  contentContainer!: ElementRef;\n\n  @ViewChild('translationContainer')\n  translationContainer!: ElementRef;\n\n  @ViewChild('contentPanelWithAltText')\n  contentPanelWithAltText!: RteOutputDisplayComponent;\n\n  HTML_SCHEMA: HTMLSchema = {type: 'html'};\n  MAX_REVIEW_MESSAGE_LENGTH = AppConstants.MAX_REVIEW_MESSAGE_LENGTH;\n  SET_OF_STRINGS_SCHEMA: ListSchema = {\n    type: 'list',\n    items: {\n      type: 'unicode',\n    },\n  };\n\n  startedEditing: boolean = false;\n  translationUpdated: boolean = false;\n  UNICODE_SCHEMA: UnicodeSchema = {type: 'unicode'};\n\n  constructor(\n    private readonly changeDetectorRef: ChangeDetectorRef,\n    public activeModal: NgbActiveModal,\n    private alertsService: AlertsService,\n    private contextService: ContextService,\n    private contributionAndReviewService: ContributionAndReviewService,\n    private contributionOpportunitiesService: ContributionOpportunitiesService,\n    private languageUtilService: LanguageUtilService,\n    private siteAnalyticsService: SiteAnalyticsService,\n    private threadDataBackendApiService: ThreadDataBackendApiService,\n    private userService: UserService,\n    private validatorsService: ValidatorsService,\n    private snackBar: MatSnackBar,\n    private platformFeatureService: PlatformFeatureService,\n    private translationValidationService: TranslationValidationService\n  ) {}\n\n  ngOnInit(): void {\n    this.isUndoFeatureEnabled =\n      this.platformFeatureService.status.CdAllowUndoingTranslationReview.isEnabled;\n    this.activeSuggestionId = this.initialSuggestionId;\n    this.activeContribution =\n      this.suggestionIdToContribution[this.activeSuggestionId];\n    this.activeSuggestion = this.activeContribution.suggestion;\n    this.authorName = this.activeSuggestion.author_name;\n    this.languageDescription =\n      this.languageUtilService.getAudioLanguageDescription(\n        this.activeSuggestion.language_code\n      );\n    this.status = this.activeSuggestion.status;\n    if (this.reviewable) {\n      this.siteAnalyticsService.registerContributorDashboardViewSuggestionForReview(\n        'Translation'\n      );\n      this.heading = 'Review Translation Contributions';\n    }\n    const suggestionIds = Object.keys(this.suggestionIdToContribution);\n    const clickedSuggestionIndex = suggestionIds.indexOf(\n      this.activeSuggestionId\n    );\n    this.skippedContributionIds = suggestionIds.slice(\n      0,\n      clickedSuggestionIndex\n    );\n    delete this.suggestionIdToContribution[this.initialSuggestionId];\n    this.remainingContributionIds = suggestionIds.slice(\n      clickedSuggestionIndex + 1,\n      suggestionIds.length\n    );\n    this.remainingContributionIds.reverse();\n    this.isLastItem = this.remainingContributionIds.length === 0;\n    this.allContributions = this.suggestionIdToContribution;\n    this.allContributions[this.activeSuggestionId] = this.activeContribution;\n    this.refreshActiveContributionState();\n    const translationError =\n      this.translationValidationService.validateTranslationFromHtmlStrings(\n        this.activeSuggestion.change_cmd.content_html as string,\n        this.translationHtml\n      );\n    this.incompleteTranslationErrorIsShown =\n      translationError.hasUntranslatedElements;\n\n    // The 'html' value is passed as an object as it is required for\n    // schema-based-editor. Otherwise the corrrectly updated value for\n    // the translation is not received from the editor when the translation\n    // is edited by the reviewer.\n    this.editedContent = {\n      html: this.translationHtml,\n    };\n  }\n\n  refreshActiveContributionState(): void {\n    this.activeContribution = this.allContributions[this.activeSuggestionId];\n\n    // Close modal instance if the suggestion's corresponding opportunity\n    // is deleted. See issue #14234.\n    if (this.activeContribution.details === null) {\n      this.activeModal.close(this.resolvedSuggestionIds);\n      return;\n    }\n    this.activeSuggestion = this.activeContribution.suggestion;\n    this.contextService.setCustomEntityContext(\n      AppConstants.IMAGE_CONTEXT.EXPLORATION_SUGGESTIONS,\n      this.activeSuggestion.target_id\n    );\n    this.subheading =\n      `${this.activeContribution.details.topic_name} / ` +\n      `${this.activeContribution.details.story_title} / ` +\n      `${this.activeContribution.details.chapter_title}`;\n\n    this.isLastItem = this.remainingContributionIds.length === 0;\n    this.isFirstItem = this.skippedContributionIds.length === 0;\n    this.userCanReviewTranslationSuggestionsInLanguages = [];\n    this.languageCode = this.activeSuggestion.change_cmd.language_code;\n    this.userService.getUserInfoAsync().then(userInfo => {\n      const username = userInfo.getUsername();\n\n      if (username === null) {\n        throw new Error('Cannot fetch username.');\n      }\n      this.username = username;\n      this.userIsCurriculumAdmin = userInfo.isCurriculumAdmin();\n    });\n    this.userService\n      .getUserContributionRightsDataAsync()\n      .then(userContributionRights => {\n        let userContributionRightsData =\n          userContributionRights as UserContributionRightsDataBackendDict;\n        this.userCanReviewTranslationSuggestionsInLanguages =\n          userContributionRightsData.can_review_translation_for_language_codes;\n        this.canEditTranslation =\n          this.userCanReviewTranslationSuggestionsInLanguages.includes(\n            this.languageCode\n          ) && this.username !== this.activeSuggestion.author_name;\n      });\n    this.isContentExpanded = false;\n    this.isTranslationExpanded = false;\n    this.errorMessage = '';\n    this.errorFound = false;\n    this.startedEditing = false;\n    this.resolvingSuggestion = false;\n    this.lastSuggestionToReview =\n      Object.keys(this.allContributions).length <= 1;\n    this.translationHtml = this.activeSuggestion.change_cmd.translation_html;\n    this.status = this.activeSuggestion.status;\n    this.contentHtml = this.activeSuggestion.change_cmd.content_html;\n    this.explorationContentHtml =\n      this.activeSuggestion.exploration_content_html;\n    this.contentTypeIsHtml =\n      this.activeSuggestion.change_cmd.data_format === 'html';\n    this.contentTypeIsUnicode =\n      this.activeSuggestion.change_cmd.data_format === 'unicode';\n    this.contentTypeIsSetOfStrings =\n      this.activeSuggestion.change_cmd.data_format ===\n        'set_of_normalized_string' ||\n      this.activeSuggestion.change_cmd.data_format === 'set_of_unicode_string';\n    this.reviewMessage = '';\n    if (!this.reviewable) {\n      this._getThreadMessagesAsync(this.activeSuggestionId).then(() => {\n        // No review message and no exploration content means the suggestion\n        // became obsolete and was auto-rejected in a batch job. See issue\n        // #16022.\n        if (!this.reviewMessage && !this.explorationContentHtml) {\n          this.reviewMessage =\n            AppConstants.OBSOLETE_TRANSLATION_SUGGESTION_REVIEW_MSG;\n        }\n      });\n    }\n    this.explorationImagesString = this.getImageInfoForSuggestion(\n      this.contentHtml\n    );\n    this.suggestionImagesString = this.getImageInfoForSuggestion(\n      this.translationHtml\n    );\n    setTimeout(() => {\n      this.computePanelOverflowState();\n    }, 0);\n  }\n\n  computePanelOverflowState(): void {\n    setTimeout(() => {\n      this.isContentOverflowing =\n        this.contentPanel.elementRef.nativeElement.offsetHeight >\n        this.contentContainer.nativeElement.offsetHeight;\n      this.isTranslationOverflowing =\n        this.translationPanel.elementRef.nativeElement.offsetHeight >\n        this.translationContainer.nativeElement.offsetHeight;\n    }, 0);\n  }\n\n  ngAfterViewInit(): void {\n    this.computePanelOverflowState();\n  }\n\n  toggleExpansionState(tab: ExpansionTabType): void {\n    if (tab === ExpansionTabType.CONTENT) {\n      this.isContentExpanded = !this.isContentExpanded;\n    } else if (tab === ExpansionTabType.TRANSLATION) {\n      this.isTranslationExpanded = !this.isTranslationExpanded;\n    }\n  }\n\n  areComponentsMismatched(): boolean {\n    const translationError =\n      this.translationValidationService.validateTranslationFromHtmlStrings(\n        this.activeSuggestion.change_cmd.content_html as string,\n        this.editedContent.html\n      );\n\n    this.incompleteTranslationErrorIsShown =\n      translationError.hasUntranslatedElements;\n    return translationError.hasUntranslatedElements;\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.editedContent && this.editedContent) {\n      const componentsAreMismatched = this.areComponentsMismatched();\n\n      if (!componentsAreMismatched) {\n        this.errorMessage = '';\n        this.errorFound = false;\n      }\n    }\n  }\n\n  get updateIsDisabled(): boolean {\n    return this.startedEditing && this.areComponentsMismatched();\n  }\n\n  updateSuggestion(): void {\n    const updatedTranslation = this.editedContent.html;\n    const suggestionId = this.activeSuggestion.suggestion_id;\n\n    if (this.areComponentsMismatched()) {\n      this.errorMessage =\n        'Please ensure all components (images, math formulas, concept cards, videos) ' +\n        'in your translation match the original content.';\n      this.errorFound = true;\n      return;\n    }\n\n    this.preEditTranslationHtml = this.translationHtml;\n    this.translationHtml = updatedTranslation;\n    this.contributionAndReviewService.updateTranslationSuggestionAsync(\n      suggestionId,\n      updatedTranslation,\n      () => {\n        this.translationUpdated = true;\n        this.startedEditing = false;\n        this.contributionOpportunitiesService.reloadOpportunitiesEventEmitter.emit();\n      },\n      this.showTranslationSuggestionUpdateError\n    );\n    this.suggestionImagesString = this.getImageInfoForSuggestion(\n      this.translationHtml\n    );\n  }\n\n  // The length of the commit message should not exceed 375 characters,\n  // since this is the maximum allowed commit message size.\n  generateCommitMessage(): string {\n    const contentId = this.activeSuggestion.change_cmd.content_id;\n    const stateName = this.activeSuggestion.change_cmd.state_name;\n    const contentType = contentId.split('_')[0];\n    const commitMessage = `${contentType} section of \"${stateName}\" card`;\n\n    return commitMessage;\n  }\n\n  async _getThreadMessagesAsync(threadId: string): Promise<void> {\n    const response =\n      await this.threadDataBackendApiService.fetchMessagesAsync(threadId);\n    const threadMessageBackendDicts = response.messages;\n    let threadMessages = threadMessageBackendDicts.map(m =>\n      ThreadMessage.createFromBackendDict(m)\n    );\n    // This is to prevent a console error when a contribution\n    // doesn't have a review message. When a contribution has\n    // a review message the second element of the threadMessages\n    // array contains the actual review message.\n    if (threadMessages[1] !== undefined) {\n      this.reviewer = threadMessages[1].authorUsername;\n      this.reviewMessage = threadMessages[1].text;\n    }\n  }\n\n  goToNextItem(): void {\n    const lastContributionId = this.remainingContributionIds.pop();\n    // If the current item is the last item, do not navigate.\n    if (lastContributionId === undefined) {\n      return;\n    }\n    // Don't add resolved contributions to the skippedContributionIds beacuse\n    // we don't want to show resolved suggestions when navigating back.\n    if (!this.resolvedSuggestionIds.includes(this.activeSuggestionId)) {\n      this.skippedContributionIds.push(this.activeSuggestionId);\n    }\n\n    this.activeSuggestionId = lastContributionId;\n\n    this.refreshActiveContributionState();\n  }\n\n  goToPreviousItem(): void {\n    const lastContributionId = this.skippedContributionIds.pop();\n    // If the current item is the first item, do not navigate.\n    if (lastContributionId === undefined) {\n      return;\n    }\n    // Don't add resolved contributions to the remainingContributionIds beacuse\n    // we don't want to show resolved suggestions when navigating forward.\n    if (!this.resolvedSuggestionIds.includes(this.activeSuggestionId)) {\n      this.remainingContributionIds.push(this.activeSuggestionId);\n    }\n\n    this.activeSuggestionId = lastContributionId;\n\n    this.refreshActiveContributionState();\n  }\n\n  resolveSuggestionAndUpdateModal(): void {\n    if (this.isUndoFeatureEnabled) {\n      if (this.queuedSuggestion) {\n        this.resolvedSuggestionIds.push(this.queuedSuggestion.suggestion_id);\n\n        // Resolved contributions don't need to be displayed in the modal.\n        this.removedSuggestion =\n          this.allContributions[this.queuedSuggestion?.suggestion_id];\n        delete this.allContributions[this.queuedSuggestion?.suggestion_id];\n\n        // If the reviewed item was the last item, close the modal.\n        if (this.lastSuggestionToReview || this.isLastItem) {\n          this.commitQueuedSuggestion();\n          this.activeModal.close(this.resolvedSuggestionIds);\n          return;\n        }\n      }\n      this.goToNextItem();\n    } else {\n      this.resolvedSuggestionIds.push(this.activeSuggestionId);\n\n      // Resolved contributions don't need to be displayed in the modal.\n      delete this.allContributions[this.activeSuggestionId];\n\n      // If the reviewed item was the last item, close the modal.\n      if (this.lastSuggestionToReview || this.isLastItem) {\n        this.activeModal.close(this.resolvedSuggestionIds);\n        return;\n      }\n      this.goToNextItem();\n    }\n  }\n\n  acceptAndReviewNext(): void {\n    if (this.isUndoFeatureEnabled) {\n      this.finalCommitMessage = this.generateCommitMessage();\n      const reviewMessageForSubmitter =\n        this.reviewMessage +\n        (this.translationUpdated\n          ? (this.reviewMessage.length > 0 ? ': ' : '') +\n            '(Note: This suggestion was submitted with reviewer edits.)'\n          : '');\n      this.resolvingSuggestion = true;\n      this.siteAnalyticsService.registerContributorDashboardAcceptSuggestion(\n        'Translation'\n      );\n      this.queuedSuggestion = {\n        target_id: this.activeSuggestion.target_id,\n        suggestion_id: this.activeSuggestionId,\n        action_status: AppConstants.ACTION_ACCEPT_SUGGESTION,\n        reviewer_message: reviewMessageForSubmitter,\n        commit_message: this.finalCommitMessage,\n      };\n      this.hasQueuedSuggestion = true;\n      this.resolveSuggestionAndUpdateModal();\n      this.startCommitTimeout();\n      this.showSnackbar();\n    } else {\n      this.finalCommitMessage = this.generateCommitMessage();\n      const reviewMessageForSubmitter =\n        this.reviewMessage +\n        (this.translationUpdated\n          ? (this.reviewMessage.length > 0 ? ': ' : '') +\n            '(Note: This suggestion was submitted with reviewer edits.)'\n          : '');\n      this.resolvingSuggestion = true;\n      this.siteAnalyticsService.registerContributorDashboardAcceptSuggestion(\n        'Translation'\n      );\n\n      this.contributionAndReviewService.reviewExplorationSuggestion(\n        this.activeSuggestion.target_id,\n        this.activeSuggestionId,\n        AppConstants.ACTION_ACCEPT_SUGGESTION,\n        reviewMessageForSubmitter,\n        this.finalCommitMessage,\n        () => {\n          this.alertsService.clearMessages();\n          this.alertsService.addSuccessMessage('Suggestion accepted.');\n          this.resolveSuggestionAndUpdateModal();\n        },\n        errorMessage => {\n          this.alertsService.clearWarnings();\n          this.alertsService.addWarning(`Invalid Suggestion: ${errorMessage}`);\n        }\n      );\n    }\n  }\n\n  rejectAndReviewNext(reviewMessage: string): void {\n    if (this.isUndoFeatureEnabled) {\n      if (\n        this.validatorsService.isValidReviewMessage(\n          reviewMessage,\n          /* ShowWarnings= */ true\n        )\n      ) {\n        this.resolvingSuggestion = true;\n        this.siteAnalyticsService.registerContributorDashboardRejectSuggestion(\n          'Translation'\n        );\n        this.queuedSuggestion = {\n          target_id: this.activeSuggestion.target_id,\n          suggestion_id: this.activeSuggestionId,\n          action_status: AppConstants.ACTION_REJECT_SUGGESTION,\n          reviewer_message: reviewMessage || this.reviewMessage,\n        };\n        this.hasQueuedSuggestion = true;\n        this.resolveSuggestionAndUpdateModal();\n        this.startCommitTimeout();\n        this.showSnackbar();\n      }\n    } else {\n      if (\n        this.validatorsService.isValidReviewMessage(\n          reviewMessage,\n          /* ShowWarnings= */ true\n        )\n      ) {\n        this.resolvingSuggestion = true;\n        this.siteAnalyticsService.registerContributorDashboardRejectSuggestion(\n          'Translation'\n        );\n\n        // In case of rejection, the suggestion is not applied, so there is no\n        // commit message. Because there is no commit to make.\n        this.contributionAndReviewService.reviewExplorationSuggestion(\n          this.activeSuggestion.target_id,\n          this.activeSuggestionId,\n          AppConstants.ACTION_REJECT_SUGGESTION,\n          reviewMessage || this.reviewMessage,\n          null,\n          () => {\n            this.alertsService.clearMessages();\n            this.alertsService.addSuccessMessage('Suggestion rejected.');\n            this.resolveSuggestionAndUpdateModal();\n          },\n          errorMessage => {\n            this.alertsService.clearWarnings();\n            this.alertsService.addWarning(\n              `Invalid Suggestion: ${errorMessage}`\n            );\n          }\n        );\n      }\n    }\n  }\n\n  revertSuggestionResolution(): void {\n    // Remove the suggestion ID from resolvedSuggestionIds.\n    if (this.queuedSuggestion && this.removedSuggestion) {\n      const index = this.resolvedSuggestionIds.indexOf(\n        this.queuedSuggestion?.suggestion_id\n      );\n      if (index > -1) {\n        this.resolvedSuggestionIds.splice(index, 1);\n      }\n\n      // Add the removed suggestion back to allContributions.\n      this.allContributions[this.queuedSuggestion?.suggestion_id] =\n        this.removedSuggestion;\n    }\n  }\n\n  startCommitTimeout(): void {\n    clearTimeout(this.commitTimeout); // Clear existing timeout.\n\n    // Start a new timeout for commit after timeframe.\n    this.commitTimeout = setTimeout(() => {\n      this.commitQueuedSuggestion();\n    }, COMMIT_TIMEOUT_DURATION);\n  }\n\n  commitQueuedSuggestion(): void {\n    if (!this.queuedSuggestion) {\n      return;\n    }\n    this.contributionAndReviewService.reviewExplorationSuggestion(\n      this.queuedSuggestion.target_id,\n      this.queuedSuggestion.suggestion_id,\n      this.queuedSuggestion.action_status,\n      this.queuedSuggestion.reviewer_message,\n      this.queuedSuggestion.action_status === 'accept' &&\n        this.queuedSuggestion.commit_message\n        ? this.queuedSuggestion.commit_message\n        : null,\n      // Only include commit_message for accepted suggestions.\n      () => {\n        this.alertsService.clearMessages();\n        this.alertsService.addSuccessMessage(\n          `Suggestion ${\n            this.queuedSuggestion?.action_status === 'accept'\n              ? 'accepted'\n              : 'rejected'\n          }.`\n        );\n        this.clearQueuedSuggestion();\n      },\n      errorMessage => {\n        this.alertsService.clearWarnings();\n        this.alertsService.addWarning(`Invalid Suggestion: ${errorMessage}`);\n        this.revertSuggestionResolution();\n      }\n    );\n  }\n\n  clearQueuedSuggestion(): void {\n    this.queuedSuggestion = undefined;\n    this.hasQueuedSuggestion = false;\n  }\n\n  undoReviewAction(): void {\n    clearTimeout(this.commitTimeout); // Clear the commit timeout.\n    if (this.queuedSuggestion) {\n      const indexToRemove = this.resolvedSuggestionIds.indexOf(\n        this.queuedSuggestion.suggestion_id\n      );\n      if (indexToRemove !== -1) {\n        this.resolvedSuggestionIds.splice(indexToRemove, 1);\n        if (this.removedSuggestion) {\n          this.allContributions[this.queuedSuggestion.suggestion_id] =\n            this.removedSuggestion;\n        }\n      }\n    }\n    this.clearQueuedSuggestion();\n  }\n\n  showSnackbar(): void {\n    this.currentSnackbarRef =\n      this.snackBar.openFromComponent<UndoSnackbarComponent>(\n        UndoSnackbarComponent,\n        {\n          duration: COMMIT_TIMEOUT_DURATION,\n          verticalPosition: 'bottom',\n          horizontalPosition: 'right',\n        }\n      );\n    this.currentSnackbarRef.instance.message = 'Suggestion queued';\n\n    this.currentSnackbarRef.onAction().subscribe(() => {\n      this.undoReviewAction();\n    });\n\n    this.currentSnackbarRef.afterDismissed().subscribe(() => {\n      if (this.hasQueuedSuggestion) {\n        this.commitQueuedSuggestion();\n      }\n    });\n  }\n\n  // Returns whether the active suggestion's exploration_content_html\n  // differs from the content_html of the suggestion's change object.\n  hasExplorationContentChanged(): boolean {\n    return !this.isHtmlContentEqual(\n      this.contentHtml,\n      this.explorationContentHtml\n    );\n  }\n\n  isHtmlContentEqual(\n    first: string | string[] | null,\n    second: string | string[] | null\n  ): boolean {\n    if (Array.isArray(first) && Array.isArray(second)) {\n      // Check equality of all array elements.\n      return (\n        first.length === second.length &&\n        first.every(\n          (val, index) =>\n            this.stripWhitespace(val) === this.stripWhitespace(second[index])\n        )\n      );\n    }\n    if (angular.isString(first) && angular.isString(second)) {\n      return this.stripWhitespace(first) === this.stripWhitespace(second);\n    }\n    return false;\n  }\n\n  // Strips whitespace (spaces, tabs, line breaks) and '&nbsp;'.\n  stripWhitespace(htmlString: string): string {\n    return htmlString.replace(/&nbsp;|\\s+/g, '');\n  }\n\n  editSuggestion(): void {\n    this.startedEditing = true;\n    this.editedContent.html = this.translationHtml;\n  }\n\n  cancelEdit(): void {\n    this.errorMessage = '';\n    this.startedEditing = false;\n    this.errorFound = false;\n    this.editedContent.html = this.translationHtml;\n  }\n\n  cancel(): void {\n    this.commitQueuedSuggestion();\n    this.activeModal.close(this.resolvedSuggestionIds);\n  }\n\n  showTranslationSuggestionUpdateError(error: Error): void {\n    this.errorMessage = 'Invalid Suggestion: ' + error.message;\n    this.errorFound = true;\n    this.startedEditing = true;\n    this.translationHtml = this.preEditTranslationHtml;\n  }\n\n  isDeprecatedTranslationSuggestionCommand(): boolean {\n    return this.activeSuggestion.change_cmd.cmd === 'add_translation';\n  }\n\n  doesTranslationContainTags(): boolean {\n    return /<.*>/g.test(this.translationHtml);\n  }\n\n  getHtmlSchema(): HTMLSchema {\n    return this.HTML_SCHEMA;\n  }\n\n  getUnicodeSchema(): UnicodeSchema {\n    return this.UNICODE_SCHEMA;\n  }\n\n  getSetOfStringsSchema(): ListSchema {\n    return this.SET_OF_STRINGS_SCHEMA;\n  }\n\n  updateHtml(value: string): void {\n    if (value !== this.editedContent.html) {\n      this.editedContent.html = value;\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  /**\n   * Retrieves image information from the given content and\n   * returns it as a string.\n   * If the content is in the form of a string (not an array),\n   * it parses the content using a DOMParser and extracts the HTML\n   * for all 'oppia-noninteractive-image' elements. The extracted HTML\n   * is returned as a string.\n   * @param content The content containing image information (\n   * either a string or an array of strings).\n   * @returns A string representation of the extracted image information.\n   */\n  getImageInfoForSuggestion(content: string | string[]): string {\n    let htmlString = '';\n\n    // Images are present in form of strings not as Array of strings.\n    if (!Array.isArray(content)) {\n      this.altTextIsDisplayed = true;\n      const doc = new DOMParser().parseFromString(content, 'text/html');\n      const imgElements = doc.querySelectorAll('oppia-noninteractive-image');\n      htmlString = Array.from(imgElements)\n        .map(img => img.outerHTML)\n        .join('');\n    }\n\n    return htmlString;\n  }\n}\n"
    },
    {
      "filename": "core/templates/services/translation-validation.service.spec.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for TranslationValidationService.\n */\n\nimport {TestBed} from '@angular/core/testing';\nimport {TranslationValidationService} from './translation-validation.service';\n\ndescribe('TranslationValidationService', () => {\n  let translationValidationService: TranslationValidationService;\n\n  const htmlWithComponents = `\n    <p>Content with components</p>\n    <oppia-noninteractive-image\n      alt-with-value=\"&amp;quot;Image description&amp;quot;\"\n      caption-with-value=\"&amp;quot;Image caption&amp;quot;\"\n      filepath-with-value=\"&amp;quot;img_20241109_030945_oc195e5356_height_350_width_450.svg&amp;quot;\">\n    </oppia-noninteractive-image>\n    <oppia-noninteractive-math \n      math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{x}{y}\\u0026amp;quot;,\\u0026amp;quot;svg_filename\\u0026amp;quot;:\\u0026amp;quot;mathImg_20250126_225215_x5vy0sjj6v_height_3d205_width_1d784_vertical_1d306.svg\\u0026amp;quot;}\">\n    </oppia-noninteractive-math>\n    <oppia-noninteractive-skillreview \n      skill_id-with-value=\"&amp;quot;wfLsQD3CTfrI&amp;quot;\" \n      text-with-value=\"&amp;quot;concept card&amp;quot;\">\n    </oppia-noninteractive-skillreview>\n  `;\n  const htmlWithoutComponents = '<p>Content without components</p>';\n  const htmlWithMultipleComponents = `\n  <p>Content with multiple components</p>\n  <oppia-noninteractive-image\n    alt-with-value=\"&amp;quot;Image 1&amp;quot;\"\n    caption-with-value=\"&amp;quot;Image 1 caption&amp;quot;\"\n    filepath-with-value=\"&amp;quot;img1.svg&amp;quot;\">\n  </oppia-noninteractive-image>\n  <oppia-noninteractive-image\n    alt-with-value=\"&amp;quot;Image 2&amp;quot;\"\n    caption-with-value=\"&amp;quot;Image 2 caption&amp;quot;\"\n    filepath-with-value=\"&amp;quot;img2.svg&amp;quot;\">\n  </oppia-noninteractive-image>\n  <oppia-noninteractive-math \n    math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{x}{y}\\u0026amp;quot;}\">\n  </oppia-noninteractive-math>\n  <oppia-noninteractive-math \n    math_content-with-value=\"{\\u0026amp;quot;raw_latex\\u0026amp;quot;:\\u0026amp;quot;\\\\\\\\frac{a}{b}\\u0026amp;quot;}\">\n  </oppia-noninteractive-math>\n  <oppia-noninteractive-skillreview \n    skill_id-with-value=\"&amp;quot;skill1&amp;quot;\"\n    text-with-value=\"&amp;quot;concept card 1&amp;quot;\">\n  </oppia-noninteractive-skillreview>\n  <oppia-noninteractive-skillreview \n    skill_id-with-value=\"&amp;quot;skill2&amp;quot;\"\n    text-with-value=\"&amp;quot;concept card 2&amp;quot;\">\n  </oppia-noninteractive-skillreview>\n  `;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({});\n    translationValidationService = TestBed.inject(TranslationValidationService);\n  });\n\n  describe('getElementAttributeTexts', () => {\n    it('should extract image attributes correctly', () => {\n      const domParser = new DOMParser();\n      const elements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.getElementAttributeTexts(\n        elements,\n        'filepath-with-value'\n      );\n      expect(result.length).toBe(1);\n      expect(result[0]).toBe(\n        'img_20241109_030945_oc195e5356_height_350_width_450.svg'\n      );\n    });\n\n    it('should handle missing attributes', () => {\n      const domParser = new DOMParser();\n      const elements = domParser\n        .parseFromString(\n          '<oppia-noninteractive-image></oppia-noninteractive-image>',\n          'text/html'\n        )\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.getElementAttributeTexts(\n        elements,\n        'filepath-with-value'\n      );\n      expect(result.length).toBe(0);\n    });\n  });\n\n  describe('isTranslationCompleted', () => {\n    it('should return true for matching components', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      expect(\n        translationValidationService.isTranslationCompleted(\n          originalElements,\n          translatedElements\n        )\n      ).toBeTrue();\n    });\n\n    it('should return false for mismatched components', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithoutComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      expect(\n        translationValidationService.isTranslationCompleted(\n          originalElements,\n          translatedElements\n        )\n      ).toBeFalse();\n    });\n  });\n\n  describe('validateTranslation', () => {\n    it('should validate content with matching components', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.validateTranslation(\n        originalElements,\n        translatedElements\n      );\n      expect(result.hasUntranslatedElements).toBeFalse();\n      expect(result.hasDuplicateAltTexts).toBeTrue();\n      expect(result.hasDuplicateDescriptions).toBeTrue();\n    });\n\n    it('should detect missing components in translation', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithoutComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.validateTranslation(\n        originalElements,\n        translatedElements\n      );\n      expect(result.hasUntranslatedElements).toBeTrue();\n    });\n\n    it('should validate when original has no components', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithoutComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithoutComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.validateTranslation(\n        originalElements,\n        translatedElements\n      );\n      expect(result.hasUntranslatedElements).toBeFalse();\n      expect(result.hasDuplicateAltTexts).toBeFalse();\n      expect(result.hasDuplicateDescriptions).toBeFalse();\n    });\n\n    it('should validate multiple components correctly', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithMultipleComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithMultipleComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.validateTranslation(\n        originalElements,\n        translatedElements\n      );\n      expect(result.hasUntranslatedElements).toBeFalse();\n      expect(result.hasDuplicateAltTexts).toBeTrue();\n      expect(result.hasDuplicateDescriptions).toBeTrue();\n    });\n\n    it('should detect when translation adds extra components', () => {\n      const domParser = new DOMParser();\n      const originalElements = domParser\n        .parseFromString(htmlWithoutComponents, 'text/html')\n        .getElementsByTagName('*');\n      const translatedElements = domParser\n        .parseFromString(htmlWithComponents, 'text/html')\n        .getElementsByTagName('*');\n\n      const result = translationValidationService.validateTranslation(\n        originalElements,\n        translatedElements\n      );\n      expect(result.hasUntranslatedElements).toBeTrue();\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/services/translation-validation.service.ts",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for handling HTML parsing\n * operations focused on image tag detection and comparison.\n */\n\nimport isEqual from 'lodash/isEqual';\n\nimport {Injectable} from '@angular/core';\n\nexport interface ImageDetails {\n  filePaths: string[];\n  alts: string[];\n  descriptions: string[];\n}\n\nexport class TranslationError {\n  constructor(\n    private _hasDuplicateAltTexts: boolean,\n    private _hasDuplicateDescriptions: boolean,\n    private _hasUntranslatedElements: boolean\n  ) {}\n\n  get hasDuplicateDescriptions(): boolean {\n    return this._hasDuplicateDescriptions;\n  }\n\n  get hasDuplicateAltTexts(): boolean {\n    return this._hasDuplicateAltTexts;\n  }\n\n  get hasUntranslatedElements(): boolean {\n    return this._hasUntranslatedElements;\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class TranslationValidationService {\n  private readonly ALLOWED_CUSTOM_TAGS_IN_TRANSLATION_SUGGESTION = [\n    'oppia-noninteractive-image',\n    'oppia-noninteractive-link',\n    'oppia-noninteractive-math',\n    'oppia-noninteractive-skillreview',\n  ];\n\n  constructor() {}\n\n  getElementAttributeTexts(\n    elements: HTMLCollectionOf<Element>,\n    type: string\n  ): string[] {\n    const textWrapperLength = 6;\n    const attributes = Array.from(elements, function (element: Element) {\n      // A sample element would be as <oppia-noninteractive-image alt-with-value\n      // =\"&amp;quot;Image description&amp;quot;\" caption-with-value=\n      // \"&amp;quot;Image caption&amp;quot;\" filepath-with-value=\"&amp;quot;\n      // img_2021029_210552_zbmdt94_height_54_width_490.png&amp;quot;\">\n      // </oppia-noninteractive-image>\n      if (element.localName === 'oppia-noninteractive-image') {\n        const attribute = element.attributes[\n          type as keyof NamedNodeMap\n        ] as Attr;\n        if (!attribute) {\n          return null;\n        }\n        const attributeValue = attribute.value;\n        return attributeValue.substring(\n          textWrapperLength,\n          attributeValue.length - textWrapperLength\n        );\n      }\n    });\n    // Typecasted to string[] because Array.from() returns\n    // (string | undefined)[] and we need to remove the undefined elements.\n    return attributes.filter(attributeValues => attributeValues) as string[];\n  }\n\n  getImageAttributeTexts(\n    htmlElements: HTMLCollectionOf<Element>\n  ): ImageDetails {\n    return {\n      filePaths: this.getElementAttributeTexts(\n        htmlElements,\n        'filepath-with-value'\n      ),\n      alts: this.getElementAttributeTexts(htmlElements, 'alt-with-value'),\n      descriptions: this.getElementAttributeTexts(\n        htmlElements,\n        'caption-with-value'\n      ),\n    };\n  }\n\n  hasSomeDuplicateElements(\n    originalElements: string[],\n    translatedElements: string[]\n  ): boolean {\n    const mathEquationRegex = new RegExp(\n      /(?:(?:^|[-+_*/=])(?:\\s*-?\\d+(\\.\\d+)?(?:[eE][+-]?\\d+)?\\s*))+$/\n    );\n    if (originalElements.length === 0) {\n      return false;\n    }\n    const hasMatchingTranslatedElement = (element: string) =>\n      translatedElements.includes(element) &&\n      originalElements.length > 0 &&\n      !mathEquationRegex.test(element);\n    return originalElements.some(hasMatchingTranslatedElement);\n  }\n\n  validateTranslationFromHtmlStrings(\n    originalHtml: string,\n    translatedHtml: string\n  ): TranslationError {\n    const domParser = new DOMParser();\n    const originalElements = domParser.parseFromString(\n      originalHtml,\n      'text/html'\n    );\n    const translatedElements = domParser.parseFromString(\n      translatedHtml,\n      'text/html'\n    );\n\n    return this.validateTranslation(\n      originalElements.getElementsByTagName('*'),\n      translatedElements.getElementsByTagName('*')\n    );\n  }\n\n  isTranslationCompleted(\n    originalElements: HTMLCollectionOf<Element>,\n    translatedElements: HTMLCollectionOf<Element>\n  ): boolean {\n    // Checks if there are custom tags present in the original content but not\n    // in the translated content.\n    const filteredOriginalElements = Array.from(originalElements, el =>\n      el.tagName.toLowerCase()\n    )\n      .filter(tagName =>\n        this.ALLOWED_CUSTOM_TAGS_IN_TRANSLATION_SUGGESTION.includes(tagName)\n      )\n      .sort();\n    const filteredTranslatedElements = Array.from(translatedElements, el =>\n      el.tagName.toLowerCase()\n    )\n      .filter(tagName =>\n        this.ALLOWED_CUSTOM_TAGS_IN_TRANSLATION_SUGGESTION.includes(tagName)\n      )\n      .sort();\n    return isEqual(filteredOriginalElements, filteredTranslatedElements);\n  }\n\n  validateTranslation(\n    textToTranslate: HTMLCollectionOf<Element>,\n    translatedText: HTMLCollectionOf<Element>\n  ): TranslationError {\n    const translatedElements: ImageDetails =\n      this.getImageAttributeTexts(translatedText);\n    const originalElements: ImageDetails =\n      this.getImageAttributeTexts(textToTranslate);\n\n    const hasDuplicateAltTexts = this.hasSomeDuplicateElements(\n      originalElements.alts,\n      translatedElements.alts\n    );\n    const hasDuplicateDescriptions = this.hasSomeDuplicateElements(\n      originalElements.descriptions,\n      translatedElements.descriptions\n    );\n    const hasUntranslatedElements = !this.isTranslationCompleted(\n      textToTranslate,\n      translatedText\n    );\n\n    return new TranslationError(\n      hasDuplicateAltTexts,\n      hasDuplicateDescriptions,\n      hasUntranslatedElements\n    );\n  }\n}\n"
    }
  ]
}