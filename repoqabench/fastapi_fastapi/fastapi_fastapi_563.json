{
  "repo_name": "fastapi_fastapi",
  "issue_id": "563",
  "issue_description": "# pathlib.Path is not serializable\n\n**Describe the bug**\r\nIf the api response contains fields of type `pathlib.Path`, an error is raised:\r\n \r\n```bash\r\nValueError: [KeyError(<class 'pathlib.PosixPath'>,), TypeError(\"'PosixPath' object is not iterable\",), TypeError('vars() argument must have __dict__ attribute',)]\r\n```\r\n\r\n**To Reproduce**\r\nI wrote a test for this bug which fails with the above ^ error.\r\n\r\n```python\r\n#tests/test_serialize_path.py\r\n\r\nfrom pathlib import Path\r\n\r\nfrom pydantic import BaseModel\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```\r\n\r\n**Expected behavior**\r\nThe test should pass, which means a 200 response is returned and the response is:\r\n\r\n```json\r\n{\r\n    \"path\": \"/some/random/path\"\r\n}\r\n```\r\n\r\n**Environment:**\r\n - OS: Linux / Windows\r\n - FastAPI Version 0.38.1\r\n\r\n- Python version 3.6.9\r\n\r\n**Additional context**\r\n\r\n**Solution 1**\r\n\r\nA possible fix would be importing and using the encoder from `pydantic` which knows to encode `Path` objects:\r\n\r\n```python\r\n# pydantic/json.py\r\n\r\ndef pydantic_encoder(obj: Any) -> Any:\r\n    ......\r\n    elif isinstance(obj, Path):\r\n        return str(obj)\r\n    ......\r\n```\r\n\r\nThe Fastapi's `jsonable_encoder(....)` would be changed from this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import ENCODERS_BY_TYPE\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = ENCODERS_BY_TYPE[type(obj)]\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nto this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import pydantic_encoder\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = pydantic_encoder\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nThe test passes but `pydantic_encoder()` has a downside: the string obtained by `str(Path(...))` is not the same on Windows (eg: `\\some\\random\\path`) vs Linux (`/some/random/path`).\r\n\r\n** Solution 2 **\r\n\r\nAs I think it is very important that a Fastapi app return the same responses no matter the platform on which it's deployed, another solution is handling the `pathlib.Path` encoding directly in Fastapi's `jsonable_encoder()`, using `Path(...).as_posix()` instead of `str(Path(...))` like:\r\n\r\n```python\r\n# fastapi/encoders.py\r\n\r\ndef jsonable_encoder(.....) -> Any:\r\n    ......\r\n    if isinstance(obj, Path):\r\n        return obj.as_posix()\r\n    .......\r\n```\r\n\r\nWhat do you guys think?",
  "issue_comments": [
    {
      "id": 534424259,
      "user": "euri10",
      "body": "imho it's an issue upstream, if you switch to `from pydantic import Path` you get \r\n```\r\n                except Exception as e:\r\n                    errors.append(e)\r\n>                   raise ValueError(errors)\r\nE                   ValueError: [KeyError(<class 'pathlib.PosixPath'>), TypeError(\"'PosixPath' object is not iterable\"), TypeError('vars() argument must have __dict__ attribute')]\r\n```\r\n\r\nwhich suggests a custom encoder wasnt written for `PosixPath` (see [ENCODERS_BY_TYPE](https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L21))\r\n\r\nOne workaround is this:\r\n```\r\nfrom pathlib import PosixPath\r\n\r\nfrom pydantic import BaseModel, Path\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix()\r\n        }\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```\r\n"
    },
    {
      "id": 534441454,
      "user": "devtud",
      "body": "Thanks for the quick response @euri10 and for the workaround.\r\n\r\n> which suggests a custom encoder wasnt written for PosixPath (see ENCODERS_BY_TYPE)\r\n\r\nPlease see [pydantic_encoder()](https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44) which is the encoder used by pydantic. Fastapi uses a custom one based on the mapping mentioned by you (in which, indeed, PosixPath is not handled). But I don't consider this an upstream issue because Pydantic itself works ok. The only issue with it if it had been used in Fastapi would be that it encodes differently in Windows than Linux.\r\n"
    },
    {
      "id": 534443763,
      "user": "euri10",
      "body": "Iirc it's incorrect, effectively FastAPI uses its own encoder but it relies\non pydantic one, especially for other types, you'll see pretty much the\nsame loop on custom encoder.\n\nLe mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\nécrit :\n\n> Thanks for the quick response @euri10 <https://github.com/euri10> and for\n> the workaround.\n>\n> which suggests a custom encoder wasnt written for PosixPath (see\n> ENCODERS_BY_TYPE)\n>\n> Please see pydantic_encoder()\n> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n> which is the encoder used by pydantic. Fastapi uses a custom one based on\n> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n> But I don't consider this an upstream issue because Pydantic itself works\n> ok. The only issue with it if it had been used in Fastapi would be that it\n> encodes differently in Windows than Linux.\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n> .\n>\n"
    },
    {
      "id": 534446104,
      "user": "euri10",
      "body": "On top of that the windows /Linux discrepancy should be eliminated by\nas_posix in the encoder I suggested, shouldn't it?\n\nLe mar. 24 sept. 2019 à 10:07 AM, Benoit Barthelet <\nbenoit.barthelet@gmail.com> a écrit :\n\n> Iirc it's incorrect, effectively FastAPI uses its own encoder but it\n> relies on pydantic one, especially for other types, you'll see pretty much\n> the same loop on custom encoder.\n>\n> Le mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\n> écrit :\n>\n>> Thanks for the quick response @euri10 <https://github.com/euri10> and\n>> for the workaround.\n>>\n>> which suggests a custom encoder wasnt written for PosixPath (see\n>> ENCODERS_BY_TYPE)\n>>\n>> Please see pydantic_encoder()\n>> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n>> which is the encoder used by pydantic. Fastapi uses a custom one based on\n>> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n>> But I don't consider this an upstream issue because Pydantic itself works\n>> ok. The only issue with it if it had been used in Fastapi would be that it\n>> encodes differently in Windows than Linux.\n>>\n>> —\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n>> .\n>>\n>\n"
    },
    {
      "id": 534450843,
      "user": "devtud",
      "body": "@euri10 , my reply was before seeing you edit. However, the workaround which also would solve the discrepancy would be:\r\n\r\n```python\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix(), # or lambda v: str(v)\r\n            WindowsPath: lambda v: v.as_posix()\r\n        }\r\n```\r\nDo you agree?\r\n\r\nThe first encoder will be executed on Linux/MacOS, and the second one on Windows.\r\n\r\nHowever, this should be fixed in Fastapi (or Pydantic if considered). "
    },
    {
      "id": 534469715,
      "user": "euri10",
      "body": "I dont have windows sorry so cant really comment on that part, but your approach seems perfectly valid\r\nI disagree this should be fixed in FastAPI and thinking about it in Pydatic too, the way you want to encode such an object may be different from one person to another, maybe pydantic could provide a default encoding, not even sure about that, @dmontagu will know."
    },
    {
      "id": 534471673,
      "user": "dmontagu",
      "body": "It looks like you've got a workaround, but if you'd like standardized encoding of `Path`, I'd encourage you to create an issue for discussion in the pydantic repo. \r\n\r\nIt seems like a reasonable request to me, though I could imagine some controversy over whether it should default to a posix format or `str`-casting (I see your point about it being platform independent, but I'm not sure that would be intuitive in all cases for all users) -- given that, it might be best left to users to decide.\r\n\r\nBut if you create an issue there, you can get feedback on it."
    },
    {
      "id": 539856071,
      "user": "GlennS",
      "body": "Is this Pydantic fix relevant?\r\n\r\nhttps://github.com/samuelcolvin/pydantic/issues/473\r\nhttps://github.com/samuelcolvin/pydantic/pull/485\r\n\r\n"
    },
    {
      "id": 547345209,
      "user": "devtud",
      "body": "@GlennS , that fix is in `pydantic_encoder()` which is not used by Fastapi."
    },
    {
      "id": 584314275,
      "user": "tiangolo",
      "body": "Thanks for the report @devtud .\r\n\r\nYes, that's a bug/feature request. We should have a case for it in `jsonable_encoder`.\r\n\r\nRight after:\r\n\r\n```Python\r\nif isinstance(obj, Enum):\r\n        return obj.value\r\n```"
    },
    {
      "id": 586748380,
      "user": "tiangolo",
      "body": "This was fixed by @patrickmckenna in #978 :rocket: :bug: \r\n\r\nIt's available in version `0.49.0` :tada: \r\n\r\n<!-- issue-manager: answered -->"
    },
    {
      "id": 591706715,
      "user": "github-actions[bot]",
      "body": "Assuming the original issue was solved, it will be automatically closed now. But feel free to add more comments or create new issues."
    }
  ],
  "text_context": "# pathlib.Path is not serializable\n\n**Describe the bug**\r\nIf the api response contains fields of type `pathlib.Path`, an error is raised:\r\n \r\n```bash\r\nValueError: [KeyError(<class 'pathlib.PosixPath'>,), TypeError(\"'PosixPath' object is not iterable\",), TypeError('vars() argument must have __dict__ attribute',)]\r\n```\r\n\r\n**To Reproduce**\r\nI wrote a test for this bug which fails with the above ^ error.\r\n\r\n```python\r\n#tests/test_serialize_path.py\r\n\r\nfrom pathlib import Path\r\n\r\nfrom pydantic import BaseModel\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```\r\n\r\n**Expected behavior**\r\nThe test should pass, which means a 200 response is returned and the response is:\r\n\r\n```json\r\n{\r\n    \"path\": \"/some/random/path\"\r\n}\r\n```\r\n\r\n**Environment:**\r\n - OS: Linux / Windows\r\n - FastAPI Version 0.38.1\r\n\r\n- Python version 3.6.9\r\n\r\n**Additional context**\r\n\r\n**Solution 1**\r\n\r\nA possible fix would be importing and using the encoder from `pydantic` which knows to encode `Path` objects:\r\n\r\n```python\r\n# pydantic/json.py\r\n\r\ndef pydantic_encoder(obj: Any) -> Any:\r\n    ......\r\n    elif isinstance(obj, Path):\r\n        return str(obj)\r\n    ......\r\n```\r\n\r\nThe Fastapi's `jsonable_encoder(....)` would be changed from this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import ENCODERS_BY_TYPE\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = ENCODERS_BY_TYPE[type(obj)]\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nto this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import pydantic_encoder\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = pydantic_encoder\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nThe test passes but `pydantic_encoder()` has a downside: the string obtained by `str(Path(...))` is not the same on Windows (eg: `\\some\\random\\path`) vs Linux (`/some/random/path`).\r\n\r\n** Solution 2 **\r\n\r\nAs I think it is very important that a Fastapi app return the same responses no matter the platform on which it's deployed, another solution is handling the `pathlib.Path` encoding directly in Fastapi's `jsonable_encoder()`, using `Path(...).as_posix()` instead of `str(Path(...))` like:\r\n\r\n```python\r\n# fastapi/encoders.py\r\n\r\ndef jsonable_encoder(.....) -> Any:\r\n    ......\r\n    if isinstance(obj, Path):\r\n        return obj.as_posix()\r\n    .......\r\n```\r\n\r\nWhat do you guys think?\n\nimho it's an issue upstream, if you switch to `from pydantic import Path` you get \r\n```\r\n                except Exception as e:\r\n                    errors.append(e)\r\n>                   raise ValueError(errors)\r\nE                   ValueError: [KeyError(<class 'pathlib.PosixPath'>), TypeError(\"'PosixPath' object is not iterable\"), TypeError('vars() argument must have __dict__ attribute')]\r\n```\r\n\r\nwhich suggests a custom encoder wasnt written for `PosixPath` (see [ENCODERS_BY_TYPE](https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L21))\r\n\r\nOne workaround is this:\r\n```\r\nfrom pathlib import PosixPath\r\n\r\nfrom pydantic import BaseModel, Path\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix()\r\n        }\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```\r\n\n\nThanks for the quick response @euri10 and for the workaround.\r\n\r\n> which suggests a custom encoder wasnt written for PosixPath (see ENCODERS_BY_TYPE)\r\n\r\nPlease see [pydantic_encoder()](https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44) which is the encoder used by pydantic. Fastapi uses a custom one based on the mapping mentioned by you (in which, indeed, PosixPath is not handled). But I don't consider this an upstream issue because Pydantic itself works ok. The only issue with it if it had been used in Fastapi would be that it encodes differently in Windows than Linux.\r\n\n\nIirc it's incorrect, effectively FastAPI uses its own encoder but it relies\non pydantic one, especially for other types, you'll see pretty much the\nsame loop on custom encoder.\n\nLe mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\nécrit :\n\n> Thanks for the quick response @euri10 <https://github.com/euri10> and for\n> the workaround.\n>\n> which suggests a custom encoder wasnt written for PosixPath (see\n> ENCODERS_BY_TYPE)\n>\n> Please see pydantic_encoder()\n> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n> which is the encoder used by pydantic. Fastapi uses a custom one based on\n> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n> But I don't consider this an upstream issue because Pydantic itself works\n> ok. The only issue with it if it had been used in Fastapi would be that it\n> encodes differently in Windows than Linux.\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n> .\n>\n\n\nOn top of that the windows /Linux discrepancy should be eliminated by\nas_posix in the encoder I suggested, shouldn't it?\n\nLe mar. 24 sept. 2019 à 10:07 AM, Benoit Barthelet <\nbenoit.barthelet@gmail.com> a écrit :\n\n> Iirc it's incorrect, effectively FastAPI uses its own encoder but it\n> relies on pydantic one, especially for other types, you'll see pretty much\n> the same loop on custom encoder.\n>\n> Le mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\n> écrit :\n>\n>> Thanks for the quick response @euri10 <https://github.com/euri10> and\n>> for the workaround.\n>>\n>> which suggests a custom encoder wasnt written for PosixPath (see\n>> ENCODERS_BY_TYPE)\n>>\n>> Please see pydantic_encoder()\n>> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n>> which is the encoder used by pydantic. Fastapi uses a custom one based on\n>> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n>> But I don't consider this an upstream issue because Pydantic itself works\n>> ok. The only issue with it if it had been used in Fastapi would be that it\n>> encodes differently in Windows than Linux.\n>>\n>> —\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n>> .\n>>\n>\n\n\n@euri10 , my reply was before seeing you edit. However, the workaround which also would solve the discrepancy would be:\r\n\r\n```python\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix(), # or lambda v: str(v)\r\n            WindowsPath: lambda v: v.as_posix()\r\n        }\r\n```\r\nDo you agree?\r\n\r\nThe first encoder will be executed on Linux/MacOS, and the second one on Windows.\r\n\r\nHowever, this should be fixed in Fastapi (or Pydantic if considered). \n\nI dont have windows sorry so cant really comment on that part, but your approach seems perfectly valid\r\nI disagree this should be fixed in FastAPI and thinking about it in Pydatic too, the way you want to encode such an object may be different from one person to another, maybe pydantic could provide a default encoding, not even sure about that, @dmontagu will know.\n\nIt looks like you've got a workaround, but if you'd like standardized encoding of `Path`, I'd encourage you to create an issue for discussion in the pydantic repo. \r\n\r\nIt seems like a reasonable request to me, though I could imagine some controversy over whether it should default to a posix format or `str`-casting (I see your point about it being platform independent, but I'm not sure that would be intuitive in all cases for all users) -- given that, it might be best left to users to decide.\r\n\r\nBut if you create an issue there, you can get feedback on it.\n\nIs this Pydantic fix relevant?\r\n\r\nhttps://github.com/samuelcolvin/pydantic/issues/473\r\nhttps://github.com/samuelcolvin/pydantic/pull/485\r\n\r\n\n\n@GlennS , that fix is in `pydantic_encoder()` which is not used by Fastapi.\n\nThanks for the report @devtud .\r\n\r\nYes, that's a bug/feature request. We should have a case for it in `jsonable_encoder`.\r\n\r\nRight after:\r\n\r\n```Python\r\nif isinstance(obj, Enum):\r\n        return obj.value\r\n```\n\nThis was fixed by @patrickmckenna in #978 :rocket: :bug: \r\n\r\nIt's available in version `0.49.0` :tada: \r\n\r\n<!-- issue-manager: answered -->\n\nAssuming the original issue was solved, it will be automatically closed now. But feel free to add more comments or create new issues.",
  "pr_link": "https://github.com/samuelcolvin/pydantic/pull/485",
  "code_context": [
    {
      "filename": "docs/examples/exotic.py",
      "content": "import uuid\nfrom decimal import Decimal\nfrom ipaddress import IPv4Address, IPv6Address, IPv4Interface, IPv6Interface, IPv4Network, IPv6Network\nfrom pathlib import Path\nfrom uuid import UUID\n\nfrom pydantic import (DSN, UUID1, UUID3, UUID4, UUID5, BaseModel, DirectoryPath, EmailStr, FilePath, NameEmail,\n                      NegativeFloat, NegativeInt, PositiveFloat, PositiveInt, PyObject, UrlStr, conbytes, condecimal,\n                      confloat, conint, constr, IPvAnyAddress, IPvAnyInterface, IPvAnyNetwork, SecretStr, SecretBytes)\n\n\nclass Model(BaseModel):\n    cos_function: PyObject = None\n\n    path_to_something: Path = None\n    path_to_file: FilePath = None\n    path_to_directory: DirectoryPath = None\n\n    short_bytes: conbytes(min_length=2, max_length=10) = None\n    strip_bytes: conbytes(strip_whitespace=True)\n\n    short_str: constr(min_length=2, max_length=10) = None\n    regex_str: constr(regex='apple (pie|tart|sandwich)') = None\n    strip_str: constr(strip_whitespace=True)\n\n    big_int: conint(gt=1000, lt=1024) = None\n    mod_int: conint(multiple_of=5) = None\n    pos_int: PositiveInt = None\n    neg_int: NegativeInt = None\n\n    big_float: confloat(gt=1000, lt=1024) = None\n    unit_interval: confloat(ge=0, le=1) = None\n    mod_float: confloat(multiple_of=0.5) = None\n    pos_float: PositiveFloat = None\n    neg_float: NegativeFloat = None\n\n    email_address: EmailStr = None\n    email_and_name: NameEmail = None\n\n    url: UrlStr = None\n\n    password: SecretStr = None\n    password_bytes: SecretBytes = None\n\n    db_name = 'foobar'\n    db_user = 'postgres'\n    db_password: str = None\n    db_host = 'localhost'\n    db_port = '5432'\n    db_driver = 'postgres'\n    db_query: dict = None\n    dsn: DSN = None\n    decimal: Decimal = None\n    decimal_positive: condecimal(gt=0) = None\n    decimal_negative: condecimal(lt=0) = None\n    decimal_max_digits_and_places: condecimal(max_digits=2, decimal_places=2) = None\n    mod_decimal: condecimal(multiple_of=Decimal('0.25')) = None\n    uuid_any: UUID = None\n    uuid_v1: UUID1 = None\n    uuid_v3: UUID3 = None\n    uuid_v4: UUID4 = None\n    uuid_v5: UUID5 = None\n    ipvany: IPvAnyAddress = None\n    ipv4: IPv4Address = None\n    ipv6: IPv6Address = None\n    ip_vany_network: IPvAnyNetwork = None\n    ip_v4_network: IPv4Network = None\n    ip_v6_network: IPv6Network = None\n    ip_vany_interface: IPvAnyInterface = None\n    ip_v4_interface: IPv4Interface = None\n    ip_v6_interface: IPv6Interface = None\n\nm = Model(\n    cos_function='math.cos',\n    path_to_something='/home',\n    path_to_file='/home/file.py',\n    path_to_directory='home/projects',\n    short_bytes=b'foo',\n    strip_bytes=b'   bar',\n    short_str='foo',\n    regex_str='apple pie',\n    strip_str='   bar',\n    big_int=1001,\n    mod_int=155,\n    pos_int=1,\n    neg_int=-1,\n    big_float=1002.1,\n    mod_float=1.5,\n    pos_float=2.2,\n    neg_float=-2.3,\n    unit_interval=0.5,\n    email_address='Samuel Colvin <s@muelcolvin.com >',\n    email_and_name='Samuel Colvin <s@muelcolvin.com >',\n    url='http://example.com',\n    password='password',\n    password_bytes=b'password2',\n    decimal=Decimal('42.24'),\n    decimal_positive=Decimal('21.12'),\n    decimal_negative=Decimal('-21.12'),\n    decimal_max_digits_and_places=Decimal('0.99'),\n    mod_decimal=Decimal('2.75'),\n    uuid_any=uuid.uuid4(),\n    uuid_v1=uuid.uuid1(),\n    uuid_v3=uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org'),\n    uuid_v4=uuid.uuid4(),\n    uuid_v5=uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org'),\n    ipvany=IPv4Address('192.168.0.1'),\n    ipv4=IPv4Address('255.255.255.255'),\n    ipv6=IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'),\n    ip_vany_network=IPv4Network('192.168.0.0/24'),\n    ip_v4_network=IPv4Network('192.168.0.0/24'),\n    ip_v6_network=IPv6Network('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128'),\n    ip_vany_interface=IPv4Interface('192.168.0.0/24'),\n    ip_v4_interface=IPv4Interface('192.168.0.0/24'),\n    ip_v6_interface=IPv6Interface('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128')\n)\nprint(m.dict())\n\"\"\"\n{\n    'cos_function': <built-in function cos>,\n    'path_to_something': PosixPath('/home'),\n    'path_to_file': PosixPath('/home/file.py'),\n    'path_to_directory': PosixPath('/home/projects'),\n    'short_bytes': b'foo',\n    'strip_bytes': b'bar',\n    'short_str': 'foo',\n    'regex_str': 'apple pie',\n    'strip_str': 'bar',\n    'big_int': 1001,\n    'mod_int': 155,\n    'pos_int': 1,\n    'neg_int': -1,\n    'big_float': 1002.1,\n    'mod_float': 1.5,\n    'pos_float': 2.2,\n    'neg_float': -2.3,\n    'unit_interval': 0.5,\n    'email_address': 's@muelcolvin.com',\n    'email_and_name': <NameEmail(\"Samuel Colvin <s@muelcolvin.com>\")>,\n    'url': 'http://example.com',\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n    ...\n    'dsn': 'postgres://postgres@localhost:5432/foobar',\n    'decimal': Decimal('42.24'),\n    'decimal_positive': Decimal('21.12'),\n    'decimal_negative': Decimal('-21.12'),\n    'decimal_max_digits_and_places': Decimal('0.99'),\n    'mod_decimal': Decimal('2.75'),\n    'uuid_any': UUID('ebcdab58-6eb8-46fb-a190-d07a33e9eac8'),\n    'uuid_v1': UUID('c96e505c-4c62-11e8-a27c-dca90496b483'),\n    'uuid_v3': UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e'),\n    'uuid_v4': UUID('22209f7a-aad1-491c-bb83-ea19b906d210'),\n    'uuid_v5': UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d'),\n    'ipvany': IPv4Address('192.168.0.1'),\n    'ipv4': IPv4Address('255.255.255.255'),\n    'ipv6': IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'),\n    'ip_vany_network': IPv4Network('192.168.0.0/24'),\n    'ip_v4_network': IPv4Network('192.168.0.0/24'),\n    'ip_v6_network': IPv4Network('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128'),\n    'ip_vany_interface': IPv4Interface('192.168.0.0/24'),\n    'ip_v4_interface': IPv4Interface('192.168.0.0/24'),\n    'ip_v6_interface': IPv6Interface('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128')\n}\n\"\"\"\n"
    },
    {
      "filename": "pydantic/json.py",
      "content": "import datetime\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom types import GeneratorType\nfrom typing import Any, Callable, Dict, Type, Union\nfrom uuid import UUID\n\nfrom pydantic.types import SecretBytes, SecretStr\n\n__all__ = 'pydantic_encoder', 'custom_pydantic_encoder', 'timedelta_isoformat'\n\n\ndef isoformat(o: Union[datetime.date, datetime.time]) -> str:\n    return o.isoformat()\n\n\nENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {\n    IPv4Address: str,\n    IPv6Address: str,\n    IPv4Interface: str,\n    IPv6Interface: str,\n    IPv4Network: str,\n    IPv6Network: str,\n    SecretStr: lambda ss: ss.display(),\n    SecretBytes: lambda sb: sb.display(),\n    UUID: str,\n    datetime.datetime: isoformat,\n    datetime.date: isoformat,\n    datetime.time: isoformat,\n    datetime.timedelta: lambda td: td.total_seconds(),\n    set: list,\n    frozenset: list,\n    GeneratorType: list,\n    bytes: lambda o: o.decode(),\n    Decimal: float,\n}\n\n\ndef pydantic_encoder(obj: Any) -> Any:\n    from .main import BaseModel\n\n    if isinstance(obj, BaseModel):\n        return obj.dict()\n    elif isinstance(obj, Enum):\n        return obj.value\n    elif isinstance(obj, Path):\n        return str(obj)\n\n    try:\n        encoder = ENCODERS_BY_TYPE[type(obj)]\n    except KeyError:\n        raise TypeError(f\"Object of type '{obj.__class__.__name__}' is not JSON serializable\")\n    else:\n        return encoder(obj)\n\n\ndef custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -> Any:\n    encoder = type_encoders.get(type(obj))\n    if encoder:\n        return encoder(obj)\n    else:\n        return pydantic_encoder(obj)\n\n\ndef timedelta_isoformat(td: datetime.timedelta) -> str:\n    \"\"\"\n    ISO 8601 encoding for timedeltas.\n    \"\"\"\n    minutes, seconds = divmod(td.seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f'P{td.days}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:06d}S'\n"
    },
    {
      "filename": "tests/test_json.py",
      "content": "import datetime\nimport json\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom uuid import UUID\n\nimport pytest\n\nfrom pydantic import BaseModel, create_model\nfrom pydantic.json import pydantic_encoder, timedelta_isoformat\nfrom pydantic.types import DirectoryPath, FilePath, SecretBytes, SecretStr\n\n\nclass MyEnum(Enum):\n    foo = 'bar'\n    snap = 'crackle'\n\n\n@pytest.mark.parametrize(\n    'input,output',\n    [\n        (UUID('ebcdab58-6eb8-46fb-a190-d07a33e9eac8'), '\"ebcdab58-6eb8-46fb-a190-d07a33e9eac8\"'),\n        (IPv4Address('192.168.0.1'), '\"192.168.0.1\"'),\n        (SecretStr('abcd'), '\"**********\"'),\n        (SecretStr(''), '\"\"'),\n        (SecretBytes(b'xyz'), '\"**********\"'),\n        (SecretBytes(b''), '\"\"'),\n        (IPv6Address('::1:0:1'), '\"::1:0:1\"'),\n        (IPv4Interface('192.168.0.0/24'), '\"192.168.0.0/24\"'),\n        (IPv6Interface('2001:db00::/120'), '\"2001:db00::/120\"'),\n        (IPv4Network('192.168.0.0/24'), '\"192.168.0.0/24\"'),\n        (IPv6Network('2001:db00::/120'), '\"2001:db00::/120\"'),\n        (datetime.datetime(2032, 1, 1, 1, 1), '\"2032-01-01T01:01:00\"'),\n        (datetime.datetime(2032, 1, 1, 1, 1, tzinfo=datetime.timezone.utc), '\"2032-01-01T01:01:00+00:00\"'),\n        (datetime.datetime(2032, 1, 1), '\"2032-01-01T00:00:00\"'),\n        (datetime.time(12, 34, 56), '\"12:34:56\"'),\n        (datetime.timedelta(days=12, seconds=34, microseconds=56), '1036834.000056'),\n        ({1, 2, 3}, '[1, 2, 3]'),\n        (frozenset([1, 2, 3]), '[1, 2, 3]'),\n        ((v for v in range(4)), '[0, 1, 2, 3]'),\n        (b'this is bytes', '\"this is bytes\"'),\n        (Decimal('12.34'), '12.34'),\n        (create_model('BarModel', a='b', c='d')(), '{\"a\": \"b\", \"c\": \"d\"}'),\n        (MyEnum.foo, '\"bar\"'),\n    ],\n)\ndef test_encoding(input, output):\n    assert output == json.dumps(input, default=pydantic_encoder)\n\n\ndef test_path_encoding(tmpdir):\n    class PathModel(BaseModel):\n        path: Path\n        file_path: FilePath\n        dir_path: DirectoryPath\n\n    tmpdir = Path(tmpdir)\n    file_path = tmpdir / 'bar'\n    file_path.touch()\n    dir_path = tmpdir / 'baz'\n    dir_path.mkdir()\n    model = PathModel(path=Path('/path/test/example/'), file_path=file_path, dir_path=dir_path)\n    expected = '{{\"path\": \"/path/test/example\", \"file_path\": \"{}\", \"dir_path\": \"{}\"}}'.format(file_path, dir_path)\n    assert json.dumps(model, default=pydantic_encoder) == expected\n\n\ndef test_model_encoding():\n    class ModelA(BaseModel):\n        x: int\n        y: str\n\n    class Model(BaseModel):\n        a: float\n        b: bytes\n        c: Decimal\n        d: ModelA\n\n    m = Model(a=10.2, b='foobar', c=10.2, d={'x': 123, 'y': '123'})\n    assert m.dict() == {'a': 10.2, 'b': b'foobar', 'c': Decimal('10.2'), 'd': {'x': 123, 'y': '123'}}\n    assert m.json() == '{\"a\": 10.2, \"b\": \"foobar\", \"c\": 10.2, \"d\": {\"x\": 123, \"y\": \"123\"}}'\n    assert m.json(exclude={'b'}) == '{\"a\": 10.2, \"c\": 10.2, \"d\": {\"x\": 123, \"y\": \"123\"}}'\n\n\ndef test_invalid_model():\n    class Foo:\n        pass\n\n    with pytest.raises(TypeError):\n        json.dumps(Foo, default=pydantic_encoder)\n\n\n@pytest.mark.parametrize(\n    'input,output',\n    [\n        (datetime.timedelta(days=12, seconds=34, microseconds=56), 'P12DT0H0M34.000056S'),\n        (datetime.timedelta(days=1001, hours=1, minutes=2, seconds=3, microseconds=654_321), 'P1001DT1H2M3.654321S'),\n    ],\n)\ndef test_iso_timedelta(input, output):\n    assert output == timedelta_isoformat(input)\n\n\ndef test_custom_encoder():\n    class Model(BaseModel):\n        x: datetime.timedelta\n        y: Decimal\n        z: datetime.date\n\n        class Config:\n            json_encoders = {datetime.timedelta: lambda v: f'{v.total_seconds():0.3f}s', Decimal: lambda v: 'a decimal'}\n\n    assert Model(x=123, y=5, z='2032-06-01').json() == '{\"x\": \"123.000s\", \"y\": \"a decimal\", \"z\": \"2032-06-01\"}'\n\n\ndef test_custom_iso_timedelta():\n    class Model(BaseModel):\n        x: datetime.timedelta\n\n        class Config:\n            json_encoders = {datetime.timedelta: timedelta_isoformat}\n\n    m = Model(x=123)\n    assert m.json() == '{\"x\": \"P0DT0H2M3.000000S\"}'\n\n\ndef test_custom_encoder_arg():\n    class Model(BaseModel):\n        x: datetime.timedelta\n\n    m = Model(x=123)\n    assert m.json() == '{\"x\": 123.0}'\n    assert m.json(encoder=lambda v: '__default__') == '{\"x\": \"__default__\"}'\n"
    }
  ],
  "questions": [
    "Iirc it's incorrect, effectively FastAPI uses its own encoder but it relies\non pydantic one, especially for other types, you'll see pretty much the\nsame loop on custom encoder.\n\nLe mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\nécrit :\n\n> Thanks for the quick response @euri10 <https://github.com/euri10> and for\n> the workaround.\n>\n> which suggests a custom encoder wasnt written for PosixPath (see\n> ENCODERS_BY_TYPE)\n>\n> Please see pydantic_encoder()\n> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n> which is the encoder used by pydantic. Fastapi uses a custom one based on\n> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n> But I don't consider this an upstream issue because Pydantic itself works\n> ok. The only issue with it if it had been used in Fastapi would be that it\n> encodes differently in Windows than Linux.\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n> .\n>",
    "On top of that the windows /Linux discrepancy should be eliminated by\nas_posix in the encoder I suggested, shouldn't it?\n\nLe mar. 24 sept. 2019 à 10:07 AM, Benoit Barthelet <\nbenoit.barthelet@gmail.com> a écrit :\n\n> Iirc it's incorrect, effectively FastAPI uses its own encoder but it\n> relies on pydantic one, especially for other types, you'll see pretty much\n> the same loop on custom encoder.\n>\n> Le mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\n> écrit :\n>\n>> Thanks for the quick response @euri10 <https://github.com/euri10> and\n>> for the workaround.\n>>\n>> which suggests a custom encoder wasnt written for PosixPath (see\n>> ENCODERS_BY_TYPE)\n>>\n>> Please see pydantic_encoder()\n>> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n>> which is the encoder used by pydantic. Fastapi uses a custom one based on\n>> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n>> But I don't consider this an upstream issue because Pydantic itself works\n>> ok. The only issue with it if it had been used in Fastapi would be that it\n>> encodes differently in Windows than Linux.\n>>\n>> —\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n>> .\n>>\n>",
    "@euri10 , my reply was before seeing you edit. However, the workaround which also would solve the discrepancy would be:\r\n\r\n```python\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix(), # or lambda v: str(v)\r\n            WindowsPath: lambda v: v.as_posix()\r\n        }\r\n```\r\nDo you agree?\r\n\r\nThe first encoder will be executed on Linux/MacOS, and the second one on Windows.\r\n\r\nHowever, this should be fixed in Fastapi (or Pydantic if considered).",
    "**Describe the bug**\r\nIf the api response contains fields of type `pathlib.Path`, an error is raised:\r\n \r\n```bash\r\nValueError: [KeyError(<class 'pathlib.PosixPath'>,), TypeError(\"'PosixPath' object is not iterable\",), TypeError('vars() argument must have __dict__ attribute',)]\r\n```\r\n\r\n**To Reproduce**\r\nI wrote a test for this bug which fails with the above ^ error.\r\n\r\n```python\r\n#tests/test_serialize_path.py\r\n\r\nfrom pathlib import Path\r\n\r\nfrom pydantic import BaseModel\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```\r\n\r\n**Expected behavior**\r\nThe test should pass, which means a 200 response is returned and the response is:\r\n\r\n```json\r\n{\r\n    \"path\": \"/some/random/path\"\r\n}\r\n```\r\n\r\n**Environment:**\r\n - OS: Linux / Windows\r\n - FastAPI Version 0.38.1\r\n\r\n- Python version 3.6.9\r\n\r\n**Additional context**\r\n\r\n**Solution 1**\r\n\r\nA possible fix would be importing and using the encoder from `pydantic` which knows to encode `Path` objects:\r\n\r\n```python\r\n# pydantic/json.py\r\n\r\ndef pydantic_encoder(obj: Any) -> Any:\r\n    ......\r\n    elif isinstance(obj, Path):\r\n        return str(obj)\r\n    ......\r\n```\r\n\r\nThe Fastapi's `jsonable_encoder(....)` would be changed from this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import ENCODERS_BY_TYPE\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = ENCODERS_BY_TYPE[type(obj)]\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nto this:\r\n\r\n```python\r\n# fastapi/encoder.py\r\n....\r\nfrom pydantic.json import pydantic_encoder\r\n....\r\n\r\ndef jsonable_encoder(....) -> Any:\r\n    .......\r\n    try:\r\n        if custom_encoder and type(obj) in custom_encoder:\r\n            encoder = custom_encoder[type(obj)]\r\n        else:\r\n            encoder = pydantic_encoder\r\n        return encoder(obj)\r\n    except KeyError as e:\r\n        .....\r\n    ......\r\n```\r\n\r\nThe test passes but `pydantic_encoder()` has a downside: the string obtained by `str(Path(...))` is not the same on Windows (eg: `\\some\\random\\path`) vs Linux (`/some/random/path`).\r\n\r\n** Solution 2 **\r\n\r\nAs I think it is very important that a Fastapi app return the same responses no matter the platform on which it's deployed, another solution is handling the `pathlib.Path` encoding directly in Fastapi's `jsonable_encoder()`, using `Path(...).as_posix()` instead of `str(Path(...))` like:\r\n\r\n```python\r\n# fastapi/encoders.py\r\n\r\ndef jsonable_encoder(.....) -> Any:\r\n    ......\r\n    if isinstance(obj, Path):\r\n        return obj.as_posix()\r\n    .......\r\n```\r\n\r\nWhat do you guys think?"
  ],
  "golden_answers": [
    "On top of that the windows /Linux discrepancy should be eliminated by\nas_posix in the encoder I suggested, shouldn't it?\n\nLe mar. 24 sept. 2019 à 10:07 AM, Benoit Barthelet <\nbenoit.barthelet@gmail.com> a écrit :\n\n> Iirc it's incorrect, effectively FastAPI uses its own encoder but it\n> relies on pydantic one, especially for other types, you'll see pretty much\n> the same loop on custom encoder.\n>\n> Le mar. 24 sept. 2019 à 10:01 AM, devtud <notifications@github.com> a\n> écrit :\n>\n>> Thanks for the quick response @euri10 <https://github.com/euri10> and\n>> for the workaround.\n>>\n>> which suggests a custom encoder wasnt written for PosixPath (see\n>> ENCODERS_BY_TYPE)\n>>\n>> Please see pydantic_encoder()\n>> <https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L44>\n>> which is the encoder used by pydantic. Fastapi uses a custom one based on\n>> the mapping mentioned by you (in which, indeed, PosixPath is not handled).\n>> But I don't consider this an upstream issue because Pydantic itself works\n>> ok. The only issue with it if it had been used in Fastapi would be that it\n>> encodes differently in Windows than Linux.\n>>\n>> —\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tiangolo/fastapi/issues/563?email_source=notifications&email_token=AAINSPUMCQTSB43447EODY3QLHCNRA5CNFSM4IZ3IWJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7NO33Q#issuecomment-534441454>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AAINSPV2ZV3TYBJFFZIZF73QLHCNRANCNFSM4IZ3IWJQ>\n>> .\n>>\n>",
    "@euri10 , my reply was before seeing you edit. However, the workaround which also would solve the discrepancy would be:\r\n\r\n```python\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix(), # or lambda v: str(v)\r\n            WindowsPath: lambda v: v.as_posix()\r\n        }\r\n```\r\nDo you agree?\r\n\r\nThe first encoder will be executed on Linux/MacOS, and the second one on Windows.\r\n\r\nHowever, this should be fixed in Fastapi (or Pydantic if considered).",
    "It looks like you've got a workaround, but if you'd like standardized encoding of `Path`, I'd encourage you to create an issue for discussion in the pydantic repo. \r\n\r\nIt seems like a reasonable request to me, though I could imagine some controversy over whether it should default to a posix format or `str`-casting (I see your point about it being platform independent, but I'm not sure that would be intuitive in all cases for all users) -- given that, it might be best left to users to decide.\r\n\r\nBut if you create an issue there, you can get feedback on it.",
    "imho it's an issue upstream, if you switch to `from pydantic import Path` you get \r\n```\r\n                except Exception as e:\r\n                    errors.append(e)\r\n>                   raise ValueError(errors)\r\nE                   ValueError: [KeyError(<class 'pathlib.PosixPath'>), TypeError(\"'PosixPath' object is not iterable\"), TypeError('vars() argument must have __dict__ attribute')]\r\n```\r\n\r\nwhich suggests a custom encoder wasnt written for `PosixPath` (see [ENCODERS_BY_TYPE](https://github.com/samuelcolvin/pydantic/blob/9ffa311f8fd54ad2a5619477a0612f99c7bc7ae4/pydantic/json.py#L21))\r\n\r\nOne workaround is this:\r\n```\r\nfrom pathlib import PosixPath\r\n\r\nfrom pydantic import BaseModel, Path\r\nfrom starlette.testclient import TestClient\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\nclass ContainsPathProperty(BaseModel):\r\n    path: Path\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            PosixPath: lambda v: v.as_posix()\r\n        }\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=ContainsPathProperty)\r\nasync def get_main():\r\n    obj = ContainsPathProperty(path=Path('/some/random/path'))\r\n    return obj\r\n\r\n\r\nclient = TestClient(app)\r\n\r\n\r\ndef test_serialize_path():\r\n    response = client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {'path': '/some/random/path'}\r\n```"
  ],
  "questions_generated": [
    "What is the root cause of the pathlib.Path serialization issue in FastAPI as described in the issue?",
    "How does Solution 1 propose to fix the serialization issue, and what is a significant drawback of this approach?",
    "Explain how Solution 2 addresses the issue of platform-consistent serialization for pathlib.Path objects in FastAPI.",
    "In the context of the issue, why is it important for FastAPI to return consistent responses across different platforms?",
    "How does the use of custom encoders in FastAPI's jsonable_encoder function influence its flexibility in handling different data types?"
  ],
  "golden_answers_generated": [
    "The root cause of the serialization issue is that FastAPI's default jsonable_encoder does not handle pathlib.Path objects, leading to a ValueError when trying to serialize API responses that include Path fields. This is because the encoder does not have a built-in method to convert Path objects to a JSON-serializable format.",
    "Solution 1 suggests using the pydantic_encoder from Pydantic, which can encode Path objects by converting them to strings using str(Path(...)). However, the drawback is that the string representation of Path objects differs between operating systems (Windows vs Linux), potentially leading to inconsistent API responses across different platforms.",
    "Solution 2 proposes handling the serialization of pathlib.Path directly within FastAPI's jsonable_encoder by converting Path objects to their POSIX representation using Path(...).as_posix(). This ensures that regardless of the operating system, the Path objects are consistently serialized as POSIX-style paths, maintaining consistent API responses.",
    "Consistency in API responses across different platforms is crucial because it ensures that clients interacting with the API receive the same data format regardless of the server's operating system. This is especially important for applications that need to be deployed in diverse environments, as inconsistent data formats can lead to client-side errors or misinterpretations of the data.",
    "The use of custom encoders in FastAPI's jsonable_encoder function allows developers to define specific serialization logic for different data types, enhancing the flexibility of the encoder. This means that developers can extend or override the default encoding behavior to accommodate custom objects or types that are not natively supported by FastAPI, such as pathlib.Path, by providing a custom encoding function."
  ]
}