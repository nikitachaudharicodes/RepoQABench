{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "19133",
  "issue_description": "# Accept additional string formatting styles in sankey\n\nCurrently, Sankey class accepts number formatting for labels using the old printf string formatting. \r\n\r\nI think the relevant line is here:\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/a02ffbcd898793c95de66d3bdb4dc0a8b6c5a3d0/lib/matplotlib/sankey.py#L742\r\n\r\nF-strings seem to be preferred over this format (you probably know this already but here's [some reasons](https://realpython.com/python-formatted-output/)). A specific reason is that I can't easily use thousands separator with the old printf format, while this is trivial with f-strings.\r\n\r\nI can rewrite this pretty easily by changing the parameter to format for an f string, [as described here](https://stackoverflow.com/a/54780825).\r\n\r\nCan I put in a pull request thingy? Or is there a particular reason for this old format?",
  "issue_comments": [
    {
      "id": 747158172,
      "user": "timhoffm",
      "body": "It's the old format because this has already existed for a long time. We cannot simply switch to another formatting mechanism because of backward-compatibility. That would break user code.\r\n\r\nI haven't thought this through completely, but I don't think you can use f-strings here because the definition of the string and the formatting are separated, but f-strings are immediately evaluated. It might be possible to use classic `{}`-formatting. But you would have to make sure that `%`-style formatting is still supported and edge-cases (in particular using curly braces and % in the respective other format) are handled correctly."
    },
    {
      "id": 747257694,
      "user": "CharlesHe16",
      "body": "> I haven't thought this through completely, but I don't think you can use f-strings here because the definition of the string and the formatting are separated, but f-strings are immediately evaluated. \r\n\r\nNo, f-string formatting can be separated, just as the fprint format is separated now. Try for yourself:\r\n\r\n```\r\nformat_f_string = '.2f'\r\n\r\nprint(f'test string: {42:{format_f_string}}')\r\n\r\nformat_f_string = '.0f'\r\n\r\nprint(f'test string: {42:{format_f_string}}')\r\n```\r\n\r\n```\r\n>>42.00\r\n\r\n>>42\r\n```\r\n\r\n> It's the old format because this has already existed for a long time. We cannot simply switch to another formatting mechanism because of backward-compatibility. That would break user code.**\r\n\r\nNot trying to argue or even persuade, but genuinely curious: things get deprecated all the time. \r\n\r\nWhat is the criteria or threshold for changing the format? The fprint or string modulo seems arcane and is discouraged by Python 3 docs. \r\n\r\n>But you would have to make sure that %-style formatting is still supported and edge-cases (in particular using curly braces and % in the respective other format) are handled correctly.\r\n\r\nOk. So I would need to find a way to easily decide whether something is an f-strings format or a string modulo format.\r\n\r\nAlternatively, would you accept an additional parameter such as \"f_string_format\" in addition to \"format\", or is that too much gore?\r\n\r\n"
    },
    {
      "id": 747765096,
      "user": "QuLogic",
      "body": "> No, f-string formatting can be separated, just as the fprint format is separated now. Try for yourself:\r\n\r\nThat example is not strictly equivalent to what's supported in `Sankey`, as it only determines the format of a value, whereas the %-string could contain anything so long as it only interpolated one value. In its usage, the format was only used for determining how a single value was formatted, but there was nothing ensuring that that would be the case, i.e., passing `format='Flow #%d'` was a possibility."
    },
    {
      "id": 747779987,
      "user": "CharlesHe16",
      "body": "@QuLogic this makes sense.\r\n\r\nI guess one solution is to have a second mode of use for when the user enters a tuple. \r\n\r\nThe first element of the tuple provides any additional text content, and the second element contains formatting for the f string.\r\n\r\nFor example `format=('test string %D', '.2f')` with the value of 5 produces `'test string 5.00'`.\r\n\r\nThis seems awkward and niche."
    },
    {
      "id": 747803188,
      "user": "timhoffm",
      "body": "> Not trying to argue or even persuade, but genuinely curious: things get deprecated all the time.\r\n\r\n> What is the criteria or threshold for changing the format?\r\n\r\nFor every deprecation we carefully weigh the benefit (clean, intuitive, consistent, ... API) against cost (users have to re-learn, existing code must be changed).\r\n\r\nFor the sankey format IMHO the benefit is small. It is true that %-formatting has its quirks but it's still a standard and well-known API of Python. And users of `format` will likely need to read the docs anyway to learn about the feature; either way `format` is not canonical enough so that a user could guess what can be passed. OTOH every user of `format` would be affected by the deprecation.\r\n\r\nI'm against different modes or multiple parameters. That would over-complicate the API. There should only be one `format` parameter and it should unambiguously specify what to do (even though multiple kinds of input may be permissive).\r\n\r\nCurrent API is\r\n~~~\r\nSankey(..., format='%.2f')\r\n~~~\r\n\r\nI could imaging extending to `str.format` (https://docs.python.org/3.9/library/stdtypes.html#str.format) i.e.\r\n~~~\r\nSankey(..., format='{0:.2f}')\r\n~~~\r\nis valid. That could possibly be checked by `re.match('.*{0(?:.*)}', format)` or similar. That would give you the full flexibility of the [Format String Syntax](https://docs.python.org/3.9/library/string.html#formatstrings).\r\n\r\nI don't see how an f-string can be helpful here."
    },
    {
      "id": 747820184,
      "user": "CharlesHe16",
      "body": "Hi Tim,\r\n\r\n>For every deprecation we carefully weigh the benefit (clean, intuitive, consistent, ... API) against cost (users have to re-learn, existing code must be changed).\r\n\r\n>For the sankey format IMHO the benefit is small. It is true that %-formatting has its quirks but it's still a standard and well-known API of Python. And users of format will likely need to read the docs anyway to learn about the feature; either way format is not canonical enough so that a user could guess what can be passed. OTOH every user of format would be affected by the deprecation.\r\n\r\nThis makes sense, thanks for explaining with as much precision as you did. \r\n\r\n>I don't see how an f-string can be helpful here.\r\n\r\nI expect you're right and I will follow this.\r\n\r\nBasically, f-strings are my way of putting numbers in strings. I've used str.format and also %-formatting in the past, and to me, f-string seems to dominate these other methods. \r\n\r\nIn fact, until reading your message, I believed that f-strings are the one best canonical way of putting numbers in strings, so I planned to \"upgrade\" `format` with them.\r\n\r\nZooming out, I agree this seems niche. \r\n\r\nI am willing to write a pull request to use str.format if you explicitly say this is useful, otherwise I will just monkey patch or move on.\r\n\r\n"
    },
    {
      "id": 747824855,
      "user": "WeatherGod",
      "body": "Just a quibble on an assertion made earlier in the thread. %-style\nformatting is *not* obsolete or discouraged, per se. It is a perfectly fine\nway of doing things. str.format() (and by extension, f-strings) are\npowerful in other ways. And don't forget about the lowly string templating\nmodule! I have actually used these three features together a few times in\nnested configuration systems for some projects.\n\nIt isn't going away any time soon.\n\nOn Thu, Dec 17, 2020 at 9:05 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> Hi Tim,\n>\n> For every deprecation we carefully weigh the benefit (clean, intuitive,\n> consistent, ... API) against cost (users have to re-learn, existing code\n> must be changed).\n>\n> For the sankey format IMHO the benefit is small. It is true that\n> %-formatting has its quirks but it's still a standard and well-known API of\n> Python. And users of format will likely need to read the docs anyway to\n> learn about the feature; either way format is not canonical enough so that\n> a user could guess what can be passed. OTOH every user of format would be\n> affected by the deprecation.\n>\n> This makes sense, thanks for explaining with as much precision as you did.\n>\n> I don't see how an f-string can be helpful here.\n>\n> I expect you're right and I will follow this.\n>\n> Basically, f-strings are my way of putting numbers in strings. I've used\n> str.format and also %-formatting in the past, and to me, f-string seems to\n> dominate these other methods.\n>\n> In fact, until reading your message, I believed that f-strings are the one\n> best canonical way of putting numbers in strings, so I planned to \"upgrade\"\n> format with them.\n>\n> Zooming out, I agree this seems niche.\n>\n> I am willing to write a pull request to use str.format if you explicitly\n> say this is useful, otherwise I will just monkey patch or move on.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747820184>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6ASAOK3FDU4IVMM4LDSVK2GZANCNFSM4U62G7QA>\n> .\n>\n"
    },
    {
      "id": 747826102,
      "user": "CharlesHe16",
      "body": ">Just a quibble on an assertion made earlier in the thread. %-style\r\nformatting is *not* obsolete or discouraged, per se. It is a perfectly fine\r\nway of doing things\r\n\r\nCan you give an example of where this is better than f-strings, preferably one that isn't stylistic?"
    },
    {
      "id": 747827663,
      "user": "WeatherGod",
      "body": "I never claimed it was better. I just said that it was a perfectly fine way\nof doing things and not obsolete. There isn't anything inherently wrong\nwith it. What is nice is its symplicity, but that is a stylistic concern.\nAs far as I am aware, the python devs have given no signal that %-style\nformatting will ever be removed.\n\nOn Thu, Dec 17, 2020 at 9:25 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> Just a quibble on an assertion made earlier in the thread. %-style\n> formatting is *not* obsolete or discouraged, per se. It is a perfectly\n> fine\n> way of doing things\n>\n> Can you give an example of where this is better than f-strings, preferably\n> one that isn't stylistic?\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747826102>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6B76AM5DLAPNHWWKSDSVK4SLANCNFSM4U62G7QA>\n> .\n>\n"
    },
    {
      "id": 747830046,
      "user": "CharlesHe16",
      "body": "People can have opinions and prefer different ways of doing things. Still, having a single way of doing things is an advantage and personal preference doesn't seem to be a good argument.\r\n\r\nYou don't have a reason as to why %-formatting is better, and seem to agree it may be no better. \r\n\r\nOn the other hand, I can present reasons why f-strings are better (they are described in the PEP)\r\n\r\n>I have actually used these three features together a few times in\r\nnested configuration systems for some projects.\r\n\r\nIt seems objectively worse to mix three different formats. \r\n\r\nArguing about this from an ego or preference point of view seems very unpromising and I don't seek to do this. \r\n\r\nI want to understand your opinions if there is content that makes anything of what I said above incorrect."
    },
    {
      "id": 747832850,
      "user": "jklymak",
      "body": "C-style string formatting is immediately familiar to anyone who has used most other programming languages.  F strings, not so much.  "
    },
    {
      "id": 747864699,
      "user": "WeatherGod",
      "body": "Please stop reading more into what I have written than is actually there.\nThere is no ego being expressed or preference being stated. I explicitly\nsaid at the beginning that I had a quibble with your claim that the python\ndocumentation made it seem like %-formatting was \"obsolete and\ndiscouraged\". This is *not* the case. That is all I was saying! Please do\nnot continue this false narrative.\n\nI like str.format()-style formatting for many reasons, particularly the\nability to create custom format notations, al la datetime objects. I\nactually have no objection with extending sanskey somehow to also include\nother formatting methods. Perhaps we could utilize the tick formatter\ninfrastructure to do this?\n\nThe only reason why I said anything in this conversation is to dispel the\nmyth that %-formatting is somehow obsolete and discouraged in python (your\nwords). In fact, the documentation makes it clear that there are times when\nhaving both types of formatting available is preferable (I don't have a\nreference on-hand, unfortunately). \"Obsolete and discouraged\" implies a\nmovement towards deprecation and removal from python, which is *not* the\ncase.\n\n\nOn Thu, Dec 17, 2020 at 9:38 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> People can have opinions and prefer different ways of doing things. Still,\n> having a single way of doing things is an advantage and personal preference\n> doesn't seem to be a good argument.\n>\n> You don't have a reason as to why %-formatting is better, and seem to\n> agree it may be no better.\n>\n> On the other hand, I can present reasons why f-strings are better (they\n> are described in the PEP)\n>\n> I have actually used these three features together a few times in\n> nested configuration systems for some projects.\n>\n> It seems objectively worse to mix three different formats.\n>\n> Arguing about this from an ego or preference point of view seems very\n> unpromising and I don't seek to do this.\n>\n> I want to understand your opinions if there is content that makes anything\n> of what I said above incorrect.\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747830046>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6EU27AKMWP5T6HBHADSVK6DJANCNFSM4U62G7QA>\n> .\n>\n"
    },
    {
      "id": 748142741,
      "user": "tacaswell",
      "body": "Can we put a lid on the relative merits of the string formatting styles?  They all exist in the Python language which is something we have to support.   If you want to have a discussion about changing that or the relative strengths, please take that to python-ideas@python.org ;).\r\n\r\n----\r\n\r\nIf we were going to extend this API to support new-style format strings I think we should go the route (riffing on some of Antony's comments else where) of accepting either a string (which is formatted with `%`) or a callable that accepts a number and returns a string (so `'{.2f}'.format` would be a valid input).  We don't pick up coupled kwargs and there is a reliable way to tell which input the user gave us, and we maintain full back-compatibility.  \r\n\r\nIt also gives the user far _more_ power as now they can inject an arbitrary function and, for example, map number to emoji."
    },
    {
      "id": 748147430,
      "user": "tacaswell",
      "body": "If folks agree with the `str` or `callable` path, I think this is a good first issue as the API extension is narrow and self-contained to the sankey code.  It will need docs, tests, an example, and a whats-new entry."
    },
    {
      "id": 748181664,
      "user": "ianhi",
      "body": "> self-contained to the sankey code.\r\n\r\nThere are a few other places in matplotlib that have similar string formatting. It would be nice if a change to accept both types of formatting was applied uniformly across them. Most notable (to me at least) is the Slider widgets which also use `%` style formatting. grepping around I also found \r\nhttps://github.com/matplotlib/matplotlib/blob/67aa50d164669a1340fe05e06dfc7223e25c87b3/lib/matplotlib/contour.py#L918-L919\r\n\r\nwhich only allows for callables. It would be nice these were all consistent and all allowed for both styles."
    },
    {
      "id": 748211761,
      "user": "jklymak",
      "body": "I think `clabel` should probably be the gold-standard here?  https://matplotlib.org/3.3.0/api/contour_api.html#matplotlib.contour.ContourLabeler.clabel\r\n\r\n```\r\n        fmt : `.Formatter` or str or callable or dict, optional\r\n            How the levels are formatted:\r\n\r\n            - If a `.Formatter`, it is used to format all levels at once, using\r\n              its `.Formatter.format_ticks` method.\r\n            - If a str, it is interpreted as a %-style format string.\r\n            - If a callable, it is called with one level at a time and should\r\n              return the corresponding label.\r\n            - If a dict, it should directly map levels to labels.\r\n\r\n            The default is to use a standard `.ScalarFormatter`.\r\n```\r\n\r\nSo maybe what `clabel` does should be made a `_api` helper and used elsewhere?   (basically `ContourLabeller.get_text`)"
    },
    {
      "id": 748228792,
      "user": "tacaswell",
      "body": "I have a small concern about the Formatter and dict layers.  The first seems tuned to clabel needing many strings (not just one) and the second seems a shortcut to `fmt=lambda x: my_dict[x]`."
    },
    {
      "id": 748329641,
      "user": "timhoffm",
      "body": "Agree that `Formatter` and `dict` are not very useful in general, and in particular for Sankey.\r\n\r\nAlso, with str and callable, you can do everything."
    },
    {
      "id": 748404124,
      "user": "CharlesHe16",
      "body": "I think I understand @tacaswell's solution with the `str or callable` route. This makes sense.\r\n\r\nPlus, we could then measure flows in nyan cats: \r\n\r\n<img src=\"https://user-images.githubusercontent.com/23063929/102678266-29dbcf00-415c-11eb-967a-c3f7d8a15164.png\" width=\"80\"><img src=\"https://user-images.githubusercontent.com/23063929/102678266-29dbcf00-415c-11eb-967a-c3f7d8a15164.png\" width=\"80\">\r\n\r\nI see the issue is in \"unassigned\" and \"needs sorting\". Some issues have been in those categories for a long time. \r\n\r\nWhat's the next step?\r\n\r\n\r\n\r\n"
    },
    {
      "id": 750506578,
      "user": "timhoffm",
      "body": "**The desired API is deciced based on the above discussion:** In addition to the existing string, the `format` parameter should support a callable.\r\n\r\n**Next step:** Someone needs to open a pull request with the desired change.\r\n\r\nI'm labeling this as \"Good first issue\" because the extension is straight forward, and you can take\r\n\r\n- https://matplotlib.org/devdocs/api/contour_api.html#matplotlib.contour.ContourLabeler.clabel `fmt` or\r\n- https://matplotlib.org/devdocs/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie `autopct`\r\n\r\nas a template."
    },
    {
      "id": 750903780,
      "user": "tacaswell",
      "body": "We do not use the \"assign\" feature of the GH (it makes lots of sense in an organization where everyone working on the code is an employee in a reporting chain and part of the org, it makes less sense in a community project where most contributors are volunteers and many are not in the org).\r\n\r\nI have re-milestoned this to 3.5 (the next-next feature release) because we are aiming to have 3.4 out \"soon\", this is not something we should block 3.4 on and work has not started yet.\r\n\r\n@CharlesHe16 If you are interested in working on this that would be great :)"
    },
    {
      "id": 751909863,
      "user": "CharlesHe16",
      "body": "Ok, I did something! I've created a [pull request, 19187](https://github.com/matplotlib/matplotlib/pull/19187).\r\n\r\nBy the way, as the [Contributor part of this Guide put it](https://matplotlib.org/devdocs/devel/contributing.html), I \"feel insecure about it\". \r\n\r\nIf anyone has a little time, it would be helpful to point out any errors I've made, either in content or procedure, and briefly suggest how to address it.\r\n\r\nThanks!"
    },
    {
      "id": 753702477,
      "user": "timhoffm",
      "body": "Ping @tacaswell @jklymak: Please add @CharlesHe16 to the `#incubator` channel if not already done so."
    },
    {
      "id": 753705950,
      "user": "jklymak",
      "body": "They would have to add themselves to gitter first I think"
    },
    {
      "id": 753760948,
      "user": "CharlesHe16",
      "body": "\r\nOk, I don't know what being added to the `#incubator` channel means, but I'm all for it!\r\n\r\n> They would have to add themselves to gitter first I think\r\n\r\nI'm not familiar with Gitter, but I think I signed up using my Github account. \r\n\r\nI cannot find a way to get a \"profile page\" on Gitter, but I think I show up on searches, producing this URL: https://gitter.im/CharlesHe16\r\n\r\nMy Gitter user id might be: `5ff29b01d73408ce4ff7ea92 `"
    },
    {
      "id": 871365981,
      "user": "tacaswell",
      "body": "Closed by #19187"
    }
  ],
  "text_context": "# Accept additional string formatting styles in sankey\n\nCurrently, Sankey class accepts number formatting for labels using the old printf string formatting. \r\n\r\nI think the relevant line is here:\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/a02ffbcd898793c95de66d3bdb4dc0a8b6c5a3d0/lib/matplotlib/sankey.py#L742\r\n\r\nF-strings seem to be preferred over this format (you probably know this already but here's [some reasons](https://realpython.com/python-formatted-output/)). A specific reason is that I can't easily use thousands separator with the old printf format, while this is trivial with f-strings.\r\n\r\nI can rewrite this pretty easily by changing the parameter to format for an f string, [as described here](https://stackoverflow.com/a/54780825).\r\n\r\nCan I put in a pull request thingy? Or is there a particular reason for this old format?\n\nIt's the old format because this has already existed for a long time. We cannot simply switch to another formatting mechanism because of backward-compatibility. That would break user code.\r\n\r\nI haven't thought this through completely, but I don't think you can use f-strings here because the definition of the string and the formatting are separated, but f-strings are immediately evaluated. It might be possible to use classic `{}`-formatting. But you would have to make sure that `%`-style formatting is still supported and edge-cases (in particular using curly braces and % in the respective other format) are handled correctly.\n\n> I haven't thought this through completely, but I don't think you can use f-strings here because the definition of the string and the formatting are separated, but f-strings are immediately evaluated. \r\n\r\nNo, f-string formatting can be separated, just as the fprint format is separated now. Try for yourself:\r\n\r\n```\r\nformat_f_string = '.2f'\r\n\r\nprint(f'test string: {42:{format_f_string}}')\r\n\r\nformat_f_string = '.0f'\r\n\r\nprint(f'test string: {42:{format_f_string}}')\r\n```\r\n\r\n```\r\n>>42.00\r\n\r\n>>42\r\n```\r\n\r\n> It's the old format because this has already existed for a long time. We cannot simply switch to another formatting mechanism because of backward-compatibility. That would break user code.**\r\n\r\nNot trying to argue or even persuade, but genuinely curious: things get deprecated all the time. \r\n\r\nWhat is the criteria or threshold for changing the format? The fprint or string modulo seems arcane and is discouraged by Python 3 docs. \r\n\r\n>But you would have to make sure that %-style formatting is still supported and edge-cases (in particular using curly braces and % in the respective other format) are handled correctly.\r\n\r\nOk. So I would need to find a way to easily decide whether something is an f-strings format or a string modulo format.\r\n\r\nAlternatively, would you accept an additional parameter such as \"f_string_format\" in addition to \"format\", or is that too much gore?\r\n\r\n\n\n> No, f-string formatting can be separated, just as the fprint format is separated now. Try for yourself:\r\n\r\nThat example is not strictly equivalent to what's supported in `Sankey`, as it only determines the format of a value, whereas the %-string could contain anything so long as it only interpolated one value. In its usage, the format was only used for determining how a single value was formatted, but there was nothing ensuring that that would be the case, i.e., passing `format='Flow #%d'` was a possibility.\n\n@QuLogic this makes sense.\r\n\r\nI guess one solution is to have a second mode of use for when the user enters a tuple. \r\n\r\nThe first element of the tuple provides any additional text content, and the second element contains formatting for the f string.\r\n\r\nFor example `format=('test string %D', '.2f')` with the value of 5 produces `'test string 5.00'`.\r\n\r\nThis seems awkward and niche.\n\n> Not trying to argue or even persuade, but genuinely curious: things get deprecated all the time.\r\n\r\n> What is the criteria or threshold for changing the format?\r\n\r\nFor every deprecation we carefully weigh the benefit (clean, intuitive, consistent, ... API) against cost (users have to re-learn, existing code must be changed).\r\n\r\nFor the sankey format IMHO the benefit is small. It is true that %-formatting has its quirks but it's still a standard and well-known API of Python. And users of `format` will likely need to read the docs anyway to learn about the feature; either way `format` is not canonical enough so that a user could guess what can be passed. OTOH every user of `format` would be affected by the deprecation.\r\n\r\nI'm against different modes or multiple parameters. That would over-complicate the API. There should only be one `format` parameter and it should unambiguously specify what to do (even though multiple kinds of input may be permissive).\r\n\r\nCurrent API is\r\n~~~\r\nSankey(..., format='%.2f')\r\n~~~\r\n\r\nI could imaging extending to `str.format` (https://docs.python.org/3.9/library/stdtypes.html#str.format) i.e.\r\n~~~\r\nSankey(..., format='{0:.2f}')\r\n~~~\r\nis valid. That could possibly be checked by `re.match('.*{0(?:.*)}', format)` or similar. That would give you the full flexibility of the [Format String Syntax](https://docs.python.org/3.9/library/string.html#formatstrings).\r\n\r\nI don't see how an f-string can be helpful here.\n\nHi Tim,\r\n\r\n>For every deprecation we carefully weigh the benefit (clean, intuitive, consistent, ... API) against cost (users have to re-learn, existing code must be changed).\r\n\r\n>For the sankey format IMHO the benefit is small. It is true that %-formatting has its quirks but it's still a standard and well-known API of Python. And users of format will likely need to read the docs anyway to learn about the feature; either way format is not canonical enough so that a user could guess what can be passed. OTOH every user of format would be affected by the deprecation.\r\n\r\nThis makes sense, thanks for explaining with as much precision as you did. \r\n\r\n>I don't see how an f-string can be helpful here.\r\n\r\nI expect you're right and I will follow this.\r\n\r\nBasically, f-strings are my way of putting numbers in strings. I've used str.format and also %-formatting in the past, and to me, f-string seems to dominate these other methods. \r\n\r\nIn fact, until reading your message, I believed that f-strings are the one best canonical way of putting numbers in strings, so I planned to \"upgrade\" `format` with them.\r\n\r\nZooming out, I agree this seems niche. \r\n\r\nI am willing to write a pull request to use str.format if you explicitly say this is useful, otherwise I will just monkey patch or move on.\r\n\r\n\n\nJust a quibble on an assertion made earlier in the thread. %-style\nformatting is *not* obsolete or discouraged, per se. It is a perfectly fine\nway of doing things. str.format() (and by extension, f-strings) are\npowerful in other ways. And don't forget about the lowly string templating\nmodule! I have actually used these three features together a few times in\nnested configuration systems for some projects.\n\nIt isn't going away any time soon.\n\nOn Thu, Dec 17, 2020 at 9:05 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> Hi Tim,\n>\n> For every deprecation we carefully weigh the benefit (clean, intuitive,\n> consistent, ... API) against cost (users have to re-learn, existing code\n> must be changed).\n>\n> For the sankey format IMHO the benefit is small. It is true that\n> %-formatting has its quirks but it's still a standard and well-known API of\n> Python. And users of format will likely need to read the docs anyway to\n> learn about the feature; either way format is not canonical enough so that\n> a user could guess what can be passed. OTOH every user of format would be\n> affected by the deprecation.\n>\n> This makes sense, thanks for explaining with as much precision as you did.\n>\n> I don't see how an f-string can be helpful here.\n>\n> I expect you're right and I will follow this.\n>\n> Basically, f-strings are my way of putting numbers in strings. I've used\n> str.format and also %-formatting in the past, and to me, f-string seems to\n> dominate these other methods.\n>\n> In fact, until reading your message, I believed that f-strings are the one\n> best canonical way of putting numbers in strings, so I planned to \"upgrade\"\n> format with them.\n>\n> Zooming out, I agree this seems niche.\n>\n> I am willing to write a pull request to use str.format if you explicitly\n> say this is useful, otherwise I will just monkey patch or move on.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747820184>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6ASAOK3FDU4IVMM4LDSVK2GZANCNFSM4U62G7QA>\n> .\n>\n\n\n>Just a quibble on an assertion made earlier in the thread. %-style\r\nformatting is *not* obsolete or discouraged, per se. It is a perfectly fine\r\nway of doing things\r\n\r\nCan you give an example of where this is better than f-strings, preferably one that isn't stylistic?\n\nI never claimed it was better. I just said that it was a perfectly fine way\nof doing things and not obsolete. There isn't anything inherently wrong\nwith it. What is nice is its symplicity, but that is a stylistic concern.\nAs far as I am aware, the python devs have given no signal that %-style\nformatting will ever be removed.\n\nOn Thu, Dec 17, 2020 at 9:25 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> Just a quibble on an assertion made earlier in the thread. %-style\n> formatting is *not* obsolete or discouraged, per se. It is a perfectly\n> fine\n> way of doing things\n>\n> Can you give an example of where this is better than f-strings, preferably\n> one that isn't stylistic?\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747826102>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6B76AM5DLAPNHWWKSDSVK4SLANCNFSM4U62G7QA>\n> .\n>\n\n\nPeople can have opinions and prefer different ways of doing things. Still, having a single way of doing things is an advantage and personal preference doesn't seem to be a good argument.\r\n\r\nYou don't have a reason as to why %-formatting is better, and seem to agree it may be no better. \r\n\r\nOn the other hand, I can present reasons why f-strings are better (they are described in the PEP)\r\n\r\n>I have actually used these three features together a few times in\r\nnested configuration systems for some projects.\r\n\r\nIt seems objectively worse to mix three different formats. \r\n\r\nArguing about this from an ego or preference point of view seems very unpromising and I don't seek to do this. \r\n\r\nI want to understand your opinions if there is content that makes anything of what I said above incorrect.\n\nC-style string formatting is immediately familiar to anyone who has used most other programming languages.  F strings, not so much.  \n\nPlease stop reading more into what I have written than is actually there.\nThere is no ego being expressed or preference being stated. I explicitly\nsaid at the beginning that I had a quibble with your claim that the python\ndocumentation made it seem like %-formatting was \"obsolete and\ndiscouraged\". This is *not* the case. That is all I was saying! Please do\nnot continue this false narrative.\n\nI like str.format()-style formatting for many reasons, particularly the\nability to create custom format notations, al la datetime objects. I\nactually have no objection with extending sanskey somehow to also include\nother formatting methods. Perhaps we could utilize the tick formatter\ninfrastructure to do this?\n\nThe only reason why I said anything in this conversation is to dispel the\nmyth that %-formatting is somehow obsolete and discouraged in python (your\nwords). In fact, the documentation makes it clear that there are times when\nhaving both types of formatting available is preferable (I don't have a\nreference on-hand, unfortunately). \"Obsolete and discouraged\" implies a\nmovement towards deprecation and removal from python, which is *not* the\ncase.\n\n\nOn Thu, Dec 17, 2020 at 9:38 PM CharlesHe16 <notifications@github.com>\nwrote:\n\n> People can have opinions and prefer different ways of doing things. Still,\n> having a single way of doing things is an advantage and personal preference\n> doesn't seem to be a good argument.\n>\n> You don't have a reason as to why %-formatting is better, and seem to\n> agree it may be no better.\n>\n> On the other hand, I can present reasons why f-strings are better (they\n> are described in the PEP)\n>\n> I have actually used these three features together a few times in\n> nested configuration systems for some projects.\n>\n> It seems objectively worse to mix three different formats.\n>\n> Arguing about this from an ego or preference point of view seems very\n> unpromising and I don't seek to do this.\n>\n> I want to understand your opinions if there is content that makes anything\n> of what I said above incorrect.\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/19133#issuecomment-747830046>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6EU27AKMWP5T6HBHADSVK6DJANCNFSM4U62G7QA>\n> .\n>\n\n\nCan we put a lid on the relative merits of the string formatting styles?  They all exist in the Python language which is something we have to support.   If you want to have a discussion about changing that or the relative strengths, please take that to python-ideas@python.org ;).\r\n\r\n----\r\n\r\nIf we were going to extend this API to support new-style format strings I think we should go the route (riffing on some of Antony's comments else where) of accepting either a string (which is formatted with `%`) or a callable that accepts a number and returns a string (so `'{.2f}'.format` would be a valid input).  We don't pick up coupled kwargs and there is a reliable way to tell which input the user gave us, and we maintain full back-compatibility.  \r\n\r\nIt also gives the user far _more_ power as now they can inject an arbitrary function and, for example, map number to emoji.\n\nIf folks agree with the `str` or `callable` path, I think this is a good first issue as the API extension is narrow and self-contained to the sankey code.  It will need docs, tests, an example, and a whats-new entry.\n\n> self-contained to the sankey code.\r\n\r\nThere are a few other places in matplotlib that have similar string formatting. It would be nice if a change to accept both types of formatting was applied uniformly across them. Most notable (to me at least) is the Slider widgets which also use `%` style formatting. grepping around I also found \r\nhttps://github.com/matplotlib/matplotlib/blob/67aa50d164669a1340fe05e06dfc7223e25c87b3/lib/matplotlib/contour.py#L918-L919\r\n\r\nwhich only allows for callables. It would be nice these were all consistent and all allowed for both styles.\n\nI think `clabel` should probably be the gold-standard here?  https://matplotlib.org/3.3.0/api/contour_api.html#matplotlib.contour.ContourLabeler.clabel\r\n\r\n```\r\n        fmt : `.Formatter` or str or callable or dict, optional\r\n            How the levels are formatted:\r\n\r\n            - If a `.Formatter`, it is used to format all levels at once, using\r\n              its `.Formatter.format_ticks` method.\r\n            - If a str, it is interpreted as a %-style format string.\r\n            - If a callable, it is called with one level at a time and should\r\n              return the corresponding label.\r\n            - If a dict, it should directly map levels to labels.\r\n\r\n            The default is to use a standard `.ScalarFormatter`.\r\n```\r\n\r\nSo maybe what `clabel` does should be made a `_api` helper and used elsewhere?   (basically `ContourLabeller.get_text`)\n\nI have a small concern about the Formatter and dict layers.  The first seems tuned to clabel needing many strings (not just one) and the second seems a shortcut to `fmt=lambda x: my_dict[x]`.\n\nAgree that `Formatter` and `dict` are not very useful in general, and in particular for Sankey.\r\n\r\nAlso, with str and callable, you can do everything.\n\nI think I understand @tacaswell's solution with the `str or callable` route. This makes sense.\r\n\r\nPlus, we could then measure flows in nyan cats: \r\n\r\n<img src=\"https://user-images.githubusercontent.com/23063929/102678266-29dbcf00-415c-11eb-967a-c3f7d8a15164.png\" width=\"80\"><img src=\"https://user-images.githubusercontent.com/23063929/102678266-29dbcf00-415c-11eb-967a-c3f7d8a15164.png\" width=\"80\">\r\n\r\nI see the issue is in \"unassigned\" and \"needs sorting\". Some issues have been in those categories for a long time. \r\n\r\nWhat's the next step?\r\n\r\n\r\n\r\n\n\n**The desired API is deciced based on the above discussion:** In addition to the existing string, the `format` parameter should support a callable.\r\n\r\n**Next step:** Someone needs to open a pull request with the desired change.\r\n\r\nI'm labeling this as \"Good first issue\" because the extension is straight forward, and you can take\r\n\r\n- https://matplotlib.org/devdocs/api/contour_api.html#matplotlib.contour.ContourLabeler.clabel `fmt` or\r\n- https://matplotlib.org/devdocs/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie `autopct`\r\n\r\nas a template.\n\nWe do not use the \"assign\" feature of the GH (it makes lots of sense in an organization where everyone working on the code is an employee in a reporting chain and part of the org, it makes less sense in a community project where most contributors are volunteers and many are not in the org).\r\n\r\nI have re-milestoned this to 3.5 (the next-next feature release) because we are aiming to have 3.4 out \"soon\", this is not something we should block 3.4 on and work has not started yet.\r\n\r\n@CharlesHe16 If you are interested in working on this that would be great :)\n\nOk, I did something! I've created a [pull request, 19187](https://github.com/matplotlib/matplotlib/pull/19187).\r\n\r\nBy the way, as the [Contributor part of this Guide put it](https://matplotlib.org/devdocs/devel/contributing.html), I \"feel insecure about it\". \r\n\r\nIf anyone has a little time, it would be helpful to point out any errors I've made, either in content or procedure, and briefly suggest how to address it.\r\n\r\nThanks!\n\nPing @tacaswell @jklymak: Please add @CharlesHe16 to the `#incubator` channel if not already done so.\n\nThey would have to add themselves to gitter first I think\n\n\r\nOk, I don't know what being added to the `#incubator` channel means, but I'm all for it!\r\n\r\n> They would have to add themselves to gitter first I think\r\n\r\nI'm not familiar with Gitter, but I think I signed up using my Github account. \r\n\r\nI cannot find a way to get a \"profile page\" on Gitter, but I think I show up on searches, producing this URL: https://gitter.im/CharlesHe16\r\n\r\nMy Gitter user id might be: `5ff29b01d73408ce4ff7ea92 `\n\nClosed by #19187",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/19187",
  "code_context": [
    {
      "filename": "lib/matplotlib/sankey.py",
      "content": "\"\"\"\nModule for creating Sankey diagrams using Matplotlib.\n\"\"\"\n\nimport logging\nfrom types import SimpleNamespace\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib import docstring\n\n_log = logging.getLogger(__name__)\n\n__author__ = \"Kevin L. Davies\"\n__credits__ = [\"Yannick Copin\"]\n__license__ = \"BSD\"\n__version__ = \"2011/09/16\"\n\n# Angles [deg/90]\nRIGHT = 0\nUP = 1\n# LEFT = 2\nDOWN = 3\n\n\nclass Sankey:\n    \"\"\"\n    Sankey diagram.\n\n      Sankey diagrams are a specific type of flow diagram, in which\n      the width of the arrows is shown proportionally to the flow\n      quantity.  They are typically used to visualize energy or\n      material or cost transfers between processes.\n      `Wikipedia (6/1/2011) <https://en.wikipedia.org/wiki/Sankey_diagram>`_\n\n    \"\"\"\n\n    def __init__(self, ax=None, scale=1.0, unit='', format='%G', gap=0.25,\n                 radius=0.1, shoulder=0.03, offset=0.15, head_angle=100,\n                 margin=0.4, tolerance=1e-6, **kwargs):\n        \"\"\"\n        Create a new Sankey instance.\n\n        The optional arguments listed below are applied to all subdiagrams so\n        that there is consistent alignment and formatting.\n\n        In order to draw a complex Sankey diagram, create an instance of\n        :class:`Sankey` by calling it without any kwargs::\n\n            sankey = Sankey()\n\n        Then add simple Sankey sub-diagrams::\n\n            sankey.add() # 1\n            sankey.add() # 2\n            #...\n            sankey.add() # n\n\n        Finally, create the full diagram::\n\n            sankey.finish()\n\n        Or, instead, simply daisy-chain those calls::\n\n            Sankey().add().add...  .add().finish()\n\n        Other Parameters\n        ----------------\n        ax : `~.axes.Axes`\n            Axes onto which the data should be plotted.  If *ax* isn't\n            provided, new Axes will be created.\n        scale : float\n            Scaling factor for the flows.  *scale* sizes the width of the paths\n            in order to maintain proper layout.  The same scale is applied to\n            all subdiagrams.  The value should be chosen such that the product\n            of the scale and the sum of the inputs is approximately 1.0 (and\n            the product of the scale and the sum of the outputs is\n            approximately -1.0).\n        unit : str\n            The physical unit associated with the flow quantities.  If *unit*\n            is None, then none of the quantities are labeled.\n        format : str or callable\n            A Python number formatting string or callable used to label the\n            flows with their quantities (i.e., a number times a unit, where the\n            unit is given). If a format string is given, the label will be\n            ``format % quantity``. If a callable is given, it will be called\n            with ``quantity`` as an argument.\n        gap : float\n            Space between paths that break in/break away to/from the top or\n            bottom.\n        radius : float\n            Inner radius of the vertical paths.\n        shoulder : float\n            Size of the shoulders of output arrows.\n        offset : float\n            Text offset (from the dip or tip of the arrow).\n        head_angle : float\n            Angle, in degrees, of the arrow heads (and negative of the angle of\n            the tails).\n        margin : float\n            Minimum space between Sankey outlines and the edge of the plot\n            area.\n        tolerance : float\n            Acceptable maximum of the magnitude of the sum of flows.  The\n            magnitude of the sum of connected flows cannot be greater than\n            *tolerance*.\n        **kwargs\n            Any additional keyword arguments will be passed to :meth:`add`,\n            which will create the first subdiagram.\n\n        See Also\n        --------\n        Sankey.add\n        Sankey.finish\n\n        Examples\n        --------\n        .. plot:: gallery/specialty_plots/sankey_basics.py\n        \"\"\"\n        # Check the arguments.\n        if gap < 0:\n            raise ValueError(\n                \"'gap' is negative, which is not allowed because it would \"\n                \"cause the paths to overlap\")\n        if radius > gap:\n            raise ValueError(\n                \"'radius' is greater than 'gap', which is not allowed because \"\n                \"it would cause the paths to overlap\")\n        if head_angle < 0:\n            raise ValueError(\n                \"'head_angle' is negative, which is not allowed because it \"\n                \"would cause inputs to look like outputs and vice versa\")\n        if tolerance < 0:\n            raise ValueError(\n                \"'tolerance' is negative, but it must be a magnitude\")\n\n        # Create axes if necessary.\n        if ax is None:\n            import matplotlib.pyplot as plt\n            fig = plt.figure()\n            ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[])\n\n        self.diagrams = []\n\n        # Store the inputs.\n        self.ax = ax\n        self.unit = unit\n        self.format = format\n        self.scale = scale\n        self.gap = gap\n        self.radius = radius\n        self.shoulder = shoulder\n        self.offset = offset\n        self.margin = margin\n        self.pitch = np.tan(np.pi * (1 - head_angle / 180.0) / 2.0)\n        self.tolerance = tolerance\n\n        # Initialize the vertices of tight box around the diagram(s).\n        self.extent = np.array((np.inf, -np.inf, np.inf, -np.inf))\n\n        # If there are any kwargs, create the first subdiagram.\n        if len(kwargs):\n            self.add(**kwargs)\n\n    def _arc(self, quadrant=0, cw=True, radius=1, center=(0, 0)):\n        \"\"\"\n        Return the codes and vertices for a rotated, scaled, and translated\n        90 degree arc.\n\n        Other Parameters\n        ----------------\n        quadrant : {0, 1, 2, 3}, default: 0\n            Uses 0-based indexing (0, 1, 2, or 3).\n        cw : bool, default: True\n            If True, the arc vertices are produced clockwise; counter-clockwise\n            otherwise.\n        radius : float, default: 1\n            The radius of the arc.\n        center : (float, float), default: (0, 0)\n            (x, y) tuple of the arc's center.\n        \"\"\"\n        # Note:  It would be possible to use matplotlib's transforms to rotate,\n        # scale, and translate the arc, but since the angles are discrete,\n        # it's just as easy and maybe more efficient to do it here.\n        ARC_CODES = [Path.LINETO,\n                     Path.CURVE4,\n                     Path.CURVE4,\n                     Path.CURVE4,\n                     Path.CURVE4,\n                     Path.CURVE4,\n                     Path.CURVE4]\n        # Vertices of a cubic Bezier curve approximating a 90 deg arc\n        # These can be determined by Path.arc(0, 90).\n        ARC_VERTICES = np.array([[1.00000000e+00, 0.00000000e+00],\n                                 [1.00000000e+00, 2.65114773e-01],\n                                 [8.94571235e-01, 5.19642327e-01],\n                                 [7.07106781e-01, 7.07106781e-01],\n                                 [5.19642327e-01, 8.94571235e-01],\n                                 [2.65114773e-01, 1.00000000e+00],\n                                 # Insignificant\n                                 # [6.12303177e-17, 1.00000000e+00]])\n                                 [0.00000000e+00, 1.00000000e+00]])\n        if quadrant == 0 or quadrant == 2:\n            if cw:\n                vertices = ARC_VERTICES\n            else:\n                vertices = ARC_VERTICES[:, ::-1]  # Swap x and y.\n        elif quadrant == 1 or quadrant == 3:\n            # Negate x.\n            if cw:\n                # Swap x and y.\n                vertices = np.column_stack((-ARC_VERTICES[:, 1],\n                                             ARC_VERTICES[:, 0]))\n            else:\n                vertices = np.column_stack((-ARC_VERTICES[:, 0],\n                                             ARC_VERTICES[:, 1]))\n        if quadrant > 1:\n            radius = -radius  # Rotate 180 deg.\n        return list(zip(ARC_CODES, radius * vertices +\n                        np.tile(center, (ARC_VERTICES.shape[0], 1))))\n\n    def _add_input(self, path, angle, flow, length):\n        \"\"\"\n        Add an input to a path and return its tip and label locations.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            dipdepth = (flow / 2) * self.pitch\n            if angle == RIGHT:\n                x -= length\n                dip = [x + dipdepth, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x + self.gap, y + flow])])\n                label_location = [dip[0] - self.offset, dip[1]]\n            else:  # Vertical\n                x -= self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                dip = [x - flow / 2, y - sign * (length - dipdepth)]\n                if angle == DOWN:\n                    quadrant = 2\n                else:\n                    quadrant = 1\n\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x + self.radius,\n                                                  y - sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y - sign * length]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x - flow, y - sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=flow + self.radius,\n                                      center=(x + self.radius,\n                                              y - sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [dip[0], dip[1] - sign * self.offset]\n\n            return dip, label_location\n\n    def _add_output(self, path, angle, flow, length):\n        \"\"\"\n        Append an output to a path and return its tip and label locations.\n\n        .. note:: *flow* is negative for an output.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            tipheight = (self.shoulder - flow / 2) * self.pitch\n            if angle == RIGHT:\n                x += length\n                tip = [x + tipheight, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, [x, y + self.shoulder]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x, y - self.shoulder + flow]),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x - self.gap, y + flow])])\n                label_location = [tip[0] + self.offset, tip[1]]\n            else:  # Vertical\n                x += self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                tip = [x - flow / 2.0, y + sign * (length + tipheight)]\n                if angle == UP:\n                    quadrant = 3\n                else:\n                    quadrant = 0\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x - self.radius,\n                                                  y + sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y + sign * length]),\n                             (Path.LINETO, [x - self.shoulder,\n                                            y + sign * length]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x + self.shoulder - flow,\n                                            y + sign * length]),\n                             (Path.LINETO, [x - flow, y + sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=self.radius - flow,\n                                      center=(x - self.radius,\n                                              y + sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [tip[0], tip[1] + sign * self.offset]\n            return tip, label_location\n\n    def _revert(self, path, first_action=Path.LINETO):\n        \"\"\"\n        A path is not simply reversible by path[::-1] since the code\n        specifies an action to take from the **previous** point.\n        \"\"\"\n        reverse_path = []\n        next_code = first_action\n        for code, position in path[::-1]:\n            reverse_path.append((next_code, position))\n            next_code = code\n        return reverse_path\n        # This might be more efficient, but it fails because 'tuple' object\n        # doesn't support item assignment:\n        # path[1] = path[1][-1:0:-1]\n        # path[1][0] = first_action\n        # path[2] = path[2][::-1]\n        # return path\n\n    @docstring.dedent_interpd\n    def add(self, patchlabel='', flows=None, orientations=None, labels='',\n            trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0),\n            rotation=0, **kwargs):\n        \"\"\"\n        Add a simple Sankey diagram with flows at the same hierarchical level.\n\n        Parameters\n        ----------\n        patchlabel : str\n            Label to be placed at the center of the diagram.\n            Note that *label* (not *patchlabel*) can be passed as keyword\n            argument to create an entry in the legend.\n\n        flows : list of float\n            Array of flow values.  By convention, inputs are positive and\n            outputs are negative.\n\n            Flows are placed along the top of the diagram from the inside out\n            in order of their index within *flows*.  They are placed along the\n            sides of the diagram from the top down and along the bottom from\n            the outside in.\n\n            If the sum of the inputs and outputs is\n            nonzero, the discrepancy will appear as a cubic Bezier curve along\n            the top and bottom edges of the trunk.\n\n        orientations : list of {-1, 0, 1}\n            List of orientations of the flows (or a single orientation to be\n            used for all flows).  Valid values are 0 (inputs from\n            the left, outputs to the right), 1 (from and to the top) or -1\n            (from and to the bottom).\n\n        labels : list of (str or None)\n            List of labels for the flows (or a single label to be used for all\n            flows).  Each label may be *None* (no label), or a labeling string.\n            If an entry is a (possibly empty) string, then the quantity for the\n            corresponding flow will be shown below the string.  However, if\n            the *unit* of the main diagram is None, then quantities are never\n            shown, regardless of the value of this argument.\n\n        trunklength : float\n            Length between the bases of the input and output groups (in\n            data-space units).\n\n        pathlengths : list of float\n            List of lengths of the vertical arrows before break-in or after\n            break-away.  If a single value is given, then it will be applied to\n            the first (inside) paths on the top and bottom, and the length of\n            all other arrows will be justified accordingly.  The *pathlengths*\n            are not applied to the horizontal inputs and outputs.\n\n        prior : int\n            Index of the prior diagram to which this diagram should be\n            connected.\n\n        connect : (int, int)\n            A (prior, this) tuple indexing the flow of the prior diagram and\n            the flow of this diagram which should be connected.  If this is the\n            first diagram or *prior* is *None*, *connect* will be ignored.\n\n        rotation : float\n            Angle of rotation of the diagram in degrees.  The interpretation of\n            the *orientations* argument will be rotated accordingly (e.g., if\n            *rotation* == 90, an *orientations* entry of 1 means to/from the\n            left).  *rotation* is ignored if this diagram is connected to an\n            existing one (using *prior* and *connect*).\n\n        Returns\n        -------\n        Sankey\n            The current `.Sankey` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs\n           Additional keyword arguments set `matplotlib.patches.PathPatch`\n           properties, listed below.  For example, one may want to use\n           ``fill=False`` or ``label=\"A legend entry\"``.\n\n        %(Patch_kwdoc)s\n\n        See Also\n        --------\n        Sankey.finish\n        \"\"\"\n        # Check and preprocess the arguments.\n        if flows is None:\n            flows = np.array([1.0, -1.0])\n        else:\n            flows = np.array(flows)\n        n = flows.shape[0]  # Number of flows\n        if rotation is None:\n            rotation = 0\n        else:\n            # In the code below, angles are expressed in deg/90.\n            rotation /= 90.0\n        if orientations is None:\n            orientations = 0\n        try:\n            orientations = np.broadcast_to(orientations, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'orientations' \"\n                f\"{np.shape(orientations)} are incompatible\"\n            ) from None\n        try:\n            labels = np.broadcast_to(labels, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'labels' \"\n                f\"{np.shape(labels)} are incompatible\"\n            ) from None\n        if trunklength < 0:\n            raise ValueError(\n                \"'trunklength' is negative, which is not allowed because it \"\n                \"would cause poor layout\")\n        if abs(np.sum(flows)) > self.tolerance:\n            _log.info(\"The sum of the flows is nonzero (%f; patchlabel=%r); \"\n                      \"is the system not at steady state?\",\n                      np.sum(flows), patchlabel)\n        scaled_flows = self.scale * flows\n        gain = sum(max(flow, 0) for flow in scaled_flows)\n        loss = sum(min(flow, 0) for flow in scaled_flows)\n        if prior is not None:\n            if prior < 0:\n                raise ValueError(\"The index of the prior diagram is negative\")\n            if min(connect) < 0:\n                raise ValueError(\n                    \"At least one of the connection indices is negative\")\n            if prior >= len(self.diagrams):\n                raise ValueError(\n                    f\"The index of the prior diagram is {prior}, but there \"\n                    f\"are only {len(self.diagrams)} other diagrams\")\n            if connect[0] >= len(self.diagrams[prior].flows):\n                raise ValueError(\n                    \"The connection index to the source diagram is {}, but \"\n                    \"that diagram has only {} flows\".format(\n                        connect[0], len(self.diagrams[prior].flows)))\n            if connect[1] >= n:\n                raise ValueError(\n                    f\"The connection index to this diagram is {connect[1]}, \"\n                    f\"but this diagram has only {n} flows\")\n            if self.diagrams[prior].angles[connect[0]] is None:\n                raise ValueError(\n                    f\"The connection cannot be made, which may occur if the \"\n                    f\"magnitude of flow {connect[0]} of diagram {prior} is \"\n                    f\"less than the specified tolerance\")\n            flow_error = (self.diagrams[prior].flows[connect[0]] +\n                          flows[connect[1]])\n            if abs(flow_error) >= self.tolerance:\n                raise ValueError(\n                    f\"The scaled sum of the connected flows is {flow_error}, \"\n                    f\"which is not within the tolerance ({self.tolerance})\")\n\n        # Determine if the flows are inputs.\n        are_inputs = [None] * n\n        for i, flow in enumerate(flows):\n            if flow >= self.tolerance:\n                are_inputs[i] = True\n            elif flow <= -self.tolerance:\n                are_inputs[i] = False\n            else:\n                _log.info(\n                    \"The magnitude of flow %d (%f) is below the tolerance \"\n                    \"(%f).\\nIt will not be shown, and it cannot be used in a \"\n                    \"connection.\", i, flow, self.tolerance)\n\n        # Determine the angles of the arrows (before rotation).\n        angles = [None] * n\n        for i, (orient, is_input) in enumerate(zip(orientations, are_inputs)):\n            if orient == 1:\n                if is_input:\n                    angles[i] = DOWN\n                elif not is_input:\n                    # Be specific since is_input can be None.\n                    angles[i] = UP\n            elif orient == 0:\n                if is_input is not None:\n                    angles[i] = RIGHT\n            else:\n                if orient != -1:\n                    raise ValueError(\n                        f\"The value of orientations[{i}] is {orient}, \"\n                        f\"but it must be -1, 0, or 1\")\n                if is_input:\n                    angles[i] = UP\n                elif not is_input:\n                    angles[i] = DOWN\n\n        # Justify the lengths of the paths.\n        if np.iterable(pathlengths):\n            if len(pathlengths) != n:\n                raise ValueError(\n                    f\"The lengths of 'flows' ({n}) and 'pathlengths' \"\n                    f\"({len(pathlengths)}) are incompatible\")\n        else:  # Make pathlengths into a list.\n            urlength = pathlengths\n            ullength = pathlengths\n            lrlength = pathlengths\n            lllength = pathlengths\n            d = dict(RIGHT=pathlengths)\n            pathlengths = [d.get(angle, 0) for angle in angles]\n            # Determine the lengths of the top-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(zip(angles, are_inputs,\n                                                            scaled_flows)):\n                if angle == DOWN and is_input:\n                    pathlengths[i] = ullength\n                    ullength += flow\n                elif angle == UP and not is_input:\n                    pathlengths[i] = urlength\n                    urlength -= flow  # Flow is negative for outputs.\n            # Determine the lengths of the bottom-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(reversed(list(zip(\n                  angles, are_inputs, scaled_flows)))):\n                if angle == UP and is_input:\n                    pathlengths[n - i - 1] = lllength\n                    lllength += flow\n                elif angle == DOWN and not is_input:\n                    pathlengths[n - i - 1] = lrlength\n                    lrlength -= flow\n            # Determine the lengths of the left-side arrows\n            # from the bottom upwards.\n            has_left_input = False\n            for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n                  angles, are_inputs, zip(scaled_flows, pathlengths))))):\n                if angle == RIGHT:\n                    if is_input:\n                        if has_left_input:\n                            pathlengths[n - i - 1] = 0\n                        else:\n                            has_left_input = True\n            # Determine the lengths of the right-side arrows\n            # from the top downwards.\n            has_right_output = False\n            for i, (angle, is_input, spec) in enumerate(zip(\n                  angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n                if angle == RIGHT:\n                    if not is_input:\n                        if has_right_output:\n                            pathlengths[i] = 0\n                        else:\n                            has_right_output = True\n\n        # Begin the subpaths, and smooth the transition if the sum of the flows\n        # is nonzero.\n        urpath = [(Path.MOVETO, [(self.gap - trunklength / 2.0),  # Upper right\n                                 gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap),\n                                 -loss / 2.0])]\n        llpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower left\n                                 loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0),\n                                 -gain / 2.0])]\n        lrpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower right\n                                 loss / 2.0])]\n        ulpath = [(Path.LINETO, [self.gap - trunklength / 2.0,  # Upper left\n                                 gain / 2.0])]\n\n        # Add the subpaths and assign the locations of the tips and labels.\n        tips = np.zeros((n, 2))\n        label_locations = np.zeros((n, 2))\n        # Add the top-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == DOWN and is_input:\n                tips[i, :], label_locations[i, :] = self._add_input(\n                    ulpath, angle, *spec)\n            elif angle == UP and not is_input:\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Add the bottom-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == UP and is_input:\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n            elif angle == DOWN and not is_input:\n                tip, label_location = self._add_output(lrpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the left-side inputs from the bottom upwards.\n        has_left_input = False\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == RIGHT and is_input:\n                if not has_left_input:\n                    # Make sure the lower path extends\n                    # at least as far as the upper one.\n                    if llpath[-1][1][0] > ulpath[-1][1][0]:\n                        llpath.append((Path.LINETO, [ulpath[-1][1][0],\n                                                     llpath[-1][1][1]]))\n                    has_left_input = True\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the right-side outputs from the top downwards.\n        has_right_output = False\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == RIGHT and not is_input:\n                if not has_right_output:\n                    # Make sure the upper path extends\n                    # at least as far as the lower one.\n                    if urpath[-1][1][0] < lrpath[-1][1][0]:\n                        urpath.append((Path.LINETO, [lrpath[-1][1][0],\n                                                     urpath[-1][1][1]]))\n                    has_right_output = True\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Trim any hanging vertices.\n        if not has_left_input:\n            ulpath.pop()\n            llpath.pop()\n        if not has_right_output:\n            lrpath.pop()\n            urpath.pop()\n\n        # Concatenate the subpaths in the correct order (clockwise from top).\n        path = (urpath + self._revert(lrpath) + llpath + self._revert(ulpath) +\n                [(Path.CLOSEPOLY, urpath[0][1])])\n\n        # Create a patch with the Sankey outline.\n        codes, vertices = zip(*path)\n        vertices = np.array(vertices)\n\n        def _get_angle(a, r):\n            if a is None:\n                return None\n            else:\n                return a + r\n\n        if prior is None:\n            if rotation != 0:  # By default, none of this is needed.\n                angles = [_get_angle(angle, rotation) for angle in angles]\n                rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n                tips = rotate(tips)\n                label_locations = rotate(label_locations)\n                vertices = rotate(vertices)\n            text = self.ax.text(0, 0, s=patchlabel, ha='center', va='center')\n        else:\n            rotation = (self.diagrams[prior].angles[connect[0]] -\n                        angles[connect[1]])\n            angles = [_get_angle(angle, rotation) for angle in angles]\n            rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n            tips = rotate(tips)\n            offset = self.diagrams[prior].tips[connect[0]] - tips[connect[1]]\n            translate = Affine2D().translate(*offset).transform_affine\n            tips = translate(tips)\n            label_locations = translate(rotate(label_locations))\n            vertices = translate(rotate(vertices))\n            kwds = dict(s=patchlabel, ha='center', va='center')\n            text = self.ax.text(*offset, **kwds)\n        if mpl.rcParams['_internal.classic_mode']:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', '#bfd1d4'))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', 0.5))\n        else:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', None))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', None))\n        if fc is None:\n            fc = next(self.ax._get_patches_for_fill.prop_cycler)['color']\n        patch = PathPatch(Path(vertices, codes), fc=fc, lw=lw, **kwargs)\n        self.ax.add_patch(patch)\n\n        # Add the path labels.\n        texts = []\n        for number, angle, label, location in zip(flows, angles, labels,\n                                                  label_locations):\n            if label is None or angle is None:\n                label = ''\n            elif self.unit is not None:\n                if isinstance(self.format, str):\n                    quantity = self.format % abs(number) + self.unit\n                elif callable(self.format):\n                    quantity = self.format(number)\n                else:\n                    raise TypeError(\n                        'format must be callable or a format string')\n                if label != '':\n                    label += \"\\n\"\n                label += quantity\n            texts.append(self.ax.text(x=location[0], y=location[1],\n                                      s=label,\n                                      ha='center', va='center'))\n        # Text objects are placed even they are empty (as long as the magnitude\n        # of the corresponding flow is larger than the tolerance) in case the\n        # user wants to provide labels later.\n\n        # Expand the size of the diagram if necessary.\n        self.extent = (min(np.min(vertices[:, 0]),\n                           np.min(label_locations[:, 0]),\n                           self.extent[0]),\n                       max(np.max(vertices[:, 0]),\n                           np.max(label_locations[:, 0]),\n                           self.extent[1]),\n                       min(np.min(vertices[:, 1]),\n                           np.min(label_locations[:, 1]),\n                           self.extent[2]),\n                       max(np.max(vertices[:, 1]),\n                           np.max(label_locations[:, 1]),\n                           self.extent[3]))\n        # Include both vertices _and_ label locations in the extents; there are\n        # where either could determine the margins (e.g., arrow shoulders).\n\n        # Add this diagram as a subdiagram.\n        self.diagrams.append(\n            SimpleNamespace(patch=patch, flows=flows, angles=angles, tips=tips,\n                            text=text, texts=texts))\n\n        # Allow a daisy-chained call structure (see docstring for the class).\n        return self\n\n    def finish(self):\n        \"\"\"\n        Adjust the axes and return a list of information about the Sankey\n        subdiagram(s).\n\n        Return value is a list of subdiagrams represented with the following\n        fields:\n\n          ===============   ===================================================\n          Field             Description\n          ===============   ===================================================\n          *patch*           Sankey outline (an instance of\n                            :class:`~matplotlib.patches.PathPatch`)\n          *flows*           values of the flows (positive for input, negative\n                            for output)\n          *angles*          list of angles of the arrows [deg/90]\n                            For example, if the diagram has not been rotated,\n                            an input to the top side will have an angle of 3\n                            (DOWN), and an output from the top side will have\n                            an angle of 1 (UP).  If a flow has been skipped\n                            (because its magnitude is less than *tolerance*),\n                            then its angle will be *None*.\n          *tips*            array in which each row is an [x, y] pair\n                            indicating the positions of the tips (or \"dips\") of\n                            the flow paths\n                            If the magnitude of a flow is less the *tolerance*\n                            for the instance of :class:`Sankey`, the flow is\n                            skipped and its tip will be at the center of the\n                            diagram.\n          *text*            :class:`~matplotlib.text.Text` instance for the\n                            label of the diagram\n          *texts*           list of :class:`~matplotlib.text.Text` instances\n                            for the labels of flows\n          ===============   ===================================================\n\n        See Also\n        --------\n        Sankey.add\n        \"\"\"\n        self.ax.axis([self.extent[0] - self.margin,\n                      self.extent[1] + self.margin,\n                      self.extent[2] - self.margin,\n                      self.extent[3] + self.margin])\n        self.ax.set_aspect('equal', adjustable='datalim')\n        return self.diagrams\n"
    },
    {
      "filename": "lib/matplotlib/tests/test_sankey.py",
      "content": "from matplotlib.sankey import Sankey\n\n\ndef test_sankey():\n    # lets just create a sankey instance and check the code runs\n    sankey = Sankey()\n    sankey.add()\n\n\ndef test_label():\n    s = Sankey(flows=[0.25], labels=['First'], orientations=[-1])\n    assert s.diagrams[0].texts[0].get_text() == 'First\\n0.25'\n\n\ndef test_format_using_callable():\n    # test using callable by slightly incrementing above label example\n\n    def show_three_decimal_places(value):\n        return f'{value:.3f}'\n\n    s = Sankey(flows=[0.25], labels=['First'], orientations=[-1],\n               format=show_three_decimal_places)\n\n    assert s.diagrams[0].texts[0].get_text() == 'First\\n0.250'\n"
    }
  ]
}