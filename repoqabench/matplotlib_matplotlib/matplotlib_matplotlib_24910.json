{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "24910",
  "issue_description": "# [Bug]: Suptitle not visible with subfigures\n\n### Bug summary\r\n\r\nIn a fairly basic example using subfigures, a suptitle added to the parent figure is not visible:\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nf = plt.figure(figsize=(4, 3))\r\nsf1, sf2 = f.subfigures(1, 2)\r\nsf1.subplots()\r\nsf2.subplots()\r\nf.suptitle(\"It's a bird, it's a plane, it's a suptitle\")\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n![test](https://user-images.githubusercontent.com/315810/211206529-a3249ee9-6de1-4f0d-8be4-3e46f6f484dc.png)\r\n\r\n\r\n### Expected outcome\r\n\r\nVisible suptitle.\r\n\r\n### Additional information\r\n\r\nIt looks like this is happening because the subfigures have a solid facecolor that obscure the suptitle:\r\n\r\n```python\r\nf = plt.figure(figsize=(4, 3))\r\nsf1, sf2 = f.subfigures(1, 2)\r\nsf1.subplots()\r\nsf2.subplots()\r\nsf1.set_facecolor((.8, 0, 0, .3))\r\nf.suptitle(\"It's a bird, it's a plane, it's a suptitle\")\r\n```\r\n![test](https://user-images.githubusercontent.com/315810/211206669-1b39ecf7-ce7c-444b-851f-8e994538cee1.png)\r\n\r\nSetting the zorder of the suptitle to a large number has no apparent effect.\r\n\r\n\r\n### Matplotlib Version\r\n\r\n3.6.2\r\n\r\n### Matplotlib Backend\r\n\r\nmodule://matplotlib_inline.backend_inline",
  "issue_comments": [
    {
      "id": 1374889337,
      "user": "jklymak",
      "body": "I don't think we specifically set the background color of subfigures to anything different than a figure, which defaults to white.  We could, by default, make subfigures transparent, but not 100% clear to me that is the right thing to do.  \r\n\r\nFWIW, this problem goes away with `layout='constrained'` which makes the subfigure the correct size to allow the suptitle. "
    },
    {
      "id": 1375003642,
      "user": "mwaskom",
      "body": "> We could, by default, make subfigures transparent, but not 100% clear to me that is the right thing to do.\r\n\r\nI agree that this could have the potential to add unpredictable complexity, but in practice what do you think the failure mode would look like?\r\n\r\nIf the default subfigure facecolor is transparent, it will _appear_ as if the overlying subfigures have whatever facecolor is set for figures by default (i.e. in the rc params), so changing the figure default will still \"work\". And you could still have subfigures listen to the `facecolor` parameter passed when they are created, so users could make a subfigure within a larger figure that has a distinct background.\r\n\r\nThe only potential confusing situation that comes to mind is if a user set the rc parameter to a specific value, set the figure facecolor to a different value, and then expects a subfigure made without an explicit facecolor to follow the rc parameter rather than inherit from the parent. While that strikes me as unusual (I think I would maybe expect inheritance? but not sure) it seems like there's an easy route to the solution (\"ah, it's inheriting the parent figure color, so let me try setting the facecolor when I create the subfigure\").\r\n\r\nIn contrast, the root cause of the behavior here is not obvious; it just looks like the suptitle \"isn't working\" for some reason. Note how the seaborn issue was presented, it appeared to the user (who is sharp) that the suptitle was \"being removed\". It took me a while to determine that it's actually there, just \"under\" the subfigure (especially since zorder didn't work, which I tried first).\r\n\r\nAnd while it's good to know that constrained_layout will help with suptitle, I don't think tight_layout accounts for suptitles, and neither layout engine handles similar edge cases like manually added text artists representing captions or panel labels. (Right?)\r\n\r\nSo on balance, I think that making subfigures have transparent facecolors by default will strictly reduce surprise, but maybe I'm not thinking of a circumstance where that's not true."
    },
    {
      "id": 1375695630,
      "user": "thuiop",
      "body": "Ah, so that was what happened. I was really confused by the issue as I could still see that the Text object was correctly in the fig.texts ; I had also tried moving it around in the figure and it did not work, probably because it was still under the subfigures (although in my case I thought that I was using the constrained layout while seaborn actually deactivated it, which added to the confusion).\r\nI do agree that this is definitely an easy trap to fall in for which I would not expect a non-expert user to quickly find the solution (using constrained layout). There is probably a way to make the suptitle show above the subfigures anyway but it does not seem obvious to me ; I agree with the case for having transparent subfigures (but could be missing something as well)."
    },
    {
      "id": 1375750846,
      "user": "anntzer",
      "body": "Not that it really matters for the discussion here, but\r\n\r\n> I don't think tight_layout accounts for suptitles\r\n\r\nhas been fixed in https://github.com/matplotlib/matplotlib/pull/17219."
    },
    {
      "id": 1375786738,
      "user": "jklymak",
      "body": "Just to clarify - suptitles now works for simple cases that tight_layout works on.  However it does not work for subfigures or other nested layouts.  "
    },
    {
      "id": 1422027001,
      "user": "jklymak",
      "body": "> neither layout engine handles similar edge cases like manually added text artists representing captions or panel labels. (Right?)\r\n\r\nI'm not sure what you mean by this - certainly if you attach text to an axes, constrained_layout will make all the axes smaller to make sure there is no overlap, just like it does for titles and ticklabels...\r\n\r\nFor this particular issue, I think someone could easily put in a PR to make the default facecolor for subfigures \"none\" and see what people think.  I agree it's probably fine for 99.9% of cases, and easy to change to something else if desired.   I'll mark as a good first issue and I don't think its hard, though anyone interested in pursuing should be prepared to advocate for it.  "
    },
    {
      "id": 1422486379,
      "user": "mwaskom",
      "body": "> I'm not sure what you mean by this\r\n\r\nI would typically specify panel labels or a caption by adding text to the figure object, not the axes:\r\n\r\n```python\r\nf, axs = plt.subplots(2, 2, constrained_layout=True)\r\nf.text(.99, .01, \"Source: I made it up\", size=15, va=\"bottom\", ha=\"right\")\r\n```\r\n<img width=500 src=\"https://user-images.githubusercontent.com/315810/217524409-47a83ef3-bb36-4b4d-9123-1f9278b964c4.png\" />\r\n"
    },
    {
      "id": 1422644293,
      "user": "jklymak",
      "body": "Yes I see. Definitely the layout engines cannot avoid random figure objects, so space would have to be reserved for a \"caption\" like this. "
    },
    {
      "id": 1424239859,
      "user": "mwaskom",
      "body": "Yeah — there's a separate issue about adding a `Figure.caption` concept that layout algorithms could then be smart about (https://github.com/matplotlib/matplotlib/issues/23873) but the point here is that there are other edge cases for this issue that are not solved even by non-default \"best practices\"."
    },
    {
      "id": 1435832413,
      "user": "robrighter",
      "body": "I created a pull request to satisfy the suggested solution above. This makes \"none\" the default facecolor for subfigures:\r\n\r\n#25255\r\n"
    }
  ],
  "text_context": "# [Bug]: Suptitle not visible with subfigures\n\n### Bug summary\r\n\r\nIn a fairly basic example using subfigures, a suptitle added to the parent figure is not visible:\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nf = plt.figure(figsize=(4, 3))\r\nsf1, sf2 = f.subfigures(1, 2)\r\nsf1.subplots()\r\nsf2.subplots()\r\nf.suptitle(\"It's a bird, it's a plane, it's a suptitle\")\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n![test](https://user-images.githubusercontent.com/315810/211206529-a3249ee9-6de1-4f0d-8be4-3e46f6f484dc.png)\r\n\r\n\r\n### Expected outcome\r\n\r\nVisible suptitle.\r\n\r\n### Additional information\r\n\r\nIt looks like this is happening because the subfigures have a solid facecolor that obscure the suptitle:\r\n\r\n```python\r\nf = plt.figure(figsize=(4, 3))\r\nsf1, sf2 = f.subfigures(1, 2)\r\nsf1.subplots()\r\nsf2.subplots()\r\nsf1.set_facecolor((.8, 0, 0, .3))\r\nf.suptitle(\"It's a bird, it's a plane, it's a suptitle\")\r\n```\r\n![test](https://user-images.githubusercontent.com/315810/211206669-1b39ecf7-ce7c-444b-851f-8e994538cee1.png)\r\n\r\nSetting the zorder of the suptitle to a large number has no apparent effect.\r\n\r\n\r\n### Matplotlib Version\r\n\r\n3.6.2\r\n\r\n### Matplotlib Backend\r\n\r\nmodule://matplotlib_inline.backend_inline\n\nI don't think we specifically set the background color of subfigures to anything different than a figure, which defaults to white.  We could, by default, make subfigures transparent, but not 100% clear to me that is the right thing to do.  \r\n\r\nFWIW, this problem goes away with `layout='constrained'` which makes the subfigure the correct size to allow the suptitle. \n\n> We could, by default, make subfigures transparent, but not 100% clear to me that is the right thing to do.\r\n\r\nI agree that this could have the potential to add unpredictable complexity, but in practice what do you think the failure mode would look like?\r\n\r\nIf the default subfigure facecolor is transparent, it will _appear_ as if the overlying subfigures have whatever facecolor is set for figures by default (i.e. in the rc params), so changing the figure default will still \"work\". And you could still have subfigures listen to the `facecolor` parameter passed when they are created, so users could make a subfigure within a larger figure that has a distinct background.\r\n\r\nThe only potential confusing situation that comes to mind is if a user set the rc parameter to a specific value, set the figure facecolor to a different value, and then expects a subfigure made without an explicit facecolor to follow the rc parameter rather than inherit from the parent. While that strikes me as unusual (I think I would maybe expect inheritance? but not sure) it seems like there's an easy route to the solution (\"ah, it's inheriting the parent figure color, so let me try setting the facecolor when I create the subfigure\").\r\n\r\nIn contrast, the root cause of the behavior here is not obvious; it just looks like the suptitle \"isn't working\" for some reason. Note how the seaborn issue was presented, it appeared to the user (who is sharp) that the suptitle was \"being removed\". It took me a while to determine that it's actually there, just \"under\" the subfigure (especially since zorder didn't work, which I tried first).\r\n\r\nAnd while it's good to know that constrained_layout will help with suptitle, I don't think tight_layout accounts for suptitles, and neither layout engine handles similar edge cases like manually added text artists representing captions or panel labels. (Right?)\r\n\r\nSo on balance, I think that making subfigures have transparent facecolors by default will strictly reduce surprise, but maybe I'm not thinking of a circumstance where that's not true.\n\nAh, so that was what happened. I was really confused by the issue as I could still see that the Text object was correctly in the fig.texts ; I had also tried moving it around in the figure and it did not work, probably because it was still under the subfigures (although in my case I thought that I was using the constrained layout while seaborn actually deactivated it, which added to the confusion).\r\nI do agree that this is definitely an easy trap to fall in for which I would not expect a non-expert user to quickly find the solution (using constrained layout). There is probably a way to make the suptitle show above the subfigures anyway but it does not seem obvious to me ; I agree with the case for having transparent subfigures (but could be missing something as well).\n\nNot that it really matters for the discussion here, but\r\n\r\n> I don't think tight_layout accounts for suptitles\r\n\r\nhas been fixed in https://github.com/matplotlib/matplotlib/pull/17219.\n\nJust to clarify - suptitles now works for simple cases that tight_layout works on.  However it does not work for subfigures or other nested layouts.  \n\n> neither layout engine handles similar edge cases like manually added text artists representing captions or panel labels. (Right?)\r\n\r\nI'm not sure what you mean by this - certainly if you attach text to an axes, constrained_layout will make all the axes smaller to make sure there is no overlap, just like it does for titles and ticklabels...\r\n\r\nFor this particular issue, I think someone could easily put in a PR to make the default facecolor for subfigures \"none\" and see what people think.  I agree it's probably fine for 99.9% of cases, and easy to change to something else if desired.   I'll mark as a good first issue and I don't think its hard, though anyone interested in pursuing should be prepared to advocate for it.  \n\n> I'm not sure what you mean by this\r\n\r\nI would typically specify panel labels or a caption by adding text to the figure object, not the axes:\r\n\r\n```python\r\nf, axs = plt.subplots(2, 2, constrained_layout=True)\r\nf.text(.99, .01, \"Source: I made it up\", size=15, va=\"bottom\", ha=\"right\")\r\n```\r\n<img width=500 src=\"https://user-images.githubusercontent.com/315810/217524409-47a83ef3-bb36-4b4d-9123-1f9278b964c4.png\" />\r\n\n\nYes I see. Definitely the layout engines cannot avoid random figure objects, so space would have to be reserved for a \"caption\" like this. \n\nYeah — there's a separate issue about adding a `Figure.caption` concept that layout algorithms could then be smart about (https://github.com/matplotlib/matplotlib/issues/23873) but the point here is that there are other edge cases for this issue that are not solved even by non-default \"best practices\".\n\nI created a pull request to satisfy the suggested solution above. This makes \"none\" the default facecolor for subfigures:\r\n\r\n#25255\r\n",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/17219",
  "code_context": [
    {
      "filename": "lib/matplotlib/tests/test_tightlayout.py",
      "content": "import warnings\n\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nimport pytest\n\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nfrom matplotlib.offsetbox import AnchoredOffsetbox, DrawingArea\nfrom matplotlib.patches import Rectangle\n\n\ndef example_plot(ax, fontsize=12):\n    ax.plot([1, 2])\n    ax.locator_params(nbins=3)\n    ax.set_xlabel('x-label', fontsize=fontsize)\n    ax.set_ylabel('y-label', fontsize=fontsize)\n    ax.set_title('Title', fontsize=fontsize)\n\n\n@image_comparison(['tight_layout1'], tol=1.9)\ndef test_tight_layout1():\n    \"\"\"Test tight_layout for a single subplot.\"\"\"\n    fig, ax = plt.subplots()\n    example_plot(ax, fontsize=24)\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout2'])\ndef test_tight_layout2():\n    \"\"\"Test tight_layout for multiple subplots.\"\"\"\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\n    example_plot(ax1)\n    example_plot(ax2)\n    example_plot(ax3)\n    example_plot(ax4)\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout3'])\ndef test_tight_layout3():\n    \"\"\"Test tight_layout for multiple subplots.\"\"\"\n    ax1 = plt.subplot(221)\n    ax2 = plt.subplot(223)\n    ax3 = plt.subplot(122)\n    example_plot(ax1)\n    example_plot(ax2)\n    example_plot(ax3)\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout4'], freetype_version=('2.5.5', '2.6.1'))\ndef test_tight_layout4():\n    \"\"\"Test tight_layout for subplot2grid.\"\"\"\n    ax1 = plt.subplot2grid((3, 3), (0, 0))\n    ax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\n    ax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\n    ax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\n    example_plot(ax1)\n    example_plot(ax2)\n    example_plot(ax3)\n    example_plot(ax4)\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout5'])\ndef test_tight_layout5():\n    \"\"\"Test tight_layout for image.\"\"\"\n    ax = plt.subplot(111)\n    arr = np.arange(100).reshape((10, 10))\n    ax.imshow(arr, interpolation=\"none\")\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout6'])\ndef test_tight_layout6():\n    \"\"\"Test tight_layout for gridspec.\"\"\"\n\n    # This raises warnings since tight layout cannot\n    # do this fully automatically. But the test is\n    # correct since the layout is manually edited\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", UserWarning)\n        fig = plt.figure()\n\n        gs1 = mpl.gridspec.GridSpec(2, 1)\n        ax1 = fig.add_subplot(gs1[0])\n        ax2 = fig.add_subplot(gs1[1])\n\n        example_plot(ax1)\n        example_plot(ax2)\n\n        gs1.tight_layout(fig, rect=[0, 0, 0.5, 1])\n\n        gs2 = mpl.gridspec.GridSpec(3, 1)\n\n        for ss in gs2:\n            ax = fig.add_subplot(ss)\n            example_plot(ax)\n            ax.set_title(\"\")\n            ax.set_xlabel(\"\")\n\n        ax.set_xlabel(\"x-label\", fontsize=12)\n\n        gs2.tight_layout(fig, rect=[0.5, 0, 1, 1], h_pad=0.45)\n\n        top = min(gs1.top, gs2.top)\n        bottom = max(gs1.bottom, gs2.bottom)\n\n        gs1.tight_layout(fig, rect=[None, 0 + (bottom-gs1.bottom),\n                                    0.5, 1 - (gs1.top-top)])\n        gs2.tight_layout(fig, rect=[0.5, 0 + (bottom-gs2.bottom),\n                                    None, 1 - (gs2.top-top)],\n                         h_pad=0.45)\n\n\n@image_comparison(['tight_layout7'], tol=1.9)\ndef test_tight_layout7():\n    # tight layout with left and right titles\n    fontsize = 24\n    fig, ax = plt.subplots()\n    ax.plot([1, 2])\n    ax.locator_params(nbins=3)\n    ax.set_xlabel('x-label', fontsize=fontsize)\n    ax.set_ylabel('y-label', fontsize=fontsize)\n    ax.set_title('Left Title', loc='left', fontsize=fontsize)\n    ax.set_title('Right Title', loc='right', fontsize=fontsize)\n    plt.tight_layout()\n\n\n@image_comparison(['tight_layout8'])\ndef test_tight_layout8():\n    \"\"\"Test automatic use of tight_layout.\"\"\"\n    fig = plt.figure()\n    fig.set_tight_layout({'pad': .1})\n    ax = fig.add_subplot(111)\n    example_plot(ax, fontsize=24)\n\n\n@image_comparison(['tight_layout9'])\ndef test_tight_layout9():\n    # Test tight_layout for non-visible subplots\n    # GH 8244\n    f, axarr = plt.subplots(2, 2)\n    axarr[1][1].set_visible(False)\n    plt.tight_layout()\n\n\ndef test_outward_ticks():\n    \"\"\"Test automatic use of tight_layout.\"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(221)\n    ax.xaxis.set_tick_params(tickdir='out', length=16, width=3)\n    ax.yaxis.set_tick_params(tickdir='out', length=16, width=3)\n    ax.xaxis.set_tick_params(\n        tickdir='out', length=32, width=3, tick1On=True, which='minor')\n    ax.yaxis.set_tick_params(\n        tickdir='out', length=32, width=3, tick1On=True, which='minor')\n    ax.xaxis.set_ticks([0], minor=True)\n    ax.yaxis.set_ticks([0], minor=True)\n    ax = fig.add_subplot(222)\n    ax.xaxis.set_tick_params(tickdir='in', length=32, width=3)\n    ax.yaxis.set_tick_params(tickdir='in', length=32, width=3)\n    ax = fig.add_subplot(223)\n    ax.xaxis.set_tick_params(tickdir='inout', length=32, width=3)\n    ax.yaxis.set_tick_params(tickdir='inout', length=32, width=3)\n    ax = fig.add_subplot(224)\n    ax.xaxis.set_tick_params(tickdir='out', length=32, width=3)\n    ax.yaxis.set_tick_params(tickdir='out', length=32, width=3)\n    plt.tight_layout()\n    # These values were obtained after visual checking that they correspond\n    # to a tight layouting that did take the ticks into account.\n    ans = [[[0.091, 0.607], [0.433, 0.933]],\n           [[0.579, 0.607], [0.922, 0.933]],\n           [[0.091, 0.140], [0.433, 0.466]],\n           [[0.579, 0.140], [0.922, 0.466]]]\n    for nn, ax in enumerate(fig.axes):\n        assert_array_equal(np.round(ax.get_position().get_points(), 3),\n                           ans[nn])\n\n\ndef add_offsetboxes(ax, size=10, margin=.1, color='black'):\n    \"\"\"\n    Surround ax with OffsetBoxes\n    \"\"\"\n    m, mp = margin, 1+margin\n    anchor_points = [(-m, -m), (-m, .5), (-m, mp),\n                     (mp, .5), (.5, mp), (mp, mp),\n                     (.5, -m), (mp, -m), (.5, -m)]\n    for point in anchor_points:\n        da = DrawingArea(size, size)\n        background = Rectangle((0, 0), width=size,\n                               height=size,\n                               facecolor=color,\n                               edgecolor='None',\n                               linewidth=0,\n                               antialiased=False)\n        da.add_artist(background)\n\n        anchored_box = AnchoredOffsetbox(\n            loc='center',\n            child=da,\n            pad=0.,\n            frameon=False,\n            bbox_to_anchor=point,\n            bbox_transform=ax.transAxes,\n            borderpad=0.)\n        ax.add_artist(anchored_box)\n    return anchored_box\n\n\n@image_comparison(['tight_layout_offsetboxes1', 'tight_layout_offsetboxes2'])\ndef test_tight_layout_offsetboxes():\n    # 1.\n    # - Create 4 subplots\n    # - Plot a diagonal line on them\n    # - Surround each plot with 7 boxes\n    # - Use tight_layout\n    # - See that the squares are included in the tight_layout\n    #   and that the squares in the middle do not overlap\n    #\n    # 2.\n    # - Make the squares around the right side axes invisible\n    # - See that the invisible squares do not affect the\n    #   tight_layout\n    rows = cols = 2\n    colors = ['red', 'blue', 'green', 'yellow']\n    x = y = [0, 1]\n\n    def _subplots():\n        _, axs = plt.subplots(rows, cols)\n        axs = axs.flat\n        for ax, color in zip(axs, colors):\n            ax.plot(x, y, color=color)\n            add_offsetboxes(ax, 20, color=color)\n        return axs\n\n    # 1.\n    axs = _subplots()\n    plt.tight_layout()\n\n    # 2.\n    axs = _subplots()\n    for ax in (axs[cols-1::rows]):\n        for child in ax.get_children():\n            if isinstance(child, AnchoredOffsetbox):\n                child.set_visible(False)\n\n    plt.tight_layout()\n\n\ndef test_empty_layout():\n    \"\"\"Test that tight layout doesn't cause an error when there are no axes.\"\"\"\n    fig = plt.gcf()\n    fig.tight_layout()\n\n\n@pytest.mark.parametrize(\"label\", [\"xlabel\", \"ylabel\"])\ndef test_verybig_decorators(label):\n    \"\"\"Test that warning emitted when xlabel/ylabel too big.\"\"\"\n    fig, ax = plt.subplots(figsize=(3, 2))\n    ax.set(**{label: 'a' * 100})\n    with pytest.warns(UserWarning):\n        fig.tight_layout()\n\n\ndef test_big_decorators_horizontal():\n    \"\"\"Test that warning emitted when xlabel too big.\"\"\"\n    fig, axs = plt.subplots(1, 2, figsize=(3, 2))\n    axs[0].set_xlabel('a' * 30)\n    axs[1].set_xlabel('b' * 30)\n    with pytest.warns(UserWarning):\n        fig.tight_layout()\n\n\ndef test_big_decorators_vertical():\n    \"\"\"Test that warning emitted when xlabel too big.\"\"\"\n    fig, axs = plt.subplots(2, 1, figsize=(3, 2))\n    axs[0].set_ylabel('a' * 20)\n    axs[1].set_ylabel('b' * 20)\n    with pytest.warns(UserWarning):\n        fig.tight_layout()\n\n\ndef test_badsubplotgrid():\n    # test that we get warning for mismatched subplot grids, not than an error\n    plt.subplot2grid((4, 5), (0, 0))\n    # this is the bad entry:\n    plt.subplot2grid((5, 5), (0, 3), colspan=3, rowspan=5)\n    with pytest.warns(UserWarning):\n        plt.tight_layout()\n\n\ndef test_collapsed():\n    # test that if a call to tight_layout will collapses the axes that\n    # it does not get applied:\n    fig, ax = plt.subplots(tight_layout=True)\n    ax.set_xlim([0, 1])\n    ax.set_ylim([0, 1])\n\n    ax.annotate('BIG LONG STRING', xy=(1.25, 2), xytext=(10.5, 1.75),)\n    p1 = ax.get_position()\n    with pytest.warns(UserWarning):\n        plt.tight_layout()\n        p2 = ax.get_position()\n        assert p1.width == p2.width\n    # test that passing a rect doesn't crash...\n    with pytest.warns(UserWarning):\n        plt.tight_layout(rect=[0, 0, 0.8, 0.8])\n\n\ndef test_suptitle():\n    fig, ax = plt.subplots(tight_layout=True)\n    st = fig.suptitle(\"foo\")\n    t = ax.set_title(\"bar\")\n    fig.canvas.draw()\n    assert st.get_window_extent().y0 > t.get_window_extent().y1\n"
    },
    {
      "filename": "lib/matplotlib/tight_layout.py",
      "content": "\"\"\"\nRoutines to adjust subplot params so that subplots are\nnicely fit in the figure. In doing so, only axis labels, tick labels, axes\ntitles and offsetboxes that are anchored to axes are currently considered.\n\nInternally, this module assumes that the margins (left_margin, etc.) which are\ndifferences between ax.get_tightbbox and ax.bbox are independent of axes\nposition. This may fail if Axes.adjustable is datalim. Also, This will fail\nfor some cases (for example, left or right margin is affected by xlabel).\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib import cbook, rcParams\nfrom matplotlib.font_manager import FontProperties\nfrom matplotlib.transforms import TransformedBbox, Bbox\n\n\ndef auto_adjust_subplotpars(\n        fig, renderer, nrows_ncols, num1num2_list, subplot_list,\n        ax_bbox_list=None, pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return a dict of subplot parameters to adjust spacing between subplots\n    or ``None`` if resulting axes would have zero height or width.\n\n    Note that this function ignores geometry information of subplot\n    itself, but uses what is given by the *nrows_ncols* and *num1num2_list*\n    parameters.  Also, the results could be incorrect if some subplots have\n    ``adjustable=datalim``.\n\n    Parameters\n    ----------\n    nrows_ncols : Tuple[int, int]\n        Number of rows and number of columns of the grid.\n    num1num2_list : List[int]\n        List of numbers specifying the area occupied by the subplot\n    subplot_list : list of subplots\n        List of subplots that will be used to calculate optimal subplot_params.\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots, as a\n        fraction of the font size.  Defaults to *pad*.\n    rect : Tuple[float, float, float, float]\n        [left, bottom, right, top] in normalized (0, 1) figure coordinates.\n    \"\"\"\n    rows, cols = nrows_ncols\n\n    font_size_inches = (\n        FontProperties(size=rcParams[\"font.size\"]).get_size_in_points() / 72)\n    pad_inches = pad * font_size_inches\n    vpad_inches = h_pad * font_size_inches if h_pad is not None else pad_inches\n    hpad_inches = w_pad * font_size_inches if w_pad is not None else pad_inches\n\n    if len(num1num2_list) != len(subplot_list) or len(subplot_list) == 0:\n        raise ValueError\n\n    if rect is None:\n        margin_left = margin_bottom = margin_right = margin_top = None\n    else:\n        margin_left, margin_bottom, _right, _top = rect\n        margin_right = 1 - _right if _right else None\n        margin_top = 1 - _top if _top else None\n\n    vspaces = np.zeros((rows + 1, cols))\n    hspaces = np.zeros((rows, cols + 1))\n\n    if ax_bbox_list is None:\n        ax_bbox_list = [\n            Bbox.union([ax.get_position(original=True) for ax in subplots])\n            for subplots in subplot_list]\n\n    for subplots, ax_bbox, (num1, num2) in zip(subplot_list,\n                                               ax_bbox_list,\n                                               num1num2_list):\n        if all(not ax.get_visible() for ax in subplots):\n            continue\n\n        tight_bbox_raw = Bbox.union([\n            ax.get_tightbbox(renderer) for ax in subplots if ax.get_visible()])\n        tight_bbox = TransformedBbox(tight_bbox_raw,\n                                     fig.transFigure.inverted())\n\n        row1, col1 = divmod(num1, cols)\n        if num2 is None:\n            num2 = num1\n        row2, col2 = divmod(num2, cols)\n\n        for row_i in range(row1, row2 + 1):\n            hspaces[row_i, col1] += ax_bbox.xmin - tight_bbox.xmin  # left\n            hspaces[row_i, col2 + 1] += tight_bbox.xmax - ax_bbox.xmax  # right\n        for col_i in range(col1, col2 + 1):\n            vspaces[row1, col_i] += tight_bbox.ymax - ax_bbox.ymax  # top\n            vspaces[row2 + 1, col_i] += ax_bbox.ymin - tight_bbox.ymin  # bot.\n\n    fig_width_inch, fig_height_inch = fig.get_size_inches()\n\n    # margins can be negative for axes with aspect applied, so use max(, 0) to\n    # make them nonnegative.\n    if not margin_left:\n        margin_left = (max(hspaces[:, 0].max(), 0)\n                       + pad_inches / fig_width_inch)\n    if not margin_right:\n        margin_right = (max(hspaces[:, -1].max(), 0)\n                        + pad_inches / fig_width_inch)\n    if not margin_top:\n        margin_top = (max(vspaces[0, :].max(), 0)\n                      + pad_inches / fig_height_inch)\n        suptitle = fig._suptitle\n        if suptitle and suptitle.get_in_layout():\n            rel_suptitle_height = fig.transFigure.inverted().transform_bbox(\n                suptitle.get_window_extent(renderer)).height\n            margin_top += rel_suptitle_height + pad_inches / fig_height_inch\n    if not margin_bottom:\n        margin_bottom = (max(vspaces[-1, :].max(), 0)\n                         + pad_inches / fig_height_inch)\n\n    if margin_left + margin_right >= 1:\n        cbook._warn_external('Tight layout not applied. The left and right '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n    if margin_bottom + margin_top >= 1:\n        cbook._warn_external('Tight layout not applied. The bottom and top '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n\n    kwargs = dict(left=margin_left,\n                  right=1 - margin_right,\n                  bottom=margin_bottom,\n                  top=1 - margin_top)\n\n    if cols > 1:\n        hspace = hspaces[:, 1:-1].max() + hpad_inches / fig_width_inch\n        # axes widths:\n        h_axes = (1 - margin_right - margin_left - hspace * (cols - 1)) / cols\n        if h_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes width small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"wspace\"] = hspace / h_axes\n    if rows > 1:\n        vspace = vspaces[1:-1, :].max() + vpad_inches / fig_height_inch\n        v_axes = (1 - margin_top - margin_bottom - vspace * (rows - 1)) / rows\n        if v_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes height small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"hspace\"] = vspace / v_axes\n\n    return kwargs\n\n\ndef get_renderer(fig):\n    if fig._cachedRenderer:\n        renderer = fig._cachedRenderer\n    else:\n        canvas = fig.canvas\n\n        if canvas and hasattr(canvas, \"get_renderer\"):\n            renderer = canvas.get_renderer()\n        else:  # Some noninteractive backends have no renderer until draw time.\n            cbook._warn_external(\"tight_layout: falling back to Agg renderer\")\n            from matplotlib.backends.backend_agg import FigureCanvasAgg\n            canvas = FigureCanvasAgg(fig)\n            renderer = canvas.get_renderer()\n\n    return renderer\n\n\ndef get_subplotspec_list(axes_list, grid_spec=None):\n    \"\"\"\n    Return a list of subplotspec from the given list of axes.\n\n    For an instance of axes that does not support subplotspec, None is inserted\n    in the list.\n\n    If grid_spec is given, None is inserted for those not from the given\n    grid_spec.\n    \"\"\"\n    subplotspec_list = []\n    for ax in axes_list:\n        axes_or_locator = ax.get_axes_locator()\n        if axes_or_locator is None:\n            axes_or_locator = ax\n\n        if hasattr(axes_or_locator, \"get_subplotspec\"):\n            subplotspec = axes_or_locator.get_subplotspec()\n            subplotspec = subplotspec.get_topmost_subplotspec()\n            gs = subplotspec.get_gridspec()\n            if grid_spec is not None:\n                if gs != grid_spec:\n                    subplotspec = None\n            elif gs.locally_modified_subplot_params():\n                subplotspec = None\n        else:\n            subplotspec = None\n\n        subplotspec_list.append(subplotspec)\n\n    return subplotspec_list\n\n\ndef get_tight_layout_figure(fig, axes_list, subplotspec_list, renderer,\n                            pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return subplot parameters for tight-layouted-figure with specified padding.\n\n    Parameters\n    ----------\n    fig : Figure\n    axes_list : list of Axes\n    subplotspec_list : list of `.SubplotSpec`\n        The subplotspecs of each axes.\n    renderer : renderer\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots.  Defaults to\n        *pad*.\n    rect : Tuple[float, float, float, float], optional\n        (left, bottom, right, top) rectangle in normalized figure coordinates\n        that the whole subplots area (including labels) will fit into.\n        Defaults to using the entire figure.\n\n    Returns\n    -------\n    subplotspec or None\n        subplotspec kwargs to be passed to `.Figure.subplots_adjust` or\n        None if tight_layout could not be accomplished.\n\n    \"\"\"\n\n    subplot_list = []\n    nrows_list = []\n    ncols_list = []\n    ax_bbox_list = []\n\n    # Multiple axes can share same subplot_interface (e.g., axes_grid1); thus\n    # we need to join them together.\n    subplot_dict = {}\n\n    subplotspec_list2 = []\n\n    for ax, subplotspec in zip(axes_list, subplotspec_list):\n        if subplotspec is None:\n            continue\n\n        subplots = subplot_dict.setdefault(subplotspec, [])\n\n        if not subplots:\n            myrows, mycols, _, _ = subplotspec.get_geometry()\n            nrows_list.append(myrows)\n            ncols_list.append(mycols)\n            subplotspec_list2.append(subplotspec)\n            subplot_list.append(subplots)\n            ax_bbox_list.append(subplotspec.get_position(fig))\n\n        subplots.append(ax)\n\n    if len(nrows_list) == 0 or len(ncols_list) == 0:\n        return {}\n\n    max_nrows = max(nrows_list)\n    max_ncols = max(ncols_list)\n\n    num1num2_list = []\n    for subplotspec in subplotspec_list2:\n        rows, cols, num1, num2 = subplotspec.get_geometry()\n        div_row, mod_row = divmod(max_nrows, rows)\n        div_col, mod_col = divmod(max_ncols, cols)\n        if mod_row != 0:\n            cbook._warn_external('tight_layout not applied: number of rows '\n                                 'in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n        if mod_col != 0:\n            cbook._warn_external('tight_layout not applied: number of '\n                                 'columns in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n\n        rowNum1, colNum1 = divmod(num1, cols)\n        if num2 is None:\n            rowNum2, colNum2 = rowNum1, colNum1\n        else:\n            rowNum2, colNum2 = divmod(num2, cols)\n\n        num1num2_list.append((rowNum1 * div_row * max_ncols +\n                              colNum1 * div_col,\n                              ((rowNum2 + 1) * div_row - 1) * max_ncols +\n                              (colNum2 + 1) * div_col - 1))\n\n    kwargs = auto_adjust_subplotpars(fig, renderer,\n                                     nrows_ncols=(max_nrows, max_ncols),\n                                     num1num2_list=num1num2_list,\n                                     subplot_list=subplot_list,\n                                     ax_bbox_list=ax_bbox_list,\n                                     pad=pad, h_pad=h_pad, w_pad=w_pad)\n\n    # kwargs can be none if tight_layout fails...\n    if rect is not None and kwargs is not None:\n        # if rect is given, the whole subplots area (including\n        # labels) will fit into the rect instead of the\n        # figure. Note that the rect argument of\n        # *auto_adjust_subplotpars* specify the area that will be\n        # covered by the total area of axes.bbox. Thus we call\n        # auto_adjust_subplotpars twice, where the second run\n        # with adjusted rect parameters.\n\n        left, bottom, right, top = rect\n        if left is not None:\n            left += kwargs[\"left\"]\n        if bottom is not None:\n            bottom += kwargs[\"bottom\"]\n        if right is not None:\n            right -= (1 - kwargs[\"right\"])\n        if top is not None:\n            top -= (1 - kwargs[\"top\"])\n\n        kwargs = auto_adjust_subplotpars(fig, renderer,\n                                         nrows_ncols=(max_nrows, max_ncols),\n                                         num1num2_list=num1num2_list,\n                                         subplot_list=subplot_list,\n                                         ax_bbox_list=ax_bbox_list,\n                                         pad=pad, h_pad=h_pad, w_pad=w_pad,\n                                         rect=(left, bottom, right, top))\n\n    return kwargs\n"
    }
  ],
  "questions": [
    "> neither layout engine handles similar edge cases like manually added text artists representing captions or panel labels. (Right?)\r\n\r\nI'm not sure what you mean by this - certainly if you attach text to an axes, constrained_layout will make all the axes smaller to make sure there is no overlap, just like it does for titles and ticklabels...\r\n\r\nFor this particular issue, I think someone could easily put in a PR to make the default facecolor for subfigures \"none\" and see what people think.  I agree it's probably fine for 99.9% of cases, and easy to change to something else if desired.   I'll mark as a good first issue and I don't think its hard, though anyone interested in pursuing should be prepared to advocate for it."
  ],
  "golden_answers": [
    "> I'm not sure what you mean by this\r\n\r\nI would typically specify panel labels or a caption by adding text to the figure object, not the axes:\r\n\r\n```python\r\nf, axs = plt.subplots(2, 2, constrained_layout=True)\r\nf.text(.99, .01, \"Source: I made it up\", size=15, va=\"bottom\", ha=\"right\")\r\n```\r\n<img width=500 src=\"https://user-images.githubusercontent.com/315810/217524409-47a83ef3-bb36-4b4d-9123-1f9278b964c4.png\" />"
  ],
  "questions_generated": [
    "What could be a potential reason for the suptitle not appearing when using subfigures in Matplotlib?",
    "How can using 'layout=\"constrained\"' resolve the issue with the suptitle not being visible in subfigures?",
    "What is the potential drawback of making the default subfigure facecolor transparent, and how might it affect users?",
    "Why does setting the zorder of the suptitle to a large number not solve the visibility issue?",
    "In the context of the Matplotlib code structure, where would you likely add a test case for this suptitle visibility issue?"
  ],
  "golden_answers_generated": [
    "The suptitle may not appear because subfigures have a solid facecolor that obscures the suptitle. If the facecolor is not set to be transparent, it can cover the area where the suptitle is supposed to be rendered, making it invisible.",
    "Using 'layout=\"constrained\"' helps adjust the size of the subfigures to accommodate the suptitle, ensuring that it is visible. This layout option automatically adjusts the figure's layout to make room for axes decorations such as titles, labels, and suptitles.",
    "Making the default subfigure facecolor transparent could lead to unexpected results if users have set specific figure facecolors expecting subfigures to inherit them. This change might cause confusion if users expect subfigures to match a specific background color set in the rc parameters rather than defaulting to transparent and showing the parent figure's color.",
    "Setting the zorder of the suptitle to a large number does not solve the visibility issue because the problem is not related to the rendering order but rather to the subfigures' facecolor covering the suptitle area. Zorder controls the drawing order of elements, but it cannot make an obscured element visible if it is covered by a non-transparent element.",
    "A test case for this suptitle visibility issue would likely be added in the `lib/matplotlib/tests/test_tightlayout.py` file or a similar test file where layout and figure display issues are tested. This file already contains tests for various layout functionalities, making it a suitable location for verifying that suptitles appear correctly with subfigures."
  ]
}