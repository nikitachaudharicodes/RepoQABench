{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "7650",
  "issue_description": "# anchored_artists don't support zorder argument\n\nAnchoredText and other items from `mpl_toolkits.axes_grid.anchored_artists` don't accept `zorder`.\r\n\r\nIn the following example, the anchored text should be above the line:\r\n```python\r\nimport matplotlib as mpl\r\nimport matplotlib.pyplot as plt\r\nfrom mpl_toolkits.axes_grid.anchored_artists import AnchoredText\r\n\r\nfig = plt.figure()\r\nax = fig.add_subplot(111)\r\n\r\nat = AnchoredText(\"test\", prop=dict(size=24,zorder=20), loc=3, frameon=True, zorder=20)\r\nax.add_artist(at)\r\nax.plot([0,1],[0,1],'r', zorder=10)\r\n\r\nplt.show()\r\n```\r\n\r\n- [x] Matplotlib 1.5.3, Python 2.7.12 and 3.4.5 Platform OpenSUSE linux\r\n- [x] How install mpl: `pip install --update --user`\r\n",
  "issue_comments": [
    {
      "id": 268332620,
      "user": "RafiKueng",
      "body": "one can however directly set the zorder on the at element:\r\n\r\n`at.zorder = 20`\r\n"
    },
    {
      "id": 268347794,
      "user": "tacaswell",
      "body": "Without looking at the code, I expect this to be a matter of tracing through where the kwargs in AnchoredText get processed and ensure that zorder is properly handled."
    },
    {
      "id": 268347910,
      "user": "tacaswell",
      "body": "@RafiKueng Would you be interested in taking a crack at sorting this out?"
    },
    {
      "id": 268357391,
      "user": "RafiKueng",
      "body": "I can have a try once my deadline is over ;)\n\n\nOn 20/12/16 21:20, Thomas A Caswell wrote:\n> @RafiKueng <https://github.com/RafiKueng> Would you be interested in\n> taking a crack at sorting this out?\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/7650#issuecomment-268347910>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AA5N-gLl3lQs4DmN3itJ5yw-gbpWTyqTks5rKDidgaJpZM4LSJXy>.\n>\n"
    },
    {
      "id": 268369364,
      "user": "RafiKueng",
      "body": "note to myself:\r\nI also found other possible bugs in the ancored artists... (scalebar for example) I might clean up everything when I'm at it."
    },
    {
      "id": 268405582,
      "user": "tacaswell",
      "body": "I believe that https://github.com/matplotlib/matplotlib/pull/7344 is related?"
    },
    {
      "id": 271389394,
      "user": "RafiKueng",
      "body": "yes, looks like #7344 is related.\r\n\r\nCan anyone help me out: what's the reason for having `mpl_toolkits/axes_grid`,  `mpl_toolkits/axes_grid1`, `mpl_toolkits/axisartist` and `matplotlib/offsetbox.py`? Should there some cleaning up happen or shoudn't one touch/move/delete anything?"
    },
    {
      "id": 271482419,
      "user": "tacaswell",
      "body": "There _should_ be some cleaning up, but it needs to be done carefully so that we do not break user code without warning. "
    },
    {
      "id": 271486148,
      "user": "QuLogic",
      "body": "`axes_grid` is the original, and `axes_grid1` and `axisartist` are split versions of them. I'm pretty sure `matplotlib.offsetbox` is the real implementation and the others just import it (of whatever's implemented there, anyway.) I've got a bit of cleanup ready for as soon as I've finished #7545."
    },
    {
      "id": 807990537,
      "user": "AhmadSenousi",
      "body": "Is this problem Solved?"
    },
    {
      "id": 808694409,
      "user": "timhoffm",
      "body": "@AhmadSenousi In general, issues are closed when they are solved. If that this was missed, you can easily run the minimal example above to see that this is not yet solved."
    }
  ],
  "text_context": "# anchored_artists don't support zorder argument\n\nAnchoredText and other items from `mpl_toolkits.axes_grid.anchored_artists` don't accept `zorder`.\r\n\r\nIn the following example, the anchored text should be above the line:\r\n```python\r\nimport matplotlib as mpl\r\nimport matplotlib.pyplot as plt\r\nfrom mpl_toolkits.axes_grid.anchored_artists import AnchoredText\r\n\r\nfig = plt.figure()\r\nax = fig.add_subplot(111)\r\n\r\nat = AnchoredText(\"test\", prop=dict(size=24,zorder=20), loc=3, frameon=True, zorder=20)\r\nax.add_artist(at)\r\nax.plot([0,1],[0,1],'r', zorder=10)\r\n\r\nplt.show()\r\n```\r\n\r\n- [x] Matplotlib 1.5.3, Python 2.7.12 and 3.4.5 Platform OpenSUSE linux\r\n- [x] How install mpl: `pip install --update --user`\r\n\n\none can however directly set the zorder on the at element:\r\n\r\n`at.zorder = 20`\r\n\n\nWithout looking at the code, I expect this to be a matter of tracing through where the kwargs in AnchoredText get processed and ensure that zorder is properly handled.\n\n@RafiKueng Would you be interested in taking a crack at sorting this out?\n\nI can have a try once my deadline is over ;)\n\n\nOn 20/12/16 21:20, Thomas A Caswell wrote:\n> @RafiKueng <https://github.com/RafiKueng> Would you be interested in\n> taking a crack at sorting this out?\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/7650#issuecomment-268347910>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AA5N-gLl3lQs4DmN3itJ5yw-gbpWTyqTks5rKDidgaJpZM4LSJXy>.\n>\n\n\nnote to myself:\r\nI also found other possible bugs in the ancored artists... (scalebar for example) I might clean up everything when I'm at it.\n\nI believe that https://github.com/matplotlib/matplotlib/pull/7344 is related?\n\nyes, looks like #7344 is related.\r\n\r\nCan anyone help me out: what's the reason for having `mpl_toolkits/axes_grid`,  `mpl_toolkits/axes_grid1`, `mpl_toolkits/axisartist` and `matplotlib/offsetbox.py`? Should there some cleaning up happen or shoudn't one touch/move/delete anything?\n\nThere _should_ be some cleaning up, but it needs to be done carefully so that we do not break user code without warning. \n\n`axes_grid` is the original, and `axes_grid1` and `axisartist` are split versions of them. I'm pretty sure `matplotlib.offsetbox` is the real implementation and the others just import it (of whatever's implemented there, anyway.) I've got a bit of cleanup ready for as soon as I've finished #7545.\n\nIs this problem Solved?\n\n@AhmadSenousi In general, issues are closed when they are solved. If that this was missed, you can easily run the minimal example above to see that this is not yet solved.",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/7344",
  "code_context": [
    {
      "filename": "lib/matplotlib/offsetbox.py",
      "content": "\"\"\"\nThe OffsetBox is a simple container artist. The child artist are meant\nto be drawn at a relative position to its parent.  The [VH]Packer,\nDrawingArea and TextArea are derived from the OffsetBox.\n\nThe [VH]Packer automatically adjust the relative postisions of their\nchildren, which should be instances of the OffsetBox. This is used to\nalign similar artists together, e.g., in legend.\n\nThe DrawingArea can contain any Artist as a child. The\nDrawingArea has a fixed width and height. The position of children\nrelative to the parent is fixed.  The TextArea is contains a single\nText instance. The width and height of the TextArea instance is the\nwidth and height of the its child text.\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import xrange, zip\n\nimport warnings\nimport matplotlib.transforms as mtransforms\nimport matplotlib.artist as martist\nimport matplotlib.text as mtext\nimport matplotlib.path as mpath\nimport numpy as np\nfrom matplotlib.transforms import Bbox, BboxBase, TransformedBbox\n\nfrom matplotlib.font_manager import FontProperties\nfrom matplotlib.patches import FancyBboxPatch, FancyArrowPatch\nfrom matplotlib import rcParams\n\nfrom matplotlib import docstring\n\n#from bboximage import BboxImage\nfrom matplotlib.image import BboxImage\n\nfrom matplotlib.patches import bbox_artist as mbbox_artist\nfrom matplotlib.text import _AnnotationBase\n\n\nDEBUG = False\n\n\n# for debuging use\ndef bbox_artist(*args, **kwargs):\n    if DEBUG:\n        mbbox_artist(*args, **kwargs)\n\n# _get_packed_offsets() and _get_aligned_offsets() are coded assuming\n# that we are packing boxes horizontally. But same function will be\n# used with vertical packing.\n\n\ndef _get_packed_offsets(wd_list, total, sep, mode=\"fixed\"):\n    \"\"\"\n    Geiven a list of (width, xdescent) of each boxes, calculate the\n    total width and the x-offset positions of each items according to\n    *mode*. xdescent is analagous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    *wd_list* : list of (width, xdescent) of boxes to be packed.\n    *sep* : spacing between boxes\n    *total* : Intended total length. None if not used.\n    *mode* : packing mode. 'fixed', 'expand', or 'equal'.\n    \"\"\"\n\n    w_list, d_list = list(zip(*wd_list))\n    # d_list is currently not used.\n\n    if mode == \"fixed\":\n        offsets_ = np.add.accumulate([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n\n        if total is None:\n            total = offsets_[-1] - sep\n\n        return total, offsets\n\n    elif mode == \"expand\":\n        if len(w_list) > 1:\n            sep = (total - sum(w_list)) / (len(w_list) - 1.)\n        else:\n            sep = 0.\n        offsets_ = np.add.accumulate([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n\n        return total, offsets\n\n    elif mode == \"equal\":\n        maxh = max(w_list)\n        if total is None:\n            total = (maxh + sep) * len(w_list)\n        else:\n            sep = float(total) / (len(w_list)) - maxh\n\n        offsets = np.array([(maxh + sep) * i for i in range(len(w_list))])\n\n        return total, offsets\n\n    else:\n        raise ValueError(\"Unknown mode : %s\" % (mode,))\n\n\ndef _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n    \"\"\"\n    Given a list of (height, descent) of each boxes, align the boxes\n    with *align* and calculate the y-offsets of each boxes.\n    total width and the offset positions of each items according to\n    *mode*. xdescent is analogous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    *hd_list* : list of (width, xdescent) of boxes to be aligned.\n    *sep* : spacing between boxes\n    *height* : Intended total length. None if not used.\n    *align* : align mode. 'baseline', 'top', 'bottom', or 'center'.\n    \"\"\"\n\n    if height is None:\n        height = max([h for h, d in hd_list])\n\n    if align == \"baseline\":\n        height_descent = max([h - d for h, d in hd_list])\n        descent = max([d for h, d in hd_list])\n        height = height_descent + descent\n        offsets = [0. for h, d in hd_list]\n    elif align in [\"left\", \"top\"]:\n        descent = 0.\n        offsets = [d for h, d in hd_list]\n    elif align in [\"right\", \"bottom\"]:\n        descent = 0.\n        offsets = [height - h + d for h, d in hd_list]\n    elif align == \"center\":\n        descent = 0.\n        offsets = [(height - h) * .5 + d for h, d in hd_list]\n    else:\n        raise ValueError(\"Unknown Align mode : %s\" % (align,))\n\n    return height, descent, offsets\n\n\nclass OffsetBox(martist.Artist):\n    \"\"\"\n    The OffsetBox is a simple container artist. The child artist are meant\n    to be drawn at a relative position to its parent.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n\n        super(OffsetBox, self).__init__(*args, **kwargs)\n\n        # Clipping has not been implemented in the OffesetBox family, so\n        # disable the clip flag for consistency. It can always be turned back\n        # on to zero effect.\n        self.set_clip_on(False)\n\n        self._children = []\n        self._offset = (0, 0)\n\n    def __getstate__(self):\n        state = martist.Artist.__getstate__(self)\n\n        # pickle cannot save instancemethods, so handle them here\n        from .cbook import _InstanceMethodPickler\n        import inspect\n\n        offset = state['_offset']\n        if inspect.ismethod(offset):\n            state['_offset'] = _InstanceMethodPickler(offset)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__ = state\n        from .cbook import _InstanceMethodPickler\n        if isinstance(self._offset, _InstanceMethodPickler):\n            self._offset = self._offset.get_instancemethod()\n        self.stale = True\n\n    def set_figure(self, fig):\n        \"\"\"\n        Set the figure\n\n        accepts a class:`~matplotlib.figure.Figure` instance\n        \"\"\"\n        martist.Artist.set_figure(self, fig)\n        for c in self.get_children():\n            c.set_figure(fig)\n\n    @martist.Artist.axes.setter\n    def axes(self, ax):\n        # TODO deal with this better\n        martist.Artist.axes.fset(self, ax)\n        for c in self.get_children():\n            if c is not None:\n                c.axes = ax\n\n    def contains(self, mouseevent):\n        for c in self.get_children():\n            a, b = c.contains(mouseevent)\n            if a:\n                return a, b\n        return False, {}\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset\n\n        accepts x, y, tuple, or a callable object.\n        \"\"\"\n        self._offset = xy\n        self.stale = True\n\n    def get_offset(self, width, height, xdescent, ydescent, renderer):\n        \"\"\"\n        Get the offset\n\n        accepts extent of the box\n        \"\"\"\n        if six.callable(self._offset):\n            return self._offset(width, height, xdescent, ydescent, renderer)\n        else:\n            return self._offset\n\n    def set_width(self, width):\n        \"\"\"\n        Set the width\n\n        accepts float\n        \"\"\"\n        self.width = width\n        self.stale = True\n\n    def set_height(self, height):\n        \"\"\"\n        Set the height\n\n        accepts float\n        \"\"\"\n        self.height = height\n        self.stale = True\n\n    def get_visible_children(self):\n        \"\"\"\n        Return a list of visible artists it contains.\n        \"\"\"\n        return [c for c in self._children if c.get_visible()]\n\n    def get_children(self):\n        \"\"\"\n        Return a list of artists it contains.\n        \"\"\"\n        return self._children\n\n    def get_extent_offsets(self, renderer):\n        raise Exception(\"\")\n\n    def get_extent(self, renderer):\n        \"\"\"\n        Return with, height, xdescent, ydescent of box\n        \"\"\"\n        w, h, xd, yd, offsets = self.get_extent_offsets(renderer)\n        return w, h, xd, yd\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        w, h, xd, yd, offsets = self.get_extent_offsets(renderer)\n        px, py = self.get_offset(w, h, xd, yd, renderer)\n        return mtransforms.Bbox.from_bounds(px - xd, py - yd, w, h)\n\n    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n\n        width, height, xdescent, ydescent, offsets = self.get_extent_offsets(\n                                                        renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass PackerBase(OffsetBox):\n    def __init__(self, pad=None, sep=None, width=None, height=None,\n                 align=None, mode=None,\n                 children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, optional\n            Boundary pad.\n\n        sep : float, optional\n            Spacing between items.\n\n        width : float, optional\n\n        height : float, optional\n           Width and height of the container box, calculated if\n           `None`.\n\n        align : str, optional\n            Alignment of boxes. Can be one of ``top``, ``bottom``,\n            ``left``, ``right``, ``center`` and ``baseline``\n\n        mode : str, optional\n            Packing mode.\n\n        Notes\n        -----\n        *pad* and *sep* need to given in points and will be scale with\n        the renderer dpi, while *width* and *height* need to be in\n        pixels.\n        \"\"\"\n        super(PackerBase, self).__init__()\n\n        self.height = height\n        self.width = width\n        self.sep = sep\n        self.pad = pad\n        self.mode = mode\n        self.align = align\n\n        self._children = children\n\n\nclass VPacker(PackerBase):\n    \"\"\"\n    The VPacker has its children packed vertically. It automatically\n    adjust the relative positions of children in the drawing time.\n    \"\"\"\n    def __init__(self, pad=None, sep=None, width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\",\n                 children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, optional\n            Boundary pad.\n\n        sep : float, optional\n            Spacing between items.\n\n        width : float, optional\n\n        height : float, optional\n\n            width and height of the container box, calculated if\n            `None`.\n\n        align : str, optional\n            Alignment of boxes.\n\n        mode : str, optional\n            Packing mode.\n\n        Notes\n        -----\n        *pad* and *sep* need to given in points and will be scale with\n        the renderer dpi, while *width* and *height* need to be in\n        pixels.\n        \"\"\"\n        super(VPacker, self).__init__(pad, sep, width, height,\n                                      align, mode,\n                                      children)\n\n    def get_extent_offsets(self, renderer):\n        \"\"\"\n        update offset of childrens and return the extents of the box\n        \"\"\"\n\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        if self.width is not None:\n            for c in self.get_visible_children():\n                if isinstance(c, PackerBase) and c.mode == \"expand\":\n                    c.set_width(self.width)\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n        whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]\n\n        wd_list = [(w, xd) for w, h, xd, yd in whd_list]\n        width, xdescent, xoffsets = _get_aligned_offsets(wd_list,\n                                                         self.width,\n                                                         self.align)\n\n        pack_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, yoffsets_ = _get_packed_offsets(pack_list, self.height,\n                                                sep, self.mode)\n\n        yoffsets = yoffsets_ + [yd for w, h, xd, yd in whd_list]\n        ydescent = height - yoffsets[0]\n        yoffsets = height - yoffsets\n\n        #w, h, xd, h_yd = whd_list[-1]\n        yoffsets = yoffsets - ydescent\n\n        return width + 2 * pad, height + 2 * pad, \\\n               xdescent + pad, ydescent + pad, \\\n               list(zip(xoffsets, yoffsets))\n\n\nclass HPacker(PackerBase):\n    \"\"\"\n    The HPacker has its children packed horizontally. It automatically\n    adjusts the relative positions of children at draw time.\n    \"\"\"\n    def __init__(self, pad=None, sep=None, width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\",\n                 children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, optional\n            Boundary pad.\n\n        sep : float, optional\n            Spacing between items.\n\n        width : float, optional\n\n        height : float, optional\n           Width and height of the container box, calculated if\n           `None`.\n\n        align : str\n           Alignment of boxes.\n\n        mode : str\n           Packing mode.\n\n        Notes\n        -----\n        *pad* and *sep* need to given in points and will be scale with\n        the renderer dpi, while *width* and *height* need to be in\n        pixels.\n        \"\"\"\n        super(HPacker, self).__init__(pad, sep, width, height,\n                                      align, mode, children)\n\n    def get_extent_offsets(self, renderer):\n        \"\"\"\n        update offset of children and return the extents of the box\n        \"\"\"\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n\n        if not whd_list:\n            return 2 * pad, 2 * pad, pad, pad, []\n\n        if self.height is None:\n            height_descent = max([h - yd for w, h, xd, yd in whd_list])\n            ydescent = max([yd for w, h, xd, yd in whd_list])\n            height = height_descent + ydescent\n        else:\n            height = self.height - 2 * pad  # width w/o pad\n\n        hd_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, ydescent, yoffsets = _get_aligned_offsets(hd_list,\n                                                          self.height,\n                                                          self.align)\n\n        pack_list = [(w, xd) for w, h, xd, yd in whd_list]\n\n        width, xoffsets_ = _get_packed_offsets(pack_list, self.width,\n                                               sep, self.mode)\n\n        xoffsets = xoffsets_ + [xd for w, h, xd, yd in whd_list]\n\n        xdescent = whd_list[0][2]\n        xoffsets = xoffsets - xdescent\n\n        return width + 2 * pad, height + 2 * pad, \\\n               xdescent + pad, ydescent + pad, \\\n               list(zip(xoffsets, yoffsets))\n\n\nclass PaddedBox(OffsetBox):\n    def __init__(self, child, pad=None, draw_frame=False, patch_attrs=None):\n        \"\"\"\n        *pad* : boundary pad\n\n        .. note::\n          *pad* need to given in points and will be\n          scale with the renderer dpi, while *width* and *height*\n          need to be in pixels.\n        \"\"\"\n\n        super(PaddedBox, self).__init__()\n\n        self.pad = pad\n        self._children = [child]\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=1,  # self.prop.get_size_in_points(),\n            snap=True\n            )\n\n        self.patch.set_boxstyle(\"square\", pad=0)\n\n        if patch_attrs is not None:\n            self.patch.update(patch_attrs)\n\n        self._drawFrame = draw_frame\n\n    def get_extent_offsets(self, renderer):\n        \"\"\"\n        update offset of childrens and return the extents of the box\n        \"\"\"\n\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n\n        w, h, xd, yd = self._children[0].get_extent(renderer)\n\n        return w + 2 * pad, h + 2 * pad, \\\n               xd + pad, yd + pad, \\\n               [(0, 0)]\n\n    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n\n        width, height, xdescent, ydescent, offsets = self.get_extent_offsets(\n                                                        renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n\n        self.draw_frame(renderer)\n\n        for c in self.get_visible_children():\n            c.draw(renderer)\n\n        #bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.x0, bbox.y0,\n                              bbox.width, bbox.height)\n\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n        self.stale = True\n\n    def draw_frame(self, renderer):\n        # update the location and size of the legend\n        bbox = self.get_window_extent(renderer)\n        self.update_frame(bbox)\n\n        if self._drawFrame:\n            self.patch.draw(renderer)\n\n\nclass DrawingArea(OffsetBox):\n    \"\"\"\n    The DrawingArea can contain any Artist as a child. The DrawingArea\n    has a fixed width and height. The position of children relative to\n    the parent is fixed. The children can be clipped at the\n    boundaries of the parent.\n    \"\"\"\n\n    def __init__(self, width, height, xdescent=0.,\n                 ydescent=0., clip=False):\n        \"\"\"\n        *width*, *height* : width and height of the container box.\n        *xdescent*, *ydescent* : descent of the box in x- and y-direction.\n        *clip* : Whether to clip the children\n        \"\"\"\n\n        super(DrawingArea, self).__init__()\n\n        self.width = width\n        self.height = height\n        self.xdescent = xdescent\n        self.ydescent = ydescent\n        self._clip_children = clip\n\n        self.offset_transform = mtransforms.Affine2D()\n        self.offset_transform.clear()\n        self.offset_transform.translate(0, 0)\n\n        self.dpi_transform = mtransforms.Affine2D()\n\n    @property\n    def clip_children(self):\n        \"\"\"\n        If the children of this DrawingArea should be clipped\n        by DrawingArea bounding box.\n        \"\"\"\n        return self._clip_children\n\n    @clip_children.setter\n    def clip_children(self, val):\n        self._clip_children = bool(val)\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"\n        Return the :class:`~matplotlib.transforms.Transform` applied\n        to the children\n        \"\"\"\n        return self.dpi_transform + self.offset_transform\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n        pass\n\n    def set_offset(self, xy):\n        \"\"\"\n        set offset of the container.\n\n        Accept : tuple of x,y cooridnate in disokay units.\n        \"\"\"\n        self._offset = xy\n\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"\n        return offset of the container.\n        \"\"\"\n        return self._offset\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset()  # w, h, xd, yd)\n\n        return mtransforms.Bbox.from_bounds(ox - xd, oy - yd, w, h)\n\n    def get_extent(self, renderer):\n        \"\"\"\n        Return with, height, xdescent, ydescent of box\n        \"\"\"\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        return self.width * dpi_cor, self.height * dpi_cor, \\\n               self.xdescent * dpi_cor, self.ydescent * dpi_cor\n\n    def add_artist(self, a):\n        'Add any :class:`~matplotlib.artist.Artist` to the container box'\n        self._children.append(a)\n        if not a.is_transform_set():\n            a.set_transform(self.get_transform())\n        if self.axes is not None:\n            a.axes = self.axes\n        fig = self.figure\n        if fig is not None:\n            a.set_figure(fig)\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        self.dpi_transform.clear()\n        self.dpi_transform.scale(dpi_cor, dpi_cor)\n\n        # At this point the DrawingArea has a transform\n        # to the display space so the path created is\n        # good for clipping children\n        tpath = mtransforms.TransformedPath(\n            mpath.Path([[0, 0], [0, self.height],\n                        [self.width, self.height],\n                        [self.width, 0]]),\n            self.get_transform())\n        for c in self._children:\n            if self._clip_children and not (c.clipbox or c._clippath):\n                c.set_clip_path(tpath)\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass TextArea(OffsetBox):\n    \"\"\"\n    The TextArea is contains a single Text instance. The text is\n    placed at (0,0) with baseline+left alignment. The width and height\n    of the TextArea instance is the width and height of the its child\n    text.\n    \"\"\"\n    def __init__(self, s,\n                 textprops=None,\n                 multilinebaseline=None,\n                 minimumdescent=True,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            a string to be displayed.\n\n        textprops : `~matplotlib.font_manager.FontProperties`, optional\n\n        multilinebaseline : bool, optional\n            If `True`, baseline for multiline text is adjusted so that\n            it is (approximatedly) center-aligned with singleline\n            text.\n\n        minimumdescent : bool, optional\n            If `True`, the box has a minimum descent of \"p\".\n        \"\"\"\n        if textprops is None:\n            textprops = {}\n\n        if \"va\" not in textprops:\n            textprops[\"va\"] = \"baseline\"\n\n        self._text = mtext.Text(0, 0, s, **textprops)\n\n        OffsetBox.__init__(self)\n\n        self._children = [self._text]\n\n        self.offset_transform = mtransforms.Affine2D()\n        self.offset_transform.clear()\n        self.offset_transform.translate(0, 0)\n        self._baseline_transform = mtransforms.Affine2D()\n        self._text.set_transform(self.offset_transform +\n                                 self._baseline_transform)\n\n        self._multilinebaseline = multilinebaseline\n        self._minimumdescent = minimumdescent\n\n    def set_text(self, s):\n        \"Set the text of this area as a string.\"\n        self._text.set_text(s)\n        self.stale = True\n\n    def get_text(self):\n        \"Returns the string representation of this area's text\"\n        return self._text.get_text()\n\n    def set_multilinebaseline(self, t):\n        \"\"\"\n        Set multilinebaseline .\n\n        If True, baseline for multiline text is\n        adjusted so that it is (approximatedly) center-aligned with\n        singleline text.\n        \"\"\"\n        self._multilinebaseline = t\n        self.stale = True\n\n    def get_multilinebaseline(self):\n        \"\"\"\n        get multilinebaseline .\n        \"\"\"\n        return self._multilinebaseline\n\n    def set_minimumdescent(self, t):\n        \"\"\"\n        Set minimumdescent .\n\n        If True, extent of the single line text is adjusted so that\n        it has minimum descent of \"p\"\n        \"\"\"\n        self._minimumdescent = t\n        self.stale = True\n\n    def get_minimumdescent(self):\n        \"\"\"\n        get minimumdescent.\n        \"\"\"\n        return self._minimumdescent\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n        pass\n\n    def set_offset(self, xy):\n        \"\"\"\n        set offset of the container.\n\n        Accept : tuple of x,y coordinates in display units.\n        \"\"\"\n        self._offset = xy\n\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"\n        return offset of the container.\n        \"\"\"\n        return self._offset\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset()  # w, h, xd, yd)\n        return mtransforms.Bbox.from_bounds(ox - xd, oy - yd, w, h)\n\n    def get_extent(self, renderer):\n        clean_line, ismath = self._text.is_math_text(self._text._text)\n        _, h_, d_ = renderer.get_text_width_height_descent(\n            \"lp\", self._text._fontproperties, ismath=False)\n\n        bbox, info, d = self._text._get_layout(renderer)\n        w, h = bbox.width, bbox.height\n\n        line = info[-1][0]  # last line\n\n        self._baseline_transform.clear()\n\n        if len(info) > 1 and self._multilinebaseline:\n            d_new = 0.5 * h - 0.5 * (h_ - d_)\n            self._baseline_transform.translate(0, d - d_new)\n            d = d_new\n\n        else:  # single line\n\n            h_d = max(h_ - d_, h - d)\n\n            if self.get_minimumdescent():\n                ## to have a minimum descent, #i.e., \"l\" and \"p\" have same\n                ## descents.\n                d = max(d, d_)\n            #else:\n            #    d = d\n\n            h = h_d + d\n\n        return w, h, 0., d\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n\n        self._text.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass AuxTransformBox(OffsetBox):\n    \"\"\"\n    Offset Box with the aux_transform . Its children will be\n    transformed with the aux_transform first then will be\n    offseted. The absolute coordinate of the aux_transform is meaning\n    as it will be automatically adjust so that the left-lower corner\n    of the bounding box of children will be set to (0,0) before the\n    offset transform.\n\n    It is similar to drawing area, except that the extent of the box\n    is not predetermined but calculated from the window extent of its\n    children. Furthermore, the extent of the children will be\n    calculated in the transformed coordinate.\n    \"\"\"\n    def __init__(self, aux_transform):\n        self.aux_transform = aux_transform\n        OffsetBox.__init__(self)\n\n        self.offset_transform = mtransforms.Affine2D()\n        self.offset_transform.clear()\n        self.offset_transform.translate(0, 0)\n\n        # ref_offset_transform is used to make the offset_transform is\n        # always reference to the lower-left corner of the bbox of its\n        # children.\n        self.ref_offset_transform = mtransforms.Affine2D()\n        self.ref_offset_transform.clear()\n\n        self.dpi_transform = mtransforms.Affine2D()\n\n    def add_artist(self, a):\n        'Add any :class:`~matplotlib.artist.Artist` to the container box'\n        self._children.append(a)\n        a.set_transform(self.get_transform())\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"\n        Return the :class:`~matplotlib.transforms.Transform` applied\n        to the children\n        \"\"\"\n        return self.aux_transform + \\\n               self.ref_offset_transform + \\\n               self.dpi_transform + \\\n               self.offset_transform\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n        pass\n\n    def set_offset(self, xy):\n        \"\"\"\n        set offset of the container.\n\n        Accept : tuple of x,y coordinate in disokay units.\n        \"\"\"\n        self._offset = xy\n\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"\n        return offset of the container.\n        \"\"\"\n        return self._offset\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset()  # w, h, xd, yd)\n        return mtransforms.Bbox.from_bounds(ox - xd, oy - yd, w, h)\n\n    def get_extent(self, renderer):\n\n        # clear the transforms, restored later\n        _off = self.offset_transform.to_values()\n        _dpi = self.dpi_transform.to_values()\n        self.ref_offset_transform.clear()\n        self.offset_transform.clear()\n        self.dpi_transform.clear()\n\n        # calculate the extent\n        bboxes = [c.get_window_extent(renderer) for c in self._children]\n        ub = mtransforms.Bbox.union(bboxes)\n\n        # adjust ref_offset_tansform\n        self.ref_offset_transform.translate(-ub.x0, -ub.y0)\n\n        # restore offset transform\n        mtx = self.offset_transform.matrix_from_values(*_off)\n        self.offset_transform.set_matrix(mtx)\n\n        # restore dpi transform\n        mtx = self.dpi_transform.matrix_from_values(*_dpi)\n        self.dpi_transform.set_matrix(mtx)\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        return ub.width*dpi_cor, ub.height*dpi_cor, 0., 0.\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        self.dpi_transform.clear()\n        self.dpi_transform.scale(dpi_cor, dpi_cor)\n\n        for c in self._children:\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass AnchoredOffsetbox(OffsetBox):\n    \"\"\"\n    An offset box placed according to the legend location\n    loc. AnchoredOffsetbox has a single child. When multiple children\n    is needed, use other OffsetBox class to enclose them.  By default,\n    the offset box is anchored against its parent axes. You may\n    explicitly specify the bbox_to_anchor.\n    \"\"\"\n    zorder = 5  # zorder of the legend\n\n    def __init__(self, loc,\n                 pad=0.4, borderpad=0.5,\n                 child=None, prop=None, frameon=True,\n                 bbox_to_anchor=None,\n                 bbox_transform=None,\n                 **kwargs):\n        \"\"\"\n        loc is a string or an integer specifying the legend location.\n        The valid  location codes are::\n\n        'upper right'  : 1,\n        'upper left'   : 2,\n        'lower left'   : 3,\n        'lower right'  : 4,\n        'right'        : 5,\n        'center left'  : 6,\n        'center right' : 7,\n        'lower center' : 8,\n        'upper center' : 9,\n        'center'       : 10,\n\n        pad : pad around the child for drawing a frame. given in\n          fraction of fontsize.\n\n        borderpad : pad between offsetbox frame and the bbox_to_anchor,\n\n        child : OffsetBox instance that will be anchored.\n\n        prop : font property. This is only used as a reference for paddings.\n\n        frameon : draw a frame box if True.\n\n        bbox_to_anchor : bbox to anchor. Use self.axes.bbox if None.\n\n        bbox_transform : with which the bbox_to_anchor will be transformed.\n\n        \"\"\"\n        super(AnchoredOffsetbox, self).__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=rcParams[\"legend.fontsize\"])\n        elif isinstance(prop, dict):\n            self.prop = FontProperties(**prop)\n            if \"size\" not in prop:\n                self.prop.set_size(rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = prop\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True\n            )\n        self.patch.set_boxstyle(\"square\", pad=0)\n        self._drawFrame = frameon\n\n    def set_child(self, child):\n        \"set the child to be anchored\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True\n\n    def get_child(self):\n        \"return the child\"\n        return self._child\n\n    def get_children(self):\n        \"return the list of children\"\n        return [self._child]\n\n    def get_extent(self, renderer):\n        \"\"\"\n        return the extent of the artist. The extent of the child\n        added with the pad is returned\n        \"\"\"\n        w, h, xd, yd = self.get_child().get_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n\n        return w + 2 * pad, h + 2 * pad, xd + pad, yd + pad\n\n    def get_bbox_to_anchor(self):\n        \"\"\"\n        return the bbox that the legend will be anchored\n        \"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor,\n                                       transform)\n\n    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        set the bbox that the child will be anchored.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError:\n                raise ValueError(\"Invalid argument for bbox : %s\" % str(bbox))\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        self._update_offset_func(renderer)\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset(w, h, xd, yd, renderer)\n        return Bbox.from_bounds(ox - xd, oy - yd, w, h)\n\n    def _update_offset_func(self, renderer, fontsize=None):\n        \"\"\"\n        Update the offset func which depends on the dpi of the\n        renderer (because of the padding).\n        \"\"\"\n        if fontsize is None:\n            fontsize = renderer.points_to_pixels(\n                            self.prop.get_size_in_points())\n\n        def _offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self):\n            bbox = Bbox.from_bounds(0, 0, w, h)\n            borderpad = self.borderpad * fontsize\n            bbox_to_anchor = self.get_bbox_to_anchor()\n\n            x0, y0 = self._get_anchored_bbox(self.loc,\n                                             bbox,\n                                             bbox_to_anchor,\n                                             borderpad)\n            return x0 + xd, y0 + yd\n\n        self.set_offset(_offset)\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.x0, bbox.y0,\n                              bbox.width, bbox.height)\n\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n\n    def draw(self, renderer):\n        \"draw the artist\"\n\n        if not self.get_visible():\n            return\n\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self._update_offset_func(renderer, fontsize)\n\n        if self._drawFrame:\n            # update the location and size of the legend\n            bbox = self.get_window_extent(renderer)\n            self.update_frame(bbox, fontsize)\n            self.patch.draw(renderer)\n\n        width, height, xdescent, ydescent = self.get_extent(renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False\n\n    def _get_anchored_bbox(self, loc, bbox, parentbbox, borderpad):\n        \"\"\"\n        return the position of the bbox anchored at the parentbbox\n        with the loc code, with the borderpad.\n        \"\"\"\n        assert loc in range(1, 11)  # called only internally\n\n        BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C = list(xrange(11))\n\n        anchor_coefs = {UR: \"NE\",\n                        UL: \"NW\",\n                        LL: \"SW\",\n                        LR: \"SE\",\n                        R: \"E\",\n                        CL: \"W\",\n                        CR: \"E\",\n                        LC: \"S\",\n                        UC: \"N\",\n                        C: \"C\"}\n\n        c = anchor_coefs[loc]\n\n        container = parentbbox.padded(-borderpad)\n        anchored_box = bbox.anchored(c, container=container)\n        return anchored_box.x0, anchored_box.y0\n\n\nclass AnchoredText(AnchoredOffsetbox):\n    \"\"\"\n    AnchoredOffsetbox with Text.\n    \"\"\"\n\n    def __init__(self, s, loc, pad=0.4, borderpad=0.5, prop=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        s : string\n            Text.\n\n        loc : str\n            Location code.\n\n        pad : float, optional\n            Pad between the text and the frame as fraction of the font\n            size.\n\n        borderpad : float, optional\n            Pad between the frame and the axes (or *bbox_to_anchor*).\n\n        prop : `matplotlib.font_manager.FontProperties`\n            Font properties.\n\n        Notes\n        -----\n        Other keyword parameters of `AnchoredOffsetbox` are also\n        allowed.\n        \"\"\"\n\n        if prop is None:\n            prop = {}\n        propkeys = list(six.iterkeys(prop))\n        badkwargs = ('ha', 'horizontalalignment', 'va', 'verticalalignment')\n        if set(badkwargs) & set(propkeys):\n            warnings.warn(\"Mixing horizontalalignment or verticalalignment \"\n                    \"with AnchoredText is not supported.\")\n\n        self.txt = TextArea(s, textprops=prop,\n                            minimumdescent=False)\n        fp = self.txt._text.get_fontproperties()\n\n        super(AnchoredText, self).__init__(loc, pad=pad, borderpad=borderpad,\n                                           child=self.txt,\n                                           prop=fp,\n                                           **kwargs)\n\n\nclass OffsetImage(OffsetBox):\n    def __init__(self, arr,\n                 zoom=1,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=1,\n                 filterrad=4.0,\n                 resample=False,\n                 dpi_cor=True,\n                 **kwargs\n                 ):\n\n        OffsetBox.__init__(self)\n        self._dpi_cor = dpi_cor\n\n        self.image = BboxImage(bbox=self.get_window_extent,\n                               cmap=cmap,\n                               norm=norm,\n                               interpolation=interpolation,\n                               origin=origin,\n                               filternorm=filternorm,\n                               filterrad=filterrad,\n                               resample=resample,\n                               **kwargs\n                               )\n\n        self._children = [self.image]\n\n        self.set_zoom(zoom)\n        self.set_data(arr)\n\n    def set_data(self, arr):\n        self._data = np.asarray(arr)\n        self.image.set_data(self._data)\n        self.stale = True\n\n    def get_data(self):\n        return self._data\n\n    def set_zoom(self, zoom):\n        self._zoom = zoom\n        self.stale = True\n\n    def get_zoom(self):\n        return self._zoom\n\n#     def set_axes(self, axes):\n#         self.image.set_axes(axes)\n#         martist.Artist.set_axes(self, axes)\n\n#     def set_offset(self, xy):\n#         \"\"\"\n#         set offset of the container.\n\n#         Accept : tuple of x,y coordinate in disokay units.\n#         \"\"\"\n#         self._offset = xy\n\n#         self.offset_transform.clear()\n#         self.offset_transform.translate(xy[0], xy[1])\n\n    def get_offset(self):\n        \"\"\"\n        return offset of the container.\n        \"\"\"\n        return self._offset\n\n    def get_children(self):\n        return [self.image]\n\n    def get_window_extent(self, renderer):\n        '''\n        get the bounding box in display space.\n        '''\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset()\n        return mtransforms.Bbox.from_bounds(ox - xd, oy - yd, w, h)\n\n    def get_extent(self, renderer):\n        if self._dpi_cor:  # True, do correction\n            dpi_cor = renderer.points_to_pixels(1.)\n        else:\n            dpi_cor = 1.\n\n        zoom = self.get_zoom()\n        data = self.get_data()\n        ny, nx = data.shape[:2]\n        w, h = dpi_cor * nx * zoom, dpi_cor * ny * zoom\n\n        return w, h, 0, 0\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the children\n        \"\"\"\n        self.image.draw(renderer)\n        # bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass AnnotationBbox(martist.Artist, _AnnotationBase):\n    \"\"\"\n    Annotation-like class, but with offsetbox instead of Text.\n    \"\"\"\n    zorder = 3\n\n    def __str__(self):\n        return \"AnnotationBbox(%g,%g)\" % (self.xy[0], self.xy[1])\n\n    @docstring.dedent_interpd\n    def __init__(self, offsetbox, xy,\n                 xybox=None,\n                 xycoords='data',\n                 boxcoords=None,\n                 frameon=True, pad=0.4,  # BboxPatch\n                 annotation_clip=None,\n                 box_alignment=(0.5, 0.5),\n                 bboxprops=None,\n                 arrowprops=None,\n                 fontsize=None,\n                 **kwargs):\n        \"\"\"\n        *offsetbox* : OffsetBox instance\n\n        *xycoords* : same as Annotation but can be a tuple of two\n           strings which are interpreted as x and y coordinates.\n\n        *boxcoords* : similar to textcoords as Annotation but can be a\n           tuple of two strings which are interpreted as x and y\n           coordinates.\n\n        *box_alignment* : a tuple of two floats for a vertical and\n           horizontal alignment of the offset box w.r.t. the *boxcoords*.\n           The lower-left corner is (0.0) and upper-right corner is (1.1).\n\n        other parameters are identical to that of Annotation.\n        \"\"\"\n\n        martist.Artist.__init__(self, **kwargs)\n        _AnnotationBase.__init__(self,\n                                 xy,\n                                 xycoords=xycoords,\n                                 annotation_clip=annotation_clip)\n\n        self.offsetbox = offsetbox\n\n        self.arrowprops = arrowprops\n\n        self.set_fontsize(fontsize)\n\n        if xybox is None:\n            self.xybox = xy\n        else:\n            self.xybox = xybox\n\n        if boxcoords is None:\n            self.boxcoords = xycoords\n        else:\n            self.boxcoords = boxcoords\n\n        if arrowprops is not None:\n            self._arrow_relpos = self.arrowprops.pop(\"relpos\", (0.5, 0.5))\n            self.arrow_patch = FancyArrowPatch((0, 0), (1, 1),\n                                               **self.arrowprops)\n        else:\n            self._arrow_relpos = None\n            self.arrow_patch = None\n\n        #self._fw, self._fh = 0., 0. # for alignment\n        self._box_alignment = box_alignment\n\n        # frame\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True\n            )\n        self.patch.set_boxstyle(\"square\", pad=pad)\n        if bboxprops:\n            self.patch.set(**bboxprops)\n        self._drawFrame = frameon\n\n    @property\n    def xyann(self):\n        return self.xybox\n\n    @xyann.setter\n    def xyann(self, xyann):\n        self.xybox = xyann\n        self.stale = True\n\n    @property\n    def anncoords(self):\n        return self.boxcoords\n\n    @anncoords.setter\n    def anncoords(self, coords):\n        self.boxcoords = coords\n        self.stale = True\n\n    def contains(self, event):\n        t, tinfo = self.offsetbox.contains(event)\n        #if self.arrow_patch is not None:\n        #    a,ainfo=self.arrow_patch.contains(event)\n        #    t = t or a\n\n        # self.arrow_patch is currently not checked as this can be a line - JJ\n\n        return t, tinfo\n\n    def get_children(self):\n        children = [self.offsetbox, self.patch]\n        if self.arrow_patch:\n            children.append(self.arrow_patch)\n        return children\n\n    def set_figure(self, fig):\n\n        if self.arrow_patch is not None:\n            self.arrow_patch.set_figure(fig)\n        self.offsetbox.set_figure(fig)\n        martist.Artist.set_figure(self, fig)\n\n    def set_fontsize(self, s=None):\n        \"\"\"\n        set fontsize in points\n        \"\"\"\n        if s is None:\n            s = rcParams[\"legend.fontsize\"]\n\n        self.prop = FontProperties(size=s)\n        self.stale = True\n\n    def get_fontsize(self, s=None):\n        \"\"\"\n        return fontsize in points\n        \"\"\"\n        return self.prop.get_size_in_points()\n\n    def update_positions(self, renderer):\n        \"\"\"\n        Update the pixel positions of the annotated point and the text.\n        \"\"\"\n        xy_pixel = self._get_position_xy(renderer)\n        self._update_position_xybox(renderer, xy_pixel)\n\n        mutation_scale = renderer.points_to_pixels(self.get_fontsize())\n        self.patch.set_mutation_scale(mutation_scale)\n\n        if self.arrow_patch:\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n    def _update_position_xybox(self, renderer, xy_pixel):\n        \"\"\"\n        Update the pixel positions of the annotation text and the arrow\n        patch.\n        \"\"\"\n\n        x, y = self.xybox\n        if isinstance(self.boxcoords, tuple):\n            xcoord, ycoord = self.boxcoords\n            x1, y1 = self._get_xy(renderer, x, y, xcoord)\n            x2, y2 = self._get_xy(renderer, x, y, ycoord)\n            ox0, oy0 = x1, y2\n        else:\n            ox0, oy0 = self._get_xy(renderer, x, y, self.boxcoords)\n\n        w, h, xd, yd = self.offsetbox.get_extent(renderer)\n\n        _fw, _fh = self._box_alignment\n        self.offsetbox.set_offset((ox0 - _fw * w + xd, oy0 - _fh * h + yd))\n\n        # update patch position\n        bbox = self.offsetbox.get_window_extent(renderer)\n        #self.offsetbox.set_offset((ox0-_fw*w, oy0-_fh*h))\n        self.patch.set_bounds(bbox.x0, bbox.y0,\n                              bbox.width, bbox.height)\n\n        x, y = xy_pixel\n\n        ox1, oy1 = x, y\n\n        if self.arrowprops:\n            x0, y0 = x, y\n\n            d = self.arrowprops.copy()\n\n            # Use FancyArrowPatch if self.arrowprops has \"arrowstyle\" key.\n\n            # adjust the starting point of the arrow relative to\n            # the textbox.\n            # TODO : Rotation needs to be accounted.\n            relpos = self._arrow_relpos\n\n            ox0 = bbox.x0 + bbox.width * relpos[0]\n            oy0 = bbox.y0 + bbox.height * relpos[1]\n\n            # The arrow will be drawn from (ox0, oy0) to (ox1,\n            # oy1). It will be first clipped by patchA and patchB.\n            # Then it will be shrinked by shirnkA and shrinkB\n            # (in points). If patch A is not set, self.bbox_patch\n            # is used.\n\n            self.arrow_patch.set_positions((ox0, oy0), (ox1, oy1))\n            fs = self.prop.get_size_in_points()\n            mutation_scale = d.pop(\"mutation_scale\", fs)\n            mutation_scale = renderer.points_to_pixels(mutation_scale)\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n            patchA = d.pop(\"patchA\", self.patch)\n            self.arrow_patch.set_patchA(patchA)\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the :class:`Annotation` object to the given *renderer*.\n        \"\"\"\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n\n        xy_pixel = self._get_position_xy(renderer)\n\n        if not self._check_xy(renderer, xy_pixel):\n            return\n\n        self.update_positions(renderer)\n\n        if self.arrow_patch is not None:\n            if self.arrow_patch.figure is None and self.figure is not None:\n                self.arrow_patch.figure = self.figure\n            self.arrow_patch.draw(renderer)\n\n        if self._drawFrame:\n            self.patch.draw(renderer)\n\n        self.offsetbox.draw(renderer)\n        self.stale = False\n\n\nclass DraggableBase(object):\n    \"\"\"\n    helper code for a draggable artist (legend, offsetbox)\n    The derived class must override following two method.\n\n      def saveoffset(self):\n          pass\n\n      def update_offset(self, dx, dy):\n          pass\n\n    *saveoffset* is called when the object is picked for dragging and it is\n    meant to save reference position of the artist.\n\n    *update_offset* is called during the dragging. dx and dy is the pixel\n     offset from the point where the mouse drag started.\n\n    Optionally you may override following two methods.\n\n      def artist_picker(self, artist, evt):\n          return self.ref_artist.contains(evt)\n\n      def finalize_offset(self):\n          pass\n\n    *artist_picker* is a picker method that will be\n     used. *finalize_offset* is called when the mouse is released. In\n     current implementaion of DraggableLegend and DraggableAnnotation,\n     *update_offset* places the artists simply in display\n     coordinates. And *finalize_offset* recalculate their position in\n     the normalized axes coordinate and set a relavant attribute.\n\n    \"\"\"\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        self.got_artist = False\n\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n\n        c2 = self.canvas.mpl_connect('pick_event', self.on_pick)\n        c3 = self.canvas.mpl_connect('button_release_event', self.on_release)\n\n        ref_artist.set_picker(self.artist_picker)\n        self.cids = [c2, c3]\n\n    def on_motion(self, evt):\n        if self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            self.canvas.draw()\n\n    def on_motion_blit(self, evt):\n        if self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            self.canvas.restore_region(self.background)\n            self.ref_artist.draw(self.ref_artist.figure._cachedRenderer)\n            self.canvas.blit(self.ref_artist.figure.bbox)\n\n    def on_pick(self, evt):\n        if evt.artist == self.ref_artist:\n\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = self.canvas.copy_from_bbox(\n                                    self.ref_artist.figure.bbox)\n                self.ref_artist.draw(self.ref_artist.figure._cachedRenderer)\n                self.canvas.blit(self.ref_artist.figure.bbox)\n                self._c1 = self.canvas.mpl_connect('motion_notify_event',\n                                                   self.on_motion_blit)\n            else:\n                self._c1 = self.canvas.mpl_connect('motion_notify_event',\n                                                   self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self.got_artist:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def disconnect(self):\n        \"\"\"disconnect the callbacks\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def artist_picker(self, artist, evt):\n        return self.ref_artist.contains(evt)\n\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n\nclass DraggableOffsetBox(DraggableBase):\n    def __init__(self, ref_artist, offsetbox, use_blit=False):\n        DraggableBase.__init__(self, ref_artist, use_blit=use_blit)\n        self.offsetbox = offsetbox\n\n    def save_offset(self):\n        offsetbox = self.offsetbox\n        renderer = offsetbox.figure._cachedRenderer\n        w, h, xd, yd = offsetbox.get_extent(renderer)\n        offset = offsetbox.get_offset(w, h, xd, yd, renderer)\n        self.offsetbox_x, self.offsetbox_y = offset\n        self.offsetbox.set_offset(offset)\n\n    def update_offset(self, dx, dy):\n        loc_in_canvas = self.offsetbox_x + dx, self.offsetbox_y + dy\n        self.offsetbox.set_offset(loc_in_canvas)\n\n    def get_loc_in_canvas(self):\n\n        offsetbox = self.offsetbox\n        renderer = offsetbox.figure._cachedRenderer\n        w, h, xd, yd = offsetbox.get_extent(renderer)\n        ox, oy = offsetbox._offset\n        loc_in_canvas = (ox - xd, oy - yd)\n\n        return loc_in_canvas\n\n\nclass DraggableAnnotation(DraggableBase):\n    def __init__(self, annotation, use_blit=False):\n        DraggableBase.__init__(self, annotation, use_blit=use_blit)\n        self.annotation = annotation\n\n    def save_offset(self):\n        ann = self.annotation\n        self.ox, self.oy = ann.get_transform().transform(ann.xyann)\n\n    def update_offset(self, dx, dy):\n        ann = self.annotation\n        ann.xyann = ann.get_transform().inverted().transform(\n            (self.ox + dx, self.oy + dy))\n\n\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n    fig = plt.figure(1)\n    fig.clf()\n    ax = plt.subplot(121)\n\n    #txt = ax.text(0.5, 0.5, \"Test\", size=30, ha=\"center\", color=\"w\")\n    kwargs = dict()\n\n    a = np.arange(256).reshape(16, 16) / 256.\n    myimage = OffsetImage(a,\n                          zoom=2,\n                          norm=None,\n                          origin=None,\n                          **kwargs\n                          )\n    ax.add_artist(myimage)\n\n    myimage.set_offset((100, 100))\n\n    myimage2 = OffsetImage(a,\n                           zoom=2,\n                           norm=None,\n                           origin=None,\n                           **kwargs\n                           )\n    ann = AnnotationBbox(myimage2, (0.5, 0.5),\n                         xybox=(30, 30),\n                         xycoords='data',\n                         boxcoords=\"offset points\",\n                         frameon=True, pad=0.4,  # BboxPatch\n                         bboxprops=dict(boxstyle=\"round\", fc=\"y\"),\n                         fontsize=None,\n                         arrowprops=dict(arrowstyle=\"->\"),\n                         )\n\n    ax.add_artist(ann)\n\n    plt.draw()\n    plt.show()\n"
    }
  ],
  "questions": [
    "yes, looks like #7344 is related.\r\n\r\nCan anyone help me out: what's the reason for having `mpl_toolkits/axes_grid`,  `mpl_toolkits/axes_grid1`, `mpl_toolkits/axisartist` and `matplotlib/offsetbox.py`? Should there some cleaning up happen or shoudn't one touch/move/delete anything?"
  ],
  "golden_answers": [
    "`axes_grid` is the original, and `axes_grid1` and `axisartist` are split versions of them. I'm pretty sure `matplotlib.offsetbox` is the real implementation and the others just import it (of whatever's implemented there, anyway.) I've got a bit of cleanup ready for as soon as I've finished #7545."
  ],
  "questions_generated": [
    "What is the primary issue with the AnchoredText in the matplotlib repository as described in the issue?",
    "How can the zorder for an AnchoredText element be set given the current limitations discussed in the issue?",
    "Why is it important to handle the zorder argument correctly in matplotlib artists, particularly within the context of anchored artists?",
    "What is the historical context of the `mpl_toolkits.axes_grid` and related modules mentioned in the discussion, and how might this affect the implementation of changes?",
    "What potential related issues or bugs are hinted at in the discussion, and how might they influence the development of a solution for the zorder problem?"
  ],
  "golden_answers_generated": [
    "The primary issue is that AnchoredText and other items from `mpl_toolkits.axes_grid.anchored_artists` do not accept the `zorder` argument. As a result, elements like AnchoredText cannot be layered correctly in terms of their rendering order in relation to other plot elements, such as lines or markers, which can accept a `zorder` argument.",
    "Despite the limitation that AnchoredText does not accept a `zorder` argument directly, the zorder can be set by directly assigning a value to the `zorder` attribute of the AnchoredText object after its creation, e.g., `at.zorder = 20`.",
    "Handling the zorder argument correctly is crucial because it determines the rendering order of plot elements. In visualizations, certain elements need to be layered above others for clarity and aesthetics. For instance, text annotations might need to appear above plot lines to remain legible. Without correct zorder handling, such elements might be obscured or rendered in an unintended order, affecting the overall readability and presentation of the plot.",
    "The `mpl_toolkits.axes_grid` is the original implementation, while `axes_grid1` and `axisartist` are split versions of it. `matplotlib.offsetbox` implements some of the functionalities, and the others might just import from it. Any changes need to be made carefully to avoid breaking user code, as these modules have evolved over time, potentially leading to duplication or overlapping functionality. Cleaning up these modules would require careful planning to maintain backward compatibility.",
    "The discussion hints at other possible bugs in anchored artists, such as those related to the scalebar, which the contributor considers cleaning up. These related issues suggest that there might be broader inconsistencies or limitations within the anchored artists module that need addressing. Developing a solution for the zorder problem could be an opportunity to review and possibly refactor the entire module to address these related issues, ensuring a more robust and consistent implementation."
  ]
}