{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "15182",
  "issue_description": "# More tests `ConciseDateFormatter` needed\n\n> Would we need to draw the conclusion that `ConciseDateFormatter` is not sufficiently tested, or is this code path too non-standard?\r\n\r\n_Originally posted by @ImportanceOfBeingErnest in https://github.com/matplotlib/matplotlib/pull/15181#issuecomment-527936743_\r\n\r\nIndeed the `format` and `zero_format` options should get tests, including checks if they are wrong-sized, etc.  ~Promise to do this ASAP~....  or happy to help a newer contributor through writing these tests.  ",
  "issue_comments": [
    {
      "id": 529205772,
      "user": "sameshl",
      "body": "@jklymak I would love to take this up"
    },
    {
      "id": 529214848,
      "user": "jklymak",
      "body": "That would be great!  Let us know if you need guidance."
    },
    {
      "id": 543920602,
      "user": "abhinuvpitale",
      "body": "@sameshl are you on this, or else I could get started on this.\r\n"
    },
    {
      "id": 544213661,
      "user": "sameshl",
      "body": "@abhinuvpitale You can get started on this."
    },
    {
      "id": 546185400,
      "user": "abhinuvpitale",
      "body": "@jklymak I need to add the tests in the `test_dates.py` right?\r\nA little guidance on the test content would be helpful."
    },
    {
      "id": 546535825,
      "user": "jklymak",
      "body": "That’s right `test_dates.py`.  The content would be checking that the formatter makes the correct format if you change `format` and `zero_format`"
    },
    {
      "id": 573943757,
      "user": "stevenjlm",
      "body": "Since this thread seems kind of dead, I wrote 2 tests and have code for it (it's on a branch on my forked copy of `matplotlib`); however, when I run tests locally, a lot of them fail because `dateutil` throws a deprecation warning. Since this is not `matplotlib`, should I ignore it? Or should I do something?"
    },
    {
      "id": 573945850,
      "user": "jklymak",
      "body": " I guess that depends on why `dateutil` is throwing a deprecation warning?"
    },
    {
      "id": 573948440,
      "user": "stevenjlm",
      "body": "Full trace:\r\n[trace.txt](https://github.com/matplotlib/matplotlib/files/4056776/trace.txt)\r\nThe relevant line is,\r\nDeprecationWarning: fractions.gcd() is deprecated. Use math.gcd() instead.\r\n"
    },
    {
      "id": 573991501,
      "user": "jklymak",
      "body": "Thanks. That’s dateutils issue so fee free to ignore it.  Or report it to them if you can make a non matplotlib mi nimble example. "
    }
  ],
  "text_context": "# More tests `ConciseDateFormatter` needed\n\n> Would we need to draw the conclusion that `ConciseDateFormatter` is not sufficiently tested, or is this code path too non-standard?\r\n\r\n_Originally posted by @ImportanceOfBeingErnest in https://github.com/matplotlib/matplotlib/pull/15181#issuecomment-527936743_\r\n\r\nIndeed the `format` and `zero_format` options should get tests, including checks if they are wrong-sized, etc.  ~Promise to do this ASAP~....  or happy to help a newer contributor through writing these tests.  \n\n@jklymak I would love to take this up\n\nThat would be great!  Let us know if you need guidance.\n\n@sameshl are you on this, or else I could get started on this.\r\n\n\n@abhinuvpitale You can get started on this.\n\n@jklymak I need to add the tests in the `test_dates.py` right?\r\nA little guidance on the test content would be helpful.\n\nThat’s right `test_dates.py`.  The content would be checking that the formatter makes the correct format if you change `format` and `zero_format`\n\nSince this thread seems kind of dead, I wrote 2 tests and have code for it (it's on a branch on my forked copy of `matplotlib`); however, when I run tests locally, a lot of them fail because `dateutil` throws a deprecation warning. Since this is not `matplotlib`, should I ignore it? Or should I do something?\n\n I guess that depends on why `dateutil` is throwing a deprecation warning?\n\nFull trace:\r\n[trace.txt](https://github.com/matplotlib/matplotlib/files/4056776/trace.txt)\r\nThe relevant line is,\r\nDeprecationWarning: fractions.gcd() is deprecated. Use math.gcd() instead.\r\n\n\nThanks. That’s dateutils issue so fee free to ignore it.  Or report it to them if you can make a non matplotlib mi nimble example. ",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/15181",
  "code_context": [
    {
      "filename": "lib/matplotlib/dates.py",
      "content": "\"\"\"\nMatplotlib provides sophisticated date plotting capabilities, standing on the\nshoulders of python :mod:`datetime` and the add-on module :mod:`dateutil`.\n\n\n.. _date-format:\n\nMatplotlib date format\n----------------------\nMatplotlib represents dates using floating point numbers specifying the number\nof days since 0001-01-01 UTC, plus 1.  For example, 0001-01-01, 06:00 is 1.25,\nnot 0.25. Values < 1, i.e. dates before 0001-01-01 UTC, are not supported.\n\nThere are a number of helper functions to convert between :mod:`datetime`\nobjects and Matplotlib dates:\n\n.. currentmodule:: matplotlib.dates\n\n.. autosummary::\n   :nosignatures:\n\n   datestr2num\n   date2num\n   num2date\n   num2timedelta\n   epoch2num\n   num2epoch\n   drange\n\n.. note::\n\n   Like Python's datetime, Matplotlib uses the Gregorian calendar for all\n   conversions between dates and floating point numbers. This practice\n   is not universal, and calendar differences can cause confusing\n   differences between what Python and Matplotlib give as the number of days\n   since 0001-01-01 and what other software and databases yield.  For\n   example, the US Naval Observatory uses a calendar that switches\n   from Julian to Gregorian in October, 1582.  Hence, using their\n   calculator, the number of days between 0001-01-01 and 2006-04-01 is\n   732403, whereas using the Gregorian calendar via the datetime\n   module we find::\n\n     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()\n     Out[1]: 732401\n\nAll the Matplotlib date converters, tickers and formatters are timezone aware.\nIf no explicit timezone is provided, :rc:`timezone` is assumed.  If you want to\nuse a custom time zone, pass a `datetime.tzinfo` instance with the tz keyword\nargument to `num2date`, `~.Axes.plot_date`, and any custom date tickers or\nlocators you create.\n\nA wide range of specific and general purpose date tick locators and\nformatters are provided in this module.  See\n:mod:`matplotlib.ticker` for general information on tick locators\nand formatters.  These are described below.\n\nThe dateutil_ module provides additional code to handle date ticking, making it\neasy to place ticks on any kinds of dates.  See examples below.\n\n.. _dateutil: https://dateutil.readthedocs.io\n\nDate tickers\n------------\n\nMost of the date tickers can locate single or multiple values.  For\nexample::\n\n    # import constants for the days of the week\n    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU\n\n    # tick on mondays every week\n    loc = WeekdayLocator(byweekday=MO, tz=tz)\n\n    # tick on mondays and saturdays\n    loc = WeekdayLocator(byweekday=(MO, SA))\n\nIn addition, most of the constructors take an interval argument::\n\n    # tick on mondays every second week\n    loc = WeekdayLocator(byweekday=MO, interval=2)\n\nThe rrule locator allows completely general date ticking::\n\n    # tick every 5th easter\n    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)\n    loc = RRuleLocator(rule)\n\nThe available date tickers are:\n\n* `MicrosecondLocator`: locate microseconds\n\n* `SecondLocator`: locate seconds\n\n* `MinuteLocator`: locate minutes\n\n* `HourLocator`: locate hours\n\n* `DayLocator`: locate specified days of the month\n\n* `WeekdayLocator`: Locate days of the week, e.g., MO, TU\n\n* `MonthLocator`: locate months, e.g., 7 for july\n\n* `YearLocator`: locate years that are multiples of base\n\n* `RRuleLocator`: locate using a `matplotlib.dates.rrulewrapper`.\n  `.rrulewrapper` is a simple wrapper around dateutil_'s `dateutil.rrule` which\n  allow almost arbitrary date tick specifications.  See :doc:`rrule example\n  </gallery/ticks_and_spines/date_demo_rrule>`.\n\n* `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`\n  (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If\n  called with ``interval_multiples=True`` it will make ticks line up with\n  sensible multiples of the tick intervals.  E.g. if the interval is 4 hours,\n  it will pick hours 0, 4, 8, etc as ticks.  This behaviour is not guaranteed\n  by default.\n\nDate formatters\n---------------\n\nThe available date formatters are:\n\n* `AutoDateFormatter`: attempts to figure out the best format to use.  This is\n  most useful when used with the `AutoDateLocator`.\n\n* `ConciseDateFormatter`: also attempts to figure out the best format to use,\n  and to make the format as compact as possible while still having complete\n  date information.  This is most useful when used with the `AutoDateLocator`.\n\n* `DateFormatter`: use `strftime` format strings.\n\n* `IndexDateFormatter`: date plots with implicit *x* indexing.\n\"\"\"\n\nimport datetime\nimport functools\nimport logging\nimport math\nimport re\nimport time\nimport warnings\n\nfrom dateutil.rrule import (rrule, MO, TU, WE, TH, FR, SA, SU, YEARLY,\n                            MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n                            SECONDLY)\nfrom dateutil.relativedelta import relativedelta\nimport dateutil.parser\nimport dateutil.tz\nimport numpy as np\n\nimport matplotlib\nfrom matplotlib import rcParams\nimport matplotlib.units as units\nimport matplotlib.cbook as cbook\nimport matplotlib.ticker as ticker\n\n__all__ = ('datestr2num', 'date2num', 'num2date', 'num2timedelta', 'drange',\n           'epoch2num', 'num2epoch', 'mx2num', 'DateFormatter',\n           'ConciseDateFormatter', 'IndexDateFormatter', 'AutoDateFormatter',\n           'DateLocator', 'RRuleLocator', 'AutoDateLocator', 'YearLocator',\n           'MonthLocator', 'WeekdayLocator',\n           'DayLocator', 'HourLocator', 'MinuteLocator',\n           'SecondLocator', 'MicrosecondLocator',\n           'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU',\n           'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',\n           'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta',\n           'seconds', 'minutes', 'hours', 'weeks')\n\n\n_log = logging.getLogger(__name__)\nUTC = datetime.timezone.utc\n\n\ndef _get_rc_timezone():\n    \"\"\"Retrieve the preferred timezone from the rcParams dictionary.\"\"\"\n    s = matplotlib.rcParams['timezone']\n    if s == 'UTC':\n        return UTC\n    return dateutil.tz.gettz(s)\n\n\n\"\"\"\nTime-related constants.\n\"\"\"\nEPOCH_OFFSET = float(datetime.datetime(1970, 1, 1).toordinal())\nJULIAN_OFFSET = 1721424.5                         # Julian date at 0001-01-01\nMICROSECONDLY = SECONDLY + 1\nHOURS_PER_DAY = 24.\nMIN_PER_HOUR = 60.\nSEC_PER_MIN = 60.\nMONTHS_PER_YEAR = 12.\n\nDAYS_PER_WEEK = 7.\nDAYS_PER_MONTH = 30.\nDAYS_PER_YEAR = 365.0\n\nMINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY\n\nSEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR\nSEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY\nSEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK\n\nMUSECONDS_PER_DAY = 1e6 * SEC_PER_DAY\n\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY = (\n    MO, TU, WE, TH, FR, SA, SU)\nWEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)\n\n\ndef _to_ordinalf(dt):\n    \"\"\"\n    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float\n    days, preserving hours, minutes, seconds and microseconds.  Return value\n    is a :func:`float`.\n    \"\"\"\n    # Convert to UTC\n    tzi = getattr(dt, 'tzinfo', None)\n    if tzi is not None:\n        dt = dt.astimezone(UTC)\n        tzi = UTC\n\n    base = float(dt.toordinal())\n\n    # If it's sufficiently datetime-like, it will have a `date()` method\n    cdate = getattr(dt, 'date', lambda: None)()\n    if cdate is not None:\n        # Get a datetime object at midnight UTC\n        midnight_time = datetime.time(0, tzinfo=tzi)\n\n        rdt = datetime.datetime.combine(cdate, midnight_time)\n\n        # Append the seconds as a fraction of a day\n        base += (dt - rdt).total_seconds() / SEC_PER_DAY\n\n    return base\n\n\n# a version of _to_ordinalf that can operate on numpy arrays\n_to_ordinalf_np_vectorized = np.vectorize(_to_ordinalf)\n\n\ndef _dt64_to_ordinalf(d):\n    \"\"\"\n    Convert `numpy.datetime64` or an ndarray of those types to Gregorian\n    date as UTC float.  Roundoff is via float64 precision.  Practically:\n    microseconds for dates between 290301 BC, 294241 AD, milliseconds for\n    larger dates (see `numpy.datetime64`).  Nanoseconds aren't possible\n    because we do times compared to ``0001-01-01T00:00:00`` (plus one day).\n    \"\"\"\n\n    # the \"extra\" ensures that we at least allow the dynamic range out to\n    # seconds.  That should get out to +/-2e11 years.\n    extra = (d - d.astype('datetime64[s]')).astype('timedelta64[ns]')\n    t0 = np.datetime64('0001-01-01T00:00:00', 's')\n    dt = (d.astype('datetime64[s]') - t0).astype(np.float64)\n    dt += extra.astype(np.float64) / 1.0e9\n    dt = dt / SEC_PER_DAY + 1.0\n\n    NaT_int = np.datetime64('NaT').astype(np.int64)\n    d_int = d.astype(np.int64)\n    try:\n        dt[d_int == NaT_int] = np.nan\n    except TypeError:\n        if d_int == NaT_int:\n            dt = np.nan\n    return dt\n\n\ndef _from_ordinalf(x, tz=None):\n    \"\"\"\n    Convert Gregorian float of the date, preserving hours, minutes,\n    seconds and microseconds.  Return value is a `.datetime`.\n\n    The input date *x* is a float in ordinal days at UTC, and the output will\n    be the specified `.datetime` object corresponding to that time in\n    timezone *tz*, or if *tz* is ``None``, in the timezone specified in\n    :rc:`timezone`.\n    \"\"\"\n    if tz is None:\n        tz = _get_rc_timezone()\n\n    ix, remainder = divmod(x, 1)\n    ix = int(ix)\n    if ix < 1:\n        raise ValueError('Cannot convert {} to a date.  This often happens if '\n                         'non-datetime values are passed to an axis that '\n                         'expects datetime objects.'.format(ix))\n    dt = datetime.datetime.fromordinal(ix).replace(tzinfo=UTC)\n\n    # Since the input date *x* float is unable to preserve microsecond\n    # precision of time representation in non-antique years, the\n    # resulting datetime is rounded to the nearest multiple of\n    # `musec_prec`. A value of 20 is appropriate for current dates.\n    musec_prec = 20\n    remainder_musec = int(round(remainder * MUSECONDS_PER_DAY / musec_prec)\n                          * musec_prec)\n\n    # For people trying to plot with full microsecond precision, enable\n    # an early-year workaround\n    if x < 30 * 365:\n        remainder_musec = int(round(remainder * MUSECONDS_PER_DAY))\n\n    # add hours, minutes, seconds, microseconds\n    dt += datetime.timedelta(microseconds=remainder_musec)\n    return dt.astimezone(tz)\n\n\n# a version of _from_ordinalf that can operate on numpy arrays\n_from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf)\n\n\n@cbook.deprecated(\n    \"3.1\", alternative=\"time.strptime or dateutil.parser.parse or datestr2num\")\nclass strpdate2num:\n    \"\"\"\n    Use this class to parse date strings to matplotlib datenums when\n    you know the date format string of the date you are parsing.\n    \"\"\"\n    def __init__(self, fmt):\n        \"\"\"\n        Parameters\n        ----------\n        fmt : any valid strptime format\n        \"\"\"\n        self.fmt = fmt\n\n    def __call__(self, s):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n\n        Returns\n        -------\n        date2num float\n        \"\"\"\n        return date2num(datetime.datetime(*time.strptime(s, self.fmt)[:6]))\n\n\n@cbook.deprecated(\n    \"3.1\", alternative=\"time.strptime or dateutil.parser.parse or datestr2num\")\nclass bytespdate2num(strpdate2num):\n    \"\"\"\n    Use this class to parse date strings to matplotlib datenums when\n    you know the date format string of the date you are parsing.  See\n    :doc:`/gallery/misc/load_converter.py`.\n    \"\"\"\n    def __init__(self, fmt, encoding='utf-8'):\n        \"\"\"\n        Parameters\n        ----------\n        fmt : any valid strptime format\n        encoding : str\n            Encoding to use on byte input.\n        \"\"\"\n        super().__init__(fmt)\n        self.encoding = encoding\n\n    def __call__(self, b):\n        \"\"\"\n        Parameters\n        ----------\n        b : bytes\n\n        Returns\n        -------\n        date2num float\n        \"\"\"\n        s = b.decode(self.encoding)\n        return super().__call__(s)\n\n\n# a version of dateutil.parser.parse that can operate on numpy arrays\n_dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse)\n\n\ndef datestr2num(d, default=None):\n    \"\"\"\n    Convert a date string to a datenum using :func:`dateutil.parser.parse`.\n\n    Parameters\n    ----------\n    d : str or sequence of str\n        The dates to convert.\n\n    default : datetime instance, optional\n        The default date to use when fields are missing in *d*.\n    \"\"\"\n    if isinstance(d, str):\n        dt = dateutil.parser.parse(d, default=default)\n        return date2num(dt)\n    else:\n        if default is not None:\n            d = [dateutil.parser.parse(s, default=default) for s in d]\n        d = np.asarray(d)\n        if not d.size:\n            return d\n        return date2num(_dateutil_parser_parse_np_vectorized(d))\n\n\ndef date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds, ms)\n        since 0001-01-01 00:00:00 UTC, plus one.\n\n    Notes\n    -----\n    The addition of one here is a historical artifact. Also, note that the\n    Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    if hasattr(d, \"values\"):\n        # this unpacks pandas series or dataframes...\n        d = d.values\n    if not np.iterable(d):\n        if (isinstance(d, np.datetime64) or\n                (isinstance(d, np.ndarray) and\n                 np.issubdtype(d.dtype, np.datetime64))):\n            return _dt64_to_ordinalf(d)\n        return _to_ordinalf(d)\n\n    else:\n        d = np.asarray(d)\n        if np.issubdtype(d.dtype, np.datetime64):\n            return _dt64_to_ordinalf(d)\n        if not d.size:\n            return d\n        return _to_ordinalf_np_vectorized(d)\n\n\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian date(s)\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib date(s)\n    \"\"\"\n    return np.subtract(j, JULIAN_OFFSET)  # Handles both scalar & nonscalar j.\n\n\ndef num2julian(n):\n    \"\"\"\n    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).\n\n    Parameters\n    ----------\n    n : float or sequence of floats\n        Matplotlib date(s)\n\n    Returns\n    -------\n    float or sequence of floats\n        Julian date(s)\n    \"\"\"\n    return np.add(n, JULIAN_OFFSET)  # Handles both scalar & nonscalar j.\n\n\ndef num2date(x, tz=None):\n    \"\"\"\n    Convert Matplotlib dates to `~datetime.datetime` objects.\n\n    Parameters\n    ----------\n    x : float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds)\n        since 0001-01-01 00:00:00 UTC, plus one.\n    tz : str, optional\n        Timezone of *x* (defaults to rcparams ``timezone``).\n\n    Returns\n    -------\n    `~datetime.datetime` or sequence of `~datetime.datetime`\n        Dates are returned in timezone *tz*.\n\n        If *x* is a sequence, a sequence of :class:`datetime` objects will\n        be returned.\n\n    Notes\n    -----\n    The addition of one here is a historical artifact. Also, note that the\n    Gregorian calendar is assumed; this is not universal practice.\n    For details, see the module docstring.\n    \"\"\"\n    if tz is None:\n        tz = _get_rc_timezone()\n    if not np.iterable(x):\n        return _from_ordinalf(x, tz)\n    else:\n        x = np.asarray(x)\n        if not x.size:\n            return x\n        return _from_ordinalf_np_vectorized(x, tz).tolist()\n\n\ndef _ordinalf_to_timedelta(x):\n    return datetime.timedelta(days=x)\n\n\n_ordinalf_to_timedelta_np_vectorized = np.vectorize(_ordinalf_to_timedelta)\n\n\ndef num2timedelta(x):\n    \"\"\"\n    Convert number of days to a `~datetime.timedelta` object.\n\n    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will\n    be returned.\n\n    Parameters\n    ----------\n    x : float, sequence of floats\n        Number of days. The fraction part represents hours, minutes, seconds.\n\n    Returns\n    -------\n    `datetime.timedelta` or list[`datetime.timedelta`]\n\n    \"\"\"\n    if not np.iterable(x):\n        return _ordinalf_to_timedelta(x)\n    else:\n        x = np.asarray(x)\n        if not x.size:\n            return x\n        return _ordinalf_to_timedelta_np_vectorized(x).tolist()\n\n\ndef drange(dstart, dend, delta):\n    \"\"\"\n    Return a sequence of equally spaced Matplotlib dates.\n\n    The dates start at *dstart* and reach up to, but not including *dend*.\n    They are spaced by *delta*.\n\n    Parameters\n    ----------\n    dstart, dend : `~datetime.datetime`\n        The date limits.\n    delta : `datetime.timedelta`\n        Spacing of the dates.\n\n    Returns\n    -------\n    drange : `numpy.array`\n        A list floats representing Matplotlib dates.\n\n    \"\"\"\n    f1 = date2num(dstart)\n    f2 = date2num(dend)\n    step = delta.total_seconds() / SEC_PER_DAY\n\n    # calculate the difference between dend and dstart in times of delta\n    num = int(np.ceil((f2 - f1) / step))\n\n    # calculate end of the interval which will be generated\n    dinterval_end = dstart + num * delta\n\n    # ensure, that an half open interval will be generated [dstart, dend)\n    if dinterval_end >= dend:\n        # if the endpoint is greater than dend, just subtract one delta\n        dinterval_end -= delta\n        num -= 1\n\n    f2 = date2num(dinterval_end)  # new float-endpoint\n    return np.linspace(f1, f2, num + 1)\n\n## date tickers and formatters ###\n\n\nclass DateFormatter(ticker.Formatter):\n    \"\"\"\n    Format a tick (in seconds since the epoch) with a `strftime` format string.\n    \"\"\"\n\n    illegal_s = re.compile(r\"((^|[^%])(%%)*%s)\")\n\n    def __init__(self, fmt, tz=None):\n        \"\"\"\n        Parameters\n        ----------\n        fmt : str\n            `strftime` format string\n        tz : `tzinfo`\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.fmt = fmt\n        self.tz = tz\n\n    def __call__(self, x, pos=0):\n        if x == 0:\n            raise ValueError('DateFormatter found a value of x=0, which is '\n                             'an illegal date; this usually occurs because '\n                             'you have not informed the axis that it is '\n                             'plotting dates, e.g., with ax.xaxis_date()')\n        return num2date(x, self.tz).strftime(self.fmt)\n\n    def set_tzinfo(self, tz):\n        self.tz = tz\n\n\nclass IndexDateFormatter(ticker.Formatter):\n    \"\"\"\n    Use with :class:`~matplotlib.ticker.IndexLocator` to cycle format\n    strings by index.\n    \"\"\"\n    def __init__(self, t, fmt, tz=None):\n        \"\"\"\n        *t* is a sequence of dates (floating point days).  *fmt* is a\n        :func:`strftime` format string.\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.t = t\n        self.fmt = fmt\n        self.tz = tz\n\n    def __call__(self, x, pos=0):\n        'Return the label for time *x* at position *pos*'\n        ind = int(round(x))\n        if ind >= len(self.t) or ind <= 0:\n            return ''\n        return num2date(self.t[ind], self.tz).strftime(self.fmt)\n\n\nclass ConciseDateFormatter(ticker.Formatter):\n    \"\"\"\n    This class attempts to figure out the best format to use for the\n    date, and to make it as compact as possible, but still be complete. This is\n    most useful when used with the :class:`AutoDateLocator`::\n\n\n    >>> locator = AutoDateLocator()\n    >>> formatter = ConciseDateFormatter(locator)\n\n    Parameters\n    ----------\n    locator : `.ticker.Locator`\n        Locator that this axis is using.\n\n    tz : str, optional\n        Passed to `.dates.date2num`.\n\n    formats : list of 6 strings, optional\n        Format strings for 6 levels of tick labelling: mostly years,\n        months, days, hours, minutes, and seconds.  Strings use\n        the same format codes as `strftime`.  Default is\n        ``['%Y', '%b', '%d', '%H:%M', '%H:%M', '%S.%f']``\n\n    zero_formats : list of 6 strings, optional\n        Format strings for tick labels that are \"zeros\" for a given tick\n        level.  For instance, if most ticks are months, ticks around 1 Jan 2005\n        will be labeled \"Dec\", \"2005\", \"Feb\".  The default is\n        ``['', '%Y', '%b', '%b-%d', '%H:%M', '%H:%M']``\n\n    offset_formats : list of 6 strings, optional\n        Format strings for the 6 levels that is applied to the \"offset\"\n        string found on the right side of an x-axis, or top of a y-axis.\n        Combined with the tick labels this should completely specify the\n        date.  The default is::\n\n            ['', '%Y', '%Y-%b', '%Y-%b-%d', '%Y-%b-%d', '%Y-%b-%d %H:%M']\n\n    show_offset : bool\n        Whether to show the offset or not.  Default is ``True``.\n\n    Examples\n    --------\n    See :doc:`/gallery/ticks_and_spines/date_concise_formatter`\n\n    .. plot::\n\n        import datetime\n        import matplotlib.dates as mdates\n\n        base = datetime.datetime(2005, 2, 1)\n        dates = np.array([base + datetime.timedelta(hours=(2 * i))\n                          for i in range(732)])\n        N = len(dates)\n        np.random.seed(19680801)\n        y = np.cumsum(np.random.randn(N))\n\n        fig, ax = plt.subplots(constrained_layout=True)\n        locator = mdates.AutoDateLocator()\n        formatter = mdates.ConciseDateFormatter(locator)\n        ax.xaxis.set_major_locator(locator)\n        ax.xaxis.set_major_formatter(formatter)\n\n        ax.plot(dates, y)\n        ax.set_title('Concise Date Formatter')\n\n    \"\"\"\n\n    def __init__(self, locator, tz=None, formats=None, offset_formats=None,\n                 zero_formats=None, show_offset=True):\n        \"\"\"\n        Autoformat the date labels.  The default format is used to form an\n        initial string, and then redundant elements are removed.\n        \"\"\"\n        self._locator = locator\n        self._tz = tz\n        self.defaultfmt = '%Y'\n        # there are 6 levels with each level getting a specific format\n        # 0: mostly years,  1: months,  2: days,\n        # 3: hours, 4: minutes, 5: seconds\n        if formats:\n            if len(formats) != 6:\n                raise ValueError('formats argument must be a list of '\n                                 '6 format strings (or None)')\n            self.formats = formats\n        else:\n            self.formats = ['%Y',  # ticks are mostly years\n                            '%b',          # ticks are mostly months\n                            '%d',          # ticks are mostly days\n                            '%H:%M',       # hrs\n                            '%H:%M',       # min\n                            '%S.%f',       # secs\n                            ]\n        # fmt for zeros ticks at this level.  These are\n        # ticks that should be labeled w/ info the level above.\n        # like 1 Jan can just be labled \"Jan\".  02:02:00 can\n        # just be labeled 02:02.\n        if zero_formats:\n            if len(zero_formats) != 6:\n                raise ValueError('zero_formats argument must be a list of '\n                                 '6 format strings (or None)')\n            self.zero_formats = zero_formats\n        elif formats:\n            # use the users formats for the zero tick formats\n            self.zero_formats = [''] + self.formats[:-1]\n        else:\n            # make the defaults a bit nicer:\n            self.zero_formats = [''] + self.formats[:-1]\n            self.zero_formats[3] = '%b-%d'\n\n        if offset_formats:\n            if len(offset_formats) != 6:\n                raise ValueError('offsetfmts argument must be a list of '\n                                 '6 format strings (or None)')\n            self.offset_formats = offset_formats\n        else:\n            self.offset_formats = ['',\n                                   '%Y',\n                                   '%Y-%b',\n                                   '%Y-%b-%d',\n                                   '%Y-%b-%d',\n                                   '%Y-%b-%d %H:%M']\n        self.offset_string = ''\n        self.show_offset = show_offset\n\n    def __call__(self, x, pos=None):\n        formatter = DateFormatter(self.defaultfmt, self._tz)\n        return formatter(x, pos=pos)\n\n    def format_ticks(self, values):\n        tickdatetime = [num2date(value) for value in values]\n        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n\n        # basic algorithm:\n        # 1) only display a part of the date if it changes over the ticks.\n        # 2) don't display the smaller part of the date if:\n        #    it is always the same or if it is the start of the\n        #    year, month, day etc.\n        # fmt for most ticks at this level\n        fmts = self.formats\n        # format beginnings of days, months, years, etc...\n        zerofmts = self.zero_formats\n        # offset fmt are for the offset in the upper left of the\n        # or lower right of the axis.\n        offsetfmts = self.offset_formats\n\n        # determine the level we will label at:\n        # mostly 0: years,  1: months,  2: days,\n        # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n        for level in range(5, -1, -1):\n            if len(np.unique(tickdate[:, level])) > 1:\n                break\n\n        # level is the basic level we will label at.\n        # now loop through and decide the actual ticklabels\n        zerovals = [0, 1, 1, 0, 0, 0, 0]\n        labels = [''] * len(tickdate)\n        for nn in range(len(tickdate)):\n            if level < 5:\n                if tickdate[nn][level] == zerovals[level]:\n                    fmt = zerofmts[level]\n                else:\n                    fmt = fmts[level]\n            else:\n                # special handling for seconds + microseconds\n                if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n                        == 0):\n                    fmt = zerofmts[level]\n                else:\n                    fmt = fmts[level]\n            labels[nn] = tickdatetime[nn].strftime(fmt)\n\n        # special handling of seconds and microseconds:\n        # strip extra zeros and decimal if possible.\n        # this is complicated by two factors.  1) we have some level-4 strings\n        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n        # same number of decimals for each string (i.e. 0.5 and 1.0).\n        if level >= 5:\n            trailing_zeros = min(\n                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n                default=None)\n            if trailing_zeros:\n                for nn in range(len(labels)):\n                    if '.' in labels[nn]:\n                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n\n        if self.show_offset:\n            # set the offset string:\n            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n\n        return labels\n\n    def get_offset(self):\n        return self.offset_string\n\n    def format_data_short(self, value):\n        return num2date(value).strftime('%Y-%m-%d %H:%M:%S')\n\n\nclass AutoDateFormatter(ticker.Formatter):\n    \"\"\"\n    This class attempts to figure out the best format to use.  This is\n    most useful when used with the :class:`AutoDateLocator`.\n\n    The AutoDateFormatter has a scale dictionary that maps the scale\n    of the tick (the distance in days between one major tick) and a\n    format string.  The default looks like this::\n\n        self.scaled = {\n            DAYS_PER_YEAR: rcParams['date.autoformat.year'],\n            DAYS_PER_MONTH: rcParams['date.autoformat.month'],\n            1.0: rcParams['date.autoformat.day'],\n            1. / HOURS_PER_DAY: rcParams['date.autoformat.hour'],\n            1. / (MINUTES_PER_DAY): rcParams['date.autoformat.minute'],\n            1. / (SEC_PER_DAY): rcParams['date.autoformat.second'],\n            1. / (MUSECONDS_PER_DAY): rcParams['date.autoformat.microsecond'],\n            }\n\n\n    The algorithm picks the key in the dictionary that is >= the\n    current scale and uses that format string.  You can customize this\n    dictionary by doing::\n\n\n    >>> locator = AutoDateLocator()\n    >>> formatter = AutoDateFormatter(locator)\n    >>> formatter.scaled[1/(24.*60.)] = '%M:%S' # only show min and sec\n\n    A custom :class:`~matplotlib.ticker.FuncFormatter` can also be used.\n    The following example shows how to use a custom format function to strip\n    trailing zeros from decimal seconds and adds the date to the first\n    ticklabel::\n\n        >>> def my_format_function(x, pos=None):\n        ...     x = matplotlib.dates.num2date(x)\n        ...     if pos == 0:\n        ...         fmt = '%D %H:%M:%S.%f'\n        ...     else:\n        ...         fmt = '%H:%M:%S.%f'\n        ...     label = x.strftime(fmt)\n        ...     label = label.rstrip(\"0\")\n        ...     label = label.rstrip(\".\")\n        ...     return label\n        >>> from matplotlib.ticker import FuncFormatter\n        >>> formatter.scaled[1/(24.*60.)] = FuncFormatter(my_format_function)\n    \"\"\"\n\n    # This can be improved by providing some user-level direction on\n    # how to choose the best format (precedence, etc...)\n\n    # Perhaps a 'struct' that has a field for each time-type where a\n    # zero would indicate \"don't show\" and a number would indicate\n    # \"show\" with some sort of priority.  Same priorities could mean\n    # show all with the same priority.\n\n    # Or more simply, perhaps just a format string for each\n    # possibility...\n\n    def __init__(self, locator, tz=None, defaultfmt='%Y-%m-%d'):\n        \"\"\"\n        Autoformat the date labels.  The default format is the one to use\n        if none of the values in ``self.scaled`` are greater than the unit\n        returned by ``locator._get_unit()``.\n        \"\"\"\n        self._locator = locator\n        self._tz = tz\n        self.defaultfmt = defaultfmt\n        self._formatter = DateFormatter(self.defaultfmt, tz)\n        self.scaled = {DAYS_PER_YEAR: rcParams['date.autoformatter.year'],\n                       DAYS_PER_MONTH: rcParams['date.autoformatter.month'],\n                       1.0: rcParams['date.autoformatter.day'],\n                       1. / HOURS_PER_DAY: rcParams['date.autoformatter.hour'],\n                       1. / (MINUTES_PER_DAY):\n                           rcParams['date.autoformatter.minute'],\n                       1. / (SEC_PER_DAY):\n                           rcParams['date.autoformatter.second'],\n                       1. / (MUSECONDS_PER_DAY):\n                           rcParams['date.autoformatter.microsecond']}\n\n    def _set_locator(self, locator):\n        self._locator = locator\n\n    def __call__(self, x, pos=None):\n        try:\n            locator_unit_scale = float(self._locator._get_unit())\n        except AttributeError:\n            locator_unit_scale = 1\n        # Pick the first scale which is greater than the locator unit.\n        fmt = next((fmt for scale, fmt in sorted(self.scaled.items())\n                    if scale >= locator_unit_scale),\n                   self.defaultfmt)\n\n        if isinstance(fmt, str):\n            self._formatter = DateFormatter(fmt, self._tz)\n            result = self._formatter(x, pos)\n        elif callable(fmt):\n            result = fmt(x, pos)\n        else:\n            raise TypeError('Unexpected type passed to {0!r}.'.format(self))\n\n        return result\n\n\nclass rrulewrapper:\n    def __init__(self, freq, tzinfo=None, **kwargs):\n        kwargs['freq'] = freq\n        self._base_tzinfo = tzinfo\n\n        self._update_rrule(**kwargs)\n\n    def set(self, **kwargs):\n        self._construct.update(kwargs)\n\n        self._update_rrule(**self._construct)\n\n    def _update_rrule(self, **kwargs):\n        tzinfo = self._base_tzinfo\n\n        # rrule does not play nicely with time zones - especially pytz time\n        # zones, it's best to use naive zones and attach timezones once the\n        # datetimes are returned\n        if 'dtstart' in kwargs:\n            dtstart = kwargs['dtstart']\n            if dtstart.tzinfo is not None:\n                if tzinfo is None:\n                    tzinfo = dtstart.tzinfo\n                else:\n                    dtstart = dtstart.astimezone(tzinfo)\n\n                kwargs['dtstart'] = dtstart.replace(tzinfo=None)\n\n        if 'until' in kwargs:\n            until = kwargs['until']\n            if until.tzinfo is not None:\n                if tzinfo is not None:\n                    until = until.astimezone(tzinfo)\n                else:\n                    raise ValueError('until cannot be aware if dtstart '\n                                     'is naive and tzinfo is None')\n\n                kwargs['until'] = until.replace(tzinfo=None)\n\n        self._construct = kwargs.copy()\n        self._tzinfo = tzinfo\n        self._rrule = rrule(**self._construct)\n\n    def _attach_tzinfo(self, dt, tzinfo):\n        # pytz zones are attached by \"localizing\" the datetime\n        if hasattr(tzinfo, 'localize'):\n            return tzinfo.localize(dt, is_dst=True)\n\n        return dt.replace(tzinfo=tzinfo)\n\n    def _aware_return_wrapper(self, f, returns_list=False):\n        \"\"\"Decorator function that allows rrule methods to handle tzinfo.\"\"\"\n        # This is only necessary if we're actually attaching a tzinfo\n        if self._tzinfo is None:\n            return f\n\n        # All datetime arguments must be naive. If they are not naive, they are\n        # converted to the _tzinfo zone before dropping the zone.\n        def normalize_arg(arg):\n            if isinstance(arg, datetime.datetime) and arg.tzinfo is not None:\n                if arg.tzinfo is not self._tzinfo:\n                    arg = arg.astimezone(self._tzinfo)\n\n                return arg.replace(tzinfo=None)\n\n            return arg\n\n        def normalize_args(args, kwargs):\n            args = tuple(normalize_arg(arg) for arg in args)\n            kwargs = {kw: normalize_arg(arg) for kw, arg in kwargs.items()}\n\n            return args, kwargs\n\n        # There are two kinds of functions we care about - ones that return\n        # dates and ones that return lists of dates.\n        if not returns_list:\n            def inner_func(*args, **kwargs):\n                args, kwargs = normalize_args(args, kwargs)\n                dt = f(*args, **kwargs)\n                return self._attach_tzinfo(dt, self._tzinfo)\n        else:\n            def inner_func(*args, **kwargs):\n                args, kwargs = normalize_args(args, kwargs)\n                dts = f(*args, **kwargs)\n                return [self._attach_tzinfo(dt, self._tzinfo) for dt in dts]\n\n        return functools.wraps(f)(inner_func)\n\n    def __getattr__(self, name):\n        if name in self.__dict__:\n            return self.__dict__[name]\n\n        f = getattr(self._rrule, name)\n\n        if name in {'after', 'before'}:\n            return self._aware_return_wrapper(f)\n        elif name in {'xafter', 'xbefore', 'between'}:\n            return self._aware_return_wrapper(f, returns_list=True)\n        else:\n            return f\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n\n\nclass DateLocator(ticker.Locator):\n    \"\"\"\n    Determines the tick locations when plotting dates.\n\n    This class is subclassed by other Locators and\n    is not meant to be used on its own.\n    \"\"\"\n    hms0d = {'byhour': 0, 'byminute': 0, 'bysecond': 0}\n\n    def __init__(self, tz=None):\n        \"\"\"\n        *tz* is a :class:`tzinfo` instance.\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.tz = tz\n\n    def set_tzinfo(self, tz):\n        \"\"\"\n        Set time zone info.\n        \"\"\"\n        self.tz = tz\n\n    def datalim_to_dt(self):\n        \"\"\"\n        Convert axis data interval to datetime objects.\n        \"\"\"\n        dmin, dmax = self.axis.get_data_interval()\n        if dmin > dmax:\n            dmin, dmax = dmax, dmin\n        if dmin < 1:\n            raise ValueError('datalim minimum {} is less than 1 and '\n                             'is an invalid Matplotlib date value. This often '\n                             'happens if you pass a non-datetime '\n                             'value to an axis that has datetime units'\n                             .format(dmin))\n        return num2date(dmin, self.tz), num2date(dmax, self.tz)\n\n    def viewlim_to_dt(self):\n        \"\"\"\n        Converts the view interval to datetime objects.\n        \"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if vmin < 1:\n            raise ValueError('view limit minimum {} is less than 1 and '\n                             'is an invalid Matplotlib date value. This '\n                             'often happens if you pass a non-datetime '\n                             'value to an axis that has datetime units'\n                             .format(vmin))\n        return num2date(vmin, self.tz), num2date(vmax, self.tz)\n\n    def _get_unit(self):\n        \"\"\"\n        Return how many days a unit of the locator is; used for\n        intelligent autoscaling.\n        \"\"\"\n        return 1\n\n    def _get_interval(self):\n        \"\"\"\n        Return the number of units for each tick.\n        \"\"\"\n        return 1\n\n    def nonsingular(self, vmin, vmax):\n        \"\"\"\n        Given the proposed upper and lower extent, adjust the range\n        if it is too close to being singular (i.e. a range of ~0).\n        \"\"\"\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        unit = self._get_unit()\n        interval = self._get_interval()\n        if abs(vmax - vmin) < 1e-6:\n            vmin -= 2 * unit * interval\n            vmax += 2 * unit * interval\n        return vmin, vmax\n\n\nclass RRuleLocator(DateLocator):\n    # use the dateutil rrule instance\n\n    def __init__(self, o, tz=None):\n        DateLocator.__init__(self, tz)\n        self.rule = o\n\n    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)\n\n    def tick_values(self, vmin, vmax):\n        delta = relativedelta(vmax, vmin)\n\n        # We need to cap at the endpoints of valid datetime\n        try:\n            start = vmin - delta\n        except (ValueError, OverflowError):\n            start = _from_ordinalf(1.0)\n\n        try:\n            stop = vmax + delta\n        except (ValueError, OverflowError):\n            # The magic number!\n            stop = _from_ordinalf(3652059.9999999)\n\n        self.rule.set(dtstart=start, until=stop)\n\n        dates = self.rule.between(vmin, vmax, True)\n        if len(dates) == 0:\n            return date2num([vmin, vmax])\n        return self.raise_if_exceeds(date2num(dates))\n\n    def _get_unit(self):\n        \"\"\"\n        Return how many days a unit of the locator is; used for\n        intelligent autoscaling.\n        \"\"\"\n        freq = self.rule._rrule._freq\n        return self.get_unit_generic(freq)\n\n    @staticmethod\n    def get_unit_generic(freq):\n        if freq == YEARLY:\n            return DAYS_PER_YEAR\n        elif freq == MONTHLY:\n            return DAYS_PER_MONTH\n        elif freq == WEEKLY:\n            return DAYS_PER_WEEK\n        elif freq == DAILY:\n            return 1.0\n        elif freq == HOURLY:\n            return 1.0 / HOURS_PER_DAY\n        elif freq == MINUTELY:\n            return 1.0 / MINUTES_PER_DAY\n        elif freq == SECONDLY:\n            return 1.0 / SEC_PER_DAY\n        else:\n            # error\n            return -1   # or should this just return '1'?\n\n    def _get_interval(self):\n        return self.rule._rrule._interval\n\n    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        \"\"\"\n        Set the view limits to include the data range.\n        \"\"\"\n        dmin, dmax = self.datalim_to_dt()\n        delta = relativedelta(dmax, dmin)\n\n        # We need to cap at the endpoints of valid datetime\n        try:\n            start = dmin - delta\n        except ValueError:\n            start = _from_ordinalf(1.0)\n\n        try:\n            stop = dmax + delta\n        except ValueError:\n            # The magic number!\n            stop = _from_ordinalf(3652059.9999999)\n\n        self.rule.set(dtstart=start, until=stop)\n        dmin, dmax = self.datalim_to_dt()\n\n        vmin = self.rule.before(dmin, True)\n        if not vmin:\n            vmin = dmin\n\n        vmax = self.rule.after(dmax, True)\n        if not vmax:\n            vmax = dmax\n\n        vmin = date2num(vmin)\n        vmax = date2num(vmax)\n\n        return self.nonsingular(vmin, vmax)\n\n\nclass AutoDateLocator(DateLocator):\n    \"\"\"\n    On autoscale, this class picks the best\n    :class:`DateLocator` to set the view limits and the tick\n    locations.\n    \"\"\"\n    def __init__(self, tz=None, minticks=5, maxticks=None,\n                 interval_multiples=True):\n        \"\"\"\n        *minticks* is the minimum number of ticks desired, which is used to\n        select the type of ticking (yearly, monthly, etc.).\n\n        *maxticks* is the maximum number of ticks desired, which controls\n        any interval between ticks (ticking every other, every 3, etc.).\n        For really fine-grained control, this can be a dictionary mapping\n        individual rrule frequency constants (YEARLY, MONTHLY, etc.)\n        to their own maximum number of ticks.  This can be used to keep\n        the number of ticks appropriate to the format chosen in\n        :class:`AutoDateFormatter`. Any frequency not specified in this\n        dictionary is given a default value.\n\n        *tz* is a :class:`tzinfo` instance.\n\n        *interval_multiples* is a boolean that indicates whether ticks\n        should be chosen to be multiple of the interval. This will lock\n        ticks to 'nicer' locations. For example, this will force the\n        ticks to be at hours 0, 6, 12, 18 when hourly ticking is done at\n        6 hour intervals.\n\n        The AutoDateLocator has an interval dictionary that maps the\n        frequency of the tick (a constant from dateutil.rrule) and a\n        multiple allowed for that ticking.  The default looks like this::\n\n          self.intervald = {\n            YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,\n                      1000, 2000, 4000, 5000, 10000],\n            MONTHLY : [1, 2, 3, 4, 6],\n            DAILY   : [1, 2, 3, 7, 14],\n            HOURLY  : [1, 2, 3, 4, 6, 12],\n            MINUTELY: [1, 5, 10, 15, 30],\n            SECONDLY: [1, 5, 10, 15, 30],\n            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,\n                           5000, 10000, 20000, 50000, 100000, 200000, 500000,\n                           1000000],\n            }\n\n        The interval is used to specify multiples that are appropriate for\n        the frequency of ticking. For instance, every 7 days is sensible\n        for daily ticks, but for minutes/seconds, 15 or 30 make sense.\n        You can customize this dictionary by doing::\n\n          locator = AutoDateLocator()\n          locator.intervald[HOURLY] = [3] # only show every 3 hours\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self._locator = YearLocator(tz=tz)\n        self._freq = YEARLY\n        self._freqs = [YEARLY, MONTHLY, DAILY, HOURLY, MINUTELY,\n                       SECONDLY, MICROSECONDLY]\n        self.minticks = minticks\n\n        self.maxticks = {YEARLY: 11, MONTHLY: 12, DAILY: 11, HOURLY: 12,\n                         MINUTELY: 11, SECONDLY: 11, MICROSECONDLY: 8}\n        if maxticks is not None:\n            try:\n                self.maxticks.update(maxticks)\n            except TypeError:\n                # Assume we were given an integer. Use this as the maximum\n                # number of ticks for every frequency and create a\n                # dictionary for this\n                self.maxticks = dict.fromkeys(self._freqs, maxticks)\n        self.interval_multiples = interval_multiples\n        self.intervald = {\n            YEARLY:   [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,\n                       1000, 2000, 4000, 5000, 10000],\n            MONTHLY:  [1, 2, 3, 4, 6],\n            DAILY:    [1, 2, 3, 7, 14, 21],\n            HOURLY:   [1, 2, 3, 4, 6, 12],\n            MINUTELY: [1, 5, 10, 15, 30],\n            SECONDLY: [1, 5, 10, 15, 30],\n            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,\n                            5000, 10000, 20000, 50000, 100000, 200000, 500000,\n                            1000000]}\n        if interval_multiples:\n            # Swap \"3\" for \"4\" in the DAILY list; If we use 3 we get bad\n            # tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1\n            # If we use 4 then we get: 1, 5, ... 25, 29, 1\n            self.intervald[DAILY] = [1, 2, 4, 7, 14, 21]\n\n        self._byranges = [None, range(1, 13), range(1, 32),\n                          range(0, 24), range(0, 60), range(0, 60), None]\n\n    def __call__(self):\n        'Return the locations of the ticks'\n        self.refresh()\n        return self._locator()\n\n    def tick_values(self, vmin, vmax):\n        return self.get_locator(vmin, vmax).tick_values(vmin, vmax)\n\n    def nonsingular(self, vmin, vmax):\n        # whatever is thrown at us, we can scale the unit.\n        # But default nonsingular date plots at an ~4 year period.\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        if vmin == vmax:\n            vmin = vmin - DAYS_PER_YEAR * 2\n            vmax = vmax + DAYS_PER_YEAR * 2\n        return vmin, vmax\n\n    def set_axis(self, axis):\n        DateLocator.set_axis(self, axis)\n        self._locator.set_axis(axis)\n\n    def refresh(self):\n        # docstring inherited\n        dmin, dmax = self.viewlim_to_dt()\n        self._locator = self.get_locator(dmin, dmax)\n\n    def _get_unit(self):\n        if self._freq in [MICROSECONDLY]:\n            return 1. / MUSECONDS_PER_DAY\n        else:\n            return RRuleLocator.get_unit_generic(self._freq)\n\n    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        'Try to choose the view limits intelligently.'\n        dmin, dmax = self.datalim_to_dt()\n        self._locator = self.get_locator(dmin, dmax)\n        return self._locator.autoscale()\n\n    def get_locator(self, dmin, dmax):\n        'Pick the best locator based on a distance.'\n        delta = relativedelta(dmax, dmin)\n        tdelta = dmax - dmin\n\n        # take absolute difference\n        if dmin > dmax:\n            delta = -delta\n            tdelta = -tdelta\n\n        # The following uses a mix of calls to relativedelta and timedelta\n        # methods because there is incomplete overlap in the functionality of\n        # these similar functions, and it's best to avoid doing our own math\n        # whenever possible.\n        numYears = float(delta.years)\n        numMonths = numYears * MONTHS_PER_YEAR + delta.months\n        numDays = tdelta.days   # Avoids estimates of days/month, days/year\n        numHours = numDays * HOURS_PER_DAY + delta.hours\n        numMinutes = numHours * MIN_PER_HOUR + delta.minutes\n        numSeconds = np.floor(tdelta.total_seconds())\n        numMicroseconds = np.floor(tdelta.total_seconds() * 1e6)\n\n        nums = [numYears, numMonths, numDays, numHours, numMinutes,\n                numSeconds, numMicroseconds]\n\n        use_rrule_locator = [True] * 6 + [False]\n\n        # Default setting of bymonth, etc. to pass to rrule\n        # [unused (for year), bymonth, bymonthday, byhour, byminute,\n        #  bysecond, unused (for microseconds)]\n        byranges = [None, 1, 1, 0, 0, 0, None]\n\n        # Loop over all the frequencies and try to find one that gives at\n        # least a minticks tick positions.  Once this is found, look for\n        # an interval from an list specific to that frequency that gives no\n        # more than maxticks tick positions. Also, set up some ranges\n        # (bymonth, etc.) as appropriate to be passed to rrulewrapper.\n        for i, (freq, num) in enumerate(zip(self._freqs, nums)):\n            # If this particular frequency doesn't give enough ticks, continue\n            if num < self.minticks:\n                # Since we're not using this particular frequency, set\n                # the corresponding by_ to None so the rrule can act as\n                # appropriate\n                byranges[i] = None\n                continue\n\n            # Find the first available interval that doesn't give too many\n            # ticks\n            for interval in self.intervald[freq]:\n                if num <= interval * (self.maxticks[freq] - 1):\n                    break\n            else:\n                # We went through the whole loop without breaking, default to\n                # the last interval in the list and raise a warning\n                cbook._warn_external(\n                    f\"AutoDateLocator was unable to pick an appropriate \"\n                    f\"interval for this date range. It may be necessary to \"\n                    f\"add an interval value to the AutoDateLocator's \"\n                    f\"intervald dictionary. Defaulting to {interval}.\")\n\n            # Set some parameters as appropriate\n            self._freq = freq\n\n            if self._byranges[i] and self.interval_multiples:\n                byranges[i] = self._byranges[i][::interval]\n                if i in (DAILY, WEEKLY):\n                    if interval == 14:\n                        # just make first and 15th.  Avoids 30th.\n                        byranges[i] = [1, 15]\n                    elif interval == 7:\n                        byranges[i] = [1, 8, 15, 22]\n\n                interval = 1\n            else:\n                byranges[i] = self._byranges[i]\n            break\n        else:\n            raise ValueError('No sensible date limit could be found in the '\n                             'AutoDateLocator.')\n\n        if (freq == YEARLY) and self.interval_multiples:\n            locator = YearLocator(interval, tz=self.tz)\n        elif use_rrule_locator[i]:\n            _, bymonth, bymonthday, byhour, byminute, bysecond, _ = byranges\n            rrule = rrulewrapper(self._freq, interval=interval,\n                                 dtstart=dmin, until=dmax,\n                                 bymonth=bymonth, bymonthday=bymonthday,\n                                 byhour=byhour, byminute=byminute,\n                                 bysecond=bysecond)\n\n            locator = RRuleLocator(rrule, self.tz)\n        else:\n            locator = MicrosecondLocator(interval, tz=self.tz)\n            if dmin.year > 20 and interval < 1000:\n                cbook._warn_external(\n                    'Plotting microsecond time intervals is not well '\n                    'supported; please see the MicrosecondLocator '\n                    'documentation for details.')\n\n        locator.set_axis(self.axis)\n\n        if self.axis is not None:\n            locator.set_view_interval(*self.axis.get_view_interval())\n            locator.set_data_interval(*self.axis.get_data_interval())\n        return locator\n\n\nclass YearLocator(DateLocator):\n    \"\"\"\n    Make ticks on a given day of each year that is a multiple of base.\n\n    Examples::\n\n      # Tick every year on Jan 1st\n      locator = YearLocator()\n\n      # Tick every 5 years on July 4th\n      locator = YearLocator(5, month=7, day=4)\n    \"\"\"\n    def __init__(self, base=1, month=1, day=1, tz=None):\n        \"\"\"\n        Mark years that are multiple of base on a given month and day\n        (default jan 1).\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self.base = ticker._Edge_integer(base, 0)\n        self.replaced = {'month':  month,\n                         'day':    day,\n                         'hour':   0,\n                         'minute': 0,\n                         'second': 0,\n                         }\n        if not hasattr(tz, 'localize'):\n            # if tz is pytz, we need to do this w/ the localize fcn,\n            # otherwise datetime.replace works fine...\n            self.replaced['tzinfo'] = tz\n\n    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)\n\n    def tick_values(self, vmin, vmax):\n        ymin = self.base.le(vmin.year) * self.base.step\n        ymax = self.base.ge(vmax.year) * self.base.step\n\n        vmin = vmin.replace(year=ymin, **self.replaced)\n        if hasattr(self.tz, 'localize'):\n            # look after pytz\n            if not vmin.tzinfo:\n                vmin = self.tz.localize(vmin, is_dst=True)\n\n        ticks = [vmin]\n\n        while True:\n            dt = ticks[-1]\n            if dt.year >= ymax:\n                return date2num(ticks)\n            year = dt.year + self.base.step\n            dt = dt.replace(year=year, **self.replaced)\n            if hasattr(self.tz, 'localize'):\n                # look after pytz\n                if not dt.tzinfo:\n                    dt = self.tz.localize(dt, is_dst=True)\n\n            ticks.append(dt)\n\n    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        \"\"\"\n        Set the view limits to include the data range.\n        \"\"\"\n        dmin, dmax = self.datalim_to_dt()\n\n        ymin = self.base.le(dmin.year)\n        ymax = self.base.ge(dmax.year)\n        vmin = dmin.replace(year=ymin, **self.replaced)\n        vmin = vmin.astimezone(self.tz)\n        vmax = dmax.replace(year=ymax, **self.replaced)\n        vmax = vmax.astimezone(self.tz)\n\n        vmin = date2num(vmin)\n        vmax = date2num(vmax)\n        return self.nonsingular(vmin, vmax)\n\n\nclass MonthLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each month, e.g., 1, 3, 12.\n    \"\"\"\n    def __init__(self, bymonth=None, bymonthday=1, interval=1, tz=None):\n        \"\"\"\n        Mark every month in *bymonth*; *bymonth* can be an int or\n        sequence.  Default is ``range(1, 13)``, i.e. every month.\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n        \"\"\"\n        if bymonth is None:\n            bymonth = range(1, 13)\n        elif isinstance(bymonth, np.ndarray):\n            # This fixes a bug in dateutil <= 2.3 which prevents the use of\n            # numpy arrays in (among other things) the bymonthday, byweekday\n            # and bymonth parameters.\n            bymonth = [x.item() for x in bymonth.astype(int)]\n\n        rule = rrulewrapper(MONTHLY, bymonth=bymonth, bymonthday=bymonthday,\n                            interval=interval, **self.hms0d)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass WeekdayLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each weekday.\n    \"\"\"\n\n    def __init__(self, byweekday=1, interval=1, tz=None):\n        \"\"\"\n        Mark every weekday in *byweekday*; *byweekday* can be a number or\n        sequence.\n\n        Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,\n        SU, the constants from :mod:`dateutil.rrule`, which have been\n        imported into the :mod:`matplotlib.dates` namespace.\n\n        *interval* specifies the number of weeks to skip.  For example,\n        ``interval=2`` plots every second week.\n        \"\"\"\n        if isinstance(byweekday, np.ndarray):\n            # This fixes a bug in dateutil <= 2.3 which prevents the use of\n            # numpy arrays in (among other things) the bymonthday, byweekday\n            # and bymonth parameters.\n            [x.item() for x in byweekday.astype(int)]\n\n        rule = rrulewrapper(DAILY, byweekday=byweekday,\n                            interval=interval, **self.hms0d)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass DayLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each day of the month.  For example,\n    1, 15, 30.\n    \"\"\"\n    def __init__(self, bymonthday=None, interval=1, tz=None):\n        \"\"\"\n        Mark every day in *bymonthday*; *bymonthday* can be an int or sequence.\n\n        Default is to tick every day of the month: ``bymonthday=range(1, 32)``.\n        \"\"\"\n        if interval != int(interval) or interval < 1:\n            raise ValueError(\"interval must be an integer greater than 0\")\n        if bymonthday is None:\n            bymonthday = range(1, 32)\n        elif isinstance(bymonthday, np.ndarray):\n            # This fixes a bug in dateutil <= 2.3 which prevents the use of\n            # numpy arrays in (among other things) the bymonthday, byweekday\n            # and bymonth parameters.\n            bymonthday = [x.item() for x in bymonthday.astype(int)]\n\n        rule = rrulewrapper(DAILY, bymonthday=bymonthday,\n                            interval=interval, **self.hms0d)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass HourLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each hour.\n    \"\"\"\n    def __init__(self, byhour=None, interval=1, tz=None):\n        \"\"\"\n        Mark every hour in *byhour*; *byhour* can be an int or sequence.\n        Default is to tick every hour: ``byhour=range(24)``\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n        \"\"\"\n        if byhour is None:\n            byhour = range(24)\n\n        rule = rrulewrapper(HOURLY, byhour=byhour, interval=interval,\n                            byminute=0, bysecond=0)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass MinuteLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each minute.\n    \"\"\"\n    def __init__(self, byminute=None, interval=1, tz=None):\n        \"\"\"\n        Mark every minute in *byminute*; *byminute* can be an int or\n        sequence.  Default is to tick every minute: ``byminute=range(60)``\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n        \"\"\"\n        if byminute is None:\n            byminute = range(60)\n\n        rule = rrulewrapper(MINUTELY, byminute=byminute, interval=interval,\n                            bysecond=0)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass SecondLocator(RRuleLocator):\n    \"\"\"\n    Make ticks on occurrences of each second.\n    \"\"\"\n    def __init__(self, bysecond=None, interval=1, tz=None):\n        \"\"\"\n        Mark every second in *bysecond*; *bysecond* can be an int or\n        sequence.  Default is to tick every second: ``bysecond = range(60)``\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n\n        \"\"\"\n        if bysecond is None:\n            bysecond = range(60)\n\n        rule = rrulewrapper(SECONDLY, bysecond=bysecond, interval=interval)\n        RRuleLocator.__init__(self, rule, tz)\n\n\nclass MicrosecondLocator(DateLocator):\n    \"\"\"\n    Make ticks on regular intervals of one or more microsecond(s).\n\n    .. note::\n\n        Due to the floating point representation of time in days since\n        0001-01-01 UTC (plus 1), plotting data with microsecond time\n        resolution does not work well with current dates.\n\n        If you want microsecond resolution time plots, it is strongly\n        recommended to use floating point seconds, not datetime-like\n        time representation.\n\n        If you really must use datetime.datetime() or similar and still\n        need microsecond precision, your only chance is to use very\n        early years; using year 0001 is recommended.\n\n    \"\"\"\n    def __init__(self, interval=1, tz=None):\n        \"\"\"\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second microsecond.\n\n        \"\"\"\n        self._interval = interval\n        self._wrapped_locator = ticker.MultipleLocator(interval)\n        self.tz = tz\n\n    def set_axis(self, axis):\n        self._wrapped_locator.set_axis(axis)\n        return DateLocator.set_axis(self, axis)\n\n    def set_view_interval(self, vmin, vmax):\n        self._wrapped_locator.set_view_interval(vmin, vmax)\n        return DateLocator.set_view_interval(self, vmin, vmax)\n\n    def set_data_interval(self, vmin, vmax):\n        self._wrapped_locator.set_data_interval(vmin, vmax)\n        return DateLocator.set_data_interval(self, vmin, vmax)\n\n    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)\n\n    def tick_values(self, vmin, vmax):\n        nmin, nmax = date2num((vmin, vmax))\n        nmin *= MUSECONDS_PER_DAY\n        nmax *= MUSECONDS_PER_DAY\n        ticks = self._wrapped_locator.tick_values(nmin, nmax)\n        ticks = [tick / MUSECONDS_PER_DAY for tick in ticks]\n        return ticks\n\n    def _get_unit(self):\n        \"\"\"\n        Return how many days a unit of the locator is; used for\n        intelligent autoscaling.\n        \"\"\"\n        return 1. / MUSECONDS_PER_DAY\n\n    def _get_interval(self):\n        \"\"\"\n        Return the number of units for each tick.\n        \"\"\"\n        return self._interval\n\n\ndef epoch2num(e):\n    \"\"\"\n    Convert an epoch or sequence of epochs to the new date format,\n    that is days since 0001.\n    \"\"\"\n    return EPOCH_OFFSET + np.asarray(e) / SEC_PER_DAY\n\n\ndef num2epoch(d):\n    \"\"\"\n    Convert days since 0001 to epoch.  *d* can be a number or sequence.\n    \"\"\"\n    return (np.asarray(d) - EPOCH_OFFSET) * SEC_PER_DAY\n\n\n@cbook.deprecated(\"3.2\")\ndef mx2num(mxdates):\n    \"\"\"\n    Convert mx :class:`datetime` instance (or sequence of mx\n    instances) to the new date format.\n    \"\"\"\n    scalar = False\n    if not np.iterable(mxdates):\n        scalar = True\n        mxdates = [mxdates]\n    ret = epoch2num([m.ticks() for m in mxdates])\n    if scalar:\n        return ret[0]\n    else:\n        return ret\n\n\ndef date_ticker_factory(span, tz=None, numticks=5):\n    \"\"\"\n    Create a date locator with *numticks* (approx) and a date formatter\n    for *span* in days.  Return value is (locator, formatter).\n    \"\"\"\n\n    if span == 0:\n        span = 1 / HOURS_PER_DAY\n\n    mins = span * MINUTES_PER_DAY\n    hrs = span * HOURS_PER_DAY\n    days = span\n    wks = span / DAYS_PER_WEEK\n    months = span / DAYS_PER_MONTH      # Approx\n    years = span / DAYS_PER_YEAR        # Approx\n\n    if years > numticks:\n        locator = YearLocator(int(years / numticks), tz=tz)  # define\n        fmt = '%Y'\n    elif months > numticks:\n        locator = MonthLocator(tz=tz)\n        fmt = '%b %Y'\n    elif wks > numticks:\n        locator = WeekdayLocator(tz=tz)\n        fmt = '%a, %b %d'\n    elif days > numticks:\n        locator = DayLocator(interval=math.ceil(days / numticks), tz=tz)\n        fmt = '%b %d'\n    elif hrs > numticks:\n        locator = HourLocator(interval=math.ceil(hrs / numticks), tz=tz)\n        fmt = '%H:%M\\n%b %d'\n    elif mins > numticks:\n        locator = MinuteLocator(interval=math.ceil(mins / numticks), tz=tz)\n        fmt = '%H:%M:%S'\n    else:\n        locator = MinuteLocator(tz=tz)\n        fmt = '%H:%M:%S'\n\n    formatter = DateFormatter(fmt, tz=tz)\n    return locator, formatter\n\n\n@cbook.deprecated(\"3.1\")\ndef seconds(s):\n    \"\"\"\n    Return seconds as days.\n    \"\"\"\n    return s / SEC_PER_DAY\n\n\n@cbook.deprecated(\"3.1\")\ndef minutes(m):\n    \"\"\"\n    Return minutes as days.\n    \"\"\"\n    return m / MINUTES_PER_DAY\n\n\n@cbook.deprecated(\"3.1\")\ndef hours(h):\n    \"\"\"\n    Return hours as days.\n    \"\"\"\n    return h / HOURS_PER_DAY\n\n\n@cbook.deprecated(\"3.1\")\ndef weeks(w):\n    \"\"\"\n    Return weeks as days.\n    \"\"\"\n    return w * DAYS_PER_WEEK\n\n\nclass DateConverter(units.ConversionInterface):\n    \"\"\"\n    Converter for datetime.date and datetime.datetime data,\n    or for date/time data represented as it would be converted\n    by :func:`date2num`.\n\n    The 'unit' tag for such data is None or a tzinfo instance.\n    \"\"\"\n\n    @staticmethod\n    def axisinfo(unit, axis):\n        \"\"\"\n        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.\n\n        *unit* is a tzinfo instance or None.\n        The *axis* argument is required but not used.\n        \"\"\"\n        tz = unit\n\n        majloc = AutoDateLocator(tz=tz)\n        majfmt = AutoDateFormatter(majloc, tz=tz)\n        datemin = datetime.date(2000, 1, 1)\n        datemax = datetime.date(2010, 1, 1)\n\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='',\n                              default_limits=(datemin, datemax))\n\n    @staticmethod\n    def convert(value, unit, axis):\n        \"\"\"\n        If *value* is not already a number or sequence of numbers,\n        convert it with :func:`date2num`.\n\n        The *unit* and *axis* arguments are not used.\n        \"\"\"\n        return date2num(value)\n\n    @staticmethod\n    def default_units(x, axis):\n        \"\"\"\n        Return the tzinfo instance of *x* or of its first element, or None\n        \"\"\"\n        if isinstance(x, np.ndarray):\n            x = x.ravel()\n\n        try:\n            x = cbook.safe_first_element(x)\n        except (TypeError, StopIteration):\n            pass\n\n        try:\n            return x.tzinfo\n        except AttributeError:\n            pass\n        return None\n\n\nclass ConciseDateConverter(DateConverter):\n    \"\"\"\n    Converter for datetime.date and datetime.datetime data,\n    or for date/time data represented as it would be converted\n    by :func:`date2num`.\n\n    The 'unit' tag for such data is None or a tzinfo instance.\n    \"\"\"\n\n    def __init__(self, formats=None, zero_formats=None, offset_formats=None,\n                 show_offset=True):\n        self._formats = formats\n        self._zero_formats = zero_formats\n        self._offset_formats = offset_formats\n        self._show_offset = show_offset\n        super().__init__()\n\n    def axisinfo(self, unit, axis):\n        \"\"\"\n        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.\n\n        *unit* is a tzinfo instance or None.\n        The *axis* argument is required but not used.\n        \"\"\"\n        tz = unit\n\n        majloc = AutoDateLocator(tz=tz)\n        majfmt = ConciseDateFormatter(majloc, tz=tz, formats=self._formats,\n                                      zero_formats=self._zero_formats,\n                                      offset_formats=self._offset_formats,\n                                      show_offset=self._show_offset)\n        datemin = datetime.date(2000, 1, 1)\n        datemax = datetime.date(2010, 1, 1)\n\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='',\n                              default_limits=(datemin, datemax))\n\n\nunits.registry[np.datetime64] = DateConverter()\nunits.registry[datetime.date] = DateConverter()\nunits.registry[datetime.datetime] = DateConverter()\n"
    }
  ],
  "questions": [
    "@jklymak I need to add the tests in the `test_dates.py` right?\r\nA little guidance on the test content would be helpful.",
    "Since this thread seems kind of dead, I wrote 2 tests and have code for it (it's on a branch on my forked copy of `matplotlib`); however, when I run tests locally, a lot of them fail because `dateutil` throws a deprecation warning. Since this is not `matplotlib`, should I ignore it? Or should I do something?",
    "I guess that depends on why `dateutil` is throwing a deprecation warning?"
  ],
  "golden_answers": [
    "That’s right `test_dates.py`.  The content would be checking that the formatter makes the correct format if you change `format` and `zero_format`",
    "I guess that depends on why `dateutil` is throwing a deprecation warning?",
    "Full trace:\r\n[trace.txt](https://github.com/matplotlib/matplotlib/files/4056776/trace.txt)\r\nThe relevant line is,\r\nDeprecationWarning: fractions.gcd() is deprecated. Use math.gcd() instead."
  ],
  "questions_generated": [
    "What testing file should new tests for `ConciseDateFormatter` be added to, and what is the purpose of these tests?",
    "What issue was encountered when running tests locally, and what is a possible way to handle it?",
    "Why is it important to test the `format` and `zero_format` options in `ConciseDateFormatter`?",
    "What are the potential challenges a new contributor might face when writing tests for `ConciseDateFormatter`, and how can they be addressed?",
    "What is the significance of the Gregorian calendar in Matplotlib's date handling, and how does it relate to the issue discussed?"
  ],
  "golden_answers_generated": [
    "New tests for `ConciseDateFormatter` should be added to the `test_dates.py` file. The purpose of these tests is to check if the formatter correctly applies the `format` and `zero_format` options, including verifying their behavior with incorrect sizes.",
    "When running tests locally, a lot of them failed due to `dateutil` throwing a deprecation warning related to `fractions.gcd()`. The warning can be ignored as it is an issue with `dateutil`, or it can be reported to them if a minimal non-matplotlib example can be provided.",
    "Testing the `format` and `zero_format` options in `ConciseDateFormatter` is important to ensure that these options work correctly and handle edge cases such as incorrect sizes. This helps maintain the robustness and reliability of the date formatting functionality in Matplotlib.",
    "A new contributor might face challenges in understanding how to structure the tests and what specific scenarios to cover. To address this, guidance can be provided on checking that the formatter produces the correct format outputs when the `format` and `zero_format` options are modified, as well as handling any deprecation warnings from dependencies like `dateutil`.",
    "Matplotlib uses the Gregorian calendar for all conversions between dates and floating point numbers, which is significant because it ensures consistent date handling across the library. This is relevant to the issue discussed as it underpins the date formatting capabilities that `ConciseDateFormatter` relies on, making accurate and robust testing of this functionality crucial."
  ]
}