{
  "repo_name": "matplotlib_matplotlib",
  "issue_id": "13400",
  "issue_description": "# Qt Embedding w/ Spyder\n\nI have found a solution to a bug when using the script on:\r\nhttps://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html\r\nwith the Spyder IDE (v3.3.2)\r\n\r\nIf the script is run as presented, two issues are present:\r\nIssue 1: The qapp.exec_() does not terminate when the window is closed.\r\n\r\nThis was resolved for me by adding:\r\n`QtWidgets.QApplication.setQuitOnLastWindowClosed(True)`\r\nbefore qapp.exec_() is called:\r\n\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\nQtWidgets.QApplication.setQuitOnLastWindowClosed(True)\r\n\r\napp = ApplicationWindow()\r\napp.show()\r\nqapp.exec_()\r\n```\r\n\r\nIssue 2: When this script is called multiple times in the IPython console, the Kernel dies and must be restarted. Per the comment thread on issue #4349, this is solved by replacing:\r\n\r\n`qapp = QtWidgets.QApplication(sys.argv)`\r\n\r\nwith\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\n```\r\n\r\nCan this be added to the example script?\r\n\r\n**Matplotlib version**\r\n  * Operating system: Windows 10\r\n  * Matplotlib version: 3.0.2\r\n  * Python version: 3.7\r\n\r\n",
  "issue_comments": [
    {
      "id": 462173119,
      "user": "ImportanceOfBeingErnest",
      "body": "All examples are meant to be run as script. \r\nIn Spyder you can check\r\n\r\n![image](https://user-images.githubusercontent.com/23121882/52539599-7136ee80-2d80-11e9-9654-6e171a236319.png)\r\n\r\nto not have your GUI interfere with the build-in IPython console.\r\n\r\n"
    },
    {
      "id": 462176947,
      "user": "hmaarrfk",
      "body": "I've struggled with this alot. I found that the workaround you suggested sometimes worked, sometimes didn't. I would really like something that worked in both Spyder and in a script."
    },
    {
      "id": 462177196,
      "user": "gigo318",
      "body": "Which part of the workaround, Issue 2?"
    },
    {
      "id": 462177394,
      "user": "hmaarrfk",
      "body": "I'm not too sure. I just remember not to ask too much of opening applications from within spyder. I'm mostly expressing my support for applications supporting execcution from within spyder. Though I know it is challenging with so many different versions out there in the wild."
    },
    {
      "id": 462178273,
      "user": "gigo318",
      "body": "I see, yeah I just tried out @ImportanceOfBeingErnest 's suggestion and using an external console is a good tool to be able to fall back on if needed. Though I like and am used to running everything within Spyder. While I have only been messing around with it recently for the past day or so, and using the most recent versions of spyder and matplotlib, I haven't had any issues with Kernel crashes or qapp.exec_() hanging using the workarounds I suggested. I noticed that there were quite a few forum threads out there that talked about this issue, so that is why I thought it might be nice to add a few extra lines or commented lines that would point people in the right direction. Though as you point out, what the 'right direction is' is complicated given the number of versions people might be using."
    },
    {
      "id": 462178283,
      "user": "jklymak",
      "body": "I'm going to close this based on @ImportanceOfBeingErnest comment.  Our examples are *not* meant to be run inside spyder or any other IDE, particularly those that spawn an application - if you ned help getting Qt apps running in spyder, that's probably better discussed  as a spyder or Qt issue.   Thanks!"
    },
    {
      "id": 462221670,
      "user": "tacaswell",
      "body": "@gigo318 Could you open a PR with those changes?\r\n\r\nI think it is good practice to always do the \"is there a running Qt app?\" dance before creating a QApplication so we should demo that."
    },
    {
      "id": 462228411,
      "user": "anntzer",
      "body": "Agreed with the change, however I think the `QtWidgets.QApplication.setQuitOnLastWindowClosed(True)` line should only be added when one is creating a new QApp, not when one is already present (on the basis of \"if you're getting the QApp from someone else, assume that they have configured it the way they want\")."
    },
    {
      "id": 508093608,
      "user": "anntzer",
      "body": "Right now closing the window (in spyder) seems to return to the ipython console just fine, so I think this can be closed?"
    },
    {
      "id": 542941717,
      "user": "timhoffm",
      "body": "@anntzer It only works with \"Execute in an external console\".\r\n\"Execute in current console\" still freezes at the second attempt. Is this expected/accepted?\r\n\r\nSteps to reproduce:\r\n\r\n- Copy code from https://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html in a file in Spyder.\r\n- Run code, with \"Execute in current console\". -> ok\r\n  (window appears, after closing the window, the console gets back to the prompt.\r\n- Run code, with \"Execute in current console\" again.\r\n  Observation: As opposed to the previeous run, the plot window now appears behind spyder.\r\n  After closing the window, the console is still blocked.\r\n"
    },
    {
      "id": 543068906,
      "user": "anntzer",
      "body": "I see the second plot appearing behind spyder, but not the blockage at the end that you report.\r\nLooks like we can ensure the window to be raised to front even the second time by adding\r\n```\r\napp.activateWindow()\r\napp.raise_()\r\n```\r\nbefore the call to `qapp.exec_()` -- see also https://github.com/matplotlib/matplotlib/pull/6384/files; this at least works for me locally."
    },
    {
      "id": 543335631,
      "user": "timhoffm",
      "body": "After the second closing the commandline does not come back for me:\r\n\r\n---\r\n![image](https://user-images.githubusercontent.com/2836374/67042462-3adc1b00-f128-11e9-9262-8a768c15ff26.png)\r\n---\r\n\r\nmatplotlib 3.1.1\r\nspyder 3.3.6\r\nipython 7.8.0\r\n Qt 5.9.6\r\nPyQt5 5.9.2 "
    },
    {
      "id": 543337027,
      "user": "anntzer",
      "body": "what about matplotlib master? what desktop environment?"
    },
    {
      "id": 543343818,
      "user": "timhoffm",
      "body": "Indeed, works on master :smile:.\r\n\r\nSo after fixing the raise, this can be closed."
    },
    {
      "id": 545198796,
      "user": "timhoffm",
      "body": "@anntzer Sorry, didn't see the label."
    }
  ],
  "text_context": "# Qt Embedding w/ Spyder\n\nI have found a solution to a bug when using the script on:\r\nhttps://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html\r\nwith the Spyder IDE (v3.3.2)\r\n\r\nIf the script is run as presented, two issues are present:\r\nIssue 1: The qapp.exec_() does not terminate when the window is closed.\r\n\r\nThis was resolved for me by adding:\r\n`QtWidgets.QApplication.setQuitOnLastWindowClosed(True)`\r\nbefore qapp.exec_() is called:\r\n\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\nQtWidgets.QApplication.setQuitOnLastWindowClosed(True)\r\n\r\napp = ApplicationWindow()\r\napp.show()\r\nqapp.exec_()\r\n```\r\n\r\nIssue 2: When this script is called multiple times in the IPython console, the Kernel dies and must be restarted. Per the comment thread on issue #4349, this is solved by replacing:\r\n\r\n`qapp = QtWidgets.QApplication(sys.argv)`\r\n\r\nwith\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\n```\r\n\r\nCan this be added to the example script?\r\n\r\n**Matplotlib version**\r\n  * Operating system: Windows 10\r\n  * Matplotlib version: 3.0.2\r\n  * Python version: 3.7\r\n\r\n\n\nAll examples are meant to be run as script. \r\nIn Spyder you can check\r\n\r\n![image](https://user-images.githubusercontent.com/23121882/52539599-7136ee80-2d80-11e9-9654-6e171a236319.png)\r\n\r\nto not have your GUI interfere with the build-in IPython console.\r\n\r\n\n\nI've struggled with this alot. I found that the workaround you suggested sometimes worked, sometimes didn't. I would really like something that worked in both Spyder and in a script.\n\nWhich part of the workaround, Issue 2?\n\nI'm not too sure. I just remember not to ask too much of opening applications from within spyder. I'm mostly expressing my support for applications supporting execcution from within spyder. Though I know it is challenging with so many different versions out there in the wild.\n\nI see, yeah I just tried out @ImportanceOfBeingErnest 's suggestion and using an external console is a good tool to be able to fall back on if needed. Though I like and am used to running everything within Spyder. While I have only been messing around with it recently for the past day or so, and using the most recent versions of spyder and matplotlib, I haven't had any issues with Kernel crashes or qapp.exec_() hanging using the workarounds I suggested. I noticed that there were quite a few forum threads out there that talked about this issue, so that is why I thought it might be nice to add a few extra lines or commented lines that would point people in the right direction. Though as you point out, what the 'right direction is' is complicated given the number of versions people might be using.\n\nI'm going to close this based on @ImportanceOfBeingErnest comment.  Our examples are *not* meant to be run inside spyder or any other IDE, particularly those that spawn an application - if you ned help getting Qt apps running in spyder, that's probably better discussed  as a spyder or Qt issue.   Thanks!\n\n@gigo318 Could you open a PR with those changes?\r\n\r\nI think it is good practice to always do the \"is there a running Qt app?\" dance before creating a QApplication so we should demo that.\n\nAgreed with the change, however I think the `QtWidgets.QApplication.setQuitOnLastWindowClosed(True)` line should only be added when one is creating a new QApp, not when one is already present (on the basis of \"if you're getting the QApp from someone else, assume that they have configured it the way they want\").\n\nRight now closing the window (in spyder) seems to return to the ipython console just fine, so I think this can be closed?\n\n@anntzer It only works with \"Execute in an external console\".\r\n\"Execute in current console\" still freezes at the second attempt. Is this expected/accepted?\r\n\r\nSteps to reproduce:\r\n\r\n- Copy code from https://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html in a file in Spyder.\r\n- Run code, with \"Execute in current console\". -> ok\r\n  (window appears, after closing the window, the console gets back to the prompt.\r\n- Run code, with \"Execute in current console\" again.\r\n  Observation: As opposed to the previeous run, the plot window now appears behind spyder.\r\n  After closing the window, the console is still blocked.\r\n\n\nI see the second plot appearing behind spyder, but not the blockage at the end that you report.\r\nLooks like we can ensure the window to be raised to front even the second time by adding\r\n```\r\napp.activateWindow()\r\napp.raise_()\r\n```\r\nbefore the call to `qapp.exec_()` -- see also https://github.com/matplotlib/matplotlib/pull/6384/files; this at least works for me locally.\n\nAfter the second closing the commandline does not come back for me:\r\n\r\n---\r\n![image](https://user-images.githubusercontent.com/2836374/67042462-3adc1b00-f128-11e9-9262-8a768c15ff26.png)\r\n---\r\n\r\nmatplotlib 3.1.1\r\nspyder 3.3.6\r\nipython 7.8.0\r\n Qt 5.9.6\r\nPyQt5 5.9.2 \n\nwhat about matplotlib master? what desktop environment?\n\nIndeed, works on master :smile:.\r\n\r\nSo after fixing the raise, this can be closed.\n\n@anntzer Sorry, didn't see the label.",
  "pr_link": "https://github.com/matplotlib/matplotlib/pull/6384",
  "code_context": [
    {
      "filename": "lib/matplotlib/backends/backend_qt5.py",
      "content": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\nfrom matplotlib.externals import six\n\nimport os\nimport re\nimport signal\nimport sys\nfrom matplotlib.externals.six import unichr\n\nimport matplotlib\n\nfrom matplotlib.cbook import is_string_like\nfrom matplotlib.backend_bases import FigureManagerBase\nfrom matplotlib.backend_bases import FigureCanvasBase\nfrom matplotlib.backend_bases import NavigationToolbar2\n\nfrom matplotlib.backend_bases import cursors\nfrom matplotlib.backend_bases import TimerBase\nfrom matplotlib.backend_bases import ShowBase\n\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.figure import Figure\n\nfrom matplotlib.widgets import SubplotTool\ntry:\n    import matplotlib.backends.qt_editor.figureoptions as figureoptions\nexcept ImportError:\n    figureoptions = None\n\nfrom .qt_compat import QtCore, QtGui, QtWidgets, _getSaveFileName, __version__\nfrom matplotlib.backends.qt_editor.formsubplottool import UiSubplotTool\n\nbackend_version = __version__\n\n# SPECIAL_KEYS are keys that do *not* return their unicode name\n# instead they have manually specified names\nSPECIAL_KEYS = {QtCore.Qt.Key_Control: 'control',\n                QtCore.Qt.Key_Shift: 'shift',\n                QtCore.Qt.Key_Alt: 'alt',\n                QtCore.Qt.Key_Meta: 'super',\n                QtCore.Qt.Key_Return: 'enter',\n                QtCore.Qt.Key_Left: 'left',\n                QtCore.Qt.Key_Up: 'up',\n                QtCore.Qt.Key_Right: 'right',\n                QtCore.Qt.Key_Down: 'down',\n                QtCore.Qt.Key_Escape: 'escape',\n                QtCore.Qt.Key_F1: 'f1',\n                QtCore.Qt.Key_F2: 'f2',\n                QtCore.Qt.Key_F3: 'f3',\n                QtCore.Qt.Key_F4: 'f4',\n                QtCore.Qt.Key_F5: 'f5',\n                QtCore.Qt.Key_F6: 'f6',\n                QtCore.Qt.Key_F7: 'f7',\n                QtCore.Qt.Key_F8: 'f8',\n                QtCore.Qt.Key_F9: 'f9',\n                QtCore.Qt.Key_F10: 'f10',\n                QtCore.Qt.Key_F11: 'f11',\n                QtCore.Qt.Key_F12: 'f12',\n                QtCore.Qt.Key_Home: 'home',\n                QtCore.Qt.Key_End: 'end',\n                QtCore.Qt.Key_PageUp: 'pageup',\n                QtCore.Qt.Key_PageDown: 'pagedown',\n                QtCore.Qt.Key_Tab: 'tab',\n                QtCore.Qt.Key_Backspace: 'backspace',\n                QtCore.Qt.Key_Enter: 'enter',\n                QtCore.Qt.Key_Insert: 'insert',\n                QtCore.Qt.Key_Delete: 'delete',\n                QtCore.Qt.Key_Pause: 'pause',\n                QtCore.Qt.Key_SysReq: 'sysreq',\n                QtCore.Qt.Key_Clear: 'clear', }\n\n# define which modifier keys are collected on keyboard events.\n# elements are (mpl names, Modifier Flag, Qt Key) tuples\nSUPER = 0\nALT = 1\nCTRL = 2\nSHIFT = 3\nMODIFIER_KEYS = [('super', QtCore.Qt.MetaModifier, QtCore.Qt.Key_Meta),\n                 ('alt', QtCore.Qt.AltModifier, QtCore.Qt.Key_Alt),\n                 ('ctrl', QtCore.Qt.ControlModifier, QtCore.Qt.Key_Control),\n                 ('shift', QtCore.Qt.ShiftModifier, QtCore.Qt.Key_Shift),\n                 ]\n\nif sys.platform == 'darwin':\n    # in OSX, the control and super (aka cmd/apple) keys are switched, so\n    # switch them back.\n    SPECIAL_KEYS.update({QtCore.Qt.Key_Control: 'super',  # cmd/apple key\n                         QtCore.Qt.Key_Meta: 'control',\n                         })\n    MODIFIER_KEYS[0] = ('super', QtCore.Qt.ControlModifier,\n                        QtCore.Qt.Key_Control)\n    MODIFIER_KEYS[2] = ('ctrl', QtCore.Qt.MetaModifier,\n                        QtCore.Qt.Key_Meta)\n\n\ndef fn_name():\n    return sys._getframe(1).f_code.co_name\n\nDEBUG = False\n\ncursord = {\n    cursors.MOVE: QtCore.Qt.SizeAllCursor,\n    cursors.HAND: QtCore.Qt.PointingHandCursor,\n    cursors.POINTER: QtCore.Qt.ArrowCursor,\n    cursors.SELECT_REGION: QtCore.Qt.CrossCursor,\n    }\n\n\ndef draw_if_interactive():\n    \"\"\"\n    Is called after every pylab drawing command\n    \"\"\"\n    if matplotlib.is_interactive():\n        figManager = Gcf.get_active()\n        if figManager is not None:\n            figManager.canvas.draw_idle()\n\n# make place holder\nqApp = None\n\n\ndef _create_qApp():\n    \"\"\"\n    Only one qApp can exist at a time, so check before creating one.\n    \"\"\"\n    global qApp\n\n    if qApp is None:\n        if DEBUG:\n            print(\"Starting up QApplication\")\n        app = QtWidgets.QApplication.instance()\n        if app is None:\n            # check for DISPLAY env variable on X11 build of Qt\n            if hasattr(QtGui, \"QX11Info\"):\n                display = os.environ.get('DISPLAY')\n                if display is None or not re.search(':\\d', display):\n                    raise RuntimeError('Invalid DISPLAY variable')\n\n            qApp = QtWidgets.QApplication([str(\" \")])\n            qApp.lastWindowClosed.connect(qApp.quit)\n        else:\n            qApp = app\n\n\nclass Show(ShowBase):\n    def mainloop(self):\n        # allow KeyboardInterrupt exceptions to close the plot window.\n        signal.signal(signal.SIGINT, signal.SIG_DFL)\n        global qApp\n        qApp.exec_()\n\nshow = Show()\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    thisFig = Figure(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasQT(figure)\n    manager = FigureManagerQT(canvas, num)\n    return manager\n\n\nclass TimerQT(TimerBase):\n    '''\n    Subclass of :class:`backend_bases.TimerBase` that uses Qt4 timer events.\n\n    Attributes:\n    * interval: The time between timer events in milliseconds. Default\n        is 1000 ms.\n    * single_shot: Boolean flag indicating whether this timer should\n        operate as single shot (run once and then stop). Defaults to False.\n    * callbacks: Stores list of (func, args) tuples that will be called\n        upon timer events. This list can be manipulated directly, or the\n        functions add_callback and remove_callback can be used.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        TimerBase.__init__(self, *args, **kwargs)\n\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        self._timer_set_interval()\n\n    def __del__(self):\n        # Probably not necessary in practice, but is good behavior to\n        # disconnect\n        try:\n            TimerBase.__del__(self)\n            self._timer.timeout.disconnect(self._on_timer)\n        except RuntimeError:\n            # Timer C++ object already deleted\n            pass\n\n    def _timer_set_single_shot(self):\n        self._timer.setSingleShot(self._single)\n\n    def _timer_set_interval(self):\n        self._timer.setInterval(self._interval)\n\n    def _timer_start(self):\n        self._timer.start()\n\n    def _timer_stop(self):\n        self._timer.stop()\n\n\nclass FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):\n\n    # map Qt button codes to MouseEvent's ones:\n    buttond = {QtCore.Qt.LeftButton: 1,\n               QtCore.Qt.MidButton: 2,\n               QtCore.Qt.RightButton: 3,\n               # QtCore.Qt.XButton1: None,\n               # QtCore.Qt.XButton2: None,\n               }\n\n    def __init__(self, figure):\n        if DEBUG:\n            print('FigureCanvasQt qt5: ', figure)\n        _create_qApp()\n\n        # NB: Using super for this call to avoid a TypeError:\n        # __init__() takes exactly 2 arguments (1 given) on QWidget\n        # PyQt5\n        # The need for this change is documented here\n        # http://pyqt.sourceforge.net/Docs/PyQt5/pyqt4_differences.html#cooperative-multi-inheritance\n        super(FigureCanvasQT, self).__init__(figure=figure)\n        self.figure = figure\n        self.setMouseTracking(True)\n        w, h = self.get_width_height()\n        self.resize(w, h)\n\n    def enterEvent(self, event):\n        FigureCanvasBase.enter_notify_event(self, guiEvent=event)\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        FigureCanvasBase.leave_notify_event(self, guiEvent=event)\n\n    def mousePressEvent(self, event):\n        x = event.pos().x()\n        # flipy so y=0 is bottom of canvas\n        y = self.figure.bbox.height - event.pos().y()\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y, button,\n                                                guiEvent=event)\n        if DEBUG:\n            print('button pressed:', event.button())\n\n    def mouseDoubleClickEvent(self, event):\n        x = event.pos().x()\n        # flipy so y=0 is bottom of canvas\n        y = self.figure.bbox.height - event.pos().y()\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y,\n                                                button, dblclick=True,\n                                                guiEvent=event)\n        if DEBUG:\n            print('button doubleclicked:', event.button())\n\n    def mouseMoveEvent(self, event):\n        x = event.x()\n        # flipy so y=0 is bottom of canvas\n        y = self.figure.bbox.height - event.y()\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event)\n        # if DEBUG: print('mouse move')\n\n    def mouseReleaseEvent(self, event):\n        x = event.x()\n        # flipy so y=0 is bottom of canvas\n        y = self.figure.bbox.height - event.y()\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_release_event(self, x, y, button,\n                                                  guiEvent=event)\n        if DEBUG:\n            print('button released')\n\n    def wheelEvent(self, event):\n        x = event.x()\n        # flipy so y=0 is bottom of canvas\n        y = self.figure.bbox.height - event.y()\n        # from QWheelEvent::delta doc\n        if event.pixelDelta().x() == 0 and event.pixelDelta().y() == 0:\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n\n        if steps != 0:\n            FigureCanvasBase.scroll_event(self, x, y, steps, guiEvent=event)\n            if DEBUG:\n                print('scroll event: delta = %i, '\n                      'steps = %i ' % (event.delta(), steps))\n\n    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is None:\n            return\n        FigureCanvasBase.key_press_event(self, key, guiEvent=event)\n        if DEBUG:\n            print('key press', key)\n\n    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is None:\n            return\n        FigureCanvasBase.key_release_event(self, key, guiEvent=event)\n        if DEBUG:\n            print('key release', key)\n\n    def resizeEvent(self, event):\n        w = event.size().width()\n        h = event.size().height()\n        if DEBUG:\n            print('resize (%d x %d)' % (w, h))\n            print(\"FigureCanvasQt.resizeEvent(%d, %d)\" % (w, h))\n        dpival = self.figure.dpi\n        winch = w / dpival\n        hinch = h / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        FigureCanvasBase.resize_event(self)\n        self.draw_idle()\n        QtWidgets.QWidget.resizeEvent(self, event)\n\n    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)\n\n    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)\n\n    def _get_key(self, event):\n        if event.isAutoRepeat():\n            return None\n\n        event_key = event.key()\n        event_mods = int(event.modifiers())  # actually a bitmask\n\n        # get names of the pressed modifier keys\n        # bit twiddling to pick out modifier keys from event_mods bitmask,\n        # if event_key is a MODIFIER, it should not be duplicated in mods\n        mods = [name for name, mod_key, qt_key in MODIFIER_KEYS\n                if event_key != qt_key and (event_mods & mod_key) == mod_key]\n        try:\n            # for certain keys (enter, left, backspace, etc) use a word for the\n            # key, rather than unicode\n            key = SPECIAL_KEYS[event_key]\n        except KeyError:\n            # unicode defines code points up to 0x0010ffff\n            # QT will use Key_Codes larger than that for keyboard keys that are\n            # are not unicode characters (like multimedia keys)\n            # skip these\n            # if you really want them, you should add them to SPECIAL_KEYS\n            MAX_UNICODE = 0x10ffff\n            if event_key > MAX_UNICODE:\n                return None\n\n            key = unichr(event_key)\n            # qt delivers capitalized letters.  fix capitalization\n            # note that capslock is ignored\n            if 'shift' in mods:\n                mods.remove('shift')\n            else:\n                key = key.lower()\n\n        mods.reverse()\n        return '+'.join(mods + [key])\n\n    def new_timer(self, *args, **kwargs):\n        \"\"\"\n        Creates a new backend-specific subclass of\n        :class:`backend_bases.Timer`.  This is useful for getting\n        periodic events through the backend's native event\n        loop. Implemented only for backends with GUIs.\n\n        optional arguments:\n\n        *interval*\n            Timer interval in milliseconds\n\n        *callbacks*\n            Sequence of (func, args, kwargs) where func(*args, **kwargs)\n            will be executed by the timer every *interval*.\n\n    \"\"\"\n        return TimerQT(*args, **kwargs)\n\n    def flush_events(self):\n        global qApp\n        qApp.processEvents()\n\n    def start_event_loop(self, timeout):\n        FigureCanvasBase.start_event_loop_default(self, timeout)\n\n    start_event_loop.__doc__ = \\\n                             FigureCanvasBase.start_event_loop_default.__doc__\n\n    def stop_event_loop(self):\n        FigureCanvasBase.stop_event_loop_default(self)\n\n    stop_event_loop.__doc__ = FigureCanvasBase.stop_event_loop_default.__doc__\n\n\nclass MainWindow(QtWidgets.QMainWindow):\n    closing = QtCore.Signal()\n\n    def closeEvent(self, event):\n        self.closing.emit()\n        QtWidgets.QMainWindow.closeEvent(self, event)\n\n\nclass FigureManagerQT(FigureManagerBase):\n    \"\"\"\n    Public attributes\n\n    canvas      : The FigureCanvas instance\n    num         : The Figure number\n    toolbar     : The qt.QToolBar\n    window      : The qt.QMainWindow\n    \"\"\"\n\n    def __init__(self, canvas, num):\n        if DEBUG:\n            print('FigureManagerQT.%s' % fn_name())\n        FigureManagerBase.__init__(self, canvas, num)\n        self.canvas = canvas\n        self.window = MainWindow()\n        self.window.closing.connect(canvas.close_event)\n        self.window.closing.connect(self._widgetclosed)\n\n        self.window.setWindowTitle(\"Figure %d\" % num)\n        image = os.path.join(matplotlib.rcParams['datapath'],\n                             'images', 'matplotlib.png')\n        self.window.setWindowIcon(QtGui.QIcon(image))\n\n        # Give the keyboard focus to the figure instead of the\n        # manager; StrongFocus accepts both tab and click to focus and\n        # will enable the canvas to process event w/o clicking.\n        # ClickFocus only takes the focus is the window has been\n        # clicked\n        # on. http://qt-project.org/doc/qt-4.8/qt.html#FocusPolicy-enum or\n        # http://doc.qt.digia.com/qt/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.canvas.setFocus()\n\n        self.window._destroying = False\n\n        self.toolbar = self._get_toolbar(self.canvas, self.window)\n        if self.toolbar is not None:\n            self.window.addToolBar(self.toolbar)\n            self.toolbar.message.connect(self._show_message)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # add text label to status bar\n        self.statusbar_label = QtWidgets.QLabel()\n        self.window.statusBar().addWidget(self.statusbar_label)\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        sbs = self.window.statusBar().sizeHint()\n        self._status_and_tool_height = tbs_height + sbs.height()\n        height = cs.height() + self._status_and_tool_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if matplotlib.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        def notify_axes_change(fig):\n            # This will be called whenever the current axes is changed\n            if self.toolbar is not None:\n                self.toolbar.update()\n        self.canvas.figure.add_axobserver(notify_axes_change)\n        self.window.raise_()\n\n    @QtCore.Slot()\n    def _show_message(self, s):\n        self.statusbar_label.setText(s)\n\n    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()\n\n    def _widgetclosed(self):\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        try:\n            Gcf.destroy(self.num)\n        except AttributeError:\n            pass\n            # It seems that when the python session is killed,\n            # Gcf can get destroyed before the Gcf.destroy\n            # line is run, leading to a useless AttributeError.\n\n    def _get_toolbar(self, canvas, parent):\n        # must be inited after the window, drawingArea and figure\n        # attrs are set\n        if matplotlib.rcParams['toolbar'] == 'toolbar2':\n            toolbar = NavigationToolbar2QT(canvas, parent, False)\n        else:\n            toolbar = None\n        return toolbar\n\n    def resize(self, width, height):\n        'set the canvas size in pixels'\n        self.window.resize(width, height + self._status_and_tool_height)\n\n    def show(self):\n        self.window.show()\n        self.window.activateWindow()\n        self.window.raise_()\n\n    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        self.window.destroyed.connect(self._widgetclosed)\n\n        if self.toolbar:\n            self.toolbar.destroy()\n        if DEBUG:\n            print(\"destroy figure manager\")\n        self.window.close()\n\n    def get_window_title(self):\n        return six.text_type(self.window.windowTitle())\n\n    def set_window_title(self, title):\n        self.window.setWindowTitle(title)\n\n\nclass NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):\n    message = QtCore.Signal(str)\n\n    def __init__(self, canvas, parent, coordinates=True):\n        \"\"\" coordinates: should we show the coordinates on the right? \"\"\"\n        self.canvas = canvas\n        self.parent = parent\n        self.coordinates = coordinates\n        self._actions = {}\n        \"\"\"A mapping of toolitem method names to their QActions\"\"\"\n\n        QtWidgets.QToolBar.__init__(self, parent)\n        NavigationToolbar2.__init__(self, canvas)\n\n    def _icon(self, name):\n        return QtGui.QIcon(os.path.join(self.basedir, name))\n\n    def _init_toolbar(self):\n        self.basedir = os.path.join(matplotlib.rcParams['datapath'], 'images')\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                         text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        if figureoptions is not None:\n            a = self.addAction(self._icon(\"qt4_editor_options.png\"),\n                               'Customize', self.edit_parameters)\n            a.setToolTip('Edit axis, curve and image parameters')\n\n        self.buttons = {}\n\n        # Add the x,y location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(\n                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTop)\n            self.locLabel.setSizePolicy(\n                QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                  QtWidgets.QSizePolicy.Ignored))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        # reference holder for subplots_adjust window\n        self.adj_window = None\n\n    if figureoptions is not None:\n        def edit_parameters(self):\n            allaxes = self.canvas.figure.get_axes()\n            if not allaxes:\n                QtWidgets.QMessageBox.warning(\n                    self.parent, \"Error\", \"There are no axes to edit.\")\n                return\n            if len(allaxes) == 1:\n                axes = allaxes[0]\n            else:\n                titles = []\n                for axes in allaxes:\n                    name = (axes.get_title() or\n                            \" - \".join(filter(None, [axes.get_xlabel(),\n                                                     axes.get_ylabel()])) or\n                            \"<anonymous {} (id: {:#x})>\".format(\n                                type(axes).__name__, id(axes)))\n                    titles.append(name)\n                item, ok = QtWidgets.QInputDialog.getItem(\n                    self.parent, 'Customize', 'Select axes:', titles, 0, False)\n                if ok:\n                    axes = allaxes[titles.index(six.text_type(item))]\n                else:\n                    return\n\n            figureoptions.figure_edit(axes, self)\n\n    def _update_buttons_checked(self):\n        # sync button checkstates to match active mode\n        self._actions['pan'].setChecked(self._active == 'PAN')\n        self._actions['zoom'].setChecked(self._active == 'ZOOM')\n\n    def pan(self, *args):\n        super(NavigationToolbar2QT, self).pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super(NavigationToolbar2QT, self).zoom(*args)\n        self._update_buttons_checked()\n\n    def dynamic_update(self):\n        self.canvas.draw_idle()\n\n    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)\n\n    def set_cursor(self, cursor):\n        if DEBUG:\n            print('Set cursor', cursor)\n        self.canvas.setCursor(cursord[cursor])\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n\n        w = abs(x1 - x0)\n        h = abs(y1 - y0)\n\n        rect = [int(val)for val in (min(x0, x1), min(y0, y1), w, h)]\n        self.canvas.drawRectangle(rect)\n\n    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)\n\n    def configure_subplots(self):\n        image = os.path.join(matplotlib.rcParams['datapath'],\n                             'images', 'matplotlib.png')\n        dia = SubplotToolQt(self.canvas.figure, self.parent)\n        dia.setWindowIcon(QtGui.QIcon(image))\n        dia.exec_()\n\n    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = list(six.iteritems(filetypes))\n        sorted_filetypes.sort()\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = matplotlib.rcParams.get('savefig.directory', '')\n        startpath = os.path.expanduser(startpath)\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = _getSaveFileName(self.parent,\n                                         \"Choose a filename to save to\",\n                                 start, filters, selectedFilter)\n        if fname:\n            if startpath == '':\n                # explicitly missing key or empty str signals to use cwd\n                matplotlib.rcParams['savefig.directory'] = startpath\n            else:\n                # save dir for next time\n                savefig_dir = os.path.dirname(six.text_type(fname))\n                matplotlib.rcParams['savefig.directory'] = savefig_dir\n            try:\n                self.canvas.print_figure(six.text_type(fname))\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", six.text_type(e),\n                    QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.NoButton)\n\n\nclass SubplotToolQt(SubplotTool, UiSubplotTool):\n    def __init__(self, targetfig, parent):\n        UiSubplotTool.__init__(self, None)\n\n        self.targetfig = targetfig\n        self.parent = parent\n        self.donebutton.clicked.connect(self.close)\n        self.resetbutton.clicked.connect(self.reset)\n        self.tightlayout.clicked.connect(self.functight)\n\n        # constraints\n        self.sliderleft.valueChanged.connect(self.sliderright.setMinimum)\n        self.sliderright.valueChanged.connect(self.sliderleft.setMaximum)\n        self.sliderbottom.valueChanged.connect(self.slidertop.setMinimum)\n        self.slidertop.valueChanged.connect(self.sliderbottom.setMaximum)\n\n        self.defaults = {}\n        for attr in ('left', 'bottom', 'right', 'top', 'wspace', 'hspace', ):\n            self.defaults[attr] = getattr(self.targetfig.subplotpars, attr)\n            slider = getattr(self, 'slider' + attr)\n            slider.setMinimum(0)\n            slider.setMaximum(1000)\n            slider.setSingleStep(5)\n            slider.valueChanged.connect(getattr(self, 'func' + attr))\n\n        self._setSliderPositions()\n\n    def _setSliderPositions(self):\n        for attr in ('left', 'bottom', 'right', 'top', 'wspace', 'hspace', ):\n            slider = getattr(self, 'slider' + attr)\n            slider.setSliderPosition(int(self.defaults[attr] * 1000))\n\n    def funcleft(self, val):\n        if val == self.sliderright.value():\n            val -= 1\n        val /= 1000.\n        self.targetfig.subplots_adjust(left=val)\n        self.leftvalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def funcright(self, val):\n        if val == self.sliderleft.value():\n            val += 1\n        val /= 1000.\n        self.targetfig.subplots_adjust(right=val)\n        self.rightvalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def funcbottom(self, val):\n        if val == self.slidertop.value():\n            val -= 1\n        val /= 1000.\n        self.targetfig.subplots_adjust(bottom=val)\n        self.bottomvalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def functop(self, val):\n        if val == self.sliderbottom.value():\n            val += 1\n        val /= 1000.\n        self.targetfig.subplots_adjust(top=val)\n        self.topvalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def funcwspace(self, val):\n        val /= 1000.\n        self.targetfig.subplots_adjust(wspace=val)\n        self.wspacevalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def funchspace(self, val):\n        val /= 1000.\n        self.targetfig.subplots_adjust(hspace=val)\n        self.hspacevalue.setText(\"%.2f\" % val)\n        if self.drawon:\n            self.targetfig.canvas.draw()\n\n    def functight(self):\n        self.targetfig.tight_layout()\n        self._setSliderPositions()\n        self.targetfig.canvas.draw()\n\n    def reset(self):\n        self.targetfig.subplots_adjust(**self.defaults)\n        self._setSliderPositions()\n        self.targetfig.canvas.draw()\n\n\ndef error_msg_qt(msg, parent=None):\n    if not is_string_like(msg):\n        msg = ','.join(map(str, msg))\n\n    QtWidgets.QMessageBox.warning(None, \"Matplotlib\",\n                                  msg, QtGui.QMessageBox.Ok)\n\n\ndef exception_handler(type, value, tb):\n    \"\"\"Handle uncaught exceptions\n    It does not catch SystemExit\n    \"\"\"\n    msg = ''\n    # get the filename attribute if available (for IOError)\n    if hasattr(value, 'filename') and value.filename is not None:\n        msg = value.filename + ': '\n    if hasattr(value, 'strerror') and value.strerror is not None:\n        msg += value.strerror\n    else:\n        msg += six.text_type(value)\n\n    if len(msg):\n        error_msg_qt(msg)\n\nFigureCanvas = FigureCanvasQT\nFigureManager = FigureManagerQT\n"
    }
  ],
  "questions": [
    "@gigo318 Could you open a PR with those changes?\r\n\r\nI think it is good practice to always do the \"is there a running Qt app?\" dance before creating a QApplication so we should demo that.",
    "@anntzer It only works with \"Execute in an external console\".\r\n\"Execute in current console\" still freezes at the second attempt. Is this expected/accepted?\r\n\r\nSteps to reproduce:\r\n\r\n- Copy code from https://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html in a file in Spyder.\r\n- Run code, with \"Execute in current console\". -> ok\r\n  (window appears, after closing the window, the console gets back to the prompt.\r\n- Run code, with \"Execute in current console\" again.\r\n  Observation: As opposed to the previeous run, the plot window now appears behind spyder.\r\n  After closing the window, the console is still blocked.",
    "I have found a solution to a bug when using the script on:\r\nhttps://matplotlib.org/gallery/user_interfaces/embedding_in_qt_sgskip.html\r\nwith the Spyder IDE (v3.3.2)\r\n\r\nIf the script is run as presented, two issues are present:\r\nIssue 1: The qapp.exec_() does not terminate when the window is closed.\r\n\r\nThis was resolved for me by adding:\r\n`QtWidgets.QApplication.setQuitOnLastWindowClosed(True)`\r\nbefore qapp.exec_() is called:\r\n\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\nQtWidgets.QApplication.setQuitOnLastWindowClosed(True)\r\n\r\napp = ApplicationWindow()\r\napp.show()\r\nqapp.exec_()\r\n```\r\n\r\nIssue 2: When this script is called multiple times in the IPython console, the Kernel dies and must be restarted. Per the comment thread on issue #4349, this is solved by replacing:\r\n\r\n`qapp = QtWidgets.QApplication(sys.argv)`\r\n\r\nwith\r\n```\r\nif not QtWidgets.QApplication.instance():\r\n    qapp = QtWidgets.QApplication(sys.argv)\r\nelse:\r\n    qapp = QtWidgets.QApplication.instance()\r\n```\r\n\r\nCan this be added to the example script?\r\n\r\n**Matplotlib version**\r\n  * Operating system: Windows 10\r\n  * Matplotlib version: 3.0.2\r\n  * Python version: 3.7"
  ],
  "golden_answers": [
    "Agreed with the change, however I think the `QtWidgets.QApplication.setQuitOnLastWindowClosed(True)` line should only be added when one is creating a new QApp, not when one is already present (on the basis of \"if you're getting the QApp from someone else, assume that they have configured it the way they want\").",
    "I see the second plot appearing behind spyder, but not the blockage at the end that you report.\r\nLooks like we can ensure the window to be raised to front even the second time by adding\r\n```\r\napp.activateWindow()\r\napp.raise_()\r\n```\r\nbefore the call to `qapp.exec_()` -- see also https://github.com/matplotlib/matplotlib/pull/6384/files; this at least works for me locally.",
    "All examples are meant to be run as script. \r\nIn Spyder you can check\r\n\r\n![image](https://user-images.githubusercontent.com/23121882/52539599-7136ee80-2d80-11e9-9654-6e171a236319.png)\r\n\r\nto not have your GUI interfere with the build-in IPython console."
  ],
  "questions_generated": [
    "What is the purpose of the 'QtWidgets.QApplication.setQuitOnLastWindowClosed(True)' line in the script?",
    "Why is it important to check if a QApplication instance already exists before creating a new one?",
    "How does the updated script ensure compatibility with both running as a standalone application and within an IDE like Spyder?",
    "What problem might arise if 'QtWidgets.QApplication.setQuitOnLastWindowClosed(True)' is not included in the script?",
    "How does the solution to Issue 2 relate to the previous discussions in issue #4349?",
    "What are the potential downsides of running GUI applications inside an IDE like Spyder according to the discussion?"
  ],
  "golden_answers_generated": [
    "The line 'QtWidgets.QApplication.setQuitOnLastWindowClosed(True)' ensures that the application terminates when the last window is closed. This addresses Issue 1 where the qapp.exec_() does not terminate when the window is closed.",
    "Checking if a QApplication instance already exists helps prevent creating multiple instances of QApplication, which can cause issues like kernel crashes when the script is run multiple times in the IPython console. This is a solution to Issue 2 mentioned in the description.",
    "The updated script includes a conditional check to use an existing QApplication instance if it exists, and it sets 'setQuitOnLastWindowClosed' to True. These changes ensure the script behaves correctly when windows are closed and prevent issues when run multiple times, making it more robust in different environments, including IDEs like Spyder.",
    "If 'QtWidgets.QApplication.setQuitOnLastWindowClosed(True)' is not included, the application may not exit when the main window is closed, leading to the qapp.exec_() call hanging and requiring manual termination of the application.",
    "The solution to Issue 2, which involves using an existing QApplication instance if it already exists, is related to issue #4349 discussions that also addressed the problem of kernel crashes in the IPython console when running scripts multiple times. The solution helps stabilize the application behavior in environments that initiate multiple script executions.",
    "Running GUI applications inside an IDE like Spyder can lead to issues such as kernel crashes and qapp.exec_() hanging. These issues arise due to the way Spyder handles GUI event loops, which might interfere with the normal execution of standalone GUI scripts, as noted in the discussion."
  ]
}