{
  "repo_name": "scrapy_scrapy",
  "issue_id": "3055",
  "issue_description": "# [bug] pillow will always recode images in imagepipieline\n\nhttps://github.com/scrapy/scrapy/blob/aa83e159c97b441167d0510064204681bbc93f21/scrapy/pipelines/images.py#L151\r\n\r\nthis line will always recode images silently and damage the image quality.\r\n\r\nplease add an option to avoid this.",
  "issue_comments": [
    {
      "id": 354885769,
      "user": "raphapassini",
      "body": "Well, seems reasonable to me, but you can simply extend the default image pipeline and override the method to do what you want."
    },
    {
      "id": 354976705,
      "user": "NewUserHa",
      "body": "I don't know image pipeline of scrapy will always damage the quality of image, even after have read scrapy's documents."
    },
    {
      "id": 356912721,
      "user": "ghost",
      "body": "Hi @NewUserHa - I'm sorry this has been a problem for you! The documents do say, at the higher-level overview, that [the images pipeline will convert all images to a common format](https://github.com/scrapy/scrapy/blob/1.5/docs/topics/media-pipeline.rst#L23), namely JPG with RGBA colourspace.\r\n\r\nI think similarly to you, that unless the user explicitly requests recoding, the images would be better left alone. But, that's one of the big differences between simply using the Files pipeline and the Images pipeline, I guess. I'd suggest using the Files pipeline for now, if you want the unaltered images to be exactly as they occur online."
    },
    {
      "id": 361748553,
      "user": "NewUserHa",
      "body": "I meant images pipeline will still convert a jpg file to a less quality jpg file. is that a problem?"
    },
    {
      "id": 366254535,
      "user": "ghost",
      "body": "I'd need to read the code again to see whether quality is 'expected' to change under normal conditions.. but I do think there's a problem with the docs if this behaviour is surprising."
    },
    {
      "id": 366388643,
      "user": "NewUserHa",
      "body": "it's a problem. jpg encoding is lossy. pillow shouldn't reencode jpg to jpg at least.\r\nbut I noticed not all jpgs will not be re-encoded by pillow. maybe there's difference within the jpgs(I checked both they are jpgs, not only the extensions.)"
    },
    {
      "id": 470923499,
      "user": "Gallaecio",
      "body": "I believe the documentation is OK.\r\n\r\n> The Images Pipeline uses `Pillow`_ for thumbnailing and normalizing images to JPEG/RGB format.\r\n\r\nIt says `JPEG/RGB`. The `RGB` part must be the culprit of the quality change @NewUserHa is experiencing.\r\n\r\nI’ve checked the code and `JPEG/RGB` images are not converted.\r\n\r\n@NewUserHa If you believe they are, please share an example image that gets converted and should not. Otherwise, I believe we should close this issue."
    },
    {
      "id": 471598098,
      "user": "NewUserHa",
      "body": "Did you try yourself?\r\n`Image.open('a.jpg').save('b.jpg', 'JPEG')`\r\nI just pick a jpg randomly and run it with the above code, and it was re-encoded just like my last try.\r\n\r\nDID you really double check it ?\r\npicture info:\r\n```\r\nJPEG, quality: 77, subsampling ON (2x2)\r\n16,7 Million   (24 BitsPerPixel)\r\n```"
    },
    {
      "id": 471673033,
      "user": "Gallaecio",
      "body": "If that is so, please provide the smallest image possible that allows to reproduce the issue. It can be used to test a fix."
    },
    {
      "id": 471810669,
      "user": "NewUserHa",
      "body": "![Q20161115204613](https://user-images.githubusercontent.com/32261870/54168432-6bc8e300-44a9-11e9-92d6-222201c18165.jpg)\r\n"
    },
    {
      "id": 471885188,
      "user": "Gallaecio",
      "body": "Although I could not visually appreciate any difference, `Image.open('original.jpg').save('modified.jpg', 'JPEG')` does indeed slightly reduce the image size. `Image.open('original.jpg').save('modified.jpg', 'JPEG', quality='keep')` does not maintain the size, it increases it instead.\r\n\r\nI think we could consider modifying `convert_image` to accept `BytesIO(response.body)` as a second parameter, and return it as `buf` when no conversion is necessary. @cathalgarvey I think this could be a good first issue."
    },
    {
      "id": 678789080,
      "user": "drs-11",
      "body": "Looks like the author of the linked PR hasn't responded to the last few suggestions.\r\nCan I take his PR and finish this issue?"
    },
    {
      "id": 678800672,
      "user": "elacuesta",
      "body": "@drs-11 By all means, be our guest. The scenario is covered in our [contributing guidelines](https://docs.scrapy.org/en/latest/contributing.html#submitting-patches):\r\n\r\n> Sometimes there is an existing pull request for the problem you’d like to solve, which is stalled for some reason. Often the pull request is in a right direction, but changes are requested by Scrapy maintainers, and the original pull request author hasn’t had time to address them. In this case consider picking up this pull request: open a new pull request with all commits from the original pull request, as well as additional changes to address the raised issues. Doing so helps a lot; it is not considered rude as soon as the original author is acknowledged by keeping his/her commits."
    }
  ],
  "text_context": "# [bug] pillow will always recode images in imagepipieline\n\nhttps://github.com/scrapy/scrapy/blob/aa83e159c97b441167d0510064204681bbc93f21/scrapy/pipelines/images.py#L151\r\n\r\nthis line will always recode images silently and damage the image quality.\r\n\r\nplease add an option to avoid this.\n\nWell, seems reasonable to me, but you can simply extend the default image pipeline and override the method to do what you want.\n\nI don't know image pipeline of scrapy will always damage the quality of image, even after have read scrapy's documents.\n\nHi @NewUserHa - I'm sorry this has been a problem for you! The documents do say, at the higher-level overview, that [the images pipeline will convert all images to a common format](https://github.com/scrapy/scrapy/blob/1.5/docs/topics/media-pipeline.rst#L23), namely JPG with RGBA colourspace.\r\n\r\nI think similarly to you, that unless the user explicitly requests recoding, the images would be better left alone. But, that's one of the big differences between simply using the Files pipeline and the Images pipeline, I guess. I'd suggest using the Files pipeline for now, if you want the unaltered images to be exactly as they occur online.\n\nI meant images pipeline will still convert a jpg file to a less quality jpg file. is that a problem?\n\nI'd need to read the code again to see whether quality is 'expected' to change under normal conditions.. but I do think there's a problem with the docs if this behaviour is surprising.\n\nit's a problem. jpg encoding is lossy. pillow shouldn't reencode jpg to jpg at least.\r\nbut I noticed not all jpgs will not be re-encoded by pillow. maybe there's difference within the jpgs(I checked both they are jpgs, not only the extensions.)\n\nI believe the documentation is OK.\r\n\r\n> The Images Pipeline uses `Pillow`_ for thumbnailing and normalizing images to JPEG/RGB format.\r\n\r\nIt says `JPEG/RGB`. The `RGB` part must be the culprit of the quality change @NewUserHa is experiencing.\r\n\r\nI’ve checked the code and `JPEG/RGB` images are not converted.\r\n\r\n@NewUserHa If you believe they are, please share an example image that gets converted and should not. Otherwise, I believe we should close this issue.\n\nDid you try yourself?\r\n`Image.open('a.jpg').save('b.jpg', 'JPEG')`\r\nI just pick a jpg randomly and run it with the above code, and it was re-encoded just like my last try.\r\n\r\nDID you really double check it ?\r\npicture info:\r\n```\r\nJPEG, quality: 77, subsampling ON (2x2)\r\n16,7 Million   (24 BitsPerPixel)\r\n```\n\nIf that is so, please provide the smallest image possible that allows to reproduce the issue. It can be used to test a fix.\n\n![Q20161115204613](https://user-images.githubusercontent.com/32261870/54168432-6bc8e300-44a9-11e9-92d6-222201c18165.jpg)\r\n\n\nAlthough I could not visually appreciate any difference, `Image.open('original.jpg').save('modified.jpg', 'JPEG')` does indeed slightly reduce the image size. `Image.open('original.jpg').save('modified.jpg', 'JPEG', quality='keep')` does not maintain the size, it increases it instead.\r\n\r\nI think we could consider modifying `convert_image` to accept `BytesIO(response.body)` as a second parameter, and return it as `buf` when no conversion is necessary. @cathalgarvey I think this could be a good first issue.\n\nLooks like the author of the linked PR hasn't responded to the last few suggestions.\r\nCan I take his PR and finish this issue?\n\n@drs-11 By all means, be our guest. The scenario is covered in our [contributing guidelines](https://docs.scrapy.org/en/latest/contributing.html#submitting-patches):\r\n\r\n> Sometimes there is an existing pull request for the problem you’d like to solve, which is stalled for some reason. Often the pull request is in a right direction, but changes are requested by Scrapy maintainers, and the original pull request author hasn’t had time to address them. In this case consider picking up this pull request: open a new pull request with all commits from the original pull request, as well as additional changes to address the raised issues. Doing so helps a lot; it is not considered rude as soon as the original author is acknowledged by keeping his/her commits.",
  "pr_link": "https://github.com/scrapy/scrapy/pull/4753",
  "code_context": [
    {
      "filename": "scrapy/pipelines/images.py",
      "content": "\"\"\"\nImages Pipeline\n\nSee documentation in topics/media-pipeline.rst\n\"\"\"\nimport functools\nimport hashlib\nimport warnings\nfrom contextlib import suppress\nfrom io import BytesIO\n\nfrom itemadapter import ItemAdapter\n\nfrom scrapy.exceptions import DropItem, NotConfigured, ScrapyDeprecationWarning\nfrom scrapy.http import Request\nfrom scrapy.pipelines.files import FileException, FilesPipeline\n# TODO: from scrapy.pipelines.media import MediaPipeline\nfrom scrapy.settings import Settings\nfrom scrapy.utils.misc import md5sum\nfrom scrapy.utils.python import get_func_args, to_bytes\n\n\nclass NoimagesDrop(DropItem):\n    \"\"\"Product with no images exception\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"The NoimagesDrop class is deprecated\", category=ScrapyDeprecationWarning, stacklevel=2)\n        super().__init__(*args, **kwargs)\n\n\nclass ImageException(FileException):\n    \"\"\"General image error exception\"\"\"\n\n\nclass ImagesPipeline(FilesPipeline):\n    \"\"\"Abstract pipeline that implement the image thumbnail generation logic\n\n    \"\"\"\n\n    MEDIA_NAME = 'image'\n\n    # Uppercase attributes kept for backward compatibility with code that subclasses\n    # ImagesPipeline. They may be overridden by settings.\n    MIN_WIDTH = 0\n    MIN_HEIGHT = 0\n    EXPIRES = 90\n    THUMBS = {}\n    DEFAULT_IMAGES_URLS_FIELD = 'image_urls'\n    DEFAULT_IMAGES_RESULT_FIELD = 'images'\n\n    def __init__(self, store_uri, download_func=None, settings=None):\n        try:\n            from PIL import Image\n            self._Image = Image\n        except ImportError:\n            raise NotConfigured(\n                'ImagesPipeline requires installing Pillow 4.0.0 or later'\n            )\n\n        super().__init__(store_uri, settings=settings, download_func=download_func)\n\n        if isinstance(settings, dict) or settings is None:\n            settings = Settings(settings)\n\n        resolve = functools.partial(self._key_for_pipe,\n                                    base_class_name=\"ImagesPipeline\",\n                                    settings=settings)\n        self.expires = settings.getint(\n            resolve(\"IMAGES_EXPIRES\"), self.EXPIRES\n        )\n\n        if not hasattr(self, \"IMAGES_RESULT_FIELD\"):\n            self.IMAGES_RESULT_FIELD = self.DEFAULT_IMAGES_RESULT_FIELD\n        if not hasattr(self, \"IMAGES_URLS_FIELD\"):\n            self.IMAGES_URLS_FIELD = self.DEFAULT_IMAGES_URLS_FIELD\n\n        self.images_urls_field = settings.get(\n            resolve('IMAGES_URLS_FIELD'),\n            self.IMAGES_URLS_FIELD\n        )\n        self.images_result_field = settings.get(\n            resolve('IMAGES_RESULT_FIELD'),\n            self.IMAGES_RESULT_FIELD\n        )\n        self.min_width = settings.getint(\n            resolve('IMAGES_MIN_WIDTH'), self.MIN_WIDTH\n        )\n        self.min_height = settings.getint(\n            resolve('IMAGES_MIN_HEIGHT'), self.MIN_HEIGHT\n        )\n        self.thumbs = settings.get(\n            resolve('IMAGES_THUMBS'), self.THUMBS\n        )\n\n        self._deprecated_convert_image = None\n\n    @classmethod\n    def from_settings(cls, settings):\n        s3store = cls.STORE_SCHEMES['s3']\n        s3store.AWS_ACCESS_KEY_ID = settings['AWS_ACCESS_KEY_ID']\n        s3store.AWS_SECRET_ACCESS_KEY = settings['AWS_SECRET_ACCESS_KEY']\n        s3store.AWS_SESSION_TOKEN = settings['AWS_SESSION_TOKEN']\n        s3store.AWS_ENDPOINT_URL = settings['AWS_ENDPOINT_URL']\n        s3store.AWS_REGION_NAME = settings['AWS_REGION_NAME']\n        s3store.AWS_USE_SSL = settings['AWS_USE_SSL']\n        s3store.AWS_VERIFY = settings['AWS_VERIFY']\n        s3store.POLICY = settings['IMAGES_STORE_S3_ACL']\n\n        gcs_store = cls.STORE_SCHEMES['gs']\n        gcs_store.GCS_PROJECT_ID = settings['GCS_PROJECT_ID']\n        gcs_store.POLICY = settings['IMAGES_STORE_GCS_ACL'] or None\n\n        ftp_store = cls.STORE_SCHEMES['ftp']\n        ftp_store.FTP_USERNAME = settings['FTP_USER']\n        ftp_store.FTP_PASSWORD = settings['FTP_PASSWORD']\n        ftp_store.USE_ACTIVE_MODE = settings.getbool('FEED_STORAGE_FTP_ACTIVE')\n\n        store_uri = settings['IMAGES_STORE']\n        return cls(store_uri, settings=settings)\n\n    def file_downloaded(self, response, request, info, *, item=None):\n        return self.image_downloaded(response, request, info, item=item)\n\n    def image_downloaded(self, response, request, info, *, item=None):\n        checksum = None\n        for path, image, buf in self.get_images(response, request, info, item=item):\n            if checksum is None:\n                buf.seek(0)\n                checksum = md5sum(buf)\n            width, height = image.size\n            self.store.persist_file(\n                path, buf, info,\n                meta={'width': width, 'height': height},\n                headers={'Content-Type': 'image/jpeg'})\n        return checksum\n\n    def get_images(self, response, request, info, *, item=None):\n        path = self.file_path(request, response=response, info=info, item=item)\n        orig_image = self._Image.open(BytesIO(response.body))\n\n        width, height = orig_image.size\n        if width < self.min_width or height < self.min_height:\n            raise ImageException(\"Image too small \"\n                                 f\"({width}x{height} < \"\n                                 f\"{self.min_width}x{self.min_height})\")\n\n        if self._deprecated_convert_image is None:\n            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n            if self._deprecated_convert_image:\n                warnings.warn(f'{self.__class__.__name__}.convert_image() method overriden in a deprecated way, '\n                              'overriden method does not accept response_body argument.',\n                              category=ScrapyDeprecationWarning)\n\n        if self._deprecated_convert_image:\n            image, buf = self.convert_image(orig_image)\n        else:\n            image, buf = self.convert_image(orig_image, response_body=BytesIO(response.body))\n        yield path, image, buf\n\n        for thumb_id, size in self.thumbs.items():\n            thumb_path = self.thumb_path(request, thumb_id, response=response, info=info, item=item)\n            if self._deprecated_convert_image:\n                thumb_image, thumb_buf = self.convert_image(image, size)\n            else:\n                thumb_image, thumb_buf = self.convert_image(image, size, buf)\n            yield thumb_path, thumb_image, thumb_buf\n\n    def convert_image(self, image, size=None, response_body=None):\n        if response_body is None:\n            warnings.warn(f'{self.__class__.__name__}.convert_image() method called in a deprecated way, '\n                          'method called without response_body argument.',\n                          category=ScrapyDeprecationWarning, stacklevel=2)\n\n        if image.format == 'PNG' and image.mode == 'RGBA':\n            background = self._Image.new('RGBA', image.size, (255, 255, 255))\n            background.paste(image, image)\n            image = background.convert('RGB')\n        elif image.mode == 'P':\n            image = image.convert(\"RGBA\")\n            background = self._Image.new('RGBA', image.size, (255, 255, 255))\n            background.paste(image, image)\n            image = background.convert('RGB')\n        elif image.mode != 'RGB':\n            image = image.convert('RGB')\n\n        if size:\n            image = image.copy()\n            try:\n                # Image.Resampling.LANCZOS was added in Pillow 9.1.0\n                # remove this try except block,\n                # when updating the minimum requirements for Pillow.\n                resampling_filter = self._Image.Resampling.LANCZOS\n            except AttributeError:\n                resampling_filter = self._Image.ANTIALIAS\n            image.thumbnail(size, resampling_filter)\n        elif response_body is not None and image.format == 'JPEG':\n            return image, response_body\n\n        buf = BytesIO()\n        image.save(buf, 'JPEG')\n        return image, buf\n\n    def get_media_requests(self, item, info):\n        urls = ItemAdapter(item).get(self.images_urls_field, [])\n        return [Request(u) for u in urls]\n\n    def item_completed(self, results, item, info):\n        with suppress(KeyError):\n            ItemAdapter(item)[self.images_result_field] = [x for ok, x in results if ok]\n        return item\n\n    def file_path(self, request, response=None, info=None, *, item=None):\n        image_guid = hashlib.sha1(to_bytes(request.url)).hexdigest()\n        return f'full/{image_guid}.jpg'\n\n    def thumb_path(self, request, thumb_id, response=None, info=None, *, item=None):\n        thumb_guid = hashlib.sha1(to_bytes(request.url)).hexdigest()\n        return f'thumbs/{thumb_id}/{thumb_guid}.jpg'\n"
    },
    {
      "filename": "tests/test_pipeline_images.py",
      "content": "import dataclasses\nimport hashlib\nimport io\nimport random\nimport warnings\nfrom shutil import rmtree\nfrom tempfile import mkdtemp\nfrom unittest.mock import patch\n\nimport attr\nfrom itemadapter import ItemAdapter\nfrom twisted.trial import unittest\n\nfrom scrapy.exceptions import ScrapyDeprecationWarning\nfrom scrapy.http import Request, Response\nfrom scrapy.item import Field, Item\nfrom scrapy.pipelines.images import ImageException, ImagesPipeline, NoimagesDrop\nfrom scrapy.settings import Settings\nfrom scrapy.utils.python import to_bytes\n\n\ntry:\n    from PIL import Image\nexcept ImportError:\n    skip_pillow = 'Missing Python Imaging Library, install https://pypi.python.org/pypi/Pillow'\nelse:\n    encoders = {'jpeg_encoder', 'jpeg_decoder'}\n    if not encoders.issubset(set(Image.core.__dict__)):\n        skip_pillow = 'Missing JPEG encoders'\n    else:\n        skip_pillow = None\n\n\ndef _mocked_download_func(request, info):\n    response = request.meta.get('response')\n    return response() if callable(response) else response\n\n\nclass ImagesPipelineTestCase(unittest.TestCase):\n\n    skip = skip_pillow\n\n    def setUp(self):\n        self.tempdir = mkdtemp()\n        self.pipeline = ImagesPipeline(self.tempdir, download_func=_mocked_download_func)\n\n    def tearDown(self):\n        rmtree(self.tempdir)\n\n    def test_file_path(self):\n        file_path = self.pipeline.file_path\n        self.assertEqual(\n            file_path(Request(\"https://dev.mydeco.com/mydeco.gif\")),\n            'full/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg')\n        self.assertEqual(\n            file_path(Request(\"http://www.maddiebrown.co.uk///catalogue-items//image_54642_12175_95307.jpg\")),\n            'full/0ffcd85d563bca45e2f90becd0ca737bc58a00b2.jpg')\n        self.assertEqual(\n            file_path(Request(\"https://dev.mydeco.com/two/dirs/with%20spaces%2Bsigns.gif\")),\n            'full/b250e3a74fff2e4703e310048a5b13eba79379d2.jpg')\n        self.assertEqual(\n            file_path(Request(\"http://www.dfsonline.co.uk/get_prod_image.php?img=status_0907_mdm.jpg\")),\n            'full/4507be485f38b0da8a0be9eb2e1dfab8a19223f2.jpg')\n        self.assertEqual(\n            file_path(Request(\"http://www.dorma.co.uk/images/product_details/2532/\")),\n            'full/97ee6f8a46cbbb418ea91502fd24176865cf39b2.jpg')\n        self.assertEqual(\n            file_path(Request(\"http://www.dorma.co.uk/images/product_details/2532\")),\n            'full/244e0dd7d96a3b7b01f54eded250c9e272577aa1.jpg')\n        self.assertEqual(\n            file_path(Request(\"http://www.dorma.co.uk/images/product_details/2532\"),\n                      response=Response(\"http://www.dorma.co.uk/images/product_details/2532\"),\n                      info=object()),\n            'full/244e0dd7d96a3b7b01f54eded250c9e272577aa1.jpg')\n\n    def test_thumbnail_name(self):\n        thumb_path = self.pipeline.thumb_path\n        name = '50'\n        self.assertEqual(thumb_path(Request(\"file:///tmp/foo.jpg\"), name),\n                         'thumbs/50/38a86208c36e59d4404db9e37ce04be863ef0335.jpg')\n        self.assertEqual(thumb_path(Request(\"file://foo.png\"), name),\n                         'thumbs/50/e55b765eba0ec7348e50a1df496040449071b96a.jpg')\n        self.assertEqual(thumb_path(Request(\"file:///tmp/foo\"), name),\n                         'thumbs/50/0329ad83ebb8e93ea7c7906d46e9ed55f7349a50.jpg')\n        self.assertEqual(thumb_path(Request(\"file:///tmp/some.name/foo\"), name),\n                         'thumbs/50/850233df65a5b83361798f532f1fc549cd13cbe9.jpg')\n        self.assertEqual(thumb_path(Request(\"file:///tmp/some.name/foo\"), name,\n                                    response=Response(\"file:///tmp/some.name/foo\"),\n                                    info=object()),\n                         'thumbs/50/850233df65a5b83361798f532f1fc549cd13cbe9.jpg')\n\n    def test_thumbnail_name_from_item(self):\n        \"\"\"\n        Custom thumbnail name based on item data, overriding default implementation\n        \"\"\"\n\n        class CustomImagesPipeline(ImagesPipeline):\n            def thumb_path(self, request, thumb_id, response=None, info=None, item=None):\n                return f\"thumb/{thumb_id}/{item.get('path')}\"\n\n        thumb_path = CustomImagesPipeline.from_settings(Settings(\n            {'IMAGES_STORE': self.tempdir}\n        )).thumb_path\n        item = dict(path='path-to-store-file')\n        request = Request(\"http://example.com\")\n        self.assertEqual(thumb_path(request, 'small', item=item), 'thumb/small/path-to-store-file')\n\n    def test_get_images_exception(self):\n        self.pipeline.min_width = 100\n        self.pipeline.min_height = 100\n\n        _, buf1 = _create_image('JPEG', 'RGB', (50, 50), (0, 0, 0))\n        _, buf2 = _create_image('JPEG', 'RGB', (150, 50), (0, 0, 0))\n        _, buf3 = _create_image('JPEG', 'RGB', (50, 150), (0, 0, 0))\n\n        resp1 = Response(url=\"https://dev.mydeco.com/mydeco.gif\", body=buf1.getvalue())\n        resp2 = Response(url=\"https://dev.mydeco.com/mydeco.gif\", body=buf2.getvalue())\n        resp3 = Response(url=\"https://dev.mydeco.com/mydeco.gif\", body=buf3.getvalue())\n        req = Request(url=\"https://dev.mydeco.com/mydeco.gif\")\n\n        with self.assertRaises(ImageException):\n            next(self.pipeline.get_images(response=resp1, request=req, info=object()))\n        with self.assertRaises(ImageException):\n            next(self.pipeline.get_images(response=resp2, request=req, info=object()))\n        with self.assertRaises(ImageException):\n            next(self.pipeline.get_images(response=resp3, request=req, info=object()))\n\n    def test_get_images_new(self):\n        self.pipeline.min_width = 0\n        self.pipeline.min_height = 0\n        self.pipeline.thumbs = {'small': (20, 20)}\n\n        orig_im, buf = _create_image('JPEG', 'RGB', (50, 50), (0, 0, 0))\n        orig_thumb, orig_thumb_buf = _create_image('JPEG', 'RGB', (20, 20), (0, 0, 0))\n        resp = Response(url=\"https://dev.mydeco.com/mydeco.gif\", body=buf.getvalue())\n        req = Request(url=\"https://dev.mydeco.com/mydeco.gif\")\n\n        get_images_gen = self.pipeline.get_images(response=resp, request=req, info=object())\n\n        path, new_im, new_buf = next(get_images_gen)\n        self.assertEqual(path, 'full/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg')\n        self.assertEqual(orig_im, new_im)\n        self.assertEqual(buf.getvalue(), new_buf.getvalue())\n\n        thumb_path, thumb_img, thumb_buf = next(get_images_gen)\n        self.assertEqual(thumb_path, 'thumbs/small/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg')\n        self.assertEqual(thumb_img, thumb_img)\n        self.assertEqual(orig_thumb_buf.getvalue(), thumb_buf.getvalue())\n\n    def test_get_images_old(self):\n        self.pipeline.thumbs = {'small': (20, 20)}\n        orig_im, buf = _create_image('JPEG', 'RGB', (50, 50), (0, 0, 0))\n        resp = Response(url=\"https://dev.mydeco.com/mydeco.gif\", body=buf.getvalue())\n        req = Request(url=\"https://dev.mydeco.com/mydeco.gif\")\n\n        def overridden_convert_image(image, size=None):\n            im, buf = _create_image('JPEG', 'RGB', (50, 50), (0, 0, 0))\n            return im, buf\n\n        with patch.object(self.pipeline, 'convert_image', overridden_convert_image):\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter('always')\n                get_images_gen = self.pipeline.get_images(response=resp, request=req, info=object())\n                path, new_im, new_buf = next(get_images_gen)\n                self.assertEqual(path, 'full/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg')\n                self.assertEqual(orig_im.mode, new_im.mode)\n                self.assertEqual(orig_im.getcolors(), new_im.getcolors())\n                self.assertEqual(buf.getvalue(), new_buf.getvalue())\n\n                thumb_path, thumb_img, thumb_buf = next(get_images_gen)\n                self.assertEqual(thumb_path, 'thumbs/small/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg')\n                self.assertEqual(orig_im.mode, thumb_img.mode)\n                self.assertEqual(orig_im.getcolors(), thumb_img.getcolors())\n                self.assertEqual(buf.getvalue(), thumb_buf.getvalue())\n\n                expected_warning_msg = ('.convert_image() method overriden in a deprecated way, '\n                                        'overriden method does not accept response_body argument.')\n                self.assertEqual(len([warning for warning in w if expected_warning_msg in str(warning.message)]), 1)\n\n    def test_convert_image_old(self):\n        # tests for old API\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter('always')\n            SIZE = (100, 100)\n            # straigh forward case: RGB and JPEG\n            COLOUR = (0, 127, 255)\n            im, _ = _create_image('JPEG', 'RGB', SIZE, COLOUR)\n            converted, _ = self.pipeline.convert_image(im)\n            self.assertEqual(converted.mode, 'RGB')\n            self.assertEqual(converted.getcolors(), [(10000, COLOUR)])\n\n            # check that thumbnail keep image ratio\n            thumbnail, _ = self.pipeline.convert_image(converted, size=(10, 25))\n            self.assertEqual(thumbnail.mode, 'RGB')\n            self.assertEqual(thumbnail.size, (10, 10))\n\n            # transparency case: RGBA and PNG\n            COLOUR = (0, 127, 255, 50)\n            im, _ = _create_image('PNG', 'RGBA', SIZE, COLOUR)\n            converted, _ = self.pipeline.convert_image(im)\n            self.assertEqual(converted.mode, 'RGB')\n            self.assertEqual(converted.getcolors(), [(10000, (205, 230, 255))])\n\n            # transparency case with palette: P and PNG\n            COLOUR = (0, 127, 255, 50)\n            im, _ = _create_image('PNG', 'RGBA', SIZE, COLOUR)\n            im = im.convert('P')\n            converted, _ = self.pipeline.convert_image(im)\n            self.assertEqual(converted.mode, 'RGB')\n            self.assertEqual(converted.getcolors(), [(10000, (205, 230, 255))])\n\n            # ensure that we recieved deprecation warnings\n            expected_warning_msg = '.convert_image() method called in a deprecated way'\n            self.assertTrue(len([warning for warning in w if expected_warning_msg in str(warning.message)]) == 4)\n\n    def test_convert_image_new(self):\n        # tests for new API\n        SIZE = (100, 100)\n        # straigh forward case: RGB and JPEG\n        COLOUR = (0, 127, 255)\n        im, buf = _create_image('JPEG', 'RGB', SIZE, COLOUR)\n        converted, converted_buf = self.pipeline.convert_image(im, response_body=buf)\n        self.assertEqual(converted.mode, 'RGB')\n        self.assertEqual(converted.getcolors(), [(10000, COLOUR)])\n        # check that we don't convert JPEGs again\n        self.assertEqual(converted_buf, buf)\n\n        # check that thumbnail keep image ratio\n        thumbnail, _ = self.pipeline.convert_image(converted, size=(10, 25), response_body=converted_buf)\n        self.assertEqual(thumbnail.mode, 'RGB')\n        self.assertEqual(thumbnail.size, (10, 10))\n\n        # transparency case: RGBA and PNG\n        COLOUR = (0, 127, 255, 50)\n        im, buf = _create_image('PNG', 'RGBA', SIZE, COLOUR)\n        converted, _ = self.pipeline.convert_image(im, response_body=buf)\n        self.assertEqual(converted.mode, 'RGB')\n        self.assertEqual(converted.getcolors(), [(10000, (205, 230, 255))])\n\n        # transparency case with palette: P and PNG\n        COLOUR = (0, 127, 255, 50)\n        im, buf = _create_image('PNG', 'RGBA', SIZE, COLOUR)\n        im = im.convert('P')\n        converted, _ = self.pipeline.convert_image(im, response_body=buf)\n        self.assertEqual(converted.mode, 'RGB')\n        self.assertEqual(converted.getcolors(), [(10000, (205, 230, 255))])\n\n\nclass DeprecatedImagesPipeline(ImagesPipeline):\n    def file_key(self, url):\n        return self.image_key(url)\n\n    def image_key(self, url):\n        image_guid = hashlib.sha1(to_bytes(url)).hexdigest()\n        return f'empty/{image_guid}.jpg'\n\n    def thumb_key(self, url, thumb_id):\n        thumb_guid = hashlib.sha1(to_bytes(url)).hexdigest()\n        return f'thumbsup/{thumb_id}/{thumb_guid}.jpg'\n\n\nclass ImagesPipelineTestCaseFieldsMixin:\n\n    skip = skip_pillow\n\n    def test_item_fields_default(self):\n        url = 'http://www.example.com/images/1.jpg'\n        item = self.item_class(name='item1', image_urls=[url])\n        pipeline = ImagesPipeline.from_settings(Settings({'IMAGES_STORE': 's3://example/images/'}))\n        requests = list(pipeline.get_media_requests(item, None))\n        self.assertEqual(requests[0].url, url)\n        results = [(True, {'url': url})]\n        item = pipeline.item_completed(results, item, None)\n        images = ItemAdapter(item).get(\"images\")\n        self.assertEqual(images, [results[0][1]])\n        self.assertIsInstance(item, self.item_class)\n\n    def test_item_fields_override_settings(self):\n        url = 'http://www.example.com/images/1.jpg'\n        item = self.item_class(name='item1', custom_image_urls=[url])\n        pipeline = ImagesPipeline.from_settings(Settings({\n            'IMAGES_STORE': 's3://example/images/',\n            'IMAGES_URLS_FIELD': 'custom_image_urls',\n            'IMAGES_RESULT_FIELD': 'custom_images'\n        }))\n        requests = list(pipeline.get_media_requests(item, None))\n        self.assertEqual(requests[0].url, url)\n        results = [(True, {'url': url})]\n        item = pipeline.item_completed(results, item, None)\n        custom_images = ItemAdapter(item).get(\"custom_images\")\n        self.assertEqual(custom_images, [results[0][1]])\n        self.assertIsInstance(item, self.item_class)\n\n\nclass ImagesPipelineTestCaseFieldsDict(ImagesPipelineTestCaseFieldsMixin, unittest.TestCase):\n    item_class = dict\n\n\nclass ImagesPipelineTestItem(Item):\n    name = Field()\n    # default fields\n    image_urls = Field()\n    images = Field()\n    # overridden fields\n    custom_image_urls = Field()\n    custom_images = Field()\n\n\nclass ImagesPipelineTestCaseFieldsItem(ImagesPipelineTestCaseFieldsMixin, unittest.TestCase):\n    item_class = ImagesPipelineTestItem\n\n\n@dataclasses.dataclass\nclass ImagesPipelineTestDataClass:\n    name: str\n    # default fields\n    image_urls: list = dataclasses.field(default_factory=list)\n    images: list = dataclasses.field(default_factory=list)\n    # overridden fields\n    custom_image_urls: list = dataclasses.field(default_factory=list)\n    custom_images: list = dataclasses.field(default_factory=list)\n\n\nclass ImagesPipelineTestCaseFieldsDataClass(ImagesPipelineTestCaseFieldsMixin, unittest.TestCase):\n    item_class = ImagesPipelineTestDataClass\n\n\n@attr.s\nclass ImagesPipelineTestAttrsItem:\n    name = attr.ib(default=\"\")\n    # default fields\n    image_urls = attr.ib(default=lambda: [])\n    images = attr.ib(default=lambda: [])\n    # overridden fields\n    custom_image_urls = attr.ib(default=lambda: [])\n    custom_images = attr.ib(default=lambda: [])\n\n\nclass ImagesPipelineTestCaseFieldsAttrsItem(ImagesPipelineTestCaseFieldsMixin, unittest.TestCase):\n    item_class = ImagesPipelineTestAttrsItem\n\n\nclass ImagesPipelineTestCaseCustomSettings(unittest.TestCase):\n\n    skip = skip_pillow\n\n    img_cls_attribute_names = [\n        # Pipeline attribute names with corresponding setting names.\n        (\"EXPIRES\", \"IMAGES_EXPIRES\"),\n        (\"MIN_WIDTH\", \"IMAGES_MIN_WIDTH\"),\n        (\"MIN_HEIGHT\", \"IMAGES_MIN_HEIGHT\"),\n        (\"IMAGES_URLS_FIELD\", \"IMAGES_URLS_FIELD\"),\n        (\"IMAGES_RESULT_FIELD\", \"IMAGES_RESULT_FIELD\"),\n        (\"THUMBS\", \"IMAGES_THUMBS\")\n    ]\n\n    # This should match what is defined in ImagesPipeline.\n    default_pipeline_settings = dict(\n        MIN_WIDTH=0,\n        MIN_HEIGHT=0,\n        EXPIRES=90,\n        THUMBS={},\n        IMAGES_URLS_FIELD='image_urls',\n        IMAGES_RESULT_FIELD='images'\n    )\n\n    def setUp(self):\n        self.tempdir = mkdtemp()\n\n    def tearDown(self):\n        rmtree(self.tempdir)\n\n    def _generate_fake_settings(self, prefix=None):\n        \"\"\"\n        :param prefix: string for setting keys\n        :return: dictionary of image pipeline settings\n        \"\"\"\n\n        def random_string():\n            return \"\".join([chr(random.randint(97, 123)) for _ in range(10)])\n\n        settings = {\n            \"IMAGES_EXPIRES\": random.randint(100, 1000),\n            \"IMAGES_STORE\": self.tempdir,\n            \"IMAGES_RESULT_FIELD\": random_string(),\n            \"IMAGES_URLS_FIELD\": random_string(),\n            \"IMAGES_MIN_WIDTH\": random.randint(1, 1000),\n            \"IMAGES_MIN_HEIGHT\": random.randint(1, 1000),\n            \"IMAGES_THUMBS\": {\n                'small': (random.randint(1, 1000), random.randint(1, 1000)),\n                'big': (random.randint(1, 1000), random.randint(1, 1000))\n            }\n        }\n        if not prefix:\n            return settings\n\n        return {prefix.upper() + \"_\" + k if k != \"IMAGES_STORE\" else k: v for k, v in settings.items()}\n\n    def _generate_fake_pipeline_subclass(self):\n        \"\"\"\n        :return: ImagePipeline class will all uppercase attributes set.\n        \"\"\"\n        class UserDefinedImagePipeline(ImagesPipeline):\n            # Values should be in different range than fake_settings.\n            MIN_WIDTH = random.randint(1000, 2000)\n            MIN_HEIGHT = random.randint(1000, 2000)\n            THUMBS = {\n                'small': (random.randint(1000, 2000), random.randint(1000, 2000)),\n                'big': (random.randint(1000, 2000), random.randint(1000, 2000))\n            }\n            EXPIRES = random.randint(1000, 2000)\n            IMAGES_URLS_FIELD = \"field_one\"\n            IMAGES_RESULT_FIELD = \"field_two\"\n\n        return UserDefinedImagePipeline\n\n    def test_different_settings_for_different_instances(self):\n        \"\"\"\n        If there are two instances of ImagesPipeline class with different settings, they should\n        have different settings.\n        \"\"\"\n        custom_settings = self._generate_fake_settings()\n        default_settings = Settings()\n        default_sts_pipe = ImagesPipeline(self.tempdir, settings=default_settings)\n        user_sts_pipe = ImagesPipeline.from_settings(Settings(custom_settings))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            expected_default_value = self.default_pipeline_settings.get(pipe_attr)\n            custom_value = custom_settings.get(settings_attr)\n            self.assertNotEqual(expected_default_value, custom_value)\n            self.assertEqual(getattr(default_sts_pipe, pipe_attr.lower()), expected_default_value)\n            self.assertEqual(getattr(user_sts_pipe, pipe_attr.lower()), custom_value)\n\n    def test_subclass_attrs_preserved_default_settings(self):\n        \"\"\"\n        If image settings are not defined at all subclass of ImagePipeline takes values\n        from class attributes.\n        \"\"\"\n        pipeline_cls = self._generate_fake_pipeline_subclass()\n        pipeline = pipeline_cls.from_settings(Settings({\"IMAGES_STORE\": self.tempdir}))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            # Instance attribute (lowercase) must be equal to class attribute (uppercase).\n            attr_value = getattr(pipeline, pipe_attr.lower())\n            self.assertNotEqual(attr_value, self.default_pipeline_settings[pipe_attr])\n            self.assertEqual(attr_value, getattr(pipeline, pipe_attr))\n\n    def test_subclass_attrs_preserved_custom_settings(self):\n        \"\"\"\n        If image settings are defined but they are not defined for subclass default\n        values taken from settings should be preserved.\n        \"\"\"\n        pipeline_cls = self._generate_fake_pipeline_subclass()\n        settings = self._generate_fake_settings()\n        pipeline = pipeline_cls.from_settings(Settings(settings))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            # Instance attribute (lowercase) must be equal to\n            # value defined in settings.\n            value = getattr(pipeline, pipe_attr.lower())\n            self.assertNotEqual(value, self.default_pipeline_settings[pipe_attr])\n            setings_value = settings.get(settings_attr)\n            self.assertEqual(value, setings_value)\n\n    def test_no_custom_settings_for_subclasses(self):\n        \"\"\"\n        If there are no settings for subclass and no subclass attributes, pipeline should use\n        attributes of base class.\n        \"\"\"\n        class UserDefinedImagePipeline(ImagesPipeline):\n            pass\n\n        user_pipeline = UserDefinedImagePipeline.from_settings(Settings({\"IMAGES_STORE\": self.tempdir}))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            # Values from settings for custom pipeline should be set on pipeline instance.\n            custom_value = self.default_pipeline_settings.get(pipe_attr.upper())\n            self.assertEqual(getattr(user_pipeline, pipe_attr.lower()), custom_value)\n\n    def test_custom_settings_for_subclasses(self):\n        \"\"\"\n        If there are custom settings for subclass and NO class attributes, pipeline should use custom\n        settings.\n        \"\"\"\n        class UserDefinedImagePipeline(ImagesPipeline):\n            pass\n\n        prefix = UserDefinedImagePipeline.__name__.upper()\n        settings = self._generate_fake_settings(prefix=prefix)\n        user_pipeline = UserDefinedImagePipeline.from_settings(Settings(settings))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            # Values from settings for custom pipeline should be set on pipeline instance.\n            custom_value = settings.get(prefix + \"_\" + settings_attr)\n            self.assertNotEqual(custom_value, self.default_pipeline_settings[pipe_attr])\n            self.assertEqual(getattr(user_pipeline, pipe_attr.lower()), custom_value)\n\n    def test_custom_settings_and_class_attrs_for_subclasses(self):\n        \"\"\"\n        If there are custom settings for subclass AND class attributes\n        setting keys are preferred and override attributes.\n        \"\"\"\n        pipeline_cls = self._generate_fake_pipeline_subclass()\n        prefix = pipeline_cls.__name__.upper()\n        settings = self._generate_fake_settings(prefix=prefix)\n        user_pipeline = pipeline_cls.from_settings(Settings(settings))\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            custom_value = settings.get(prefix + \"_\" + settings_attr)\n            self.assertNotEqual(custom_value, self.default_pipeline_settings[pipe_attr])\n            self.assertEqual(getattr(user_pipeline, pipe_attr.lower()), custom_value)\n\n    def test_cls_attrs_with_DEFAULT_prefix(self):\n        class UserDefinedImagePipeline(ImagesPipeline):\n            DEFAULT_IMAGES_URLS_FIELD = \"something\"\n            DEFAULT_IMAGES_RESULT_FIELD = \"something_else\"\n        pipeline = UserDefinedImagePipeline.from_settings(Settings({\"IMAGES_STORE\": self.tempdir}))\n        self.assertEqual(pipeline.images_result_field, \"something_else\")\n        self.assertEqual(pipeline.images_urls_field, \"something\")\n\n    def test_user_defined_subclass_default_key_names(self):\n        \"\"\"Test situation when user defines subclass of ImagePipeline,\n        but uses attribute names for default pipeline (without prefixing\n        them with pipeline class name).\n        \"\"\"\n        settings = self._generate_fake_settings()\n\n        class UserPipe(ImagesPipeline):\n            pass\n\n        pipeline_cls = UserPipe.from_settings(Settings(settings))\n\n        for pipe_attr, settings_attr in self.img_cls_attribute_names:\n            expected_value = settings.get(settings_attr)\n            self.assertEqual(getattr(pipeline_cls, pipe_attr.lower()),\n                             expected_value)\n\n\nclass NoimagesDropTestCase(unittest.TestCase):\n\n    def test_deprecation_warning(self):\n        arg = str()\n        with warnings.catch_warnings(record=True) as w:\n            NoimagesDrop(arg)\n            self.assertEqual(len(w), 1)\n            self.assertEqual(w[0].category, ScrapyDeprecationWarning)\n        with warnings.catch_warnings(record=True) as w:\n            class SubclassedNoimagesDrop(NoimagesDrop):\n                pass\n            SubclassedNoimagesDrop(arg)\n            self.assertEqual(len(w), 1)\n            self.assertEqual(w[0].category, ScrapyDeprecationWarning)\n\n\ndef _create_image(format, *a, **kw):\n    buf = io.BytesIO()\n    Image.new(*a, **kw).save(buf, format)\n    buf.seek(0)\n    return Image.open(buf), buf\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
    }
  ],
  "questions": [
    "Looks like the author of the linked PR hasn't responded to the last few suggestions.\r\nCan I take his PR and finish this issue?"
  ],
  "golden_answers": [
    "@drs-11 By all means, be our guest. The scenario is covered in our [contributing guidelines](https://docs.scrapy.org/en/latest/contributing.html#submitting-patches):\r\n\r\n> Sometimes there is an existing pull request for the problem you’d like to solve, which is stalled for some reason. Often the pull request is in a right direction, but changes are requested by Scrapy maintainers, and the original pull request author hasn’t had time to address them. In this case consider picking up this pull request: open a new pull request with all commits from the original pull request, as well as additional changes to address the raised issues. Doing so helps a lot; it is not considered rude as soon as the original author is acknowledged by keeping his/her commits."
  ],
  "questions_generated": [
    "What is the role of the ImagesPipeline class in the scrapy_scrapy repository, and how does it relate to the issue described?",
    "How does the ImagesPipeline currently handle image recoding, and what is the proposed change to address the issue of image quality degradation?",
    "What are the potential drawbacks of the current implementation that recodes JPEG images, even when they are already in JPEG format?",
    "How does the documentation of the scrapy_scrapy repository describe the behavior of the ImagesPipeline, and why might there be a discrepancy between the documentation and user expectations?",
    "Considering the discussion about the Pillow library's behavior in the ImagesPipeline, what workaround does the developer suggest for users who want to avoid image recoding?"
  ],
  "golden_answers_generated": [
    "The ImagesPipeline class in the scrapy_scrapy repository is responsible for handling image processing tasks such as downloading images and generating thumbnails. It is an abstract pipeline that implements image thumbnail generation logic. The issue described is related to this class because the ImagesPipeline uses the Pillow library to standardize images to a JPEG/RGB format, which can lead to quality loss when images are recoded.",
    "The ImagesPipeline currently uses Pillow to convert all images to a JPEG/RGB format, which can result in recoding even for images that are already in JPEG format, potentially causing a loss in quality. The proposed change is to add an option to the pipeline to avoid this automatic recoding, thereby preserving the original image quality when it is not necessary to re-encode.",
    "The potential drawbacks of the current implementation include the loss of image quality due to the lossy nature of JPEG encoding. When an image is already in JPEG format, re-encoding it can degrade its quality further. This happens because each JPEG encoding involves data compression, which results in loss of detail and artifacts. This is particularly problematic for users who require the images to be as close to their original quality as possible.",
    "The documentation of the scrapy_scrapy repository states that the ImagesPipeline will convert all images to a common format, specifically JPEG with RGBA color space. This is intended to standardize images for processing. However, there might be a discrepancy between the documentation and user expectations because users may not anticipate the quality degradation associated with converting JPEG images that are already in JPEG format. Users expect the pipeline to preserve image quality unless explicitly requested otherwise.",
    "For users who want to avoid image recoding and preserve the original quality, the developer suggests using the Files pipeline instead of the Images pipeline. The Files pipeline does not alter the images and retains them in their original format as they occur online. This recommendation is made to address the concern of unwanted image transformations that occur in the Images pipeline."
  ]
}