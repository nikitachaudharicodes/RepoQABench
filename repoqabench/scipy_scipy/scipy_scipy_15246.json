{
  "repo_name": "scipy_scipy",
  "issue_id": "15246",
  "issue_description": "# BUG: Docs (or implementation) for negative inputs to factorial2 are incorrect\n\n### Describe your issue.\n\nThe docstring for [factorial2](https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/special/_basic.py#L2399-L2453) says:\r\n>If ``n < 0``, the return value is 0.\r\n\r\nHowever directly below that in the code, we can see this is not the case for `n==-1`\r\n\r\n```\r\nif exact:\r\n    if n < -1:\r\n        return 0\r\n    if n <= 0:\r\n        return 1\r\n```\r\nThis will give a value of 1 for `factorial2(-1)` (if `exact` is false, it returns 1.0).\r\n\r\nThe code could be made consistent with the documentation (either making the result for n==-1 be 0 or saying that for n<-1, factorial2 is 0).\r\n\r\nAlternatively, the code could be adapted to perform the [extended double factorial](https://en.m.wikipedia.org/wiki/Double_factorial#Negative_arguments) which allows for negative inputs.\r\n\r\n\r\n\r\n\n\n### Reproducing Code Example\n\n```python\nscipy.special.factorial(-1)\n```\n\n\n### Error message\n\n```shell\nNone\n```\n\n\n### SciPy/NumPy/Python version information\n\n1.7.1 1.21.2 sys.version_info(major=3, minor=9, micro=7, releaselevel='final', serial=0) ",
  "issue_comments": [
    {
      "id": 997658099,
      "user": "samO2I1",
      "body": "Dear sir,\r\nI would like to work on this issue."
    },
    {
      "id": 998046800,
      "user": "TyBalduf",
      "body": "@samO2I1 I think if you submit a pull-request and connect it with this issue, they will be able to see if they want to use your version of the code or make any corrections to it before merging it."
    },
    {
      "id": 998503978,
      "user": "samO2I1",
      "body": "Sure Sir\r\n "
    },
    {
      "id": 1001045148,
      "user": "samO2I1",
      "body": "The result of n==-1 should be 1 as per [info](https://en.m.wikipedia.org/wiki/Double_factorial#Negative_arguments)  and the code when run \r\n```\r\nif exact:\r\n    if n < -1:\r\n        return 0\r\n    if n <= 0:\r\n        return 1\r\n```\r\ngives 1 and 0 for all the values less than -1  which also satisfies the condition of factorial2 docstring.\r\nSo sir can you please explain the issue more clearly .\r\nThanks"
    },
    {
      "id": 1001048440,
      "user": "TyBalduf",
      "body": "@samO2I1 The docstring says that for n>0, the result should be 0. So for n==-1 it's giving the \"wrong\" result at least according to the docstring. \r\n\r\nFactorial2 should either give 0 for all negative values or it should be extended to work for all negative values. I'm more partial to extending it (I happen to have some code that uses needs factorial2 (-1) to be 1)."
    },
    {
      "id": 1001115395,
      "user": "samO2I1",
      "body": "Ok sir i will work on the code that can give exact answers to all the negative values i.e extending to work for all negative values."
    },
    {
      "id": 1003124264,
      "user": "samO2I1",
      "body": "@TyBalduf  I am not able to find the solution to the negative even integers whereas we have a formula for negative odd integers.\r\nSo should we give 0 for all negative even integers and normal solutions to negative odd integers according to the formula ?"
    },
    {
      "id": 1003127500,
      "user": "TyBalduf",
      "body": "@samO2I1 the extension still leaves the value for negative even integers undefined, so it would make sense to leave these as zero and use the formula for negative odd integers."
    },
    {
      "id": 1003270807,
      "user": "samO2I1",
      "body": "@TyBalduf  then to make the result consistent should I make the solution 0 for all negative integers as the value for negative even integers is undefined."
    },
    {
      "id": 1003271908,
      "user": "TyBalduf",
      "body": "@samO2I1 some ideas for this are being discussed on an open pull request: https://github.com/scipy/scipy/pull/15299. One could choose to define these arbitrarily as zero or as mentioned in the pull request have them return a ValueError for these other inputs."
    },
    {
      "id": 1003276189,
      "user": "samO2I1",
      "body": "@TyBalduf learning from this pull request should I return the value as ValueError for all the **negative even** integers?"
    },
    {
      "id": 1004185164,
      "user": "AvinashDwivedi",
      "body": "Hello sir, I would like to work on this issue. If possible then guide me sir this will be my first contribution."
    },
    {
      "id": 1046333764,
      "user": "AvinashDwivedi",
      "body": "_Hello is there someone who can guide me to solve this issue. I really want to do this_, **It will be my first contribution, Please guide me I'm a newbie**"
    },
    {
      "id": 1053655151,
      "user": "j-bowhay",
      "body": "I think this can be closed gh-15592 changed the docstring to match the implementation and gh-15600 is discussing the current inconsistencies and any possible extensions."
    }
  ],
  "text_context": "# BUG: Docs (or implementation) for negative inputs to factorial2 are incorrect\n\n### Describe your issue.\n\nThe docstring for [factorial2](https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/special/_basic.py#L2399-L2453) says:\r\n>If ``n < 0``, the return value is 0.\r\n\r\nHowever directly below that in the code, we can see this is not the case for `n==-1`\r\n\r\n```\r\nif exact:\r\n    if n < -1:\r\n        return 0\r\n    if n <= 0:\r\n        return 1\r\n```\r\nThis will give a value of 1 for `factorial2(-1)` (if `exact` is false, it returns 1.0).\r\n\r\nThe code could be made consistent with the documentation (either making the result for n==-1 be 0 or saying that for n<-1, factorial2 is 0).\r\n\r\nAlternatively, the code could be adapted to perform the [extended double factorial](https://en.m.wikipedia.org/wiki/Double_factorial#Negative_arguments) which allows for negative inputs.\r\n\r\n\r\n\r\n\n\n### Reproducing Code Example\n\n```python\nscipy.special.factorial(-1)\n```\n\n\n### Error message\n\n```shell\nNone\n```\n\n\n### SciPy/NumPy/Python version information\n\n1.7.1 1.21.2 sys.version_info(major=3, minor=9, micro=7, releaselevel='final', serial=0) \n\nDear sir,\r\nI would like to work on this issue.\n\n@samO2I1 I think if you submit a pull-request and connect it with this issue, they will be able to see if they want to use your version of the code or make any corrections to it before merging it.\n\nSure Sir\r\n \n\nThe result of n==-1 should be 1 as per [info](https://en.m.wikipedia.org/wiki/Double_factorial#Negative_arguments)  and the code when run \r\n```\r\nif exact:\r\n    if n < -1:\r\n        return 0\r\n    if n <= 0:\r\n        return 1\r\n```\r\ngives 1 and 0 for all the values less than -1  which also satisfies the condition of factorial2 docstring.\r\nSo sir can you please explain the issue more clearly .\r\nThanks\n\n@samO2I1 The docstring says that for n>0, the result should be 0. So for n==-1 it's giving the \"wrong\" result at least according to the docstring. \r\n\r\nFactorial2 should either give 0 for all negative values or it should be extended to work for all negative values. I'm more partial to extending it (I happen to have some code that uses needs factorial2 (-1) to be 1).\n\nOk sir i will work on the code that can give exact answers to all the negative values i.e extending to work for all negative values.\n\n@TyBalduf  I am not able to find the solution to the negative even integers whereas we have a formula for negative odd integers.\r\nSo should we give 0 for all negative even integers and normal solutions to negative odd integers according to the formula ?\n\n@samO2I1 the extension still leaves the value for negative even integers undefined, so it would make sense to leave these as zero and use the formula for negative odd integers.\n\n@TyBalduf  then to make the result consistent should I make the solution 0 for all negative integers as the value for negative even integers is undefined.\n\n@samO2I1 some ideas for this are being discussed on an open pull request: https://github.com/scipy/scipy/pull/15299. One could choose to define these arbitrarily as zero or as mentioned in the pull request have them return a ValueError for these other inputs.\n\n@TyBalduf learning from this pull request should I return the value as ValueError for all the **negative even** integers?\n\nHello sir, I would like to work on this issue. If possible then guide me sir this will be my first contribution.\n\n_Hello is there someone who can guide me to solve this issue. I really want to do this_, **It will be my first contribution, Please guide me I'm a newbie**\n\nI think this can be closed gh-15592 changed the docstring to match the implementation and gh-15600 is discussing the current inconsistencies and any possible extensions.",
  "pr_link": "https://github.com/scipy/scipy/pull/15299",
  "code_context": [
    {
      "filename": "scipy/special/_basic.py",
      "content": "#\n# Author:  Travis Oliphant, 2002\n#\n\nimport operator\nimport numpy as np\nimport math\nimport warnings\nfrom numpy import (pi, asarray, floor, isscalar, iscomplex, real,\n                   imag, sqrt, where, mgrid, sin, place, issubdtype,\n                   extract, inexact, nan, zeros, sinc)\nfrom . import _ufuncs\nfrom ._ufuncs import (mathieu_a, mathieu_b, iv, jv, gamma,\n                      psi, hankel1, hankel2, yv, kv, poch, binom)\nfrom . import _specfun\nfrom ._comb import _comb_int\n\n\n__all__ = [\n    'ai_zeros',\n    'assoc_laguerre',\n    'bei_zeros',\n    'beip_zeros',\n    'ber_zeros',\n    'bernoulli',\n    'berp_zeros',\n    'bi_zeros',\n    'clpmn',\n    'comb',\n    'digamma',\n    'diric',\n    'erf_zeros',\n    'euler',\n    'factorial',\n    'factorial2',\n    'factorialk',\n    'fresnel_zeros',\n    'fresnelc_zeros',\n    'fresnels_zeros',\n    'h1vp',\n    'h2vp',\n    'ivp',\n    'jn_zeros',\n    'jnjnp_zeros',\n    'jnp_zeros',\n    'jnyn_zeros',\n    'jvp',\n    'kei_zeros',\n    'keip_zeros',\n    'kelvin_zeros',\n    'ker_zeros',\n    'kerp_zeros',\n    'kvp',\n    'lmbda',\n    'lpmn',\n    'lpn',\n    'lqmn',\n    'lqn',\n    'mathieu_even_coef',\n    'mathieu_odd_coef',\n    'obl_cv_seq',\n    'pbdn_seq',\n    'pbdv_seq',\n    'pbvv_seq',\n    'perm',\n    'polygamma',\n    'pro_cv_seq',\n    'riccati_jn',\n    'riccati_yn',\n    'sinc',\n    'y0_zeros',\n    'y1_zeros',\n    'y1p_zeros',\n    'yn_zeros',\n    'ynp_zeros',\n    'yvp',\n    'zeta'\n]\n\n\ndef _nonneg_int_or_fail(n, var_name, strict=True):\n    try:\n        if strict:\n            # Raises an exception if float\n            n = operator.index(n)\n        elif n == floor(n):\n            n = int(n)\n        else:\n            raise ValueError()\n        if n < 0:\n            raise ValueError()\n    except (ValueError, TypeError) as err:\n        raise err.__class__(\"{} must be a non-negative integer\".format(var_name)) from err\n    return n\n\n\ndef diric(x, n):\n    \"\"\"Periodic sinc function, also called the Dirichlet function.\n\n    The Dirichlet function is defined as::\n\n        diric(x, n) = sin(x * n/2) / (n * sin(x / 2)),\n\n    where `n` is a positive integer.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data\n    n : int\n        Integer defining the periodicity.\n\n    Returns\n    -------\n    diric : ndarray\n\n    Examples\n    --------\n    >>> from scipy import special\n    >>> import matplotlib.pyplot as plt\n\n    >>> x = np.linspace(-8*np.pi, 8*np.pi, num=201)\n    >>> plt.figure(figsize=(8, 8));\n    >>> for idx, n in enumerate([2, 3, 4, 9]):\n    ...     plt.subplot(2, 2, idx+1)\n    ...     plt.plot(x, special.diric(x, n))\n    ...     plt.title('diric, n={}'.format(n))\n    >>> plt.show()\n\n    The following example demonstrates that `diric` gives the magnitudes\n    (modulo the sign and scaling) of the Fourier coefficients of a\n    rectangular pulse.\n\n    Suppress output of values that are effectively 0:\n\n    >>> np.set_printoptions(suppress=True)\n\n    Create a signal `x` of length `m` with `k` ones:\n\n    >>> m = 8\n    >>> k = 3\n    >>> x = np.zeros(m)\n    >>> x[:k] = 1\n\n    Use the FFT to compute the Fourier transform of `x`, and\n    inspect the magnitudes of the coefficients:\n\n    >>> np.abs(np.fft.fft(x))\n    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,\n            0.41421356,  1.        ,  2.41421356])\n\n    Now find the same values (up to sign) using `diric`. We multiply\n    by `k` to account for the different scaling conventions of\n    `numpy.fft.fft` and `diric`:\n\n    >>> theta = np.linspace(0, 2*np.pi, m, endpoint=False)\n    >>> k * special.diric(theta, k)\n    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,\n           -0.41421356,  1.        ,  2.41421356])\n    \"\"\"\n    x, n = asarray(x), asarray(n)\n    n = asarray(n + (x-x))\n    x = asarray(x + (n-n))\n    if issubdtype(x.dtype, inexact):\n        ytype = x.dtype\n    else:\n        ytype = float\n    y = zeros(x.shape, ytype)\n\n    # empirical minval for 32, 64 or 128 bit float computations\n    # where sin(x/2) < minval, result is fixed at +1 or -1\n    if np.finfo(ytype).eps < 1e-18:\n        minval = 1e-11\n    elif np.finfo(ytype).eps < 1e-15:\n        minval = 1e-7\n    else:\n        minval = 1e-3\n\n    mask1 = (n <= 0) | (n != floor(n))\n    place(y, mask1, nan)\n\n    x = x / 2\n    denom = sin(x)\n    mask2 = (1-mask1) & (abs(denom) < minval)\n    xsub = extract(mask2, x)\n    nsub = extract(mask2, n)\n    zsub = xsub / pi\n    place(y, mask2, pow(-1, np.round(zsub)*(nsub-1)))\n\n    mask = (1-mask1) & (1-mask2)\n    xsub = extract(mask, x)\n    nsub = extract(mask, n)\n    dsub = extract(mask, denom)\n    place(y, mask, sin(nsub*xsub)/(nsub*dsub))\n    return y\n\n\ndef jnjnp_zeros(nt):\n    \"\"\"Compute zeros of integer-order Bessel functions Jn and Jn'.\n\n    Results are arranged in order of the magnitudes of the zeros.\n\n    Parameters\n    ----------\n    nt : int\n        Number (<=1200) of zeros to compute\n\n    Returns\n    -------\n    zo[l-1] : ndarray\n        Value of the lth zero of Jn(x) and Jn'(x). Of length `nt`.\n    n[l-1] : ndarray\n        Order of the Jn(x) or Jn'(x) associated with lth zero. Of length `nt`.\n    m[l-1] : ndarray\n        Serial number of the zeros of Jn(x) or Jn'(x) associated\n        with lth zero. Of length `nt`.\n    t[l-1] : ndarray\n        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of\n        length `nt`.\n\n    See Also\n    --------\n    jn_zeros, jnp_zeros : to get separated arrays of zeros.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt > 1200):\n        raise ValueError(\"Number must be integer <= 1200.\")\n    nt = int(nt)\n    n, m, t, zo = _specfun.jdzo(nt)\n    return zo[1:nt+1], n[:nt], m[:nt], t[:nt]\n\n\ndef jnyn_zeros(n, nt):\n    \"\"\"Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).\n\n    Returns 4 arrays of length `nt`, corresponding to the first `nt`\n    zeros of Jn(x), Jn'(x), Yn(x), and Yn'(x), respectively. The zeros\n    are returned in ascending order.\n\n    Parameters\n    ----------\n    n : int\n        Order of the Bessel functions\n    nt : int\n        Number (<=1200) of zeros to compute\n\n    Returns\n    -------\n    Jn : ndarray\n        First `nt` zeros of Jn\n    Jnp : ndarray\n        First `nt` zeros of Jn'\n    Yn : ndarray\n        First `nt` zeros of Yn\n    Ynp : ndarray\n        First `nt` zeros of Yn'\n\n    See Also\n    --------\n    jn_zeros, jnp_zeros, yn_zeros, ynp_zeros\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(nt) and isscalar(n)):\n        raise ValueError(\"Arguments must be scalars.\")\n    if (floor(n) != n) or (floor(nt) != nt):\n        raise ValueError(\"Arguments must be integers.\")\n    if (nt <= 0):\n        raise ValueError(\"nt > 0\")\n    return _specfun.jyzo(abs(n), nt)\n\n\ndef jn_zeros(n, nt):\n    r\"\"\"Compute zeros of integer-order Bessel functions Jn.\n\n    Compute `nt` zeros of the Bessel functions :math:`J_n(x)` on the\n    interval :math:`(0, \\infty)`. The zeros are returned in ascending\n    order. Note that this interval excludes the zero at :math:`x = 0`\n    that exists for :math:`n > 0`.\n\n    Parameters\n    ----------\n    n : int\n        Order of Bessel function\n    nt : int\n        Number of zeros to return\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Bessel function.\n\n    See Also\n    --------\n    jv\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    Examples\n    --------\n    >>> import scipy.special as sc\n\n    We can check that we are getting approximations of the zeros by\n    evaluating them with `jv`.\n\n    >>> n = 1\n    >>> x = sc.jn_zeros(n, 3)\n    >>> x\n    array([ 3.83170597,  7.01558667, 10.17346814])\n    >>> sc.jv(n, x)\n    array([-0.00000000e+00,  1.72975330e-16,  2.89157291e-16])\n\n    Note that the zero at ``x = 0`` for ``n > 0`` is not included.\n\n    >>> sc.jv(1, 0)\n    0.0\n\n    \"\"\"\n    return jnyn_zeros(n, nt)[0]\n\n\ndef jnp_zeros(n, nt):\n    r\"\"\"Compute zeros of integer-order Bessel function derivatives Jn'.\n\n    Compute `nt` zeros of the functions :math:`J_n'(x)` on the\n    interval :math:`(0, \\infty)`. The zeros are returned in ascending\n    order. Note that this interval excludes the zero at :math:`x = 0`\n    that exists for :math:`n > 1`.\n\n    Parameters\n    ----------\n    n : int\n        Order of Bessel function\n    nt : int\n        Number of zeros to return\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Bessel function.\n\n    See Also\n    --------\n    jvp, jv\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    Examples\n    --------\n    >>> import scipy.special as sc\n\n    We can check that we are getting approximations of the zeros by\n    evaluating them with `jvp`.\n\n    >>> n = 2\n    >>> x = sc.jnp_zeros(n, 3)\n    >>> x\n    array([3.05423693, 6.70613319, 9.96946782])\n    >>> sc.jvp(n, x)\n    array([ 2.77555756e-17,  2.08166817e-16, -3.01841885e-16])\n\n    Note that the zero at ``x = 0`` for ``n > 1`` is not included.\n\n    >>> sc.jvp(n, 0)\n    0.0\n\n    \"\"\"\n    return jnyn_zeros(n, nt)[1]\n\n\ndef yn_zeros(n, nt):\n    r\"\"\"Compute zeros of integer-order Bessel function Yn(x).\n\n    Compute `nt` zeros of the functions :math:`Y_n(x)` on the interval\n    :math:`(0, \\infty)`. The zeros are returned in ascending order.\n\n    Parameters\n    ----------\n    n : int\n        Order of Bessel function\n    nt : int\n        Number of zeros to return\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Bessel function.\n\n    See Also\n    --------\n    yn, yv\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    Examples\n    --------\n    >>> import scipy.special as sc\n\n    We can check that we are getting approximations of the zeros by\n    evaluating them with `yn`.\n\n    >>> n = 2\n    >>> x = sc.yn_zeros(n, 3)\n    >>> x\n    array([ 3.38424177,  6.79380751, 10.02347798])\n    >>> sc.yn(n, x)\n    array([-1.94289029e-16,  8.32667268e-17, -1.52655666e-16])\n\n    \"\"\"\n    return jnyn_zeros(n, nt)[2]\n\n\ndef ynp_zeros(n, nt):\n    r\"\"\"Compute zeros of integer-order Bessel function derivatives Yn'(x).\n\n    Compute `nt` zeros of the functions :math:`Y_n'(x)` on the\n    interval :math:`(0, \\infty)`. The zeros are returned in ascending\n    order.\n\n    Parameters\n    ----------\n    n : int\n        Order of Bessel function\n    nt : int\n        Number of zeros to return\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Bessel derivative function.\n\n\n    See Also\n    --------\n    yvp\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    Examples\n    --------\n    >>> import scipy.special as sc\n\n    We can check that we are getting approximations of the zeros by\n    evaluating them with `yvp`.\n\n    >>> n = 2\n    >>> x = sc.ynp_zeros(n, 3)\n    >>> x\n    array([ 5.00258293,  8.3507247 , 11.57419547])\n    >>> sc.yvp(n, x)\n    array([ 2.22044605e-16, -3.33066907e-16,  2.94902991e-16])\n\n    \"\"\"\n    return jnyn_zeros(n, nt)[3]\n\n\ndef y0_zeros(nt, complex=False):\n    \"\"\"Compute nt zeros of Bessel function Y0(z), and derivative at each zero.\n\n    The derivatives are given by Y0'(z0) = -Y1(z0) at each zero z0.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to return\n    complex : bool, default False\n        Set to False to return only the real zeros; set to True to return only\n        the complex zeros with negative real part and positive imaginary part.\n        Note that the complex conjugates of the latter are also zeros of the\n        function, but are not returned by this routine.\n\n    Returns\n    -------\n    z0n : ndarray\n        Location of nth zero of Y0(z)\n    y0pz0n : ndarray\n        Value of derivative Y0'(z0) for nth zero\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"Arguments must be scalar positive integer.\")\n    kf = 0\n    kc = not complex\n    return _specfun.cyzo(nt, kf, kc)\n\n\ndef y1_zeros(nt, complex=False):\n    \"\"\"Compute nt zeros of Bessel function Y1(z), and derivative at each zero.\n\n    The derivatives are given by Y1'(z1) = Y0(z1) at each zero z1.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to return\n    complex : bool, default False\n        Set to False to return only the real zeros; set to True to return only\n        the complex zeros with negative real part and positive imaginary part.\n        Note that the complex conjugates of the latter are also zeros of the\n        function, but are not returned by this routine.\n\n    Returns\n    -------\n    z1n : ndarray\n        Location of nth zero of Y1(z)\n    y1pz1n : ndarray\n        Value of derivative Y1'(z1) for nth zero\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"Arguments must be scalar positive integer.\")\n    kf = 1\n    kc = not complex\n    return _specfun.cyzo(nt, kf, kc)\n\n\ndef y1p_zeros(nt, complex=False):\n    \"\"\"Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.\n\n    The values are given by Y1(z1) at each z1 where Y1'(z1)=0.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to return\n    complex : bool, default False\n        Set to False to return only the real zeros; set to True to return only\n        the complex zeros with negative real part and positive imaginary part.\n        Note that the complex conjugates of the latter are also zeros of the\n        function, but are not returned by this routine.\n\n    Returns\n    -------\n    z1pn : ndarray\n        Location of nth zero of Y1'(z)\n    y1z1pn : ndarray\n        Value of derivative Y1(z1) for nth zero\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"Arguments must be scalar positive integer.\")\n    kf = 2\n    kc = not complex\n    return _specfun.cyzo(nt, kf, kc)\n\n\ndef _bessel_diff_formula(v, z, n, L, phase):\n    # from AMS55.\n    # L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1\n    # L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1\n    # For K, you can pull out the exp((v-k)*pi*i) into the caller\n    v = asarray(v)\n    p = 1.0\n    s = L(v-n, z)\n    for i in range(1, n+1):\n        p = phase * (p * (n-i+1)) / i   # = choose(k, i)\n        s += p*L(v-n + i*2, z)\n    return s / (2.**n)\n\n\ndef jvp(v, z, n=1):\n    \"\"\"Compute derivatives of Bessel functions of the first kind.\n\n    Compute the nth derivative of the Bessel function `Jv` with\n    respect to `z`.\n\n    Parameters\n    ----------\n    v : float\n        Order of Bessel function\n    z : complex\n        Argument at which to evaluate the derivative; can be real or\n        complex.\n    n : int, default 1\n        Order of derivative\n\n    Returns\n    -------\n    scalar or ndarray\n        Values of the derivative of the Bessel function.\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.6.7 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.6.E7\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return jv(v, z)\n    else:\n        return _bessel_diff_formula(v, z, n, jv, -1)\n\n\ndef yvp(v, z, n=1):\n    \"\"\"Compute derivatives of Bessel functions of the second kind.\n\n    Compute the nth derivative of the Bessel function `Yv` with\n    respect to `z`.\n\n    Parameters\n    ----------\n    v : float\n        Order of Bessel function\n    z : complex\n        Argument at which to evaluate the derivative\n    n : int, default 1\n        Order of derivative\n\n    Returns\n    -------\n    scalar or ndarray\n        nth derivative of the Bessel function.\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.6.7 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.6.E7\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return yv(v, z)\n    else:\n        return _bessel_diff_formula(v, z, n, yv, -1)\n\n\ndef kvp(v, z, n=1):\n    \"\"\"Compute nth derivative of real-order modified Bessel function Kv(z)\n\n    Kv(z) is the modified Bessel function of the second kind.\n    Derivative is calculated with respect to `z`.\n\n    Parameters\n    ----------\n    v : array_like of float\n        Order of Bessel function\n    z : array_like of complex\n        Argument at which to evaluate the derivative\n    n : int\n        Order of derivative.  Default is first derivative.\n\n    Returns\n    -------\n    out : ndarray\n        The results\n\n    Examples\n    --------\n    Calculate multiple values at order 5:\n\n    >>> from scipy.special import kvp\n    >>> kvp(5, (1, 2, 3+5j))\n    array([-1.84903536e+03+0.j        , -2.57735387e+01+0.j        ,\n           -3.06627741e-02+0.08750845j])\n\n\n    Calculate for a single value at multiple orders:\n\n    >>> kvp((4, 4.5, 5), 1)\n    array([ -184.0309,  -568.9585, -1849.0354])\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.29.5 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 6.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.29.E5\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return kv(v, z)\n    else:\n        return (-1)**n * _bessel_diff_formula(v, z, n, kv, 1)\n\n\ndef ivp(v, z, n=1):\n    \"\"\"Compute derivatives of modified Bessel functions of the first kind.\n\n    Compute the nth derivative of the modified Bessel function `Iv`\n    with respect to `z`.\n\n    Parameters\n    ----------\n    v : array_like\n        Order of Bessel function\n    z : array_like\n        Argument at which to evaluate the derivative; can be real or\n        complex.\n    n : int, default 1\n        Order of derivative\n\n    Returns\n    -------\n    scalar or ndarray\n        nth derivative of the modified Bessel function.\n\n    See Also\n    --------\n    iv\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.29.5 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 6.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.29.E5\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return iv(v, z)\n    else:\n        return _bessel_diff_formula(v, z, n, iv, 1)\n\n\ndef h1vp(v, z, n=1):\n    \"\"\"Compute nth derivative of Hankel function H1v(z) with respect to `z`.\n\n    Parameters\n    ----------\n    v : array_like\n        Order of Hankel function\n    z : array_like\n        Argument at which to evaluate the derivative. Can be real or\n        complex.\n    n : int, default 1\n        Order of derivative\n\n    Returns\n    -------\n    scalar or ndarray\n        Values of the derivative of the Hankel function.\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.6.7 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.6.E7\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return hankel1(v, z)\n    else:\n        return _bessel_diff_formula(v, z, n, hankel1, -1)\n\n\ndef h2vp(v, z, n=1):\n    \"\"\"Compute nth derivative of Hankel function H2v(z) with respect to `z`.\n\n    Parameters\n    ----------\n    v : array_like\n        Order of Hankel function\n    z : array_like\n        Argument at which to evaluate the derivative. Can be real or\n        complex.\n    n : int, default 1\n        Order of derivative\n\n    Returns\n    -------\n    scalar or ndarray\n        Values of the derivative of the Hankel function.\n\n    Notes\n    -----\n    The derivative is computed using the relation DLFM 10.6.7 [2]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 5.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.6.E7\n\n    \"\"\"\n    n = _nonneg_int_or_fail(n, 'n')\n    if n == 0:\n        return hankel2(v, z)\n    else:\n        return _bessel_diff_formula(v, z, n, hankel2, -1)\n\n\ndef riccati_jn(n, x):\n    r\"\"\"Compute Ricatti-Bessel function of the first kind and its derivative.\n\n    The Ricatti-Bessel function of the first kind is defined as :math:`x\n    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first\n    kind of order :math:`n`.\n\n    This function computes the value and first derivative of the\n    Ricatti-Bessel function for all orders up to and including `n`.\n\n    Parameters\n    ----------\n    n : int\n        Maximum order of function to compute\n    x : float\n        Argument at which to evaluate\n\n    Returns\n    -------\n    jn : ndarray\n        Value of j0(x), ..., jn(x)\n    jnp : ndarray\n        First derivative j0'(x), ..., jn'(x)\n\n    Notes\n    -----\n    The computation is carried out via backward recurrence, using the\n    relation DLMF 10.51.1 [2]_.\n\n    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n    Jin [1]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.51.E1\n\n    \"\"\"\n    if not (isscalar(n) and isscalar(x)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = _nonneg_int_or_fail(n, 'n', strict=False)\n    if (n == 0):\n        n1 = 1\n    else:\n        n1 = n\n    nm, jn, jnp = _specfun.rctj(n1, x)\n    return jn[:(n+1)], jnp[:(n+1)]\n\n\ndef riccati_yn(n, x):\n    \"\"\"Compute Ricatti-Bessel function of the second kind and its derivative.\n\n    The Ricatti-Bessel function of the second kind is defined as :math:`x\n    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second\n    kind of order :math:`n`.\n\n    This function computes the value and first derivative of the function for\n    all orders up to and including `n`.\n\n    Parameters\n    ----------\n    n : int\n        Maximum order of function to compute\n    x : float\n        Argument at which to evaluate\n\n    Returns\n    -------\n    yn : ndarray\n        Value of y0(x), ..., yn(x)\n    ynp : ndarray\n        First derivative y0'(x), ..., yn'(x)\n\n    Notes\n    -----\n    The computation is carried out via ascending recurrence, using the\n    relation DLMF 10.51.1 [2]_.\n\n    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n    Jin [1]_.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions.\n           https://dlmf.nist.gov/10.51.E1\n\n    \"\"\"\n    if not (isscalar(n) and isscalar(x)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = _nonneg_int_or_fail(n, 'n', strict=False)\n    if (n == 0):\n        n1 = 1\n    else:\n        n1 = n\n    nm, jn, jnp = _specfun.rcty(n1, x)\n    return jn[:(n+1)], jnp[:(n+1)]\n\n\ndef erf_zeros(nt):\n    \"\"\"Compute the first nt zero in the first quadrant, ordered by absolute value.\n\n    Zeros in the other quadrants can be obtained by using the symmetries erf(-z) = erf(z) and\n    erf(conj(z)) = conj(erf(z)).\n\n\n    Parameters\n    ----------\n    nt : int\n        The number of zeros to compute\n\n    Returns\n    -------\n    The locations of the zeros of erf : ndarray (complex)\n        Complex values at which zeros of erf(z)\n\n    Examples\n    --------\n    >>> from scipy import special\n    >>> special.erf_zeros(1)\n    array([1.45061616+1.880943j])\n\n    Check that erf is (close to) zero for the value returned by erf_zeros\n\n    >>> special.erf(special.erf_zeros(1))\n    array([4.95159469e-14-1.16407394e-16j])\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):\n        raise ValueError(\"Argument must be positive scalar integer.\")\n    return _specfun.cerzo(nt)\n\n\ndef fresnelc_zeros(nt):\n    \"\"\"Compute nt complex zeros of cosine Fresnel integral C(z).\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):\n        raise ValueError(\"Argument must be positive scalar integer.\")\n    return _specfun.fcszo(1, nt)\n\n\ndef fresnels_zeros(nt):\n    \"\"\"Compute nt complex zeros of sine Fresnel integral S(z).\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):\n        raise ValueError(\"Argument must be positive scalar integer.\")\n    return _specfun.fcszo(2, nt)\n\n\ndef fresnel_zeros(nt):\n    \"\"\"Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):\n        raise ValueError(\"Argument must be positive scalar integer.\")\n    return _specfun.fcszo(2, nt), _specfun.fcszo(1, nt)\n\n\ndef assoc_laguerre(x, n, k=0.0):\n    \"\"\"Compute the generalized (associated) Laguerre polynomial of degree n and order k.\n\n    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``,\n    with weighting function ``exp(-x) * x**k`` with ``k > -1``.\n\n    Notes\n    -----\n    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with\n    reversed argument order ``(x, n, k=0.0) --> (n, k, x)``.\n\n    \"\"\"\n    return _ufuncs.eval_genlaguerre(n, k, x)\n\n\ndigamma = psi\n\n\ndef polygamma(n, x):\n    r\"\"\"Polygamma functions.\n\n    Defined as :math:`\\psi^{(n)}(x)` where :math:`\\psi` is the\n    `digamma` function. See [dlmf]_ for details.\n\n    Parameters\n    ----------\n    n : array_like\n        The order of the derivative of the digamma function; must be\n        integral\n    x : array_like\n        Real valued input\n\n    Returns\n    -------\n    ndarray\n        Function results\n\n    See Also\n    --------\n    digamma\n\n    References\n    ----------\n    .. [dlmf] NIST, Digital Library of Mathematical Functions,\n        https://dlmf.nist.gov/5.15\n\n    Examples\n    --------\n    >>> from scipy import special\n    >>> x = [2, 3, 25.5]\n    >>> special.polygamma(1, x)\n    array([ 0.64493407,  0.39493407,  0.03999467])\n    >>> special.polygamma(0, x) == special.psi(x)\n    array([ True,  True,  True], dtype=bool)\n\n    \"\"\"\n    n, x = asarray(n), asarray(x)\n    fac2 = (-1.0)**(n+1) * gamma(n+1.0) * zeta(n+1, x)\n    return where(n == 0, psi(x), fac2)\n\n\ndef mathieu_even_coef(m, q):\n    r\"\"\"Fourier coefficients for even Mathieu and modified Mathieu functions.\n\n    The Fourier series of the even solutions of the Mathieu differential\n    equation are of the form\n\n    .. math:: \\mathrm{ce}_{2n}(z, q) = \\sum_{k=0}^{\\infty} A_{(2n)}^{(2k)} \\cos 2kz\n\n    .. math:: \\mathrm{ce}_{2n+1}(z, q) = \\sum_{k=0}^{\\infty} A_{(2n+1)}^{(2k+1)} \\cos (2k+1)z\n\n    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even\n    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input\n    m=2n+1.\n\n    Parameters\n    ----------\n    m : int\n        Order of Mathieu functions.  Must be non-negative.\n    q : float (>=0)\n        Parameter of Mathieu functions.  Must be non-negative.\n\n    Returns\n    -------\n    Ak : ndarray\n        Even or odd Fourier coefficients, corresponding to even or odd m.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions\n           https://dlmf.nist.gov/28.4#i\n\n    \"\"\"\n    if not (isscalar(m) and isscalar(q)):\n        raise ValueError(\"m and q must be scalars.\")\n    if (q < 0):\n        raise ValueError(\"q >=0\")\n    if (m != floor(m)) or (m < 0):\n        raise ValueError(\"m must be an integer >=0.\")\n\n    if (q <= 1):\n        qm = 7.5 + 56.1*sqrt(q) - 134.7*q + 90.7*sqrt(q)*q\n    else:\n        qm = 17.0 + 3.1*sqrt(q) - .126*q + .0037*sqrt(q)*q\n    km = int(qm + 0.5*m)\n    if km > 251:\n        warnings.warn(\"Too many predicted coefficients.\", RuntimeWarning, 2)\n    kd = 1\n    m = int(floor(m))\n    if m % 2:\n        kd = 2\n\n    a = mathieu_a(m, q)\n    fc = _specfun.fcoef(kd, m, q, a)\n    return fc[:km]\n\n\ndef mathieu_odd_coef(m, q):\n    r\"\"\"Fourier coefficients for even Mathieu and modified Mathieu functions.\n\n    The Fourier series of the odd solutions of the Mathieu differential\n    equation are of the form\n\n    .. math:: \\mathrm{se}_{2n+1}(z, q) = \\sum_{k=0}^{\\infty} B_{(2n+1)}^{(2k+1)} \\sin (2k+1)z\n\n    .. math:: \\mathrm{se}_{2n+2}(z, q) = \\sum_{k=0}^{\\infty} B_{(2n+2)}^{(2k+2)} \\sin (2k+2)z\n\n    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even\n    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd\n    input m=2n+1.\n\n    Parameters\n    ----------\n    m : int\n        Order of Mathieu functions.  Must be non-negative.\n    q : float (>=0)\n        Parameter of Mathieu functions.  Must be non-negative.\n\n    Returns\n    -------\n    Bk : ndarray\n        Even or odd Fourier coefficients, corresponding to even or odd m.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(m) and isscalar(q)):\n        raise ValueError(\"m and q must be scalars.\")\n    if (q < 0):\n        raise ValueError(\"q >=0\")\n    if (m != floor(m)) or (m <= 0):\n        raise ValueError(\"m must be an integer > 0\")\n\n    if (q <= 1):\n        qm = 7.5 + 56.1*sqrt(q) - 134.7*q + 90.7*sqrt(q)*q\n    else:\n        qm = 17.0 + 3.1*sqrt(q) - .126*q + .0037*sqrt(q)*q\n    km = int(qm + 0.5*m)\n    if km > 251:\n        warnings.warn(\"Too many predicted coefficients.\", RuntimeWarning, 2)\n    kd = 4\n    m = int(floor(m))\n    if m % 2:\n        kd = 3\n\n    b = mathieu_b(m, q)\n    fc = _specfun.fcoef(kd, m, q, b)\n    return fc[:km]\n\n\ndef lpmn(m, n, z):\n    \"\"\"Sequence of associated Legendre functions of the first kind.\n\n    Computes the associated Legendre function of the first kind of order m and\n    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``.\n    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and\n    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.\n\n    This function takes a real argument ``z``. For complex arguments ``z``\n    use clpmn instead.\n\n    Parameters\n    ----------\n    m : int\n       ``|m| <= n``; the order of the Legendre function.\n    n : int\n       where ``n >= 0``; the degree of the Legendre function.  Often\n       called ``l`` (lower case L) in descriptions of the associated\n       Legendre function\n    z : float\n        Input value.\n\n    Returns\n    -------\n    Pmn_z : (m+1, n+1) array\n       Values for all orders 0..m and degrees 0..n\n    Pmn_d_z : (m+1, n+1) array\n       Derivatives for all orders 0..m and degrees 0..n\n\n    See Also\n    --------\n    clpmn: associated Legendre functions of the first kind for complex z\n\n    Notes\n    -----\n    In the interval (-1, 1), Ferrer's function of the first kind is\n    returned. The phase convention used for the intervals (1, inf)\n    and (-inf, -1) is such that the result is always real.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions\n           https://dlmf.nist.gov/14.3\n\n    \"\"\"\n    if not isscalar(m) or (abs(m) > n):\n        raise ValueError(\"m must be <= n.\")\n    if not isscalar(n) or (n < 0):\n        raise ValueError(\"n must be a non-negative integer.\")\n    if not isscalar(z):\n        raise ValueError(\"z must be scalar.\")\n    if iscomplex(z):\n        raise ValueError(\"Argument must be real. Use clpmn instead.\")\n    if (m < 0):\n        mp = -m\n        mf, nf = mgrid[0:mp+1, 0:n+1]\n        with _ufuncs.errstate(all='ignore'):\n            if abs(z) < 1:\n                # Ferrer function; DLMF 14.9.3\n                fixarr = where(mf > nf, 0.0,\n                               (-1)**mf * gamma(nf-mf+1) / gamma(nf+mf+1))\n            else:\n                # Match to clpmn; DLMF 14.9.13\n                fixarr = where(mf > nf, 0.0, gamma(nf-mf+1) / gamma(nf+mf+1))\n    else:\n        mp = m\n    p, pd = _specfun.lpmn(mp, n, z)\n    if (m < 0):\n        p = p * fixarr\n        pd = pd * fixarr\n    return p, pd\n\n\ndef clpmn(m, n, z, type=3):\n    \"\"\"Associated Legendre function of the first kind for complex arguments.\n\n    Computes the associated Legendre function of the first kind of order m and\n    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``.\n    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and\n    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.\n\n    Parameters\n    ----------\n    m : int\n       ``|m| <= n``; the order of the Legendre function.\n    n : int\n       where ``n >= 0``; the degree of the Legendre function.  Often\n       called ``l`` (lower case L) in descriptions of the associated\n       Legendre function\n    z : float or complex\n        Input value.\n    type : int, optional\n       takes values 2 or 3\n       2: cut on the real axis ``|x| > 1``\n       3: cut on the real axis ``-1 < x < 1`` (default)\n\n    Returns\n    -------\n    Pmn_z : (m+1, n+1) array\n       Values for all orders ``0..m`` and degrees ``0..n``\n    Pmn_d_z : (m+1, n+1) array\n       Derivatives for all orders ``0..m`` and degrees ``0..n``\n\n    See Also\n    --------\n    lpmn: associated Legendre functions of the first kind for real z\n\n    Notes\n    -----\n    By default, i.e. for ``type=3``, phase conventions are chosen according\n    to [1]_ such that the function is analytic. The cut lies on the interval\n    (-1, 1). Approaching the cut from above or below in general yields a phase\n    factor with respect to Ferrer's function of the first kind\n    (cf. `lpmn`).\n\n    For ``type=2`` a cut at ``|x| > 1`` is chosen. Approaching the real values\n    on the interval (-1, 1) in the complex plane yields Ferrer's function\n    of the first kind.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] NIST Digital Library of Mathematical Functions\n           https://dlmf.nist.gov/14.21\n\n    \"\"\"\n    if not isscalar(m) or (abs(m) > n):\n        raise ValueError(\"m must be <= n.\")\n    if not isscalar(n) or (n < 0):\n        raise ValueError(\"n must be a non-negative integer.\")\n    if not isscalar(z):\n        raise ValueError(\"z must be scalar.\")\n    if not(type == 2 or type == 3):\n        raise ValueError(\"type must be either 2 or 3.\")\n    if (m < 0):\n        mp = -m\n        mf, nf = mgrid[0:mp+1, 0:n+1]\n        with _ufuncs.errstate(all='ignore'):\n            if type == 2:\n                fixarr = where(mf > nf, 0.0,\n                               (-1)**mf * gamma(nf-mf+1) / gamma(nf+mf+1))\n            else:\n                fixarr = where(mf > nf, 0.0, gamma(nf-mf+1) / gamma(nf+mf+1))\n    else:\n        mp = m\n    p, pd = _specfun.clpmn(mp, n, real(z), imag(z), type)\n    if (m < 0):\n        p = p * fixarr\n        pd = pd * fixarr\n    return p, pd\n\n\ndef lqmn(m, n, z):\n    \"\"\"Sequence of associated Legendre functions of the second kind.\n\n    Computes the associated Legendre function of the second kind of order m and\n    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn'(z)``.\n    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and\n    ``Qmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.\n\n    Parameters\n    ----------\n    m : int\n       ``|m| <= n``; the order of the Legendre function.\n    n : int\n       where ``n >= 0``; the degree of the Legendre function.  Often\n       called ``l`` (lower case L) in descriptions of the associated\n       Legendre function\n    z : complex\n        Input value.\n\n    Returns\n    -------\n    Qmn_z : (m+1, n+1) array\n       Values for all orders 0..m and degrees 0..n\n    Qmn_d_z : (m+1, n+1) array\n       Derivatives for all orders 0..m and degrees 0..n\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(m) or (m < 0):\n        raise ValueError(\"m must be a non-negative integer.\")\n    if not isscalar(n) or (n < 0):\n        raise ValueError(\"n must be a non-negative integer.\")\n    if not isscalar(z):\n        raise ValueError(\"z must be scalar.\")\n    m = int(m)\n    n = int(n)\n\n    # Ensure neither m nor n == 0\n    mm = max(1, m)\n    nn = max(1, n)\n\n    if iscomplex(z):\n        q, qd = _specfun.clqmn(mm, nn, z)\n    else:\n        q, qd = _specfun.lqmn(mm, nn, z)\n    return q[:(m+1), :(n+1)], qd[:(m+1), :(n+1)]\n\n\ndef bernoulli(n):\n    \"\"\"Bernoulli numbers B0..Bn (inclusive).\n\n    Parameters\n    ----------\n    n : int\n        Indicated the number of terms in the Bernoulli series to generate.\n\n    Returns\n    -------\n    ndarray\n        The Bernoulli numbers ``[B(0), B(1), ..., B(n)]``.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] \"Bernoulli number\", Wikipedia, https://en.wikipedia.org/wiki/Bernoulli_number\n\n    Examples\n    --------\n    >>> from scipy.special import bernoulli, zeta\n    >>> bernoulli(4)\n    array([ 1.        , -0.5       ,  0.16666667,  0.        , -0.03333333])\n\n    The Wikipedia article ([2]_) points out the relationship between the\n    Bernoulli numbers and the zeta function, ``B_n^+ = -n * zeta(1 - n)``\n    for ``n > 0``:\n\n    >>> n = np.arange(1, 5)\n    >>> -n * zeta(1 - n)\n    array([ 0.5       ,  0.16666667, -0.        , -0.03333333])\n\n    Note that, in the notation used in the wikipedia article,\n    `bernoulli` computes ``B_n^-`` (i.e. it used the convention that\n    ``B_1`` is -1/2).  The relation given above is for ``B_n^+``, so the\n    sign of 0.5 does not match the output of ``bernoulli(4)``.\n\n    \"\"\"\n    if not isscalar(n) or (n < 0):\n        raise ValueError(\"n must be a non-negative integer.\")\n    n = int(n)\n    if (n < 2):\n        n1 = 2\n    else:\n        n1 = n\n    return _specfun.bernob(int(n1))[:(n+1)]\n\n\ndef euler(n):\n    \"\"\"Euler numbers E(0), E(1), ..., E(n).\n\n    The Euler numbers [1]_ are also known as the secant numbers.\n\n    Because ``euler(n)`` returns floating point values, it does not give\n    exact values for large `n`.  The first inexact value is E(22).\n\n    Parameters\n    ----------\n    n : int\n        The highest index of the Euler number to be returned.\n\n    Returns\n    -------\n    ndarray\n        The Euler numbers [E(0), E(1), ..., E(n)].\n        The odd Euler numbers, which are all zero, are included.\n\n    References\n    ----------\n    .. [1] Sequence A122045, The On-Line Encyclopedia of Integer Sequences,\n           https://oeis.org/A122045\n    .. [2] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    Examples\n    --------\n    >>> from scipy.special import euler\n    >>> euler(6)\n    array([  1.,   0.,  -1.,   0.,   5.,   0., -61.])\n\n    >>> euler(13).astype(np.int64)\n    array([      1,       0,      -1,       0,       5,       0,     -61,\n                 0,    1385,       0,  -50521,       0, 2702765,       0])\n\n    >>> euler(22)[-1]  # Exact value of E(22) is -69348874393137901.\n    -69348874393137976.0\n\n    \"\"\"\n    if not isscalar(n) or (n < 0):\n        raise ValueError(\"n must be a non-negative integer.\")\n    n = int(n)\n    if (n < 2):\n        n1 = 2\n    else:\n        n1 = n\n    return _specfun.eulerb(n1)[:(n+1)]\n\n\ndef lpn(n, z):\n    \"\"\"Legendre function of the first kind.\n\n    Compute sequence of Legendre functions of the first kind (polynomials),\n    Pn(z) and derivatives for all degrees from 0 to n (inclusive).\n\n    See also special.legendre for polynomial class.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(n) and isscalar(z)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = _nonneg_int_or_fail(n, 'n', strict=False)\n    if (n < 1):\n        n1 = 1\n    else:\n        n1 = n\n    if iscomplex(z):\n        pn, pd = _specfun.clpn(n1, z)\n    else:\n        pn, pd = _specfun.lpn(n1, z)\n    return pn[:(n+1)], pd[:(n+1)]\n\n\ndef lqn(n, z):\n    \"\"\"Legendre function of the second kind.\n\n    Compute sequence of Legendre functions of the second kind, Qn(z) and\n    derivatives for all degrees from 0 to n (inclusive).\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(n) and isscalar(z)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = _nonneg_int_or_fail(n, 'n', strict=False)\n    if (n < 1):\n        n1 = 1\n    else:\n        n1 = n\n    if iscomplex(z):\n        qn, qd = _specfun.clqn(n1, z)\n    else:\n        qn, qd = _specfun.lqnb(n1, z)\n    return qn[:(n+1)], qd[:(n+1)]\n\n\ndef ai_zeros(nt):\n    \"\"\"\n    Compute `nt` zeros and values of the Airy function Ai and its derivative.\n\n    Computes the first `nt` zeros, `a`, of the Airy function Ai(x);\n    first `nt` zeros, `ap`, of the derivative of the Airy function Ai'(x);\n    the corresponding values Ai(a');\n    and the corresponding values Ai'(a).\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute\n\n    Returns\n    -------\n    a : ndarray\n        First `nt` zeros of Ai(x)\n    ap : ndarray\n        First `nt` zeros of Ai'(x)\n    ai : ndarray\n        Values of Ai(x) evaluated at first `nt` zeros of Ai'(x)\n    aip : ndarray\n        Values of Ai'(x) evaluated at first `nt` zeros of Ai(x)\n\n    Examples\n    --------\n    >>> from scipy import special\n    >>> a, ap, ai, aip = special.ai_zeros(3)\n    >>> a\n    array([-2.33810741, -4.08794944, -5.52055983])\n    >>> ap\n    array([-1.01879297, -3.24819758, -4.82009921])\n    >>> ai\n    array([ 0.53565666, -0.41901548,  0.38040647])\n    >>> aip\n    array([ 0.70121082, -0.80311137,  0.86520403])\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    kf = 1\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be a positive integer scalar.\")\n    return _specfun.airyzo(nt, kf)\n\n\ndef bi_zeros(nt):\n    \"\"\"\n    Compute `nt` zeros and values of the Airy function Bi and its derivative.\n\n    Computes the first `nt` zeros, b, of the Airy function Bi(x);\n    first `nt` zeros, b', of the derivative of the Airy function Bi'(x);\n    the corresponding values Bi(b');\n    and the corresponding values Bi'(b).\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute\n\n    Returns\n    -------\n    b : ndarray\n        First `nt` zeros of Bi(x)\n    bp : ndarray\n        First `nt` zeros of Bi'(x)\n    bi : ndarray\n        Values of Bi(x) evaluated at first `nt` zeros of Bi'(x)\n    bip : ndarray\n        Values of Bi'(x) evaluated at first `nt` zeros of Bi(x)\n\n    Examples\n    --------\n    >>> from scipy import special\n    >>> b, bp, bi, bip = special.bi_zeros(3)\n    >>> b\n    array([-1.17371322, -3.2710933 , -4.83073784])\n    >>> bp\n    array([-2.29443968, -4.07315509, -5.51239573])\n    >>> bi\n    array([-0.45494438,  0.39652284, -0.36796916])\n    >>> bip\n    array([ 0.60195789, -0.76031014,  0.83699101])\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    kf = 2\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be a positive integer scalar.\")\n    return _specfun.airyzo(nt, kf)\n\n\ndef lmbda(v, x):\n    r\"\"\"Jahnke-Emden Lambda function, Lambdav(x).\n\n    This function is defined as [2]_,\n\n    .. math:: \\Lambda_v(x) = \\Gamma(v+1) \\frac{J_v(x)}{(x/2)^v},\n\n    where :math:`\\Gamma` is the gamma function and :math:`J_v` is the\n    Bessel function of the first kind.\n\n    Parameters\n    ----------\n    v : float\n        Order of the Lambda function\n    x : float\n        Value at which to evaluate the function and derivatives\n\n    Returns\n    -------\n    vl : ndarray\n        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n    dl : ndarray\n        Derivatives Lambda_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n    .. [2] Jahnke, E. and Emde, F. \"Tables of Functions with Formulae and\n           Curves\" (4th ed.), Dover, 1945\n    \"\"\"\n    if not (isscalar(v) and isscalar(x)):\n        raise ValueError(\"arguments must be scalars.\")\n    if (v < 0):\n        raise ValueError(\"argument must be > 0.\")\n    n = int(v)\n    v0 = v - n\n    if (n < 1):\n        n1 = 1\n    else:\n        n1 = n\n    v1 = n1 + v0\n    if (v != floor(v)):\n        vm, vl, dl = _specfun.lamv(v1, x)\n    else:\n        vm, vl, dl = _specfun.lamn(v1, x)\n    return vl[:(n+1)], dl[:(n+1)]\n\n\ndef pbdv_seq(v, x):\n    \"\"\"Parabolic cylinder functions Dv(x) and derivatives.\n\n    Parameters\n    ----------\n    v : float\n        Order of the parabolic cylinder function\n    x : float\n        Value at which to evaluate the function and derivatives\n\n    Returns\n    -------\n    dv : ndarray\n        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n    dp : ndarray\n        Derivatives D_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 13.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(v) and isscalar(x)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = int(v)\n    v0 = v-n\n    if (n < 1):\n        n1 = 1\n    else:\n        n1 = n\n    v1 = n1 + v0\n    dv, dp, pdf, pdd = _specfun.pbdv(v1, x)\n    return dv[:n1+1], dp[:n1+1]\n\n\ndef pbvv_seq(v, x):\n    \"\"\"Parabolic cylinder functions Vv(x) and derivatives.\n\n    Parameters\n    ----------\n    v : float\n        Order of the parabolic cylinder function\n    x : float\n        Value at which to evaluate the function and derivatives\n\n    Returns\n    -------\n    dv : ndarray\n        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n    dp : ndarray\n        Derivatives V_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 13.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(v) and isscalar(x)):\n        raise ValueError(\"arguments must be scalars.\")\n    n = int(v)\n    v0 = v-n\n    if (n <= 1):\n        n1 = 1\n    else:\n        n1 = n\n    v1 = n1 + v0\n    dv, dp, pdf, pdd = _specfun.pbvv(v1, x)\n    return dv[:n1+1], dp[:n1+1]\n\n\ndef pbdn_seq(n, z):\n    \"\"\"Parabolic cylinder functions Dn(z) and derivatives.\n\n    Parameters\n    ----------\n    n : int\n        Order of the parabolic cylinder function\n    z : complex\n        Value at which to evaluate the function and derivatives\n\n    Returns\n    -------\n    dv : ndarray\n        Values of D_i(z), for i=0, ..., i=n.\n    dp : ndarray\n        Derivatives D_i'(z), for i=0, ..., i=n.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996, chapter 13.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(n) and isscalar(z)):\n        raise ValueError(\"arguments must be scalars.\")\n    if (floor(n) != n):\n        raise ValueError(\"n must be an integer.\")\n    if (abs(n) <= 1):\n        n1 = 1\n    else:\n        n1 = n\n    cpb, cpd = _specfun.cpbdn(n1, z)\n    return cpb[:n1+1], cpd[:n1+1]\n\n\ndef ber_zeros(nt):\n    \"\"\"Compute nt zeros of the Kelvin function ber.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Kelvin function.\n\n    See Also\n    --------\n    ber\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 1)\n\n\ndef bei_zeros(nt):\n    \"\"\"Compute nt zeros of the Kelvin function bei.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Kelvin function.\n\n    See Also\n    --------\n    bei\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 2)\n\n\ndef ker_zeros(nt):\n    \"\"\"Compute nt zeros of the Kelvin function ker.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Kelvin function.\n\n    See Also\n    --------\n    ker\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 3)\n\n\ndef kei_zeros(nt):\n    \"\"\"Compute nt zeros of the Kelvin function kei.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the Kelvin function.\n\n    See Also\n    --------\n    kei\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 4)\n\n\ndef berp_zeros(nt):\n    \"\"\"Compute nt zeros of the derivative of the Kelvin function ber.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the derivative of the Kelvin function.\n\n    See Also\n    --------\n    ber, berp\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 5)\n\n\ndef beip_zeros(nt):\n    \"\"\"Compute nt zeros of the derivative of the Kelvin function bei.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the derivative of the Kelvin function.\n\n    See Also\n    --------\n    bei, beip\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 6)\n\n\ndef kerp_zeros(nt):\n    \"\"\"Compute nt zeros of the derivative of the Kelvin function ker.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the derivative of the Kelvin function.\n\n    See Also\n    --------\n    ker, kerp\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 7)\n\n\ndef keip_zeros(nt):\n    \"\"\"Compute nt zeros of the derivative of the Kelvin function kei.\n\n    Parameters\n    ----------\n    nt : int\n        Number of zeros to compute. Must be positive.\n\n    Returns\n    -------\n    ndarray\n        First `nt` zeros of the derivative of the Kelvin function.\n\n    See Also\n    --------\n    kei, keip\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return _specfun.klvnzo(nt, 8)\n\n\ndef kelvin_zeros(nt):\n    \"\"\"Compute nt zeros of all Kelvin functions.\n\n    Returned in a length-8 tuple of arrays of length nt.  The tuple contains\n    the arrays of zeros of (ber, bei, ker, kei, ber', bei', ker', kei').\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):\n        raise ValueError(\"nt must be positive integer scalar.\")\n    return (_specfun.klvnzo(nt, 1),\n            _specfun.klvnzo(nt, 2),\n            _specfun.klvnzo(nt, 3),\n            _specfun.klvnzo(nt, 4),\n            _specfun.klvnzo(nt, 5),\n            _specfun.klvnzo(nt, 6),\n            _specfun.klvnzo(nt, 7),\n            _specfun.klvnzo(nt, 8))\n\n\ndef pro_cv_seq(m, n, c):\n    \"\"\"Characteristic values for prolate spheroidal wave functions.\n\n    Compute a sequence of characteristic values for the prolate\n    spheroidal wave functions for mode m and n'=m..n and spheroidal\n    parameter c.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(m) and isscalar(n) and isscalar(c)):\n        raise ValueError(\"Arguments must be scalars.\")\n    if (n != floor(n)) or (m != floor(m)):\n        raise ValueError(\"Modes must be integers.\")\n    if (n-m > 199):\n        raise ValueError(\"Difference between n and m is too large.\")\n    maxL = n-m+1\n    return _specfun.segv(m, n, c, 1)[1][:maxL]\n\n\ndef obl_cv_seq(m, n, c):\n    \"\"\"Characteristic values for oblate spheroidal wave functions.\n\n    Compute a sequence of characteristic values for the oblate\n    spheroidal wave functions for mode m and n'=m..n and spheroidal\n    parameter c.\n\n    References\n    ----------\n    .. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n           Functions\", John Wiley and Sons, 1996.\n           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html\n\n    \"\"\"\n    if not (isscalar(m) and isscalar(n) and isscalar(c)):\n        raise ValueError(\"Arguments must be scalars.\")\n    if (n != floor(n)) or (m != floor(m)):\n        raise ValueError(\"Modes must be integers.\")\n    if (n-m > 199):\n        raise ValueError(\"Difference between n and m is too large.\")\n    maxL = n-m+1\n    return _specfun.segv(m, n, c, -1)[1][:maxL]\n\n\ndef comb(N, k, exact=False, repetition=False):\n    \"\"\"The number of combinations of N things taken k at a time.\n\n    This is often expressed as \"N choose k\".\n\n    Parameters\n    ----------\n    N : int, ndarray\n        Number of things.\n    k : int, ndarray\n        Number of elements taken.\n    exact : bool, optional\n        If `exact` is False, then floating point precision is used, otherwise\n        exact long integer is computed.\n    repetition : bool, optional\n        If `repetition` is True, then the number of combinations with\n        repetition is computed.\n\n    Returns\n    -------\n    val : int, float, ndarray\n        The total number of combinations.\n\n    See Also\n    --------\n    binom : Binomial coefficient considered as a function of two real\n            variables.\n\n    Notes\n    -----\n    - Array arguments accepted only for exact=False case.\n    - If N < 0, or k < 0, then 0 is returned.\n    - If k > N and repetition=False, then 0 is returned.\n\n    Examples\n    --------\n    >>> from scipy.special import comb\n    >>> k = np.array([3, 4])\n    >>> n = np.array([10, 10])\n    >>> comb(n, k, exact=False)\n    array([ 120.,  210.])\n    >>> comb(10, 3, exact=True)\n    120\n    >>> comb(10, 3, exact=True, repetition=True)\n    220\n\n    \"\"\"\n    if repetition:\n        return comb(N + k - 1, k, exact)\n    if exact:\n        return _comb_int(N, k)\n    else:\n        k, N = asarray(k), asarray(N)\n        cond = (k <= N) & (N >= 0) & (k >= 0)\n        vals = binom(N, k)\n        if isinstance(vals, np.ndarray):\n            vals[~cond] = 0\n        elif not cond:\n            vals = np.float64(0)\n        return vals\n\n\ndef perm(N, k, exact=False):\n    \"\"\"Permutations of N things taken k at a time, i.e., k-permutations of N.\n\n    It's also known as \"partial permutations\".\n\n    Parameters\n    ----------\n    N : int, ndarray\n        Number of things.\n    k : int, ndarray\n        Number of elements taken.\n    exact : bool, optional\n        If `exact` is False, then floating point precision is used, otherwise\n        exact long integer is computed.\n\n    Returns\n    -------\n    val : int, ndarray\n        The number of k-permutations of N.\n\n    Notes\n    -----\n    - Array arguments accepted only for exact=False case.\n    - If k > N, N < 0, or k < 0, then a 0 is returned.\n\n    Examples\n    --------\n    >>> from scipy.special import perm\n    >>> k = np.array([3, 4])\n    >>> n = np.array([10, 10])\n    >>> perm(n, k)\n    array([  720.,  5040.])\n    >>> perm(10, 3, exact=True)\n    720\n\n    \"\"\"\n    if exact:\n        if (k > N) or (N < 0) or (k < 0):\n            return 0\n        val = 1\n        for i in range(N - k + 1, N + 1):\n            val *= i\n        return val\n    else:\n        k, N = asarray(k), asarray(N)\n        cond = (k <= N) & (N >= 0) & (k >= 0)\n        vals = poch(N - k + 1, k)\n        if isinstance(vals, np.ndarray):\n            vals[~cond] = 0\n        elif not cond:\n            vals = np.float64(0)\n        return vals\n\n\n# https://stackoverflow.com/a/16327037\ndef _range_prod(lo, hi):\n    \"\"\"\n    Product of a range of numbers.\n\n    Returns the product of\n    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi\n    = hi! / (lo-1)!\n\n    Breaks into smaller products first for speed:\n    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9))\n    \"\"\"\n    if lo + 1 < hi:\n        mid = (hi + lo) // 2\n        return _range_prod(lo, mid) * _range_prod(mid + 1, hi)\n    if lo == hi:\n        return lo\n    return lo * hi\n\n\ndef factorial(n, exact=False):\n    \"\"\"\n    The factorial of a number or array of numbers.\n\n    The factorial of non-negative integer `n` is the product of all\n    positive integers less than or equal to `n`::\n\n        n! = n * (n - 1) * (n - 2) * ... * 1\n\n    Parameters\n    ----------\n    n : int or array_like of ints\n        Input values.  If ``n < 0``, the return value is 0.\n    exact : bool, optional\n        If True, calculate the answer exactly using long integer arithmetic.\n        If False, result is approximated in floating point rapidly using the\n        `gamma` function.\n        Default is False.\n\n    Returns\n    -------\n    nf : float or int or ndarray\n        Factorial of `n`, as integer or float depending on `exact`.\n\n    Notes\n    -----\n    For arrays with ``exact=True``, the factorial is computed only once, for\n    the largest input, with each other result computed in the process.\n    The output dtype is increased to ``int64`` or ``object`` if necessary.\n\n    With ``exact=False`` the factorial is approximated using the gamma\n    function:\n\n    .. math:: n! = \\\\Gamma(n+1)\n\n    Examples\n    --------\n    >>> from scipy.special import factorial\n    >>> arr = np.array([3, 4, 5])\n    >>> factorial(arr, exact=False)\n    array([   6.,   24.,  120.])\n    >>> factorial(arr, exact=True)\n    array([  6,  24, 120])\n    >>> factorial(5, exact=True)\n    120\n\n    \"\"\"\n    if exact:\n        if np.ndim(n) == 0:\n            if np.isnan(n):\n                return n\n            return 0 if n < 0 else math.factorial(n)\n        else:\n            n = asarray(n)\n            un = np.unique(n).astype(object)\n\n            # Convert to object array of long ints if np.int_ can't handle size\n            if np.isnan(n).any():\n                dt = float\n            elif un[-1] > 20:\n                dt = object\n            elif un[-1] > 12:\n                dt = np.int64\n            else:\n                dt = np.int_\n\n            out = np.empty_like(n, dtype=dt)\n\n            # Handle invalid/trivial values\n            # Ignore runtime warning when less operator used w/np.nan\n            with np.errstate(all='ignore'):\n                un = un[un > 1]\n                out[n < 2] = 1\n                out[n < 0] = 0\n\n            # Calculate products of each range of numbers\n            if un.size:\n                val = math.factorial(un[0])\n                out[n == un[0]] = val\n                for i in range(len(un) - 1):\n                    prev = un[i] + 1\n                    current = un[i + 1]\n                    val *= _range_prod(prev, current)\n                    out[n == current] = val\n\n            if np.isnan(n).any():\n                out = out.astype(np.float64)\n                out[np.isnan(n)] = n[np.isnan(n)]\n            return out\n    else:\n        out = _ufuncs._factorial(n)\n        return out\n\n\ndef factorial2(n, exact=False):\n    \"\"\"Double factorial.\n\n    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5\n    * 3 * 1``.  It can be approximated numerically as::\n\n      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd\n          = 2**(n/2) * (n/2)!                           n even\n\n    Parameters\n    ----------\n    n : int or array_like\n        Calculate ``n!!``.  Arrays are only supported with `exact` set\n        to False.  If ``n < 0``, the return value is 0 if `exact` is set to\n        False. If `exact` is true then ``n`` can be an odd negative integer.\n    exact : bool, optional\n        The result can be approximated rapidly using the gamma-formula\n        above (default).  If `exact` is set to True, calculate the\n        answer exactly using integer arithmetic.\n\n    Returns\n    -------\n    nff : float or int\n        Double factorial of `n`, as an int or a float depending on\n        `exact`.\n\n    Examples\n    --------\n    >>> from scipy.special import factorial2\n    >>> factorial2(7, exact=False)\n    array(105.00000000000001)\n    >>> factorial2(7, exact=True)\n    105\n    >>> factorial2(-3, exact=True)\n    -1\n\n    \"\"\"\n    if exact:\n        if not isscalar(n):\n            raise ValueError(\"n must be scalar.\")\n        elif n in [0, -1]:\n            val = 1\n        elif n > 0 and isinstance(n, int):\n            val = factorialk(n, 2)\n        elif n < 0 and n % 2 == 1:\n            val = ((-1) ** ((n - 1) / 2) * n) / factorial2(-n, exact=True)\n        else:\n            raise ValueError(\"n must be a positive integer or an odd \"\n                             \"negative integer.\")\n        return val\n    else:\n        n = asarray(n)\n        vals = zeros(n.shape, 'd')\n        cond1 = (n % 2) & (n >= -1)\n        cond2 = (1-(n % 2)) & (n >= -1)\n        oddn = extract(cond1, n)\n        evenn = extract(cond2, n)\n        nd2o = oddn / 2.0\n        nd2e = evenn / 2.0\n        place(vals, cond1, gamma(nd2o + 1) / sqrt(pi) * pow(2.0, nd2o + 0.5))\n        place(vals, cond2, gamma(nd2e + 1) * pow(2.0, nd2e))\n        return vals\n\n\ndef factorialk(n, k, exact=True):\n    \"\"\"Multifactorial of n of order k, n(!!...!).\n\n    This is the multifactorial of n skipping k values.  For example,\n\n      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1\n\n    In particular, for any integer ``n``, we have\n\n      factorialk(n, 1) = factorial(n)\n\n      factorialk(n, 2) = factorial2(n)\n\n    Parameters\n    ----------\n    n : int\n        Calculate multifactorial. If `n` < 0, the return value is 0.\n    k : int\n        Order of multifactorial.\n    exact : bool, optional\n        If exact is set to True, calculate the answer exactly using\n        integer arithmetic.\n\n    Returns\n    -------\n    val : int\n        Multifactorial of `n`.\n\n    Raises\n    ------\n    NotImplementedError\n        Raises when exact is False\n\n    Examples\n    --------\n    >>> from scipy.special import factorialk\n    >>> factorialk(5, 1, exact=True)\n    120\n    >>> factorialk(5, 3, exact=True)\n    10\n\n    \"\"\"\n    if exact:\n        if n < 1-k:\n            return 0\n        if n <= 0:\n            return 1\n        val = 1\n        for j in range(n, 0, -k):\n            val = val*j\n        return val\n    else:\n        raise NotImplementedError\n\n\ndef zeta(x, q=None, out=None):\n    r\"\"\"\n    Riemann or Hurwitz zeta function.\n\n    Parameters\n    ----------\n    x : array_like of float\n        Input data, must be real\n    q : array_like of float, optional\n        Input data, must be real.  Defaults to Riemann zeta.\n    out : ndarray, optional\n        Output array for the computed values.\n\n    Returns\n    -------\n    out : array_like\n        Values of zeta(x).\n\n    Notes\n    -----\n    The two-argument version is the Hurwitz zeta function\n\n    .. math::\n\n        \\zeta(x, q) = \\sum_{k=0}^{\\infty} \\frac{1}{(k + q)^x};\n\n    see [dlmf]_ for details. The Riemann zeta function corresponds to\n    the case when ``q = 1``.\n\n    See Also\n    --------\n    zetac\n\n    References\n    ----------\n    .. [dlmf] NIST, Digital Library of Mathematical Functions,\n        https://dlmf.nist.gov/25.11#i\n\n    Examples\n    --------\n    >>> from scipy.special import zeta, polygamma, factorial\n\n    Some specific values:\n\n    >>> zeta(2), np.pi**2/6\n    (1.6449340668482266, 1.6449340668482264)\n\n    >>> zeta(4), np.pi**4/90\n    (1.0823232337111381, 1.082323233711138)\n\n    Relation to the `polygamma` function:\n\n    >>> m = 3\n    >>> x = 1.25\n    >>> polygamma(m, x)\n    array(2.782144009188397)\n    >>> (-1)**(m+1) * factorial(m) * zeta(m+1, x)\n    2.7821440091883969\n\n    \"\"\"\n    if q is None:\n        return _ufuncs._riemann_zeta(x, out)\n    else:\n        return _ufuncs._zeta(x, q, out)\n"
    },
    {
      "filename": "scipy/special/tests/test_basic.py",
      "content": "# this program corresponds to special.py\n\n### Means test is not done yet\n# E   Means test is giving error (E)\n# F   Means test is failing (F)\n# EF  Means test is giving error and Failing\n#!   Means test is segfaulting\n# 8   Means test runs forever\n\n###  test_besselpoly\n###  test_mathieu_a\n###  test_mathieu_even_coef\n###  test_mathieu_odd_coef\n###  test_modfresnelp\n###  test_modfresnelm\n#    test_pbdv_seq\n###  test_pbvv_seq\n###  test_sph_harm\n\nimport itertools\nimport platform\nimport sys\n\nimport numpy as np\nfrom numpy import (array, isnan, r_, arange, finfo, pi, sin, cos, tan, exp,\n        log, zeros, sqrt, asarray, inf, nan_to_num, real, arctan, float_)\n\nimport pytest\nfrom pytest import raises as assert_raises\nfrom numpy.testing import (assert_equal, assert_almost_equal,\n        assert_array_equal, assert_array_almost_equal, assert_approx_equal,\n        assert_, assert_allclose, assert_array_almost_equal_nulp,\n        suppress_warnings)\n\nfrom scipy import special\nimport scipy.special._ufuncs as cephes\nfrom scipy.special import ellipe, ellipk, ellipkm1\nfrom scipy.special import elliprc, elliprd, elliprf, elliprg, elliprj\nfrom scipy.special import mathieu_odd_coef, mathieu_even_coef\n\nfrom scipy.special._testutils import with_special_errors, \\\n     assert_func_equal, FuncData\n\nimport math\n\n\nclass TestCephes:\n    def test_airy(self):\n        cephes.airy(0)\n\n    def test_airye(self):\n        cephes.airye(0)\n\n    def test_binom(self):\n        n = np.array([0.264, 4, 5.2, 17])\n        k = np.array([2, 0.4, 7, 3.3])\n        nk = np.array(np.broadcast_arrays(n[:,None], k[None,:])\n                      ).reshape(2, -1).T\n        rknown = np.array([[-0.097152, 0.9263051596159367, 0.01858423645695389,\n            -0.007581020651518199],[6, 2.0214389119675666, 0, 2.9827344527963846],\n            [10.92, 2.22993515861399, -0.00585728, 10.468891352063146],\n            [136, 3.5252179590758828, 19448, 1024.5526916174495]])\n        assert_func_equal(cephes.binom, rknown.ravel(), nk, rtol=1e-13)\n\n        # Test branches in implementation\n        np.random.seed(1234)\n        n = np.r_[np.arange(-7, 30), 1000*np.random.rand(30) - 500]\n        k = np.arange(0, 102)\n        nk = np.array(np.broadcast_arrays(n[:,None], k[None,:])\n                      ).reshape(2, -1).T\n\n        assert_func_equal(cephes.binom,\n                          cephes.binom(nk[:,0], nk[:,1] * (1 + 1e-15)),\n                          nk,\n                          atol=1e-10, rtol=1e-10)\n\n    def test_binom_2(self):\n        # Test branches in implementation\n        np.random.seed(1234)\n        n = np.r_[np.logspace(1, 300, 20)]\n        k = np.arange(0, 102)\n        nk = np.array(np.broadcast_arrays(n[:,None], k[None,:])\n                      ).reshape(2, -1).T\n\n        assert_func_equal(cephes.binom,\n                          cephes.binom(nk[:,0], nk[:,1] * (1 + 1e-15)),\n                          nk,\n                          atol=1e-10, rtol=1e-10)\n\n    def test_binom_exact(self):\n        @np.vectorize\n        def binom_int(n, k):\n            n = int(n)\n            k = int(k)\n            num = int(1)\n            den = int(1)\n            for i in range(1, k+1):\n                num *= i + n - k\n                den *= i\n            return float(num/den)\n\n        np.random.seed(1234)\n        n = np.arange(1, 15)\n        k = np.arange(0, 15)\n        nk = np.array(np.broadcast_arrays(n[:,None], k[None,:])\n                      ).reshape(2, -1).T\n        nk = nk[nk[:,0] >= nk[:,1]]\n        assert_func_equal(cephes.binom,\n                          binom_int(nk[:,0], nk[:,1]),\n                          nk,\n                          atol=0, rtol=0)\n\n    def test_binom_nooverflow_8346(self):\n        # Test (binom(n, k) doesn't overflow prematurely */\n        dataset = [\n            (1000, 500, 2.70288240945436551e+299),\n            (1002, 501, 1.08007396880791225e+300),\n            (1004, 502, 4.31599279169058121e+300),\n            (1006, 503, 1.72468101616263781e+301),\n            (1008, 504, 6.89188009236419153e+301),\n            (1010, 505, 2.75402257948335448e+302),\n            (1012, 506, 1.10052048531923757e+303),\n            (1014, 507, 4.39774063758732849e+303),\n            (1016, 508, 1.75736486108312519e+304),\n            (1018, 509, 7.02255427788423734e+304),\n            (1020, 510, 2.80626776829962255e+305),\n            (1022, 511, 1.12140876377061240e+306),\n            (1024, 512, 4.48125455209897109e+306),\n            (1026, 513, 1.79075474304149900e+307),\n            (1028, 514, 7.15605105487789676e+307)\n        ]\n        dataset = np.asarray(dataset)\n        FuncData(cephes.binom, dataset, (0, 1), 2, rtol=1e-12).check()\n\n    def test_bdtr(self):\n        assert_equal(cephes.bdtr(1,1,0.5),1.0)\n\n    def test_bdtri(self):\n        assert_equal(cephes.bdtri(1,3,0.5),0.5)\n\n    def test_bdtrc(self):\n        assert_equal(cephes.bdtrc(1,3,0.5),0.5)\n\n    def test_bdtrin(self):\n        assert_equal(cephes.bdtrin(1,0,1),5.0)\n\n    def test_bdtrik(self):\n        cephes.bdtrik(1,3,0.5)\n\n    def test_bei(self):\n        assert_equal(cephes.bei(0),0.0)\n\n    def test_beip(self):\n        assert_equal(cephes.beip(0),0.0)\n\n    def test_ber(self):\n        assert_equal(cephes.ber(0),1.0)\n\n    def test_berp(self):\n        assert_equal(cephes.berp(0),0.0)\n\n    def test_besselpoly(self):\n        assert_equal(cephes.besselpoly(0,0,0),1.0)\n\n    def test_beta(self):\n        assert_equal(cephes.beta(1,1),1.0)\n        assert_allclose(cephes.beta(-100.3, 1e-200), cephes.gamma(1e-200))\n        assert_allclose(cephes.beta(0.0342, 171), 24.070498359873497,\n                        rtol=1e-13, atol=0)\n\n    def test_betainc(self):\n        assert_equal(cephes.betainc(1,1,1),1.0)\n        assert_allclose(cephes.betainc(0.0342, 171, 1e-10), 0.55269916901806648)\n\n    def test_betaln(self):\n        assert_equal(cephes.betaln(1,1),0.0)\n        assert_allclose(cephes.betaln(-100.3, 1e-200), cephes.gammaln(1e-200))\n        assert_allclose(cephes.betaln(0.0342, 170), 3.1811881124242447,\n                        rtol=1e-14, atol=0)\n\n    def test_betaincinv(self):\n        assert_equal(cephes.betaincinv(1,1,1),1.0)\n        assert_allclose(cephes.betaincinv(0.0342, 171, 0.25),\n                        8.4231316935498957e-21, rtol=3e-12, atol=0)\n\n    def test_beta_inf(self):\n        assert_(np.isinf(special.beta(-1, 2)))\n\n    def test_btdtr(self):\n        assert_equal(cephes.btdtr(1,1,1),1.0)\n\n    def test_btdtri(self):\n        assert_equal(cephes.btdtri(1,1,1),1.0)\n\n    def test_btdtria(self):\n        assert_equal(cephes.btdtria(1,1,1),5.0)\n\n    def test_btdtrib(self):\n        assert_equal(cephes.btdtrib(1,1,1),5.0)\n\n    def test_cbrt(self):\n        assert_approx_equal(cephes.cbrt(1),1.0)\n\n    def test_chdtr(self):\n        assert_equal(cephes.chdtr(1,0),0.0)\n\n    def test_chdtrc(self):\n        assert_equal(cephes.chdtrc(1,0),1.0)\n\n    def test_chdtri(self):\n        assert_equal(cephes.chdtri(1,1),0.0)\n\n    def test_chdtriv(self):\n        assert_equal(cephes.chdtriv(0,0),5.0)\n\n    def test_chndtr(self):\n        assert_equal(cephes.chndtr(0,1,0),0.0)\n\n        # Each row holds (x, nu, lam, expected_value)\n        # These values were computed using Wolfram Alpha with\n        #     CDF[NoncentralChiSquareDistribution[nu, lam], x]\n        values = np.array([\n            [25.00, 20.0, 400, 4.1210655112396197139e-57],\n            [25.00, 8.00, 250, 2.3988026526832425878e-29],\n            [0.001, 8.00, 40., 5.3761806201366039084e-24],\n            [0.010, 8.00, 40., 5.45396231055999457039e-20],\n            [20.00, 2.00, 107, 1.39390743555819597802e-9],\n            [22.50, 2.00, 107, 7.11803307138105870671e-9],\n            [25.00, 2.00, 107, 3.11041244829864897313e-8],\n            [3.000, 2.00, 1.0, 0.62064365321954362734],\n            [350.0, 300., 10., 0.93880128006276407710],\n            [100.0, 13.5, 10., 0.99999999650104210949],\n            [700.0, 20.0, 400, 0.99999999925680650105],\n            [150.0, 13.5, 10., 0.99999999999999983046],\n            [160.0, 13.5, 10., 0.99999999999999999518],  # 1.0\n        ])\n        cdf = cephes.chndtr(values[:, 0], values[:, 1], values[:, 2])\n        assert_allclose(cdf, values[:, 3], rtol=1e-12)\n\n        assert_almost_equal(cephes.chndtr(np.inf, np.inf, 0), 2.0)\n        assert_almost_equal(cephes.chndtr(2, 1, np.inf), 0.0)\n        assert_(np.isnan(cephes.chndtr(np.nan, 1, 2)))\n        assert_(np.isnan(cephes.chndtr(5, np.nan, 2)))\n        assert_(np.isnan(cephes.chndtr(5, 1, np.nan)))\n\n    def test_chndtridf(self):\n        assert_equal(cephes.chndtridf(0,0,1),5.0)\n\n    def test_chndtrinc(self):\n        assert_equal(cephes.chndtrinc(0,1,0),5.0)\n\n    def test_chndtrix(self):\n        assert_equal(cephes.chndtrix(0,1,0),0.0)\n\n    def test_cosdg(self):\n        assert_equal(cephes.cosdg(0),1.0)\n\n    def test_cosm1(self):\n        assert_equal(cephes.cosm1(0),0.0)\n\n    def test_cotdg(self):\n        assert_almost_equal(cephes.cotdg(45),1.0)\n\n    def test_dawsn(self):\n        assert_equal(cephes.dawsn(0),0.0)\n        assert_allclose(cephes.dawsn(1.23), 0.50053727749081767)\n\n    def test_diric(self):\n        # Test behavior near multiples of 2pi.  Regression test for issue\n        # described in gh-4001.\n        n_odd = [1, 5, 25]\n        x = np.array(2*np.pi + 5e-5).astype(np.float32)\n        assert_almost_equal(special.diric(x, n_odd), 1.0, decimal=7)\n        x = np.array(2*np.pi + 1e-9).astype(np.float64)\n        assert_almost_equal(special.diric(x, n_odd), 1.0, decimal=15)\n        x = np.array(2*np.pi + 1e-15).astype(np.float64)\n        assert_almost_equal(special.diric(x, n_odd), 1.0, decimal=15)\n        if hasattr(np, 'float128'):\n            # No float128 available in 32-bit numpy\n            x = np.array(2*np.pi + 1e-12).astype(np.float128)\n            assert_almost_equal(special.diric(x, n_odd), 1.0, decimal=19)\n\n        n_even = [2, 4, 24]\n        x = np.array(2*np.pi + 1e-9).astype(np.float64)\n        assert_almost_equal(special.diric(x, n_even), -1.0, decimal=15)\n\n        # Test at some values not near a multiple of pi\n        x = np.arange(0.2*np.pi, 1.0*np.pi, 0.2*np.pi)\n        octave_result = [0.872677996249965, 0.539344662916632,\n                         0.127322003750035, -0.206011329583298]\n        assert_almost_equal(special.diric(x, 3), octave_result, decimal=15)\n\n    def test_diric_broadcasting(self):\n        x = np.arange(5)\n        n = np.array([1, 3, 7])\n        assert_(special.diric(x[:, np.newaxis], n).shape == (x.size, n.size))\n\n    def test_ellipe(self):\n        assert_equal(cephes.ellipe(1),1.0)\n\n    def test_ellipeinc(self):\n        assert_equal(cephes.ellipeinc(0,1),0.0)\n\n    def test_ellipj(self):\n        cephes.ellipj(0,1)\n\n    def test_ellipk(self):\n        assert_allclose(ellipk(0), pi/2)\n\n    def test_ellipkinc(self):\n        assert_equal(cephes.ellipkinc(0,0),0.0)\n\n    def test_erf(self):\n        assert_equal(cephes.erf(0), 0.0)\n\n    def test_erf_symmetry(self):\n        x = 5.905732037710919\n        assert_equal(cephes.erf(x) + cephes.erf(-x), 0.0)\n\n    def test_erfc(self):\n        assert_equal(cephes.erfc(0), 1.0)\n\n    def test_exp10(self):\n        assert_approx_equal(cephes.exp10(2),100.0)\n\n    def test_exp2(self):\n        assert_equal(cephes.exp2(2),4.0)\n\n    def test_expm1(self):\n        assert_equal(cephes.expm1(0),0.0)\n        assert_equal(cephes.expm1(np.inf), np.inf)\n        assert_equal(cephes.expm1(-np.inf), -1)\n        assert_equal(cephes.expm1(np.nan), np.nan)\n\n    def test_expm1_complex(self):\n        expm1 = cephes.expm1\n        assert_equal(expm1(0 + 0j), 0 + 0j)\n        assert_equal(expm1(complex(np.inf, 0)), complex(np.inf, 0))\n        assert_equal(expm1(complex(np.inf, 1)), complex(np.inf, np.inf))\n        assert_equal(expm1(complex(np.inf, 2)), complex(-np.inf, np.inf))\n        assert_equal(expm1(complex(np.inf, 4)), complex(-np.inf, -np.inf))\n        assert_equal(expm1(complex(np.inf, 5)), complex(np.inf, -np.inf))\n        assert_equal(expm1(complex(1, np.inf)), complex(np.nan, np.nan))\n        assert_equal(expm1(complex(0, np.inf)), complex(np.nan, np.nan))\n        assert_equal(expm1(complex(np.inf, np.inf)), complex(np.inf, np.nan))\n        assert_equal(expm1(complex(-np.inf, np.inf)), complex(-1, 0))\n        assert_equal(expm1(complex(-np.inf, np.nan)), complex(-1, 0))\n        assert_equal(expm1(complex(np.inf, np.nan)), complex(np.inf, np.nan))\n        assert_equal(expm1(complex(0, np.nan)), complex(np.nan, np.nan))\n        assert_equal(expm1(complex(1, np.nan)), complex(np.nan, np.nan))\n        assert_equal(expm1(complex(np.nan, 1)), complex(np.nan, np.nan))\n        assert_equal(expm1(complex(np.nan, np.nan)), complex(np.nan, np.nan))\n\n    @pytest.mark.xfail(reason='The real part of expm1(z) bad at these points')\n    def test_expm1_complex_hard(self):\n        # The real part of this function is difficult to evaluate when\n        # z.real = -log(cos(z.imag)).\n        y = np.array([0.1, 0.2, 0.3, 5, 11, 20])\n        x = -np.log(np.cos(y))\n        z = x + 1j*y\n\n        # evaluate using mpmath.expm1 with dps=1000\n        expected = np.array([-5.5507901846769623e-17+0.10033467208545054j,\n                              2.4289354732893695e-18+0.20271003550867248j,\n                              4.5235500262585768e-17+0.30933624960962319j,\n                              7.8234305217489006e-17-3.3805150062465863j,\n                             -1.3685191953697676e-16-225.95084645419513j,\n                              8.7175620481291045e-17+2.2371609442247422j])\n        found = cephes.expm1(z)\n        # this passes.\n        assert_array_almost_equal_nulp(found.imag, expected.imag, 3)\n        # this fails.\n        assert_array_almost_equal_nulp(found.real, expected.real, 20)\n\n    def test_fdtr(self):\n        assert_equal(cephes.fdtr(1, 1, 0), 0.0)\n        # Computed using Wolfram Alpha: CDF[FRatioDistribution[1e-6, 5], 10]\n        assert_allclose(cephes.fdtr(1e-6, 5, 10), 0.9999940790193488,\n                        rtol=1e-12)\n\n    def test_fdtrc(self):\n        assert_equal(cephes.fdtrc(1, 1, 0), 1.0)\n        # Computed using Wolfram Alpha:\n        #   1 - CDF[FRatioDistribution[2, 1/10], 1e10]\n        assert_allclose(cephes.fdtrc(2, 0.1, 1e10), 0.27223784621293512,\n                        rtol=1e-12)\n\n    def test_fdtri(self):\n        assert_allclose(cephes.fdtri(1, 1, [0.499, 0.501]),\n                        array([0.9937365, 1.00630298]), rtol=1e-6)\n        # From Wolfram Alpha:\n        #   CDF[FRatioDistribution[1/10, 1], 3] = 0.8756751669632105666874...\n        p = 0.8756751669632105666874\n        assert_allclose(cephes.fdtri(0.1, 1, p), 3, rtol=1e-12)\n\n    @pytest.mark.xfail(reason='Returns nan on i686.')\n    def test_fdtri_mysterious_failure(self):\n        assert_allclose(cephes.fdtri(1, 1, 0.5), 1)\n\n    def test_fdtridfd(self):\n        assert_equal(cephes.fdtridfd(1,0,0),5.0)\n\n    def test_fresnel(self):\n        assert_equal(cephes.fresnel(0),(0.0,0.0))\n\n    def test_gamma(self):\n        assert_equal(cephes.gamma(5),24.0)\n\n    def test_gammainccinv(self):\n        assert_equal(cephes.gammainccinv(5,1),0.0)\n\n    def test_gammaln(self):\n        cephes.gammaln(10)\n\n    def test_gammasgn(self):\n        vals = np.array([-4, -3.5, -2.3, 1, 4.2], np.float64)\n        assert_array_equal(cephes.gammasgn(vals), np.sign(cephes.rgamma(vals)))\n\n    def test_gdtr(self):\n        assert_equal(cephes.gdtr(1,1,0),0.0)\n\n    def test_gdtr_inf(self):\n        assert_equal(cephes.gdtr(1,1,np.inf),1.0)\n\n    def test_gdtrc(self):\n        assert_equal(cephes.gdtrc(1,1,0),1.0)\n\n    def test_gdtria(self):\n        assert_equal(cephes.gdtria(0,1,1),0.0)\n\n    def test_gdtrib(self):\n        cephes.gdtrib(1,0,1)\n        # assert_equal(cephes.gdtrib(1,0,1),5.0)\n\n    def test_gdtrix(self):\n        cephes.gdtrix(1,1,.1)\n\n    def test_hankel1(self):\n        cephes.hankel1(1,1)\n\n    def test_hankel1e(self):\n        cephes.hankel1e(1,1)\n\n    def test_hankel2(self):\n        cephes.hankel2(1,1)\n\n    def test_hankel2e(self):\n        cephes.hankel2e(1,1)\n\n    def test_hyp1f1(self):\n        assert_approx_equal(cephes.hyp1f1(1,1,1), exp(1.0))\n        assert_approx_equal(cephes.hyp1f1(3,4,-6), 0.026056422099537251095)\n        cephes.hyp1f1(1,1,1)\n\n    def test_hyp2f1(self):\n        assert_equal(cephes.hyp2f1(1,1,1,0),1.0)\n\n    def test_i0(self):\n        assert_equal(cephes.i0(0),1.0)\n\n    def test_i0e(self):\n        assert_equal(cephes.i0e(0),1.0)\n\n    def test_i1(self):\n        assert_equal(cephes.i1(0),0.0)\n\n    def test_i1e(self):\n        assert_equal(cephes.i1e(0),0.0)\n\n    def test_it2i0k0(self):\n        cephes.it2i0k0(1)\n\n    def test_it2j0y0(self):\n        cephes.it2j0y0(1)\n\n    def test_it2struve0(self):\n        cephes.it2struve0(1)\n\n    def test_itairy(self):\n        cephes.itairy(1)\n\n    def test_iti0k0(self):\n        assert_equal(cephes.iti0k0(0),(0.0,0.0))\n\n    def test_itj0y0(self):\n        assert_equal(cephes.itj0y0(0),(0.0,0.0))\n\n    def test_itmodstruve0(self):\n        assert_equal(cephes.itmodstruve0(0),0.0)\n\n    def test_itstruve0(self):\n        assert_equal(cephes.itstruve0(0),0.0)\n\n    def test_iv(self):\n        assert_equal(cephes.iv(1,0),0.0)\n\n    def _check_ive(self):\n        assert_equal(cephes.ive(1,0),0.0)\n\n    def test_j0(self):\n        assert_equal(cephes.j0(0),1.0)\n\n    def test_j1(self):\n        assert_equal(cephes.j1(0),0.0)\n\n    def test_jn(self):\n        assert_equal(cephes.jn(0,0),1.0)\n\n    def test_jv(self):\n        assert_equal(cephes.jv(0,0),1.0)\n\n    def _check_jve(self):\n        assert_equal(cephes.jve(0,0),1.0)\n\n    def test_k0(self):\n        cephes.k0(2)\n\n    def test_k0e(self):\n        cephes.k0e(2)\n\n    def test_k1(self):\n        cephes.k1(2)\n\n    def test_k1e(self):\n        cephes.k1e(2)\n\n    def test_kei(self):\n        cephes.kei(2)\n\n    def test_keip(self):\n        assert_equal(cephes.keip(0),0.0)\n\n    def test_ker(self):\n        cephes.ker(2)\n\n    def test_kerp(self):\n        cephes.kerp(2)\n\n    def _check_kelvin(self):\n        cephes.kelvin(2)\n\n    def test_kn(self):\n        cephes.kn(1,1)\n\n    def test_kolmogi(self):\n        assert_equal(cephes.kolmogi(1),0.0)\n        assert_(np.isnan(cephes.kolmogi(np.nan)))\n\n    def test_kolmogorov(self):\n        assert_equal(cephes.kolmogorov(0), 1.0)\n\n    def test_kolmogp(self):\n        assert_equal(cephes._kolmogp(0), -0.0)\n\n    def test_kolmogc(self):\n        assert_equal(cephes._kolmogc(0), 0.0)\n\n    def test_kolmogci(self):\n        assert_equal(cephes._kolmogci(0), 0.0)\n        assert_(np.isnan(cephes._kolmogci(np.nan)))\n\n    def _check_kv(self):\n        cephes.kv(1,1)\n\n    def _check_kve(self):\n        cephes.kve(1,1)\n\n    def test_log1p(self):\n        log1p = cephes.log1p\n        assert_equal(log1p(0), 0.0)\n        assert_equal(log1p(-1), -np.inf)\n        assert_equal(log1p(-2), np.nan)\n        assert_equal(log1p(np.inf), np.inf)\n\n    def test_log1p_complex(self):\n        log1p = cephes.log1p\n        c = complex\n        assert_equal(log1p(0 + 0j), 0 + 0j)\n        assert_equal(log1p(c(-1, 0)), c(-np.inf, 0))\n        with suppress_warnings() as sup:\n            sup.filter(RuntimeWarning, \"invalid value encountered in multiply\")\n            assert_allclose(log1p(c(1, np.inf)), c(np.inf, np.pi/2))\n            assert_equal(log1p(c(1, np.nan)), c(np.nan, np.nan))\n            assert_allclose(log1p(c(-np.inf, 1)), c(np.inf, np.pi))\n            assert_equal(log1p(c(np.inf, 1)), c(np.inf, 0))\n            assert_allclose(log1p(c(-np.inf, np.inf)), c(np.inf, 3*np.pi/4))\n            assert_allclose(log1p(c(np.inf, np.inf)), c(np.inf, np.pi/4))\n            assert_equal(log1p(c(np.inf, np.nan)), c(np.inf, np.nan))\n            assert_equal(log1p(c(-np.inf, np.nan)), c(np.inf, np.nan))\n            assert_equal(log1p(c(np.nan, np.inf)), c(np.inf, np.nan))\n            assert_equal(log1p(c(np.nan, 1)), c(np.nan, np.nan))\n            assert_equal(log1p(c(np.nan, np.nan)), c(np.nan, np.nan))\n\n    def test_lpmv(self):\n        assert_equal(cephes.lpmv(0,0,1),1.0)\n\n    def test_mathieu_a(self):\n        assert_equal(cephes.mathieu_a(1,0),1.0)\n\n    def test_mathieu_b(self):\n        assert_equal(cephes.mathieu_b(1,0),1.0)\n\n    def test_mathieu_cem(self):\n        assert_equal(cephes.mathieu_cem(1,0,0),(1.0,0.0))\n\n        # Test AMS 20.2.27\n        @np.vectorize\n        def ce_smallq(m, q, z):\n            z *= np.pi/180\n            if m == 0:\n                return 2**(-0.5) * (1 - .5*q*cos(2*z))  # + O(q^2)\n            elif m == 1:\n                return cos(z) - q/8 * cos(3*z)  # + O(q^2)\n            elif m == 2:\n                return cos(2*z) - q*(cos(4*z)/12 - 1/4)  # + O(q^2)\n            else:\n                return cos(m*z) - q*(cos((m+2)*z)/(4*(m+1)) - cos((m-2)*z)/(4*(m-1)))  # + O(q^2)\n        m = np.arange(0, 100)\n        q = np.r_[0, np.logspace(-30, -9, 10)]\n        assert_allclose(cephes.mathieu_cem(m[:,None], q[None,:], 0.123)[0],\n                        ce_smallq(m[:,None], q[None,:], 0.123),\n                        rtol=1e-14, atol=0)\n\n    def test_mathieu_sem(self):\n        assert_equal(cephes.mathieu_sem(1,0,0),(0.0,1.0))\n\n        # Test AMS 20.2.27\n        @np.vectorize\n        def se_smallq(m, q, z):\n            z *= np.pi/180\n            if m == 1:\n                return sin(z) - q/8 * sin(3*z)  # + O(q^2)\n            elif m == 2:\n                return sin(2*z) - q*sin(4*z)/12  # + O(q^2)\n            else:\n                return sin(m*z) - q*(sin((m+2)*z)/(4*(m+1)) - sin((m-2)*z)/(4*(m-1)))  # + O(q^2)\n        m = np.arange(1, 100)\n        q = np.r_[0, np.logspace(-30, -9, 10)]\n        assert_allclose(cephes.mathieu_sem(m[:,None], q[None,:], 0.123)[0],\n                        se_smallq(m[:,None], q[None,:], 0.123),\n                        rtol=1e-14, atol=0)\n\n    def test_mathieu_modcem1(self):\n        assert_equal(cephes.mathieu_modcem1(1,0,0),(0.0,0.0))\n\n    def test_mathieu_modcem2(self):\n        cephes.mathieu_modcem2(1,1,1)\n\n        # Test reflection relation AMS 20.6.19\n        m = np.arange(0, 4)[:,None,None]\n        q = np.r_[np.logspace(-2, 2, 10)][None,:,None]\n        z = np.linspace(0, 1, 7)[None,None,:]\n\n        y1 = cephes.mathieu_modcem2(m, q, -z)[0]\n\n        fr = -cephes.mathieu_modcem2(m, q, 0)[0] / cephes.mathieu_modcem1(m, q, 0)[0]\n        y2 = -cephes.mathieu_modcem2(m, q, z)[0] - 2*fr*cephes.mathieu_modcem1(m, q, z)[0]\n\n        assert_allclose(y1, y2, rtol=1e-10)\n\n    def test_mathieu_modsem1(self):\n        assert_equal(cephes.mathieu_modsem1(1,0,0),(0.0,0.0))\n\n    def test_mathieu_modsem2(self):\n        cephes.mathieu_modsem2(1,1,1)\n\n        # Test reflection relation AMS 20.6.20\n        m = np.arange(1, 4)[:,None,None]\n        q = np.r_[np.logspace(-2, 2, 10)][None,:,None]\n        z = np.linspace(0, 1, 7)[None,None,:]\n\n        y1 = cephes.mathieu_modsem2(m, q, -z)[0]\n        fr = cephes.mathieu_modsem2(m, q, 0)[1] / cephes.mathieu_modsem1(m, q, 0)[1]\n        y2 = cephes.mathieu_modsem2(m, q, z)[0] - 2*fr*cephes.mathieu_modsem1(m, q, z)[0]\n        assert_allclose(y1, y2, rtol=1e-10)\n\n    def test_mathieu_overflow(self):\n        # Check that these return NaNs instead of causing a SEGV\n        assert_equal(cephes.mathieu_cem(10000, 0, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_sem(10000, 0, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_cem(10000, 1.5, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_sem(10000, 1.5, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_modcem1(10000, 1.5, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_modsem1(10000, 1.5, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_modcem2(10000, 1.5, 1.3), (np.nan, np.nan))\n        assert_equal(cephes.mathieu_modsem2(10000, 1.5, 1.3), (np.nan, np.nan))\n\n    def test_mathieu_ticket_1847(self):\n        # Regression test --- this call had some out-of-bounds access\n        # and could return nan occasionally\n        for k in range(60):\n            v = cephes.mathieu_modsem2(2, 100, -1)\n            # Values from ACM TOMS 804 (derivate by numerical differentiation)\n            assert_allclose(v[0], 0.1431742913063671074347, rtol=1e-10)\n            assert_allclose(v[1], 0.9017807375832909144719, rtol=1e-4)\n\n    def test_modfresnelm(self):\n        cephes.modfresnelm(0)\n\n    def test_modfresnelp(self):\n        cephes.modfresnelp(0)\n\n    def _check_modstruve(self):\n        assert_equal(cephes.modstruve(1,0),0.0)\n\n    def test_nbdtr(self):\n        assert_equal(cephes.nbdtr(1,1,1),1.0)\n\n    def test_nbdtrc(self):\n        assert_equal(cephes.nbdtrc(1,1,1),0.0)\n\n    def test_nbdtri(self):\n        assert_equal(cephes.nbdtri(1,1,1),1.0)\n\n    def __check_nbdtrik(self):\n        cephes.nbdtrik(1,.4,.5)\n\n    def test_nbdtrin(self):\n        assert_equal(cephes.nbdtrin(1,0,0),5.0)\n\n    def test_ncfdtr(self):\n        assert_equal(cephes.ncfdtr(1,1,1,0),0.0)\n\n    def test_ncfdtri(self):\n        assert_equal(cephes.ncfdtri(1, 1, 1, 0), 0.0)\n        f = [0.5, 1, 1.5]\n        p = cephes.ncfdtr(2, 3, 1.5, f)\n        assert_allclose(cephes.ncfdtri(2, 3, 1.5, p), f)\n\n    def test_ncfdtridfd(self):\n        dfd = [1, 2, 3]\n        p = cephes.ncfdtr(2, dfd, 0.25, 15)\n        assert_allclose(cephes.ncfdtridfd(2, p, 0.25, 15), dfd)\n\n    def test_ncfdtridfn(self):\n        dfn = [0.1, 1, 2, 3, 1e4]\n        p = cephes.ncfdtr(dfn, 2, 0.25, 15)\n        assert_allclose(cephes.ncfdtridfn(p, 2, 0.25, 15), dfn, rtol=1e-5)\n\n    def test_ncfdtrinc(self):\n        nc = [0.5, 1.5, 2.0]\n        p = cephes.ncfdtr(2, 3, nc, 15)\n        assert_allclose(cephes.ncfdtrinc(2, 3, p, 15), nc)\n\n    def test_nctdtr(self):\n        assert_equal(cephes.nctdtr(1,0,0),0.5)\n        assert_equal(cephes.nctdtr(9, 65536, 45), 0.0)\n\n        assert_approx_equal(cephes.nctdtr(np.inf, 1., 1.), 0.5, 5)\n        assert_(np.isnan(cephes.nctdtr(2., np.inf, 10.)))\n        assert_approx_equal(cephes.nctdtr(2., 1., np.inf), 1.)\n\n        assert_(np.isnan(cephes.nctdtr(np.nan, 1., 1.)))\n        assert_(np.isnan(cephes.nctdtr(2., np.nan, 1.)))\n        assert_(np.isnan(cephes.nctdtr(2., 1., np.nan)))\n\n    def __check_nctdtridf(self):\n        cephes.nctdtridf(1,0.5,0)\n\n    def test_nctdtrinc(self):\n        cephes.nctdtrinc(1,0,0)\n\n    def test_nctdtrit(self):\n        cephes.nctdtrit(.1,0.2,.5)\n\n    def test_nrdtrimn(self):\n        assert_approx_equal(cephes.nrdtrimn(0.5,1,1),1.0)\n\n    def test_nrdtrisd(self):\n        assert_allclose(cephes.nrdtrisd(0.5,0.5,0.5), 0.0,\n                         atol=0, rtol=0)\n\n    def test_obl_ang1(self):\n        cephes.obl_ang1(1,1,1,0)\n\n    def test_obl_ang1_cv(self):\n        result = cephes.obl_ang1_cv(1,1,1,1,0)\n        assert_almost_equal(result[0],1.0)\n        assert_almost_equal(result[1],0.0)\n\n    def _check_obl_cv(self):\n        assert_equal(cephes.obl_cv(1,1,0),2.0)\n\n    def test_obl_rad1(self):\n        cephes.obl_rad1(1,1,1,0)\n\n    def test_obl_rad1_cv(self):\n        cephes.obl_rad1_cv(1,1,1,1,0)\n\n    def test_obl_rad2(self):\n        cephes.obl_rad2(1,1,1,0)\n\n    def test_obl_rad2_cv(self):\n        cephes.obl_rad2_cv(1,1,1,1,0)\n\n    def test_pbdv(self):\n        assert_equal(cephes.pbdv(1,0),(0.0,1.0))\n\n    def test_pbvv(self):\n        cephes.pbvv(1,0)\n\n    def test_pbwa(self):\n        cephes.pbwa(1,0)\n\n    def test_pdtr(self):\n        val = cephes.pdtr(0, 1)\n        assert_almost_equal(val, np.exp(-1))\n        # Edge case: m = 0.\n        val = cephes.pdtr([0, 1, 2], 0)\n        assert_array_equal(val, [1, 1, 1])\n\n    def test_pdtrc(self):\n        val = cephes.pdtrc(0, 1)\n        assert_almost_equal(val, 1 - np.exp(-1))\n        # Edge case: m = 0.\n        val = cephes.pdtrc([0, 1, 2], 0.0)\n        assert_array_equal(val, [0, 0, 0])\n\n    def test_pdtri(self):\n        with suppress_warnings() as sup:\n            sup.filter(RuntimeWarning, \"floating point number truncated to an integer\")\n            cephes.pdtri(0.5,0.5)\n\n    def test_pdtrik(self):\n        k = cephes.pdtrik(0.5, 1)\n        assert_almost_equal(cephes.gammaincc(k + 1, 1), 0.5)\n        # Edge case: m = 0 or very small.\n        k = cephes.pdtrik([[0], [0.25], [0.95]], [0, 1e-20, 1e-6])\n        assert_array_equal(k, np.zeros((3, 3)))\n\n    def test_pro_ang1(self):\n        cephes.pro_ang1(1,1,1,0)\n\n    def test_pro_ang1_cv(self):\n        assert_array_almost_equal(cephes.pro_ang1_cv(1,1,1,1,0),\n                                  array((1.0,0.0)))\n\n    def _check_pro_cv(self):\n        assert_equal(cephes.pro_cv(1,1,0),2.0)\n\n    def test_pro_rad1(self):\n        cephes.pro_rad1(1,1,1,0.1)\n\n    def test_pro_rad1_cv(self):\n        cephes.pro_rad1_cv(1,1,1,1,0)\n\n    def test_pro_rad2(self):\n        cephes.pro_rad2(1,1,1,0)\n\n    def test_pro_rad2_cv(self):\n        cephes.pro_rad2_cv(1,1,1,1,0)\n\n    def test_psi(self):\n        cephes.psi(1)\n\n    def test_radian(self):\n        assert_equal(cephes.radian(0,0,0),0)\n\n    def test_rgamma(self):\n        assert_equal(cephes.rgamma(1),1.0)\n\n    def test_round(self):\n        assert_equal(cephes.round(3.4),3.0)\n        assert_equal(cephes.round(-3.4),-3.0)\n        assert_equal(cephes.round(3.6),4.0)\n        assert_equal(cephes.round(-3.6),-4.0)\n        assert_equal(cephes.round(3.5),4.0)\n        assert_equal(cephes.round(-3.5),-4.0)\n\n    def test_shichi(self):\n        cephes.shichi(1)\n\n    def test_sici(self):\n        cephes.sici(1)\n\n        s, c = cephes.sici(np.inf)\n        assert_almost_equal(s, np.pi * 0.5)\n        assert_almost_equal(c, 0)\n\n        s, c = cephes.sici(-np.inf)\n        assert_almost_equal(s, -np.pi * 0.5)\n        assert_(np.isnan(c), \"cosine integral(-inf) is not nan\")\n\n    def test_sindg(self):\n        assert_equal(cephes.sindg(90),1.0)\n\n    def test_smirnov(self):\n        assert_equal(cephes.smirnov(1,.1),0.9)\n        assert_(np.isnan(cephes.smirnov(1,np.nan)))\n\n    def test_smirnovp(self):\n        assert_equal(cephes._smirnovp(1, .1), -1)\n        assert_equal(cephes._smirnovp(2, 0.75), -2*(0.25)**(2-1))\n        assert_equal(cephes._smirnovp(3, 0.75), -3*(0.25)**(3-1))\n        assert_(np.isnan(cephes._smirnovp(1, np.nan)))\n\n    def test_smirnovc(self):\n        assert_equal(cephes._smirnovc(1,.1),0.1)\n        assert_(np.isnan(cephes._smirnovc(1,np.nan)))\n        x10 = np.linspace(0, 1, 11, endpoint=True)\n        assert_almost_equal(cephes._smirnovc(3, x10), 1-cephes.smirnov(3, x10))\n        x4 = np.linspace(0, 1, 5, endpoint=True)\n        assert_almost_equal(cephes._smirnovc(4, x4), 1-cephes.smirnov(4, x4))\n\n    def test_smirnovi(self):\n        assert_almost_equal(cephes.smirnov(1,cephes.smirnovi(1,0.4)),0.4)\n        assert_almost_equal(cephes.smirnov(1,cephes.smirnovi(1,0.6)),0.6)\n        assert_(np.isnan(cephes.smirnovi(1,np.nan)))\n\n    def test_smirnovci(self):\n        assert_almost_equal(cephes._smirnovc(1,cephes._smirnovci(1,0.4)),0.4)\n        assert_almost_equal(cephes._smirnovc(1,cephes._smirnovci(1,0.6)),0.6)\n        assert_(np.isnan(cephes._smirnovci(1,np.nan)))\n\n    def test_spence(self):\n        assert_equal(cephes.spence(1),0.0)\n\n    def test_stdtr(self):\n        assert_equal(cephes.stdtr(1,0),0.5)\n        assert_almost_equal(cephes.stdtr(1,1), 0.75)\n        assert_almost_equal(cephes.stdtr(1,2), 0.852416382349)\n\n    def test_stdtridf(self):\n        cephes.stdtridf(0.7,1)\n\n    def test_stdtrit(self):\n        cephes.stdtrit(1,0.7)\n\n    def test_struve(self):\n        assert_equal(cephes.struve(0,0),0.0)\n\n    def test_tandg(self):\n        assert_equal(cephes.tandg(45),1.0)\n\n    def test_tklmbda(self):\n        assert_almost_equal(cephes.tklmbda(1,1),1.0)\n\n    def test_y0(self):\n        cephes.y0(1)\n\n    def test_y1(self):\n        cephes.y1(1)\n\n    def test_yn(self):\n        cephes.yn(1,1)\n\n    def test_yv(self):\n        cephes.yv(1,1)\n\n    def _check_yve(self):\n        cephes.yve(1,1)\n\n    def test_wofz(self):\n        z = [complex(624.2,-0.26123), complex(-0.4,3.), complex(0.6,2.),\n             complex(-1.,1.), complex(-1.,-9.), complex(-1.,9.),\n             complex(-0.0000000234545,1.1234), complex(-3.,5.1),\n             complex(-53,30.1), complex(0.0,0.12345),\n             complex(11,1), complex(-22,-2), complex(9,-28),\n             complex(21,-33), complex(1e5,1e5), complex(1e14,1e14)\n             ]\n        w = [\n            complex(-3.78270245518980507452677445620103199303131110e-7,\n                    0.000903861276433172057331093754199933411710053155),\n            complex(0.1764906227004816847297495349730234591778719532788,\n                    -0.02146550539468457616788719893991501311573031095617),\n            complex(0.2410250715772692146133539023007113781272362309451,\n                    0.06087579663428089745895459735240964093522265589350),\n            complex(0.30474420525691259245713884106959496013413834051768,\n                    -0.20821893820283162728743734725471561394145872072738),\n            complex(7.317131068972378096865595229600561710140617977e34,\n                    8.321873499714402777186848353320412813066170427e34),\n            complex(0.0615698507236323685519612934241429530190806818395,\n                    -0.00676005783716575013073036218018565206070072304635),\n            complex(0.3960793007699874918961319170187598400134746631,\n                    -5.593152259116644920546186222529802777409274656e-9),\n            complex(0.08217199226739447943295069917990417630675021771804,\n                    -0.04701291087643609891018366143118110965272615832184),\n            complex(0.00457246000350281640952328010227885008541748668738,\n                    -0.00804900791411691821818731763401840373998654987934),\n            complex(0.8746342859608052666092782112565360755791467973338452,\n                    0.),\n            complex(0.00468190164965444174367477874864366058339647648741,\n                    0.0510735563901306197993676329845149741675029197050),\n            complex(-0.0023193175200187620902125853834909543869428763219,\n                    -0.025460054739731556004902057663500272721780776336),\n            complex(9.11463368405637174660562096516414499772662584e304,\n                    3.97101807145263333769664875189354358563218932e305),\n            complex(-4.4927207857715598976165541011143706155432296e281,\n                    -2.8019591213423077494444700357168707775769028e281),\n            complex(2.820947917809305132678577516325951485807107151e-6,\n                    2.820947917668257736791638444590253942253354058e-6),\n            complex(2.82094791773878143474039725787438662716372268e-15,\n                    2.82094791773878143474039725773333923127678361e-15)\n        ]\n        assert_func_equal(cephes.wofz, w, z, rtol=1e-13)\n\n\nclass TestAiry:\n    def test_airy(self):\n        # This tests the airy function to ensure 8 place accuracy in computation\n\n        x = special.airy(.99)\n        assert_array_almost_equal(x,array([0.13689066,-0.16050153,1.19815925,0.92046818]),8)\n        x = special.airy(.41)\n        assert_array_almost_equal(x,array([0.25238916,-.23480512,0.80686202,0.51053919]),8)\n        x = special.airy(-.36)\n        assert_array_almost_equal(x,array([0.44508477,-0.23186773,0.44939534,0.48105354]),8)\n\n    def test_airye(self):\n        a = special.airye(0.01)\n        b = special.airy(0.01)\n        b1 = [None]*4\n        for n in range(2):\n            b1[n] = b[n]*exp(2.0/3.0*0.01*sqrt(0.01))\n        for n in range(2,4):\n            b1[n] = b[n]*exp(-abs(real(2.0/3.0*0.01*sqrt(0.01))))\n        assert_array_almost_equal(a,b1,6)\n\n    def test_bi_zeros(self):\n        bi = special.bi_zeros(2)\n        bia = (array([-1.17371322, -3.2710930]),\n               array([-2.29443968, -4.07315509]),\n               array([-0.45494438, 0.39652284]),\n               array([0.60195789, -0.76031014]))\n        assert_array_almost_equal(bi,bia,4)\n\n        bi = special.bi_zeros(5)\n        assert_array_almost_equal(bi[0],array([-1.173713222709127,\n                                               -3.271093302836352,\n                                               -4.830737841662016,\n                                               -6.169852128310251,\n                                               -7.376762079367764]),11)\n\n        assert_array_almost_equal(bi[1],array([-2.294439682614122,\n                                               -4.073155089071828,\n                                               -5.512395729663599,\n                                               -6.781294445990305,\n                                               -7.940178689168587]),10)\n\n        assert_array_almost_equal(bi[2],array([-0.454944383639657,\n                                               0.396522836094465,\n                                               -0.367969161486959,\n                                               0.349499116831805,\n                                               -0.336026240133662]),11)\n\n        assert_array_almost_equal(bi[3],array([0.601957887976239,\n                                               -0.760310141492801,\n                                               0.836991012619261,\n                                               -0.88947990142654,\n                                               0.929983638568022]),10)\n\n    def test_ai_zeros(self):\n        ai = special.ai_zeros(1)\n        assert_array_almost_equal(ai,(array([-2.33810741]),\n                                     array([-1.01879297]),\n                                     array([0.5357]),\n                                     array([0.7012])),4)\n\n    def test_ai_zeros_big(self):\n        z, zp, ai_zpx, aip_zx = special.ai_zeros(50000)\n        ai_z, aip_z, _, _ = special.airy(z)\n        ai_zp, aip_zp, _, _ = special.airy(zp)\n\n        ai_envelope = 1/abs(z)**(1./4)\n        aip_envelope = abs(zp)**(1./4)\n\n        # Check values\n        assert_allclose(ai_zpx, ai_zp, rtol=1e-10)\n        assert_allclose(aip_zx, aip_z, rtol=1e-10)\n\n        # Check they are zeros\n        assert_allclose(ai_z/ai_envelope, 0, atol=1e-10, rtol=0)\n        assert_allclose(aip_zp/aip_envelope, 0, atol=1e-10, rtol=0)\n\n        # Check first zeros, DLMF 9.9.1\n        assert_allclose(z[:6],\n            [-2.3381074105, -4.0879494441, -5.5205598281,\n             -6.7867080901, -7.9441335871, -9.0226508533], rtol=1e-10)\n        assert_allclose(zp[:6],\n            [-1.0187929716, -3.2481975822, -4.8200992112,\n             -6.1633073556, -7.3721772550, -8.4884867340], rtol=1e-10)\n\n    def test_bi_zeros_big(self):\n        z, zp, bi_zpx, bip_zx = special.bi_zeros(50000)\n        _, _, bi_z, bip_z = special.airy(z)\n        _, _, bi_zp, bip_zp = special.airy(zp)\n\n        bi_envelope = 1/abs(z)**(1./4)\n        bip_envelope = abs(zp)**(1./4)\n\n        # Check values\n        assert_allclose(bi_zpx, bi_zp, rtol=1e-10)\n        assert_allclose(bip_zx, bip_z, rtol=1e-10)\n\n        # Check they are zeros\n        assert_allclose(bi_z/bi_envelope, 0, atol=1e-10, rtol=0)\n        assert_allclose(bip_zp/bip_envelope, 0, atol=1e-10, rtol=0)\n\n        # Check first zeros, DLMF 9.9.2\n        assert_allclose(z[:6],\n            [-1.1737132227, -3.2710933028, -4.8307378417,\n             -6.1698521283, -7.3767620794, -8.4919488465], rtol=1e-10)\n        assert_allclose(zp[:6],\n            [-2.2944396826, -4.0731550891, -5.5123957297,\n             -6.7812944460, -7.9401786892, -9.0195833588], rtol=1e-10)\n\n\nclass TestAssocLaguerre:\n    def test_assoc_laguerre(self):\n        a1 = special.genlaguerre(11,1)\n        a2 = special.assoc_laguerre(.2,11,1)\n        assert_array_almost_equal(a2,a1(.2),8)\n        a2 = special.assoc_laguerre(1,11,1)\n        assert_array_almost_equal(a2,a1(1),8)\n\n\nclass TestBesselpoly:\n    def test_besselpoly(self):\n        pass\n\n\nclass TestKelvin:\n    def test_bei(self):\n        mbei = special.bei(2)\n        assert_almost_equal(mbei, 0.9722916273066613,5)  # this may not be exact\n\n    def test_beip(self):\n        mbeip = special.beip(2)\n        assert_almost_equal(mbeip,0.91701361338403631,5)  # this may not be exact\n\n    def test_ber(self):\n        mber = special.ber(2)\n        assert_almost_equal(mber,0.75173418271380821,5)  # this may not be exact\n\n    def test_berp(self):\n        mberp = special.berp(2)\n        assert_almost_equal(mberp,-0.49306712470943909,5)  # this may not be exact\n\n    def test_bei_zeros(self):\n        # Abramowitz & Stegun, Table 9.12\n        bi = special.bei_zeros(5)\n        assert_array_almost_equal(bi,array([5.02622,\n                                            9.45541,\n                                            13.89349,\n                                            18.33398,\n                                            22.77544]),4)\n\n    def test_beip_zeros(self):\n        bip = special.beip_zeros(5)\n        assert_array_almost_equal(bip,array([3.772673304934953,\n                                               8.280987849760042,\n                                               12.742147523633703,\n                                               17.193431752512542,\n                                               21.641143941167325]),8)\n\n    def test_ber_zeros(self):\n        ber = special.ber_zeros(5)\n        assert_array_almost_equal(ber,array([2.84892,\n                                             7.23883,\n                                             11.67396,\n                                             16.11356,\n                                             20.55463]),4)\n\n    def test_berp_zeros(self):\n        brp = special.berp_zeros(5)\n        assert_array_almost_equal(brp,array([6.03871,\n                                             10.51364,\n                                             14.96844,\n                                             19.41758,\n                                             23.86430]),4)\n\n    def test_kelvin(self):\n        mkelv = special.kelvin(2)\n        assert_array_almost_equal(mkelv,(special.ber(2) + special.bei(2)*1j,\n                                         special.ker(2) + special.kei(2)*1j,\n                                         special.berp(2) + special.beip(2)*1j,\n                                         special.kerp(2) + special.keip(2)*1j),8)\n\n    def test_kei(self):\n        mkei = special.kei(2)\n        assert_almost_equal(mkei,-0.20240006776470432,5)\n\n    def test_keip(self):\n        mkeip = special.keip(2)\n        assert_almost_equal(mkeip,0.21980790991960536,5)\n\n    def test_ker(self):\n        mker = special.ker(2)\n        assert_almost_equal(mker,-0.041664513991509472,5)\n\n    def test_kerp(self):\n        mkerp = special.kerp(2)\n        assert_almost_equal(mkerp,-0.10660096588105264,5)\n\n    def test_kei_zeros(self):\n        kei = special.kei_zeros(5)\n        assert_array_almost_equal(kei,array([3.91467,\n                                              8.34422,\n                                              12.78256,\n                                              17.22314,\n                                              21.66464]),4)\n\n    def test_keip_zeros(self):\n        keip = special.keip_zeros(5)\n        assert_array_almost_equal(keip,array([4.93181,\n                                                9.40405,\n                                                13.85827,\n                                                18.30717,\n                                                22.75379]),4)\n\n    # numbers come from 9.9 of A&S pg. 381\n    def test_kelvin_zeros(self):\n        tmp = special.kelvin_zeros(5)\n        berz,beiz,kerz,keiz,berpz,beipz,kerpz,keipz = tmp\n        assert_array_almost_equal(berz,array([2.84892,\n                                               7.23883,\n                                               11.67396,\n                                               16.11356,\n                                               20.55463]),4)\n        assert_array_almost_equal(beiz,array([5.02622,\n                                               9.45541,\n                                               13.89349,\n                                               18.33398,\n                                               22.77544]),4)\n        assert_array_almost_equal(kerz,array([1.71854,\n                                               6.12728,\n                                               10.56294,\n                                               15.00269,\n                                               19.44382]),4)\n        assert_array_almost_equal(keiz,array([3.91467,\n                                               8.34422,\n                                               12.78256,\n                                               17.22314,\n                                               21.66464]),4)\n        assert_array_almost_equal(berpz,array([6.03871,\n                                                10.51364,\n                                                14.96844,\n                                                19.41758,\n                                                23.86430]),4)\n        assert_array_almost_equal(beipz,array([3.77267,\n                 # table from 1927 had 3.77320\n                 #  but this is more accurate\n                                                8.28099,\n                                                12.74215,\n                                                17.19343,\n                                                21.64114]),4)\n        assert_array_almost_equal(kerpz,array([2.66584,\n                                                7.17212,\n                                                11.63218,\n                                                16.08312,\n                                                20.53068]),4)\n        assert_array_almost_equal(keipz,array([4.93181,\n                                                9.40405,\n                                                13.85827,\n                                                18.30717,\n                                                22.75379]),4)\n\n    def test_ker_zeros(self):\n        ker = special.ker_zeros(5)\n        assert_array_almost_equal(ker,array([1.71854,\n                                               6.12728,\n                                               10.56294,\n                                               15.00269,\n                                               19.44381]),4)\n\n    def test_kerp_zeros(self):\n        kerp = special.kerp_zeros(5)\n        assert_array_almost_equal(kerp,array([2.66584,\n                                                7.17212,\n                                                11.63218,\n                                                16.08312,\n                                                20.53068]),4)\n\n\nclass TestBernoulli:\n    def test_bernoulli(self):\n        brn = special.bernoulli(5)\n        assert_array_almost_equal(brn,array([1.0000,\n                                             -0.5000,\n                                             0.1667,\n                                             0.0000,\n                                             -0.0333,\n                                             0.0000]),4)\n\n\nclass TestBeta:\n    def test_beta(self):\n        bet = special.beta(2,4)\n        betg = (special.gamma(2)*special.gamma(4))/special.gamma(6)\n        assert_almost_equal(bet,betg,8)\n\n    def test_betaln(self):\n        betln = special.betaln(2,4)\n        bet = log(abs(special.beta(2,4)))\n        assert_almost_equal(betln,bet,8)\n\n    def test_betainc(self):\n        btinc = special.betainc(1,1,.2)\n        assert_almost_equal(btinc,0.2,8)\n\n    def test_betaincinv(self):\n        y = special.betaincinv(2,4,.5)\n        comp = special.betainc(2,4,y)\n        assert_almost_equal(comp,.5,5)\n\n\nclass TestCombinatorics:\n    def test_comb(self):\n        assert_array_almost_equal(special.comb([10, 10], [3, 4]), [120., 210.])\n        assert_almost_equal(special.comb(10, 3), 120.)\n        assert_equal(special.comb(10, 3, exact=True), 120)\n        assert_equal(special.comb(10, 3, exact=True, repetition=True), 220)\n\n        assert_allclose([special.comb(20, k, exact=True) for k in range(21)],\n                        special.comb(20, list(range(21))), atol=1e-15)\n\n        ii = np.iinfo(int).max + 1\n        assert_equal(special.comb(ii, ii-1, exact=True), ii)\n\n        expected = 100891344545564193334812497256\n        assert_equal(special.comb(100, 50, exact=True), expected)\n\n    def test_comb_with_np_int64(self):\n        n = 70\n        k = 30\n        np_n = np.int64(n)\n        np_k = np.int64(k)\n        assert_equal(special.comb(np_n, np_k, exact=True),\n                     special.comb(n, k, exact=True))\n\n    def test_comb_zeros(self):\n        assert_equal(special.comb(2, 3, exact=True), 0)\n        assert_equal(special.comb(-1, 3, exact=True), 0)\n        assert_equal(special.comb(2, -1, exact=True), 0)\n        assert_equal(special.comb(2, -1, exact=False), 0)\n        assert_array_almost_equal(special.comb([2, -1, 2, 10], [3, 3, -1, 3]),\n                [0., 0., 0., 120.])\n\n    def test_perm(self):\n        assert_array_almost_equal(special.perm([10, 10], [3, 4]), [720., 5040.])\n        assert_almost_equal(special.perm(10, 3), 720.)\n        assert_equal(special.perm(10, 3, exact=True), 720)\n\n    def test_perm_zeros(self):\n        assert_equal(special.perm(2, 3, exact=True), 0)\n        assert_equal(special.perm(-1, 3, exact=True), 0)\n        assert_equal(special.perm(2, -1, exact=True), 0)\n        assert_equal(special.perm(2, -1, exact=False), 0)\n        assert_array_almost_equal(special.perm([2, -1, 2, 10], [3, 3, -1, 3]),\n                [0., 0., 0., 720.])\n\n\nclass TestTrigonometric:\n    def test_cbrt(self):\n        cb = special.cbrt(27)\n        cbrl = 27**(1.0/3.0)\n        assert_approx_equal(cb,cbrl)\n\n    def test_cbrtmore(self):\n        cb1 = special.cbrt(27.9)\n        cbrl1 = 27.9**(1.0/3.0)\n        assert_almost_equal(cb1,cbrl1,8)\n\n    def test_cosdg(self):\n        cdg = special.cosdg(90)\n        cdgrl = cos(pi/2.0)\n        assert_almost_equal(cdg,cdgrl,8)\n\n    def test_cosdgmore(self):\n        cdgm = special.cosdg(30)\n        cdgmrl = cos(pi/6.0)\n        assert_almost_equal(cdgm,cdgmrl,8)\n\n    def test_cosm1(self):\n        cs = (special.cosm1(0),special.cosm1(.3),special.cosm1(pi/10))\n        csrl = (cos(0)-1,cos(.3)-1,cos(pi/10)-1)\n        assert_array_almost_equal(cs,csrl,8)\n\n    def test_cotdg(self):\n        ct = special.cotdg(30)\n        ctrl = tan(pi/6.0)**(-1)\n        assert_almost_equal(ct,ctrl,8)\n\n    def test_cotdgmore(self):\n        ct1 = special.cotdg(45)\n        ctrl1 = tan(pi/4.0)**(-1)\n        assert_almost_equal(ct1,ctrl1,8)\n\n    def test_specialpoints(self):\n        assert_almost_equal(special.cotdg(45), 1.0, 14)\n        assert_almost_equal(special.cotdg(-45), -1.0, 14)\n        assert_almost_equal(special.cotdg(90), 0.0, 14)\n        assert_almost_equal(special.cotdg(-90), 0.0, 14)\n        assert_almost_equal(special.cotdg(135), -1.0, 14)\n        assert_almost_equal(special.cotdg(-135), 1.0, 14)\n        assert_almost_equal(special.cotdg(225), 1.0, 14)\n        assert_almost_equal(special.cotdg(-225), -1.0, 14)\n        assert_almost_equal(special.cotdg(270), 0.0, 14)\n        assert_almost_equal(special.cotdg(-270), 0.0, 14)\n        assert_almost_equal(special.cotdg(315), -1.0, 14)\n        assert_almost_equal(special.cotdg(-315), 1.0, 14)\n        assert_almost_equal(special.cotdg(765), 1.0, 14)\n\n    def test_sinc(self):\n        # the sinc implementation and more extensive sinc tests are in numpy\n        assert_array_equal(special.sinc([0]), 1)\n        assert_equal(special.sinc(0.0), 1.0)\n\n    def test_sindg(self):\n        sn = special.sindg(90)\n        assert_equal(sn,1.0)\n\n    def test_sindgmore(self):\n        snm = special.sindg(30)\n        snmrl = sin(pi/6.0)\n        assert_almost_equal(snm,snmrl,8)\n        snm1 = special.sindg(45)\n        snmrl1 = sin(pi/4.0)\n        assert_almost_equal(snm1,snmrl1,8)\n\n\nclass TestTandg:\n\n    def test_tandg(self):\n        tn = special.tandg(30)\n        tnrl = tan(pi/6.0)\n        assert_almost_equal(tn,tnrl,8)\n\n    def test_tandgmore(self):\n        tnm = special.tandg(45)\n        tnmrl = tan(pi/4.0)\n        assert_almost_equal(tnm,tnmrl,8)\n        tnm1 = special.tandg(60)\n        tnmrl1 = tan(pi/3.0)\n        assert_almost_equal(tnm1,tnmrl1,8)\n\n    def test_specialpoints(self):\n        assert_almost_equal(special.tandg(0), 0.0, 14)\n        assert_almost_equal(special.tandg(45), 1.0, 14)\n        assert_almost_equal(special.tandg(-45), -1.0, 14)\n        assert_almost_equal(special.tandg(135), -1.0, 14)\n        assert_almost_equal(special.tandg(-135), 1.0, 14)\n        assert_almost_equal(special.tandg(180), 0.0, 14)\n        assert_almost_equal(special.tandg(-180), 0.0, 14)\n        assert_almost_equal(special.tandg(225), 1.0, 14)\n        assert_almost_equal(special.tandg(-225), -1.0, 14)\n        assert_almost_equal(special.tandg(315), -1.0, 14)\n        assert_almost_equal(special.tandg(-315), 1.0, 14)\n\n\nclass TestEllip:\n    def test_ellipj_nan(self):\n        \"\"\"Regression test for #912.\"\"\"\n        special.ellipj(0.5, np.nan)\n\n    def test_ellipj(self):\n        el = special.ellipj(0.2,0)\n        rel = [sin(0.2),cos(0.2),1.0,0.20]\n        assert_array_almost_equal(el,rel,13)\n\n    def test_ellipk(self):\n        elk = special.ellipk(.2)\n        assert_almost_equal(elk,1.659623598610528,11)\n\n        assert_equal(special.ellipkm1(0.0), np.inf)\n        assert_equal(special.ellipkm1(1.0), pi/2)\n        assert_equal(special.ellipkm1(np.inf), 0.0)\n        assert_equal(special.ellipkm1(np.nan), np.nan)\n        assert_equal(special.ellipkm1(-1), np.nan)\n        assert_allclose(special.ellipk(-10), 0.7908718902387385)\n\n    def test_ellipkinc(self):\n        elkinc = special.ellipkinc(pi/2,.2)\n        elk = special.ellipk(0.2)\n        assert_almost_equal(elkinc,elk,15)\n        alpha = 20*pi/180\n        phi = 45*pi/180\n        m = sin(alpha)**2\n        elkinc = special.ellipkinc(phi,m)\n        assert_almost_equal(elkinc,0.79398143,8)\n        # From pg. 614 of A & S\n\n        assert_equal(special.ellipkinc(pi/2, 0.0), pi/2)\n        assert_equal(special.ellipkinc(pi/2, 1.0), np.inf)\n        assert_equal(special.ellipkinc(pi/2, -np.inf), 0.0)\n        assert_equal(special.ellipkinc(pi/2, np.nan), np.nan)\n        assert_equal(special.ellipkinc(pi/2, 2), np.nan)\n        assert_equal(special.ellipkinc(0, 0.5), 0.0)\n        assert_equal(special.ellipkinc(np.inf, 0.5), np.inf)\n        assert_equal(special.ellipkinc(-np.inf, 0.5), -np.inf)\n        assert_equal(special.ellipkinc(np.inf, np.inf), np.nan)\n        assert_equal(special.ellipkinc(np.inf, -np.inf), np.nan)\n        assert_equal(special.ellipkinc(-np.inf, -np.inf), np.nan)\n        assert_equal(special.ellipkinc(-np.inf, np.inf), np.nan)\n        assert_equal(special.ellipkinc(np.nan, 0.5), np.nan)\n        assert_equal(special.ellipkinc(np.nan, np.nan), np.nan)\n\n        assert_allclose(special.ellipkinc(0.38974112035318718, 1), 0.4, rtol=1e-14)\n        assert_allclose(special.ellipkinc(1.5707, -10), 0.79084284661724946)\n\n    def test_ellipkinc_2(self):\n        # Regression test for gh-3550\n        # ellipkinc(phi, mbad) was NaN and mvals[2:6] were twice the correct value\n        mbad = 0.68359375000000011\n        phi = 0.9272952180016123\n        m = np.nextafter(mbad, 0)\n        mvals = []\n        for j in range(10):\n            mvals.append(m)\n            m = np.nextafter(m, 1)\n        f = special.ellipkinc(phi, mvals)\n        assert_array_almost_equal_nulp(f, np.full_like(f, 1.0259330100195334), 1)\n        # this bug also appears at phi + n * pi for at least small n\n        f1 = special.ellipkinc(phi + pi, mvals)\n        assert_array_almost_equal_nulp(f1, np.full_like(f1, 5.1296650500976675), 2)\n\n    def test_ellipkinc_singular(self):\n        # ellipkinc(phi, 1) has closed form and is finite only for phi in (-pi/2, pi/2)\n        xlog = np.logspace(-300, -17, 25)\n        xlin = np.linspace(1e-17, 0.1, 25)\n        xlin2 = np.linspace(0.1, pi/2, 25, endpoint=False)\n\n        assert_allclose(special.ellipkinc(xlog, 1), np.arcsinh(np.tan(xlog)), rtol=1e14)\n        assert_allclose(special.ellipkinc(xlin, 1), np.arcsinh(np.tan(xlin)), rtol=1e14)\n        assert_allclose(special.ellipkinc(xlin2, 1), np.arcsinh(np.tan(xlin2)), rtol=1e14)\n        assert_equal(special.ellipkinc(np.pi/2, 1), np.inf)\n        assert_allclose(special.ellipkinc(-xlog, 1), np.arcsinh(np.tan(-xlog)), rtol=1e14)\n        assert_allclose(special.ellipkinc(-xlin, 1), np.arcsinh(np.tan(-xlin)), rtol=1e14)\n        assert_allclose(special.ellipkinc(-xlin2, 1), np.arcsinh(np.tan(-xlin2)), rtol=1e14)\n        assert_equal(special.ellipkinc(-np.pi/2, 1), np.inf)\n\n    def test_ellipe(self):\n        ele = special.ellipe(.2)\n        assert_almost_equal(ele,1.4890350580958529,8)\n\n        assert_equal(special.ellipe(0.0), pi/2)\n        assert_equal(special.ellipe(1.0), 1.0)\n        assert_equal(special.ellipe(-np.inf), np.inf)\n        assert_equal(special.ellipe(np.nan), np.nan)\n        assert_equal(special.ellipe(2), np.nan)\n        assert_allclose(special.ellipe(-10), 3.6391380384177689)\n\n    def test_ellipeinc(self):\n        eleinc = special.ellipeinc(pi/2,.2)\n        ele = special.ellipe(0.2)\n        assert_almost_equal(eleinc,ele,14)\n        # pg 617 of A & S\n        alpha, phi = 52*pi/180,35*pi/180\n        m = sin(alpha)**2\n        eleinc = special.ellipeinc(phi,m)\n        assert_almost_equal(eleinc, 0.58823065, 8)\n\n        assert_equal(special.ellipeinc(pi/2, 0.0), pi/2)\n        assert_equal(special.ellipeinc(pi/2, 1.0), 1.0)\n        assert_equal(special.ellipeinc(pi/2, -np.inf), np.inf)\n        assert_equal(special.ellipeinc(pi/2, np.nan), np.nan)\n        assert_equal(special.ellipeinc(pi/2, 2), np.nan)\n        assert_equal(special.ellipeinc(0, 0.5), 0.0)\n        assert_equal(special.ellipeinc(np.inf, 0.5), np.inf)\n        assert_equal(special.ellipeinc(-np.inf, 0.5), -np.inf)\n        assert_equal(special.ellipeinc(np.inf, -np.inf), np.inf)\n        assert_equal(special.ellipeinc(-np.inf, -np.inf), -np.inf)\n        assert_equal(special.ellipeinc(np.inf, np.inf), np.nan)\n        assert_equal(special.ellipeinc(-np.inf, np.inf), np.nan)\n        assert_equal(special.ellipeinc(np.nan, 0.5), np.nan)\n        assert_equal(special.ellipeinc(np.nan, np.nan), np.nan)\n        assert_allclose(special.ellipeinc(1.5707, -10), 3.6388185585822876)\n\n    def test_ellipeinc_2(self):\n        # Regression test for gh-3550\n        # ellipeinc(phi, mbad) was NaN and mvals[2:6] were twice the correct value\n        mbad = 0.68359375000000011\n        phi = 0.9272952180016123\n        m = np.nextafter(mbad, 0)\n        mvals = []\n        for j in range(10):\n            mvals.append(m)\n            m = np.nextafter(m, 1)\n        f = special.ellipeinc(phi, mvals)\n        assert_array_almost_equal_nulp(f, np.full_like(f, 0.84442884574781019), 2)\n        # this bug also appears at phi + n * pi for at least small n\n        f1 = special.ellipeinc(phi + pi, mvals)\n        assert_array_almost_equal_nulp(f1, np.full_like(f1, 3.3471442287390509), 4)\n\n\nclass TestEllipCarlson(object):\n    \"\"\"Test for Carlson elliptic integrals ellipr[cdfgj].\n    The special values used in these tests can be found in Sec. 3 of Carlson\n    (1994), https://arxiv.org/abs/math/9409227\n    \"\"\"\n    def test_elliprc(self):\n        assert_allclose(elliprc(1, 1), 1)\n        assert elliprc(1, inf) == 0.0\n        assert isnan(elliprc(1, 0))\n        assert elliprc(1, complex(1, inf)) == 0.0\n        args = array([[0.0, 0.25],\n                      [2.25, 2.0],\n                      [0.0, 1.0j],\n                      [-1.0j, 1.0j],\n                      [0.25, -2.0],\n                      [1.0j, -1.0]])\n        expected_results = array([np.pi,\n                                  np.log(2.0),\n                                  1.1107207345396 * (1.0-1.0j),\n                                  1.2260849569072-0.34471136988768j,\n                                  np.log(2.0) / 3.0,\n                                  0.77778596920447+0.19832484993429j])\n        for i, arr in enumerate(args):\n            assert_allclose(elliprc(*arr), expected_results[i])\n\n    def test_elliprd(self):\n        assert_allclose(elliprd(1, 1, 1), 1)\n        assert_allclose(elliprd(0, 2, 1) / 3.0, 0.59907011736779610371)\n        assert elliprd(1, 1, inf) == 0.0\n        assert np.isinf(elliprd(1, 1, 0))\n        assert np.isinf(elliprd(1, 1, complex(0, 0)))\n        assert np.isinf(elliprd(0, 1, complex(0, 0)))\n        assert isnan(elliprd(1, 1, -np.finfo(np.double).tiny / 2.0))\n        assert isnan(elliprd(1, 1, complex(-1, 0)))\n        args = array([[0.0, 2.0, 1.0],\n                      [2.0, 3.0, 4.0],\n                      [1.0j, -1.0j, 2.0],\n                      [0.0, 1.0j, -1.0j],\n                      [0.0, -1.0+1.0j, 1.0j],\n                      [-2.0-1.0j, -1.0j, -1.0+1.0j]])\n        expected_results = array([1.7972103521034,\n                                  0.16510527294261,\n                                  0.65933854154220,\n                                  1.2708196271910+2.7811120159521j,\n                                  -1.8577235439239-0.96193450888839j,\n                                  1.8249027393704-1.2218475784827j])\n        for i, arr in enumerate(args):\n            assert_allclose(elliprd(*arr), expected_results[i])\n\n    def test_elliprf(self):\n        assert_allclose(elliprf(1, 1, 1), 1)\n        assert_allclose(elliprf(0, 1, 2), 1.31102877714605990523)\n        assert elliprf(1, inf, 1) == 0.0\n        assert np.isinf(elliprf(0, 1, 0))\n        assert isnan(elliprf(1, 1, -1))\n        assert elliprf(complex(inf), 0, 1) == 0.0\n        assert isnan(elliprf(1, 1, complex(-inf, 1)))\n        args = array([[1.0, 2.0, 0.0],\n                      [1.0j, -1.0j, 0.0],\n                      [0.5, 1.0, 0.0],\n                      [-1.0+1.0j, 1.0j, 0.0],\n                      [2.0, 3.0, 4.0],\n                      [1.0j, -1.0j, 2.0],\n                      [-1.0+1.0j, 1.0j, 1.0-1.0j]])\n        expected_results = array([1.3110287771461,\n                                  1.8540746773014,\n                                  1.8540746773014,\n                                  0.79612586584234-1.2138566698365j,\n                                  0.58408284167715,\n                                  1.0441445654064,\n                                  0.93912050218619-0.53296252018635j])\n        for i, arr in enumerate(args):\n            assert_allclose(elliprf(*arr), expected_results[i])\n\n    def test_elliprg(self):\n        assert_allclose(elliprg(1, 1, 1), 1)\n        assert_allclose(elliprg(0, 0, 1), 0.5)\n        assert_allclose(elliprg(0, 0, 0), 0)\n        assert np.isinf(elliprg(1, inf, 1))\n        assert np.isinf(elliprg(complex(inf), 1, 1))\n        args = array([[0.0, 16.0, 16.0],\n                      [2.0, 3.0, 4.0],\n                      [0.0, 1.0j, -1.0j],\n                      [-1.0+1.0j, 1.0j, 0.0],\n                      [-1.0j, -1.0+1.0j, 1.0j],\n                      [0.0, 0.0796, 4.0]])\n        expected_results = array([np.pi,\n                                  1.7255030280692,\n                                  0.42360654239699,\n                                  0.44660591677018+0.70768352357515j,\n                                  0.36023392184473+0.40348623401722j,\n                                  1.0284758090288])\n        for i, arr in enumerate(args):\n            assert_allclose(elliprg(*arr), expected_results[i])\n\n    def test_elliprj(self):\n        assert_allclose(elliprj(1, 1, 1, 1), 1)\n        assert elliprj(1, 1, inf, 1) == 0.0\n        assert isnan(elliprj(1, 0, 0, 0))\n        assert isnan(elliprj(-1, 1, 1, 1))\n        assert elliprj(1, 1, 1, inf) == 0.0\n        args = array([[0.0, 1.0, 2.0, 3.0],\n                      [2.0, 3.0, 4.0, 5.0],\n                      [2.0, 3.0, 4.0, -1.0+1.0j],\n                      [1.0j, -1.0j, 0.0, 2.0],\n                      [-1.0+1.0j, -1.0-1.0j, 1.0, 2.0],\n                      [1.0j, -1.0j, 0.0, 1.0-1.0j],\n                      [-1.0+1.0j, -1.0-1.0j, 1.0, -3.0+1.0j],\n                      [2.0, 3.0, 4.0, -0.5],    # Cauchy principal value\n                      [2.0, 3.0, 4.0, -5.0]])   # Cauchy principal value\n        expected_results = array([0.77688623778582,\n                                  0.14297579667157,\n                                  0.13613945827771-0.38207561624427j,\n                                  1.6490011662711,\n                                  0.94148358841220,\n                                  1.8260115229009+1.2290661908643j,\n                                  -0.61127970812028-1.0684038390007j,\n                                  0.24723819703052,    # Cauchy principal value\n                                  -0.12711230042964])  # Caucny principal value\n        for i, arr in enumerate(args):\n            assert_allclose(elliprj(*arr), expected_results[i])\n\n    @pytest.mark.xfail(reason=\"Insufficient accuracy on 32-bit\")\n    def test_elliprj_hard(self):\n        assert_allclose(elliprj(6.483625725195452e-08,\n                                1.1649136528196886e-27,\n                                3.6767340167168e+13,\n                                0.493704617023468),\n                        8.63426920644241857617477551054e-6,\n                        rtol=5e-15, atol=1e-20)\n        assert_allclose(elliprj(14.375105857849121,\n                                9.993988969725365e-11,\n                                1.72844262269944e-26,\n                                5.898871222598245e-06),\n                        829774.1424801627252574054378691828,\n                        rtol=5e-15, atol=1e-20)\n\n\nclass TestEllipLegendreCarlsonIdentities(object):\n    \"\"\"Test identities expressing the Legendre elliptic integrals in terms\n    of Carlson's symmetric integrals.  These identities can be found\n    in the DLMF https://dlmf.nist.gov/19.25#i .\n    \"\"\"\n\n    def setup_class(self):\n        self.m_n1_1 = np.arange(-1., 1., 0.01)\n        # For double, this is -(2**1024)\n        self.max_neg = finfo(float_).min\n        # Lots of very negative numbers\n        self.very_neg_m = -1. * 2.**arange(-1 +\n                                           np.log2(-self.max_neg), 0.,\n                                           -1.)\n        self.ms_up_to_1 = np.concatenate(([self.max_neg],\n                                          self.very_neg_m,\n                                          self.m_n1_1))\n\n    def test_k(self):\n        \"\"\"Test identity:\n        K(m) = R_F(0, 1-m, 1)\n        \"\"\"\n        m = self.ms_up_to_1\n        assert_allclose(ellipk(m), elliprf(0., 1.-m, 1.))\n\n    def test_km1(self):\n        \"\"\"Test identity:\n        K(m) = R_F(0, 1-m, 1)\n        But with the ellipkm1 function\n        \"\"\"\n        # For double, this is 2**-1022\n        tiny = finfo(float_).tiny\n        # All these small powers of 2, up to 2**-1\n        m1 = tiny * 2.**arange(0., -np.log2(tiny))\n        assert_allclose(ellipkm1(m1), elliprf(0., m1, 1.))\n\n    def test_e(self):\n        \"\"\"Test identity:\n        E(m) = 2*R_G(0, 1-k^2, 1)\n        \"\"\"\n        m = self.ms_up_to_1\n        assert_allclose(ellipe(m), 2.*elliprg(0., 1.-m, 1.))\n\nclass TestErf:\n\n    def test_erf(self):\n        er = special.erf(.25)\n        assert_almost_equal(er,0.2763263902,8)\n\n    def test_erf_zeros(self):\n        erz = special.erf_zeros(5)\n        erzr = array([1.45061616+1.88094300j,\n                     2.24465928+2.61657514j,\n                     2.83974105+3.17562810j,\n                     3.33546074+3.64617438j,\n                     3.76900557+4.06069723j])\n        assert_array_almost_equal(erz,erzr,4)\n\n    def _check_variant_func(self, func, other_func, rtol, atol=0):\n        np.random.seed(1234)\n        n = 10000\n        x = np.random.pareto(0.02, n) * (2*np.random.randint(0, 2, n) - 1)\n        y = np.random.pareto(0.02, n) * (2*np.random.randint(0, 2, n) - 1)\n        z = x + 1j*y\n\n        with np.errstate(all='ignore'):\n            w = other_func(z)\n            w_real = other_func(x).real\n\n            mask = np.isfinite(w)\n            w = w[mask]\n            z = z[mask]\n\n            mask = np.isfinite(w_real)\n            w_real = w_real[mask]\n            x = x[mask]\n\n            # test both real and complex variants\n            assert_func_equal(func, w, z, rtol=rtol, atol=atol)\n            assert_func_equal(func, w_real, x, rtol=rtol, atol=atol)\n\n    def test_erfc_consistent(self):\n        self._check_variant_func(\n            cephes.erfc,\n            lambda z: 1 - cephes.erf(z),\n            rtol=1e-12,\n            atol=1e-14  # <- the test function loses precision\n            )\n\n    def test_erfcx_consistent(self):\n        self._check_variant_func(\n            cephes.erfcx,\n            lambda z: np.exp(z*z) * cephes.erfc(z),\n            rtol=1e-12\n            )\n\n    def test_erfi_consistent(self):\n        self._check_variant_func(\n            cephes.erfi,\n            lambda z: -1j * cephes.erf(1j*z),\n            rtol=1e-12\n            )\n\n    def test_dawsn_consistent(self):\n        self._check_variant_func(\n            cephes.dawsn,\n            lambda z: sqrt(pi)/2 * np.exp(-z*z) * cephes.erfi(z),\n            rtol=1e-12\n            )\n\n    def test_erf_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan, -1, 1]\n        assert_allclose(special.erf(vals), expected, rtol=1e-15)\n\n    def test_erfc_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan, 2, 0]\n        assert_allclose(special.erfc(vals), expected, rtol=1e-15)\n\n    def test_erfcx_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan, np.inf, 0]\n        assert_allclose(special.erfcx(vals), expected, rtol=1e-15)\n\n    def test_erfi_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan, -np.inf, np.inf]\n        assert_allclose(special.erfi(vals), expected, rtol=1e-15)\n\n    def test_dawsn_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan, -0.0, 0.0]\n        assert_allclose(special.dawsn(vals), expected, rtol=1e-15)\n\n    def test_wofz_nan_inf(self):\n        vals = [np.nan, -np.inf, np.inf]\n        expected = [np.nan + np.nan * 1.j, 0.-0.j, 0.+0.j]\n        assert_allclose(special.wofz(vals), expected, rtol=1e-15)\n\n\nclass TestEuler:\n    def test_euler(self):\n        eu0 = special.euler(0)\n        eu1 = special.euler(1)\n        eu2 = special.euler(2)   # just checking segfaults\n        assert_allclose(eu0, [1], rtol=1e-15)\n        assert_allclose(eu1, [1, 0], rtol=1e-15)\n        assert_allclose(eu2, [1, 0, -1], rtol=1e-15)\n        eu24 = special.euler(24)\n        mathworld = [1,1,5,61,1385,50521,2702765,199360981,\n                     19391512145,2404879675441,\n                     370371188237525,69348874393137901,\n                     15514534163557086905]\n        correct = zeros((25,),'d')\n        for k in range(0,13):\n            if (k % 2):\n                correct[2*k] = -float(mathworld[k])\n            else:\n                correct[2*k] = float(mathworld[k])\n        with np.errstate(all='ignore'):\n            err = nan_to_num((eu24-correct)/correct)\n            errmax = max(err)\n        assert_almost_equal(errmax, 0.0, 14)\n\n\nclass TestExp:\n    def test_exp2(self):\n        ex = special.exp2(2)\n        exrl = 2**2\n        assert_equal(ex,exrl)\n\n    def test_exp2more(self):\n        exm = special.exp2(2.5)\n        exmrl = 2**(2.5)\n        assert_almost_equal(exm,exmrl,8)\n\n    def test_exp10(self):\n        ex = special.exp10(2)\n        exrl = 10**2\n        assert_approx_equal(ex,exrl)\n\n    def test_exp10more(self):\n        exm = special.exp10(2.5)\n        exmrl = 10**(2.5)\n        assert_almost_equal(exm,exmrl,8)\n\n    def test_expm1(self):\n        ex = (special.expm1(2),special.expm1(3),special.expm1(4))\n        exrl = (exp(2)-1,exp(3)-1,exp(4)-1)\n        assert_array_almost_equal(ex,exrl,8)\n\n    def test_expm1more(self):\n        ex1 = (special.expm1(2),special.expm1(2.1),special.expm1(2.2))\n        exrl1 = (exp(2)-1,exp(2.1)-1,exp(2.2)-1)\n        assert_array_almost_equal(ex1,exrl1,8)\n\n\nclass TestFactorialFunctions:\n    def test_factorial(self):\n        # Some known values, float math\n        assert_array_almost_equal(special.factorial(0), 1)\n        assert_array_almost_equal(special.factorial(1), 1)\n        assert_array_almost_equal(special.factorial(2), 2)\n        assert_array_almost_equal([6., 24., 120.],\n                                  special.factorial([3, 4, 5], exact=False))\n        assert_array_almost_equal(special.factorial([[5, 3], [4, 3]]),\n                                  [[120, 6], [24, 6]])\n\n        # Some known values, integer math\n        assert_equal(special.factorial(0, exact=True), 1)\n        assert_equal(special.factorial(1, exact=True), 1)\n        assert_equal(special.factorial(2, exact=True), 2)\n        assert_equal(special.factorial(5, exact=True), 120)\n        assert_equal(special.factorial(15, exact=True), 1307674368000)\n\n        # ndarray shape is maintained\n        assert_equal(special.factorial([7, 4, 15, 10], exact=True),\n                     [5040, 24, 1307674368000, 3628800])\n\n        assert_equal(special.factorial([[5, 3], [4, 3]], True),\n                     [[120, 6], [24, 6]])\n\n        # object arrays\n        assert_equal(special.factorial(np.arange(-3, 22), True),\n                     special.factorial(np.arange(-3, 22), False))\n\n        # int64 array\n        assert_equal(special.factorial(np.arange(-3, 15), True),\n                     special.factorial(np.arange(-3, 15), False))\n\n        # int32 array\n        assert_equal(special.factorial(np.arange(-3, 5), True),\n                     special.factorial(np.arange(-3, 5), False))\n\n        # Consistent output for n < 0\n        for exact in (True, False):\n            assert_array_equal(0, special.factorial(-3, exact))\n            assert_array_equal([1, 2, 0, 0],\n                               special.factorial([1, 2, -5, -4], exact))\n\n        for n in range(0, 22):\n            # Compare all with math.factorial\n            correct = math.factorial(n)\n            assert_array_equal(correct, special.factorial(n, True))\n            assert_array_equal(correct, special.factorial([n], True)[0])\n\n            assert_allclose(float(correct), special.factorial(n, False))\n            assert_allclose(float(correct), special.factorial([n], False)[0])\n\n            # Compare exact=True vs False, scalar vs array\n            assert_array_equal(special.factorial(n, True),\n                               special.factorial(n, False))\n\n            assert_array_equal(special.factorial([n], True),\n                               special.factorial([n], False))\n\n    @pytest.mark.parametrize('x, exact', [\n        (1, True),\n        (1, False),\n        (np.array(1), True),\n        (np.array(1), False),\n    ])\n    def test_factorial_0d_return_type(self, x, exact):\n        assert np.isscalar(special.factorial(x, exact=exact))\n\n    def test_factorial2(self):\n        assert_array_almost_equal([105., 384., 945.],\n                                  special.factorial2([7, 8, 9], exact=False))\n        assert_equal(special.factorial2(7, exact=True), 105)\n        assert_equal(special.factorial2(0, exact=True), 1)\n        assert_equal(special.factorial2(-1, exact=True), 1)\n        assert_equal(special.factorial2(-3, exact=True), -1)\n        assert_equal(special.factorial2(-5, exact=True), 1/3)\n        with assert_raises(\n            ValueError, match=\"n must be a positive integer or an odd \"\n                              \"negative integer.\"\n        ):\n            special.factorial2(1.5, exact=True)\n        with assert_raises(ValueError, match=\"n must be scalar.\"):\n            special.factorial2([1, 2], exact=True)\n        with assert_raises(\n            ValueError, match=\"n must be a positive integer or an odd \"\n                              \"negative integer.\"\n        ):\n            special.factorial2(-2, exact=True)\n        with assert_raises(\n            ValueError, match=\"n must be a positive integer or an odd \"\n                              \"negative integer.\"\n        ):\n            special.factorial2(-3.5, exact=True)\n\n\n    def test_factorialk(self):\n        assert_equal(special.factorialk(5, 1, exact=True), 120)\n        assert_equal(special.factorialk(5, 3, exact=True), 10)\n\n    @pytest.mark.parametrize('x, exact', [\n        (np.nan, True),\n        (np.nan, False),\n        (np.array([np.nan]), True),\n        (np.array([np.nan]), False),\n    ])\n    def test_nan_inputs(self, x, exact):\n        result = special.factorial(x, exact=exact)\n        assert_(np.isnan(result))\n\n    # GH-13122: special.factorial() argument should be an array of integers.\n    # On Python 3.10, math.factorial() reject float.\n    # On Python 3.9, a DeprecationWarning is emitted.\n    # A numpy array casts all integers to float if the array contains a\n    # single NaN.\n    @pytest.mark.skipif(sys.version_info >= (3, 10),\n                        reason=\"Python 3.10+ math.factorial() requires int\")\n    def test_mixed_nan_inputs(self):\n        x = np.array([np.nan, 1, 2, 3, np.nan])\n        with suppress_warnings() as sup:\n            sup.filter(DeprecationWarning, \"Using factorial\\\\(\\\\) with floats is deprecated\")\n            result = special.factorial(x, exact=True)\n            assert_equal(np.array([np.nan, 1, 2, 6, np.nan]), result)\n            result = special.factorial(x, exact=False)\n            assert_equal(np.array([np.nan, 1, 2, 6, np.nan]), result)\n\n\nclass TestFresnel:\n    @pytest.mark.parametrize(\"z, s, c\", [\n        # some positive value\n        (.5, 0.064732432859999287, 0.49234422587144644),\n        (.5 + .0j, 0.064732432859999287, 0.49234422587144644),\n        # negative half annulus\n        # https://github.com/scipy/scipy/issues/12309\n        # Reference values can be reproduced with\n        # https://www.wolframalpha.com/input/?i=FresnelS%5B-2.0+%2B+0.1i%5D\n        # https://www.wolframalpha.com/input/?i=FresnelC%5B-2.0+%2B+0.1i%5D\n        (\n            -2.0 + 0.1j,\n            -0.3109538687728942-0.0005870728836383176j,\n            -0.4879956866358554+0.10670801832903172j\n        ),\n        (\n            -0.1 - 1.5j,\n            -0.03918309471866977+0.7197508454568574j,\n            0.09605692502968956-0.43625191013617465j\n        ),\n        # a different algorithm kicks in for \"large\" values, i.e., |z| >= 4.5,\n        # make sure to test both float and complex values; a different\n        # algorithm is used\n        (6.0, 0.44696076, 0.49953147),\n        (6.0 + 0.0j, 0.44696076, 0.49953147),\n        (6.0j, -0.44696076j, 0.49953147j),\n        (-6.0 + 0.0j, -0.44696076, -0.49953147),\n        (-6.0j, 0.44696076j, -0.49953147j),\n        # inf\n        (np.inf, 0.5, 0.5),\n        (-np.inf, -0.5, -0.5),\n    ])\n    def test_fresnel_values(self, z, s, c):\n        frs = array(special.fresnel(z))\n        assert_array_almost_equal(frs, array([s, c]), 8)\n\n    # values from pg 329  Table 7.11 of A & S\n    #  slightly corrected in 4th decimal place\n    def test_fresnel_zeros(self):\n        szo, czo = special.fresnel_zeros(5)\n        assert_array_almost_equal(szo,\n                                  array([2.0093+0.2885j,\n                                          2.8335+0.2443j,\n                                          3.4675+0.2185j,\n                                          4.0026+0.2009j,\n                                          4.4742+0.1877j]),3)\n        assert_array_almost_equal(czo,\n                                  array([1.7437+0.3057j,\n                                          2.6515+0.2529j,\n                                          3.3204+0.2240j,\n                                          3.8757+0.2047j,\n                                          4.3611+0.1907j]),3)\n        vals1 = special.fresnel(szo)[0]\n        vals2 = special.fresnel(czo)[1]\n        assert_array_almost_equal(vals1,0,14)\n        assert_array_almost_equal(vals2,0,14)\n\n    def test_fresnelc_zeros(self):\n        szo, czo = special.fresnel_zeros(6)\n        frc = special.fresnelc_zeros(6)\n        assert_array_almost_equal(frc,czo,12)\n\n    def test_fresnels_zeros(self):\n        szo, czo = special.fresnel_zeros(5)\n        frs = special.fresnels_zeros(5)\n        assert_array_almost_equal(frs,szo,12)\n\n\nclass TestGamma:\n    def test_gamma(self):\n        gam = special.gamma(5)\n        assert_equal(gam,24.0)\n\n    def test_gammaln(self):\n        gamln = special.gammaln(3)\n        lngam = log(special.gamma(3))\n        assert_almost_equal(gamln,lngam,8)\n\n    def test_gammainccinv(self):\n        gccinv = special.gammainccinv(.5,.5)\n        gcinv = special.gammaincinv(.5,.5)\n        assert_almost_equal(gccinv,gcinv,8)\n\n    @with_special_errors\n    def test_gammaincinv(self):\n        y = special.gammaincinv(.4,.4)\n        x = special.gammainc(.4,y)\n        assert_almost_equal(x,0.4,1)\n        y = special.gammainc(10, 0.05)\n        x = special.gammaincinv(10, 2.5715803516000736e-20)\n        assert_almost_equal(0.05, x, decimal=10)\n        assert_almost_equal(y, 2.5715803516000736e-20, decimal=10)\n        x = special.gammaincinv(50, 8.20754777388471303050299243573393e-18)\n        assert_almost_equal(11.0, x, decimal=10)\n\n    @with_special_errors\n    def test_975(self):\n        # Regression test for ticket #975 -- switch point in algorithm\n        # check that things work OK at the point, immediately next floats\n        # around it, and a bit further away\n        pts = [0.25,\n               np.nextafter(0.25, 0), 0.25 - 1e-12,\n               np.nextafter(0.25, 1), 0.25 + 1e-12]\n        for xp in pts:\n            y = special.gammaincinv(.4, xp)\n            x = special.gammainc(0.4, y)\n            assert_allclose(x, xp, rtol=1e-12)\n\n    def test_rgamma(self):\n        rgam = special.rgamma(8)\n        rlgam = 1/special.gamma(8)\n        assert_almost_equal(rgam,rlgam,8)\n\n    def test_infinity(self):\n        assert_(np.isinf(special.gamma(-1)))\n        assert_equal(special.rgamma(-1), 0)\n\n\nclass TestHankel:\n\n    def test_negv1(self):\n        assert_almost_equal(special.hankel1(-3,2), -special.hankel1(3,2), 14)\n\n    def test_hankel1(self):\n        hank1 = special.hankel1(1,.1)\n        hankrl = (special.jv(1,.1) + special.yv(1,.1)*1j)\n        assert_almost_equal(hank1,hankrl,8)\n\n    def test_negv1e(self):\n        assert_almost_equal(special.hankel1e(-3,2), -special.hankel1e(3,2), 14)\n\n    def test_hankel1e(self):\n        hank1e = special.hankel1e(1,.1)\n        hankrle = special.hankel1(1,.1)*exp(-.1j)\n        assert_almost_equal(hank1e,hankrle,8)\n\n    def test_negv2(self):\n        assert_almost_equal(special.hankel2(-3,2), -special.hankel2(3,2), 14)\n\n    def test_hankel2(self):\n        hank2 = special.hankel2(1,.1)\n        hankrl2 = (special.jv(1,.1) - special.yv(1,.1)*1j)\n        assert_almost_equal(hank2,hankrl2,8)\n\n    def test_neg2e(self):\n        assert_almost_equal(special.hankel2e(-3,2), -special.hankel2e(3,2), 14)\n\n    def test_hankl2e(self):\n        hank2e = special.hankel2e(1,.1)\n        hankrl2e = special.hankel2e(1,.1)\n        assert_almost_equal(hank2e,hankrl2e,8)\n\n\nclass TestHyper:\n    def test_h1vp(self):\n        h1 = special.h1vp(1,.1)\n        h1real = (special.jvp(1,.1) + special.yvp(1,.1)*1j)\n        assert_almost_equal(h1,h1real,8)\n\n    def test_h2vp(self):\n        h2 = special.h2vp(1,.1)\n        h2real = (special.jvp(1,.1) - special.yvp(1,.1)*1j)\n        assert_almost_equal(h2,h2real,8)\n\n    def test_hyp0f1(self):\n        # scalar input\n        assert_allclose(special.hyp0f1(2.5, 0.5), 1.21482702689997, rtol=1e-12)\n        assert_allclose(special.hyp0f1(2.5, 0), 1.0, rtol=1e-15)\n\n        # float input, expected values match mpmath\n        x = special.hyp0f1(3.0, [-1.5, -1, 0, 1, 1.5])\n        expected = np.array([0.58493659229143, 0.70566805723127, 1.0,\n                             1.37789689539747, 1.60373685288480])\n        assert_allclose(x, expected, rtol=1e-12)\n\n        # complex input\n        x = special.hyp0f1(3.0, np.array([-1.5, -1, 0, 1, 1.5]) + 0.j)\n        assert_allclose(x, expected.astype(complex), rtol=1e-12)\n\n        # test broadcasting\n        x1 = [0.5, 1.5, 2.5]\n        x2 = [0, 1, 0.5]\n        x = special.hyp0f1(x1, x2)\n        expected = [1.0, 1.8134302039235093, 1.21482702689997]\n        assert_allclose(x, expected, rtol=1e-12)\n        x = special.hyp0f1(np.row_stack([x1] * 2), x2)\n        assert_allclose(x, np.row_stack([expected] * 2), rtol=1e-12)\n        assert_raises(ValueError, special.hyp0f1,\n                      np.row_stack([x1] * 3), [0, 1])\n\n    def test_hyp0f1_gh5764(self):\n        # Just checks the point that failed; there's a more systematic\n        # test in test_mpmath\n        res = special.hyp0f1(0.8, 0.5 + 0.5*1J)\n        # The expected value was generated using mpmath\n        assert_almost_equal(res, 1.6139719776441115 + 1J*0.80893054061790665)\n\n    def test_hyp1f1(self):\n        hyp1 = special.hyp1f1(.1,.1,.3)\n        assert_almost_equal(hyp1, 1.3498588075760032,7)\n\n        # test contributed by Moritz Deger (2008-05-29)\n        # https://github.com/scipy/scipy/issues/1186 (Trac #659)\n\n        # reference data obtained from mathematica [ a, b, x, m(a,b,x)]:\n        # produced with test_hyp1f1.nb\n        ref_data = array([[-8.38132975e+00, -1.28436461e+01, -2.91081397e+01, 1.04178330e+04],\n                          [2.91076882e+00, -6.35234333e+00, -1.27083993e+01, 6.68132725e+00],\n                          [-1.42938258e+01, 1.80869131e-01, 1.90038728e+01, 1.01385897e+05],\n                          [5.84069088e+00, 1.33187908e+01, 2.91290106e+01, 1.59469411e+08],\n                          [-2.70433202e+01, -1.16274873e+01, -2.89582384e+01, 1.39900152e+24],\n                          [4.26344966e+00, -2.32701773e+01, 1.91635759e+01, 6.13816915e+21],\n                          [1.20514340e+01, -3.40260240e+00, 7.26832235e+00, 1.17696112e+13],\n                          [2.77372955e+01, -1.99424687e+00, 3.61332246e+00, 3.07419615e+13],\n                          [1.50310939e+01, -2.91198675e+01, -1.53581080e+01, -3.79166033e+02],\n                          [1.43995827e+01, 9.84311196e+00, 1.93204553e+01, 2.55836264e+10],\n                          [-4.08759686e+00, 1.34437025e+01, -1.42072843e+01, 1.70778449e+01],\n                          [8.05595738e+00, -1.31019838e+01, 1.52180721e+01, 3.06233294e+21],\n                          [1.81815804e+01, -1.42908793e+01, 9.57868793e+00, -2.84771348e+20],\n                          [-2.49671396e+01, 1.25082843e+01, -1.71562286e+01, 2.36290426e+07],\n                          [2.67277673e+01, 1.70315414e+01, 6.12701450e+00, 7.77917232e+03],\n                          [2.49565476e+01, 2.91694684e+01, 6.29622660e+00, 2.35300027e+02],\n                          [6.11924542e+00, -1.59943768e+00, 9.57009289e+00, 1.32906326e+11],\n                          [-1.47863653e+01, 2.41691301e+01, -1.89981821e+01, 2.73064953e+03],\n                          [2.24070483e+01, -2.93647433e+00, 8.19281432e+00, -6.42000372e+17],\n                          [8.04042600e-01, 1.82710085e+01, -1.97814534e+01, 5.48372441e-01],\n                          [1.39590390e+01, 1.97318686e+01, 2.37606635e+00, 5.51923681e+00],\n                          [-4.66640483e+00, -2.00237930e+01, 7.40365095e+00, 4.50310752e+00],\n                          [2.76821999e+01, -6.36563968e+00, 1.11533984e+01, -9.28725179e+23],\n                          [-2.56764457e+01, 1.24544906e+00, 1.06407572e+01, 1.25922076e+01],\n                          [3.20447808e+00, 1.30874383e+01, 2.26098014e+01, 2.03202059e+04],\n                          [-1.24809647e+01, 4.15137113e+00, -2.92265700e+01, 2.39621411e+08],\n                          [2.14778108e+01, -2.35162960e+00, -1.13758664e+01, 4.46882152e-01],\n                          [-9.85469168e+00, -3.28157680e+00, 1.67447548e+01, -1.07342390e+07],\n                          [1.08122310e+01, -2.47353236e+01, -1.15622349e+01, -2.91733796e+03],\n                          [-2.67933347e+01, -3.39100709e+00, 2.56006986e+01, -5.29275382e+09],\n                          [-8.60066776e+00, -8.02200924e+00, 1.07231926e+01, 1.33548320e+06],\n                          [-1.01724238e-01, -1.18479709e+01, -2.55407104e+01, 1.55436570e+00],\n                          [-3.93356771e+00, 2.11106818e+01, -2.57598485e+01, 2.13467840e+01],\n                          [3.74750503e+00, 1.55687633e+01, -2.92841720e+01, 1.43873509e-02],\n                          [6.99726781e+00, 2.69855571e+01, -1.63707771e+01, 3.08098673e-02],\n                          [-2.31996011e+01, 3.47631054e+00, 9.75119815e-01, 1.79971073e-02],\n                          [2.38951044e+01, -2.91460190e+01, -2.50774708e+00, 9.56934814e+00],\n                          [1.52730825e+01, 5.77062507e+00, 1.21922003e+01, 1.32345307e+09],\n                          [1.74673917e+01, 1.89723426e+01, 4.94903250e+00, 9.90859484e+01],\n                          [1.88971241e+01, 2.86255413e+01, 5.52360109e-01, 1.44165360e+00],\n                          [1.02002319e+01, -1.66855152e+01, -2.55426235e+01, 6.56481554e+02],\n                          [-1.79474153e+01, 1.22210200e+01, -1.84058212e+01, 8.24041812e+05],\n                          [-1.36147103e+01, 1.32365492e+00, -7.22375200e+00, 9.92446491e+05],\n                          [7.57407832e+00, 2.59738234e+01, -1.34139168e+01, 3.64037761e-02],\n                          [2.21110169e+00, 1.28012666e+01, 1.62529102e+01, 1.33433085e+02],\n                          [-2.64297569e+01, -1.63176658e+01, -1.11642006e+01, -2.44797251e+13],\n                          [-2.46622944e+01, -3.02147372e+00, 8.29159315e+00, -3.21799070e+05],\n                          [-1.37215095e+01, -1.96680183e+01, 2.91940118e+01, 3.21457520e+12],\n                          [-5.45566105e+00, 2.81292086e+01, 1.72548215e-01, 9.66973000e-01],\n                          [-1.55751298e+00, -8.65703373e+00, 2.68622026e+01, -3.17190834e+16],\n                          [2.45393609e+01, -2.70571903e+01, 1.96815505e+01, 1.80708004e+37],\n                          [5.77482829e+00, 1.53203143e+01, 2.50534322e+01, 1.14304242e+06],\n                          [-1.02626819e+01, 2.36887658e+01, -2.32152102e+01, 7.28965646e+02],\n                          [-1.30833446e+00, -1.28310210e+01, 1.87275544e+01, -9.33487904e+12],\n                          [5.83024676e+00, -1.49279672e+01, 2.44957538e+01, -7.61083070e+27],\n                          [-2.03130747e+01, 2.59641715e+01, -2.06174328e+01, 4.54744859e+04],\n                          [1.97684551e+01, -2.21410519e+01, -2.26728740e+01, 3.53113026e+06],\n                          [2.73673444e+01, 2.64491725e+01, 1.57599882e+01, 1.07385118e+07],\n                          [5.73287971e+00, 1.21111904e+01, 1.33080171e+01, 2.63220467e+03],\n                          [-2.82751072e+01, 2.08605881e+01, 9.09838900e+00, -6.60957033e-07],\n                          [1.87270691e+01, -1.74437016e+01, 1.52413599e+01, 6.59572851e+27],\n                          [6.60681457e+00, -2.69449855e+00, 9.78972047e+00, -2.38587870e+12],\n                          [1.20895561e+01, -2.51355765e+01, 2.30096101e+01, 7.58739886e+32],\n                          [-2.44682278e+01, 2.10673441e+01, -1.36705538e+01, 4.54213550e+04],\n                          [-4.50665152e+00, 3.72292059e+00, -4.83403707e+00, 2.68938214e+01],\n                          [-7.46540049e+00, -1.08422222e+01, -1.72203805e+01, -2.09402162e+02],\n                          [-2.00307551e+01, -7.50604431e+00, -2.78640020e+01, 4.15985444e+19],\n                          [1.99890876e+01, 2.20677419e+01, -2.51301778e+01, 1.23840297e-09],\n                          [2.03183823e+01, -7.66942559e+00, 2.10340070e+01, 1.46285095e+31],\n                          [-2.90315825e+00, -2.55785967e+01, -9.58779316e+00, 2.65714264e-01],\n                          [2.73960829e+01, -1.80097203e+01, -2.03070131e+00, 2.52908999e+02],\n                          [-2.11708058e+01, -2.70304032e+01, 2.48257944e+01, 3.09027527e+08],\n                          [2.21959758e+01, 4.00258675e+00, -1.62853977e+01, -9.16280090e-09],\n                          [1.61661840e+01, -2.26845150e+01, 2.17226940e+01, -8.24774394e+33],\n                          [-3.35030306e+00, 1.32670581e+00, 9.39711214e+00, -1.47303163e+01],\n                          [7.23720726e+00, -2.29763909e+01, 2.34709682e+01, -9.20711735e+29],\n                          [2.71013568e+01, 1.61951087e+01, -7.11388906e-01, 2.98750911e-01],\n                          [8.40057933e+00, -7.49665220e+00, 2.95587388e+01, 6.59465635e+29],\n                          [-1.51603423e+01, 1.94032322e+01, -7.60044357e+00, 1.05186941e+02],\n                          [-8.83788031e+00, -2.72018313e+01, 1.88269907e+00, 1.81687019e+00],\n                          [-1.87283712e+01, 5.87479570e+00, -1.91210203e+01, 2.52235612e+08],\n                          [-5.61338513e-01, 2.69490237e+01, 1.16660111e-01, 9.97567783e-01],\n                          [-5.44354025e+00, -1.26721408e+01, -4.66831036e+00, 1.06660735e-01],\n                          [-2.18846497e+00, 2.33299566e+01, 9.62564397e+00, 3.03842061e-01],\n                          [6.65661299e+00, -2.39048713e+01, 1.04191807e+01, 4.73700451e+13],\n                          [-2.57298921e+01, -2.60811296e+01, 2.74398110e+01, -5.32566307e+11],\n                          [-1.11431826e+01, -1.59420160e+01, -1.84880553e+01, -1.01514747e+02],\n                          [6.50301931e+00, 2.59859051e+01, -2.33270137e+01, 1.22760500e-02],\n                          [-1.94987891e+01, -2.62123262e+01, 3.90323225e+00, 1.71658894e+01],\n                          [7.26164601e+00, -1.41469402e+01, 2.81499763e+01, -2.50068329e+31],\n                          [-1.52424040e+01, 2.99719005e+01, -2.85753678e+01, 1.31906693e+04],\n                          [5.24149291e+00, -1.72807223e+01, 2.22129493e+01, 2.50748475e+25],\n                          [3.63207230e-01, -9.54120862e-02, -2.83874044e+01, 9.43854939e-01],\n                          [-2.11326457e+00, -1.25707023e+01, 1.17172130e+00, 1.20812698e+00],\n                          [2.48513582e+00, 1.03652647e+01, -1.84625148e+01, 6.47910997e-02],\n                          [2.65395942e+01, 2.74794672e+01, 1.29413428e+01, 2.89306132e+05],\n                          [-9.49445460e+00, 1.59930921e+01, -1.49596331e+01, 3.27574841e+02],\n                          [-5.89173945e+00, 9.96742426e+00, 2.60318889e+01, -3.15842908e-01],\n                          [-1.15387239e+01, -2.21433107e+01, -2.17686413e+01, 1.56724718e-01],\n                          [-5.30592244e+00, -2.42752190e+01, 1.29734035e+00, 1.31985534e+00]])\n\n        for a,b,c,expected in ref_data:\n            result = special.hyp1f1(a,b,c)\n            assert_(abs(expected - result)/expected < 1e-4)\n\n    def test_hyp1f1_gh2957(self):\n        hyp1 = special.hyp1f1(0.5, 1.5, -709.7827128933)\n        hyp2 = special.hyp1f1(0.5, 1.5, -709.7827128934)\n        assert_almost_equal(hyp1, hyp2, 12)\n\n    def test_hyp1f1_gh2282(self):\n        hyp = special.hyp1f1(0.5, 1.5, -1000)\n        assert_almost_equal(hyp, 0.028024956081989643, 12)\n\n    def test_hyp2f1(self):\n        # a collection of special cases taken from AMS 55\n        values = [[0.5, 1, 1.5, 0.2**2, 0.5/0.2*log((1+0.2)/(1-0.2))],\n                  [0.5, 1, 1.5, -0.2**2, 1./0.2*arctan(0.2)],\n                  [1, 1, 2, 0.2, -1/0.2*log(1-0.2)],\n                  [3, 3.5, 1.5, 0.2**2,\n                      0.5/0.2/(-5)*((1+0.2)**(-5)-(1-0.2)**(-5))],\n                  [-3, 3, 0.5, sin(0.2)**2, cos(2*3*0.2)],\n                  [3, 4, 8, 1, special.gamma(8)*special.gamma(8-4-3)/special.gamma(8-3)/special.gamma(8-4)],\n                  [3, 2, 3-2+1, -1, 1./2**3*sqrt(pi) *\n                      special.gamma(1+3-2)/special.gamma(1+0.5*3-2)/special.gamma(0.5+0.5*3)],\n                  [5, 2, 5-2+1, -1, 1./2**5*sqrt(pi) *\n                      special.gamma(1+5-2)/special.gamma(1+0.5*5-2)/special.gamma(0.5+0.5*5)],\n                  [4, 0.5+4, 1.5-2*4, -1./3, (8./9)**(-2*4)*special.gamma(4./3) *\n                      special.gamma(1.5-2*4)/special.gamma(3./2)/special.gamma(4./3-2*4)],\n                  # and some others\n                  # ticket #424\n                  [1.5, -0.5, 1.0, -10.0, 4.1300097765277476484],\n                  # negative integer a or b, with c-a-b integer and x > 0.9\n                  [-2,3,1,0.95,0.715],\n                  [2,-3,1,0.95,-0.007],\n                  [-6,3,1,0.95,0.0000810625],\n                  [2,-5,1,0.95,-0.000029375],\n                  # huge negative integers\n                  (10, -900, 10.5, 0.99, 1.91853705796607664803709475658e-24),\n                  (10, -900, -10.5, 0.99, 3.54279200040355710199058559155e-18),\n                  ]\n        for i, (a, b, c, x, v) in enumerate(values):\n            cv = special.hyp2f1(a, b, c, x)\n            assert_almost_equal(cv, v, 8, err_msg='test #%d' % i)\n\n    def test_hyperu(self):\n        val1 = special.hyperu(1,0.1,100)\n        assert_almost_equal(val1,0.0098153,7)\n        a,b = [0.3,0.6,1.2,-2.7],[1.5,3.2,-0.4,-3.2]\n        a,b = asarray(a), asarray(b)\n        z = 0.5\n        hypu = special.hyperu(a,b,z)\n        hprl = (pi/sin(pi*b))*(special.hyp1f1(a,b,z) /\n                               (special.gamma(1+a-b)*special.gamma(b)) -\n                               z**(1-b)*special.hyp1f1(1+a-b,2-b,z)\n                               / (special.gamma(a)*special.gamma(2-b)))\n        assert_array_almost_equal(hypu,hprl,12)\n\n    def test_hyperu_gh2287(self):\n        assert_almost_equal(special.hyperu(1, 1.5, 20.2),\n                            0.048360918656699191, 12)\n\n\nclass TestBessel:\n    def test_itj0y0(self):\n        it0 = array(special.itj0y0(.2))\n        assert_array_almost_equal(it0,array([0.19933433254006822, -0.34570883800412566]),8)\n\n    def test_it2j0y0(self):\n        it2 = array(special.it2j0y0(.2))\n        assert_array_almost_equal(it2,array([0.0049937546274601858, -0.43423067011231614]),8)\n\n    def test_negv_iv(self):\n        assert_equal(special.iv(3,2), special.iv(-3,2))\n\n    def test_j0(self):\n        oz = special.j0(.1)\n        ozr = special.jn(0,.1)\n        assert_almost_equal(oz,ozr,8)\n\n    def test_j1(self):\n        o1 = special.j1(.1)\n        o1r = special.jn(1,.1)\n        assert_almost_equal(o1,o1r,8)\n\n    def test_jn(self):\n        jnnr = special.jn(1,.2)\n        assert_almost_equal(jnnr,0.099500832639235995,8)\n\n    def test_negv_jv(self):\n        assert_almost_equal(special.jv(-3,2), -special.jv(3,2), 14)\n\n    def test_jv(self):\n        values = [[0, 0.1, 0.99750156206604002],\n                  [2./3, 1e-8, 0.3239028506761532e-5],\n                  [2./3, 1e-10, 0.1503423854873779e-6],\n                  [3.1, 1e-10, 0.1711956265409013e-32],\n                  [2./3, 4.0, -0.2325440850267039],\n                  ]\n        for i, (v, x, y) in enumerate(values):\n            yc = special.jv(v, x)\n            assert_almost_equal(yc, y, 8, err_msg='test #%d' % i)\n\n    def test_negv_jve(self):\n        assert_almost_equal(special.jve(-3,2), -special.jve(3,2), 14)\n\n    def test_jve(self):\n        jvexp = special.jve(1,.2)\n        assert_almost_equal(jvexp,0.099500832639235995,8)\n        jvexp1 = special.jve(1,.2+1j)\n        z = .2+1j\n        jvexpr = special.jv(1,z)*exp(-abs(z.imag))\n        assert_almost_equal(jvexp1,jvexpr,8)\n\n    def test_jn_zeros(self):\n        jn0 = special.jn_zeros(0,5)\n        jn1 = special.jn_zeros(1,5)\n        assert_array_almost_equal(jn0,array([2.4048255577,\n                                              5.5200781103,\n                                              8.6537279129,\n                                              11.7915344391,\n                                              14.9309177086]),4)\n        assert_array_almost_equal(jn1,array([3.83171,\n                                              7.01559,\n                                              10.17347,\n                                              13.32369,\n                                              16.47063]),4)\n\n        jn102 = special.jn_zeros(102,5)\n        assert_allclose(jn102, array([110.89174935992040343,\n                                       117.83464175788308398,\n                                       123.70194191713507279,\n                                       129.02417238949092824,\n                                       134.00114761868422559]), rtol=1e-13)\n\n        jn301 = special.jn_zeros(301,5)\n        assert_allclose(jn301, array([313.59097866698830153,\n                                       323.21549776096288280,\n                                       331.22338738656748796,\n                                       338.39676338872084500,\n                                       345.03284233056064157]), rtol=1e-13)\n\n    def test_jn_zeros_slow(self):\n        jn0 = special.jn_zeros(0, 300)\n        assert_allclose(jn0[260-1], 816.02884495068867280, rtol=1e-13)\n        assert_allclose(jn0[280-1], 878.86068707124422606, rtol=1e-13)\n        assert_allclose(jn0[300-1], 941.69253065317954064, rtol=1e-13)\n\n        jn10 = special.jn_zeros(10, 300)\n        assert_allclose(jn10[260-1], 831.67668514305631151, rtol=1e-13)\n        assert_allclose(jn10[280-1], 894.51275095371316931, rtol=1e-13)\n        assert_allclose(jn10[300-1], 957.34826370866539775, rtol=1e-13)\n\n        jn3010 = special.jn_zeros(3010,5)\n        assert_allclose(jn3010, array([3036.86590780927,\n                                        3057.06598526482,\n                                        3073.66360690272,\n                                        3088.37736494778,\n                                        3101.86438139042]), rtol=1e-8)\n\n    def test_jnjnp_zeros(self):\n        jn = special.jn\n\n        def jnp(n, x):\n            return (jn(n-1,x) - jn(n+1,x))/2\n        for nt in range(1, 30):\n            z, n, m, t = special.jnjnp_zeros(nt)\n            for zz, nn, tt in zip(z, n, t):\n                if tt == 0:\n                    assert_allclose(jn(nn, zz), 0, atol=1e-6)\n                elif tt == 1:\n                    assert_allclose(jnp(nn, zz), 0, atol=1e-6)\n                else:\n                    raise AssertionError(\"Invalid t return for nt=%d\" % nt)\n\n    def test_jnp_zeros(self):\n        jnp = special.jnp_zeros(1,5)\n        assert_array_almost_equal(jnp, array([1.84118,\n                                                5.33144,\n                                                8.53632,\n                                                11.70600,\n                                                14.86359]),4)\n        jnp = special.jnp_zeros(443,5)\n        assert_allclose(special.jvp(443, jnp), 0, atol=1e-15)\n\n    def test_jnyn_zeros(self):\n        jnz = special.jnyn_zeros(1,5)\n        assert_array_almost_equal(jnz,(array([3.83171,\n                                                7.01559,\n                                                10.17347,\n                                                13.32369,\n                                                16.47063]),\n                                       array([1.84118,\n                                                5.33144,\n                                                8.53632,\n                                                11.70600,\n                                                14.86359]),\n                                       array([2.19714,\n                                                5.42968,\n                                                8.59601,\n                                                11.74915,\n                                                14.89744]),\n                                       array([3.68302,\n                                                6.94150,\n                                                10.12340,\n                                                13.28576,\n                                                16.44006])),5)\n\n    def test_jvp(self):\n        jvprim = special.jvp(2,2)\n        jv0 = (special.jv(1,2)-special.jv(3,2))/2\n        assert_almost_equal(jvprim,jv0,10)\n\n    def test_k0(self):\n        ozk = special.k0(.1)\n        ozkr = special.kv(0,.1)\n        assert_almost_equal(ozk,ozkr,8)\n\n    def test_k0e(self):\n        ozke = special.k0e(.1)\n        ozker = special.kve(0,.1)\n        assert_almost_equal(ozke,ozker,8)\n\n    def test_k1(self):\n        o1k = special.k1(.1)\n        o1kr = special.kv(1,.1)\n        assert_almost_equal(o1k,o1kr,8)\n\n    def test_k1e(self):\n        o1ke = special.k1e(.1)\n        o1ker = special.kve(1,.1)\n        assert_almost_equal(o1ke,o1ker,8)\n\n    def test_jacobi(self):\n        a = 5*np.random.random() - 1\n        b = 5*np.random.random() - 1\n        P0 = special.jacobi(0,a,b)\n        P1 = special.jacobi(1,a,b)\n        P2 = special.jacobi(2,a,b)\n        P3 = special.jacobi(3,a,b)\n\n        assert_array_almost_equal(P0.c,[1],13)\n        assert_array_almost_equal(P1.c,array([a+b+2,a-b])/2.0,13)\n        cp = [(a+b+3)*(a+b+4), 4*(a+b+3)*(a+2), 4*(a+1)*(a+2)]\n        p2c = [cp[0],cp[1]-2*cp[0],cp[2]-cp[1]+cp[0]]\n        assert_array_almost_equal(P2.c,array(p2c)/8.0,13)\n        cp = [(a+b+4)*(a+b+5)*(a+b+6),6*(a+b+4)*(a+b+5)*(a+3),\n              12*(a+b+4)*(a+2)*(a+3),8*(a+1)*(a+2)*(a+3)]\n        p3c = [cp[0],cp[1]-3*cp[0],cp[2]-2*cp[1]+3*cp[0],cp[3]-cp[2]+cp[1]-cp[0]]\n        assert_array_almost_equal(P3.c,array(p3c)/48.0,13)\n\n    def test_kn(self):\n        kn1 = special.kn(0,.2)\n        assert_almost_equal(kn1,1.7527038555281462,8)\n\n    def test_negv_kv(self):\n        assert_equal(special.kv(3.0, 2.2), special.kv(-3.0, 2.2))\n\n    def test_kv0(self):\n        kv0 = special.kv(0,.2)\n        assert_almost_equal(kv0, 1.7527038555281462, 10)\n\n    def test_kv1(self):\n        kv1 = special.kv(1,0.2)\n        assert_almost_equal(kv1, 4.775972543220472, 10)\n\n    def test_kv2(self):\n        kv2 = special.kv(2,0.2)\n        assert_almost_equal(kv2, 49.51242928773287, 10)\n\n    def test_kn_largeorder(self):\n        assert_allclose(special.kn(32, 1), 1.7516596664574289e+43)\n\n    def test_kv_largearg(self):\n        assert_equal(special.kv(0, 1e19), 0)\n\n    def test_negv_kve(self):\n        assert_equal(special.kve(3.0, 2.2), special.kve(-3.0, 2.2))\n\n    def test_kve(self):\n        kve1 = special.kve(0,.2)\n        kv1 = special.kv(0,.2)*exp(.2)\n        assert_almost_equal(kve1,kv1,8)\n        z = .2+1j\n        kve2 = special.kve(0,z)\n        kv2 = special.kv(0,z)*exp(z)\n        assert_almost_equal(kve2,kv2,8)\n\n    def test_kvp_v0n1(self):\n        z = 2.2\n        assert_almost_equal(-special.kv(1,z), special.kvp(0,z, n=1), 10)\n\n    def test_kvp_n1(self):\n        v = 3.\n        z = 2.2\n        xc = -special.kv(v+1,z) + v/z*special.kv(v,z)\n        x = special.kvp(v,z, n=1)\n        assert_almost_equal(xc, x, 10)   # this function (kvp) is broken\n\n    def test_kvp_n2(self):\n        v = 3.\n        z = 2.2\n        xc = (z**2+v**2-v)/z**2 * special.kv(v,z) + special.kv(v+1,z)/z\n        x = special.kvp(v, z, n=2)\n        assert_almost_equal(xc, x, 10)\n\n    def test_y0(self):\n        oz = special.y0(.1)\n        ozr = special.yn(0,.1)\n        assert_almost_equal(oz,ozr,8)\n\n    def test_y1(self):\n        o1 = special.y1(.1)\n        o1r = special.yn(1,.1)\n        assert_almost_equal(o1,o1r,8)\n\n    def test_y0_zeros(self):\n        yo,ypo = special.y0_zeros(2)\n        zo,zpo = special.y0_zeros(2,complex=1)\n        all = r_[yo,zo]\n        allval = r_[ypo,zpo]\n        assert_array_almost_equal(abs(special.yv(0.0,all)),0.0,11)\n        assert_array_almost_equal(abs(special.yv(1,all)-allval),0.0,11)\n\n    def test_y1_zeros(self):\n        y1 = special.y1_zeros(1)\n        assert_array_almost_equal(y1,(array([2.19714]),array([0.52079])),5)\n\n    def test_y1p_zeros(self):\n        y1p = special.y1p_zeros(1,complex=1)\n        assert_array_almost_equal(y1p,(array([0.5768+0.904j]), array([-0.7635+0.5892j])),3)\n\n    def test_yn_zeros(self):\n        an = special.yn_zeros(4,2)\n        assert_array_almost_equal(an,array([5.64515, 9.36162]),5)\n        an = special.yn_zeros(443,5)\n        assert_allclose(an, [450.13573091578090314, 463.05692376675001542,\n                              472.80651546418663566, 481.27353184725625838,\n                              488.98055964441374646], rtol=1e-15)\n\n    def test_ynp_zeros(self):\n        ao = special.ynp_zeros(0,2)\n        assert_array_almost_equal(ao,array([2.19714133, 5.42968104]),6)\n        ao = special.ynp_zeros(43,5)\n        assert_allclose(special.yvp(43, ao), 0, atol=1e-15)\n        ao = special.ynp_zeros(443,5)\n        assert_allclose(special.yvp(443, ao), 0, atol=1e-9)\n\n    def test_ynp_zeros_large_order(self):\n        ao = special.ynp_zeros(443,5)\n        assert_allclose(special.yvp(443, ao), 0, atol=1e-14)\n\n    def test_yn(self):\n        yn2n = special.yn(1,.2)\n        assert_almost_equal(yn2n,-3.3238249881118471,8)\n\n    def test_negv_yv(self):\n        assert_almost_equal(special.yv(-3,2), -special.yv(3,2), 14)\n\n    def test_yv(self):\n        yv2 = special.yv(1,.2)\n        assert_almost_equal(yv2,-3.3238249881118471,8)\n\n    def test_negv_yve(self):\n        assert_almost_equal(special.yve(-3,2), -special.yve(3,2), 14)\n\n    def test_yve(self):\n        yve2 = special.yve(1,.2)\n        assert_almost_equal(yve2,-3.3238249881118471,8)\n        yve2r = special.yv(1,.2+1j)*exp(-1)\n        yve22 = special.yve(1,.2+1j)\n        assert_almost_equal(yve22,yve2r,8)\n\n    def test_yvp(self):\n        yvpr = (special.yv(1,.2) - special.yv(3,.2))/2.0\n        yvp1 = special.yvp(2,.2)\n        assert_array_almost_equal(yvp1,yvpr,10)\n\n    def _cephes_vs_amos_points(self):\n        \"\"\"Yield points at which to compare Cephes implementation to AMOS\"\"\"\n        # check several points, including large-amplitude ones\n        v = [-120, -100.3, -20., -10., -1., -.5, 0., 1., 12.49, 120., 301]\n        z = [-1300, -11, -10, -1, 1., 10., 200.5, 401., 600.5, 700.6, 1300,\n             10003]\n        yield from itertools.product(v, z)\n\n        # check half-integers; these are problematic points at least\n        # for cephes/iv\n        yield from itertools.product(0.5 + arange(-60, 60), [3.5])\n\n    def check_cephes_vs_amos(self, f1, f2, rtol=1e-11, atol=0, skip=None):\n        for v, z in self._cephes_vs_amos_points():\n            if skip is not None and skip(v, z):\n                continue\n            c1, c2, c3 = f1(v, z), f1(v,z+0j), f2(int(v), z)\n            if np.isinf(c1):\n                assert_(np.abs(c2) >= 1e300, (v, z))\n            elif np.isnan(c1):\n                assert_(c2.imag != 0, (v, z))\n            else:\n                assert_allclose(c1, c2, err_msg=(v, z), rtol=rtol, atol=atol)\n                if v == int(v):\n                    assert_allclose(c3, c2, err_msg=(v, z),\n                                     rtol=rtol, atol=atol)\n\n    @pytest.mark.xfail(platform.machine() == 'ppc64le',\n                       reason=\"fails on ppc64le\")\n    def test_jv_cephes_vs_amos(self):\n        self.check_cephes_vs_amos(special.jv, special.jn, rtol=1e-10, atol=1e-305)\n\n    @pytest.mark.xfail(platform.machine() == 'ppc64le',\n                       reason=\"fails on ppc64le\")\n    def test_yv_cephes_vs_amos(self):\n        self.check_cephes_vs_amos(special.yv, special.yn, rtol=1e-11, atol=1e-305)\n\n    def test_yv_cephes_vs_amos_only_small_orders(self):\n        skipper = lambda v, z: (abs(v) > 50)\n        self.check_cephes_vs_amos(special.yv, special.yn, rtol=1e-11, atol=1e-305, skip=skipper)\n\n    def test_iv_cephes_vs_amos(self):\n        with np.errstate(all='ignore'):\n            self.check_cephes_vs_amos(special.iv, special.iv, rtol=5e-9, atol=1e-305)\n\n    @pytest.mark.slow\n    def test_iv_cephes_vs_amos_mass_test(self):\n        N = 1000000\n        np.random.seed(1)\n        v = np.random.pareto(0.5, N) * (-1)**np.random.randint(2, size=N)\n        x = np.random.pareto(0.2, N) * (-1)**np.random.randint(2, size=N)\n\n        imsk = (np.random.randint(8, size=N) == 0)\n        v[imsk] = v[imsk].astype(int)\n\n        with np.errstate(all='ignore'):\n            c1 = special.iv(v, x)\n            c2 = special.iv(v, x+0j)\n\n            # deal with differences in the inf and zero cutoffs\n            c1[abs(c1) > 1e300] = np.inf\n            c2[abs(c2) > 1e300] = np.inf\n            c1[abs(c1) < 1e-300] = 0\n            c2[abs(c2) < 1e-300] = 0\n\n            dc = abs(c1/c2 - 1)\n            dc[np.isnan(dc)] = 0\n\n        k = np.argmax(dc)\n\n        # Most error apparently comes from AMOS and not our implementation;\n        # there are some problems near integer orders there\n        assert_(dc[k] < 2e-7, (v[k], x[k], special.iv(v[k], x[k]), special.iv(v[k], x[k]+0j)))\n\n    def test_kv_cephes_vs_amos(self):\n        self.check_cephes_vs_amos(special.kv, special.kn, rtol=1e-9, atol=1e-305)\n        self.check_cephes_vs_amos(special.kv, special.kv, rtol=1e-9, atol=1e-305)\n\n    def test_ticket_623(self):\n        assert_allclose(special.jv(3, 4), 0.43017147387562193)\n        assert_allclose(special.jv(301, 1300), 0.0183487151115275)\n        assert_allclose(special.jv(301, 1296.0682), -0.0224174325312048)\n\n    def test_ticket_853(self):\n        \"\"\"Negative-order Bessels\"\"\"\n        # cephes\n        assert_allclose(special.jv(-1, 1), -0.4400505857449335)\n        assert_allclose(special.jv(-2, 1), 0.1149034849319005)\n        assert_allclose(special.yv(-1, 1), 0.7812128213002887)\n        assert_allclose(special.yv(-2, 1), -1.650682606816255)\n        assert_allclose(special.iv(-1, 1), 0.5651591039924851)\n        assert_allclose(special.iv(-2, 1), 0.1357476697670383)\n        assert_allclose(special.kv(-1, 1), 0.6019072301972347)\n        assert_allclose(special.kv(-2, 1), 1.624838898635178)\n        assert_allclose(special.jv(-0.5, 1), 0.43109886801837607952)\n        assert_allclose(special.yv(-0.5, 1), 0.6713967071418031)\n        assert_allclose(special.iv(-0.5, 1), 1.231200214592967)\n        assert_allclose(special.kv(-0.5, 1), 0.4610685044478945)\n        # amos\n        assert_allclose(special.jv(-1, 1+0j), -0.4400505857449335)\n        assert_allclose(special.jv(-2, 1+0j), 0.1149034849319005)\n        assert_allclose(special.yv(-1, 1+0j), 0.7812128213002887)\n        assert_allclose(special.yv(-2, 1+0j), -1.650682606816255)\n\n        assert_allclose(special.iv(-1, 1+0j), 0.5651591039924851)\n        assert_allclose(special.iv(-2, 1+0j), 0.1357476697670383)\n        assert_allclose(special.kv(-1, 1+0j), 0.6019072301972347)\n        assert_allclose(special.kv(-2, 1+0j), 1.624838898635178)\n\n        assert_allclose(special.jv(-0.5, 1+0j), 0.43109886801837607952)\n        assert_allclose(special.jv(-0.5, 1+1j), 0.2628946385649065-0.827050182040562j)\n        assert_allclose(special.yv(-0.5, 1+0j), 0.6713967071418031)\n        assert_allclose(special.yv(-0.5, 1+1j), 0.967901282890131+0.0602046062142816j)\n\n        assert_allclose(special.iv(-0.5, 1+0j), 1.231200214592967)\n        assert_allclose(special.iv(-0.5, 1+1j), 0.77070737376928+0.39891821043561j)\n        assert_allclose(special.kv(-0.5, 1+0j), 0.4610685044478945)\n        assert_allclose(special.kv(-0.5, 1+1j), 0.06868578341999-0.38157825981268j)\n\n        assert_allclose(special.jve(-0.5,1+0.3j), special.jv(-0.5, 1+0.3j)*exp(-0.3))\n        assert_allclose(special.yve(-0.5,1+0.3j), special.yv(-0.5, 1+0.3j)*exp(-0.3))\n        assert_allclose(special.ive(-0.5,0.3+1j), special.iv(-0.5, 0.3+1j)*exp(-0.3))\n        assert_allclose(special.kve(-0.5,0.3+1j), special.kv(-0.5, 0.3+1j)*exp(0.3+1j))\n\n        assert_allclose(special.hankel1(-0.5, 1+1j), special.jv(-0.5, 1+1j) + 1j*special.yv(-0.5,1+1j))\n        assert_allclose(special.hankel2(-0.5, 1+1j), special.jv(-0.5, 1+1j) - 1j*special.yv(-0.5,1+1j))\n\n    def test_ticket_854(self):\n        \"\"\"Real-valued Bessel domains\"\"\"\n        assert_(isnan(special.jv(0.5, -1)))\n        assert_(isnan(special.iv(0.5, -1)))\n        assert_(isnan(special.yv(0.5, -1)))\n        assert_(isnan(special.yv(1, -1)))\n        assert_(isnan(special.kv(0.5, -1)))\n        assert_(isnan(special.kv(1, -1)))\n        assert_(isnan(special.jve(0.5, -1)))\n        assert_(isnan(special.ive(0.5, -1)))\n        assert_(isnan(special.yve(0.5, -1)))\n        assert_(isnan(special.yve(1, -1)))\n        assert_(isnan(special.kve(0.5, -1)))\n        assert_(isnan(special.kve(1, -1)))\n        assert_(isnan(special.airye(-1)[0:2]).all(), special.airye(-1))\n        assert_(not isnan(special.airye(-1)[2:4]).any(), special.airye(-1))\n\n    def test_gh_7909(self):\n        assert_(special.kv(1.5, 0) == np.inf)\n        assert_(special.kve(1.5, 0) == np.inf)\n\n    def test_ticket_503(self):\n        \"\"\"Real-valued Bessel I overflow\"\"\"\n        assert_allclose(special.iv(1, 700), 1.528500390233901e302)\n        assert_allclose(special.iv(1000, 1120), 1.301564549405821e301)\n\n    def test_iv_hyperg_poles(self):\n        assert_allclose(special.iv(-0.5, 1), 1.231200214592967)\n\n    def iv_series(self, v, z, n=200):\n        k = arange(0, n).astype(float_)\n        r = (v+2*k)*log(.5*z) - special.gammaln(k+1) - special.gammaln(v+k+1)\n        r[isnan(r)] = inf\n        r = exp(r)\n        err = abs(r).max() * finfo(float_).eps * n + abs(r[-1])*10\n        return r.sum(), err\n\n    def test_i0_series(self):\n        for z in [1., 10., 200.5]:\n            value, err = self.iv_series(0, z)\n            assert_allclose(special.i0(z), value, atol=err, err_msg=z)\n\n    def test_i1_series(self):\n        for z in [1., 10., 200.5]:\n            value, err = self.iv_series(1, z)\n            assert_allclose(special.i1(z), value, atol=err, err_msg=z)\n\n    def test_iv_series(self):\n        for v in [-20., -10., -1., 0., 1., 12.49, 120.]:\n            for z in [1., 10., 200.5, -1+2j]:\n                value, err = self.iv_series(v, z)\n                assert_allclose(special.iv(v, z), value, atol=err, err_msg=(v, z))\n\n    def test_i0(self):\n        values = [[0.0, 1.0],\n                  [1e-10, 1.0],\n                  [0.1, 0.9071009258],\n                  [0.5, 0.6450352706],\n                  [1.0, 0.4657596077],\n                  [2.5, 0.2700464416],\n                  [5.0, 0.1835408126],\n                  [20.0, 0.0897803119],\n                  ]\n        for i, (x, v) in enumerate(values):\n            cv = special.i0(x) * exp(-x)\n            assert_almost_equal(cv, v, 8, err_msg='test #%d' % i)\n\n    def test_i0e(self):\n        oize = special.i0e(.1)\n        oizer = special.ive(0,.1)\n        assert_almost_equal(oize,oizer,8)\n\n    def test_i1(self):\n        values = [[0.0, 0.0],\n                  [1e-10, 0.4999999999500000e-10],\n                  [0.1, 0.0452984468],\n                  [0.5, 0.1564208032],\n                  [1.0, 0.2079104154],\n                  [5.0, 0.1639722669],\n                  [20.0, 0.0875062222],\n                  ]\n        for i, (x, v) in enumerate(values):\n            cv = special.i1(x) * exp(-x)\n            assert_almost_equal(cv, v, 8, err_msg='test #%d' % i)\n\n    def test_i1e(self):\n        oi1e = special.i1e(.1)\n        oi1er = special.ive(1,.1)\n        assert_almost_equal(oi1e,oi1er,8)\n\n    def test_iti0k0(self):\n        iti0 = array(special.iti0k0(5))\n        assert_array_almost_equal(iti0,array([31.848667776169801, 1.5673873907283657]),5)\n\n    def test_it2i0k0(self):\n        it2k = special.it2i0k0(.1)\n        assert_array_almost_equal(it2k,array([0.0012503906973464409, 3.3309450354686687]),6)\n\n    def test_iv(self):\n        iv1 = special.iv(0,.1)*exp(-.1)\n        assert_almost_equal(iv1,0.90710092578230106,10)\n\n    def test_negv_ive(self):\n        assert_equal(special.ive(3,2), special.ive(-3,2))\n\n    def test_ive(self):\n        ive1 = special.ive(0,.1)\n        iv1 = special.iv(0,.1)*exp(-.1)\n        assert_almost_equal(ive1,iv1,10)\n\n    def test_ivp0(self):\n        assert_almost_equal(special.iv(1,2), special.ivp(0,2), 10)\n\n    def test_ivp(self):\n        y = (special.iv(0,2) + special.iv(2,2))/2\n        x = special.ivp(1,2)\n        assert_almost_equal(x,y,10)\n\n\nclass TestLaguerre:\n    def test_laguerre(self):\n        lag0 = special.laguerre(0)\n        lag1 = special.laguerre(1)\n        lag2 = special.laguerre(2)\n        lag3 = special.laguerre(3)\n        lag4 = special.laguerre(4)\n        lag5 = special.laguerre(5)\n        assert_array_almost_equal(lag0.c,[1],13)\n        assert_array_almost_equal(lag1.c,[-1,1],13)\n        assert_array_almost_equal(lag2.c,array([1,-4,2])/2.0,13)\n        assert_array_almost_equal(lag3.c,array([-1,9,-18,6])/6.0,13)\n        assert_array_almost_equal(lag4.c,array([1,-16,72,-96,24])/24.0,13)\n        assert_array_almost_equal(lag5.c,array([-1,25,-200,600,-600,120])/120.0,13)\n\n    def test_genlaguerre(self):\n        k = 5*np.random.random() - 0.9\n        lag0 = special.genlaguerre(0,k)\n        lag1 = special.genlaguerre(1,k)\n        lag2 = special.genlaguerre(2,k)\n        lag3 = special.genlaguerre(3,k)\n        assert_equal(lag0.c,[1])\n        assert_equal(lag1.c,[-1,k+1])\n        assert_almost_equal(lag2.c,array([1,-2*(k+2),(k+1.)*(k+2.)])/2.0)\n        assert_almost_equal(lag3.c,array([-1,3*(k+3),-3*(k+2)*(k+3),(k+1)*(k+2)*(k+3)])/6.0)\n\n\n# Base polynomials come from Abrahmowitz and Stegan\nclass TestLegendre:\n    def test_legendre(self):\n        leg0 = special.legendre(0)\n        leg1 = special.legendre(1)\n        leg2 = special.legendre(2)\n        leg3 = special.legendre(3)\n        leg4 = special.legendre(4)\n        leg5 = special.legendre(5)\n        assert_equal(leg0.c, [1])\n        assert_equal(leg1.c, [1,0])\n        assert_almost_equal(leg2.c, array([3,0,-1])/2.0, decimal=13)\n        assert_almost_equal(leg3.c, array([5,0,-3,0])/2.0)\n        assert_almost_equal(leg4.c, array([35,0,-30,0,3])/8.0)\n        assert_almost_equal(leg5.c, array([63,0,-70,0,15,0])/8.0)\n\n\nclass TestLambda:\n    def test_lmbda(self):\n        lam = special.lmbda(1,.1)\n        lamr = (array([special.jn(0,.1), 2*special.jn(1,.1)/.1]),\n                array([special.jvp(0,.1), -2*special.jv(1,.1)/.01 + 2*special.jvp(1,.1)/.1]))\n        assert_array_almost_equal(lam,lamr,8)\n\n\nclass TestLog1p:\n    def test_log1p(self):\n        l1p = (special.log1p(10), special.log1p(11), special.log1p(12))\n        l1prl = (log(11), log(12), log(13))\n        assert_array_almost_equal(l1p,l1prl,8)\n\n    def test_log1pmore(self):\n        l1pm = (special.log1p(1), special.log1p(1.1), special.log1p(1.2))\n        l1pmrl = (log(2),log(2.1),log(2.2))\n        assert_array_almost_equal(l1pm,l1pmrl,8)\n\n\nclass TestLegendreFunctions:\n    def test_clpmn(self):\n        z = 0.5+0.3j\n        clp = special.clpmn(2, 2, z, 3)\n        assert_array_almost_equal(clp,\n                   (array([[1.0000, z, 0.5*(3*z*z-1)],\n                           [0.0000, sqrt(z*z-1), 3*z*sqrt(z*z-1)],\n                           [0.0000, 0.0000, 3*(z*z-1)]]),\n                    array([[0.0000, 1.0000, 3*z],\n                           [0.0000, z/sqrt(z*z-1), 3*(2*z*z-1)/sqrt(z*z-1)],\n                           [0.0000, 0.0000, 6*z]])),\n                    7)\n\n    def test_clpmn_close_to_real_2(self):\n        eps = 1e-10\n        m = 1\n        n = 3\n        x = 0.5\n        clp_plus = special.clpmn(m, n, x+1j*eps, 2)[0][m, n]\n        clp_minus = special.clpmn(m, n, x-1j*eps, 2)[0][m, n]\n        assert_array_almost_equal(array([clp_plus, clp_minus]),\n                                  array([special.lpmv(m, n, x),\n                                         special.lpmv(m, n, x)]),\n                                  7)\n\n    def test_clpmn_close_to_real_3(self):\n        eps = 1e-10\n        m = 1\n        n = 3\n        x = 0.5\n        clp_plus = special.clpmn(m, n, x+1j*eps, 3)[0][m, n]\n        clp_minus = special.clpmn(m, n, x-1j*eps, 3)[0][m, n]\n        assert_array_almost_equal(array([clp_plus, clp_minus]),\n                                  array([special.lpmv(m, n, x)*np.exp(-0.5j*m*np.pi),\n                                         special.lpmv(m, n, x)*np.exp(0.5j*m*np.pi)]),\n                                  7)\n\n    def test_clpmn_across_unit_circle(self):\n        eps = 1e-7\n        m = 1\n        n = 1\n        x = 1j\n        for type in [2, 3]:\n            assert_almost_equal(special.clpmn(m, n, x+1j*eps, type)[0][m, n],\n                            special.clpmn(m, n, x-1j*eps, type)[0][m, n], 6)\n\n    def test_inf(self):\n        for z in (1, -1):\n            for n in range(4):\n                for m in range(1, n):\n                    lp = special.clpmn(m, n, z)\n                    assert_(np.isinf(lp[1][1,1:]).all())\n                    lp = special.lpmn(m, n, z)\n                    assert_(np.isinf(lp[1][1,1:]).all())\n\n    def test_deriv_clpmn(self):\n        # data inside and outside of the unit circle\n        zvals = [0.5+0.5j, -0.5+0.5j, -0.5-0.5j, 0.5-0.5j,\n                 1+1j, -1+1j, -1-1j, 1-1j]\n        m = 2\n        n = 3\n        for type in [2, 3]:\n            for z in zvals:\n                for h in [1e-3, 1e-3j]:\n                    approx_derivative = (special.clpmn(m, n, z+0.5*h, type)[0]\n                                         - special.clpmn(m, n, z-0.5*h, type)[0])/h\n                    assert_allclose(special.clpmn(m, n, z, type)[1],\n                                    approx_derivative,\n                                    rtol=1e-4)\n\n    def test_lpmn(self):\n        lp = special.lpmn(0,2,.5)\n        assert_array_almost_equal(lp,(array([[1.00000,\n                                                      0.50000,\n                                                      -0.12500]]),\n                                      array([[0.00000,\n                                                      1.00000,\n                                                      1.50000]])),4)\n\n    def test_lpn(self):\n        lpnf = special.lpn(2,.5)\n        assert_array_almost_equal(lpnf,(array([1.00000,\n                                                        0.50000,\n                                                        -0.12500]),\n                                      array([0.00000,\n                                                      1.00000,\n                                                      1.50000])),4)\n\n    def test_lpmv(self):\n        lp = special.lpmv(0,2,.5)\n        assert_almost_equal(lp,-0.125,7)\n        lp = special.lpmv(0,40,.001)\n        assert_almost_equal(lp,0.1252678976534484,7)\n\n        # XXX: this is outside the domain of the current implementation,\n        #      so ensure it returns a NaN rather than a wrong answer.\n        with np.errstate(all='ignore'):\n            lp = special.lpmv(-1,-1,.001)\n        assert_(lp != 0 or np.isnan(lp))\n\n    def test_lqmn(self):\n        lqmnf = special.lqmn(0,2,.5)\n        lqf = special.lqn(2,.5)\n        assert_array_almost_equal(lqmnf[0][0],lqf[0],4)\n        assert_array_almost_equal(lqmnf[1][0],lqf[1],4)\n\n    def test_lqmn_gt1(self):\n        \"\"\"algorithm for real arguments changes at 1.0001\n           test against analytical result for m=2, n=1\n        \"\"\"\n        x0 = 1.0001\n        delta = 0.00002\n        for x in (x0-delta, x0+delta):\n            lq = special.lqmn(2, 1, x)[0][-1, -1]\n            expected = 2/(x*x-1)\n            assert_almost_equal(lq, expected)\n\n    def test_lqmn_shape(self):\n        a, b = special.lqmn(4, 4, 1.1)\n        assert_equal(a.shape, (5, 5))\n        assert_equal(b.shape, (5, 5))\n\n        a, b = special.lqmn(4, 0, 1.1)\n        assert_equal(a.shape, (5, 1))\n        assert_equal(b.shape, (5, 1))\n\n    def test_lqn(self):\n        lqf = special.lqn(2,.5)\n        assert_array_almost_equal(lqf,(array([0.5493, -0.7253, -0.8187]),\n                                       array([1.3333, 1.216, -0.8427])),4)\n\n\nclass TestMathieu:\n\n    def test_mathieu_a(self):\n        pass\n\n    def test_mathieu_even_coef(self):\n        special.mathieu_even_coef(2,5)\n        # Q not defined broken and cannot figure out proper reporting order\n\n    def test_mathieu_odd_coef(self):\n        # same problem as above\n        pass\n\n\nclass TestFresnelIntegral:\n\n    def test_modfresnelp(self):\n        pass\n\n    def test_modfresnelm(self):\n        pass\n\n\nclass TestOblCvSeq:\n    def test_obl_cv_seq(self):\n        obl = special.obl_cv_seq(0,3,1)\n        assert_array_almost_equal(obl,array([-0.348602,\n                                              1.393206,\n                                              5.486800,\n                                              11.492120]),5)\n\n\nclass TestParabolicCylinder:\n    def test_pbdn_seq(self):\n        pb = special.pbdn_seq(1,.1)\n        assert_array_almost_equal(pb,(array([0.9975,\n                                              0.0998]),\n                                      array([-0.0499,\n                                             0.9925])),4)\n\n    def test_pbdv(self):\n        special.pbdv(1,.2)\n        1/2*(.2)*special.pbdv(1,.2)[0] - special.pbdv(0,.2)[0]\n\n    def test_pbdv_seq(self):\n        pbn = special.pbdn_seq(1,.1)\n        pbv = special.pbdv_seq(1,.1)\n        assert_array_almost_equal(pbv,(real(pbn[0]),real(pbn[1])),4)\n\n    def test_pbdv_points(self):\n        # simple case\n        eta = np.linspace(-10, 10, 5)\n        z = 2**(eta/2)*np.sqrt(np.pi)/special.gamma(.5-.5*eta)\n        assert_allclose(special.pbdv(eta, 0.)[0], z, rtol=1e-14, atol=1e-14)\n\n        # some points\n        assert_allclose(special.pbdv(10.34, 20.44)[0], 1.3731383034455e-32, rtol=1e-12)\n        assert_allclose(special.pbdv(-9.53, 3.44)[0], 3.166735001119246e-8, rtol=1e-12)\n\n    def test_pbdv_gradient(self):\n        x = np.linspace(-4, 4, 8)[:,None]\n        eta = np.linspace(-10, 10, 5)[None,:]\n\n        p = special.pbdv(eta, x)\n        eps = 1e-7 + 1e-7*abs(x)\n        dp = (special.pbdv(eta, x + eps)[0] - special.pbdv(eta, x - eps)[0]) / eps / 2.\n        assert_allclose(p[1], dp, rtol=1e-6, atol=1e-6)\n\n    def test_pbvv_gradient(self):\n        x = np.linspace(-4, 4, 8)[:,None]\n        eta = np.linspace(-10, 10, 5)[None,:]\n\n        p = special.pbvv(eta, x)\n        eps = 1e-7 + 1e-7*abs(x)\n        dp = (special.pbvv(eta, x + eps)[0] - special.pbvv(eta, x - eps)[0]) / eps / 2.\n        assert_allclose(p[1], dp, rtol=1e-6, atol=1e-6)\n\n\nclass TestPolygamma:\n    # from Table 6.2 (pg. 271) of A&S\n    def test_polygamma(self):\n        poly2 = special.polygamma(2,1)\n        poly3 = special.polygamma(3,1)\n        assert_almost_equal(poly2,-2.4041138063,10)\n        assert_almost_equal(poly3,6.4939394023,10)\n\n        # Test polygamma(0, x) == psi(x)\n        x = [2, 3, 1.1e14]\n        assert_almost_equal(special.polygamma(0, x), special.psi(x))\n\n        # Test broadcasting\n        n = [0, 1, 2]\n        x = [0.5, 1.5, 2.5]\n        expected = [-1.9635100260214238, 0.93480220054467933,\n                    -0.23620405164172739]\n        assert_almost_equal(special.polygamma(n, x), expected)\n        expected = np.row_stack([expected]*2)\n        assert_almost_equal(special.polygamma(n, np.row_stack([x]*2)),\n                            expected)\n        assert_almost_equal(special.polygamma(np.row_stack([n]*2), x),\n                            expected)\n\n\nclass TestProCvSeq:\n    def test_pro_cv_seq(self):\n        prol = special.pro_cv_seq(0,3,1)\n        assert_array_almost_equal(prol,array([0.319000,\n                                               2.593084,\n                                               6.533471,\n                                               12.514462]),5)\n\n\nclass TestPsi:\n    def test_psi(self):\n        ps = special.psi(1)\n        assert_almost_equal(ps,-0.57721566490153287,8)\n\n\nclass TestRadian:\n    def test_radian(self):\n        rad = special.radian(90,0,0)\n        assert_almost_equal(rad,pi/2.0,5)\n\n    def test_radianmore(self):\n        rad1 = special.radian(90,1,60)\n        assert_almost_equal(rad1,pi/2+0.0005816135199345904,5)\n\n\nclass TestRiccati:\n    def test_riccati_jn(self):\n        N, x = 2, 0.2\n        S = np.empty((N, N))\n        for n in range(N):\n            j = special.spherical_jn(n, x)\n            jp = special.spherical_jn(n, x, derivative=True)\n            S[0,n] = x*j\n            S[1,n] = x*jp + j\n        assert_array_almost_equal(S, special.riccati_jn(n, x), 8)\n\n    def test_riccati_yn(self):\n        N, x = 2, 0.2\n        C = np.empty((N, N))\n        for n in range(N):\n            y = special.spherical_yn(n, x)\n            yp = special.spherical_yn(n, x, derivative=True)\n            C[0,n] = x*y\n            C[1,n] = x*yp + y\n        assert_array_almost_equal(C, special.riccati_yn(n, x), 8)\n\n\nclass TestRound:\n    def test_round(self):\n        rnd = list(map(int,(special.round(10.1),special.round(10.4),special.round(10.5),special.round(10.6))))\n\n        # Note: According to the documentation, scipy.special.round is\n        # supposed to round to the nearest even number if the fractional\n        # part is exactly 0.5. On some platforms, this does not appear\n        # to work and thus this test may fail. However, this unit test is\n        # correctly written.\n        rndrl = (10,10,10,11)\n        assert_array_equal(rnd,rndrl)\n\n\ndef test_sph_harm():\n    # Tests derived from tables in\n    # https://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n    sh = special.sph_harm\n    pi = np.pi\n    exp = np.exp\n    sqrt = np.sqrt\n    sin = np.sin\n    cos = np.cos\n    assert_array_almost_equal(sh(0,0,0,0),\n           0.5/sqrt(pi))\n    assert_array_almost_equal(sh(-2,2,0.,pi/4),\n           0.25*sqrt(15./(2.*pi)) *\n           (sin(pi/4))**2.)\n    assert_array_almost_equal(sh(-2,2,0.,pi/2),\n           0.25*sqrt(15./(2.*pi)))\n    assert_array_almost_equal(sh(2,2,pi,pi/2),\n           0.25*sqrt(15/(2.*pi)) *\n           exp(0+2.*pi*1j)*sin(pi/2.)**2.)\n    assert_array_almost_equal(sh(2,4,pi/4.,pi/3.),\n           (3./8.)*sqrt(5./(2.*pi)) *\n           exp(0+2.*pi/4.*1j) *\n           sin(pi/3.)**2. *\n           (7.*cos(pi/3.)**2.-1))\n    assert_array_almost_equal(sh(4,4,pi/8.,pi/6.),\n           (3./16.)*sqrt(35./(2.*pi)) *\n           exp(0+4.*pi/8.*1j)*sin(pi/6.)**4.)\n\n\ndef test_sph_harm_ufunc_loop_selection():\n    # see https://github.com/scipy/scipy/issues/4895\n    dt = np.dtype(np.complex128)\n    assert_equal(special.sph_harm(0, 0, 0, 0).dtype, dt)\n    assert_equal(special.sph_harm([0], 0, 0, 0).dtype, dt)\n    assert_equal(special.sph_harm(0, [0], 0, 0).dtype, dt)\n    assert_equal(special.sph_harm(0, 0, [0], 0).dtype, dt)\n    assert_equal(special.sph_harm(0, 0, 0, [0]).dtype, dt)\n    assert_equal(special.sph_harm([0], [0], [0], [0]).dtype, dt)\n\n\nclass TestStruve:\n    def _series(self, v, z, n=100):\n        \"\"\"Compute Struve function & error estimate from its power series.\"\"\"\n        k = arange(0, n)\n        r = (-1)**k * (.5*z)**(2*k+v+1)/special.gamma(k+1.5)/special.gamma(k+v+1.5)\n        err = abs(r).max() * finfo(float_).eps * n\n        return r.sum(), err\n\n    def test_vs_series(self):\n        \"\"\"Check Struve function versus its power series\"\"\"\n        for v in [-20, -10, -7.99, -3.4, -1, 0, 1, 3.4, 12.49, 16]:\n            for z in [1, 10, 19, 21, 30]:\n                value, err = self._series(v, z)\n                assert_allclose(special.struve(v, z), value, rtol=0, atol=err), (v, z)\n\n    def test_some_values(self):\n        assert_allclose(special.struve(-7.99, 21), 0.0467547614113, rtol=1e-7)\n        assert_allclose(special.struve(-8.01, 21), 0.0398716951023, rtol=1e-8)\n        assert_allclose(special.struve(-3.0, 200), 0.0142134427432, rtol=1e-12)\n        assert_allclose(special.struve(-8.0, -41), 0.0192469727846, rtol=1e-11)\n        assert_equal(special.struve(-12, -41), -special.struve(-12, 41))\n        assert_equal(special.struve(+12, -41), -special.struve(+12, 41))\n        assert_equal(special.struve(-11, -41), +special.struve(-11, 41))\n        assert_equal(special.struve(+11, -41), +special.struve(+11, 41))\n\n        assert_(isnan(special.struve(-7.1, -1)))\n        assert_(isnan(special.struve(-10.1, -1)))\n\n    def test_regression_679(self):\n        \"\"\"Regression test for #679\"\"\"\n        assert_allclose(special.struve(-1.0, 20 - 1e-8), special.struve(-1.0, 20 + 1e-8))\n        assert_allclose(special.struve(-2.0, 20 - 1e-8), special.struve(-2.0, 20 + 1e-8))\n        assert_allclose(special.struve(-4.3, 20 - 1e-8), special.struve(-4.3, 20 + 1e-8))\n\n\ndef test_chi2_smalldf():\n    assert_almost_equal(special.chdtr(0.6,3), 0.957890536704110)\n\n\ndef test_ch2_inf():\n    assert_equal(special.chdtr(0.7,np.inf), 1.0)\n\n\ndef test_chi2c_smalldf():\n    assert_almost_equal(special.chdtrc(0.6,3), 1-0.957890536704110)\n\n\ndef test_chi2_inv_smalldf():\n    assert_almost_equal(special.chdtri(0.6,1-0.957890536704110), 3)\n\n\ndef test_agm_simple():\n    rtol = 1e-13\n\n    # Gauss's constant\n    assert_allclose(1/special.agm(1, np.sqrt(2)), 0.834626841674073186,\n                    rtol=rtol)\n\n    # These values were computed using Wolfram Alpha, with the\n    # function ArithmeticGeometricMean[a, b].\n    agm13 = 1.863616783244897\n    agm15 = 2.604008190530940\n    agm35 = 3.936235503649555\n    assert_allclose(special.agm([[1], [3]], [1, 3, 5]),\n                    [[1, agm13, agm15],\n                     [agm13, 3, agm35]], rtol=rtol)\n\n    # Computed by the iteration formula using mpmath,\n    # with mpmath.mp.prec = 1000:\n    agm12 = 1.4567910310469068\n    assert_allclose(special.agm(1, 2), agm12, rtol=rtol)\n    assert_allclose(special.agm(2, 1), agm12, rtol=rtol)\n    assert_allclose(special.agm(-1, -2), -agm12, rtol=rtol)\n    assert_allclose(special.agm(24, 6), 13.458171481725614, rtol=rtol)\n    assert_allclose(special.agm(13, 123456789.5), 11111458.498599306,\n                    rtol=rtol)\n    assert_allclose(special.agm(1e30, 1), 2.229223055945383e+28, rtol=rtol)\n    assert_allclose(special.agm(1e-22, 1), 0.030182566420169886, rtol=rtol)\n    assert_allclose(special.agm(1e150, 1e180), 2.229223055945383e+178,\n                    rtol=rtol)\n    assert_allclose(special.agm(1e180, 1e-150), 2.0634722510162677e+177,\n                    rtol=rtol)\n    assert_allclose(special.agm(1e-150, 1e-170), 3.3112619670463756e-152,\n                    rtol=rtol)\n    fi = np.finfo(1.0)\n    assert_allclose(special.agm(fi.tiny, fi.max), 1.9892072050015473e+305,\n                    rtol=rtol)\n    assert_allclose(special.agm(0.75*fi.max, fi.max), 1.564904312298045e+308,\n                    rtol=rtol)\n    assert_allclose(special.agm(fi.tiny, 3*fi.tiny), 4.1466849866735005e-308,\n                    rtol=rtol)\n\n    # zero, nan and inf cases.\n    assert_equal(special.agm(0, 0), 0)\n    assert_equal(special.agm(99, 0), 0)\n\n    assert_equal(special.agm(-1, 10), np.nan)\n    assert_equal(special.agm(0, np.inf), np.nan)\n    assert_equal(special.agm(np.inf, 0), np.nan)\n    assert_equal(special.agm(0, -np.inf), np.nan)\n    assert_equal(special.agm(-np.inf, 0), np.nan)\n    assert_equal(special.agm(np.inf, -np.inf), np.nan)\n    assert_equal(special.agm(-np.inf, np.inf), np.nan)\n    assert_equal(special.agm(1, np.nan), np.nan)\n    assert_equal(special.agm(np.nan, -1), np.nan)\n\n    assert_equal(special.agm(1, np.inf), np.inf)\n    assert_equal(special.agm(np.inf, 1), np.inf)\n    assert_equal(special.agm(-1, -np.inf), -np.inf)\n    assert_equal(special.agm(-np.inf, -1), -np.inf)\n\n\ndef test_legacy():\n    # Legacy behavior: truncating arguments to integers\n    with suppress_warnings() as sup:\n        sup.filter(RuntimeWarning, \"floating point number truncated to an integer\")\n        assert_equal(special.expn(1, 0.3), special.expn(1.8, 0.3))\n        assert_equal(special.nbdtrc(1, 2, 0.3), special.nbdtrc(1.8, 2.8, 0.3))\n        assert_equal(special.nbdtr(1, 2, 0.3), special.nbdtr(1.8, 2.8, 0.3))\n        assert_equal(special.nbdtri(1, 2, 0.3), special.nbdtri(1.8, 2.8, 0.3))\n        assert_equal(special.pdtri(1, 0.3), special.pdtri(1.8, 0.3))\n        assert_equal(special.kn(1, 0.3), special.kn(1.8, 0.3))\n        assert_equal(special.yn(1, 0.3), special.yn(1.8, 0.3))\n        assert_equal(special.smirnov(1, 0.3), special.smirnov(1.8, 0.3))\n        assert_equal(special.smirnovi(1, 0.3), special.smirnovi(1.8, 0.3))\n\n\n@with_special_errors\ndef test_error_raising():\n    assert_raises(special.SpecialFunctionError, special.iv, 1, 1e99j)\n\n\ndef test_xlogy():\n    def xfunc(x, y):\n        with np.errstate(invalid='ignore'):\n            if x == 0 and not np.isnan(y):\n                return x\n            else:\n                return x*np.log(y)\n\n    z1 = np.asarray([(0,0), (0, np.nan), (0, np.inf), (1.0, 2.0)], dtype=float)\n    z2 = np.r_[z1, [(0, 1j), (1, 1j)]]\n\n    w1 = np.vectorize(xfunc)(z1[:,0], z1[:,1])\n    assert_func_equal(special.xlogy, w1, z1, rtol=1e-13, atol=1e-13)\n    w2 = np.vectorize(xfunc)(z2[:,0], z2[:,1])\n    assert_func_equal(special.xlogy, w2, z2, rtol=1e-13, atol=1e-13)\n\n\ndef test_xlog1py():\n    def xfunc(x, y):\n        with np.errstate(invalid='ignore'):\n            if x == 0 and not np.isnan(y):\n                return x\n            else:\n                return x * np.log1p(y)\n\n    z1 = np.asarray([(0,0), (0, np.nan), (0, np.inf), (1.0, 2.0),\n                     (1, 1e-30)], dtype=float)\n    w1 = np.vectorize(xfunc)(z1[:,0], z1[:,1])\n    assert_func_equal(special.xlog1py, w1, z1, rtol=1e-13, atol=1e-13)\n\n\ndef test_entr():\n    def xfunc(x):\n        if x < 0:\n            return -np.inf\n        else:\n            return -special.xlogy(x, x)\n    values = (0, 0.5, 1.0, np.inf)\n    signs = [-1, 1]\n    arr = []\n    for sgn, v in itertools.product(signs, values):\n        arr.append(sgn * v)\n    z = np.array(arr, dtype=float)\n    w = np.vectorize(xfunc, otypes=[np.float64])(z)\n    assert_func_equal(special.entr, w, z, rtol=1e-13, atol=1e-13)\n\n\ndef test_kl_div():\n    def xfunc(x, y):\n        if x < 0 or y < 0 or (y == 0 and x != 0):\n            # extension of natural domain to preserve convexity\n            return np.inf\n        elif np.isposinf(x) or np.isposinf(y):\n            # limits within the natural domain\n            return np.inf\n        elif x == 0:\n            return y\n        else:\n            return special.xlogy(x, x/y) - x + y\n    values = (0, 0.5, 1.0)\n    signs = [-1, 1]\n    arr = []\n    for sgna, va, sgnb, vb in itertools.product(signs, values, signs, values):\n        arr.append((sgna*va, sgnb*vb))\n    z = np.array(arr, dtype=float)\n    w = np.vectorize(xfunc, otypes=[np.float64])(z[:,0], z[:,1])\n    assert_func_equal(special.kl_div, w, z, rtol=1e-13, atol=1e-13)\n\n\ndef test_rel_entr():\n    def xfunc(x, y):\n        if x > 0 and y > 0:\n            return special.xlogy(x, x/y)\n        elif x == 0 and y >= 0:\n            return 0\n        else:\n            return np.inf\n    values = (0, 0.5, 1.0)\n    signs = [-1, 1]\n    arr = []\n    for sgna, va, sgnb, vb in itertools.product(signs, values, signs, values):\n        arr.append((sgna*va, sgnb*vb))\n    z = np.array(arr, dtype=float)\n    w = np.vectorize(xfunc, otypes=[np.float64])(z[:,0], z[:,1])\n    assert_func_equal(special.rel_entr, w, z, rtol=1e-13, atol=1e-13)\n\n\ndef test_huber():\n    assert_equal(special.huber(-1, 1.5), np.inf)\n    assert_allclose(special.huber(2, 1.5), 0.5 * np.square(1.5))\n    assert_allclose(special.huber(2, 2.5), 2 * (2.5 - 0.5 * 2))\n\n    def xfunc(delta, r):\n        if delta < 0:\n            return np.inf\n        elif np.abs(r) < delta:\n            return 0.5 * np.square(r)\n        else:\n            return delta * (np.abs(r) - 0.5 * delta)\n\n    z = np.random.randn(10, 2)\n    w = np.vectorize(xfunc, otypes=[np.float64])(z[:,0], z[:,1])\n    assert_func_equal(special.huber, w, z, rtol=1e-13, atol=1e-13)\n\n\ndef test_pseudo_huber():\n    def xfunc(delta, r):\n        if delta < 0:\n            return np.inf\n        elif (not delta) or (not r):\n            return 0\n        else:\n            return delta**2 * (np.sqrt(1 + (r/delta)**2) - 1)\n\n    z = np.array(np.random.randn(10, 2).tolist() + [[0, 0.5], [0.5, 0]])\n    w = np.vectorize(xfunc, otypes=[np.float64])(z[:,0], z[:,1])\n    assert_func_equal(special.pseudo_huber, w, z, rtol=1e-13, atol=1e-13)\n\n\ndef test_pseudo_huber_small_r():\n    delta = 1.0\n    r = 1e-18\n    y = special.pseudo_huber(delta, r)\n    # expected computed with mpmath:\n    #     import mpmath\n    #     mpmath.mp.dps = 200\n    #     r = mpmath.mpf(1e-18)\n    #     expected = float(mpmath.sqrt(1 + r**2) - 1)\n    expected = 5.0000000000000005e-37\n    assert_allclose(y, expected, rtol=1e-13)\n\n\ndef test_runtime_warning():\n    with pytest.warns(RuntimeWarning,\n                      match=r'Too many predicted coefficients'):\n        mathieu_odd_coef(1000, 1000)\n    with pytest.warns(RuntimeWarning,\n                      match=r'Too many predicted coefficients'):\n        mathieu_even_coef(1000, 1000)\n"
    }
  ]
}