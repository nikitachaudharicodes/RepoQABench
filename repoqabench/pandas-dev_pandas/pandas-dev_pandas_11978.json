{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "11978",
  "issue_description": "# ENH: other plotting tools via plot accessor\n\n- [ ] `scatter_matrix` (deprecate, redirect to `seaborn`)\n- [ ] `andrews_curve`\n- [ ] `parallel_coordinates`\n- [ ] `lag_plot` (maybe rename to `lag`)\n- [ ] `autocorrelation_plot` (maybe rename to `autocorrelation`?)\n- [ ] `bootstrap_plot` (maybe rename to `bootstrap`?)\n- [ ] `radviz`\n\nI think it would be nice to allow [scatter_matrix](http://pandas.pydata.org/pandas-docs/version/0.15.0/visualization.html#scatter-matrix-plot) to be called directly on a DataFrame. Currently, `scatter_matrix` is a separate function that takes a DataFrame as a parameter, but it seems like it would be easy enough to rework to allow it to be called directly on a DataFrame as well. Effectively, the convenience function would look something like:\n\n``` python\ndef scatter_matrix(self, ...):\n    pandas.tools.plotting.scatter_matrix(self.data, ...)\n```\n\nIs this feature feasible?\n",
  "issue_comments": [
    {
      "id": 169533788,
      "user": "TomAugspurger",
      "body": "We could probably do this as `DataFrame.plot.scatter_matrix`. I'm not sure why this wasn't ever folded into the `df.plot(kind=)` function.\n\nAlso, the standard disclaimer that seaborn [does this better](https://stanford.edu/~mwaskom/software/seaborn/examples/scatterplot_matrix.html)\n"
    },
    {
      "id": 169534007,
      "user": "jreback",
      "body": "actually prob _all_ should be added via the plot accessor: http://pandas.pydata.org/pandas-docs/stable/visualization.html#plotting-tools\n"
    },
    {
      "id": 169776296,
      "user": "shoyer",
      "body": "Something to consider: Maybe we want to deprecate some of these more complex plot types? For example, seaborn does a better job of scatter matrix than we do...\n"
    },
    {
      "id": 169779201,
      "user": "jreback",
      "body": "absolutely let's do that. any others?\n\n `bootstrap`, `autocorrelation`, `lag` for statsmodels?\n\ncc @jseabold\ncc @josef-pkt\n"
    },
    {
      "id": 169781132,
      "user": "rhiever",
      "body": "@shoyer: IMO the scatter matrix is a basic plot type that people would want to see for a DataFrame.\n"
    },
    {
      "id": 169782560,
      "user": "jorisvandenbossche",
      "body": "I agree with @shoyer. These plotting methods are rather 'neglected' lately. I think we should either choose to give them more attention, or deprecate them. And personally I think it should not be the focus of pandas. \n\nBut maybe `scatter_matrix` as the IMO the most generic of the plotting methods listed can be the exception?\n"
    },
    {
      "id": 169782922,
      "user": "jreback",
      "body": "why don't we defer scatter_mattix to seaborn anyhow? so seaborn becomes an optional dep)\n"
    },
    {
      "id": 169788771,
      "user": "josef-pkt",
      "body": "@jreback   how well are optional circular dependencies no supported in various packagings?\nI haven't kept up with it, but we get circular dependency pandas - seaborn - statsmodels.\nI'm in favor of tight integration, in general.\n\nI'm not a heavy pandas user directly, but I also find some quick plot methods convenient, instead of having to look for the appropriate function in another package.\n\nabout plots in statsmodels: plots are mostly in a minimal maintenance state. There is not much effort for a style update to make them look better, e.g. compared to seaborn, because of a lack of developers. \nHowever, we need them in support of the models and other stats functions and still keep adding more. \nFor example, acf and pacf are some of our oldest plot functions and won't go away.\n\nTrying to use seaborn as optional statsmodels dependency to upgrade plots is an idea but doesn't have a champion to look into it and work on it. For many plots the focus of seaborn is exploratory analysis which is more similar to the pandas use, but for us having a model inside the plot is inside out because we need plots inside the models, or after having estimated a model.\n"
    },
    {
      "id": 169789619,
      "user": "jreback",
      "body": "using seaborn (or sm using pandas is no problem here)\nyou can simply import inside the method itself\n"
    },
    {
      "id": 169794343,
      "user": "jseabold",
      "body": "I'm in favor of not duplicating efforts and seaborn take over \"statistics-driven\" plotting in general. I do agree that quick and dirty DataFrame.plot for basic matplotlib plots is still useful, of course.\n"
    },
    {
      "id": 169801286,
      "user": "datnamer",
      "body": "@jreback @jseabold   What about bokeh?  Is there going to be a stats plotting effort there in the new chart interface? \n\nI think that has more potential (for interactive data exploration like ggvis and due to engineer time) than seaborn. \n"
    },
    {
      "id": 169801404,
      "user": "josef-pkt",
      "body": "@jreback  I was thinking more about the install process, pip, requirements and various distributions. Are those all smart enough by now, or will there be, at least temporary, problems?\n\nIn statsmodels all plot functions try except protect matplotlib import, but we would still have to watch out for circular module imports when statsmodels reuses seaborn. However, that's a internal problem not a distribution problem.\n"
    },
    {
      "id": 169802402,
      "user": "jreback",
      "body": "well I have been pushing the `engine=seaborn | bokeh | mpl | pandas` for a little bit. IOW for the 'standard' ones, we have an implementation and just defer if the user passes `engine`. For the ones we don't have an impl, then have to defer.\n\nIdeally we would remove _all_ plotting code from pandas (except for say resampling callback and such). And just defer to various engines.\n\nYou can do this now via `.pipe`, this would just make the methods slightly easier.\n"
    },
    {
      "id": 169805459,
      "user": "max-sixty",
      "body": "> Ideally we would remove all plotting code from pandas (except for say resampling callback and such). And just defer to various engines.\n\n:+1: \n"
    },
    {
      "id": 526984471,
      "user": "Ochirgarid",
      "body": "Received this issue from CodeTriage. Seems like it is already closed issue @jorisvandenbossche could you explain why you reopened the issue? "
    },
    {
      "id": 823791724,
      "user": "mroeschke",
      "body": "From the reversion of this feature in https://github.com/pandas-dev/pandas/pull/24912 and discussion within, it appears that there's not much appetite in supporting this directly in an accessor and having a free standing function is fine. Closing. "
    }
  ],
  "text_context": "# ENH: other plotting tools via plot accessor\n\n- [ ] `scatter_matrix` (deprecate, redirect to `seaborn`)\n- [ ] `andrews_curve`\n- [ ] `parallel_coordinates`\n- [ ] `lag_plot` (maybe rename to `lag`)\n- [ ] `autocorrelation_plot` (maybe rename to `autocorrelation`?)\n- [ ] `bootstrap_plot` (maybe rename to `bootstrap`?)\n- [ ] `radviz`\n\nI think it would be nice to allow [scatter_matrix](http://pandas.pydata.org/pandas-docs/version/0.15.0/visualization.html#scatter-matrix-plot) to be called directly on a DataFrame. Currently, `scatter_matrix` is a separate function that takes a DataFrame as a parameter, but it seems like it would be easy enough to rework to allow it to be called directly on a DataFrame as well. Effectively, the convenience function would look something like:\n\n``` python\ndef scatter_matrix(self, ...):\n    pandas.tools.plotting.scatter_matrix(self.data, ...)\n```\n\nIs this feature feasible?\n\n\nWe could probably do this as `DataFrame.plot.scatter_matrix`. I'm not sure why this wasn't ever folded into the `df.plot(kind=)` function.\n\nAlso, the standard disclaimer that seaborn [does this better](https://stanford.edu/~mwaskom/software/seaborn/examples/scatterplot_matrix.html)\n\n\nactually prob _all_ should be added via the plot accessor: http://pandas.pydata.org/pandas-docs/stable/visualization.html#plotting-tools\n\n\nSomething to consider: Maybe we want to deprecate some of these more complex plot types? For example, seaborn does a better job of scatter matrix than we do...\n\n\nabsolutely let's do that. any others?\n\n `bootstrap`, `autocorrelation`, `lag` for statsmodels?\n\ncc @jseabold\ncc @josef-pkt\n\n\n@shoyer: IMO the scatter matrix is a basic plot type that people would want to see for a DataFrame.\n\n\nI agree with @shoyer. These plotting methods are rather 'neglected' lately. I think we should either choose to give them more attention, or deprecate them. And personally I think it should not be the focus of pandas. \n\nBut maybe `scatter_matrix` as the IMO the most generic of the plotting methods listed can be the exception?\n\n\nwhy don't we defer scatter_mattix to seaborn anyhow? so seaborn becomes an optional dep)\n\n\n@jreback   how well are optional circular dependencies no supported in various packagings?\nI haven't kept up with it, but we get circular dependency pandas - seaborn - statsmodels.\nI'm in favor of tight integration, in general.\n\nI'm not a heavy pandas user directly, but I also find some quick plot methods convenient, instead of having to look for the appropriate function in another package.\n\nabout plots in statsmodels: plots are mostly in a minimal maintenance state. There is not much effort for a style update to make them look better, e.g. compared to seaborn, because of a lack of developers. \nHowever, we need them in support of the models and other stats functions and still keep adding more. \nFor example, acf and pacf are some of our oldest plot functions and won't go away.\n\nTrying to use seaborn as optional statsmodels dependency to upgrade plots is an idea but doesn't have a champion to look into it and work on it. For many plots the focus of seaborn is exploratory analysis which is more similar to the pandas use, but for us having a model inside the plot is inside out because we need plots inside the models, or after having estimated a model.\n\n\nusing seaborn (or sm using pandas is no problem here)\nyou can simply import inside the method itself\n\n\nI'm in favor of not duplicating efforts and seaborn take over \"statistics-driven\" plotting in general. I do agree that quick and dirty DataFrame.plot for basic matplotlib plots is still useful, of course.\n\n\n@jreback @jseabold   What about bokeh?  Is there going to be a stats plotting effort there in the new chart interface? \n\nI think that has more potential (for interactive data exploration like ggvis and due to engineer time) than seaborn. \n\n\n@jreback  I was thinking more about the install process, pip, requirements and various distributions. Are those all smart enough by now, or will there be, at least temporary, problems?\n\nIn statsmodels all plot functions try except protect matplotlib import, but we would still have to watch out for circular module imports when statsmodels reuses seaborn. However, that's a internal problem not a distribution problem.\n\n\nwell I have been pushing the `engine=seaborn | bokeh | mpl | pandas` for a little bit. IOW for the 'standard' ones, we have an implementation and just defer if the user passes `engine`. For the ones we don't have an impl, then have to defer.\n\nIdeally we would remove _all_ plotting code from pandas (except for say resampling callback and such). And just defer to various engines.\n\nYou can do this now via `.pipe`, this would just make the methods slightly easier.\n\n\n> Ideally we would remove all plotting code from pandas (except for say resampling callback and such). And just defer to various engines.\n\n:+1: \n\n\nReceived this issue from CodeTriage. Seems like it is already closed issue @jorisvandenbossche could you explain why you reopened the issue? \n\nFrom the reversion of this feature in https://github.com/pandas-dev/pandas/pull/24912 and discussion within, it appears that there's not much appetite in supporting this directly in an accessor and having a free standing function is fine. Closing. ",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/24912",
  "code_context": [
    {
      "filename": "pandas/plotting/_core.py",
      "content": "# being a bit too dynamic\n# pylint: disable=E1101\nfrom __future__ import division\n\nfrom collections import namedtuple\nfrom distutils.version import LooseVersion\nimport re\nimport warnings\n\nimport numpy as np\n\nimport pandas.compat as compat\nfrom pandas.compat import lrange, map, range, string_types, zip\nfrom pandas.errors import AbstractMethodError\nfrom pandas.util._decorators import Appender, cache_readonly\n\nfrom pandas.core.dtypes.common import (\n    is_hashable, is_integer, is_iterator, is_list_like, is_number)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame, ABCIndexClass, ABCMultiIndex, ABCPeriodIndex, ABCSeries)\nfrom pandas.core.dtypes.missing import isna, notna, remove_na_arraylike\n\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.config import get_option\nfrom pandas.core.generic import _shared_doc_kwargs, _shared_docs\n\nfrom pandas.io.formats.printing import pprint_thing\nfrom pandas.plotting._compat import _mpl_ge_3_0_0\nfrom pandas.plotting._style import _get_standard_colors, plot_params\nfrom pandas.plotting._tools import (\n    _flatten, _get_all_lines, _get_xlim, _handle_shared_axes, _set_ticks_props,\n    _subplots, format_date_labels, table)\n\ntry:\n    from pandas.plotting import _converter\nexcept ImportError:\n    _HAS_MPL = False\nelse:\n    _HAS_MPL = True\n    if get_option('plotting.matplotlib.register_converters'):\n        _converter.register(explicit=True)\n\n\ndef _raise_if_no_mpl():\n    # TODO(mpl_converter): remove once converter is explicit\n    if not _HAS_MPL:\n        raise ImportError(\"matplotlib is required for plotting.\")\n\n\ndef _get_standard_kind(kind):\n    return {'density': 'kde'}.get(kind, kind)\n\n\ndef _gca(rc=None):\n    import matplotlib.pyplot as plt\n    with plt.rc_context(rc):\n        return plt.gca()\n\n\ndef _gcf():\n    import matplotlib.pyplot as plt\n    return plt.gcf()\n\n\nclass MPLPlot(object):\n    \"\"\"\n    Base class for assembling a pandas plot using matplotlib\n\n    Parameters\n    ----------\n    data :\n\n    \"\"\"\n\n    @property\n    def _kind(self):\n        \"\"\"Specify kind str. Must be overridden in child class\"\"\"\n        raise NotImplementedError\n\n    _layout_type = 'vertical'\n    _default_rot = 0\n    orientation = None\n    _pop_attributes = ['label', 'style', 'logy', 'logx', 'loglog',\n                       'mark_right', 'stacked']\n    _attr_defaults = {'logy': False, 'logx': False, 'loglog': False,\n                      'mark_right': True, 'stacked': False}\n\n    def __init__(self, data, kind=None, by=None, subplots=False, sharex=None,\n                 sharey=False, use_index=True,\n                 figsize=None, grid=None, legend=True, rot=None,\n                 ax=None, fig=None, title=None, xlim=None, ylim=None,\n                 xticks=None, yticks=None,\n                 sort_columns=False, fontsize=None,\n                 secondary_y=False, colormap=None,\n                 table=False, layout=None, **kwds):\n\n        _raise_if_no_mpl()\n        _converter._WARN = False\n        self.data = data\n        self.by = by\n\n        self.kind = kind\n\n        self.sort_columns = sort_columns\n\n        self.subplots = subplots\n\n        if sharex is None:\n            if ax is None:\n                self.sharex = True\n            else:\n                # if we get an axis, the users should do the visibility\n                # setting...\n                self.sharex = False\n        else:\n            self.sharex = sharex\n\n        self.sharey = sharey\n        self.figsize = figsize\n        self.layout = layout\n\n        self.xticks = xticks\n        self.yticks = yticks\n        self.xlim = xlim\n        self.ylim = ylim\n        self.title = title\n        self.use_index = use_index\n\n        self.fontsize = fontsize\n\n        if rot is not None:\n            self.rot = rot\n            # need to know for format_date_labels since it's rotated to 30 by\n            # default\n            self._rot_set = True\n        else:\n            self._rot_set = False\n            self.rot = self._default_rot\n\n        if grid is None:\n            grid = False if secondary_y else self.plt.rcParams['axes.grid']\n\n        self.grid = grid\n        self.legend = legend\n        self.legend_handles = []\n        self.legend_labels = []\n\n        for attr in self._pop_attributes:\n            value = kwds.pop(attr, self._attr_defaults.get(attr, None))\n            setattr(self, attr, value)\n\n        self.ax = ax\n        self.fig = fig\n        self.axes = None\n\n        # parse errorbar input if given\n        xerr = kwds.pop('xerr', None)\n        yerr = kwds.pop('yerr', None)\n        self.errors = {kw: self._parse_errorbars(kw, err)\n                       for kw, err in zip(['xerr', 'yerr'], [xerr, yerr])}\n\n        if not isinstance(secondary_y, (bool, tuple, list,\n                                        np.ndarray, ABCIndexClass)):\n            secondary_y = [secondary_y]\n        self.secondary_y = secondary_y\n\n        # ugly TypeError if user passes matplotlib's `cmap` name.\n        # Probably better to accept either.\n        if 'cmap' in kwds and colormap:\n            raise TypeError(\"Only specify one of `cmap` and `colormap`.\")\n        elif 'cmap' in kwds:\n            self.colormap = kwds.pop('cmap')\n        else:\n            self.colormap = colormap\n\n        self.table = table\n\n        self.kwds = kwds\n\n        self._validate_color_args()\n\n    def _validate_color_args(self):\n        if 'color' not in self.kwds and 'colors' in self.kwds:\n            warnings.warn((\"'colors' is being deprecated. Please use 'color'\"\n                           \"instead of 'colors'\"))\n            colors = self.kwds.pop('colors')\n            self.kwds['color'] = colors\n\n        if ('color' in self.kwds and self.nseries == 1 and\n                not is_list_like(self.kwds['color'])):\n            # support series.plot(color='green')\n            self.kwds['color'] = [self.kwds['color']]\n\n        if ('color' in self.kwds and isinstance(self.kwds['color'], tuple) and\n                self.nseries == 1 and len(self.kwds['color']) in (3, 4)):\n            # support RGB and RGBA tuples in series plot\n            self.kwds['color'] = [self.kwds['color']]\n\n        if ('color' in self.kwds or 'colors' in self.kwds) and \\\n                self.colormap is not None:\n            warnings.warn(\"'color' and 'colormap' cannot be used \"\n                          \"simultaneously. Using 'color'\")\n\n        if 'color' in self.kwds and self.style is not None:\n            if is_list_like(self.style):\n                styles = self.style\n            else:\n                styles = [self.style]\n            # need only a single match\n            for s in styles:\n                if re.match('^[a-z]+?', s) is not None:\n                    raise ValueError(\n                        \"Cannot pass 'style' string with a color \"\n                        \"symbol and 'color' keyword argument. Please\"\n                        \" use one or the other or pass 'style' \"\n                        \"without a color symbol\")\n\n    def _iter_data(self, data=None, keep_index=False, fillna=None):\n        if data is None:\n            data = self.data\n        if fillna is not None:\n            data = data.fillna(fillna)\n\n        # TODO: unused?\n        # if self.sort_columns:\n        #     columns = com.try_sort(data.columns)\n        # else:\n        #     columns = data.columns\n\n        for col, values in data.iteritems():\n            if keep_index is True:\n                yield col, values\n            else:\n                yield col, values.values\n\n    @property\n    def nseries(self):\n        if self.data.ndim == 1:\n            return 1\n        else:\n            return self.data.shape[1]\n\n    def draw(self):\n        self.plt.draw_if_interactive()\n\n    def generate(self):\n        self._args_adjust()\n        self._compute_plot_data()\n        self._setup_subplots()\n        self._make_plot()\n        self._add_table()\n        self._make_legend()\n        self._adorn_subplots()\n\n        for ax in self.axes:\n            self._post_plot_logic_common(ax, self.data)\n            self._post_plot_logic(ax, self.data)\n\n    def _args_adjust(self):\n        pass\n\n    def _has_plotted_object(self, ax):\n        \"\"\"check whether ax has data\"\"\"\n        return (len(ax.lines) != 0 or\n                len(ax.artists) != 0 or\n                len(ax.containers) != 0)\n\n    def _maybe_right_yaxis(self, ax, axes_num):\n        if not self.on_right(axes_num):\n            # secondary axes may be passed via ax kw\n            return self._get_ax_layer(ax)\n\n        if hasattr(ax, 'right_ax'):\n            # if it has right_ax proparty, ``ax`` must be left axes\n            return ax.right_ax\n        elif hasattr(ax, 'left_ax'):\n            # if it has left_ax proparty, ``ax`` must be right axes\n            return ax\n        else:\n            # otherwise, create twin axes\n            orig_ax, new_ax = ax, ax.twinx()\n            # TODO: use Matplotlib public API when available\n            new_ax._get_lines = orig_ax._get_lines\n            new_ax._get_patches_for_fill = orig_ax._get_patches_for_fill\n            orig_ax.right_ax, new_ax.left_ax = new_ax, orig_ax\n\n            if not self._has_plotted_object(orig_ax):  # no data on left y\n                orig_ax.get_yaxis().set_visible(False)\n            return new_ax\n\n    def _setup_subplots(self):\n        if self.subplots:\n            fig, axes = _subplots(naxes=self.nseries,\n                                  sharex=self.sharex, sharey=self.sharey,\n                                  figsize=self.figsize, ax=self.ax,\n                                  layout=self.layout,\n                                  layout_type=self._layout_type)\n        else:\n            if self.ax is None:\n                fig = self.plt.figure(figsize=self.figsize)\n                axes = fig.add_subplot(111)\n            else:\n                fig = self.ax.get_figure()\n                if self.figsize is not None:\n                    fig.set_size_inches(self.figsize)\n                axes = self.ax\n\n        axes = _flatten(axes)\n\n        if self.logx or self.loglog:\n            [a.set_xscale('log') for a in axes]\n        if self.logy or self.loglog:\n            [a.set_yscale('log') for a in axes]\n\n        self.fig = fig\n        self.axes = axes\n\n    @property\n    def result(self):\n        \"\"\"\n        Return result axes\n        \"\"\"\n        if self.subplots:\n            if self.layout is not None and not is_list_like(self.ax):\n                return self.axes.reshape(*self.layout)\n            else:\n                return self.axes\n        else:\n            sec_true = isinstance(self.secondary_y, bool) and self.secondary_y\n            all_sec = (is_list_like(self.secondary_y) and\n                       len(self.secondary_y) == self.nseries)\n            if (sec_true or all_sec):\n                # if all data is plotted on secondary, return right axes\n                return self._get_ax_layer(self.axes[0], primary=False)\n            else:\n                return self.axes[0]\n\n    def _compute_plot_data(self):\n        data = self.data\n\n        if isinstance(data, ABCSeries):\n            label = self.label\n            if label is None and data.name is None:\n                label = 'None'\n            data = data.to_frame(name=label)\n\n        # GH16953, _convert is needed as fallback, for ``Series``\n        # with ``dtype == object``\n        data = data._convert(datetime=True, timedelta=True)\n        numeric_data = data.select_dtypes(include=[np.number,\n                                                   \"datetime\",\n                                                   \"datetimetz\",\n                                                   \"timedelta\"])\n\n        try:\n            is_empty = numeric_data.empty\n        except AttributeError:\n            is_empty = not len(numeric_data)\n\n        # no empty frames or series allowed\n        if is_empty:\n            raise TypeError('Empty {0!r}: no numeric data to '\n                            'plot'.format(numeric_data.__class__.__name__))\n\n        self.data = numeric_data\n\n    def _make_plot(self):\n        raise AbstractMethodError(self)\n\n    def _add_table(self):\n        if self.table is False:\n            return\n        elif self.table is True:\n            data = self.data.transpose()\n        else:\n            data = self.table\n        ax = self._get_ax(0)\n        table(ax, data)\n\n    def _post_plot_logic_common(self, ax, data):\n        \"\"\"Common post process for each axes\"\"\"\n\n        def get_label(i):\n            try:\n                return pprint_thing(data.index[i])\n            except Exception:\n                return ''\n\n        if self.orientation == 'vertical' or self.orientation is None:\n            if self._need_to_set_index:\n                xticklabels = [get_label(x) for x in ax.get_xticks()]\n                ax.set_xticklabels(xticklabels)\n            self._apply_axis_properties(ax.xaxis, rot=self.rot,\n                                        fontsize=self.fontsize)\n            self._apply_axis_properties(ax.yaxis, fontsize=self.fontsize)\n\n            if hasattr(ax, 'right_ax'):\n                self._apply_axis_properties(ax.right_ax.yaxis,\n                                            fontsize=self.fontsize)\n\n        elif self.orientation == 'horizontal':\n            if self._need_to_set_index:\n                yticklabels = [get_label(y) for y in ax.get_yticks()]\n                ax.set_yticklabels(yticklabels)\n            self._apply_axis_properties(ax.yaxis, rot=self.rot,\n                                        fontsize=self.fontsize)\n            self._apply_axis_properties(ax.xaxis, fontsize=self.fontsize)\n\n            if hasattr(ax, 'right_ax'):\n                self._apply_axis_properties(ax.right_ax.yaxis,\n                                            fontsize=self.fontsize)\n        else:  # pragma no cover\n            raise ValueError\n\n    def _post_plot_logic(self, ax, data):\n        \"\"\"Post process for each axes. Overridden in child classes\"\"\"\n        pass\n\n    def _adorn_subplots(self):\n        \"\"\"Common post process unrelated to data\"\"\"\n        if len(self.axes) > 0:\n            all_axes = self._get_subplots()\n            nrows, ncols = self._get_axes_layout()\n            _handle_shared_axes(axarr=all_axes, nplots=len(all_axes),\n                                naxes=nrows * ncols, nrows=nrows,\n                                ncols=ncols, sharex=self.sharex,\n                                sharey=self.sharey)\n\n        for ax in self.axes:\n            if self.yticks is not None:\n                ax.set_yticks(self.yticks)\n\n            if self.xticks is not None:\n                ax.set_xticks(self.xticks)\n\n            if self.ylim is not None:\n                ax.set_ylim(self.ylim)\n\n            if self.xlim is not None:\n                ax.set_xlim(self.xlim)\n\n            ax.grid(self.grid)\n\n        if self.title:\n            if self.subplots:\n                if is_list_like(self.title):\n                    if len(self.title) != self.nseries:\n                        msg = ('The length of `title` must equal the number '\n                               'of columns if using `title` of type `list` '\n                               'and `subplots=True`.\\n'\n                               'length of title = {}\\n'\n                               'number of columns = {}').format(\n                            len(self.title), self.nseries)\n                        raise ValueError(msg)\n\n                    for (ax, title) in zip(self.axes, self.title):\n                        ax.set_title(title)\n                else:\n                    self.fig.suptitle(self.title)\n            else:\n                if is_list_like(self.title):\n                    msg = ('Using `title` of type `list` is not supported '\n                           'unless `subplots=True` is passed')\n                    raise ValueError(msg)\n                self.axes[0].set_title(self.title)\n\n    def _apply_axis_properties(self, axis, rot=None, fontsize=None):\n        labels = axis.get_majorticklabels() + axis.get_minorticklabels()\n        for label in labels:\n            if rot is not None:\n                label.set_rotation(rot)\n            if fontsize is not None:\n                label.set_fontsize(fontsize)\n\n    @property\n    def legend_title(self):\n        if not isinstance(self.data.columns, ABCMultiIndex):\n            name = self.data.columns.name\n            if name is not None:\n                name = pprint_thing(name)\n            return name\n        else:\n            stringified = map(pprint_thing,\n                              self.data.columns.names)\n            return ','.join(stringified)\n\n    def _add_legend_handle(self, handle, label, index=None):\n        if label is not None:\n            if self.mark_right and index is not None:\n                if self.on_right(index):\n                    label = label + ' (right)'\n            self.legend_handles.append(handle)\n            self.legend_labels.append(label)\n\n    def _make_legend(self):\n        ax, leg = self._get_ax_legend(self.axes[0])\n\n        handles = []\n        labels = []\n        title = ''\n\n        if not self.subplots:\n            if leg is not None:\n                title = leg.get_title().get_text()\n                handles = leg.legendHandles\n                labels = [x.get_text() for x in leg.get_texts()]\n\n            if self.legend:\n                if self.legend == 'reverse':\n                    self.legend_handles = reversed(self.legend_handles)\n                    self.legend_labels = reversed(self.legend_labels)\n\n                handles += self.legend_handles\n                labels += self.legend_labels\n                if self.legend_title is not None:\n                    title = self.legend_title\n\n            if len(handles) > 0:\n                ax.legend(handles, labels, loc='best', title=title)\n\n        elif self.subplots and self.legend:\n            for ax in self.axes:\n                if ax.get_visible():\n                    ax.legend(loc='best')\n\n    def _get_ax_legend(self, ax):\n        leg = ax.get_legend()\n        other_ax = (getattr(ax, 'left_ax', None) or\n                    getattr(ax, 'right_ax', None))\n        other_leg = None\n        if other_ax is not None:\n            other_leg = other_ax.get_legend()\n        if leg is None and other_leg is not None:\n            leg = other_leg\n            ax = other_ax\n        return ax, leg\n\n    @cache_readonly\n    def plt(self):\n        import matplotlib.pyplot as plt\n        return plt\n\n    _need_to_set_index = False\n\n    def _get_xticks(self, convert_period=False):\n        index = self.data.index\n        is_datetype = index.inferred_type in ('datetime', 'date',\n                                              'datetime64', 'time')\n\n        if self.use_index:\n            if convert_period and isinstance(index, ABCPeriodIndex):\n                self.data = self.data.reindex(index=index.sort_values())\n                x = self.data.index.to_timestamp()._mpl_repr()\n            elif index.is_numeric():\n                \"\"\"\n                Matplotlib supports numeric values or datetime objects as\n                xaxis values. Taking LBYL approach here, by the time\n                matplotlib raises exception when using non numeric/datetime\n                values for xaxis, several actions are already taken by plt.\n                \"\"\"\n                x = index._mpl_repr()\n            elif is_datetype:\n                self.data = self.data[notna(self.data.index)]\n                self.data = self.data.sort_index()\n                x = self.data.index._mpl_repr()\n            else:\n                self._need_to_set_index = True\n                x = lrange(len(index))\n        else:\n            x = lrange(len(index))\n\n        return x\n\n    @classmethod\n    def _plot(cls, ax, x, y, style=None, is_errorbar=False, **kwds):\n        mask = isna(y)\n        if mask.any():\n            y = np.ma.array(y)\n            y = np.ma.masked_where(mask, y)\n\n        if isinstance(x, ABCIndexClass):\n            x = x._mpl_repr()\n\n        if is_errorbar:\n            if 'xerr' in kwds:\n                kwds['xerr'] = np.array(kwds.get('xerr'))\n            if 'yerr' in kwds:\n                kwds['yerr'] = np.array(kwds.get('yerr'))\n            return ax.errorbar(x, y, **kwds)\n        else:\n            # prevent style kwarg from going to errorbar, where it is\n            # unsupported\n            if style is not None:\n                args = (x, y, style)\n            else:\n                args = (x, y)\n            return ax.plot(*args, **kwds)\n\n    def _get_index_name(self):\n        if isinstance(self.data.index, ABCMultiIndex):\n            name = self.data.index.names\n            if com._any_not_none(*name):\n                name = ','.join(pprint_thing(x) for x in name)\n            else:\n                name = None\n        else:\n            name = self.data.index.name\n            if name is not None:\n                name = pprint_thing(name)\n\n        return name\n\n    @classmethod\n    def _get_ax_layer(cls, ax, primary=True):\n        \"\"\"get left (primary) or right (secondary) axes\"\"\"\n        if primary:\n            return getattr(ax, 'left_ax', ax)\n        else:\n            return getattr(ax, 'right_ax', ax)\n\n    def _get_ax(self, i):\n        # get the twinx ax if appropriate\n        if self.subplots:\n            ax = self.axes[i]\n            ax = self._maybe_right_yaxis(ax, i)\n            self.axes[i] = ax\n        else:\n            ax = self.axes[0]\n            ax = self._maybe_right_yaxis(ax, i)\n\n        ax.get_yaxis().set_visible(True)\n        return ax\n\n    def on_right(self, i):\n        if isinstance(self.secondary_y, bool):\n            return self.secondary_y\n\n        if isinstance(self.secondary_y, (tuple, list,\n                                         np.ndarray, ABCIndexClass)):\n            return self.data.columns[i] in self.secondary_y\n\n    def _apply_style_colors(self, colors, kwds, col_num, label):\n        \"\"\"\n        Manage style and color based on column number and its label.\n        Returns tuple of appropriate style and kwds which \"color\" may be added.\n        \"\"\"\n        style = None\n        if self.style is not None:\n            if isinstance(self.style, list):\n                try:\n                    style = self.style[col_num]\n                except IndexError:\n                    pass\n            elif isinstance(self.style, dict):\n                style = self.style.get(label, style)\n            else:\n                style = self.style\n\n        has_color = 'color' in kwds or self.colormap is not None\n        nocolor_style = style is None or re.match('[a-z]+', style) is None\n        if (has_color or self.subplots) and nocolor_style:\n            kwds['color'] = colors[col_num % len(colors)]\n        return style, kwds\n\n    def _get_colors(self, num_colors=None, color_kwds='color'):\n        if num_colors is None:\n            num_colors = self.nseries\n\n        return _get_standard_colors(num_colors=num_colors,\n                                    colormap=self.colormap,\n                                    color=self.kwds.get(color_kwds))\n\n    def _parse_errorbars(self, label, err):\n        \"\"\"\n        Look for error keyword arguments and return the actual errorbar data\n        or return the error DataFrame/dict\n\n        Error bars can be specified in several ways:\n            Series: the user provides a pandas.Series object of the same\n                    length as the data\n            ndarray: provides a np.ndarray of the same length as the data\n            DataFrame/dict: error values are paired with keys matching the\n                    key in the plotted DataFrame\n            str: the name of the column within the plotted DataFrame\n        \"\"\"\n\n        if err is None:\n            return None\n\n        def match_labels(data, e):\n            e = e.reindex(data.index)\n            return e\n\n        # key-matched DataFrame\n        if isinstance(err, ABCDataFrame):\n\n            err = match_labels(self.data, err)\n        # key-matched dict\n        elif isinstance(err, dict):\n            pass\n\n        # Series of error values\n        elif isinstance(err, ABCSeries):\n            # broadcast error series across data\n            err = match_labels(self.data, err)\n            err = np.atleast_2d(err)\n            err = np.tile(err, (self.nseries, 1))\n\n        # errors are a column in the dataframe\n        elif isinstance(err, string_types):\n            evalues = self.data[err].values\n            self.data = self.data[self.data.columns.drop(err)]\n            err = np.atleast_2d(evalues)\n            err = np.tile(err, (self.nseries, 1))\n\n        elif is_list_like(err):\n            if is_iterator(err):\n                err = np.atleast_2d(list(err))\n            else:\n                # raw error values\n                err = np.atleast_2d(err)\n\n            err_shape = err.shape\n\n            # asymmetrical error bars\n            if err.ndim == 3:\n                if (err_shape[0] != self.nseries) or \\\n                        (err_shape[1] != 2) or \\\n                        (err_shape[2] != len(self.data)):\n                    msg = \"Asymmetrical error bars should be provided \" + \\\n                        \"with the shape (%u, 2, %u)\" % \\\n                        (self.nseries, len(self.data))\n                    raise ValueError(msg)\n\n            # broadcast errors to each data series\n            if len(err) == 1:\n                err = np.tile(err, (self.nseries, 1))\n\n        elif is_number(err):\n            err = np.tile([err], (self.nseries, len(self.data)))\n\n        else:\n            msg = \"No valid {label} detected\".format(label=label)\n            raise ValueError(msg)\n\n        return err\n\n    def _get_errorbars(self, label=None, index=None, xerr=True, yerr=True):\n        errors = {}\n\n        for kw, flag in zip(['xerr', 'yerr'], [xerr, yerr]):\n            if flag:\n                err = self.errors[kw]\n                # user provided label-matched dataframe of errors\n                if isinstance(err, (ABCDataFrame, dict)):\n                    if label is not None and label in err.keys():\n                        err = err[label]\n                    else:\n                        err = None\n                elif index is not None and err is not None:\n                    err = err[index]\n\n                if err is not None:\n                    errors[kw] = err\n        return errors\n\n    def _get_subplots(self):\n        from matplotlib.axes import Subplot\n        return [ax for ax in self.axes[0].get_figure().get_axes()\n                if isinstance(ax, Subplot)]\n\n    def _get_axes_layout(self):\n        axes = self._get_subplots()\n        x_set = set()\n        y_set = set()\n        for ax in axes:\n            # check axes coordinates to estimate layout\n            points = ax.get_position().get_points()\n            x_set.add(points[0][0])\n            y_set.add(points[0][1])\n        return (len(y_set), len(x_set))\n\n\nclass PlanePlot(MPLPlot):\n    \"\"\"\n    Abstract class for plotting on plane, currently scatter and hexbin.\n    \"\"\"\n\n    _layout_type = 'single'\n\n    def __init__(self, data, x, y, **kwargs):\n        MPLPlot.__init__(self, data, **kwargs)\n        if x is None or y is None:\n            raise ValueError(self._kind + ' requires an x and y column')\n        if is_integer(x) and not self.data.columns.holds_integer():\n            x = self.data.columns[x]\n        if is_integer(y) and not self.data.columns.holds_integer():\n            y = self.data.columns[y]\n        if len(self.data[x]._get_numeric_data()) == 0:\n            raise ValueError(self._kind + ' requires x column to be numeric')\n        if len(self.data[y]._get_numeric_data()) == 0:\n            raise ValueError(self._kind + ' requires y column to be numeric')\n\n        self.x = x\n        self.y = y\n\n    @property\n    def nseries(self):\n        return 1\n\n    def _post_plot_logic(self, ax, data):\n        x, y = self.x, self.y\n        ax.set_ylabel(pprint_thing(y))\n        ax.set_xlabel(pprint_thing(x))\n\n    def _plot_colorbar(self, ax, **kwds):\n        # Addresses issues #10611 and #10678:\n        # When plotting scatterplots and hexbinplots in IPython\n        # inline backend the colorbar axis height tends not to\n        # exactly match the parent axis height.\n        # The difference is due to small fractional differences\n        # in floating points with similar representation.\n        # To deal with this, this method forces the colorbar\n        # height to take the height of the parent axes.\n        # For a more detailed description of the issue\n        # see the following link:\n        # https://github.com/ipython/ipython/issues/11215\n        img = ax.collections[0]\n        cbar = self.fig.colorbar(img, ax=ax, **kwds)\n\n        if _mpl_ge_3_0_0():\n            # The workaround below is no longer necessary.\n            return\n\n        points = ax.get_position().get_points()\n        cbar_points = cbar.ax.get_position().get_points()\n\n        cbar.ax.set_position([cbar_points[0, 0],\n                              points[0, 1],\n                              cbar_points[1, 0] - cbar_points[0, 0],\n                              points[1, 1] - points[0, 1]])\n        # To see the discrepancy in axis heights uncomment\n        # the following two lines:\n        # print(points[1, 1] - points[0, 1])\n        # print(cbar_points[1, 1] - cbar_points[0, 1])\n\n\nclass ScatterPlot(PlanePlot):\n    _kind = 'scatter'\n\n    def __init__(self, data, x, y, s=None, c=None, **kwargs):\n        if s is None:\n            # hide the matplotlib default for size, in case we want to change\n            # the handling of this argument later\n            s = 20\n        super(ScatterPlot, self).__init__(data, x, y, s=s, **kwargs)\n        if is_integer(c) and not self.data.columns.holds_integer():\n            c = self.data.columns[c]\n        self.c = c\n\n    def _make_plot(self):\n        x, y, c, data = self.x, self.y, self.c, self.data\n        ax = self.axes[0]\n\n        c_is_column = is_hashable(c) and c in self.data.columns\n\n        # plot a colorbar only if a colormap is provided or necessary\n        cb = self.kwds.pop('colorbar', self.colormap or c_is_column)\n\n        # pandas uses colormap, matplotlib uses cmap.\n        cmap = self.colormap or 'Greys'\n        cmap = self.plt.cm.get_cmap(cmap)\n        color = self.kwds.pop(\"color\", None)\n        if c is not None and color is not None:\n            raise TypeError('Specify exactly one of `c` and `color`')\n        elif c is None and color is None:\n            c_values = self.plt.rcParams['patch.facecolor']\n        elif color is not None:\n            c_values = color\n        elif c_is_column:\n            c_values = self.data[c].values\n        else:\n            c_values = c\n\n        if self.legend and hasattr(self, 'label'):\n            label = self.label\n        else:\n            label = None\n        scatter = ax.scatter(data[x].values, data[y].values, c=c_values,\n                             label=label, cmap=cmap, **self.kwds)\n        if cb:\n            cbar_label = c if c_is_column else ''\n            self._plot_colorbar(ax, label=cbar_label)\n\n        if label is not None:\n            self._add_legend_handle(scatter, label)\n        else:\n            self.legend = False\n\n        errors_x = self._get_errorbars(label=x, index=0, yerr=False)\n        errors_y = self._get_errorbars(label=y, index=0, xerr=False)\n        if len(errors_x) > 0 or len(errors_y) > 0:\n            err_kwds = dict(errors_x, **errors_y)\n            err_kwds['ecolor'] = scatter.get_facecolor()[0]\n            ax.errorbar(data[x].values, data[y].values,\n                        linestyle='none', **err_kwds)\n\n\nclass HexBinPlot(PlanePlot):\n    _kind = 'hexbin'\n\n    def __init__(self, data, x, y, C=None, **kwargs):\n        super(HexBinPlot, self).__init__(data, x, y, **kwargs)\n        if is_integer(C) and not self.data.columns.holds_integer():\n            C = self.data.columns[C]\n        self.C = C\n\n    def _make_plot(self):\n        x, y, data, C = self.x, self.y, self.data, self.C\n        ax = self.axes[0]\n        # pandas uses colormap, matplotlib uses cmap.\n        cmap = self.colormap or 'BuGn'\n        cmap = self.plt.cm.get_cmap(cmap)\n        cb = self.kwds.pop('colorbar', True)\n\n        if C is None:\n            c_values = None\n        else:\n            c_values = data[C].values\n\n        ax.hexbin(data[x].values, data[y].values, C=c_values, cmap=cmap,\n                  **self.kwds)\n        if cb:\n            self._plot_colorbar(ax)\n\n    def _make_legend(self):\n        pass\n\n\nclass LinePlot(MPLPlot):\n    _kind = 'line'\n    _default_rot = 0\n    orientation = 'vertical'\n\n    def __init__(self, data, **kwargs):\n        MPLPlot.__init__(self, data, **kwargs)\n        if self.stacked:\n            self.data = self.data.fillna(value=0)\n        self.x_compat = plot_params['x_compat']\n        if 'x_compat' in self.kwds:\n            self.x_compat = bool(self.kwds.pop('x_compat'))\n\n    def _is_ts_plot(self):\n        # this is slightly deceptive\n        return not self.x_compat and self.use_index and self._use_dynamic_x()\n\n    def _use_dynamic_x(self):\n        from pandas.plotting._timeseries import _use_dynamic_x\n        return _use_dynamic_x(self._get_ax(0), self.data)\n\n    def _make_plot(self):\n        if self._is_ts_plot():\n            from pandas.plotting._timeseries import _maybe_convert_index\n            data = _maybe_convert_index(self._get_ax(0), self.data)\n\n            x = data.index      # dummy, not used\n            plotf = self._ts_plot\n            it = self._iter_data(data=data, keep_index=True)\n        else:\n            x = self._get_xticks(convert_period=True)\n            plotf = self._plot\n            it = self._iter_data()\n\n        stacking_id = self._get_stacking_id()\n        is_errorbar = com._any_not_none(*self.errors.values())\n\n        colors = self._get_colors()\n        for i, (label, y) in enumerate(it):\n            ax = self._get_ax(i)\n            kwds = self.kwds.copy()\n            style, kwds = self._apply_style_colors(colors, kwds, i, label)\n\n            errors = self._get_errorbars(label=label, index=i)\n            kwds = dict(kwds, **errors)\n\n            label = pprint_thing(label)  # .encode('utf-8')\n            kwds['label'] = label\n\n            newlines = plotf(ax, x, y, style=style, column_num=i,\n                             stacking_id=stacking_id,\n                             is_errorbar=is_errorbar,\n                             **kwds)\n            self._add_legend_handle(newlines[0], label, index=i)\n\n            lines = _get_all_lines(ax)\n            left, right = _get_xlim(lines)\n            ax.set_xlim(left, right)\n\n    @classmethod\n    def _plot(cls, ax, x, y, style=None, column_num=None,\n              stacking_id=None, **kwds):\n        # column_num is used to get the target column from protf in line and\n        # area plots\n        if column_num == 0:\n            cls._initialize_stacker(ax, stacking_id, len(y))\n        y_values = cls._get_stacked_values(ax, stacking_id, y, kwds['label'])\n        lines = MPLPlot._plot(ax, x, y_values, style=style, **kwds)\n        cls._update_stacker(ax, stacking_id, y)\n        return lines\n\n    @classmethod\n    def _ts_plot(cls, ax, x, data, style=None, **kwds):\n        from pandas.plotting._timeseries import (_maybe_resample,\n                                                 _decorate_axes,\n                                                 format_dateaxis)\n        # accept x to be consistent with normal plot func,\n        # x is not passed to tsplot as it uses data.index as x coordinate\n        # column_num must be in kwds for stacking purpose\n        freq, data = _maybe_resample(data, ax, kwds)\n\n        # Set ax with freq info\n        _decorate_axes(ax, freq, kwds)\n        # digging deeper\n        if hasattr(ax, 'left_ax'):\n            _decorate_axes(ax.left_ax, freq, kwds)\n        if hasattr(ax, 'right_ax'):\n            _decorate_axes(ax.right_ax, freq, kwds)\n        ax._plot_data.append((data, cls._kind, kwds))\n\n        lines = cls._plot(ax, data.index, data.values, style=style, **kwds)\n        # set date formatter, locators and rescale limits\n        format_dateaxis(ax, ax.freq, data.index)\n        return lines\n\n    def _get_stacking_id(self):\n        if self.stacked:\n            return id(self.data)\n        else:\n            return None\n\n    @classmethod\n    def _initialize_stacker(cls, ax, stacking_id, n):\n        if stacking_id is None:\n            return\n        if not hasattr(ax, '_stacker_pos_prior'):\n            ax._stacker_pos_prior = {}\n        if not hasattr(ax, '_stacker_neg_prior'):\n            ax._stacker_neg_prior = {}\n        ax._stacker_pos_prior[stacking_id] = np.zeros(n)\n        ax._stacker_neg_prior[stacking_id] = np.zeros(n)\n\n    @classmethod\n    def _get_stacked_values(cls, ax, stacking_id, values, label):\n        if stacking_id is None:\n            return values\n        if not hasattr(ax, '_stacker_pos_prior'):\n            # stacker may not be initialized for subplots\n            cls._initialize_stacker(ax, stacking_id, len(values))\n\n        if (values >= 0).all():\n            return ax._stacker_pos_prior[stacking_id] + values\n        elif (values <= 0).all():\n            return ax._stacker_neg_prior[stacking_id] + values\n\n        raise ValueError('When stacked is True, each column must be either '\n                         'all positive or negative.'\n                         '{0} contains both positive and negative values'\n                         .format(label))\n\n    @classmethod\n    def _update_stacker(cls, ax, stacking_id, values):\n        if stacking_id is None:\n            return\n        if (values >= 0).all():\n            ax._stacker_pos_prior[stacking_id] += values\n        elif (values <= 0).all():\n            ax._stacker_neg_prior[stacking_id] += values\n\n    def _post_plot_logic(self, ax, data):\n        condition = (not self._use_dynamic_x() and\n                     data.index.is_all_dates and\n                     not self.subplots or\n                     (self.subplots and self.sharex))\n\n        index_name = self._get_index_name()\n\n        if condition:\n            # irregular TS rotated 30 deg. by default\n            # probably a better place to check / set this.\n            if not self._rot_set:\n                self.rot = 30\n            format_date_labels(ax, rot=self.rot)\n\n        if index_name is not None and self.use_index:\n            ax.set_xlabel(index_name)\n\n\nclass AreaPlot(LinePlot):\n    _kind = 'area'\n\n    def __init__(self, data, **kwargs):\n        kwargs.setdefault('stacked', True)\n        data = data.fillna(value=0)\n        LinePlot.__init__(self, data, **kwargs)\n\n        if not self.stacked:\n            # use smaller alpha to distinguish overlap\n            self.kwds.setdefault('alpha', 0.5)\n\n        if self.logy or self.loglog:\n            raise ValueError(\"Log-y scales are not supported in area plot\")\n\n    @classmethod\n    def _plot(cls, ax, x, y, style=None, column_num=None,\n              stacking_id=None, is_errorbar=False, **kwds):\n\n        if column_num == 0:\n            cls._initialize_stacker(ax, stacking_id, len(y))\n        y_values = cls._get_stacked_values(ax, stacking_id, y, kwds['label'])\n\n        # need to remove label, because subplots uses mpl legend as it is\n        line_kwds = kwds.copy()\n        line_kwds.pop('label')\n        lines = MPLPlot._plot(ax, x, y_values, style=style, **line_kwds)\n\n        # get data from the line to get coordinates for fill_between\n        xdata, y_values = lines[0].get_data(orig=False)\n\n        # unable to use ``_get_stacked_values`` here to get starting point\n        if stacking_id is None:\n            start = np.zeros(len(y))\n        elif (y >= 0).all():\n            start = ax._stacker_pos_prior[stacking_id]\n        elif (y <= 0).all():\n            start = ax._stacker_neg_prior[stacking_id]\n        else:\n            start = np.zeros(len(y))\n\n        if 'color' not in kwds:\n            kwds['color'] = lines[0].get_color()\n\n        rect = ax.fill_between(xdata, start, y_values, **kwds)\n        cls._update_stacker(ax, stacking_id, y)\n\n        # LinePlot expects list of artists\n        res = [rect]\n        return res\n\n    def _post_plot_logic(self, ax, data):\n        LinePlot._post_plot_logic(self, ax, data)\n\n        if self.ylim is None:\n            if (data >= 0).all().all():\n                ax.set_ylim(0, None)\n            elif (data <= 0).all().all():\n                ax.set_ylim(None, 0)\n\n\nclass BarPlot(MPLPlot):\n    _kind = 'bar'\n    _default_rot = 90\n    orientation = 'vertical'\n\n    def __init__(self, data, **kwargs):\n        # we have to treat a series differently than a\n        # 1-column DataFrame w.r.t. color handling\n        self._is_series = isinstance(data, ABCSeries)\n        self.bar_width = kwargs.pop('width', 0.5)\n        pos = kwargs.pop('position', 0.5)\n        kwargs.setdefault('align', 'center')\n        self.tick_pos = np.arange(len(data))\n\n        self.bottom = kwargs.pop('bottom', 0)\n        self.left = kwargs.pop('left', 0)\n\n        self.log = kwargs.pop('log', False)\n        MPLPlot.__init__(self, data, **kwargs)\n\n        if self.stacked or self.subplots:\n            self.tickoffset = self.bar_width * pos\n            if kwargs['align'] == 'edge':\n                self.lim_offset = self.bar_width / 2\n            else:\n                self.lim_offset = 0\n        else:\n            if kwargs['align'] == 'edge':\n                w = self.bar_width / self.nseries\n                self.tickoffset = self.bar_width * (pos - 0.5) + w * 0.5\n                self.lim_offset = w * 0.5\n            else:\n                self.tickoffset = self.bar_width * pos\n                self.lim_offset = 0\n\n        self.ax_pos = self.tick_pos - self.tickoffset\n\n    def _args_adjust(self):\n        if is_list_like(self.bottom):\n            self.bottom = np.array(self.bottom)\n        if is_list_like(self.left):\n            self.left = np.array(self.left)\n\n    @classmethod\n    def _plot(cls, ax, x, y, w, start=0, log=False, **kwds):\n        return ax.bar(x, y, w, bottom=start, log=log, **kwds)\n\n    @property\n    def _start_base(self):\n        return self.bottom\n\n    def _make_plot(self):\n        import matplotlib as mpl\n\n        colors = self._get_colors()\n        ncolors = len(colors)\n\n        pos_prior = neg_prior = np.zeros(len(self.data))\n        K = self.nseries\n\n        for i, (label, y) in enumerate(self._iter_data(fillna=0)):\n            ax = self._get_ax(i)\n            kwds = self.kwds.copy()\n            if self._is_series:\n                kwds['color'] = colors\n            else:\n                kwds['color'] = colors[i % ncolors]\n\n            errors = self._get_errorbars(label=label, index=i)\n            kwds = dict(kwds, **errors)\n\n            label = pprint_thing(label)\n\n            if (('yerr' in kwds) or ('xerr' in kwds)) \\\n                    and (kwds.get('ecolor') is None):\n                kwds['ecolor'] = mpl.rcParams['xtick.color']\n\n            start = 0\n            if self.log and (y >= 1).all():\n                start = 1\n            start = start + self._start_base\n\n            if self.subplots:\n                w = self.bar_width / 2\n                rect = self._plot(ax, self.ax_pos + w, y, self.bar_width,\n                                  start=start, label=label,\n                                  log=self.log, **kwds)\n                ax.set_title(label)\n            elif self.stacked:\n                mask = y > 0\n                start = np.where(mask, pos_prior, neg_prior) + self._start_base\n                w = self.bar_width / 2\n                rect = self._plot(ax, self.ax_pos + w, y, self.bar_width,\n                                  start=start, label=label,\n                                  log=self.log, **kwds)\n                pos_prior = pos_prior + np.where(mask, y, 0)\n                neg_prior = neg_prior + np.where(mask, 0, y)\n            else:\n                w = self.bar_width / K\n                rect = self._plot(ax, self.ax_pos + (i + 0.5) * w, y, w,\n                                  start=start, label=label,\n                                  log=self.log, **kwds)\n            self._add_legend_handle(rect, label, index=i)\n\n    def _post_plot_logic(self, ax, data):\n        if self.use_index:\n            str_index = [pprint_thing(key) for key in data.index]\n        else:\n            str_index = [pprint_thing(key) for key in range(data.shape[0])]\n        name = self._get_index_name()\n\n        s_edge = self.ax_pos[0] - 0.25 + self.lim_offset\n        e_edge = self.ax_pos[-1] + 0.25 + self.bar_width + self.lim_offset\n\n        self._decorate_ticks(ax, name, str_index, s_edge, e_edge)\n\n    def _decorate_ticks(self, ax, name, ticklabels, start_edge, end_edge):\n        ax.set_xlim((start_edge, end_edge))\n        ax.set_xticks(self.tick_pos)\n        ax.set_xticklabels(ticklabels)\n        if name is not None and self.use_index:\n            ax.set_xlabel(name)\n\n\nclass BarhPlot(BarPlot):\n    _kind = 'barh'\n    _default_rot = 0\n    orientation = 'horizontal'\n\n    @property\n    def _start_base(self):\n        return self.left\n\n    @classmethod\n    def _plot(cls, ax, x, y, w, start=0, log=False, **kwds):\n        return ax.barh(x, y, w, left=start, log=log, **kwds)\n\n    def _decorate_ticks(self, ax, name, ticklabels, start_edge, end_edge):\n        # horizontal bars\n        ax.set_ylim((start_edge, end_edge))\n        ax.set_yticks(self.tick_pos)\n        ax.set_yticklabels(ticklabels)\n        if name is not None and self.use_index:\n            ax.set_ylabel(name)\n\n\nclass HistPlot(LinePlot):\n    _kind = 'hist'\n\n    def __init__(self, data, bins=10, bottom=0, **kwargs):\n        self.bins = bins        # use mpl default\n        self.bottom = bottom\n        # Do not call LinePlot.__init__ which may fill nan\n        MPLPlot.__init__(self, data, **kwargs)\n\n    def _args_adjust(self):\n        if is_integer(self.bins):\n            # create common bin edge\n            values = (self.data._convert(datetime=True)._get_numeric_data())\n            values = np.ravel(values)\n            values = values[~isna(values)]\n\n            hist, self.bins = np.histogram(\n                values, bins=self.bins,\n                range=self.kwds.get('range', None),\n                weights=self.kwds.get('weights', None))\n\n        if is_list_like(self.bottom):\n            self.bottom = np.array(self.bottom)\n\n    @classmethod\n    def _plot(cls, ax, y, style=None, bins=None, bottom=0, column_num=0,\n              stacking_id=None, **kwds):\n        if column_num == 0:\n            cls._initialize_stacker(ax, stacking_id, len(bins) - 1)\n        y = y[~isna(y)]\n\n        base = np.zeros(len(bins) - 1)\n        bottom = bottom + \\\n            cls._get_stacked_values(ax, stacking_id, base, kwds['label'])\n        # ignore style\n        n, bins, patches = ax.hist(y, bins=bins, bottom=bottom, **kwds)\n        cls._update_stacker(ax, stacking_id, n)\n        return patches\n\n    def _make_plot(self):\n        colors = self._get_colors()\n        stacking_id = self._get_stacking_id()\n\n        for i, (label, y) in enumerate(self._iter_data()):\n            ax = self._get_ax(i)\n\n            kwds = self.kwds.copy()\n\n            label = pprint_thing(label)\n            kwds['label'] = label\n\n            style, kwds = self._apply_style_colors(colors, kwds, i, label)\n            if style is not None:\n                kwds['style'] = style\n\n            kwds = self._make_plot_keywords(kwds, y)\n            artists = self._plot(ax, y, column_num=i,\n                                 stacking_id=stacking_id, **kwds)\n            self._add_legend_handle(artists[0], label, index=i)\n\n    def _make_plot_keywords(self, kwds, y):\n        \"\"\"merge BoxPlot/KdePlot properties to passed kwds\"\"\"\n        # y is required for KdePlot\n        kwds['bottom'] = self.bottom\n        kwds['bins'] = self.bins\n        return kwds\n\n    def _post_plot_logic(self, ax, data):\n        if self.orientation == 'horizontal':\n            ax.set_xlabel('Frequency')\n        else:\n            ax.set_ylabel('Frequency')\n\n    @property\n    def orientation(self):\n        if self.kwds.get('orientation', None) == 'horizontal':\n            return 'horizontal'\n        else:\n            return 'vertical'\n\n\n_kde_docstring = \"\"\"\n        Generate Kernel Density Estimate plot using Gaussian kernels.\n\n        In statistics, `kernel density estimation`_ (KDE) is a non-parametric\n        way to estimate the probability density function (PDF) of a random\n        variable. This function uses Gaussian kernels and includes automatic\n        bandwidth determination.\n\n        .. _kernel density estimation:\n            https://en.wikipedia.org/wiki/Kernel_density_estimation\n\n        Parameters\n        ----------\n        bw_method : str, scalar or callable, optional\n            The method used to calculate the estimator bandwidth. This can be\n            'scott', 'silverman', a scalar constant or a callable.\n            If None (default), 'scott' is used.\n            See :class:`scipy.stats.gaussian_kde` for more information.\n        ind : NumPy array or integer, optional\n            Evaluation points for the estimated PDF. If None (default),\n            1000 equally spaced points are used. If `ind` is a NumPy array, the\n            KDE is evaluated at the points passed. If `ind` is an integer,\n            `ind` number of equally spaced points are used.\n        **kwds : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.%(this-datatype)s.plot`.\n\n        Returns\n        -------\n        axes : matplotlib.axes.Axes or numpy.ndarray of them\n\n        See Also\n        --------\n        scipy.stats.gaussian_kde : Representation of a kernel-density\n            estimate using Gaussian kernels. This is the function used\n            internally to estimate the PDF.\n        %(sibling-datatype)s.plot.kde : Generate a KDE plot for a\n            %(sibling-datatype)s.\n\n        Examples\n        --------\n        %(examples)s\n        \"\"\"\n\n\nclass KdePlot(HistPlot):\n    _kind = 'kde'\n    orientation = 'vertical'\n\n    def __init__(self, data, bw_method=None, ind=None, **kwargs):\n        MPLPlot.__init__(self, data, **kwargs)\n        self.bw_method = bw_method\n        self.ind = ind\n\n    def _args_adjust(self):\n        pass\n\n    def _get_ind(self, y):\n        if self.ind is None:\n            # np.nanmax() and np.nanmin() ignores the missing values\n            sample_range = np.nanmax(y) - np.nanmin(y)\n            ind = np.linspace(np.nanmin(y) - 0.5 * sample_range,\n                              np.nanmax(y) + 0.5 * sample_range, 1000)\n        elif is_integer(self.ind):\n            sample_range = np.nanmax(y) - np.nanmin(y)\n            ind = np.linspace(np.nanmin(y) - 0.5 * sample_range,\n                              np.nanmax(y) + 0.5 * sample_range, self.ind)\n        else:\n            ind = self.ind\n        return ind\n\n    @classmethod\n    def _plot(cls, ax, y, style=None, bw_method=None, ind=None,\n              column_num=None, stacking_id=None, **kwds):\n        from scipy.stats import gaussian_kde\n        from scipy import __version__ as spv\n\n        y = remove_na_arraylike(y)\n\n        if LooseVersion(spv) >= '0.11.0':\n            gkde = gaussian_kde(y, bw_method=bw_method)\n        else:\n            gkde = gaussian_kde(y)\n            if bw_method is not None:\n                msg = ('bw_method was added in Scipy 0.11.0.' +\n                       ' Scipy version in use is {spv}.'.format(spv=spv))\n                warnings.warn(msg)\n\n        y = gkde.evaluate(ind)\n        lines = MPLPlot._plot(ax, ind, y, style=style, **kwds)\n        return lines\n\n    def _make_plot_keywords(self, kwds, y):\n        kwds['bw_method'] = self.bw_method\n        kwds['ind'] = self._get_ind(y)\n        return kwds\n\n    def _post_plot_logic(self, ax, data):\n        ax.set_ylabel('Density')\n\n\nclass PiePlot(MPLPlot):\n    _kind = 'pie'\n    _layout_type = 'horizontal'\n\n    def __init__(self, data, kind=None, **kwargs):\n        data = data.fillna(value=0)\n        if (data < 0).any().any():\n            raise ValueError(\"{0} doesn't allow negative values\".format(kind))\n        MPLPlot.__init__(self, data, kind=kind, **kwargs)\n\n    def _args_adjust(self):\n        self.grid = False\n        self.logy = False\n        self.logx = False\n        self.loglog = False\n\n    def _validate_color_args(self):\n        pass\n\n    def _make_plot(self):\n        colors = self._get_colors(\n            num_colors=len(self.data), color_kwds='colors')\n        self.kwds.setdefault('colors', colors)\n\n        for i, (label, y) in enumerate(self._iter_data()):\n            ax = self._get_ax(i)\n            if label is not None:\n                label = pprint_thing(label)\n                ax.set_ylabel(label)\n\n            kwds = self.kwds.copy()\n\n            def blank_labeler(label, value):\n                if value == 0:\n                    return ''\n                else:\n                    return label\n\n            idx = [pprint_thing(v) for v in self.data.index]\n            labels = kwds.pop('labels', idx)\n            # labels is used for each wedge's labels\n            # Blank out labels for values of 0 so they don't overlap\n            # with nonzero wedges\n            if labels is not None:\n                blabels = [blank_labeler(l, value) for\n                           l, value in zip(labels, y)]\n            else:\n                blabels = None\n            results = ax.pie(y, labels=blabels, **kwds)\n\n            if kwds.get('autopct', None) is not None:\n                patches, texts, autotexts = results\n            else:\n                patches, texts = results\n                autotexts = []\n\n            if self.fontsize is not None:\n                for t in texts + autotexts:\n                    t.set_fontsize(self.fontsize)\n\n            # leglabels is used for legend labels\n            leglabels = labels if labels is not None else idx\n            for p, l in zip(patches, leglabels):\n                self._add_legend_handle(p, l)\n\n\nclass BoxPlot(LinePlot):\n    _kind = 'box'\n    _layout_type = 'horizontal'\n\n    _valid_return_types = (None, 'axes', 'dict', 'both')\n    # namedtuple to hold results\n    BP = namedtuple(\"Boxplot\", ['ax', 'lines'])\n\n    def __init__(self, data, return_type='axes', **kwargs):\n        # Do not call LinePlot.__init__ which may fill nan\n        if return_type not in self._valid_return_types:\n            raise ValueError(\n                \"return_type must be {None, 'axes', 'dict', 'both'}\")\n\n        self.return_type = return_type\n        MPLPlot.__init__(self, data, **kwargs)\n\n    def _args_adjust(self):\n        if self.subplots:\n            # Disable label ax sharing. Otherwise, all subplots shows last\n            # column label\n            if self.orientation == 'vertical':\n                self.sharex = False\n            else:\n                self.sharey = False\n\n    @classmethod\n    def _plot(cls, ax, y, column_num=None, return_type='axes', **kwds):\n        if y.ndim == 2:\n            y = [remove_na_arraylike(v) for v in y]\n            # Boxplot fails with empty arrays, so need to add a NaN\n            #   if any cols are empty\n            # GH 8181\n            y = [v if v.size > 0 else np.array([np.nan]) for v in y]\n        else:\n            y = remove_na_arraylike(y)\n        bp = ax.boxplot(y, **kwds)\n\n        if return_type == 'dict':\n            return bp, bp\n        elif return_type == 'both':\n            return cls.BP(ax=ax, lines=bp), bp\n        else:\n            return ax, bp\n\n    def _validate_color_args(self):\n        if 'color' in self.kwds:\n            if self.colormap is not None:\n                warnings.warn(\"'color' and 'colormap' cannot be used \"\n                              \"simultaneously. Using 'color'\")\n            self.color = self.kwds.pop('color')\n\n            if isinstance(self.color, dict):\n                valid_keys = ['boxes', 'whiskers', 'medians', 'caps']\n                for key, values in compat.iteritems(self.color):\n                    if key not in valid_keys:\n                        raise ValueError(\"color dict contains invalid \"\n                                         \"key '{0}' \"\n                                         \"The key must be either {1}\"\n                                         .format(key, valid_keys))\n        else:\n            self.color = None\n\n        # get standard colors for default\n        colors = _get_standard_colors(num_colors=3,\n                                      colormap=self.colormap,\n                                      color=None)\n        # use 2 colors by default, for box/whisker and median\n        # flier colors isn't needed here\n        # because it can be specified by ``sym`` kw\n        self._boxes_c = colors[0]\n        self._whiskers_c = colors[0]\n        self._medians_c = colors[2]\n        self._caps_c = 'k'          # mpl default\n\n    def _get_colors(self, num_colors=None, color_kwds='color'):\n        pass\n\n    def maybe_color_bp(self, bp):\n        if isinstance(self.color, dict):\n            boxes = self.color.get('boxes', self._boxes_c)\n            whiskers = self.color.get('whiskers', self._whiskers_c)\n            medians = self.color.get('medians', self._medians_c)\n            caps = self.color.get('caps', self._caps_c)\n        else:\n            # Other types are forwarded to matplotlib\n            # If None, use default colors\n            boxes = self.color or self._boxes_c\n            whiskers = self.color or self._whiskers_c\n            medians = self.color or self._medians_c\n            caps = self.color or self._caps_c\n\n        from matplotlib.artist import setp\n        setp(bp['boxes'], color=boxes, alpha=1)\n        setp(bp['whiskers'], color=whiskers, alpha=1)\n        setp(bp['medians'], color=medians, alpha=1)\n        setp(bp['caps'], color=caps, alpha=1)\n\n    def _make_plot(self):\n        if self.subplots:\n            from pandas.core.series import Series\n            self._return_obj = Series()\n\n            for i, (label, y) in enumerate(self._iter_data()):\n                ax = self._get_ax(i)\n                kwds = self.kwds.copy()\n\n                ret, bp = self._plot(ax, y, column_num=i,\n                                     return_type=self.return_type, **kwds)\n                self.maybe_color_bp(bp)\n                self._return_obj[label] = ret\n\n                label = [pprint_thing(label)]\n                self._set_ticklabels(ax, label)\n        else:\n            y = self.data.values.T\n            ax = self._get_ax(0)\n            kwds = self.kwds.copy()\n\n            ret, bp = self._plot(ax, y, column_num=0,\n                                 return_type=self.return_type, **kwds)\n            self.maybe_color_bp(bp)\n            self._return_obj = ret\n\n            labels = [l for l, _ in self._iter_data()]\n            labels = [pprint_thing(l) for l in labels]\n            if not self.use_index:\n                labels = [pprint_thing(key) for key in range(len(labels))]\n            self._set_ticklabels(ax, labels)\n\n    def _set_ticklabels(self, ax, labels):\n        if self.orientation == 'vertical':\n            ax.set_xticklabels(labels)\n        else:\n            ax.set_yticklabels(labels)\n\n    def _make_legend(self):\n        pass\n\n    def _post_plot_logic(self, ax, data):\n        pass\n\n    @property\n    def orientation(self):\n        if self.kwds.get('vert', True):\n            return 'vertical'\n        else:\n            return 'horizontal'\n\n    @property\n    def result(self):\n        if self.return_type is None:\n            return super(BoxPlot, self).result\n        else:\n            return self._return_obj\n\n\n# kinds supported by both dataframe and series\n_common_kinds = ['line', 'bar', 'barh',\n                 'kde', 'density', 'area', 'hist', 'box']\n# kinds supported by dataframe\n_dataframe_kinds = ['scatter', 'hexbin']\n# kinds supported only by series or dataframe single column\n_series_kinds = ['pie']\n_all_kinds = _common_kinds + _dataframe_kinds + _series_kinds\n\n_klasses = [LinePlot, BarPlot, BarhPlot, KdePlot, HistPlot, BoxPlot,\n            ScatterPlot, HexBinPlot, AreaPlot, PiePlot]\n\n_plot_klass = {klass._kind: klass for klass in _klasses}\n\n\ndef _plot(data, x=None, y=None, subplots=False,\n          ax=None, kind='line', **kwds):\n    kind = _get_standard_kind(kind.lower().strip())\n    if kind in _all_kinds:\n        klass = _plot_klass[kind]\n    else:\n        raise ValueError(\"%r is not a valid plot kind\" % kind)\n\n    if kind in _dataframe_kinds:\n        if isinstance(data, ABCDataFrame):\n            plot_obj = klass(data, x=x, y=y, subplots=subplots, ax=ax,\n                             kind=kind, **kwds)\n        else:\n            raise ValueError(\"plot kind %r can only be used for data frames\"\n                             % kind)\n\n    elif kind in _series_kinds:\n        if isinstance(data, ABCDataFrame):\n            if y is None and subplots is False:\n                msg = \"{0} requires either y column or 'subplots=True'\"\n                raise ValueError(msg.format(kind))\n            elif y is not None:\n                if is_integer(y) and not data.columns.holds_integer():\n                    y = data.columns[y]\n                # converted to series actually. copy to not modify\n                data = data[y].copy()\n                data.index.name = y\n        plot_obj = klass(data, subplots=subplots, ax=ax, kind=kind, **kwds)\n    else:\n        if isinstance(data, ABCDataFrame):\n            data_cols = data.columns\n            if x is not None:\n                if is_integer(x) and not data.columns.holds_integer():\n                    x = data_cols[x]\n                elif not isinstance(data[x], ABCSeries):\n                    raise ValueError(\"x must be a label or position\")\n                data = data.set_index(x)\n\n            if y is not None:\n                # check if we have y as int or list of ints\n                int_ylist = is_list_like(y) and all(is_integer(c) for c in y)\n                int_y_arg = is_integer(y) or int_ylist\n                if int_y_arg and not data.columns.holds_integer():\n                    y = data_cols[y]\n\n                label_kw = kwds['label'] if 'label' in kwds else False\n                for kw in ['xerr', 'yerr']:\n                    if (kw in kwds) and \\\n                        (isinstance(kwds[kw], string_types) or\n                            is_integer(kwds[kw])):\n                        try:\n                            kwds[kw] = data[kwds[kw]]\n                        except (IndexError, KeyError, TypeError):\n                            pass\n\n                # don't overwrite\n                data = data[y].copy()\n\n                if isinstance(data, ABCSeries):\n                    label_name = label_kw or y\n                    data.name = label_name\n                else:\n                    match = is_list_like(label_kw) and len(label_kw) == len(y)\n                    if label_kw and not match:\n                        raise ValueError(\n                            \"label should be list-like and same length as y\"\n                        )\n                    label_name = label_kw or data.columns\n                    data.columns = label_name\n\n        plot_obj = klass(data, subplots=subplots, ax=ax, kind=kind, **kwds)\n\n    plot_obj.generate()\n    plot_obj.draw()\n    return plot_obj.result\n\n\ndf_kind = \"\"\"- 'scatter' : scatter plot\n        - 'hexbin' : hexbin plot\"\"\"\nseries_kind = \"\"\n\ndf_coord = \"\"\"x : label or position, default None\n    y : label, position or list of label, positions, default None\n        Allows plotting of one column versus another\"\"\"\nseries_coord = \"\"\n\ndf_unique = \"\"\"stacked : boolean, default False in line and\n        bar plots, and True in area plot. If True, create stacked plot.\n    sort_columns : boolean, default False\n        Sort column names to determine plot ordering\n    secondary_y : boolean or sequence, default False\n        Whether to plot on the secondary y-axis\n        If a list/tuple, which columns to plot on secondary y-axis\"\"\"\nseries_unique = \"\"\"label : label argument to provide to plot\n    secondary_y : boolean or sequence of ints, default False\n        If True then y-axis will be on the right\"\"\"\n\ndf_ax = \"\"\"ax : matplotlib axes object, default None\n    subplots : boolean, default False\n        Make separate subplots for each column\n    sharex : boolean, default True if ax is None else False\n        In case subplots=True, share x axis and set some x axis labels to\n        invisible; defaults to True if ax is None otherwise False if an ax\n        is passed in; Be aware, that passing in both an ax and sharex=True\n        will alter all x axis labels for all axis in a figure!\n    sharey : boolean, default False\n        In case subplots=True, share y axis and set some y axis labels to\n        invisible\n    layout : tuple (optional)\n        (rows, columns) for the layout of subplots\"\"\"\nseries_ax = \"\"\"ax : matplotlib axes object\n        If not passed, uses gca()\"\"\"\n\ndf_note = \"\"\"- If `kind` = 'scatter' and the argument `c` is the name of a dataframe\n      column, the values of that column are used to color each point.\n    - If `kind` = 'hexbin', you can control the size of the bins with the\n      `gridsize` argument. By default, a histogram of the counts around each\n      `(x, y)` point is computed. You can specify alternative aggregations\n      by passing values to the `C` and `reduce_C_function` arguments.\n      `C` specifies the value at each `(x, y)` point and `reduce_C_function`\n      is a function of one argument that reduces all the values in a bin to\n      a single number (e.g. `mean`, `max`, `sum`, `std`).\"\"\"\nseries_note = \"\"\n\n_shared_doc_df_kwargs = dict(klass='DataFrame', klass_obj='df',\n                             klass_kind=df_kind, klass_coord=df_coord,\n                             klass_ax=df_ax, klass_unique=df_unique,\n                             klass_note=df_note)\n_shared_doc_series_kwargs = dict(klass='Series', klass_obj='s',\n                                 klass_kind=series_kind,\n                                 klass_coord=series_coord, klass_ax=series_ax,\n                                 klass_unique=series_unique,\n                                 klass_note=series_note)\n\n_shared_docs['plot'] = \"\"\"\n    Make plots of %(klass)s using matplotlib / pylab.\n\n    *New in version 0.17.0:* Each plot kind has a corresponding method on the\n    ``%(klass)s.plot`` accessor:\n    ``%(klass_obj)s.plot(kind='line')`` is equivalent to\n    ``%(klass_obj)s.plot.line()``.\n\n    Parameters\n    ----------\n    data : %(klass)s\n    %(klass_coord)s\n    kind : str\n        - 'line' : line plot (default)\n        - 'bar' : vertical bar plot\n        - 'barh' : horizontal bar plot\n        - 'hist' : histogram\n        - 'box' : boxplot\n        - 'kde' : Kernel Density Estimation plot\n        - 'density' : same as 'kde'\n        - 'area' : area plot\n        - 'pie' : pie plot\n        %(klass_kind)s\n    %(klass_ax)s\n    figsize : a tuple (width, height) in inches\n    use_index : boolean, default True\n        Use index as ticks for x axis\n    title : string or list\n        Title to use for the plot. If a string is passed, print the string at\n        the top of the figure. If a list is passed and `subplots` is True,\n        print each item in the list above the corresponding subplot.\n    grid : boolean, default None (matlab style default)\n        Axis grid lines\n    legend : False/True/'reverse'\n        Place legend on axis subplots\n    style : list or dict\n        matplotlib line style per column\n    logx : boolean, default False\n        Use log scaling on x axis\n    logy : boolean, default False\n        Use log scaling on y axis\n    loglog : boolean, default False\n        Use log scaling on both x and y axes\n    xticks : sequence\n        Values to use for the xticks\n    yticks : sequence\n        Values to use for the yticks\n    xlim : 2-tuple/list\n    ylim : 2-tuple/list\n    rot : int, default None\n        Rotation for ticks (xticks for vertical, yticks for horizontal plots)\n    fontsize : int, default None\n        Font size for xticks and yticks\n    colormap : str or matplotlib colormap object, default None\n        Colormap to select colors from. If string, load colormap with that name\n        from matplotlib.\n    colorbar : boolean, optional\n        If True, plot colorbar (only relevant for 'scatter' and 'hexbin' plots)\n    position : float\n        Specify relative alignments for bar plot layout.\n        From 0 (left/bottom-end) to 1 (right/top-end). Default is 0.5 (center)\n    table : boolean, Series or DataFrame, default False\n        If True, draw a table using the data in the DataFrame and the data will\n        be transposed to meet matplotlib's default layout.\n        If a Series or DataFrame is passed, use passed data to draw a table.\n    yerr : DataFrame, Series, array-like, dict and str\n        See :ref:`Plotting with Error Bars <visualization.errorbars>` for\n        detail.\n    xerr : same types as yerr.\n    %(klass_unique)s\n    mark_right : boolean, default True\n        When using a secondary_y axis, automatically mark the column\n        labels with \"(right)\" in the legend\n    `**kwds` : keywords\n        Options to pass to matplotlib plotting method\n\n    Returns\n    -------\n    axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n\n    Notes\n    -----\n\n    - See matplotlib documentation online for more on this subject\n    - If `kind` = 'bar' or 'barh', you can specify relative alignments\n      for bar plot layout by `position` keyword.\n      From 0 (left/bottom-end) to 1 (right/top-end). Default is 0.5 (center)\n    %(klass_note)s\n    \"\"\"\n\n\n@Appender(_shared_docs['plot'] % _shared_doc_df_kwargs)\ndef plot_frame(data, x=None, y=None, kind='line', ax=None,\n               subplots=False, sharex=None, sharey=False, layout=None,\n               figsize=None, use_index=True, title=None, grid=None,\n               legend=True, style=None, logx=False, logy=False, loglog=False,\n               xticks=None, yticks=None, xlim=None, ylim=None,\n               rot=None, fontsize=None, colormap=None, table=False,\n               yerr=None, xerr=None,\n               secondary_y=False, sort_columns=False,\n               **kwds):\n    return _plot(data, kind=kind, x=x, y=y, ax=ax,\n                 subplots=subplots, sharex=sharex, sharey=sharey,\n                 layout=layout, figsize=figsize, use_index=use_index,\n                 title=title, grid=grid, legend=legend,\n                 style=style, logx=logx, logy=logy, loglog=loglog,\n                 xticks=xticks, yticks=yticks, xlim=xlim, ylim=ylim,\n                 rot=rot, fontsize=fontsize, colormap=colormap, table=table,\n                 yerr=yerr, xerr=xerr,\n                 secondary_y=secondary_y, sort_columns=sort_columns,\n                 **kwds)\n\n\n@Appender(_shared_docs['plot'] % _shared_doc_series_kwargs)\ndef plot_series(data, kind='line', ax=None,                    # Series unique\n                figsize=None, use_index=True, title=None, grid=None,\n                legend=False, style=None, logx=False, logy=False, loglog=False,\n                xticks=None, yticks=None, xlim=None, ylim=None,\n                rot=None, fontsize=None, colormap=None, table=False,\n                yerr=None, xerr=None,\n                label=None, secondary_y=False,                 # Series unique\n                **kwds):\n\n    import matplotlib.pyplot as plt\n    if ax is None and len(plt.get_fignums()) > 0:\n        ax = _gca()\n        ax = MPLPlot._get_ax_layer(ax)\n    return _plot(data, kind=kind, ax=ax,\n                 figsize=figsize, use_index=use_index, title=title,\n                 grid=grid, legend=legend,\n                 style=style, logx=logx, logy=logy, loglog=loglog,\n                 xticks=xticks, yticks=yticks, xlim=xlim, ylim=ylim,\n                 rot=rot, fontsize=fontsize, colormap=colormap, table=table,\n                 yerr=yerr, xerr=xerr,\n                 label=label, secondary_y=secondary_y,\n                 **kwds)\n\n\n_shared_docs['boxplot'] = \"\"\"\n    Make a box plot from DataFrame columns.\n\n    Make a box-and-whisker plot from DataFrame columns, optionally grouped\n    by some other columns. A box plot is a method for graphically depicting\n    groups of numerical data through their quartiles.\n    The box extends from the Q1 to Q3 quartile values of the data,\n    with a line at the median (Q2). The whiskers extend from the edges\n    of box to show the range of the data. The position of the whiskers\n    is set by default to `1.5 * IQR (IQR = Q3 - Q1)` from the edges of the box.\n    Outlier points are those past the end of the whiskers.\n\n    For further details see\n    Wikipedia's entry for `boxplot <https://en.wikipedia.org/wiki/Box_plot>`_.\n\n    Parameters\n    ----------\n    column : str or list of str, optional\n        Column name or list of names, or vector.\n        Can be any valid input to :meth:`pandas.DataFrame.groupby`.\n    by : str or array-like, optional\n        Column in the DataFrame to :meth:`pandas.DataFrame.groupby`.\n        One box-plot will be done per value of columns in `by`.\n    ax : object of class matplotlib.axes.Axes, optional\n        The matplotlib axes to be used by boxplot.\n    fontsize : float or str\n        Tick label font size in points or as a string (e.g., `large`).\n    rot : int or float, default 0\n        The rotation angle of labels (in degrees)\n        with respect to the screen coordinate system.\n    grid : boolean, default True\n        Setting this to True will show the grid.\n    figsize : A tuple (width, height) in inches\n        The size of the figure to create in matplotlib.\n    layout : tuple (rows, columns), optional\n        For example, (3, 5) will display the subplots\n        using 3 columns and 5 rows, starting from the top-left.\n    return_type : {'axes', 'dict', 'both'} or None, default 'axes'\n        The kind of object to return. The default is ``axes``.\n\n        * 'axes' returns the matplotlib axes the boxplot is drawn on.\n        * 'dict' returns a dictionary whose values are the matplotlib\n          Lines of the boxplot.\n        * 'both' returns a namedtuple with the axes and dict.\n        * when grouping with ``by``, a Series mapping columns to\n          ``return_type`` is returned.\n\n          If ``return_type`` is `None`, a NumPy array\n          of axes with the same shape as ``layout`` is returned.\n    **kwds\n        All other plotting keyword arguments to be passed to\n        :func:`matplotlib.pyplot.boxplot`.\n\n    Returns\n    -------\n    result :\n\n        The return type depends on the `return_type` parameter:\n\n        * 'axes' : object of class matplotlib.axes.Axes\n        * 'dict' : dict of matplotlib.lines.Line2D objects\n        * 'both' : a namedtuple with structure (ax, lines)\n\n        For data grouped with ``by``:\n\n        * :class:`~pandas.Series`\n        * :class:`~numpy.array` (for ``return_type = None``)\n\n    See Also\n    --------\n    Series.plot.hist: Make a histogram.\n    matplotlib.pyplot.boxplot : Matplotlib equivalent plot.\n\n    Notes\n    -----\n    Use ``return_type='dict'`` when you want to tweak the appearance\n    of the lines after plotting. In this case a dict containing the Lines\n    making up the boxes, caps, fliers, medians, and whiskers is returned.\n\n    Examples\n    --------\n\n    Boxplots can be created for every column in the dataframe\n    by ``df.boxplot()`` or indicating the columns to be used:\n\n    .. plot::\n        :context: close-figs\n\n        >>> np.random.seed(1234)\n        >>> df = pd.DataFrame(np.random.randn(10,4),\n        ...                   columns=['Col1', 'Col2', 'Col3', 'Col4'])\n        >>> boxplot = df.boxplot(column=['Col1', 'Col2', 'Col3'])\n\n    Boxplots of variables distributions grouped by the values of a third\n    variable can be created using the option ``by``. For instance:\n\n    .. plot::\n        :context: close-figs\n\n        >>> df = pd.DataFrame(np.random.randn(10, 2),\n        ...                   columns=['Col1', 'Col2'])\n        >>> df['X'] = pd.Series(['A', 'A', 'A', 'A', 'A',\n        ...                      'B', 'B', 'B', 'B', 'B'])\n        >>> boxplot = df.boxplot(by='X')\n\n    A list of strings (i.e. ``['X', 'Y']``) can be passed to boxplot\n    in order to group the data by combination of the variables in the x-axis:\n\n    .. plot::\n        :context: close-figs\n\n        >>> df = pd.DataFrame(np.random.randn(10,3),\n        ...                   columns=['Col1', 'Col2', 'Col3'])\n        >>> df['X'] = pd.Series(['A', 'A', 'A', 'A', 'A',\n        ...                      'B', 'B', 'B', 'B', 'B'])\n        >>> df['Y'] = pd.Series(['A', 'B', 'A', 'B', 'A',\n        ...                      'B', 'A', 'B', 'A', 'B'])\n        >>> boxplot = df.boxplot(column=['Col1', 'Col2'], by=['X', 'Y'])\n\n    The layout of boxplot can be adjusted giving a tuple to ``layout``:\n\n    .. plot::\n        :context: close-figs\n\n        >>> boxplot = df.boxplot(column=['Col1', 'Col2'], by='X',\n        ...                      layout=(2, 1))\n\n    Additional formatting can be done to the boxplot, like suppressing the grid\n    (``grid=False``), rotating the labels in the x-axis (i.e. ``rot=45``)\n    or changing the fontsize (i.e. ``fontsize=15``):\n\n    .. plot::\n        :context: close-figs\n\n        >>> boxplot = df.boxplot(grid=False, rot=45, fontsize=15)\n\n    The parameter ``return_type`` can be used to select the type of element\n    returned by `boxplot`.  When ``return_type='axes'`` is selected,\n    the matplotlib axes on which the boxplot is drawn are returned:\n\n        >>> boxplot = df.boxplot(column=['Col1','Col2'], return_type='axes')\n        >>> type(boxplot)\n        <class 'matplotlib.axes._subplots.AxesSubplot'>\n\n    When grouping with ``by``, a Series mapping columns to ``return_type``\n    is returned:\n\n        >>> boxplot = df.boxplot(column=['Col1', 'Col2'], by='X',\n        ...                      return_type='axes')\n        >>> type(boxplot)\n        <class 'pandas.core.series.Series'>\n\n    If ``return_type`` is `None`, a NumPy array of axes with the same shape\n    as ``layout`` is returned:\n\n        >>> boxplot =  df.boxplot(column=['Col1', 'Col2'], by='X',\n        ...                       return_type=None)\n        >>> type(boxplot)\n        <class 'numpy.ndarray'>\n    \"\"\"\n\n\n@Appender(_shared_docs['boxplot'] % _shared_doc_kwargs)\ndef boxplot(data, column=None, by=None, ax=None, fontsize=None,\n            rot=0, grid=True, figsize=None, layout=None, return_type=None,\n            **kwds):\n\n    # validate return_type:\n    if return_type not in BoxPlot._valid_return_types:\n        raise ValueError(\"return_type must be {'axes', 'dict', 'both'}\")\n\n    if isinstance(data, ABCSeries):\n        data = data.to_frame('x')\n        column = 'x'\n\n    def _get_colors():\n        #  num_colors=3 is required as method maybe_color_bp takes the colors\n        #  in positions 0 and 2.\n        return _get_standard_colors(color=kwds.get('color'), num_colors=3)\n\n    def maybe_color_bp(bp):\n        if 'color' not in kwds:\n            from matplotlib.artist import setp\n            setp(bp['boxes'], color=colors[0], alpha=1)\n            setp(bp['whiskers'], color=colors[0], alpha=1)\n            setp(bp['medians'], color=colors[2], alpha=1)\n\n    def plot_group(keys, values, ax):\n        keys = [pprint_thing(x) for x in keys]\n        values = [np.asarray(remove_na_arraylike(v)) for v in values]\n        bp = ax.boxplot(values, **kwds)\n        if fontsize is not None:\n            ax.tick_params(axis='both', labelsize=fontsize)\n        if kwds.get('vert', 1):\n            ax.set_xticklabels(keys, rotation=rot)\n        else:\n            ax.set_yticklabels(keys, rotation=rot)\n        maybe_color_bp(bp)\n\n        # Return axes in multiplot case, maybe revisit later # 985\n        if return_type == 'dict':\n            return bp\n        elif return_type == 'both':\n            return BoxPlot.BP(ax=ax, lines=bp)\n        else:\n            return ax\n\n    colors = _get_colors()\n    if column is None:\n        columns = None\n    else:\n        if isinstance(column, (list, tuple)):\n            columns = column\n        else:\n            columns = [column]\n\n    if by is not None:\n        # Prefer array return type for 2-D plots to match the subplot layout\n        # https://github.com/pandas-dev/pandas/pull/12216#issuecomment-241175580\n        result = _grouped_plot_by_column(plot_group, data, columns=columns,\n                                         by=by, grid=grid, figsize=figsize,\n                                         ax=ax, layout=layout,\n                                         return_type=return_type)\n    else:\n        if return_type is None:\n            return_type = 'axes'\n        if layout is not None:\n            raise ValueError(\"The 'layout' keyword is not supported when \"\n                             \"'by' is None\")\n\n        if ax is None:\n            rc = {'figure.figsize': figsize} if figsize is not None else {}\n            ax = _gca(rc)\n        data = data._get_numeric_data()\n        if columns is None:\n            columns = data.columns\n        else:\n            data = data[columns]\n\n        result = plot_group(columns, data.values.T, ax)\n        ax.grid(grid)\n\n    return result\n\n\n@Appender(_shared_docs['boxplot'] % _shared_doc_kwargs)\ndef boxplot_frame(self, column=None, by=None, ax=None, fontsize=None, rot=0,\n                  grid=True, figsize=None, layout=None,\n                  return_type=None, **kwds):\n    import matplotlib.pyplot as plt\n    _converter._WARN = False\n    ax = boxplot(self, column=column, by=by, ax=ax, fontsize=fontsize,\n                 grid=grid, rot=rot, figsize=figsize, layout=layout,\n                 return_type=return_type, **kwds)\n    plt.draw_if_interactive()\n    return ax\n\n\ndef scatter_plot(data, x, y, by=None, ax=None, figsize=None, grid=False,\n                 **kwargs):\n    \"\"\"\n    Make a scatter plot from two DataFrame columns\n\n    Parameters\n    ----------\n    data : DataFrame\n    x : Column name for the x-axis values\n    y : Column name for the y-axis values\n    ax : Matplotlib axis object\n    figsize : A tuple (width, height) in inches\n    grid : Setting this to True will show the grid\n    kwargs : other plotting keyword arguments\n        To be passed to scatter function\n\n    Returns\n    -------\n    fig : matplotlib.Figure\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    kwargs.setdefault('edgecolors', 'none')\n\n    def plot_group(group, ax):\n        xvals = group[x].values\n        yvals = group[y].values\n        ax.scatter(xvals, yvals, **kwargs)\n        ax.grid(grid)\n\n    if by is not None:\n        fig = _grouped_plot(plot_group, data, by=by, figsize=figsize, ax=ax)\n    else:\n        if ax is None:\n            fig = plt.figure()\n            ax = fig.add_subplot(111)\n        else:\n            fig = ax.get_figure()\n        plot_group(data, ax)\n        ax.set_ylabel(pprint_thing(y))\n        ax.set_xlabel(pprint_thing(x))\n\n        ax.grid(grid)\n\n    return fig\n\n\ndef hist_frame(data, column=None, by=None, grid=True, xlabelsize=None,\n               xrot=None, ylabelsize=None, yrot=None, ax=None, sharex=False,\n               sharey=False, figsize=None, layout=None, bins=10, **kwds):\n    \"\"\"\n    Make a histogram of the DataFrame's.\n\n    A `histogram`_ is a representation of the distribution of data.\n    This function calls :meth:`matplotlib.pyplot.hist`, on each series in\n    the DataFrame, resulting in one histogram per column.\n\n    .. _histogram: https://en.wikipedia.org/wiki/Histogram\n\n    Parameters\n    ----------\n    data : DataFrame\n        The pandas object holding the data.\n    column : string or sequence\n        If passed, will be used to limit data to a subset of columns.\n    by : object, optional\n        If passed, then used to form histograms for separate groups.\n    grid : boolean, default True\n        Whether to show axis grid lines.\n    xlabelsize : int, default None\n        If specified changes the x-axis label size.\n    xrot : float, default None\n        Rotation of x axis labels. For example, a value of 90 displays the\n        x labels rotated 90 degrees clockwise.\n    ylabelsize : int, default None\n        If specified changes the y-axis label size.\n    yrot : float, default None\n        Rotation of y axis labels. For example, a value of 90 displays the\n        y labels rotated 90 degrees clockwise.\n    ax : Matplotlib axes object, default None\n        The axes to plot the histogram on.\n    sharex : boolean, default True if ax is None else False\n        In case subplots=True, share x axis and set some x axis labels to\n        invisible; defaults to True if ax is None otherwise False if an ax\n        is passed in.\n        Note that passing in both an ax and sharex=True will alter all x axis\n        labels for all subplots in a figure.\n    sharey : boolean, default False\n        In case subplots=True, share y axis and set some y axis labels to\n        invisible.\n    figsize : tuple\n        The size in inches of the figure to create. Uses the value in\n        `matplotlib.rcParams` by default.\n    layout : tuple, optional\n        Tuple of (rows, columns) for the layout of the histograms.\n    bins : integer or sequence, default 10\n        Number of histogram bins to be used. If an integer is given, bins + 1\n        bin edges are calculated and returned. If bins is a sequence, gives\n        bin edges, including left edge of first bin and right edge of last\n        bin. In this case, bins is returned unmodified.\n    **kwds\n        All other plotting keyword arguments to be passed to\n        :meth:`matplotlib.pyplot.hist`.\n\n    Returns\n    -------\n    axes : matplotlib.AxesSubplot or numpy.ndarray of them\n\n    See Also\n    --------\n    matplotlib.pyplot.hist : Plot a histogram using matplotlib.\n\n    Examples\n    --------\n\n    .. plot::\n        :context: close-figs\n\n        This example draws a histogram based on the length and width of\n        some animals, displayed in three bins\n\n        >>> df = pd.DataFrame({\n        ...     'length': [1.5, 0.5, 1.2, 0.9, 3],\n        ...     'width': [0.7, 0.2, 0.15, 0.2, 1.1]\n        ...     }, index= ['pig', 'rabbit', 'duck', 'chicken', 'horse'])\n        >>> hist = df.hist(bins=3)\n    \"\"\"\n    _raise_if_no_mpl()\n    _converter._WARN = False\n    if by is not None:\n        axes = grouped_hist(data, column=column, by=by, ax=ax, grid=grid,\n                            figsize=figsize, sharex=sharex, sharey=sharey,\n                            layout=layout, bins=bins, xlabelsize=xlabelsize,\n                            xrot=xrot, ylabelsize=ylabelsize,\n                            yrot=yrot, **kwds)\n        return axes\n\n    if column is not None:\n        if not isinstance(column, (list, np.ndarray, ABCIndexClass)):\n            column = [column]\n        data = data[column]\n    data = data._get_numeric_data()\n    naxes = len(data.columns)\n\n    fig, axes = _subplots(naxes=naxes, ax=ax, squeeze=False,\n                          sharex=sharex, sharey=sharey, figsize=figsize,\n                          layout=layout)\n    _axes = _flatten(axes)\n\n    for i, col in enumerate(com.try_sort(data.columns)):\n        ax = _axes[i]\n        ax.hist(data[col].dropna().values, bins=bins, **kwds)\n        ax.set_title(col)\n        ax.grid(grid)\n\n    _set_ticks_props(axes, xlabelsize=xlabelsize, xrot=xrot,\n                     ylabelsize=ylabelsize, yrot=yrot)\n    fig.subplots_adjust(wspace=0.3, hspace=0.3)\n\n    return axes\n\n\ndef hist_series(self, by=None, ax=None, grid=True, xlabelsize=None,\n                xrot=None, ylabelsize=None, yrot=None, figsize=None,\n                bins=10, **kwds):\n    \"\"\"\n    Draw histogram of the input series using matplotlib.\n\n    Parameters\n    ----------\n    by : object, optional\n        If passed, then used to form histograms for separate groups\n    ax : matplotlib axis object\n        If not passed, uses gca()\n    grid : boolean, default True\n        Whether to show axis grid lines\n    xlabelsize : int, default None\n        If specified changes the x-axis label size\n    xrot : float, default None\n        rotation of x axis labels\n    ylabelsize : int, default None\n        If specified changes the y-axis label size\n    yrot : float, default None\n        rotation of y axis labels\n    figsize : tuple, default None\n        figure size in inches by default\n    bins : integer or sequence, default 10\n        Number of histogram bins to be used. If an integer is given, bins + 1\n        bin edges are calculated and returned. If bins is a sequence, gives\n        bin edges, including left edge of first bin and right edge of last\n        bin. In this case, bins is returned unmodified.\n    bins : integer, default 10\n        Number of histogram bins to be used\n    `**kwds` : keywords\n        To be passed to the actual plotting function\n\n    See Also\n    --------\n    matplotlib.axes.Axes.hist : Plot a histogram using matplotlib.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    if by is None:\n        if kwds.get('layout', None) is not None:\n            raise ValueError(\"The 'layout' keyword is not supported when \"\n                             \"'by' is None\")\n        # hack until the plotting interface is a bit more unified\n        fig = kwds.pop('figure', plt.gcf() if plt.get_fignums() else\n                       plt.figure(figsize=figsize))\n        if (figsize is not None and tuple(figsize) !=\n                tuple(fig.get_size_inches())):\n            fig.set_size_inches(*figsize, forward=True)\n        if ax is None:\n            ax = fig.gca()\n        elif ax.get_figure() != fig:\n            raise AssertionError('passed axis not bound to passed figure')\n        values = self.dropna().values\n\n        ax.hist(values, bins=bins, **kwds)\n        ax.grid(grid)\n        axes = np.array([ax])\n\n        _set_ticks_props(axes, xlabelsize=xlabelsize, xrot=xrot,\n                         ylabelsize=ylabelsize, yrot=yrot)\n\n    else:\n        if 'figure' in kwds:\n            raise ValueError(\"Cannot pass 'figure' when using the \"\n                             \"'by' argument, since a new 'Figure' instance \"\n                             \"will be created\")\n        axes = grouped_hist(self, by=by, ax=ax, grid=grid, figsize=figsize,\n                            bins=bins, xlabelsize=xlabelsize, xrot=xrot,\n                            ylabelsize=ylabelsize, yrot=yrot, **kwds)\n\n    if hasattr(axes, 'ndim'):\n        if axes.ndim == 1 and len(axes) == 1:\n            return axes[0]\n    return axes\n\n\ndef grouped_hist(data, column=None, by=None, ax=None, bins=50, figsize=None,\n                 layout=None, sharex=False, sharey=False, rot=90, grid=True,\n                 xlabelsize=None, xrot=None, ylabelsize=None, yrot=None,\n                 **kwargs):\n    \"\"\"\n    Grouped histogram\n\n    Parameters\n    ----------\n    data : Series/DataFrame\n    column : object, optional\n    by : object, optional\n    ax : axes, optional\n    bins : int, default 50\n    figsize : tuple, optional\n    layout : optional\n    sharex : boolean, default False\n    sharey : boolean, default False\n    rot : int, default 90\n    grid : bool, default True\n    kwargs : dict, keyword arguments passed to matplotlib.Axes.hist\n\n    Returns\n    -------\n    axes : collection of Matplotlib Axes\n    \"\"\"\n    _raise_if_no_mpl()\n    _converter._WARN = False\n\n    def plot_group(group, ax):\n        ax.hist(group.dropna().values, bins=bins, **kwargs)\n\n    xrot = xrot or rot\n\n    fig, axes = _grouped_plot(plot_group, data, column=column,\n                              by=by, sharex=sharex, sharey=sharey, ax=ax,\n                              figsize=figsize, layout=layout, rot=rot)\n\n    _set_ticks_props(axes, xlabelsize=xlabelsize, xrot=xrot,\n                     ylabelsize=ylabelsize, yrot=yrot)\n\n    fig.subplots_adjust(bottom=0.15, top=0.9, left=0.1, right=0.9,\n                        hspace=0.5, wspace=0.3)\n    return axes\n\n\ndef boxplot_frame_groupby(grouped, subplots=True, column=None, fontsize=None,\n                          rot=0, grid=True, ax=None, figsize=None,\n                          layout=None, sharex=False, sharey=True, **kwds):\n    \"\"\"\n    Make box plots from DataFrameGroupBy data.\n\n    Parameters\n    ----------\n    grouped : Grouped DataFrame\n    subplots :\n        * ``False`` - no subplots will be used\n        * ``True`` - create a subplot for each group\n    column : column name or list of names, or vector\n        Can be any valid input to groupby\n    fontsize : int or string\n    rot : label rotation angle\n    grid : Setting this to True will show the grid\n    ax : Matplotlib axis object, default None\n    figsize : A tuple (width, height) in inches\n    layout : tuple (optional)\n        (rows, columns) for the layout of the plot\n    sharex : bool, default False\n        Whether x-axes will be shared among subplots\n\n        .. versionadded:: 0.23.1\n    sharey : bool, default True\n        Whether y-axes will be shared among subplots\n\n        .. versionadded:: 0.23.1\n    `**kwds` : Keyword Arguments\n        All other plotting keyword arguments to be passed to\n        matplotlib's boxplot function\n\n    Returns\n    -------\n    dict of key/value = group key/DataFrame.boxplot return value\n    or DataFrame.boxplot return value in case subplots=figures=False\n\n    Examples\n    --------\n    >>> import itertools\n    >>> tuples = [t for t in itertools.product(range(1000), range(4))]\n    >>> index = pd.MultiIndex.from_tuples(tuples, names=['lvl0', 'lvl1'])\n    >>> data = np.random.randn(len(index),4)\n    >>> df = pd.DataFrame(data, columns=list('ABCD'), index=index)\n    >>>\n    >>> grouped = df.groupby(level='lvl1')\n    >>> boxplot_frame_groupby(grouped)\n    >>>\n    >>> grouped = df.unstack(level='lvl1').groupby(level=0, axis=1)\n    >>> boxplot_frame_groupby(grouped, subplots=False)\n    \"\"\"\n    _raise_if_no_mpl()\n    _converter._WARN = False\n    if subplots is True:\n        naxes = len(grouped)\n        fig, axes = _subplots(naxes=naxes, squeeze=False,\n                              ax=ax, sharex=sharex, sharey=sharey,\n                              figsize=figsize, layout=layout)\n        axes = _flatten(axes)\n\n        from pandas.core.series import Series\n        ret = Series()\n        for (key, group), ax in zip(grouped, axes):\n            d = group.boxplot(ax=ax, column=column, fontsize=fontsize,\n                              rot=rot, grid=grid, **kwds)\n            ax.set_title(pprint_thing(key))\n            ret.loc[key] = d\n        fig.subplots_adjust(bottom=0.15, top=0.9, left=0.1,\n                            right=0.9, wspace=0.2)\n    else:\n        from pandas.core.reshape.concat import concat\n        keys, frames = zip(*grouped)\n        if grouped.axis == 0:\n            df = concat(frames, keys=keys, axis=1)\n        else:\n            if len(frames) > 1:\n                df = frames[0].join(frames[1::])\n            else:\n                df = frames[0]\n        ret = df.boxplot(column=column, fontsize=fontsize, rot=rot,\n                         grid=grid, ax=ax, figsize=figsize,\n                         layout=layout, **kwds)\n    return ret\n\n\ndef _grouped_plot(plotf, data, column=None, by=None, numeric_only=True,\n                  figsize=None, sharex=True, sharey=True, layout=None,\n                  rot=0, ax=None, **kwargs):\n\n    if figsize == 'default':\n        # allowed to specify mpl default with 'default'\n        warnings.warn(\"figsize='default' is deprecated. Specify figure\"\n                      \"size by tuple instead\", FutureWarning, stacklevel=4)\n        figsize = None\n\n    grouped = data.groupby(by)\n    if column is not None:\n        grouped = grouped[column]\n\n    naxes = len(grouped)\n    fig, axes = _subplots(naxes=naxes, figsize=figsize,\n                          sharex=sharex, sharey=sharey, ax=ax,\n                          layout=layout)\n\n    _axes = _flatten(axes)\n\n    for i, (key, group) in enumerate(grouped):\n        ax = _axes[i]\n        if numeric_only and isinstance(group, ABCDataFrame):\n            group = group._get_numeric_data()\n        plotf(group, ax, **kwargs)\n        ax.set_title(pprint_thing(key))\n\n    return fig, axes\n\n\ndef _grouped_plot_by_column(plotf, data, columns=None, by=None,\n                            numeric_only=True, grid=False,\n                            figsize=None, ax=None, layout=None,\n                            return_type=None, **kwargs):\n    grouped = data.groupby(by)\n    if columns is None:\n        if not isinstance(by, (list, tuple)):\n            by = [by]\n        columns = data._get_numeric_data().columns.difference(by)\n    naxes = len(columns)\n    fig, axes = _subplots(naxes=naxes, sharex=True, sharey=True,\n                          figsize=figsize, ax=ax, layout=layout)\n\n    _axes = _flatten(axes)\n\n    ax_values = []\n\n    for i, col in enumerate(columns):\n        ax = _axes[i]\n        gp_col = grouped[col]\n        keys, values = zip(*gp_col)\n        re_plotf = plotf(keys, values, ax, **kwargs)\n        ax.set_title(col)\n        ax.set_xlabel(pprint_thing(by))\n        ax_values.append(re_plotf)\n        ax.grid(grid)\n\n    from pandas.core.series import Series\n    result = Series(ax_values, index=columns)\n\n    # Return axes in multiplot case, maybe revisit later # 985\n    if return_type is None:\n        result = axes\n\n    byline = by[0] if len(by) == 1 else by\n    fig.suptitle('Boxplot grouped by {byline}'.format(byline=byline))\n    fig.subplots_adjust(bottom=0.15, top=0.9, left=0.1, right=0.9, wspace=0.2)\n\n    return result\n\n\nclass BasePlotMethods(PandasObject):\n\n    def __init__(self, data):\n        self._parent = data  # can be Series or DataFrame\n\n    def __call__(self, *args, **kwargs):\n        raise NotImplementedError\n\n\nclass SeriesPlotMethods(BasePlotMethods):\n    \"\"\"\n    Series plotting accessor and method.\n\n    Examples\n    --------\n    >>> s.plot.line()\n    >>> s.plot.bar()\n    >>> s.plot.hist()\n\n    Plotting methods can also be accessed by calling the accessor as a method\n    with the ``kind`` argument:\n    ``s.plot(kind='line')`` is equivalent to ``s.plot.line()``\n    \"\"\"\n\n    def __call__(self, kind='line', ax=None,\n                 figsize=None, use_index=True, title=None, grid=None,\n                 legend=False, style=None, logx=False, logy=False,\n                 loglog=False, xticks=None, yticks=None,\n                 xlim=None, ylim=None,\n                 rot=None, fontsize=None, colormap=None, table=False,\n                 yerr=None, xerr=None,\n                 label=None, secondary_y=False, **kwds):\n        return plot_series(self._parent, kind=kind, ax=ax, figsize=figsize,\n                           use_index=use_index, title=title, grid=grid,\n                           legend=legend, style=style, logx=logx, logy=logy,\n                           loglog=loglog, xticks=xticks, yticks=yticks,\n                           xlim=xlim, ylim=ylim, rot=rot, fontsize=fontsize,\n                           colormap=colormap, table=table, yerr=yerr,\n                           xerr=xerr, label=label, secondary_y=secondary_y,\n                           **kwds)\n    __call__.__doc__ = plot_series.__doc__\n\n    def line(self, **kwds):\n        \"\"\"\n        Line plot.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n\n        Examples\n        --------\n\n        .. plot::\n            :context: close-figs\n\n            >>> s = pd.Series([1, 3, 2])\n            >>> s.plot.line()\n        \"\"\"\n        return self(kind='line', **kwds)\n\n    def bar(self, **kwds):\n        \"\"\"\n        Vertical bar plot.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='bar', **kwds)\n\n    def barh(self, **kwds):\n        \"\"\"\n        Horizontal bar plot.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='barh', **kwds)\n\n    def box(self, **kwds):\n        \"\"\"\n        Boxplot.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='box', **kwds)\n\n    def hist(self, bins=10, **kwds):\n        \"\"\"\n        Histogram.\n\n        Parameters\n        ----------\n        bins : integer, default 10\n            Number of histogram bins to be used\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='hist', bins=bins, **kwds)\n\n    @Appender(_kde_docstring % {\n        'this-datatype': 'Series',\n        'sibling-datatype': 'DataFrame',\n        'examples': \"\"\"\n        Given a Series of points randomly sampled from an unknown\n        distribution, estimate its PDF using KDE with automatic\n        bandwidth determination and plot the results, evaluating them at\n        1000 equally spaced points (default):\n\n        .. plot::\n            :context: close-figs\n\n            >>> s = pd.Series([1, 2, 2.5, 3, 3.5, 4, 5])\n            >>> ax = s.plot.kde()\n\n        A scalar bandwidth can be specified. Using a small bandwidth value can\n        lead to over-fitting, while using a large bandwidth value may result\n        in under-fitting:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = s.plot.kde(bw_method=0.3)\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = s.plot.kde(bw_method=3)\n\n        Finally, the `ind` parameter determines the evaluation points for the\n        plot of the estimated PDF:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = s.plot.kde(ind=[1, 2, 3, 4, 5])\n        \"\"\".strip()\n    })\n    def kde(self, bw_method=None, ind=None, **kwds):\n        return self(kind='kde', bw_method=bw_method, ind=ind, **kwds)\n\n    density = kde\n\n    def area(self, **kwds):\n        \"\"\"\n        Area plot.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='area', **kwds)\n\n    def pie(self, **kwds):\n        \"\"\"\n        Pie chart.\n\n        Parameters\n        ----------\n        `**kwds` : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.Series.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n        \"\"\"\n        return self(kind='pie', **kwds)\n\n\nclass FramePlotMethods(BasePlotMethods):\n    \"\"\"DataFrame plotting accessor and method\n\n    Examples\n    --------\n    >>> df.plot.line()\n    >>> df.plot.scatter('x', 'y')\n    >>> df.plot.hexbin()\n\n    These plotting methods can also be accessed by calling the accessor as a\n    method with the ``kind`` argument:\n    ``df.plot(kind='line')`` is equivalent to ``df.plot.line()``\n    \"\"\"\n\n    def __call__(self, x=None, y=None, kind='line', ax=None,\n                 subplots=False, sharex=None, sharey=False, layout=None,\n                 figsize=None, use_index=True, title=None, grid=None,\n                 legend=True, style=None, logx=False, logy=False, loglog=False,\n                 xticks=None, yticks=None, xlim=None, ylim=None,\n                 rot=None, fontsize=None, colormap=None, table=False,\n                 yerr=None, xerr=None,\n                 secondary_y=False, sort_columns=False, **kwds):\n        return plot_frame(self._parent, kind=kind, x=x, y=y, ax=ax,\n                          subplots=subplots, sharex=sharex, sharey=sharey,\n                          layout=layout, figsize=figsize, use_index=use_index,\n                          title=title, grid=grid, legend=legend, style=style,\n                          logx=logx, logy=logy, loglog=loglog, xticks=xticks,\n                          yticks=yticks, xlim=xlim, ylim=ylim, rot=rot,\n                          fontsize=fontsize, colormap=colormap, table=table,\n                          yerr=yerr, xerr=xerr, secondary_y=secondary_y,\n                          sort_columns=sort_columns, **kwds)\n    __call__.__doc__ = plot_frame.__doc__\n\n    def line(self, x=None, y=None, **kwds):\n        \"\"\"\n        Plot DataFrame columns as lines.\n\n        This function is useful to plot lines using DataFrame's values\n        as coordinates.\n\n        Parameters\n        ----------\n        x : int or str, optional\n            Columns to use for the horizontal axis.\n            Either the location or the label of the columns to be used.\n            By default, it will use the DataFrame indices.\n        y : int, str, or list of them, optional\n            The values to be plotted.\n            Either the location or the label of the columns to be used.\n            By default, it will use the remaining DataFrame numeric columns.\n        **kwds\n            Keyword arguments to pass on to :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or :class:`numpy.ndarray`\n            Returns an ndarray when ``subplots=True``.\n\n        See Also\n        --------\n        matplotlib.pyplot.plot : Plot y versus x as lines and/or markers.\n\n        Examples\n        --------\n\n        .. plot::\n            :context: close-figs\n\n            The following example shows the populations for some animals\n            over the years.\n\n            >>> df = pd.DataFrame({\n            ...    'pig': [20, 18, 489, 675, 1776],\n            ...    'horse': [4, 25, 281, 600, 1900]\n            ...    }, index=[1990, 1997, 2003, 2009, 2014])\n            >>> lines = df.plot.line()\n\n        .. plot::\n           :context: close-figs\n\n           An example with subplots, so an array of axes is returned.\n\n           >>> axes = df.plot.line(subplots=True)\n           >>> type(axes)\n           <class 'numpy.ndarray'>\n\n        .. plot::\n            :context: close-figs\n\n            The following example shows the relationship between both\n            populations.\n\n            >>> lines = df.plot.line(x='pig', y='horse')\n        \"\"\"\n        return self(kind='line', x=x, y=y, **kwds)\n\n    def bar(self, x=None, y=None, **kwds):\n        \"\"\"\n        Vertical bar plot.\n\n        A bar plot is a plot that presents categorical data with\n        rectangular bars with lengths proportional to the values that they\n        represent. A bar plot shows comparisons among discrete categories. One\n        axis of the plot shows the specific categories being compared, and the\n        other axis represents a measured value.\n\n        Parameters\n        ----------\n        x : label or position, optional\n            Allows plotting of one column versus another. If not specified,\n            the index of the DataFrame is used.\n        y : label or position, optional\n            Allows plotting of one column versus another. If not specified,\n            all numerical columns are used.\n        **kwds\n            Additional keyword arguments are documented in\n            :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : matplotlib.axes.Axes or np.ndarray of them\n            An ndarray is returned with one :class:`matplotlib.axes.Axes`\n            per column when ``subplots=True``.\n\n        See Also\n        --------\n        pandas.DataFrame.plot.barh : Horizontal bar plot.\n        pandas.DataFrame.plot : Make plots of a DataFrame.\n        matplotlib.pyplot.bar : Make a bar plot with matplotlib.\n\n        Examples\n        --------\n        Basic plot.\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({'lab':['A', 'B', 'C'], 'val':[10, 30, 20]})\n            >>> ax = df.plot.bar(x='lab', y='val', rot=0)\n\n        Plot a whole dataframe to a bar plot. Each column is assigned a\n        distinct color, and each row is nested in a group along the\n        horizontal axis.\n\n        .. plot::\n            :context: close-figs\n\n            >>> speed = [0.1, 17.5, 40, 48, 52, 69, 88]\n            >>> lifespan = [2, 8, 70, 1.5, 25, 12, 28]\n            >>> index = ['snail', 'pig', 'elephant',\n            ...          'rabbit', 'giraffe', 'coyote', 'horse']\n            >>> df = pd.DataFrame({'speed': speed,\n            ...                    'lifespan': lifespan}, index=index)\n            >>> ax = df.plot.bar(rot=0)\n\n        Instead of nesting, the figure can be split by column with\n        ``subplots=True``. In this case, a :class:`numpy.ndarray` of\n        :class:`matplotlib.axes.Axes` are returned.\n\n        .. plot::\n            :context: close-figs\n\n            >>> axes = df.plot.bar(rot=0, subplots=True)\n            >>> axes[1].legend(loc=2)  # doctest: +SKIP\n\n        Plot a single column.\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.bar(y='speed', rot=0)\n\n        Plot only selected categories for the DataFrame.\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.bar(x='lifespan', rot=0)\n        \"\"\"\n        return self(kind='bar', x=x, y=y, **kwds)\n\n    def barh(self, x=None, y=None, **kwds):\n        \"\"\"\n        Make a horizontal bar plot.\n\n        A horizontal bar plot is a plot that presents quantitative data with\n        rectangular bars with lengths proportional to the values that they\n        represent. A bar plot shows comparisons among discrete categories. One\n        axis of the plot shows the specific categories being compared, and the\n        other axis represents a measured value.\n\n        Parameters\n        ----------\n        x : label or position, default DataFrame.index\n            Column to be used for categories.\n        y : label or position, default All numeric columns in dataframe\n            Columns to be plotted from the DataFrame.\n        **kwds\n            Keyword arguments to pass on to :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them.\n\n        See Also\n        --------\n        pandas.DataFrame.plot.bar: Vertical bar plot.\n        pandas.DataFrame.plot : Make plots of DataFrame using matplotlib.\n        matplotlib.axes.Axes.bar : Plot a vertical bar plot using matplotlib.\n\n        Examples\n        --------\n        Basic example\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({'lab':['A', 'B', 'C'], 'val':[10, 30, 20]})\n            >>> ax = df.plot.barh(x='lab', y='val')\n\n        Plot a whole DataFrame to a horizontal bar plot\n\n        .. plot::\n            :context: close-figs\n\n            >>> speed = [0.1, 17.5, 40, 48, 52, 69, 88]\n            >>> lifespan = [2, 8, 70, 1.5, 25, 12, 28]\n            >>> index = ['snail', 'pig', 'elephant',\n            ...          'rabbit', 'giraffe', 'coyote', 'horse']\n            >>> df = pd.DataFrame({'speed': speed,\n            ...                    'lifespan': lifespan}, index=index)\n            >>> ax = df.plot.barh()\n\n        Plot a column of the DataFrame to a horizontal bar plot\n\n        .. plot::\n            :context: close-figs\n\n            >>> speed = [0.1, 17.5, 40, 48, 52, 69, 88]\n            >>> lifespan = [2, 8, 70, 1.5, 25, 12, 28]\n            >>> index = ['snail', 'pig', 'elephant',\n            ...          'rabbit', 'giraffe', 'coyote', 'horse']\n            >>> df = pd.DataFrame({'speed': speed,\n            ...                    'lifespan': lifespan}, index=index)\n            >>> ax = df.plot.barh(y='speed')\n\n        Plot DataFrame versus the desired column\n\n        .. plot::\n            :context: close-figs\n\n            >>> speed = [0.1, 17.5, 40, 48, 52, 69, 88]\n            >>> lifespan = [2, 8, 70, 1.5, 25, 12, 28]\n            >>> index = ['snail', 'pig', 'elephant',\n            ...          'rabbit', 'giraffe', 'coyote', 'horse']\n            >>> df = pd.DataFrame({'speed': speed,\n            ...                    'lifespan': lifespan}, index=index)\n            >>> ax = df.plot.barh(x='lifespan')\n        \"\"\"\n        return self(kind='barh', x=x, y=y, **kwds)\n\n    def box(self, by=None, **kwds):\n        r\"\"\"\n        Make a box plot of the DataFrame columns.\n\n        A box plot is a method for graphically depicting groups of numerical\n        data through their quartiles.\n        The box extends from the Q1 to Q3 quartile values of the data,\n        with a line at the median (Q2). The whiskers extend from the edges\n        of box to show the range of the data. The position of the whiskers\n        is set by default to 1.5*IQR (IQR = Q3 - Q1) from the edges of the\n        box. Outlier points are those past the end of the whiskers.\n\n        For further details see Wikipedia's\n        entry for `boxplot <https://en.wikipedia.org/wiki/Box_plot>`__.\n\n        A consideration when using this chart is that the box and the whiskers\n        can overlap, which is very common when plotting small sets of data.\n\n        Parameters\n        ----------\n        by : string or sequence\n            Column in the DataFrame to group by.\n        **kwds : optional\n            Additional keywords are documented in\n            :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n\n        See Also\n        --------\n        pandas.DataFrame.boxplot: Another method to draw a box plot.\n        pandas.Series.plot.box: Draw a box plot from a Series object.\n        matplotlib.pyplot.boxplot: Draw a box plot in matplotlib.\n\n        Examples\n        --------\n        Draw a box plot from a DataFrame with four columns of randomly\n        generated data.\n\n        .. plot::\n            :context: close-figs\n\n            >>> data = np.random.randn(25, 4)\n            >>> df = pd.DataFrame(data, columns=list('ABCD'))\n            >>> ax = df.plot.box()\n        \"\"\"\n        return self(kind='box', by=by, **kwds)\n\n    def hist(self, by=None, bins=10, **kwds):\n        \"\"\"\n        Draw one histogram of the DataFrame's columns.\n\n        A histogram is a representation of the distribution of data.\n        This function groups the values of all given Series in the DataFrame\n        into bins and draws all bins in one :class:`matplotlib.axes.Axes`.\n        This is useful when the DataFrame's Series are in a similar scale.\n\n        Parameters\n        ----------\n        by : str or sequence, optional\n            Column in the DataFrame to group by.\n        bins : int, default 10\n            Number of histogram bins to be used.\n        **kwds\n            Additional keyword arguments are documented in\n            :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : matplotlib.AxesSubplot histogram.\n\n        See Also\n        --------\n        DataFrame.hist : Draw histograms per DataFrame's Series.\n        Series.hist : Draw a histogram with Series' data.\n\n        Examples\n        --------\n        When we draw a dice 6000 times, we expect to get each value around 1000\n        times. But when we draw two dices and sum the result, the distribution\n        is going to be quite different. A histogram illustrates those\n        distributions.\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame(\n            ...     np.random.randint(1, 7, 6000),\n            ...     columns = ['one'])\n            >>> df['two'] = df['one'] + np.random.randint(1, 7, 6000)\n            >>> ax = df.plot.hist(bins=12, alpha=0.5)\n        \"\"\"\n        return self(kind='hist', by=by, bins=bins, **kwds)\n\n    @Appender(_kde_docstring % {\n        'this-datatype': 'DataFrame',\n        'sibling-datatype': 'Series',\n        'examples': \"\"\"\n        Given several Series of points randomly sampled from unknown\n        distributions, estimate their PDFs using KDE with automatic\n        bandwidth determination and plot the results, evaluating them at\n        1000 equally spaced points (default):\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({\n            ...     'x': [1, 2, 2.5, 3, 3.5, 4, 5],\n            ...     'y': [4, 4, 4.5, 5, 5.5, 6, 6],\n            ... })\n            >>> ax = df.plot.kde()\n\n        A scalar bandwidth can be specified. Using a small bandwidth value can\n        lead to over-fitting, while using a large bandwidth value may result\n        in under-fitting:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.kde(bw_method=0.3)\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.kde(bw_method=3)\n\n        Finally, the `ind` parameter determines the evaluation points for the\n        plot of the estimated PDF:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.kde(ind=[1, 2, 3, 4, 5, 6])\n        \"\"\".strip()\n    })\n    def kde(self, bw_method=None, ind=None, **kwds):\n        return self(kind='kde', bw_method=bw_method, ind=ind, **kwds)\n\n    density = kde\n\n    def area(self, x=None, y=None, **kwds):\n        \"\"\"\n        Draw a stacked area plot.\n\n        An area plot displays quantitative data visually.\n        This function wraps the matplotlib area function.\n\n        Parameters\n        ----------\n        x : label or position, optional\n            Coordinates for the X axis. By default uses the index.\n        y : label or position, optional\n            Column to plot. By default uses all columns.\n        stacked : bool, default True\n            Area plots are stacked by default. Set to False to create a\n            unstacked plot.\n        **kwds : optional\n            Additional keyword arguments are documented in\n            :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes or numpy.ndarray\n            Area plot, or array of area plots if subplots is True\n\n        See Also\n        --------\n        DataFrame.plot : Make plots of DataFrame using matplotlib / pylab.\n\n        Examples\n        --------\n        Draw an area plot based on basic business metrics:\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({\n            ...     'sales': [3, 2, 3, 9, 10, 6],\n            ...     'signups': [5, 5, 6, 12, 14, 13],\n            ...     'visits': [20, 42, 28, 62, 81, 50],\n            ... }, index=pd.date_range(start='2018/01/01', end='2018/07/01',\n            ...                        freq='M'))\n            >>> ax = df.plot.area()\n\n        Area plots are stacked by default. To produce an unstacked plot,\n        pass ``stacked=False``:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.area(stacked=False)\n\n        Draw an area plot for a single column:\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax = df.plot.area(y='sales')\n\n        Draw with a different `x`:\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({\n            ...     'sales': [3, 2, 3],\n            ...     'visits': [20, 42, 28],\n            ...     'day': [1, 2, 3],\n            ... })\n            >>> ax = df.plot.area(x='day')\n        \"\"\"\n        return self(kind='area', x=x, y=y, **kwds)\n\n    def pie(self, y=None, **kwds):\n        \"\"\"\n        Generate a pie plot.\n\n        A pie plot is a proportional representation of the numerical data in a\n        column. This function wraps :meth:`matplotlib.pyplot.pie` for the\n        specified column. If no column reference is passed and\n        ``subplots=True`` a pie plot is drawn for each numerical column\n        independently.\n\n        Parameters\n        ----------\n        y : int or label, optional\n            Label or position of the column to plot.\n            If not provided, ``subplots=True`` argument must be passed.\n        **kwds\n            Keyword arguments to pass on to :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : matplotlib.axes.Axes or np.ndarray of them.\n            A NumPy array is returned when `subplots` is True.\n\n        See Also\n        --------\n        Series.plot.pie : Generate a pie plot for a Series.\n        DataFrame.plot : Make plots of a DataFrame.\n\n        Examples\n        --------\n        In the example below we have a DataFrame with the information about\n        planet's mass and radius. We pass the the 'mass' column to the\n        pie function to get a pie plot.\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame({'mass': [0.330, 4.87 , 5.97],\n            ...                    'radius': [2439.7, 6051.8, 6378.1]},\n            ...                   index=['Mercury', 'Venus', 'Earth'])\n            >>> plot = df.plot.pie(y='mass', figsize=(5, 5))\n\n        .. plot::\n            :context: close-figs\n\n            >>> plot = df.plot.pie(subplots=True, figsize=(6, 3))\n        \"\"\"\n        return self(kind='pie', y=y, **kwds)\n\n    def scatter(self, x, y, s=None, c=None, **kwds):\n        \"\"\"\n        Create a scatter plot with varying marker point size and color.\n\n        The coordinates of each point are defined by two dataframe columns and\n        filled circles are used to represent each point. This kind of plot is\n        useful to see complex correlations between two variables. Points could\n        be for instance natural 2D coordinates like longitude and latitude in\n        a map or, in general, any pair of metrics that can be plotted against\n        each other.\n\n        Parameters\n        ----------\n        x : int or str\n            The column name or column position to be used as horizontal\n            coordinates for each point.\n        y : int or str\n            The column name or column position to be used as vertical\n            coordinates for each point.\n        s : scalar or array_like, optional\n            The size of each point. Possible values are:\n\n            - A single scalar so all points have the same size.\n\n            - A sequence of scalars, which will be used for each point's size\n              recursively. For instance, when passing [2,14] all points size\n              will be either 2 or 14, alternatively.\n\n        c : str, int or array_like, optional\n            The color of each point. Possible values are:\n\n            - A single color string referred to by name, RGB or RGBA code,\n              for instance 'red' or '#a98d19'.\n\n            - A sequence of color strings referred to by name, RGB or RGBA\n              code, which will be used for each point's color recursively. For\n              instance ['green','yellow'] all points will be filled in green or\n              yellow, alternatively.\n\n            - A column name or position whose values will be used to color the\n              marker points according to a colormap.\n\n        **kwds\n            Keyword arguments to pass on to :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        axes : :class:`matplotlib.axes.Axes` or numpy.ndarray of them\n\n        See Also\n        --------\n        matplotlib.pyplot.scatter : Scatter plot using multiple input data\n            formats.\n\n        Examples\n        --------\n        Let's see how to draw a scatter plot using coordinates from the values\n        in a DataFrame's columns.\n\n        .. plot::\n            :context: close-figs\n\n            >>> df = pd.DataFrame([[5.1, 3.5, 0], [4.9, 3.0, 0], [7.0, 3.2, 1],\n            ...                    [6.4, 3.2, 1], [5.9, 3.0, 2]],\n            ...                   columns=['length', 'width', 'species'])\n            >>> ax1 = df.plot.scatter(x='length',\n            ...                       y='width',\n            ...                       c='DarkBlue')\n\n        And now with the color determined by a column as well.\n\n        .. plot::\n            :context: close-figs\n\n            >>> ax2 = df.plot.scatter(x='length',\n            ...                       y='width',\n            ...                       c='species',\n            ...                       colormap='viridis')\n        \"\"\"\n        return self(kind='scatter', x=x, y=y, c=c, s=s, **kwds)\n\n    def hexbin(self, x, y, C=None, reduce_C_function=None, gridsize=None,\n               **kwds):\n        \"\"\"\n        Generate a hexagonal binning plot.\n\n        Generate a hexagonal binning plot of `x` versus `y`. If `C` is `None`\n        (the default), this is a histogram of the number of occurrences\n        of the observations at ``(x[i], y[i])``.\n\n        If `C` is specified, specifies values at given coordinates\n        ``(x[i], y[i])``. These values are accumulated for each hexagonal\n        bin and then reduced according to `reduce_C_function`,\n        having as default the NumPy's mean function (:meth:`numpy.mean`).\n        (If `C` is specified, it must also be a 1-D sequence\n        of the same length as `x` and `y`, or a column label.)\n\n        Parameters\n        ----------\n        x : int or str\n            The column label or position for x points.\n        y : int or str\n            The column label or position for y points.\n        C : int or str, optional\n            The column label or position for the value of `(x, y)` point.\n        reduce_C_function : callable, default `np.mean`\n            Function of one argument that reduces all the values in a bin to\n            a single number (e.g. `np.mean`, `np.max`, `np.sum`, `np.std`).\n        gridsize : int or tuple of (int, int), default 100\n            The number of hexagons in the x-direction.\n            The corresponding number of hexagons in the y-direction is\n            chosen in a way that the hexagons are approximately regular.\n            Alternatively, gridsize can be a tuple with two elements\n            specifying the number of hexagons in the x-direction and the\n            y-direction.\n        **kwds\n            Additional keyword arguments are documented in\n            :meth:`pandas.DataFrame.plot`.\n\n        Returns\n        -------\n        matplotlib.AxesSubplot\n            The matplotlib ``Axes`` on which the hexbin is plotted.\n\n        See Also\n        --------\n        DataFrame.plot : Make plots of a DataFrame.\n        matplotlib.pyplot.hexbin : Hexagonal binning plot using matplotlib,\n            the matplotlib function that is used under the hood.\n\n        Examples\n        --------\n        The following examples are generated with random data from\n        a normal distribution.\n\n        .. plot::\n            :context: close-figs\n\n            >>> n = 10000\n            >>> df = pd.DataFrame({'x': np.random.randn(n),\n            ...                    'y': np.random.randn(n)})\n            >>> ax = df.plot.hexbin(x='x', y='y', gridsize=20)\n\n        The next example uses `C` and `np.sum` as `reduce_C_function`.\n        Note that `'observations'` values ranges from 1 to 5 but the result\n        plot shows values up to more than 25. This is because of the\n        `reduce_C_function`.\n\n        .. plot::\n            :context: close-figs\n\n            >>> n = 500\n            >>> df = pd.DataFrame({\n            ...     'coord_x': np.random.uniform(-3, 3, size=n),\n            ...     'coord_y': np.random.uniform(30, 50, size=n),\n            ...     'observations': np.random.randint(1,5, size=n)\n            ...     })\n            >>> ax = df.plot.hexbin(x='coord_x',\n            ...                     y='coord_y',\n            ...                     C='observations',\n            ...                     reduce_C_function=np.sum,\n            ...                     gridsize=10,\n            ...                     cmap=\"viridis\")\n        \"\"\"\n        if reduce_C_function is not None:\n            kwds['reduce_C_function'] = reduce_C_function\n        if gridsize is not None:\n            kwds['gridsize'] = gridsize\n        return self(kind='hexbin', x=x, y=y, C=C, **kwds)\n"
    },
    {
      "filename": "pandas/tests/plotting/test_frame.py",
      "content": "# coding: utf-8\n\n\"\"\" Test cases for DataFrame.plot \"\"\"\n\nfrom datetime import date, datetime\nimport string\nimport warnings\n\nimport numpy as np\nfrom numpy.random import rand, randn\nimport pytest\n\nfrom pandas.compat import PY3, lmap, lrange, lzip, range, u, zip\nimport pandas.util._test_decorators as td\n\nfrom pandas.core.dtypes.api import is_list_like\n\nimport pandas as pd\nfrom pandas import (\n    DataFrame, MultiIndex, PeriodIndex, Series, bdate_range, date_range)\nfrom pandas.tests.plotting.common import (\n    TestPlotBase, _check_plot_works, _ok_for_gaussian_kde,\n    _skip_if_no_scipy_gaussian_kde)\nimport pandas.util.testing as tm\n\nfrom pandas.io.formats.printing import pprint_thing\nimport pandas.plotting as plotting\n\n\n@td.skip_if_no_mpl\nclass TestDataFramePlots(TestPlotBase):\n\n    def setup_method(self, method):\n        TestPlotBase.setup_method(self, method)\n        import matplotlib as mpl\n        mpl.rcdefaults()\n\n        self.tdf = tm.makeTimeDataFrame()\n        self.hexbin_df = DataFrame({\"A\": np.random.uniform(size=20),\n                                    \"B\": np.random.uniform(size=20),\n                                    \"C\": np.arange(20) + np.random.uniform(\n                                        size=20)})\n\n    def _assert_ytickslabels_visibility(self, axes, expected):\n        for ax, exp in zip(axes, expected):\n            self._check_visible(ax.get_yticklabels(), visible=exp)\n\n    def _assert_xtickslabels_visibility(self, axes, expected):\n        for ax, exp in zip(axes, expected):\n            self._check_visible(ax.get_xticklabels(), visible=exp)\n\n    @pytest.mark.slow\n    def test_plot(self):\n        df = self.tdf\n        _check_plot_works(df.plot, grid=False)\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot,\n                                     subplots=True)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot,\n                                     subplots=True, layout=(-1, 2))\n        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot,\n                                     subplots=True, use_index=False)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        df = DataFrame({'x': [1, 2], 'y': [3, 4]})\n        with pytest.raises(AttributeError, match='Unknown property blarg'):\n            df.plot.line(blarg=True)\n\n        df = DataFrame(np.random.rand(10, 3),\n                       index=list(string.ascii_letters[:10]))\n\n        _check_plot_works(df.plot, use_index=True)\n        _check_plot_works(df.plot, sort_columns=False)\n        _check_plot_works(df.plot, yticks=[1, 5, 10])\n        _check_plot_works(df.plot, xticks=[1, 5, 10])\n        _check_plot_works(df.plot, ylim=(-100, 100), xlim=(-100, 100))\n\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(df.plot, subplots=True, title='blah')\n\n        # We have to redo it here because _check_plot_works does two plots,\n        # once without an ax kwarg and once with an ax kwarg and the new sharex\n        # behaviour does not remove the visibility of the latter axis (as ax is\n        # present).  see: https://github.com/pandas-dev/pandas/issues/9737\n\n        axes = df.plot(subplots=True, title='blah')\n        self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n        # axes[0].figure.savefig(\"test.png\")\n        for ax in axes[:2]:\n            self._check_visible(ax.xaxis)  # xaxis must be visible for grid\n            self._check_visible(ax.get_xticklabels(), visible=False)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=False)\n            self._check_visible([ax.xaxis.get_label()], visible=False)\n        for ax in [axes[2]]:\n            self._check_visible(ax.xaxis)\n            self._check_visible(ax.get_xticklabels())\n            self._check_visible([ax.xaxis.get_label()])\n            self._check_ticks_props(ax, xrot=0)\n\n        _check_plot_works(df.plot, title='blah')\n\n        tuples = lzip(string.ascii_letters[:10], range(10))\n        df = DataFrame(np.random.rand(10, 3),\n                       index=MultiIndex.from_tuples(tuples))\n        _check_plot_works(df.plot, use_index=True)\n\n        # unicode\n        index = MultiIndex.from_tuples([(u('\\u03b1'), 0),\n                                        (u('\\u03b1'), 1),\n                                        (u('\\u03b2'), 2),\n                                        (u('\\u03b2'), 3),\n                                        (u('\\u03b3'), 4),\n                                        (u('\\u03b3'), 5),\n                                        (u('\\u03b4'), 6),\n                                        (u('\\u03b4'), 7)], names=['i0', 'i1'])\n        columns = MultiIndex.from_tuples([('bar', u('\\u0394')),\n                                          ('bar', u('\\u0395'))], names=['c0',\n                                                                        'c1'])\n        df = DataFrame(np.random.randint(0, 10, (8, 2)),\n                       columns=columns,\n                       index=index)\n        _check_plot_works(df.plot, title=u('\\u03A3'))\n\n        # GH 6951\n        # Test with single column\n        df = DataFrame({'x': np.random.rand(10)})\n        axes = _check_plot_works(df.plot.bar, subplots=True)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n        axes = _check_plot_works(df.plot.bar, subplots=True, layout=(-1, 1))\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n        # When ax is supplied and required number of axes is 1,\n        # passed ax should be used:\n        fig, ax = self.plt.subplots()\n        axes = df.plot.bar(subplots=True, ax=ax)\n        assert len(axes) == 1\n        result = ax.axes\n        assert result is axes[0]\n\n    # GH 15516\n    def test_mpl2_color_cycle_str(self):\n        colors = ['C' + str(x) for x in range(10)]\n        df = DataFrame(randn(10, 3), columns=['a', 'b', 'c'])\n        for c in colors:\n            _check_plot_works(df.plot, color=c)\n\n    def test_color_single_series_list(self):\n        # GH 3486\n        df = DataFrame({\"A\": [1, 2, 3]})\n        _check_plot_works(df.plot, color=['red'])\n\n    def test_rgb_tuple_color(self):\n        # GH 16695\n        df = DataFrame({'x': [1, 2], 'y': [3, 4]})\n        _check_plot_works(df.plot, x='x', y='y', color=(1, 0, 0))\n        _check_plot_works(df.plot, x='x', y='y', color=(1, 0, 0, 0.5))\n\n    def test_color_empty_string(self):\n        df = DataFrame(randn(10, 2))\n        with pytest.raises(ValueError):\n            df.plot(color='')\n\n    def test_color_and_style_arguments(self):\n        df = DataFrame({'x': [1, 2], 'y': [3, 4]})\n        # passing both 'color' and 'style' arguments should be allowed\n        # if there is no color symbol in the style strings:\n        ax = df.plot(color=['red', 'black'], style=['-', '--'])\n        # check that the linestyles are correctly set:\n        linestyle = [line.get_linestyle() for line in ax.lines]\n        assert linestyle == ['-', '--']\n        # check that the colors are correctly set:\n        color = [line.get_color() for line in ax.lines]\n        assert color == ['red', 'black']\n        # passing both 'color' and 'style' arguments should not be allowed\n        # if there is a color symbol in the style strings:\n        with pytest.raises(ValueError):\n            df.plot(color=['red', 'black'], style=['k-', 'r--'])\n\n    def test_nonnumeric_exclude(self):\n        df = DataFrame({'A': [\"x\", \"y\", \"z\"], 'B': [1, 2, 3]})\n        ax = df.plot()\n        assert len(ax.get_lines()) == 1  # B was plotted\n\n    @pytest.mark.slow\n    def test_implicit_label(self):\n        df = DataFrame(randn(10, 3), columns=['a', 'b', 'c'])\n        ax = df.plot(x='a', y='b')\n        self._check_text_labels(ax.xaxis.get_label(), 'a')\n\n    @pytest.mark.slow\n    def test_donot_overwrite_index_name(self):\n        # GH 8494\n        df = DataFrame(randn(2, 2), columns=['a', 'b'])\n        df.index.name = 'NAME'\n        df.plot(y='b', label='LABEL')\n        assert df.index.name == 'NAME'\n\n    @pytest.mark.slow\n    def test_plot_xy(self):\n        # columns.inferred_type == 'string'\n        df = self.tdf\n        self._check_data(df.plot(x=0, y=1), df.set_index('A')['B'].plot())\n        self._check_data(df.plot(x=0), df.set_index('A').plot())\n        self._check_data(df.plot(y=0), df.B.plot())\n        self._check_data(df.plot(x='A', y='B'), df.set_index('A').B.plot())\n        self._check_data(df.plot(x='A'), df.set_index('A').plot())\n        self._check_data(df.plot(y='B'), df.B.plot())\n\n        # columns.inferred_type == 'integer'\n        df.columns = lrange(1, len(df.columns) + 1)\n        self._check_data(df.plot(x=1, y=2), df.set_index(1)[2].plot())\n        self._check_data(df.plot(x=1), df.set_index(1).plot())\n        self._check_data(df.plot(y=1), df[1].plot())\n\n        # figsize and title\n        ax = df.plot(x=1, y=2, title='Test', figsize=(16, 8))\n        self._check_text_labels(ax.title, 'Test')\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1),\n                               figsize=(16., 8.))\n\n        # columns.inferred_type == 'mixed'\n        # TODO add MultiIndex test\n\n    @pytest.mark.slow\n    def test_logscales(self):\n        df = DataFrame({'a': np.arange(100)}, index=np.arange(100))\n        ax = df.plot(logy=True)\n        self._check_ax_scales(ax, yaxis='log')\n\n        ax = df.plot(logx=True)\n        self._check_ax_scales(ax, xaxis='log')\n\n        ax = df.plot(loglog=True)\n        self._check_ax_scales(ax, xaxis='log', yaxis='log')\n\n    @pytest.mark.slow\n    def test_xcompat(self):\n        import pandas as pd\n\n        df = self.tdf\n        ax = df.plot(x_compat=True)\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n\n        tm.close()\n        pd.plotting.plot_params['xaxis.compat'] = True\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n\n        tm.close()\n        pd.plotting.plot_params['x_compat'] = False\n\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)\n\n        tm.close()\n        # useful if you're plotting a bunch together\n        with pd.plotting.plot_params.use('x_compat', True):\n            ax = df.plot()\n            lines = ax.get_lines()\n            assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n\n        tm.close()\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)\n\n    def test_period_compat(self):\n        # GH 9012\n        # period-array conversions\n        df = DataFrame(\n            np.random.rand(21, 2),\n            index=bdate_range(datetime(2000, 1, 1), datetime(2000, 1, 31)),\n            columns=['a', 'b'])\n\n        df.plot()\n        self.plt.axhline(y=0)\n        tm.close()\n\n    def test_unsorted_index(self):\n        df = DataFrame({'y': np.arange(100)}, index=np.arange(99, -1, -1),\n                       dtype=np.int64)\n        ax = df.plot()\n        lines = ax.get_lines()[0]\n        rs = lines.get_xydata()\n        rs = Series(rs[:, 1], rs[:, 0], dtype=np.int64, name='y')\n        tm.assert_series_equal(rs, df.y, check_index_type=False)\n        tm.close()\n\n        df.index = pd.Index(np.arange(99, -1, -1), dtype=np.float64)\n        ax = df.plot()\n        lines = ax.get_lines()[0]\n        rs = lines.get_xydata()\n        rs = Series(rs[:, 1], rs[:, 0], dtype=np.int64, name='y')\n        tm.assert_series_equal(rs, df.y)\n\n    def test_unsorted_index_lims(self):\n        df = DataFrame({'y': [0., 1., 2., 3.]}, index=[1., 0., 3., 2.])\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n        df = DataFrame({'y': [0., 1., np.nan, 3., 4., 5., 6.]},\n                       index=[1., 0., 3., 2., np.nan, 3., 2.])\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n        df = DataFrame({'y': [0., 1., 2., 3.], 'z': [91., 90., 93., 92.]})\n        ax = df.plot(x='z', y='y')\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n    @pytest.mark.slow\n    def test_subplots(self):\n        df = DataFrame(np.random.rand(10, 3),\n                       index=list(string.ascii_letters[:10]))\n\n        for kind in ['bar', 'barh', 'line', 'area']:\n            axes = df.plot(kind=kind, subplots=True, sharex=True, legend=True)\n            self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n            assert axes.shape == (3, )\n\n            for ax, column in zip(axes, df.columns):\n                self._check_legend_labels(ax,\n                                          labels=[pprint_thing(column)])\n\n            for ax in axes[:-2]:\n                self._check_visible(ax.xaxis)  # xaxis must be visible for grid\n                self._check_visible(ax.get_xticklabels(), visible=False)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=False)\n                self._check_visible(ax.xaxis.get_label(), visible=False)\n                self._check_visible(ax.get_yticklabels())\n\n            self._check_visible(axes[-1].xaxis)\n            self._check_visible(axes[-1].get_xticklabels())\n            self._check_visible(axes[-1].get_xticklabels(minor=True))\n            self._check_visible(axes[-1].xaxis.get_label())\n            self._check_visible(axes[-1].get_yticklabels())\n\n            axes = df.plot(kind=kind, subplots=True, sharex=False)\n            for ax in axes:\n                self._check_visible(ax.xaxis)\n                self._check_visible(ax.get_xticklabels())\n                self._check_visible(ax.get_xticklabels(minor=True))\n                self._check_visible(ax.xaxis.get_label())\n                self._check_visible(ax.get_yticklabels())\n\n            axes = df.plot(kind=kind, subplots=True, legend=False)\n            for ax in axes:\n                assert ax.get_legend() is None\n\n    def test_groupby_boxplot_sharey(self):\n        # https://github.com/pandas-dev/pandas/issues/20968\n        # sharey can now be switched check whether the right\n        # pair of axes is turned on or off\n\n        df = DataFrame({'a': [-1.43, -0.15, -3.70, -1.43, -0.14],\n                        'b': [0.56, 0.84, 0.29, 0.56, 0.85],\n                        'c': [0, 1, 2, 3, 1]},\n                       index=[0, 1, 2, 3, 4])\n\n        # behavior without keyword\n        axes = df.groupby('c').boxplot()\n        expected = [True, False, True, False]\n        self._assert_ytickslabels_visibility(axes, expected)\n\n        # set sharey=True should be identical\n        axes = df.groupby('c').boxplot(sharey=True)\n        expected = [True, False, True, False]\n        self._assert_ytickslabels_visibility(axes, expected)\n\n        # sharey=False, all yticklabels should be visible\n        axes = df.groupby('c').boxplot(sharey=False)\n        expected = [True, True, True, True]\n        self._assert_ytickslabels_visibility(axes, expected)\n\n    def test_groupby_boxplot_sharex(self):\n        # https://github.com/pandas-dev/pandas/issues/20968\n        # sharex can now be switched check whether the right\n        # pair of axes is turned on or off\n\n        df = DataFrame({'a': [-1.43, -0.15, -3.70, -1.43, -0.14],\n                        'b': [0.56, 0.84, 0.29, 0.56, 0.85],\n                        'c': [0, 1, 2, 3, 1]},\n                       index=[0, 1, 2, 3, 4])\n\n        # behavior without keyword\n        axes = df.groupby('c').boxplot()\n        expected = [True, True, True, True]\n        self._assert_xtickslabels_visibility(axes, expected)\n\n        # set sharex=False should be identical\n        axes = df.groupby('c').boxplot(sharex=False)\n        expected = [True, True, True, True]\n        self._assert_xtickslabels_visibility(axes, expected)\n\n        # sharex=True, yticklabels should be visible\n        # only for bottom plots\n        axes = df.groupby('c').boxplot(sharex=True)\n        expected = [False, False, True, True]\n        self._assert_xtickslabels_visibility(axes, expected)\n\n    @pytest.mark.slow\n    def test_subplots_timeseries(self):\n        idx = date_range(start='2014-07-01', freq='M', periods=10)\n        df = DataFrame(np.random.rand(10, 3), index=idx)\n\n        for kind in ['line', 'area']:\n            axes = df.plot(kind=kind, subplots=True, sharex=True)\n            self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n\n            for ax in axes[:-2]:\n                # GH 7801\n                self._check_visible(ax.xaxis)  # xaxis must be visible for grid\n                self._check_visible(ax.get_xticklabels(), visible=False)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=False)\n                self._check_visible(ax.xaxis.get_label(), visible=False)\n                self._check_visible(ax.get_yticklabels())\n\n            self._check_visible(axes[-1].xaxis)\n            self._check_visible(axes[-1].get_xticklabels())\n            self._check_visible(axes[-1].get_xticklabels(minor=True))\n            self._check_visible(axes[-1].xaxis.get_label())\n            self._check_visible(axes[-1].get_yticklabels())\n            self._check_ticks_props(axes, xrot=0)\n\n            axes = df.plot(kind=kind, subplots=True, sharex=False, rot=45,\n                           fontsize=7)\n            for ax in axes:\n                self._check_visible(ax.xaxis)\n                self._check_visible(ax.get_xticklabels())\n                self._check_visible(ax.get_xticklabels(minor=True))\n                self._check_visible(ax.xaxis.get_label())\n                self._check_visible(ax.get_yticklabels())\n                self._check_ticks_props(ax, xlabelsize=7, xrot=45,\n                                        ylabelsize=7)\n\n    def test_subplots_timeseries_y_axis(self):\n        # GH16953\n        data = {\"numeric\": np.array([1, 2, 5]),\n                \"timedelta\": [pd.Timedelta(-10, unit=\"s\"),\n                              pd.Timedelta(10, unit=\"m\"),\n                              pd.Timedelta(10, unit=\"h\")],\n                \"datetime_no_tz\": [pd.to_datetime(\"2017-08-01 00:00:00\"),\n                                   pd.to_datetime(\"2017-08-01 02:00:00\"),\n                                   pd.to_datetime(\"2017-08-02 00:00:00\")],\n                \"datetime_all_tz\": [pd.to_datetime(\"2017-08-01 00:00:00\",\n                                                   utc=True),\n                                    pd.to_datetime(\"2017-08-01 02:00:00\",\n                                                   utc=True),\n                                    pd.to_datetime(\"2017-08-02 00:00:00\",\n                                                   utc=True)],\n                \"text\": [\"This\", \"should\", \"fail\"]}\n        testdata = DataFrame(data)\n\n        ax_numeric = testdata.plot(y=\"numeric\")\n        assert (ax_numeric.get_lines()[0].get_data()[1] ==\n                testdata[\"numeric\"].values).all()\n        ax_timedelta = testdata.plot(y=\"timedelta\")\n        assert (ax_timedelta.get_lines()[0].get_data()[1] ==\n                testdata[\"timedelta\"].values).all()\n        ax_datetime_no_tz = testdata.plot(y=\"datetime_no_tz\")\n        assert (ax_datetime_no_tz.get_lines()[0].get_data()[1] ==\n                testdata[\"datetime_no_tz\"].values).all()\n        ax_datetime_all_tz = testdata.plot(y=\"datetime_all_tz\")\n        assert (ax_datetime_all_tz.get_lines()[0].get_data()[1] ==\n                testdata[\"datetime_all_tz\"].values).all()\n        with pytest.raises(TypeError):\n            testdata.plot(y=\"text\")\n\n    @pytest.mark.xfail(reason='not support for period, categorical, '\n                              'datetime_mixed_tz')\n    def test_subplots_timeseries_y_axis_not_supported(self):\n        \"\"\"\n        This test will fail for:\n            period:\n                since period isn't yet implemented in ``select_dtypes``\n                and because it will need a custom value converter +\n                tick formater (as was done for x-axis plots)\n\n            categorical:\n                 because it will need a custom value converter +\n                 tick formater (also doesn't work for x-axis, as of now)\n\n            datetime_mixed_tz:\n                because of the way how pandas handels ``Series`` of\n                ``datetime`` objects with different timezone,\n                generally converting ``datetime`` objects in a tz-aware\n                form could help with this problem\n        \"\"\"\n        data = {\"numeric\": np.array([1, 2, 5]),\n                \"period\": [pd.Period('2017-08-01 00:00:00', freq='H'),\n                           pd.Period('2017-08-01 02:00', freq='H'),\n                           pd.Period('2017-08-02 00:00:00', freq='H')],\n                \"categorical\": pd.Categorical([\"c\", \"b\", \"a\"],\n                                              categories=[\"a\", \"b\", \"c\"],\n                                              ordered=False),\n                \"datetime_mixed_tz\": [pd.to_datetime(\"2017-08-01 00:00:00\",\n                                                     utc=True),\n                                      pd.to_datetime(\"2017-08-01 02:00:00\"),\n                                      pd.to_datetime(\"2017-08-02 00:00:00\")]}\n        testdata = pd.DataFrame(data)\n        ax_period = testdata.plot(x=\"numeric\", y=\"period\")\n        assert (ax_period.get_lines()[0].get_data()[1] ==\n                testdata[\"period\"].values).all()\n        ax_categorical = testdata.plot(x=\"numeric\", y=\"categorical\")\n        assert (ax_categorical.get_lines()[0].get_data()[1] ==\n                testdata[\"categorical\"].values).all()\n        ax_datetime_mixed_tz = testdata.plot(x=\"numeric\",\n                                             y=\"datetime_mixed_tz\")\n        assert (ax_datetime_mixed_tz.get_lines()[0].get_data()[1] ==\n                testdata[\"datetime_mixed_tz\"].values).all()\n\n    @pytest.mark.slow\n    def test_subplots_layout(self):\n        # GH 6667\n        df = DataFrame(np.random.rand(10, 3),\n                       index=list(string.ascii_letters[:10]))\n\n        axes = df.plot(subplots=True, layout=(2, 2))\n        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))\n        assert axes.shape == (2, 2)\n\n        axes = df.plot(subplots=True, layout=(-1, 2))\n        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))\n        assert axes.shape == (2, 2)\n\n        axes = df.plot(subplots=True, layout=(2, -1))\n        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))\n        assert axes.shape == (2, 2)\n\n        axes = df.plot(subplots=True, layout=(1, 4))\n        self._check_axes_shape(axes, axes_num=3, layout=(1, 4))\n        assert axes.shape == (1, 4)\n\n        axes = df.plot(subplots=True, layout=(-1, 4))\n        self._check_axes_shape(axes, axes_num=3, layout=(1, 4))\n        assert axes.shape == (1, 4)\n\n        axes = df.plot(subplots=True, layout=(4, -1))\n        self._check_axes_shape(axes, axes_num=3, layout=(4, 1))\n        assert axes.shape == (4, 1)\n\n        with pytest.raises(ValueError):\n            df.plot(subplots=True, layout=(1, 1))\n        with pytest.raises(ValueError):\n            df.plot(subplots=True, layout=(-1, -1))\n\n        # single column\n        df = DataFrame(np.random.rand(10, 1),\n                       index=list(string.ascii_letters[:10]))\n        axes = df.plot(subplots=True)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n        assert axes.shape == (1, )\n\n        axes = df.plot(subplots=True, layout=(3, 3))\n        self._check_axes_shape(axes, axes_num=1, layout=(3, 3))\n        assert axes.shape == (3, 3)\n\n    @pytest.mark.slow\n    def test_subplots_warnings(self):\n        # GH 9464\n        with tm.assert_produces_warning(None):\n            df = DataFrame(np.random.randn(100, 4))\n            df.plot(subplots=True, layout=(3, 2))\n\n            df = DataFrame(np.random.randn(100, 4),\n                           index=date_range('1/1/2000', periods=100))\n            df.plot(subplots=True, layout=(3, 2))\n\n    @pytest.mark.slow\n    def test_subplots_multiple_axes(self):\n        # GH 5353, 6970, GH 7069\n        fig, axes = self.plt.subplots(2, 3)\n        df = DataFrame(np.random.rand(10, 3),\n                       index=list(string.ascii_letters[:10]))\n\n        returned = df.plot(subplots=True, ax=axes[0], sharex=False,\n                           sharey=False)\n        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))\n        assert returned.shape == (3, )\n        assert returned[0].figure is fig\n        # draw on second row\n        returned = df.plot(subplots=True, ax=axes[1], sharex=False,\n                           sharey=False)\n        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))\n        assert returned.shape == (3, )\n        assert returned[0].figure is fig\n        self._check_axes_shape(axes, axes_num=6, layout=(2, 3))\n        tm.close()\n\n        with pytest.raises(ValueError):\n            fig, axes = self.plt.subplots(2, 3)\n            # pass different number of axes from required\n            df.plot(subplots=True, ax=axes)\n\n        # pass 2-dim axes and invalid layout\n        # invalid lauout should not affect to input and return value\n        # (show warning is tested in\n        # TestDataFrameGroupByPlots.test_grouped_box_multiple_axes\n        fig, axes = self.plt.subplots(2, 2)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", UserWarning)\n            df = DataFrame(np.random.rand(10, 4),\n                           index=list(string.ascii_letters[:10]))\n\n            returned = df.plot(subplots=True, ax=axes, layout=(2, 1),\n                               sharex=False, sharey=False)\n            self._check_axes_shape(returned, axes_num=4, layout=(2, 2))\n            assert returned.shape == (4, )\n\n            returned = df.plot(subplots=True, ax=axes, layout=(2, -1),\n                               sharex=False, sharey=False)\n            self._check_axes_shape(returned, axes_num=4, layout=(2, 2))\n            assert returned.shape == (4, )\n\n            returned = df.plot(subplots=True, ax=axes, layout=(-1, 2),\n                               sharex=False, sharey=False)\n        self._check_axes_shape(returned, axes_num=4, layout=(2, 2))\n        assert returned.shape == (4, )\n\n        # single column\n        fig, axes = self.plt.subplots(1, 1)\n        df = DataFrame(np.random.rand(10, 1),\n                       index=list(string.ascii_letters[:10]))\n\n        axes = df.plot(subplots=True, ax=[axes], sharex=False, sharey=False)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n        assert axes.shape == (1, )\n\n    def test_subplots_ts_share_axes(self):\n        # GH 3964\n        fig, axes = self.plt.subplots(3, 3, sharex=True, sharey=True)\n        self.plt.subplots_adjust(left=0.05, right=0.95, hspace=0.3, wspace=0.3)\n        df = DataFrame(\n            np.random.randn(10, 9),\n            index=date_range(start='2014-07-01', freq='M', periods=10))\n        for i, ax in enumerate(axes.ravel()):\n            df[i].plot(ax=ax, fontsize=5)\n\n        # Rows other than bottom should not be visible\n        for ax in axes[0:-1].ravel():\n            self._check_visible(ax.get_xticklabels(), visible=False)\n\n        # Bottom row should be visible\n        for ax in axes[-1].ravel():\n            self._check_visible(ax.get_xticklabels(), visible=True)\n\n        # First column should be visible\n        for ax in axes[[0, 1, 2], [0]].ravel():\n            self._check_visible(ax.get_yticklabels(), visible=True)\n\n        # Other columns should not be visible\n        for ax in axes[[0, 1, 2], [1]].ravel():\n            self._check_visible(ax.get_yticklabels(), visible=False)\n        for ax in axes[[0, 1, 2], [2]].ravel():\n            self._check_visible(ax.get_yticklabels(), visible=False)\n\n    def test_subplots_sharex_axes_existing_axes(self):\n        # GH 9158\n        d = {'A': [1., 2., 3., 4.], 'B': [4., 3., 2., 1.], 'C': [5, 1, 3, 4]}\n        df = DataFrame(d, index=date_range('2014 10 11', '2014 10 14'))\n\n        axes = df[['A', 'B']].plot(subplots=True)\n        df['C'].plot(ax=axes[0], secondary_y=True)\n\n        self._check_visible(axes[0].get_xticklabels(), visible=False)\n        self._check_visible(axes[1].get_xticklabels(), visible=True)\n        for ax in axes.ravel():\n            self._check_visible(ax.get_yticklabels(), visible=True)\n\n    @pytest.mark.slow\n    def test_subplots_dup_columns(self):\n        # GH 10962\n        df = DataFrame(np.random.rand(5, 5), columns=list('aaaaa'))\n        axes = df.plot(subplots=True)\n        for ax in axes:\n            self._check_legend_labels(ax, labels=['a'])\n            assert len(ax.lines) == 1\n        tm.close()\n\n        axes = df.plot(subplots=True, secondary_y='a')\n        for ax in axes:\n            # (right) is only attached when subplots=False\n            self._check_legend_labels(ax, labels=['a'])\n            assert len(ax.lines) == 1\n        tm.close()\n\n        ax = df.plot(secondary_y='a')\n        self._check_legend_labels(ax, labels=['a (right)'] * 5)\n        assert len(ax.lines) == 0\n        assert len(ax.right_ax.lines) == 5\n\n    def test_negative_log(self):\n        df = - DataFrame(rand(6, 4),\n                         index=list(string.ascii_letters[:6]),\n                         columns=['x', 'y', 'z', 'four'])\n\n        with pytest.raises(ValueError):\n            df.plot.area(logy=True)\n        with pytest.raises(ValueError):\n            df.plot.area(loglog=True)\n\n    def _compare_stacked_y_cood(self, normal_lines, stacked_lines):\n        base = np.zeros(len(normal_lines[0].get_data()[1]))\n        for nl, sl in zip(normal_lines, stacked_lines):\n            base += nl.get_data()[1]  # get y coordinates\n            sy = sl.get_data()[1]\n            tm.assert_numpy_array_equal(base, sy)\n\n    def test_line_area_stacked(self):\n        with tm.RNGContext(42):\n            df = DataFrame(rand(6, 4), columns=['w', 'x', 'y', 'z'])\n            neg_df = -df\n            # each column has either positive or negative value\n            sep_df = DataFrame({'w': rand(6),\n                                'x': rand(6),\n                                'y': -rand(6),\n                                'z': -rand(6)})\n            # each column has positive-negative mixed value\n            mixed_df = DataFrame(randn(6, 4),\n                                 index=list(string.ascii_letters[:6]),\n                                 columns=['w', 'x', 'y', 'z'])\n\n            for kind in ['line', 'area']:\n                ax1 = _check_plot_works(df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines, ax2.lines)\n\n                ax1 = _check_plot_works(neg_df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(neg_df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines, ax2.lines)\n\n                ax1 = _check_plot_works(sep_df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(sep_df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines[:2], ax2.lines[:2])\n                self._compare_stacked_y_cood(ax1.lines[2:], ax2.lines[2:])\n\n                _check_plot_works(mixed_df.plot, stacked=False)\n                with pytest.raises(ValueError):\n                    mixed_df.plot(stacked=True)\n\n                _check_plot_works(df.plot, kind=kind, logx=True, stacked=True)\n\n    def test_line_area_nan_df(self):\n        values1 = [1, 2, np.nan, 3]\n        values2 = [3, np.nan, 2, 1]\n        df = DataFrame({'a': values1, 'b': values2})\n        tdf = DataFrame({'a': values1,\n                         'b': values2}, index=tm.makeDateIndex(k=4))\n\n        for d in [df, tdf]:\n            ax = _check_plot_works(d.plot)\n            masked1 = ax.lines[0].get_ydata()\n            masked2 = ax.lines[1].get_ydata()\n            # remove nan for comparison purpose\n\n            exp = np.array([1, 2, 3], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked1.data, 2), exp)\n\n            exp = np.array([3, 2, 1], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked2.data, 1), exp)\n            tm.assert_numpy_array_equal(\n                masked1.mask, np.array([False, False, True, False]))\n            tm.assert_numpy_array_equal(\n                masked2.mask, np.array([False, True, False, False]))\n\n            expected1 = np.array([1, 2, 0, 3], dtype=np.float64)\n            expected2 = np.array([3, 0, 2, 1], dtype=np.float64)\n\n            ax = _check_plot_works(d.plot, stacked=True)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(),\n                                        expected1 + expected2)\n\n            ax = _check_plot_works(d.plot.area)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(),\n                                        expected1 + expected2)\n\n            ax = _check_plot_works(d.plot.area, stacked=False)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected2)\n\n    def test_line_lim(self):\n        df = DataFrame(rand(6, 3), columns=['x', 'y', 'z'])\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data()[0][0]\n        assert xmax >= lines[0].get_data()[0][-1]\n\n        ax = df.plot(secondary_y=True)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data()[0][0]\n        assert xmax >= lines[0].get_data()[0][-1]\n\n        axes = df.plot(secondary_y=True, subplots=True)\n        self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n        for ax in axes:\n            assert hasattr(ax, 'left_ax')\n            assert not hasattr(ax, 'right_ax')\n            xmin, xmax = ax.get_xlim()\n            lines = ax.get_lines()\n            assert xmin <= lines[0].get_data()[0][0]\n            assert xmax >= lines[0].get_data()[0][-1]\n\n    def test_area_lim(self):\n        df = DataFrame(rand(6, 4), columns=['x', 'y', 'z', 'four'])\n\n        neg_df = -df\n        for stacked in [True, False]:\n            ax = _check_plot_works(df.plot.area, stacked=stacked)\n            xmin, xmax = ax.get_xlim()\n            ymin, ymax = ax.get_ylim()\n            lines = ax.get_lines()\n            assert xmin <= lines[0].get_data()[0][0]\n            assert xmax >= lines[0].get_data()[0][-1]\n            assert ymin == 0\n\n            ax = _check_plot_works(neg_df.plot.area, stacked=stacked)\n            ymin, ymax = ax.get_ylim()\n            assert ymax == 0\n\n    @pytest.mark.slow\n    def test_bar_colors(self):\n        import matplotlib.pyplot as plt\n        default_colors = self._unpack_cycler(plt.rcParams)\n\n        df = DataFrame(randn(5, 5))\n        ax = df.plot.bar()\n        self._check_colors(ax.patches[::5], facecolors=default_colors[:5])\n        tm.close()\n\n        custom_colors = 'rgcby'\n        ax = df.plot.bar(color=custom_colors)\n        self._check_colors(ax.patches[::5], facecolors=custom_colors)\n        tm.close()\n\n        from matplotlib import cm\n        # Test str -> colormap functionality\n        ax = df.plot.bar(colormap='jet')\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, 5))\n        self._check_colors(ax.patches[::5], facecolors=rgba_colors)\n        tm.close()\n\n        # Test colormap functionality\n        ax = df.plot.bar(colormap=cm.jet)\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, 5))\n        self._check_colors(ax.patches[::5], facecolors=rgba_colors)\n        tm.close()\n\n        ax = df.loc[:, [0]].plot.bar(color='DodgerBlue')\n        self._check_colors([ax.patches[0]], facecolors=['DodgerBlue'])\n        tm.close()\n\n        ax = df.plot(kind='bar', color='green')\n        self._check_colors(ax.patches[::5], facecolors=['green'] * 5)\n        tm.close()\n\n    def test_bar_user_colors(self):\n        df = pd.DataFrame({\"A\": range(4),\n                           \"B\": range(1, 5),\n                           \"color\": ['red', 'blue', 'blue', 'red']})\n        # This should *only* work when `y` is specified, else\n        # we use one color per column\n        ax = df.plot.bar(y='A', color=df['color'])\n        result = [p.get_facecolor() for p in ax.patches]\n        expected = [(1., 0., 0., 1.),\n                    (0., 0., 1., 1.),\n                    (0., 0., 1., 1.),\n                    (1., 0., 0., 1.)]\n        assert result == expected\n\n    @pytest.mark.slow\n    def test_bar_linewidth(self):\n        df = DataFrame(randn(5, 5))\n\n        # regular\n        ax = df.plot.bar(linewidth=2)\n        for r in ax.patches:\n            assert r.get_linewidth() == 2\n\n        # stacked\n        ax = df.plot.bar(stacked=True, linewidth=2)\n        for r in ax.patches:\n            assert r.get_linewidth() == 2\n\n        # subplots\n        axes = df.plot.bar(linewidth=2, subplots=True)\n        self._check_axes_shape(axes, axes_num=5, layout=(5, 1))\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_linewidth() == 2\n\n    @pytest.mark.slow\n    def test_bar_barwidth(self):\n        df = DataFrame(randn(5, 5))\n\n        width = 0.9\n\n        # regular\n        ax = df.plot.bar(width=width)\n        for r in ax.patches:\n            assert r.get_width() == width / len(df.columns)\n\n        # stacked\n        ax = df.plot.bar(stacked=True, width=width)\n        for r in ax.patches:\n            assert r.get_width() == width\n\n        # horizontal regular\n        ax = df.plot.barh(width=width)\n        for r in ax.patches:\n            assert r.get_height() == width / len(df.columns)\n\n        # horizontal stacked\n        ax = df.plot.barh(stacked=True, width=width)\n        for r in ax.patches:\n            assert r.get_height() == width\n\n        # subplots\n        axes = df.plot.bar(width=width, subplots=True)\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_width() == width\n\n        # horizontal subplots\n        axes = df.plot.barh(width=width, subplots=True)\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_height() == width\n\n    @pytest.mark.slow\n    def test_bar_barwidth_position(self):\n        df = DataFrame(randn(5, 5))\n        self._check_bar_alignment(df, kind='bar', stacked=False, width=0.9,\n                                  position=0.2)\n        self._check_bar_alignment(df, kind='bar', stacked=True, width=0.9,\n                                  position=0.2)\n        self._check_bar_alignment(df, kind='barh', stacked=False, width=0.9,\n                                  position=0.2)\n        self._check_bar_alignment(df, kind='barh', stacked=True, width=0.9,\n                                  position=0.2)\n        self._check_bar_alignment(df, kind='bar', subplots=True, width=0.9,\n                                  position=0.2)\n        self._check_bar_alignment(df, kind='barh', subplots=True, width=0.9,\n                                  position=0.2)\n\n    @pytest.mark.slow\n    def test_bar_barwidth_position_int(self):\n        # GH 12979\n        df = DataFrame(randn(5, 5))\n\n        for w in [1, 1.]:\n            ax = df.plot.bar(stacked=True, width=w)\n            ticks = ax.xaxis.get_ticklocs()\n            tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4]))\n            assert ax.get_xlim() == (-0.75, 4.75)\n            # check left-edge of bars\n            assert ax.patches[0].get_x() == -0.5\n            assert ax.patches[-1].get_x() == 3.5\n\n        self._check_bar_alignment(df, kind='bar', stacked=True, width=1)\n        self._check_bar_alignment(df, kind='barh', stacked=False, width=1)\n        self._check_bar_alignment(df, kind='barh', stacked=True, width=1)\n        self._check_bar_alignment(df, kind='bar', subplots=True, width=1)\n        self._check_bar_alignment(df, kind='barh', subplots=True, width=1)\n\n    @pytest.mark.slow\n    def test_bar_bottom_left(self):\n        df = DataFrame(rand(5, 5))\n        ax = df.plot.bar(stacked=False, bottom=1)\n        result = [p.get_y() for p in ax.patches]\n        assert result == [1] * 25\n\n        ax = df.plot.bar(stacked=True, bottom=[-1, -2, -3, -4, -5])\n        result = [p.get_y() for p in ax.patches[:5]]\n        assert result == [-1, -2, -3, -4, -5]\n\n        ax = df.plot.barh(stacked=False, left=np.array([1, 1, 1, 1, 1]))\n        result = [p.get_x() for p in ax.patches]\n        assert result == [1] * 25\n\n        ax = df.plot.barh(stacked=True, left=[1, 2, 3, 4, 5])\n        result = [p.get_x() for p in ax.patches[:5]]\n        assert result == [1, 2, 3, 4, 5]\n\n        axes = df.plot.bar(subplots=True, bottom=-1)\n        for ax in axes:\n            result = [p.get_y() for p in ax.patches]\n            assert result == [-1] * 5\n\n        axes = df.plot.barh(subplots=True, left=np.array([1, 1, 1, 1, 1]))\n        for ax in axes:\n            result = [p.get_x() for p in ax.patches]\n            assert result == [1] * 5\n\n    @pytest.mark.slow\n    def test_bar_nan(self):\n        df = DataFrame({'A': [10, np.nan, 20],\n                        'B': [5, 10, 20],\n                        'C': [1, 2, 3]})\n        ax = df.plot.bar()\n        expected = [10, 0, 20, 5, 10, 20, 1, 2, 3]\n        result = [p.get_height() for p in ax.patches]\n        assert result == expected\n\n        ax = df.plot.bar(stacked=True)\n        result = [p.get_height() for p in ax.patches]\n        assert result == expected\n\n        result = [p.get_y() for p in ax.patches]\n        expected = [0.0, 0.0, 0.0, 10.0, 0.0, 20.0, 15.0, 10.0, 40.0]\n        assert result == expected\n\n    @pytest.mark.slow\n    def test_bar_categorical(self):\n        # GH 13019\n        df1 = pd.DataFrame(np.random.randn(6, 5),\n                           index=pd.Index(list('ABCDEF')),\n                           columns=pd.Index(list('abcde')))\n        # categorical index must behave the same\n        df2 = pd.DataFrame(np.random.randn(6, 5),\n                           index=pd.CategoricalIndex(list('ABCDEF')),\n                           columns=pd.CategoricalIndex(list('abcde')))\n\n        for df in [df1, df2]:\n            ax = df.plot.bar()\n            ticks = ax.xaxis.get_ticklocs()\n            tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))\n            assert ax.get_xlim() == (-0.5, 5.5)\n            # check left-edge of bars\n            assert ax.patches[0].get_x() == -0.25\n            assert ax.patches[-1].get_x() == 5.15\n\n            ax = df.plot.bar(stacked=True)\n            tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))\n            assert ax.get_xlim() == (-0.5, 5.5)\n            assert ax.patches[0].get_x() == -0.25\n            assert ax.patches[-1].get_x() == 4.75\n\n    @pytest.mark.slow\n    def test_plot_scatter(self):\n        df = DataFrame(randn(6, 4),\n                       index=list(string.ascii_letters[:6]),\n                       columns=['x', 'y', 'z', 'four'])\n\n        _check_plot_works(df.plot.scatter, x='x', y='y')\n        _check_plot_works(df.plot.scatter, x=1, y=2)\n\n        with pytest.raises(TypeError):\n            df.plot.scatter(x='x')\n        with pytest.raises(TypeError):\n            df.plot.scatter(y='y')\n\n        # GH 6951\n        axes = df.plot(x='x', y='y', kind='scatter', subplots=True)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n    @pytest.mark.slow\n    def test_if_scatterplot_colorbar_affects_xaxis_visibility(self):\n        # addressing issue #10611, to ensure colobar does not\n        # interfere with x-axis label and ticklabels with\n        # ipython inline backend.\n        random_array = np.random.random((1000, 3))\n        df = pd.DataFrame(random_array,\n                          columns=['A label', 'B label', 'C label'])\n\n        ax1 = df.plot.scatter(x='A label', y='B label')\n        ax2 = df.plot.scatter(x='A label', y='B label', c='C label')\n\n        vis1 = [vis.get_visible() for vis in\n                ax1.xaxis.get_minorticklabels()]\n        vis2 = [vis.get_visible() for vis in\n                ax2.xaxis.get_minorticklabels()]\n        assert vis1 == vis2\n\n        vis1 = [vis.get_visible() for vis in\n                ax1.xaxis.get_majorticklabels()]\n        vis2 = [vis.get_visible() for vis in\n                ax2.xaxis.get_majorticklabels()]\n        assert vis1 == vis2\n\n        assert (ax1.xaxis.get_label().get_visible() ==\n                ax2.xaxis.get_label().get_visible())\n\n    @pytest.mark.slow\n    def test_if_hexbin_xaxis_label_is_visible(self):\n        # addressing issue #10678, to ensure colobar does not\n        # interfere with x-axis label and ticklabels with\n        # ipython inline backend.\n        random_array = np.random.random((1000, 3))\n        df = pd.DataFrame(random_array,\n                          columns=['A label', 'B label', 'C label'])\n\n        ax = df.plot.hexbin('A label', 'B label', gridsize=12)\n        assert all(vis.get_visible() for vis in\n                   ax.xaxis.get_minorticklabels())\n        assert all(vis.get_visible() for vis in\n                   ax.xaxis.get_majorticklabels())\n        assert ax.xaxis.get_label().get_visible()\n\n    @pytest.mark.slow\n    def test_if_scatterplot_colorbars_are_next_to_parent_axes(self):\n        import matplotlib.pyplot as plt\n        random_array = np.random.random((1000, 3))\n        df = pd.DataFrame(random_array,\n                          columns=['A label', 'B label', 'C label'])\n\n        fig, axes = plt.subplots(1, 2)\n        df.plot.scatter('A label', 'B label', c='C label', ax=axes[0])\n        df.plot.scatter('A label', 'B label', c='C label', ax=axes[1])\n        plt.tight_layout()\n\n        points = np.array([ax.get_position().get_points()\n                           for ax in fig.axes])\n        axes_x_coords = points[:, :, 0]\n        parent_distance = axes_x_coords[1, :] - axes_x_coords[0, :]\n        colorbar_distance = axes_x_coords[3, :] - axes_x_coords[2, :]\n        assert np.isclose(parent_distance,\n                          colorbar_distance, atol=1e-7).all()\n\n    @pytest.mark.slow\n    def test_plot_scatter_with_categorical_data(self):\n        # GH 16199\n        df = pd.DataFrame({'x': [1, 2, 3, 4],\n                           'y': pd.Categorical(['a', 'b', 'a', 'c'])})\n\n        with pytest.raises(ValueError) as ve:\n            df.plot(x='x', y='y', kind='scatter')\n        ve.match('requires y column to be numeric')\n\n        with pytest.raises(ValueError) as ve:\n            df.plot(x='y', y='x', kind='scatter')\n        ve.match('requires x column to be numeric')\n\n        with pytest.raises(ValueError) as ve:\n            df.plot(x='y', y='y', kind='scatter')\n        ve.match('requires x column to be numeric')\n\n    @pytest.mark.slow\n    def test_plot_scatter_with_c(self):\n        df = DataFrame(randn(6, 4),\n                       index=list(string.ascii_letters[:6]),\n                       columns=['x', 'y', 'z', 'four'])\n\n        axes = [df.plot.scatter(x='x', y='y', c='z'),\n                df.plot.scatter(x=0, y=1, c=2)]\n        for ax in axes:\n            # default to Greys\n            assert ax.collections[0].cmap.name == 'Greys'\n\n            # n.b. there appears to be no public method\n            # to get the colorbar label\n            assert ax.collections[0].colorbar._label == 'z'\n\n        cm = 'cubehelix'\n        ax = df.plot.scatter(x='x', y='y', c='z', colormap=cm)\n        assert ax.collections[0].cmap.name == cm\n\n        # verify turning off colorbar works\n        ax = df.plot.scatter(x='x', y='y', c='z', colorbar=False)\n        assert ax.collections[0].colorbar is None\n\n        # verify that we can still plot a solid color\n        ax = df.plot.scatter(x=0, y=1, c='red')\n        assert ax.collections[0].colorbar is None\n        self._check_colors(ax.collections, facecolors=['r'])\n\n        # Ensure that we can pass an np.array straight through to matplotlib,\n        # this functionality was accidentally removed previously.\n        # See https://github.com/pandas-dev/pandas/issues/8852 for bug report\n        #\n        # Exercise colormap path and non-colormap path as they are independent\n        #\n        df = DataFrame({'A': [1, 2], 'B': [3, 4]})\n        red_rgba = [1.0, 0.0, 0.0, 1.0]\n        green_rgba = [0.0, 1.0, 0.0, 1.0]\n        rgba_array = np.array([red_rgba, green_rgba])\n        ax = df.plot.scatter(x='A', y='B', c=rgba_array)\n        # expect the face colors of the points in the non-colormap path to be\n        # identical to the values we supplied, normally we'd be on shaky ground\n        # comparing floats for equality but here we expect them to be\n        # identical.\n        tm.assert_numpy_array_equal(ax.collections[0]\n                                    .get_facecolor(), rgba_array)\n        # we don't test the colors of the faces in this next plot because they\n        # are dependent on the spring colormap, which may change its colors\n        # later.\n        float_array = np.array([0.0, 1.0])\n        df.plot.scatter(x='A', y='B', c=float_array, cmap='spring')\n\n    def test_scatter_colors(self):\n        df = DataFrame({'a': [1, 2, 3], 'b': [1, 2, 3], 'c': [1, 2, 3]})\n        with pytest.raises(TypeError):\n            df.plot.scatter(x='a', y='b', c='c', color='green')\n\n        default_colors = self._unpack_cycler(self.plt.rcParams)\n\n        ax = df.plot.scatter(x='a', y='b', c='c')\n        tm.assert_numpy_array_equal(\n            ax.collections[0].get_facecolor()[0],\n            np.array(self.colorconverter.to_rgba(default_colors[0])))\n\n        ax = df.plot.scatter(x='a', y='b', color='white')\n        tm.assert_numpy_array_equal(ax.collections[0].get_facecolor()[0],\n                                    np.array([1, 1, 1, 1], dtype=np.float64))\n\n    @pytest.mark.slow\n    def test_plot_bar(self):\n        df = DataFrame(randn(6, 4),\n                       index=list(string.ascii_letters[:6]),\n                       columns=['one', 'two', 'three', 'four'])\n\n        _check_plot_works(df.plot.bar)\n        _check_plot_works(df.plot.bar, legend=False)\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(df.plot.bar, subplots=True)\n        _check_plot_works(df.plot.bar, stacked=True)\n\n        df = DataFrame(randn(10, 15),\n                       index=list(string.ascii_letters[:10]),\n                       columns=lrange(15))\n        _check_plot_works(df.plot.bar)\n\n        df = DataFrame({'a': [0, 1], 'b': [1, 0]})\n        ax = _check_plot_works(df.plot.bar)\n        self._check_ticks_props(ax, xrot=90)\n\n        ax = df.plot.bar(rot=35, fontsize=10)\n        self._check_ticks_props(ax, xrot=35, xlabelsize=10, ylabelsize=10)\n\n        ax = _check_plot_works(df.plot.barh)\n        self._check_ticks_props(ax, yrot=0)\n\n        ax = df.plot.barh(rot=55, fontsize=11)\n        self._check_ticks_props(ax, yrot=55, ylabelsize=11, xlabelsize=11)\n\n    def _check_bar_alignment(self, df, kind='bar', stacked=False,\n                             subplots=False, align='center', width=0.5,\n                             position=0.5):\n\n        axes = df.plot(kind=kind, stacked=stacked, subplots=subplots,\n                       align=align, width=width, position=position, grid=True)\n\n        axes = self._flatten_visible(axes)\n\n        for ax in axes:\n            if kind == 'bar':\n                axis = ax.xaxis\n                ax_min, ax_max = ax.get_xlim()\n                min_edge = min(p.get_x() for p in ax.patches)\n                max_edge = max(p.get_x() + p.get_width() for p in ax.patches)\n            elif kind == 'barh':\n                axis = ax.yaxis\n                ax_min, ax_max = ax.get_ylim()\n                min_edge = min(p.get_y() for p in ax.patches)\n                max_edge = max(p.get_y() + p.get_height() for p in ax.patches)\n            else:\n                raise ValueError\n\n            # GH 7498\n            # compare margins between lim and bar edges\n            tm.assert_almost_equal(ax_min, min_edge - 0.25)\n            tm.assert_almost_equal(ax_max, max_edge + 0.25)\n\n            p = ax.patches[0]\n            if kind == 'bar' and (stacked is True or subplots is True):\n                edge = p.get_x()\n                center = edge + p.get_width() * position\n            elif kind == 'bar' and stacked is False:\n                center = p.get_x() + p.get_width() * len(df.columns) * position\n                edge = p.get_x()\n            elif kind == 'barh' and (stacked is True or subplots is True):\n                center = p.get_y() + p.get_height() * position\n                edge = p.get_y()\n            elif kind == 'barh' and stacked is False:\n                center = p.get_y() + p.get_height() * len(\n                    df.columns) * position\n                edge = p.get_y()\n            else:\n                raise ValueError\n\n            # Check the ticks locates on integer\n            assert (axis.get_ticklocs() == np.arange(len(df))).all()\n\n            if align == 'center':\n                # Check whether the bar locates on center\n                tm.assert_almost_equal(axis.get_ticklocs()[0], center)\n            elif align == 'edge':\n                # Check whether the bar's edge starts from the tick\n                tm.assert_almost_equal(axis.get_ticklocs()[0], edge)\n            else:\n                raise ValueError\n\n        return axes\n\n    @pytest.mark.slow\n    def test_bar_stacked_center(self):\n        # GH2157\n        df = DataFrame({'A': [3] * 5, 'B': lrange(5)}, index=lrange(5))\n        self._check_bar_alignment(df, kind='bar', stacked=True)\n        self._check_bar_alignment(df, kind='bar', stacked=True, width=0.9)\n        self._check_bar_alignment(df, kind='barh', stacked=True)\n        self._check_bar_alignment(df, kind='barh', stacked=True, width=0.9)\n\n    @pytest.mark.slow\n    def test_bar_center(self):\n        df = DataFrame({'A': [3] * 5, 'B': lrange(5)}, index=lrange(5))\n        self._check_bar_alignment(df, kind='bar', stacked=False)\n        self._check_bar_alignment(df, kind='bar', stacked=False, width=0.9)\n        self._check_bar_alignment(df, kind='barh', stacked=False)\n        self._check_bar_alignment(df, kind='barh', stacked=False, width=0.9)\n\n    @pytest.mark.slow\n    def test_bar_subplots_center(self):\n        df = DataFrame({'A': [3] * 5, 'B': lrange(5)}, index=lrange(5))\n        self._check_bar_alignment(df, kind='bar', subplots=True)\n        self._check_bar_alignment(df, kind='bar', subplots=True, width=0.9)\n        self._check_bar_alignment(df, kind='barh', subplots=True)\n        self._check_bar_alignment(df, kind='barh', subplots=True, width=0.9)\n\n    @pytest.mark.slow\n    def test_bar_align_single_column(self):\n        df = DataFrame(randn(5))\n        self._check_bar_alignment(df, kind='bar', stacked=False)\n        self._check_bar_alignment(df, kind='bar', stacked=True)\n        self._check_bar_alignment(df, kind='barh', stacked=False)\n        self._check_bar_alignment(df, kind='barh', stacked=True)\n        self._check_bar_alignment(df, kind='bar', subplots=True)\n        self._check_bar_alignment(df, kind='barh', subplots=True)\n\n    @pytest.mark.slow\n    def test_bar_edge(self):\n        df = DataFrame({'A': [3] * 5, 'B': lrange(5)}, index=lrange(5))\n\n        self._check_bar_alignment(df, kind='bar', stacked=True, align='edge')\n        self._check_bar_alignment(df, kind='bar', stacked=True, width=0.9,\n                                  align='edge')\n        self._check_bar_alignment(df, kind='barh', stacked=True, align='edge')\n        self._check_bar_alignment(df, kind='barh', stacked=True, width=0.9,\n                                  align='edge')\n\n        self._check_bar_alignment(df, kind='bar', stacked=False, align='edge')\n        self._check_bar_alignment(df, kind='bar', stacked=False, width=0.9,\n                                  align='edge')\n        self._check_bar_alignment(df, kind='barh', stacked=False, align='edge')\n        self._check_bar_alignment(df, kind='barh', stacked=False, width=0.9,\n                                  align='edge')\n\n        self._check_bar_alignment(df, kind='bar', subplots=True, align='edge')\n        self._check_bar_alignment(df, kind='bar', subplots=True, width=0.9,\n                                  align='edge')\n        self._check_bar_alignment(df, kind='barh', subplots=True, align='edge')\n        self._check_bar_alignment(df, kind='barh', subplots=True, width=0.9,\n                                  align='edge')\n\n    @pytest.mark.slow\n    def test_bar_log_no_subplots(self):\n        # GH3254, GH3298 matplotlib/matplotlib#1882, #1892\n        # regressions in 1.2.1\n        expected = np.array([.1, 1., 10., 100])\n\n        # no subplots\n        df = DataFrame({'A': [3] * 5, 'B': lrange(1, 6)}, index=lrange(5))\n        ax = df.plot.bar(grid=True, log=True)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)\n\n    @pytest.mark.slow\n    def test_bar_log_subplots(self):\n        expected = np.array([.1, 1., 10., 100., 1000., 1e4])\n\n        ax = DataFrame([Series([200, 300]), Series([300, 500])]).plot.bar(\n            log=True, subplots=True)\n\n        tm.assert_numpy_array_equal(ax[0].yaxis.get_ticklocs(), expected)\n        tm.assert_numpy_array_equal(ax[1].yaxis.get_ticklocs(), expected)\n\n    @pytest.mark.slow\n    def test_boxplot(self):\n        df = self.hist_df\n        series = df['height']\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n\n        ax = _check_plot_works(df.plot.box)\n        self._check_text_labels(ax.get_xticklabels(), labels)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(),\n                                    np.arange(1, len(numeric_cols) + 1))\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n        # different warning on py3\n        if not PY3:\n            with tm.assert_produces_warning(UserWarning):\n                axes = _check_plot_works(df.plot.box, subplots=True, logy=True)\n\n            self._check_axes_shape(axes, axes_num=3, layout=(1, 3))\n            self._check_ax_scales(axes, yaxis='log')\n            for ax, label in zip(axes, labels):\n                self._check_text_labels(ax.get_xticklabels(), [label])\n                assert len(ax.lines) == self.bp_n_objects\n\n        axes = series.plot.box(rot=40)\n        self._check_ticks_props(axes, xrot=40, yrot=0)\n        tm.close()\n\n        ax = _check_plot_works(series.plot.box)\n\n        positions = np.array([1, 6, 7])\n        ax = df.plot.box(positions=positions)\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n        self._check_text_labels(ax.get_xticklabels(), labels)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), positions)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n    @pytest.mark.slow\n    def test_boxplot_vertical(self):\n        df = self.hist_df\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n\n        # if horizontal, yticklabels are rotated\n        ax = df.plot.box(rot=50, fontsize=8, vert=False)\n        self._check_ticks_props(ax, xrot=0, yrot=50, ylabelsize=8)\n        self._check_text_labels(ax.get_yticklabels(), labels)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot.box,\n                                     subplots=True, vert=False, logx=True)\n        self._check_axes_shape(axes, axes_num=3, layout=(1, 3))\n        self._check_ax_scales(axes, xaxis='log')\n        for ax, label in zip(axes, labels):\n            self._check_text_labels(ax.get_yticklabels(), [label])\n            assert len(ax.lines) == self.bp_n_objects\n\n        positions = np.array([3, 2, 8])\n        ax = df.plot.box(positions=positions, vert=False)\n        self._check_text_labels(ax.get_yticklabels(), labels)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), positions)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n    @pytest.mark.slow\n    def test_boxplot_return_type(self):\n        df = DataFrame(randn(6, 4),\n                       index=list(string.ascii_letters[:6]),\n                       columns=['one', 'two', 'three', 'four'])\n        with pytest.raises(ValueError):\n            df.plot.box(return_type='NOTATYPE')\n\n        result = df.plot.box(return_type='dict')\n        self._check_box_return_type(result, 'dict')\n\n        result = df.plot.box(return_type='axes')\n        self._check_box_return_type(result, 'axes')\n\n        result = df.plot.box()  # default axes\n        self._check_box_return_type(result, 'axes')\n\n        result = df.plot.box(return_type='both')\n        self._check_box_return_type(result, 'both')\n\n    @pytest.mark.slow\n    def test_boxplot_subplots_return_type(self):\n        df = self.hist_df\n\n        # normal style: return_type=None\n        result = df.plot.box(subplots=True)\n        assert isinstance(result, Series)\n        self._check_box_return_type(result, None, expected_keys=[\n                                    'height', 'weight', 'category'])\n\n        for t in ['dict', 'axes', 'both']:\n            returned = df.plot.box(return_type=t, subplots=True)\n            self._check_box_return_type(\n                returned, t,\n                expected_keys=['height', 'weight', 'category'],\n                check_ax_title=False)\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_df(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        df = DataFrame(randn(100, 4))\n        ax = _check_plot_works(df.plot, kind='kde')\n        expected = [pprint_thing(c) for c in df.columns]\n        self._check_legend_labels(ax, labels=expected)\n        self._check_ticks_props(ax, xrot=0)\n\n        ax = df.plot(kind='kde', rot=20, fontsize=5)\n        self._check_ticks_props(ax, xrot=20, xlabelsize=5, ylabelsize=5)\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot, kind='kde',\n                                     subplots=True)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        axes = df.plot(kind='kde', logy=True, subplots=True)\n        self._check_ax_scales(axes, yaxis='log')\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_missing_vals(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        df = DataFrame(np.random.uniform(size=(100, 4)))\n        df.loc[0, 0] = np.nan\n        _check_plot_works(df.plot, kind='kde')\n\n    @pytest.mark.slow\n    def test_hist_df(self):\n        from matplotlib.patches import Rectangle\n\n        df = DataFrame(randn(100, 4))\n        series = df[0]\n\n        ax = _check_plot_works(df.plot.hist)\n        expected = [pprint_thing(c) for c in df.columns]\n        self._check_legend_labels(ax, labels=expected)\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot.hist,\n                                     subplots=True, logy=True)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n        self._check_ax_scales(axes, yaxis='log')\n\n        axes = series.plot.hist(rot=40)\n        self._check_ticks_props(axes, xrot=40, yrot=0)\n        tm.close()\n\n        if plotting._compat._mpl_ge_2_2_0():\n            kwargs = {\"density\": True}\n        else:\n            kwargs = {\"normed\": True}\n        ax = series.plot.hist(cumulative=True, bins=4, **kwargs)\n        # height of last bin (index 5) must be 1.0\n        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]\n        tm.assert_almost_equal(rects[-1].get_height(), 1.0)\n        tm.close()\n\n        ax = series.plot.hist(cumulative=True, bins=4)\n        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]\n\n        tm.assert_almost_equal(rects[-2].get_height(), 100.0)\n        tm.close()\n\n        # if horizontal, yticklabels are rotated\n        axes = df.plot.hist(rot=50, fontsize=8, orientation='horizontal')\n        self._check_ticks_props(axes, xrot=0, yrot=50, ylabelsize=8)\n\n    def _check_box_coord(self, patches, expected_y=None, expected_h=None,\n                         expected_x=None, expected_w=None):\n        result_y = np.array([p.get_y() for p in patches])\n        result_height = np.array([p.get_height() for p in patches])\n        result_x = np.array([p.get_x() for p in patches])\n        result_width = np.array([p.get_width() for p in patches])\n        # dtype is depending on above values, no need to check\n\n        if expected_y is not None:\n            tm.assert_numpy_array_equal(result_y, expected_y,\n                                        check_dtype=False)\n        if expected_h is not None:\n            tm.assert_numpy_array_equal(result_height, expected_h,\n                                        check_dtype=False)\n        if expected_x is not None:\n            tm.assert_numpy_array_equal(result_x, expected_x,\n                                        check_dtype=False)\n        if expected_w is not None:\n            tm.assert_numpy_array_equal(result_width, expected_w,\n                                        check_dtype=False)\n\n    @pytest.mark.slow\n    def test_hist_df_coord(self):\n        normal_df = DataFrame({'A': np.repeat(np.array([1, 2, 3, 4, 5]),\n                                              np.array([10, 9, 8, 7, 6])),\n                               'B': np.repeat(np.array([1, 2, 3, 4, 5]),\n                                              np.array([8, 8, 8, 8, 8])),\n                               'C': np.repeat(np.array([1, 2, 3, 4, 5]),\n                                              np.array([6, 7, 8, 9, 10]))},\n                              columns=['A', 'B', 'C'])\n\n        nan_df = DataFrame({'A': np.repeat(np.array([np.nan, 1, 2, 3, 4, 5]),\n                                           np.array([3, 10, 9, 8, 7, 6])),\n                            'B': np.repeat(np.array([1, np.nan, 2, 3, 4, 5]),\n                                           np.array([8, 3, 8, 8, 8, 8])),\n                            'C': np.repeat(np.array([1, 2, 3, np.nan, 4, 5]),\n                                           np.array([6, 7, 8, 3, 9, 10]))},\n                           columns=['A', 'B', 'C'])\n\n        for df in [normal_df, nan_df]:\n            ax = df.plot.hist(bins=5)\n            self._check_box_coord(ax.patches[:5],\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(ax.patches[5:10],\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(ax.patches[10:],\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([6, 7, 8, 9, 10]))\n\n            ax = df.plot.hist(bins=5, stacked=True)\n            self._check_box_coord(ax.patches[:5],\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(ax.patches[5:10],\n                                  expected_y=np.array([10, 9, 8, 7, 6]),\n                                  expected_h=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(ax.patches[10:],\n                                  expected_y=np.array([18, 17, 16, 15, 14]),\n                                  expected_h=np.array([6, 7, 8, 9, 10]))\n\n            axes = df.plot.hist(bins=5, stacked=True, subplots=True)\n            self._check_box_coord(axes[0].patches,\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(axes[1].patches,\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(axes[2].patches,\n                                  expected_y=np.array([0, 0, 0, 0, 0]),\n                                  expected_h=np.array([6, 7, 8, 9, 10]))\n\n            # horizontal\n            ax = df.plot.hist(bins=5, orientation='horizontal')\n            self._check_box_coord(ax.patches[:5],\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(ax.patches[5:10],\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(ax.patches[10:],\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([6, 7, 8, 9, 10]))\n\n            ax = df.plot.hist(bins=5, stacked=True,\n                              orientation='horizontal')\n            self._check_box_coord(ax.patches[:5],\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(ax.patches[5:10],\n                                  expected_x=np.array([10, 9, 8, 7, 6]),\n                                  expected_w=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(\n                ax.patches[10:],\n                expected_x=np.array([18, 17, 16, 15, 14]),\n                expected_w=np.array([6, 7, 8, 9, 10]))\n\n            axes = df.plot.hist(bins=5, stacked=True, subplots=True,\n                                orientation='horizontal')\n            self._check_box_coord(axes[0].patches,\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([10, 9, 8, 7, 6]))\n            self._check_box_coord(axes[1].patches,\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([8, 8, 8, 8, 8]))\n            self._check_box_coord(axes[2].patches,\n                                  expected_x=np.array([0, 0, 0, 0, 0]),\n                                  expected_w=np.array([6, 7, 8, 9, 10]))\n\n    @pytest.mark.slow\n    def test_plot_int_columns(self):\n        df = DataFrame(randn(100, 4)).cumsum()\n        _check_plot_works(df.plot, legend=True)\n\n    @pytest.mark.slow\n    def test_df_legend_labels(self):\n        kinds = ['line', 'bar', 'barh', 'kde', 'area', 'hist']\n        df = DataFrame(rand(3, 3), columns=['a', 'b', 'c'])\n        df2 = DataFrame(rand(3, 3), columns=['d', 'e', 'f'])\n        df3 = DataFrame(rand(3, 3), columns=['g', 'h', 'i'])\n        df4 = DataFrame(rand(3, 3), columns=['j', 'k', 'l'])\n\n        for kind in kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n\n            ax = df.plot(kind=kind, legend=True)\n            self._check_legend_labels(ax, labels=df.columns)\n\n            ax = df2.plot(kind=kind, legend=False, ax=ax)\n            self._check_legend_labels(ax, labels=df.columns)\n\n            ax = df3.plot(kind=kind, legend=True, ax=ax)\n            self._check_legend_labels(ax, labels=df.columns.union(df3.columns))\n\n            ax = df4.plot(kind=kind, legend='reverse', ax=ax)\n            expected = list(df.columns.union(df3.columns)) + list(reversed(\n                df4.columns))\n            self._check_legend_labels(ax, labels=expected)\n\n        # Secondary Y\n        ax = df.plot(legend=True, secondary_y='b')\n        self._check_legend_labels(ax, labels=['a', 'b (right)', 'c'])\n        ax = df2.plot(legend=False, ax=ax)\n        self._check_legend_labels(ax, labels=['a', 'b (right)', 'c'])\n        ax = df3.plot(kind='bar', legend=True, secondary_y='h', ax=ax)\n        self._check_legend_labels(\n            ax, labels=['a', 'b (right)', 'c', 'g', 'h (right)', 'i'])\n\n        # Time Series\n        ind = date_range('1/1/2014', periods=3)\n        df = DataFrame(randn(3, 3), columns=['a', 'b', 'c'], index=ind)\n        df2 = DataFrame(randn(3, 3), columns=['d', 'e', 'f'], index=ind)\n        df3 = DataFrame(randn(3, 3), columns=['g', 'h', 'i'], index=ind)\n        ax = df.plot(legend=True, secondary_y='b')\n        self._check_legend_labels(ax, labels=['a', 'b (right)', 'c'])\n        ax = df2.plot(legend=False, ax=ax)\n        self._check_legend_labels(ax, labels=['a', 'b (right)', 'c'])\n        ax = df3.plot(legend=True, ax=ax)\n        self._check_legend_labels(\n            ax, labels=['a', 'b (right)', 'c', 'g', 'h', 'i'])\n\n        # scatter\n        ax = df.plot.scatter(x='a', y='b', label='data1')\n        self._check_legend_labels(ax, labels=['data1'])\n        ax = df2.plot.scatter(x='d', y='e', legend=False, label='data2', ax=ax)\n        self._check_legend_labels(ax, labels=['data1'])\n        ax = df3.plot.scatter(x='g', y='h', label='data3', ax=ax)\n        self._check_legend_labels(ax, labels=['data1', 'data3'])\n\n        # ensure label args pass through and\n        # index name does not mutate\n        # column names don't mutate\n        df5 = df.set_index('a')\n        ax = df5.plot(y='b')\n        self._check_legend_labels(ax, labels=['b'])\n        ax = df5.plot(y='b', label='LABEL_b')\n        self._check_legend_labels(ax, labels=['LABEL_b'])\n        self._check_text_labels(ax.xaxis.get_label(), 'a')\n        ax = df5.plot(y='c', label='LABEL_c', ax=ax)\n        self._check_legend_labels(ax, labels=['LABEL_b', 'LABEL_c'])\n        assert df5.columns.tolist() == ['b', 'c']\n\n    def test_legend_name(self):\n        multi = DataFrame(randn(4, 4),\n                          columns=[np.array(['a', 'a', 'b', 'b']),\n                                   np.array(['x', 'y', 'x', 'y'])])\n        multi.columns.names = ['group', 'individual']\n\n        ax = multi.plot()\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, 'group,individual')\n\n        df = DataFrame(randn(5, 5))\n        ax = df.plot(legend=True, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, 'group,individual')\n\n        df.columns.name = 'new'\n        ax = df.plot(legend=False, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, 'group,individual')\n\n        ax = df.plot(legend=True, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, 'new')\n\n    @pytest.mark.slow\n    def test_no_legend(self):\n        kinds = ['line', 'bar', 'barh', 'kde', 'area', 'hist']\n        df = DataFrame(rand(3, 3), columns=['a', 'b', 'c'])\n\n        for kind in kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n\n            ax = df.plot(kind=kind, legend=False)\n            self._check_legend_labels(ax, visible=False)\n\n    @pytest.mark.slow\n    def test_style_by_column(self):\n        import matplotlib.pyplot as plt\n        fig = plt.gcf()\n\n        df = DataFrame(randn(100, 3))\n        for markers in [{0: '^',\n                         1: '+',\n                         2: 'o'}, {0: '^',\n                                   1: '+'}, ['^', '+', 'o'], ['^', '+']]:\n            fig.clf()\n            fig.add_subplot(111)\n            ax = df.plot(style=markers)\n            for i, l in enumerate(ax.get_lines()[:len(markers)]):\n                assert l.get_marker() == markers[i]\n\n    @pytest.mark.slow\n    def test_line_label_none(self):\n        s = Series([1, 2])\n        ax = s.plot()\n        assert ax.get_legend() is None\n\n        ax = s.plot(legend=True)\n        assert ax.get_legend().get_texts()[0].get_text() == 'None'\n\n    @pytest.mark.slow\n    def test_line_colors(self):\n        from matplotlib import cm\n\n        custom_colors = 'rgcby'\n        df = DataFrame(randn(5, 5))\n\n        ax = df.plot(color=custom_colors)\n        self._check_colors(ax.get_lines(), linecolors=custom_colors)\n\n        tm.close()\n\n        ax2 = df.plot(color=custom_colors)\n        lines2 = ax2.get_lines()\n\n        for l1, l2 in zip(ax.get_lines(), lines2):\n            assert l1.get_color() == l2.get_color()\n\n        tm.close()\n\n        ax = df.plot(colormap='jet')\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        self._check_colors(ax.get_lines(), linecolors=rgba_colors)\n        tm.close()\n\n        ax = df.plot(colormap=cm.jet)\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        self._check_colors(ax.get_lines(), linecolors=rgba_colors)\n        tm.close()\n\n        # make color a list if plotting one column frame\n        # handles cases like df.plot(color='DodgerBlue')\n        ax = df.loc[:, [0]].plot(color='DodgerBlue')\n        self._check_colors(ax.lines, linecolors=['DodgerBlue'])\n\n        ax = df.plot(color='red')\n        self._check_colors(ax.get_lines(), linecolors=['red'] * 5)\n        tm.close()\n\n        # GH 10299\n        custom_colors = ['#FF0000', '#0000FF', '#FFFF00', '#000000', '#FFFFFF']\n        ax = df.plot(color=custom_colors)\n        self._check_colors(ax.get_lines(), linecolors=custom_colors)\n        tm.close()\n\n        with pytest.raises(ValueError):\n            # Color contains shorthand hex value results in ValueError\n            custom_colors = ['#F00', '#00F', '#FF0', '#000', '#FFF']\n            # Forced show plot\n            _check_plot_works(df.plot, color=custom_colors)\n\n    @pytest.mark.slow\n    def test_dont_modify_colors(self):\n        colors = ['r', 'g', 'b']\n        pd.DataFrame(np.random.rand(10, 2)).plot(color=colors)\n        assert len(colors) == 3\n\n    @pytest.mark.slow\n    def test_line_colors_and_styles_subplots(self):\n        # GH 9894\n        from matplotlib import cm\n        default_colors = self._unpack_cycler(self.plt.rcParams)\n\n        df = DataFrame(randn(5, 5))\n\n        axes = df.plot(subplots=True)\n        for ax, c in zip(axes, list(default_colors)):\n            c = [c]\n            self._check_colors(ax.get_lines(), linecolors=c)\n        tm.close()\n\n        # single color char\n        axes = df.plot(subplots=True, color='k')\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['k'])\n        tm.close()\n\n        # single color str\n        axes = df.plot(subplots=True, color='green')\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['green'])\n        tm.close()\n\n        custom_colors = 'rgcby'\n        axes = df.plot(color=custom_colors, subplots=True)\n        for ax, c in zip(axes, list(custom_colors)):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n        axes = df.plot(color=list(custom_colors), subplots=True)\n        for ax, c in zip(axes, list(custom_colors)):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n        # GH 10299\n        custom_colors = ['#FF0000', '#0000FF', '#FFFF00', '#000000', '#FFFFFF']\n        axes = df.plot(color=custom_colors, subplots=True)\n        for ax, c in zip(axes, list(custom_colors)):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n        with pytest.raises(ValueError):\n            # Color contains shorthand hex value results in ValueError\n            custom_colors = ['#F00', '#00F', '#FF0', '#000', '#FFF']\n            # Forced show plot\n            # _check_plot_works adds an ax so catch warning. see GH #13188\n            with tm.assert_produces_warning(UserWarning):\n                _check_plot_works(df.plot, color=custom_colors, subplots=True)\n\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        for cmap in ['jet', cm.jet]:\n            axes = df.plot(colormap=cmap, subplots=True)\n            for ax, c in zip(axes, rgba_colors):\n                self._check_colors(ax.get_lines(), linecolors=[c])\n            tm.close()\n\n        # make color a list if plotting one column frame\n        # handles cases like df.plot(color='DodgerBlue')\n        axes = df.loc[:, [0]].plot(color='DodgerBlue', subplots=True)\n        self._check_colors(axes[0].lines, linecolors=['DodgerBlue'])\n\n        # single character style\n        axes = df.plot(style='r', subplots=True)\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['r'])\n        tm.close()\n\n        # list of styles\n        styles = list('rgcby')\n        axes = df.plot(style=styles, subplots=True)\n        for ax, c in zip(axes, styles):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n    @pytest.mark.slow\n    def test_area_colors(self):\n        from matplotlib import cm\n        from matplotlib.collections import PolyCollection\n\n        custom_colors = 'rgcby'\n        df = DataFrame(rand(5, 5))\n\n        ax = df.plot.area(color=custom_colors)\n        self._check_colors(ax.get_lines(), linecolors=custom_colors)\n        poly = [o for o in ax.get_children() if isinstance(o, PolyCollection)]\n        self._check_colors(poly, facecolors=custom_colors)\n\n        handles, labels = ax.get_legend_handles_labels()\n        self._check_colors(handles, facecolors=custom_colors)\n\n        for h in handles:\n            assert h.get_alpha() is None\n        tm.close()\n\n        ax = df.plot.area(colormap='jet')\n        jet_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        self._check_colors(ax.get_lines(), linecolors=jet_colors)\n        poly = [o for o in ax.get_children() if isinstance(o, PolyCollection)]\n        self._check_colors(poly, facecolors=jet_colors)\n\n        handles, labels = ax.get_legend_handles_labels()\n        self._check_colors(handles, facecolors=jet_colors)\n        for h in handles:\n            assert h.get_alpha() is None\n        tm.close()\n\n        # When stacked=False, alpha is set to 0.5\n        ax = df.plot.area(colormap=cm.jet, stacked=False)\n        self._check_colors(ax.get_lines(), linecolors=jet_colors)\n        poly = [o for o in ax.get_children() if isinstance(o, PolyCollection)]\n        jet_with_alpha = [(c[0], c[1], c[2], 0.5) for c in jet_colors]\n        self._check_colors(poly, facecolors=jet_with_alpha)\n\n        handles, labels = ax.get_legend_handles_labels()\n        linecolors = jet_with_alpha\n        self._check_colors(handles[:len(jet_colors)], linecolors=linecolors)\n        for h in handles:\n            assert h.get_alpha() == 0.5\n\n    @pytest.mark.slow\n    def test_hist_colors(self):\n        default_colors = self._unpack_cycler(self.plt.rcParams)\n\n        df = DataFrame(randn(5, 5))\n        ax = df.plot.hist()\n        self._check_colors(ax.patches[::10], facecolors=default_colors[:5])\n        tm.close()\n\n        custom_colors = 'rgcby'\n        ax = df.plot.hist(color=custom_colors)\n        self._check_colors(ax.patches[::10], facecolors=custom_colors)\n        tm.close()\n\n        from matplotlib import cm\n        # Test str -> colormap functionality\n        ax = df.plot.hist(colormap='jet')\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, 5))\n        self._check_colors(ax.patches[::10], facecolors=rgba_colors)\n        tm.close()\n\n        # Test colormap functionality\n        ax = df.plot.hist(colormap=cm.jet)\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, 5))\n        self._check_colors(ax.patches[::10], facecolors=rgba_colors)\n        tm.close()\n\n        ax = df.loc[:, [0]].plot.hist(color='DodgerBlue')\n        self._check_colors([ax.patches[0]], facecolors=['DodgerBlue'])\n\n        ax = df.plot(kind='hist', color='green')\n        self._check_colors(ax.patches[::10], facecolors=['green'] * 5)\n        tm.close()\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_colors(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        from matplotlib import cm\n\n        custom_colors = 'rgcby'\n        df = DataFrame(rand(5, 5))\n\n        ax = df.plot.kde(color=custom_colors)\n        self._check_colors(ax.get_lines(), linecolors=custom_colors)\n        tm.close()\n\n        ax = df.plot.kde(colormap='jet')\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        self._check_colors(ax.get_lines(), linecolors=rgba_colors)\n        tm.close()\n\n        ax = df.plot.kde(colormap=cm.jet)\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        self._check_colors(ax.get_lines(), linecolors=rgba_colors)\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_colors_and_styles_subplots(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        from matplotlib import cm\n        default_colors = self._unpack_cycler(self.plt.rcParams)\n\n        df = DataFrame(randn(5, 5))\n\n        axes = df.plot(kind='kde', subplots=True)\n        for ax, c in zip(axes, list(default_colors)):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n        # single color char\n        axes = df.plot(kind='kde', color='k', subplots=True)\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['k'])\n        tm.close()\n\n        # single color str\n        axes = df.plot(kind='kde', color='red', subplots=True)\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['red'])\n        tm.close()\n\n        custom_colors = 'rgcby'\n        axes = df.plot(kind='kde', color=custom_colors, subplots=True)\n        for ax, c in zip(axes, list(custom_colors)):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n        rgba_colors = lmap(cm.jet, np.linspace(0, 1, len(df)))\n        for cmap in ['jet', cm.jet]:\n            axes = df.plot(kind='kde', colormap=cmap, subplots=True)\n            for ax, c in zip(axes, rgba_colors):\n                self._check_colors(ax.get_lines(), linecolors=[c])\n            tm.close()\n\n        # make color a list if plotting one column frame\n        # handles cases like df.plot(color='DodgerBlue')\n        axes = df.loc[:, [0]].plot(kind='kde', color='DodgerBlue',\n                                   subplots=True)\n        self._check_colors(axes[0].lines, linecolors=['DodgerBlue'])\n\n        # single character style\n        axes = df.plot(kind='kde', style='r', subplots=True)\n        for ax in axes:\n            self._check_colors(ax.get_lines(), linecolors=['r'])\n        tm.close()\n\n        # list of styles\n        styles = list('rgcby')\n        axes = df.plot(kind='kde', style=styles, subplots=True)\n        for ax, c in zip(axes, styles):\n            self._check_colors(ax.get_lines(), linecolors=[c])\n        tm.close()\n\n    @pytest.mark.slow\n    def test_boxplot_colors(self):\n        def _check_colors(bp, box_c, whiskers_c, medians_c, caps_c='k',\n                          fliers_c=None):\n            # TODO: outside this func?\n            if fliers_c is None:\n                fliers_c = 'k'\n            self._check_colors(bp['boxes'],\n                               linecolors=[box_c] * len(bp['boxes']))\n            self._check_colors(bp['whiskers'],\n                               linecolors=[whiskers_c] * len(bp['whiskers']))\n            self._check_colors(bp['medians'],\n                               linecolors=[medians_c] * len(bp['medians']))\n            self._check_colors(bp['fliers'],\n                               linecolors=[fliers_c] * len(bp['fliers']))\n            self._check_colors(bp['caps'],\n                               linecolors=[caps_c] * len(bp['caps']))\n\n        default_colors = self._unpack_cycler(self.plt.rcParams)\n\n        df = DataFrame(randn(5, 5))\n        bp = df.plot.box(return_type='dict')\n        _check_colors(bp, default_colors[0], default_colors[0],\n                      default_colors[2])\n        tm.close()\n\n        dict_colors = dict(boxes='#572923', whiskers='#982042',\n                           medians='#804823', caps='#123456')\n        bp = df.plot.box(color=dict_colors, sym='r+', return_type='dict')\n        _check_colors(bp, dict_colors['boxes'], dict_colors['whiskers'],\n                      dict_colors['medians'], dict_colors['caps'], 'r')\n        tm.close()\n\n        # partial colors\n        dict_colors = dict(whiskers='c', medians='m')\n        bp = df.plot.box(color=dict_colors, return_type='dict')\n        _check_colors(bp, default_colors[0], 'c', 'm')\n        tm.close()\n\n        from matplotlib import cm\n        # Test str -> colormap functionality\n        bp = df.plot.box(colormap='jet', return_type='dict')\n        jet_colors = lmap(cm.jet, np.linspace(0, 1, 3))\n        _check_colors(bp, jet_colors[0], jet_colors[0], jet_colors[2])\n        tm.close()\n\n        # Test colormap functionality\n        bp = df.plot.box(colormap=cm.jet, return_type='dict')\n        _check_colors(bp, jet_colors[0], jet_colors[0], jet_colors[2])\n        tm.close()\n\n        # string color is applied to all artists except fliers\n        bp = df.plot.box(color='DodgerBlue', return_type='dict')\n        _check_colors(bp, 'DodgerBlue', 'DodgerBlue', 'DodgerBlue',\n                      'DodgerBlue')\n\n        # tuple is also applied to all artists except fliers\n        bp = df.plot.box(color=(0, 1, 0), sym='#123456', return_type='dict')\n        _check_colors(bp, (0, 1, 0), (0, 1, 0), (0, 1, 0),\n                      (0, 1, 0), '#123456')\n\n        with pytest.raises(ValueError):\n            # Color contains invalid key results in ValueError\n            df.plot.box(color=dict(boxes='red', xxxx='blue'))\n\n    def test_default_color_cycle(self):\n        import matplotlib.pyplot as plt\n        import cycler\n        colors = list('rgbk')\n        plt.rcParams['axes.prop_cycle'] = cycler.cycler('color', colors)\n\n        df = DataFrame(randn(5, 3))\n        ax = df.plot()\n\n        expected = self._unpack_cycler(plt.rcParams)[:3]\n        self._check_colors(ax.get_lines(), linecolors=expected)\n\n    def test_unordered_ts(self):\n        df = DataFrame(np.array([3.0, 2.0, 1.0]),\n                       index=[date(2012, 10, 1),\n                              date(2012, 9, 1),\n                              date(2012, 8, 1)],\n                       columns=['test'])\n        ax = df.plot()\n        xticks = ax.lines[0].get_xdata()\n        assert xticks[0] < xticks[1]\n        ydata = ax.lines[0].get_ydata()\n        tm.assert_numpy_array_equal(ydata, np.array([1.0, 2.0, 3.0]))\n\n    def test_kind_both_ways(self):\n        df = DataFrame({'x': [1, 2, 3]})\n        for kind in plotting._core._common_kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            df.plot(kind=kind)\n            getattr(df.plot, kind)()\n        for kind in ['scatter', 'hexbin']:\n            df.plot('x', 'x', kind=kind)\n            getattr(df.plot, kind)('x', 'x')\n\n    def test_all_invalid_plot_data(self):\n        df = DataFrame(list('abcd'))\n        for kind in plotting._core._common_kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            with pytest.raises(TypeError):\n                df.plot(kind=kind)\n\n    @pytest.mark.slow\n    def test_partially_invalid_plot_data(self):\n        with tm.RNGContext(42):\n            df = DataFrame(randn(10, 2), dtype=object)\n            df[np.random.rand(df.shape[0]) > 0.5] = 'a'\n            for kind in plotting._core._common_kinds:\n                if not _ok_for_gaussian_kde(kind):\n                    continue\n                with pytest.raises(TypeError):\n                    df.plot(kind=kind)\n\n        with tm.RNGContext(42):\n            # area plot doesn't support positive/negative mixed data\n            kinds = ['area']\n            df = DataFrame(rand(10, 2), dtype=object)\n            df[np.random.rand(df.shape[0]) > 0.5] = 'a'\n            for kind in kinds:\n                with pytest.raises(TypeError):\n                    df.plot(kind=kind)\n\n    def test_invalid_kind(self):\n        df = DataFrame(randn(10, 2))\n        with pytest.raises(ValueError):\n            df.plot(kind='aasdf')\n\n    @pytest.mark.parametrize(\"x,y,lbl\", [\n        (['B', 'C'], 'A', 'a'),\n        (['A'], ['B', 'C'], ['b', 'c']),\n        ('A', ['B', 'C'], 'badlabel')\n    ])\n    def test_invalid_xy_args(self, x, y, lbl):\n        # GH 18671, 19699 allows y to be list-like but not x\n        df = DataFrame({\"A\": [1, 2], 'B': [3, 4], 'C': [5, 6]})\n        with pytest.raises(ValueError):\n            df.plot(x=x, y=y, label=lbl)\n\n    @pytest.mark.parametrize(\"x,y\", [\n        ('A', 'B'),\n        (['A'], 'B')\n    ])\n    def test_invalid_xy_args_dup_cols(self, x, y):\n        # GH 18671, 19699 allows y to be list-like but not x\n        df = DataFrame([[1, 3, 5], [2, 4, 6]], columns=list('AAB'))\n        with pytest.raises(ValueError):\n            df.plot(x=x, y=y)\n\n    @pytest.mark.parametrize(\"x,y,lbl,colors\", [\n        ('A', ['B'], ['b'], ['red']),\n        ('A', ['B', 'C'], ['b', 'c'], ['red', 'blue']),\n        (0, [1, 2], ['bokeh', 'cython'], ['green', 'yellow'])\n    ])\n    def test_y_listlike(self, x, y, lbl, colors):\n        # GH 19699: tests list-like y and verifies lbls & colors\n        df = DataFrame({\"A\": [1, 2], 'B': [3, 4], 'C': [5, 6]})\n        _check_plot_works(df.plot, x='A', y=y, label=lbl)\n\n        ax = df.plot(x=x, y=y, label=lbl, color=colors)\n        assert len(ax.lines) == len(y)\n        self._check_colors(ax.get_lines(), linecolors=colors)\n\n    @pytest.mark.parametrize(\"x,y,colnames\", [\n        (0, 1, ['A', 'B']),\n        (1, 0, [0, 1])\n    ])\n    def test_xy_args_integer(self, x, y, colnames):\n        # GH 20056: tests integer args for xy and checks col names\n        df = DataFrame({\"A\": [1, 2], 'B': [3, 4]})\n        df.columns = colnames\n        _check_plot_works(df.plot, x=x, y=y)\n\n    @pytest.mark.slow\n    def test_hexbin_basic(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x='A', y='B', gridsize=10)\n        # TODO: need better way to test. This just does existence.\n        assert len(ax.collections) == 1\n\n        # GH 6951\n        axes = df.plot.hexbin(x='A', y='B', subplots=True)\n        # hexbin should have 2 axes in the figure, 1 for plotting and another\n        # is colorbar\n        assert len(axes[0].figure.axes) == 2\n        # return value is single axes\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n    @pytest.mark.slow\n    def test_hexbin_with_c(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x='A', y='B', C='C')\n        assert len(ax.collections) == 1\n\n        ax = df.plot.hexbin(x='A', y='B', C='C', reduce_C_function=np.std)\n        assert len(ax.collections) == 1\n\n    @pytest.mark.slow\n    def test_hexbin_cmap(self):\n        df = self.hexbin_df\n\n        # Default to BuGn\n        ax = df.plot.hexbin(x='A', y='B')\n        assert ax.collections[0].cmap.name == 'BuGn'\n\n        cm = 'cubehelix'\n        ax = df.plot.hexbin(x='A', y='B', colormap=cm)\n        assert ax.collections[0].cmap.name == cm\n\n    @pytest.mark.slow\n    def test_no_color_bar(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x='A', y='B', colorbar=None)\n        assert ax.collections[0].colorbar is None\n\n    @pytest.mark.slow\n    def test_allow_cmap(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x='A', y='B', cmap='YlGn')\n        assert ax.collections[0].cmap.name == 'YlGn'\n\n        with pytest.raises(TypeError):\n            df.plot.hexbin(x='A', y='B', cmap='YlGn', colormap='BuGn')\n\n    @pytest.mark.slow\n    def test_pie_df(self):\n        df = DataFrame(np.random.rand(5, 3), columns=['X', 'Y', 'Z'],\n                       index=['a', 'b', 'c', 'd', 'e'])\n        with pytest.raises(ValueError):\n            df.plot.pie()\n\n        ax = _check_plot_works(df.plot.pie, y='Y')\n        self._check_text_labels(ax.texts, df.index)\n\n        ax = _check_plot_works(df.plot.pie, y=2)\n        self._check_text_labels(ax.texts, df.index)\n\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot.pie,\n                                     subplots=True)\n        assert len(axes) == len(df.columns)\n        for ax in axes:\n            self._check_text_labels(ax.texts, df.index)\n        for ax, ylabel in zip(axes, df.columns):\n            assert ax.get_ylabel() == ylabel\n\n        labels = ['A', 'B', 'C', 'D', 'E']\n        color_args = ['r', 'g', 'b', 'c', 'm']\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.plot.pie,\n                                     subplots=True, labels=labels,\n                                     colors=color_args)\n        assert len(axes) == len(df.columns)\n\n        for ax in axes:\n            self._check_text_labels(ax.texts, labels)\n            self._check_colors(ax.patches, facecolors=color_args)\n\n    def test_pie_df_nan(self):\n        df = DataFrame(np.random.rand(4, 4))\n        for i in range(4):\n            df.iloc[i, i] = np.nan\n        fig, axes = self.plt.subplots(ncols=4)\n        df.plot.pie(subplots=True, ax=axes, legend=True)\n\n        base_expected = ['0', '1', '2', '3']\n        for i, ax in enumerate(axes):\n            expected = list(base_expected)  # force copy\n            expected[i] = ''\n            result = [x.get_text() for x in ax.texts]\n            assert result == expected\n            # legend labels\n            # NaN's not included in legend with subplots\n            # see https://github.com/pandas-dev/pandas/issues/8390\n            assert ([x.get_text() for x in ax.get_legend().get_texts()] ==\n                    base_expected[:i] + base_expected[i + 1:])\n\n    @pytest.mark.slow\n    def test_errorbar_plot(self):\n        with warnings.catch_warnings():\n            d = {'x': np.arange(12), 'y': np.arange(12, 0, -1)}\n            df = DataFrame(d)\n            d_err = {'x': np.ones(12) * 0.2, 'y': np.ones(12) * 0.4}\n            df_err = DataFrame(d_err)\n\n            # check line plots\n            ax = _check_plot_works(df.plot, yerr=df_err, logy=True)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n            ax = _check_plot_works(df.plot, yerr=df_err, logx=True, logy=True)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n            ax = _check_plot_works(df.plot, yerr=df_err, loglog=True)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n            kinds = ['line', 'bar', 'barh']\n            for kind in kinds:\n                ax = _check_plot_works(df.plot, yerr=df_err['x'], kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n                ax = _check_plot_works(df.plot, yerr=d_err, kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n                ax = _check_plot_works(df.plot, yerr=df_err, xerr=df_err,\n                                       kind=kind)\n                self._check_has_errorbars(ax, xerr=2, yerr=2)\n                ax = _check_plot_works(df.plot, yerr=df_err['x'],\n                                       xerr=df_err['x'],\n                                       kind=kind)\n                self._check_has_errorbars(ax, xerr=2, yerr=2)\n                ax = _check_plot_works(df.plot, xerr=0.2, yerr=0.2, kind=kind)\n                self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n                # _check_plot_works adds an ax so catch warning. see GH #13188\n                axes = _check_plot_works(df.plot,\n                                         yerr=df_err, xerr=df_err,\n                                         subplots=True,\n                                         kind=kind)\n                self._check_has_errorbars(axes, xerr=1, yerr=1)\n\n            ax = _check_plot_works((df + 1).plot, yerr=df_err,\n                                   xerr=df_err, kind='bar', log=True)\n            self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n            # yerr is raw error values\n            ax = _check_plot_works(df['y'].plot, yerr=np.ones(12) * 0.4)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(df.plot, yerr=np.ones((2, 12)) * 0.4)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n            # yerr is iterator\n            import itertools\n            ax = _check_plot_works(df.plot,\n                                   yerr=itertools.repeat(0.1, len(df)))\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n            # yerr is column name\n            for yerr in ['yerr', u('')]:\n                s_df = df.copy()\n                s_df[yerr] = np.ones(12) * 0.2\n                ax = _check_plot_works(s_df.plot, yerr=yerr)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n                ax = _check_plot_works(s_df.plot, y='y', x='x', yerr=yerr)\n                self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n            with pytest.raises(ValueError):\n                df.plot(yerr=np.random.randn(11))\n\n            df_err = DataFrame({'x': ['zzz'] * 12, 'y': ['zzz'] * 12})\n            with pytest.raises((ValueError, TypeError)):\n                df.plot(yerr=df_err)\n\n    @pytest.mark.slow\n    def test_errorbar_with_integer_column_names(self):\n        # test with integer column names\n        df = DataFrame(np.random.randn(10, 2))\n        df_err = DataFrame(np.random.randn(10, 2))\n        ax = _check_plot_works(df.plot, yerr=df_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n        ax = _check_plot_works(df.plot, y=0, yerr=1)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n    @pytest.mark.slow\n    def test_errorbar_with_partial_columns(self):\n        df = DataFrame(np.random.randn(10, 3))\n        df_err = DataFrame(np.random.randn(10, 2), columns=[0, 2])\n        kinds = ['line', 'bar']\n        for kind in kinds:\n            ax = _check_plot_works(df.plot, yerr=df_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ix = date_range('1/1/2000', periods=10, freq='M')\n        df.set_index(ix, inplace=True)\n        df_err.set_index(ix, inplace=True)\n        ax = _check_plot_works(df.plot, yerr=df_err, kind='line')\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        d = {'x': np.arange(12), 'y': np.arange(12, 0, -1)}\n        df = DataFrame(d)\n        d_err = {'x': np.ones(12) * 0.2, 'z': np.ones(12) * 0.4}\n        df_err = DataFrame(d_err)\n        for err in [d_err, df_err]:\n            ax = _check_plot_works(df.plot, yerr=err)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n    @pytest.mark.slow\n    def test_errorbar_timeseries(self):\n\n        with warnings.catch_warnings():\n            d = {'x': np.arange(12), 'y': np.arange(12, 0, -1)}\n            d_err = {'x': np.ones(12) * 0.2, 'y': np.ones(12) * 0.4}\n\n            # check time-series plots\n            ix = date_range('1/1/2000', '1/1/2001', freq='M')\n            tdf = DataFrame(d, index=ix)\n            tdf_err = DataFrame(d_err, index=ix)\n\n            kinds = ['line', 'bar', 'barh']\n            for kind in kinds:\n                ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n                ax = _check_plot_works(tdf.plot, yerr=d_err, kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n                ax = _check_plot_works(tdf.plot, y='y', yerr=tdf_err['x'],\n                                       kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=1)\n                ax = _check_plot_works(tdf.plot, y='y', yerr='x', kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=1)\n                ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)\n                self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n                # _check_plot_works adds an ax so catch warning. see GH #13188\n                axes = _check_plot_works(tdf.plot,\n                                         kind=kind, yerr=tdf_err,\n                                         subplots=True)\n                self._check_has_errorbars(axes, xerr=0, yerr=1)\n\n    def test_errorbar_asymmetrical(self):\n\n        np.random.seed(0)\n        err = np.random.rand(3, 2, 5)\n\n        # each column is [0, 1, 2, 3, 4], [3, 4, 5, 6, 7]...\n        df = DataFrame(np.arange(15).reshape(3, 5)).T\n\n        ax = df.plot(yerr=err, xerr=err / 2)\n\n        yerr_0_0 = ax.collections[1].get_paths()[0].vertices[:, 1]\n        expected_0_0 = err[0, :, 0] * np.array([-1, 1])\n        tm.assert_almost_equal(yerr_0_0, expected_0_0)\n\n        with pytest.raises(ValueError):\n            df.plot(yerr=err.T)\n\n        tm.close()\n\n    # This XPASSES when tested with mpl == 3.0.1\n    @td.xfail_if_mpl_2_2\n    def test_table(self):\n        df = DataFrame(np.random.rand(10, 3),\n                       index=list(string.ascii_letters[:10]))\n        _check_plot_works(df.plot, table=True)\n        _check_plot_works(df.plot, table=df)\n\n        ax = df.plot()\n        assert len(ax.tables) == 0\n        plotting.table(ax, df.T)\n        assert len(ax.tables) == 1\n\n    def test_errorbar_scatter(self):\n        df = DataFrame(\n            np.random.randn(5, 2), index=range(5), columns=['x', 'y'])\n        df_err = DataFrame(np.random.randn(5, 2) / 5,\n                           index=range(5), columns=['x', 'y'])\n\n        ax = _check_plot_works(df.plot.scatter, x='x', y='y')\n        self._check_has_errorbars(ax, xerr=0, yerr=0)\n        ax = _check_plot_works(df.plot.scatter, x='x', y='y', xerr=df_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=0)\n\n        ax = _check_plot_works(df.plot.scatter, x='x', y='y', yerr=df_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        ax = _check_plot_works(df.plot.scatter, x='x', y='y', xerr=df_err,\n                               yerr=df_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=1)\n\n        def _check_errorbar_color(containers, expected, has_err='has_xerr'):\n            lines = []\n            errs = [c.lines\n                    for c in ax.containers if getattr(c, has_err, False)][0]\n            for el in errs:\n                if is_list_like(el):\n                    lines.extend(el)\n                else:\n                    lines.append(el)\n            err_lines = [x for x in lines if x in ax.collections]\n            self._check_colors(\n                err_lines, linecolors=np.array([expected] * len(err_lines)))\n\n        # GH 8081\n        df = DataFrame(\n            np.random.randn(10, 5), columns=['a', 'b', 'c', 'd', 'e'])\n        ax = df.plot.scatter(x='a', y='b', xerr='d', yerr='e', c='red')\n        self._check_has_errorbars(ax, xerr=1, yerr=1)\n        _check_errorbar_color(ax.containers, 'red', has_err='has_xerr')\n        _check_errorbar_color(ax.containers, 'red', has_err='has_yerr')\n\n        ax = df.plot.scatter(x='a', y='b', yerr='e', color='green')\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        _check_errorbar_color(ax.containers, 'green', has_err='has_yerr')\n\n    @pytest.mark.slow\n    def test_sharex_and_ax(self):\n        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,\n        # the axis in fig.get_axis() are sorted differently than pandas\n        # expected them, so make sure that only the right ones are removed\n        import matplotlib.pyplot as plt\n        plt.close('all')\n        gs, axes = _generate_4_axes_via_gridspec()\n\n        df = DataFrame({\"a\": [1, 2, 3, 4, 5, 6],\n                        \"b\": [1, 2, 3, 4, 5, 6],\n                        \"c\": [1, 2, 3, 4, 5, 6],\n                        \"d\": [1, 2, 3, 4, 5, 6]})\n\n        def _check(axes):\n            for ax in axes:\n                assert len(ax.lines) == 1\n                self._check_visible(ax.get_yticklabels(), visible=True)\n            for ax in [axes[0], axes[2]]:\n                self._check_visible(ax.get_xticklabels(), visible=False)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=False)\n            for ax in [axes[1], axes[3]]:\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=True)\n\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax, sharex=True)\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharex=True)\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        # without sharex, no labels should be touched!\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax)\n\n        gs.tight_layout(plt.gcf())\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n    @pytest.mark.slow\n    def test_sharey_and_ax(self):\n        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,\n        # the axis in fig.get_axis() are sorted differently than pandas\n        # expected them, so make sure that only the right ones are removed\n        import matplotlib.pyplot as plt\n\n        gs, axes = _generate_4_axes_via_gridspec()\n\n        df = DataFrame({\"a\": [1, 2, 3, 4, 5, 6],\n                        \"b\": [1, 2, 3, 4, 5, 6],\n                        \"c\": [1, 2, 3, 4, 5, 6],\n                        \"d\": [1, 2, 3, 4, 5, 6]})\n\n        def _check(axes):\n            for ax in axes:\n                assert len(ax.lines) == 1\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=True)\n            for ax in [axes[0], axes[1]]:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n            for ax in [axes[2], axes[3]]:\n                self._check_visible(ax.get_yticklabels(), visible=False)\n\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax, sharey=True)\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharey=True)\n\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        # without sharex, no labels should be touched!\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax)\n\n        gs.tight_layout(plt.gcf())\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n\n    def test_memory_leak(self):\n        \"\"\" Check that every plot type gets properly collected. \"\"\"\n        import weakref\n        import gc\n\n        results = {}\n        for kind in plotting._core._plot_klass.keys():\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            args = {}\n            if kind in ['hexbin', 'scatter', 'pie']:\n                df = self.hexbin_df\n                args = {'x': 'A', 'y': 'B'}\n            elif kind == 'area':\n                df = self.tdf.abs()\n            else:\n                df = self.tdf\n\n            # Use a weakref so we can see if the object gets collected without\n            # also preventing it from being collected\n            results[kind] = weakref.proxy(df.plot(kind=kind, **args))\n\n        # have matplotlib delete all the figures\n        tm.close()\n        # force a garbage collection\n        gc.collect()\n        for key in results:\n            # check that every plot was collected\n            with pytest.raises(ReferenceError):\n                # need to actually access something to get an error\n                results[key].lines\n\n    @pytest.mark.slow\n    def test_df_subplots_patterns_minorticks(self):\n        # GH 10657\n        import matplotlib.pyplot as plt\n\n        df = DataFrame(np.random.randn(10, 2),\n                       index=date_range('1/1/2000', periods=10),\n                       columns=list('AB'))\n\n        # shared subplots\n        fig, axes = plt.subplots(2, 1, sharex=True)\n        axes = df.plot(subplots=True, ax=axes)\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        # xaxis of 1st ax must be hidden\n        self._check_visible(axes[0].get_xticklabels(), visible=False)\n        self._check_visible(axes[0].get_xticklabels(minor=True), visible=False)\n        self._check_visible(axes[1].get_xticklabels(), visible=True)\n        self._check_visible(axes[1].get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        fig, axes = plt.subplots(2, 1)\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharex=True)\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        # xaxis of 1st ax must be hidden\n        self._check_visible(axes[0].get_xticklabels(), visible=False)\n        self._check_visible(axes[0].get_xticklabels(minor=True), visible=False)\n        self._check_visible(axes[1].get_xticklabels(), visible=True)\n        self._check_visible(axes[1].get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # not shared\n        fig, axes = plt.subplots(2, 1)\n        axes = df.plot(subplots=True, ax=axes)\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n    @pytest.mark.slow\n    def test_df_gridspec_patterns(self):\n        # GH 10819\n        import matplotlib.pyplot as plt\n        import matplotlib.gridspec as gridspec\n\n        ts = Series(np.random.randn(10),\n                    index=date_range('1/1/2000', periods=10))\n\n        df = DataFrame(np.random.randn(10, 2), index=ts.index,\n                       columns=list('AB'))\n\n        def _get_vertical_grid():\n            gs = gridspec.GridSpec(3, 1)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:2, :])\n            ax2 = fig.add_subplot(gs[2, :])\n            return ax1, ax2\n\n        def _get_horizontal_grid():\n            gs = gridspec.GridSpec(1, 3)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:, :2])\n            ax2 = fig.add_subplot(gs[:, 2])\n            return ax1, ax2\n\n        for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:\n            ax1 = ts.plot(ax=ax1)\n            assert len(ax1.lines) == 1\n            ax2 = df.plot(ax=ax2)\n            assert len(ax2.lines) == 2\n            for ax in [ax1, ax2]:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=True)\n            tm.close()\n\n        # subplots=True\n        for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:\n            axes = df.plot(subplots=True, ax=[ax1, ax2])\n            assert len(ax1.lines) == 1\n            assert len(ax2.lines) == 1\n            for ax in axes:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(\n                    ax.get_xticklabels(minor=True), visible=True)\n            tm.close()\n\n        # vertical / subplots / sharex=True / sharey=True\n        ax1, ax2 = _get_vertical_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True,\n                           sharey=True)\n        assert len(axes[0].lines) == 1\n        assert len(axes[1].lines) == 1\n        for ax in [ax1, ax2]:\n            # yaxis are visible because there is only one column\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        # xaxis of axes0 (top) are hidden\n        self._check_visible(axes[0].get_xticklabels(), visible=False)\n        self._check_visible(axes[0].get_xticklabels(minor=True), visible=False)\n        self._check_visible(axes[1].get_xticklabels(), visible=True)\n        self._check_visible(axes[1].get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # horizontal / subplots / sharex=True / sharey=True\n        ax1, ax2 = _get_horizontal_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True,\n                           sharey=True)\n        assert len(axes[0].lines) == 1\n        assert len(axes[1].lines) == 1\n        self._check_visible(axes[0].get_yticklabels(), visible=True)\n        # yaxis of axes1 (right) are hidden\n        self._check_visible(axes[1].get_yticklabels(), visible=False)\n        for ax in [ax1, ax2]:\n            # xaxis are visible because there is only one column\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # boxed\n        def _get_boxed_grid():\n            gs = gridspec.GridSpec(3, 3)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:2, :2])\n            ax2 = fig.add_subplot(gs[:2, 2])\n            ax3 = fig.add_subplot(gs[2, :2])\n            ax4 = fig.add_subplot(gs[2, 2])\n            return ax1, ax2, ax3, ax4\n\n        axes = _get_boxed_grid()\n        df = DataFrame(np.random.randn(10, 4),\n                       index=ts.index, columns=list('ABCD'))\n        axes = df.plot(subplots=True, ax=axes)\n        for ax in axes:\n            assert len(ax.lines) == 1\n            # axis are visible because these are not shared\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # subplots / sharex=True / sharey=True\n        axes = _get_boxed_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharex=True, sharey=True)\n        for ax in axes:\n            assert len(ax.lines) == 1\n        for ax in [axes[0], axes[2]]:  # left column\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        for ax in [axes[1], axes[3]]:  # right column\n            self._check_visible(ax.get_yticklabels(), visible=False)\n        for ax in [axes[0], axes[1]]:  # top row\n            self._check_visible(ax.get_xticklabels(), visible=False)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=False)\n        for ax in [axes[2], axes[3]]:  # bottom row\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n    @pytest.mark.slow\n    def test_df_grid_settings(self):\n        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792\n        self._check_grid_settings(\n            DataFrame({'a': [1, 2, 3], 'b': [2, 3, 4]}),\n            plotting._core._dataframe_kinds, kws={'x': 'a', 'y': 'b'})\n\n    def test_invalid_colormap(self):\n        df = DataFrame(randn(3, 2), columns=['A', 'B'])\n\n        with pytest.raises(ValueError):\n            df.plot(colormap='invalid_colormap')\n\n    def test_plain_axes(self):\n\n        # supplied ax itself is a SubplotAxes, but figure contains also\n        # a plain Axes object (GH11556)\n        fig, ax = self.plt.subplots()\n        fig.add_axes([0.2, 0.2, 0.2, 0.2])\n        Series(rand(10)).plot(ax=ax)\n\n        # suppliad ax itself is a plain Axes, but because the cmap keyword\n        # a new ax is created for the colorbar -> also multiples axes (GH11520)\n        df = DataFrame({'a': randn(8), 'b': randn(8)})\n        fig = self.plt.figure()\n        ax = fig.add_axes((0, 0, 1, 1))\n        df.plot(kind='scatter', ax=ax, x='a', y='b', c='a', cmap='hsv')\n\n        # other examples\n        fig, ax = self.plt.subplots()\n        from mpl_toolkits.axes_grid1 import make_axes_locatable\n        divider = make_axes_locatable(ax)\n        cax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        Series(rand(10)).plot(ax=ax)\n        Series(rand(10)).plot(ax=cax)\n\n        fig, ax = self.plt.subplots()\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n        iax = inset_axes(ax, width=\"30%\", height=1., loc=3)\n        Series(rand(10)).plot(ax=ax)\n        Series(rand(10)).plot(ax=iax)\n\n    def test_passed_bar_colors(self):\n        import matplotlib as mpl\n        color_tuples = [(0.9, 0, 0, 1), (0, 0.9, 0, 1), (0, 0, 0.9, 1)]\n        colormap = mpl.colors.ListedColormap(color_tuples)\n        barplot = pd.DataFrame([[1, 2, 3]]).plot(kind=\"bar\", cmap=colormap)\n        assert color_tuples == [c.get_facecolor() for c in barplot.patches]\n\n    def test_rcParams_bar_colors(self):\n        import matplotlib as mpl\n        color_tuples = [(0.9, 0, 0, 1), (0, 0.9, 0, 1), (0, 0, 0.9, 1)]\n        with mpl.rc_context(\n                rc={'axes.prop_cycle': mpl.cycler(\"color\", color_tuples)}):\n            barplot = pd.DataFrame([[1, 2, 3]]).plot(kind=\"bar\")\n        assert color_tuples == [c.get_facecolor() for c in barplot.patches]\n\n    @pytest.mark.parametrize('method', ['line', 'barh', 'bar'])\n    def test_secondary_axis_font_size(self, method):\n        # GH: 12565\n        df = (pd.DataFrame(np.random.randn(15, 2),\n                           columns=list('AB'))\n              .assign(C=lambda df: df.B.cumsum())\n              .assign(D=lambda df: df.C * 1.1))\n\n        fontsize = 20\n        sy = ['C', 'D']\n\n        kwargs = dict(secondary_y=sy, fontsize=fontsize,\n                      mark_right=True)\n        ax = getattr(df.plot, method)(**kwargs)\n        self._check_ticks_props(axes=ax.right_ax,\n                                ylabelsize=fontsize)\n\n\ndef _generate_4_axes_via_gridspec():\n    import matplotlib.pyplot as plt\n    import matplotlib as mpl\n    import matplotlib.gridspec  # noqa\n\n    gs = mpl.gridspec.GridSpec(2, 2)\n    ax_tl = plt.subplot(gs[0, 0])\n    ax_ll = plt.subplot(gs[1, 0])\n    ax_tr = plt.subplot(gs[0, 1])\n    ax_lr = plt.subplot(gs[1, 1])\n\n    return gs, [ax_tl, ax_ll, ax_tr, ax_lr]\n"
    },
    {
      "filename": "pandas/tests/plotting/test_series.py",
      "content": "# coding: utf-8\n\n\"\"\" Test cases for Series.plot \"\"\"\n\n\nfrom datetime import datetime\nfrom itertools import chain\n\nimport numpy as np\nfrom numpy.random import randn\nimport pytest\n\nfrom pandas.compat import lrange, range\nimport pandas.util._test_decorators as td\n\nimport pandas as pd\nfrom pandas import DataFrame, Series, date_range\nfrom pandas.tests.plotting.common import (\n    TestPlotBase, _check_plot_works, _ok_for_gaussian_kde,\n    _skip_if_no_scipy_gaussian_kde)\nimport pandas.util.testing as tm\n\nimport pandas.plotting as plotting\n\n\n@td.skip_if_no_mpl\nclass TestSeriesPlots(TestPlotBase):\n\n    def setup_method(self, method):\n        TestPlotBase.setup_method(self, method)\n        import matplotlib as mpl\n        mpl.rcdefaults()\n\n        self.ts = tm.makeTimeSeries()\n        self.ts.name = 'ts'\n\n        self.series = tm.makeStringSeries()\n        self.series.name = 'series'\n\n        self.iseries = tm.makePeriodSeries()\n        self.iseries.name = 'iseries'\n\n    @pytest.mark.slow\n    def test_plot(self):\n        _check_plot_works(self.ts.plot, label='foo')\n        _check_plot_works(self.ts.plot, use_index=False)\n        axes = _check_plot_works(self.ts.plot, rot=0)\n        self._check_ticks_props(axes, xrot=0)\n\n        ax = _check_plot_works(self.ts.plot, style='.', logy=True)\n        self._check_ax_scales(ax, yaxis='log')\n\n        ax = _check_plot_works(self.ts.plot, style='.', logx=True)\n        self._check_ax_scales(ax, xaxis='log')\n\n        ax = _check_plot_works(self.ts.plot, style='.', loglog=True)\n        self._check_ax_scales(ax, xaxis='log', yaxis='log')\n\n        _check_plot_works(self.ts[:10].plot.bar)\n        _check_plot_works(self.ts.plot.area, stacked=False)\n        _check_plot_works(self.iseries.plot)\n\n        for kind in ['line', 'bar', 'barh', 'kde', 'hist', 'box']:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            _check_plot_works(self.series[:5].plot, kind=kind)\n\n        _check_plot_works(self.series[:10].plot.barh)\n        ax = _check_plot_works(Series(randn(10)).plot.bar, color='black')\n        self._check_colors([ax.patches[0]], facecolors=['black'])\n\n        # GH 6951\n        ax = _check_plot_works(self.ts.plot, subplots=True)\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))\n\n        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(-1, 1))\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))\n        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(1, -1))\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))\n\n    @pytest.mark.slow\n    def test_plot_figsize_and_title(self):\n        # figsize and title\n        _, ax = self.plt.subplots()\n        ax = self.series.plot(title='Test', figsize=(16, 8), ax=ax)\n        self._check_text_labels(ax.title, 'Test')\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16, 8))\n\n    def test_dont_modify_rcParams(self):\n        # GH 8242\n        key = 'axes.prop_cycle'\n        colors = self.plt.rcParams[key]\n        _, ax = self.plt.subplots()\n        Series([1, 2, 3]).plot(ax=ax)\n        assert colors == self.plt.rcParams[key]\n\n    def test_ts_line_lim(self):\n        fig, ax = self.plt.subplots()\n        ax = self.ts.plot(ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data(orig=False)[0][0]\n        assert xmax >= lines[0].get_data(orig=False)[0][-1]\n        tm.close()\n\n        ax = self.ts.plot(secondary_y=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data(orig=False)[0][0]\n        assert xmax >= lines[0].get_data(orig=False)[0][-1]\n\n    def test_ts_area_lim(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.area(stacked=False, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        # GH 7471\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.area(stacked=False, x_compat=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        tz_ts = self.ts.copy()\n        tz_ts.index = tz_ts.tz_localize('GMT').tz_convert('CET')\n        _, ax = self.plt.subplots()\n        ax = tz_ts.plot.area(stacked=False, x_compat=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = tz_ts.plot.area(stacked=False, secondary_y=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n\n    def test_label(self):\n        s = Series([1, 2])\n        _, ax = self.plt.subplots()\n        ax = s.plot(label='LABEL', legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=['LABEL'])\n        self.plt.close()\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=['None'])\n        self.plt.close()\n        # get name from index\n        s.name = 'NAME'\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=['NAME'])\n        self.plt.close()\n        # override the default\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, label='LABEL', ax=ax)\n        self._check_legend_labels(ax, labels=['LABEL'])\n        self.plt.close()\n        # Add lebel info, but don't draw\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=False, label='LABEL', ax=ax)\n        assert ax.get_legend() is None  # Hasn't been drawn\n        ax.legend()  # draw it\n        self._check_legend_labels(ax, labels=['LABEL'])\n\n    def test_line_area_nan_series(self):\n        values = [1, 2, np.nan, 3]\n        s = Series(values)\n        ts = Series(values, index=tm.makeDateIndex(k=4))\n\n        for d in [s, ts]:\n            ax = _check_plot_works(d.plot)\n            masked = ax.lines[0].get_ydata()\n            # remove nan for comparison purpose\n            exp = np.array([1, 2, 3], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked.data, 2), exp)\n            tm.assert_numpy_array_equal(\n                masked.mask, np.array([False, False, True, False]))\n\n            expected = np.array([1, 2, 0, 3], dtype=np.float64)\n            ax = _check_plot_works(d.plot, stacked=True)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)\n            ax = _check_plot_works(d.plot.area)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)\n            ax = _check_plot_works(d.plot.area, stacked=False)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)\n\n    def test_line_use_index_false(self):\n        s = Series([1, 2, 3], index=['a', 'b', 'c'])\n        s.index.name = 'The Index'\n        _, ax = self.plt.subplots()\n        ax = s.plot(use_index=False, ax=ax)\n        label = ax.get_xlabel()\n        assert label == ''\n        _, ax = self.plt.subplots()\n        ax2 = s.plot.bar(use_index=False, ax=ax)\n        label2 = ax2.get_xlabel()\n        assert label2 == ''\n\n    @pytest.mark.slow\n    def test_bar_log(self):\n        expected = np.array([1e-1, 1e0, 1e1, 1e2, 1e3, 1e4])\n\n        _, ax = self.plt.subplots()\n        ax = Series([200, 500]).plot.bar(log=True, ax=ax)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = Series([200, 500]).plot.barh(log=True, ax=ax)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)\n        tm.close()\n\n        # GH 9905\n        expected = np.array([1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1])\n\n        _, ax = self.plt.subplots()\n        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='bar', ax=ax)\n        ymin = 0.0007943282347242822\n        ymax = 0.12589254117941673\n        res = ax.get_ylim()\n        tm.assert_almost_equal(res[0], ymin)\n        tm.assert_almost_equal(res[1], ymax)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='barh', ax=ax)\n        res = ax.get_xlim()\n        tm.assert_almost_equal(res[0], ymin)\n        tm.assert_almost_equal(res[1], ymax)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)\n\n    @pytest.mark.slow\n    def test_bar_ignore_index(self):\n        df = Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])\n        _, ax = self.plt.subplots()\n        ax = df.plot.bar(use_index=False, ax=ax)\n        self._check_text_labels(ax.get_xticklabels(), ['0', '1', '2', '3'])\n\n    def test_bar_user_colors(self):\n        s = Series([1, 2, 3, 4])\n        ax = s.plot.bar(color=['red', 'blue', 'blue', 'red'])\n        result = [p.get_facecolor() for p in ax.patches]\n        expected = [(1., 0., 0., 1.),\n                    (0., 0., 1., 1.),\n                    (0., 0., 1., 1.),\n                    (1., 0., 0., 1.)]\n        assert result == expected\n\n    def test_rotation(self):\n        df = DataFrame(randn(5, 5))\n        # Default rot 0\n        _, ax = self.plt.subplots()\n        axes = df.plot(ax=ax)\n        self._check_ticks_props(axes, xrot=0)\n\n        _, ax = self.plt.subplots()\n        axes = df.plot(rot=30, ax=ax)\n        self._check_ticks_props(axes, xrot=30)\n\n    def test_irregular_datetime(self):\n        rng = date_range('1/1/2000', '3/1/2000')\n        rng = rng[[0, 1, 2, 3, 5, 9, 10, 11, 12]]\n        ser = Series(randn(len(rng)), rng)\n        _, ax = self.plt.subplots()\n        ax = ser.plot(ax=ax)\n        xp = datetime(1999, 1, 1).toordinal()\n        ax.set_xlim('1/1/1999', '1/1/2001')\n        assert xp == ax.get_xlim()[0]\n\n    def test_unsorted_index_xlim(self):\n        ser = Series([0., 1., np.nan, 3., 4., 5., 6.],\n                     index=[1., 0., 3., 2., np.nan, 3., 2.])\n        _, ax = self.plt.subplots()\n        ax = ser.plot(ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data(orig=False)[0])\n        assert xmax >= np.nanmax(lines[0].get_data(orig=False)[0])\n\n    @pytest.mark.slow\n    def test_pie_series(self):\n        # if sum of values is less than 1.0, pie handle them as rate and draw\n        # semicircle.\n        series = Series(np.random.randint(1, 5),\n                        index=['a', 'b', 'c', 'd', 'e'], name='YLABEL')\n        ax = _check_plot_works(series.plot.pie)\n        self._check_text_labels(ax.texts, series.index)\n        assert ax.get_ylabel() == 'YLABEL'\n\n        # without wedge labels\n        ax = _check_plot_works(series.plot.pie, labels=None)\n        self._check_text_labels(ax.texts, [''] * 5)\n\n        # with less colors than elements\n        color_args = ['r', 'g', 'b']\n        ax = _check_plot_works(series.plot.pie, colors=color_args)\n\n        color_expected = ['r', 'g', 'b', 'r', 'g']\n        self._check_colors(ax.patches, facecolors=color_expected)\n\n        # with labels and colors\n        labels = ['A', 'B', 'C', 'D', 'E']\n        color_args = ['r', 'g', 'b', 'c', 'm']\n        ax = _check_plot_works(series.plot.pie, labels=labels,\n                               colors=color_args)\n        self._check_text_labels(ax.texts, labels)\n        self._check_colors(ax.patches, facecolors=color_args)\n\n        # with autopct and fontsize\n        ax = _check_plot_works(series.plot.pie, colors=color_args,\n                               autopct='%.2f', fontsize=7)\n        pcts = ['{0:.2f}'.format(s * 100)\n                for s in series.values / float(series.sum())]\n        expected_texts = list(chain.from_iterable(zip(series.index, pcts)))\n        self._check_text_labels(ax.texts, expected_texts)\n        for t in ax.texts:\n            assert t.get_fontsize() == 7\n\n        # includes negative value\n        with pytest.raises(ValueError):\n            series = Series([1, 2, 0, 4, -1], index=['a', 'b', 'c', 'd', 'e'])\n            series.plot.pie()\n\n        # includes nan\n        series = Series([1, 2, np.nan, 4], index=['a', 'b', 'c', 'd'],\n                        name='YLABEL')\n        ax = _check_plot_works(series.plot.pie)\n        self._check_text_labels(ax.texts, ['a', 'b', '', 'd'])\n\n    def test_pie_nan(self):\n        s = Series([1, np.nan, 1, 1])\n        _, ax = self.plt.subplots()\n        ax = s.plot.pie(legend=True, ax=ax)\n        expected = ['0', '', '2', '3']\n        result = [x.get_text() for x in ax.texts]\n        assert result == expected\n\n    @pytest.mark.slow\n    def test_hist_df_kwargs(self):\n        df = DataFrame(np.random.randn(10, 2))\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 10\n\n    @pytest.mark.slow\n    def test_hist_df_with_nonnumerics(self):\n        # GH 9853\n        with tm.RNGContext(1):\n            df = DataFrame(\n                np.random.randn(10, 4), columns=['A', 'B', 'C', 'D'])\n        df['E'] = ['x', 'y'] * 5\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 20\n\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(ax=ax)  # bins=10\n        assert len(ax.patches) == 40\n\n    @pytest.mark.slow\n    def test_hist_legacy(self):\n        _check_plot_works(self.ts.hist)\n        _check_plot_works(self.ts.hist, grid=False)\n        _check_plot_works(self.ts.hist, figsize=(8, 10))\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(self.ts.hist,\n                              by=self.ts.index.month)\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(self.ts.hist,\n                              by=self.ts.index.month, bins=5)\n\n        fig, ax = self.plt.subplots(1, 1)\n        _check_plot_works(self.ts.hist, ax=ax)\n        _check_plot_works(self.ts.hist, ax=ax, figure=fig)\n        _check_plot_works(self.ts.hist, figure=fig)\n        tm.close()\n\n        fig, (ax1, ax2) = self.plt.subplots(1, 2)\n        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)\n        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)\n\n        with pytest.raises(ValueError):\n            self.ts.hist(by=self.ts.index, figure=fig)\n\n    @pytest.mark.slow\n    def test_hist_bins_legacy(self):\n        df = DataFrame(np.random.randn(10, 2))\n        ax = df.hist(bins=2)[0][0]\n        assert len(ax.patches) == 2\n\n    @pytest.mark.slow\n    def test_hist_layout(self):\n        df = self.hist_df\n        with pytest.raises(ValueError):\n            df.height.hist(layout=(1, 1))\n\n        with pytest.raises(ValueError):\n            df.height.hist(layout=[1, 1])\n\n    @pytest.mark.slow\n    def test_hist_layout_with_by(self):\n        df = self.hist_df\n\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.gender, layout=(2, 1))\n        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.gender, layout=(3, -1))\n        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.category, layout=(4, 1))\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.category, layout=(2, -1))\n        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.category, layout=(3, -1))\n        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.category, layout=(-1, 4))\n        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist,\n                                     by=df.classroom, layout=(2, 2))\n        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))\n\n        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 2),\n                               figsize=(12, 7))\n\n    @pytest.mark.slow\n    def test_hist_no_overlap(self):\n        from matplotlib.pyplot import subplot, gcf\n        x = Series(randn(2))\n        y = Series(randn(2))\n        subplot(121)\n        x.hist()\n        subplot(122)\n        y.hist()\n        fig = gcf()\n        axes = fig.axes\n        assert len(axes) == 2\n\n    @pytest.mark.slow\n    def test_hist_secondary_legend(self):\n        # GH 9610\n        df = DataFrame(np.random.randn(30, 4), columns=list('abcd'))\n\n        # primary -> secondary\n        _, ax = self.plt.subplots()\n        ax = df['a'].plot.hist(legend=True, ax=ax)\n        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=['a', 'b (right)'])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary\n        _, ax = self.plt.subplots()\n        ax = df['a'].plot.hist(legend=True, secondary_y=True, ax=ax)\n        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)\n        # both legends are draw on left ax\n        # left axis must be invisible, right axis must be visible\n        self._check_legend_labels(ax.left_ax,\n                                  labels=['a (right)', 'b (right)'])\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> primary\n        _, ax = self.plt.subplots()\n        ax = df['a'].plot.hist(legend=True, secondary_y=True, ax=ax)\n        # right axes is returned\n        df['b'].plot.hist(ax=ax, legend=True)\n        # both legends are draw on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax.left_ax, labels=['a (right)', 'b'])\n        assert ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n    @pytest.mark.slow\n    def test_df_series_secondary_legend(self):\n        # GH 9779\n        df = DataFrame(np.random.randn(30, 3), columns=list('abc'))\n        s = Series(np.random.randn(30), name='x')\n\n        # primary -> secondary (without passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(ax=ax)\n        s.plot(legend=True, secondary_y=True, ax=ax)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # primary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # seconcary -> secondary (without passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, ax=ax)\n        s.plot(legend=True, secondary_y=True, ax=ax)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']\n        self._check_legend_labels(ax.left_ax, labels=expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']\n        self._check_legend_labels(ax.left_ax, expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, mark_right=False, ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = ['a', 'b', 'c', 'x (right)']\n        self._check_legend_labels(ax.left_ax, expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n    @pytest.mark.slow\n    def test_plot_fails_with_dupe_color_and_style(self):\n        x = Series(randn(2))\n        with pytest.raises(ValueError):\n            _, ax = self.plt.subplots()\n            x.plot(style='k--', color='k', ax=ax)\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_hist_kde(self):\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        xlabels = ax.get_xticklabels()\n        # ticks are values, thus ticklabels are blank\n        self._check_text_labels(xlabels, [''] * len(xlabels))\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [''] * len(ylabels))\n\n        _skip_if_no_scipy_gaussian_kde()\n        _check_plot_works(self.ts.plot.kde)\n        _check_plot_works(self.ts.plot.density)\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        xlabels = ax.get_xticklabels()\n        self._check_text_labels(xlabels, [''] * len(xlabels))\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [''] * len(ylabels))\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_kwargs(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        sample_points = np.linspace(-100, 100, 20)\n        _check_plot_works(self.ts.plot.kde, bw_method='scott', ind=20)\n        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=20)\n        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=np.int(20))\n        _check_plot_works(self.ts.plot.kde, bw_method=.5, ind=sample_points)\n        _check_plot_works(self.ts.plot.density, bw_method=.5,\n                          ind=sample_points)\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, bw_method=.5, ind=sample_points,\n                              ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        self._check_text_labels(ax.yaxis.get_label(), 'Density')\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_missing_vals(self):\n        _skip_if_no_scipy_gaussian_kde()\n\n        s = Series(np.random.uniform(size=50))\n        s[0] = np.nan\n        axes = _check_plot_works(s.plot.kde)\n\n        # gh-14821: check if the values have any missing values\n        assert any(~np.isnan(axes.lines[0].get_xdata()))\n\n    @pytest.mark.slow\n    def test_hist_kwargs(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 5\n        self._check_text_labels(ax.yaxis.get_label(), 'Frequency')\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(orientation='horizontal', ax=ax)\n        self._check_text_labels(ax.xaxis.get_label(), 'Frequency')\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(align='left', stacked=True, ax=ax)\n        tm.close()\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_hist_kde_color(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(logy=True, bins=10, color='b', ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        assert len(ax.patches) == 10\n        self._check_colors(ax.patches, facecolors=['b'] * 10)\n\n        _skip_if_no_scipy_gaussian_kde()\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, color='r', ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        lines = ax.get_lines()\n        assert len(lines) == 1\n        self._check_colors(lines, ['r'])\n\n    @pytest.mark.slow\n    def test_boxplot_series(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.box(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis='log')\n        xlabels = ax.get_xticklabels()\n        self._check_text_labels(xlabels, [self.ts.name])\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [''] * len(ylabels))\n\n    @pytest.mark.slow\n    def test_kind_both_ways(self):\n        s = Series(range(3))\n        kinds = (plotting._core._common_kinds +\n                 plotting._core._series_kinds)\n        _, ax = self.plt.subplots()\n        for kind in kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            s.plot(kind=kind, ax=ax)\n            getattr(s.plot, kind)()\n\n    @pytest.mark.slow\n    def test_invalid_plot_data(self):\n        s = Series(list('abcd'))\n        _, ax = self.plt.subplots()\n        for kind in plotting._core._common_kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            with pytest.raises(TypeError):\n                s.plot(kind=kind, ax=ax)\n\n    @pytest.mark.slow\n    def test_valid_object_plot(self):\n        s = Series(lrange(10), dtype=object)\n        for kind in plotting._core._common_kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            _check_plot_works(s.plot, kind=kind)\n\n    def test_partially_invalid_plot_data(self):\n        s = Series(['a', 'b', 1.0, 2])\n        _, ax = self.plt.subplots()\n        for kind in plotting._core._common_kinds:\n            if not _ok_for_gaussian_kde(kind):\n                continue\n            with pytest.raises(TypeError):\n                s.plot(kind=kind, ax=ax)\n\n    def test_invalid_kind(self):\n        s = Series([1, 2])\n        with pytest.raises(ValueError):\n            s.plot(kind='aasdf')\n\n    @pytest.mark.slow\n    def test_dup_datetime_index_plot(self):\n        dr1 = date_range('1/1/2009', periods=4)\n        dr2 = date_range('1/2/2009', periods=4)\n        index = dr1.append(dr2)\n        values = randn(index.size)\n        s = Series(values, index=index)\n        _check_plot_works(s.plot)\n\n    @pytest.mark.slow\n    def test_errorbar_plot(self):\n\n        s = Series(np.arange(10), name='x')\n        s_err = np.random.randn(10)\n        d_err = DataFrame(randn(10, 2), index=s.index, columns=['x', 'y'])\n        # test line and bar plots\n        kinds = ['line', 'bar']\n        for kind in kinds:\n            ax = _check_plot_works(s.plot, yerr=Series(s_err), kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=s_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=s_err.tolist(), kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=d_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, xerr=0.2, yerr=0.2, kind=kind)\n            self._check_has_errorbars(ax, xerr=1, yerr=1)\n\n        ax = _check_plot_works(s.plot, xerr=s_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=0)\n\n        # test time series plotting\n        ix = date_range('1/1/2000', '1/1/2001', freq='M')\n        ts = Series(np.arange(12), index=ix, name='x')\n        ts_err = Series(np.random.randn(12), index=ix)\n        td_err = DataFrame(randn(12, 2), index=ix, columns=['x', 'y'])\n\n        ax = _check_plot_works(ts.plot, yerr=ts_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        ax = _check_plot_works(ts.plot, yerr=td_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        # check incorrect lengths and types\n        with pytest.raises(ValueError):\n            s.plot(yerr=np.arange(11))\n\n        s_err = ['zzz'] * 10\n        # MPL > 2.0.0 will most likely use TypeError here\n        with pytest.raises((TypeError, ValueError)):\n            s.plot(yerr=s_err)\n\n    # This XPASSES when tested with mpl == 3.0.1\n    @td.xfail_if_mpl_2_2\n    def test_table(self):\n        _check_plot_works(self.series.plot, table=True)\n        _check_plot_works(self.series.plot, table=self.series)\n\n    @pytest.mark.slow\n    def test_series_grid_settings(self):\n        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792\n        self._check_grid_settings(Series([1, 2, 3]),\n                                  plotting._core._series_kinds +\n                                  plotting._core._common_kinds)\n\n    @pytest.mark.slow\n    def test_standard_colors(self):\n        from pandas.plotting._style import _get_standard_colors\n\n        for c in ['r', 'red', 'green', '#FF0000']:\n            result = _get_standard_colors(1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(3, color=[c])\n            assert result == [c] * 3\n\n    @pytest.mark.slow\n    def test_standard_colors_all(self):\n        import matplotlib.colors as colors\n        from pandas.plotting._style import _get_standard_colors\n\n        # multiple colors like mediumaquamarine\n        for c in colors.cnames:\n            result = _get_standard_colors(num_colors=1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(num_colors=3, color=[c])\n            assert result == [c] * 3\n\n        # single letter colors like k\n        for c in colors.ColorConverter.colors:\n            result = _get_standard_colors(num_colors=1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(num_colors=3, color=[c])\n            assert result == [c] * 3\n\n    def test_series_plot_color_kwargs(self):\n        # GH1890\n        _, ax = self.plt.subplots()\n        ax = Series(np.arange(12) + 1).plot(color='green', ax=ax)\n        self._check_colors(ax.get_lines(), linecolors=['green'])\n\n    def test_time_series_plot_color_kwargs(self):\n        # #1890\n        _, ax = self.plt.subplots()\n        ax = Series(np.arange(12) + 1, index=date_range(\n            '1/1/2000', periods=12)).plot(color='green', ax=ax)\n        self._check_colors(ax.get_lines(), linecolors=['green'])\n\n    def test_time_series_plot_color_with_empty_kwargs(self):\n        import matplotlib as mpl\n\n        def_colors = self._unpack_cycler(mpl.rcParams)\n        index = date_range('1/1/2000', periods=12)\n        s = Series(np.arange(1, 13), index=index)\n\n        ncolors = 3\n\n        _, ax = self.plt.subplots()\n        for i in range(ncolors):\n            ax = s.plot(ax=ax)\n        self._check_colors(ax.get_lines(), linecolors=def_colors[:ncolors])\n\n    def test_xticklabels(self):\n        # GH11529\n        s = Series(np.arange(10), index=['P%02d' % i for i in range(10)])\n        _, ax = self.plt.subplots()\n        ax = s.plot(xticks=[0, 3, 5, 9], ax=ax)\n        exp = ['P%02d' % i for i in [0, 3, 5, 9]]\n        self._check_text_labels(ax.get_xticklabels(), exp)\n\n    def test_custom_business_day_freq(self):\n        # GH7222\n        from pandas.tseries.offsets import CustomBusinessDay\n        s = Series(range(100, 121), index=pd.bdate_range(\n            start='2014-05-01', end='2014-06-01',\n            freq=CustomBusinessDay(holidays=['2014-05-26'])))\n\n        _check_plot_works(s.plot)\n\n    @pytest.mark.xfail\n    def test_plot_accessor_updates_on_inplace(self):\n        s = Series([1, 2, 3, 4])\n        _, ax = self.plt.subplots()\n        ax = s.plot(ax=ax)\n        before = ax.xaxis.get_ticklocs()\n\n        s.drop([0, 1], inplace=True)\n        _, ax = self.plt.subplots()\n        after = ax.xaxis.get_ticklocs()\n        tm.assert_numpy_array_equal(before, after)\n"
    }
  ],
  "questions": [
    "absolutely let's do that. any others?\n\n `bootstrap`, `autocorrelation`, `lag` for statsmodels?\n\ncc @jseabold\ncc @josef-pkt",
    "I agree with @shoyer. These plotting methods are rather 'neglected' lately. I think we should either choose to give them more attention, or deprecate them. And personally I think it should not be the focus of pandas. \n\nBut maybe `scatter_matrix` as the IMO the most generic of the plotting methods listed can be the exception?",
    "why don't we defer scatter_mattix to seaborn anyhow? so seaborn becomes an optional dep)",
    "@jreback   how well are optional circular dependencies no supported in various packagings?\nI haven't kept up with it, but we get circular dependency pandas - seaborn - statsmodels.\nI'm in favor of tight integration, in general.\n\nI'm not a heavy pandas user directly, but I also find some quick plot methods convenient, instead of having to look for the appropriate function in another package.\n\nabout plots in statsmodels: plots are mostly in a minimal maintenance state. There is not much effort for a style update to make them look better, e.g. compared to seaborn, because of a lack of developers. \nHowever, we need them in support of the models and other stats functions and still keep adding more. \nFor example, acf and pacf are some of our oldest plot functions and won't go away.\n\nTrying to use seaborn as optional statsmodels dependency to upgrade plots is an idea but doesn't have a champion to look into it and work on it. For many plots the focus of seaborn is exploratory analysis which is more similar to the pandas use, but for us having a model inside the plot is inside out because we need plots inside the models, or after having estimated a model.",
    "Received this issue from CodeTriage. Seems like it is already closed issue @jorisvandenbossche could you explain why you reopened the issue?",
    "- [ ] `scatter_matrix` (deprecate, redirect to `seaborn`)\n- [ ] `andrews_curve`\n- [ ] `parallel_coordinates`\n- [ ] `lag_plot` (maybe rename to `lag`)\n- [ ] `autocorrelation_plot` (maybe rename to `autocorrelation`?)\n- [ ] `bootstrap_plot` (maybe rename to `bootstrap`?)\n- [ ] `radviz`"
  ],
  "golden_answers": [
    "I agree with @shoyer. These plotting methods are rather 'neglected' lately. I think we should either choose to give them more attention, or deprecate them. And personally I think it should not be the focus of pandas. \n\nBut maybe `scatter_matrix` as the IMO the most generic of the plotting methods listed can be the exception?",
    "@jreback   how well are optional circular dependencies no supported in various packagings?\nI haven't kept up with it, but we get circular dependency pandas - seaborn - statsmodels.\nI'm in favor of tight integration, in general.\n\nI'm not a heavy pandas user directly, but I also find some quick plot methods convenient, instead of having to look for the appropriate function in another package.\n\nabout plots in statsmodels: plots are mostly in a minimal maintenance state. There is not much effort for a style update to make them look better, e.g. compared to seaborn, because of a lack of developers. \nHowever, we need them in support of the models and other stats functions and still keep adding more. \nFor example, acf and pacf are some of our oldest plot functions and won't go away.\n\nTrying to use seaborn as optional statsmodels dependency to upgrade plots is an idea but doesn't have a champion to look into it and work on it. For many plots the focus of seaborn is exploratory analysis which is more similar to the pandas use, but for us having a model inside the plot is inside out because we need plots inside the models, or after having estimated a model.",
    "@jreback   how well are optional circular dependencies no supported in various packagings?\nI haven't kept up with it, but we get circular dependency pandas - seaborn - statsmodels.\nI'm in favor of tight integration, in general.\n\nI'm not a heavy pandas user directly, but I also find some quick plot methods convenient, instead of having to look for the appropriate function in another package.\n\nabout plots in statsmodels: plots are mostly in a minimal maintenance state. There is not much effort for a style update to make them look better, e.g. compared to seaborn, because of a lack of developers. \nHowever, we need them in support of the models and other stats functions and still keep adding more. \nFor example, acf and pacf are some of our oldest plot functions and won't go away.\n\nTrying to use seaborn as optional statsmodels dependency to upgrade plots is an idea but doesn't have a champion to look into it and work on it. For many plots the focus of seaborn is exploratory analysis which is more similar to the pandas use, but for us having a model inside the plot is inside out because we need plots inside the models, or after having estimated a model.",
    "using seaborn (or sm using pandas is no problem here)\nyou can simply import inside the method itself",
    "From the reversion of this feature in https://github.com/pandas-dev/pandas/pull/24912 and discussion within, it appears that there's not much appetite in supporting this directly in an accessor and having a free standing function is fine. Closing.",
    "We could probably do this as `DataFrame.plot.scatter_matrix`. I'm not sure why this wasn't ever folded into the `df.plot(kind=)` function.\n\nAlso, the standard disclaimer that seaborn [does this better](https://stanford.edu/~mwaskom/software/seaborn/examples/scatterplot_matrix.html)"
  ],
  "questions_generated": [
    "What is the main proposal discussed in the issue regarding the 'scatter_matrix' function in the pandas repository?",
    "Why is there a suggestion to deprecate 'scatter_matrix' in favor of seaborn, and what are the potential benefits of this change?",
    "What concerns are raised regarding the potential circular dependencies between pandas, seaborn, and statsmodels?",
    "What are the technical challenges mentioned regarding the integration of plotting methods as part of the plot accessor in pandas?",
    "How does the proposed change to utilize 'DataFrame.plot.scatter_matrix' align with pandas' current code structure, especially in relation to the 'pandas.plotting._core.py' module?",
    "What are the implications of deprecating other complex plot types like 'bootstrap_plot' and 'autocorrelation_plot', and are there any suggested alternatives?"
  ],
  "golden_answers_generated": [
    "The main proposal discussed is to allow the 'scatter_matrix' function to be called directly on a DataFrame through a plot accessor, instead of being a separate function. This would enable users to call it as 'DataFrame.plot.scatter_matrix', streamlining the process and making it more consistent with other plotting functions.",
    "The suggestion to deprecate 'scatter_matrix' in favor of seaborn is based on the idea that seaborn provides more advanced and aesthetically pleasing plotting capabilities. By redirecting users to seaborn, pandas can focus on its core functionalities while allowing users to leverage seaborn's superior visualization tools. This change could lead to less maintenance overhead for pandas and encourage the use of more sophisticated plotting libraries.",
    "The concern raised is about how well optional circular dependencies are supported in various packaging systems. If pandas, seaborn, and statsmodels were to become interdependent, it could lead to complications in maintaining and distributing these libraries. The discussion suggests ensuring tight integration without creating problematic dependencies that could hinder installation or usage.",
    "One technical challenge is determining which plotting methods should be integrated into the plot accessor, given the existence of more advanced libraries like seaborn. Another challenge is maintaining the existing functionality while potentially deprecating certain plots that are either neglected or better handled by other libraries. The decision involves balancing ease of use, maintenance, and the quality of the visualizations.",
    "The proposed change aligns with pandas' current code structure by utilizing the plot accessor pattern already in place for other plotting functions. The 'pandas.plotting._core.py' module, which handles the core plotting functionalities, would be a logical place to implement this change. This would likely involve adding a method to the 'MPLPlot' class or a similar class, enabling 'scatter_matrix' to be called as part of the DataFrame's plot methods.",
    "Deprecating plots like 'bootstrap_plot' and 'autocorrelation_plot' implies that pandas would no longer maintain or improve these plots, suggesting users find alternatives. The discussion mentions statsmodels as a potential alternative for statistical plots, although it also notes that plots in statsmodels are in a minimal maintenance state. The implication is a shift towards relying on specialized libraries for complex visualizations, which could offer better support and features."
  ]
}