{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "24798",
  "issue_description": "# Assigning values breaks in different ways when duplicate column names\n\n#### Code Sample, a copy-pastable example if possible\r\n\r\nOur primary data with two columns with identical name:\r\n\r\n```python\r\ndf = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\ndf.columns = list('AABC')\r\nprint(df)\r\n\"\"\"\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n\"\"\"\r\n```\r\nIssue 1a: `Series.replace` throws `ValueError` when assigning:\r\n\r\n```python\r\nprint(df['B'].replace(6, np.nan))  # will work as expected with int as well\r\n\"\"\"\r\n0    NaN\r\n1    7.0\r\n2    8.0\r\nName: B, dtype: float64\r\n\"\"\"\r\n# ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\ndf['B'] = df['B'].replace(6, np.nan)  # inplace=True does not raise error, but no change\r\ndf['B'] = df['B'].replace(6, 5)\r\n```\r\nIssue 1b: Same `ValueError` as above thrown when assigning `np.nan` with `loc`:\r\n```python\r\n# ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\ndf.loc[df['B'] == 6, 'B'] = np.nan\r\n\r\n# Assigning int with loc will however work: \r\ndf.loc[df['B'] == 6, 'B'] = 5\r\n```\r\nIssue 2a: assigning `np.nan` with `iloc` on column with a duplicate will apply on both columns:\r\n\r\n```python\r\n# Assigning np.nan with iloc on column with a duplicate will apply on both columns:\r\ndf.iloc[0, 0] = np.nan\r\nprint(df)\r\n\"\"\"\r\n     A    A  B   C\r\n0  NaN  NaN  5   9\r\n1  1.0  4.0  7  10\r\n2  2.0  5.0  8  11\r\n\"\"\"\r\n```` \r\nIssue 2b: assigning `int` with `iloc` will work int `v0.22.0` but not `v0.23.4`\r\n\r\n```python\r\ndf.iloc[0, 0] = 10\r\nprint(df)\r\n\"\"\"\r\n0.22.0:\r\n    A  A  B   C\r\n0  10  3  5   9\r\n1   1  4  7  10\r\n2   2  5  8  11\r\n\r\n0.23.4:\r\n      A     A  B   C\r\n0  10.0  10.0  5   9\r\n1   1.0   4.0  7  10\r\n2   2.0   5.0  8  11\r\n\"\"\"\r\n# Assigning with iloc will not break if BOTH columns contain a nan:\r\nx = pd.DataFrame({'a': np.array([np.nan, 1, 2])})\r\ny = pd.DataFrame({'a': np.array([0, np.nan, 2])})\r\n\r\ndf = pd.concat([x, y], axis=1)\r\n\r\ndf.iloc[0, 0] = 10\r\nprint(df)\r\n\"\"\"\r\n      a    a \r\n0  10.0  0.0\r\n1   1.0  NaN\r\n2   2.0  2.0\r\n\"\"\"\r\n```\r\n#### Problem description\r\n\r\nThe main topic for this issue is assigning different values to a `DataFrame` that contains duplicate column names. List of issues reported:\r\n\r\n- [x] Issue 1a: `Series.replace` throws `ValueError` when assigning (#32477)\r\n- [x] Issue 1b: Same `ValueError` as `Issue 1a` thrown when assigning np.nan with loc (#34302)\r\n- [x] Issue 2a: assigning `np.nan` with `iloc` on column with a duplicate will apply on both columns (#22036, #15686 closed by #32477)\r\n- [x] Issue 2b: assigning `int` with `iloc` will work in `v0.22.0` but not `v0.23.4` (#22036, #15686 closed by #32477)\r\n\r\nhe issue with `iloc` and `np.nan` (above called `Issue 2a`) was reported and closed as fixed here: https://github.com/pandas-dev/pandas/issues/13423 per  `0.18.0` but I'm able to recreate that issue with `v0.23.4`.\r\n\r\n#### Expected Output\r\nEither the same output as we would expect if we had only unique names in our columns or a `DuplicateColumnWarning`/`DuplicateColumnException` when `DataFrame` contains duplicate columns.\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\npandas: 0.23.4\r\npytest: None\r\npip: 18.0\r\nsetuptools: 39.0.1\r\nCython: None\r\nnumpy: 1.16.0\r\nscipy: 1.1.0T\r\npyarrow: None\r\nxarray: None\r\nIPython: 6.3.1\r\nsphinx: None\r\npatsy: None\r\ndateutil: 2.7.2\r\npytz: 2018.3\r\nblosc: None\r\nbottleneck: None\r\ntables: None\r\nnumexpr: None\r\nfeather: None\r\nmatplotlib: 2.1.0\r\nopenpyxl: 2.5.1\r\nxlrd: 1.1.0\r\nxlwt: None\r\nxlsxwriter: None\r\nlxml: 4.2.1\r\nbs4: 4.6.0\r\nhtml5lib: 1.0.1\r\nsqlalchemy: 1.2.5\r\npymysql: None\r\npsycopg2: None\r\njinja2: 2.10\r\ns3fs: None\r\nfastparquet: None\r\npandas_gbq: None\r\npandas_datareader: None\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 454840777,
      "user": "WillAyd",
      "body": "IIUC correctly you have quite a few separate problems here - could you make a checklist of them to aid the discussion? As is now it's a little challenging to dissect the entire sample provided"
    },
    {
      "id": 454885205,
      "user": "user347",
      "body": "Updated in an attempt to make it a little bit clearer."
    },
    {
      "id": 454927941,
      "user": "TomAugspurger",
      "body": "@user347 can you search to see if any of these are duplicate issues? Your 1a sounds familiar."
    },
    {
      "id": 455081399,
      "user": "user347",
      "body": "> \r\n> \r\n> @user347 can you search to see if any of these are duplicate issues? Your 1a sounds familiar.\r\n\r\nMaybe I'm blind but I searched before posting and again now, and can't find any open issues that seem the same as either of the issues reported here."
    },
    {
      "id": 606095792,
      "user": "simonjayhawkins",
      "body": "Issue 1A (ValueError: Buffer has wrong number of dimensions (expected 1, got 0)) is fixed on master\r\n\r\n```\r\n>>> import numpy as np\r\n>>>\r\n>>> import pandas as pd\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+1029.gbdf969cd6'\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> print(df[\"B\"].replace(6, np.nan))\r\n0    NaN\r\n1    7.0\r\n2    8.0\r\nName: B, dtype: float64\r\n>>>\r\n>>> df[\"B\"] = df[\"B\"].replace(6, np.nan)\r\n>>> print(df)\r\n   A  A    B   C\r\n0  0  3  NaN   9\r\n1  1  4  7.0  10\r\n2  2  5  8.0  11\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> df[\"B\"] = df[\"B\"].replace(6, 5)\r\n>>> df\r\n   A  A  B   C\r\n0  0  3  5   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n```"
    },
    {
      "id": 606135390,
      "user": "simonjayhawkins",
      "body": "> Issue 1A (ValueError: Buffer has wrong number of dimensions (expected 1, got 0)) is fixed on master\r\n\r\nfixed in #32477\r\n\r\n33f67d98aa74bdfdc4237930229b3dbe06d4fca7 is the first new commit\r\ncommit 33f67d98aa74bdfdc4237930229b3dbe06d4fca7\r\nAuthor: jbrockmendel <jbrockmendel@gmail.com>\r\nDate:   Tue Mar 10 19:35:21 2020 -0700\r\n\r\n    BUG: iloc.__setitem__ with duplicate columns (#32477)\r\n\r\nThis PR also fixed Issue 1b\r\n\r\n```\r\n>>> import numpy as np\r\n>>>\r\n>>> import pandas as pd\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+756.g33f67d98a'\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> # ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\n>>> df.loc[df[\"B\"] == 6, \"B\"] = np.nan\r\n>>> print(df)\r\n   A  A    B   C\r\n0  0  3  NaN   9\r\n1  1  4  7.0  10\r\n2  2  5  8.0  11\r\n>>>\r\n```"
    },
    {
      "id": 606149587,
      "user": "simonjayhawkins",
      "body": "Issue 2a (and Issue 2b) is a duplicate of #22036 and #15686 and also fixed by #32477 (no additional tests needed)"
    },
    {
      "id": 631199444,
      "user": "matteosantama",
      "body": "Is there more work to be done here? Or is this ticket effectively closed?"
    },
    {
      "id": 631424701,
      "user": "simonjayhawkins",
      "body": "> Is there more work to be done here? Or is this ticket effectively closed?\r\n\r\nneed to add tests for 1A and 1B to prevent regression before closing issue.\r\n\r\nPRs welcome."
    },
    {
      "id": 631642365,
      "user": "matteosantama",
      "body": "Happy to take this. I imagine the test (at least for 1a) will live in tests/frame/methods/test_replace.py. This file doesn't seem to be passing tests currently. I'm trying to run `pytest test_replace.py` from within the /methods directory.\r\n\r\n`AttributeError: module 'pandas._libs.tslibs.offsets' has no attribute 'YearOffset'`\r\n\r\nAny advice on tracking this down? Or do you know if someone working on a fix?"
    },
    {
      "id": 631643245,
      "user": "WillAyd",
      "body": "You will need to rebuild the C extensions. Check here for more info:\r\n\r\nhttps://pandas.pydata.org/pandas-docs/stable/development/contributing.html#creating-a-python-environment"
    },
    {
      "id": 631674133,
      "user": "matteosantama",
      "body": "Thanks Will, that did it. \r\n\r\nWith the original problem statement in mind I've parametrized the test the run with inplace=[True, False], but it's causing a bit of a problem. \r\n```\r\nresult = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\nresult[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n    \r\nexpected = pd.DataFrame(\r\n    {\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [np.nan, 8, 9]}\r\n)\r\n```\r\nFails because the B column in `result` is object dtype, but float64 in `expected`. Doesn't happen when `inplace=False`.\r\n\r\nDo you think this is expected behavior? Or is there another issue lurking?\r\n\r\n**EDIT:** Solved the above issue by not assigning the column when using inplace=True.\r\n\r\nI've run into a second issue, though. I'm attempting to replace with `pd.NA` as well, and when I initialize `expected` as \r\n\r\n```\r\nexpected = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [pd.NA, 8, 9]})\r\n\r\nresult = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\nresult[\"B\"] = result[\"B\"].replace(7, pd.NA, inplace=False)\r\n\r\n```\r\n\r\nexpected column B has dtype object. This errors when I compare to `result`, which has dtype float64. I know the whole None/pd.NA/np.nan ecosystem is problematic. In short, replacing with pd.NA seems to maintain dtype, but initializing with pd.NA falls back on object dtype. \r\n\r\nDo you think it's better to leave out the pd.NA case, or ignore dtype when comparing the dataframes (at least for the pd.NA parameter)?"
    },
    {
      "id": 632039424,
      "user": "simonjayhawkins",
      "body": "@matteosantama Thanks for looking into this.\r\n\r\n> With the original problem statement in mind I've parametrized the test the run with inplace=[True, False], but it's causing a bit of a problem.\r\n> \r\n> ```\r\n> result = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n> result[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n>     \r\n> expected = pd.DataFrame(\r\n>     {\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [np.nan, 8, 9]}\r\n> )\r\n> ```\r\n> \r\n> Fails because the B column in `result` is object dtype, but float64 in `expected`. Doesn't happen when `inplace=False`.\r\n> \r\n> Do you think this is expected behavior? Or is there another issue lurking?\r\n\r\nThe return type is None, when inplace=True, so effectively assigning None to `B`\r\n\r\n```\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+1624.gc5ea16f302'\r\n>>>\r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n>>> result\r\n   A     B\r\n0  4  None\r\n1  5  None\r\n2  6  None\r\n>>>\r\n```\r\n\r\nto parameterise over inplace parameter you will need to use the the following pattern in the test\r\n\r\n```\r\n        if inplace:\r\n            result[\"B\"].replace(7, np.nan, inplace=True)\r\n        else:\r\n            result[\"B\"]= result[\"B\"].replace(7, np.nan, inplace=False)\r\n```\r\n\r\nalso note that `pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})` does NOT create a dataframe with duplicate column names.\r\n\r\n```\r\n>>> pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n   A  B\r\n0  4  7\r\n1  5  8\r\n2  6  9\r\n>>>\r\n```\r\n\r\nyou could use the same pattern in the OP to assign column names after creating the dataframe. maybe\r\n\r\n```\r\n>>> df = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> df.columns = list(\"AAB\")\r\n>>> df\r\n   A  A  B\r\n0  1  4  7\r\n1  2  5  8\r\n2  3  6  9\r\n>>>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
      "id": 632208135,
      "user": "matteosantama",
      "body": "> also note that pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]}) does NOT create a dataframe with duplicate column names.\r\n\r\n@simonjayhawkins Oops! Good catch, new here so trying to get my bearings. 1A) still seems to be partially broken.\r\n\r\n```\r\n>>> pd.__version__\r\n'1.1.0.dev0+1622.g23c7e85d8.dirty'\r\n>>> \r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result.columns = list(\"AAB\")\r\n>>> \r\n>>> result[\"B\"].replace(7, np.nan, inplace=True)\r\n/home/pandas/pandas/util/_decorators.py:355: SettingWithCopyWarning: \r\nA value is trying to be set on a copy of a slice from a DataFrame\r\n\r\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\r\n  return func(*args, **kwargs)\r\n>>>\r\n>>> result\r\n   A  A  B\r\n0  1  4  7\r\n1  2  5  8\r\n2  3  6  9\r\n```\r\n\r\nIf you point me in the right direction I can take a crack at it."
    },
    {
      "id": 632280735,
      "user": "simonjayhawkins",
      "body": "> 1A) still seems to be partially broken.\r\n\r\ninplace was not included in the OP (only as a comment) and appears to still be broken. can you see if we have an issue for this. (maybe raise one)\r\n\r\nto close this issue, an more importantly to add tests to prevent regression from master for the working cases fixed in #32477 we can xfail the inplace tests for now if necessary.\r\n\r\ncan you submit your current changes as a PR as this will make it easier to review.\r\n\r\n> If you point me in the right direction I can take a crack at it.\r\n\r\nany fixes should be done separately, can we keep the PR scoped to adding tests."
    },
    {
      "id": 632348559,
      "user": "matteosantama",
      "body": "Understood, PR submitted. It's still failing one test, and the is issue that when a DataFrame column is initialized with a pd.NA entry, the dtype is object, but when you replace with pd.NA the dtype is float64.\r\n\r\n```\r\n>>> pd.__version__\r\n'1.1.0.dev0+1622.g23c7e85d8.dirty'\r\n>>> \r\n>>> expected = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [pd.NA, 8, 9]})\r\n>>> expected.columns = list(\"AAB\")\r\n>>> \r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result.columns = list(\"AAB\")\r\n>>> result[\"B\"] = result[\"B\"].replace(7, pd.NA, inplace=False)\r\n>>> \r\n>>> expected.dtypes\r\nA     int64\r\nA     int64\r\nB    object\r\ndtype: object\r\n>>> \r\n>>> result.dtypes\r\nA      int64\r\nA      int64\r\nB    float64\r\ndtype: object\r\n```\r\n"
    },
    {
      "id": 633736613,
      "user": "jreback",
      "body": "@simonjayhawkins see if the refs on the checkboxes above make sense."
    },
    {
      "id": 658973154,
      "user": "TomAugspurger",
      "body": "@matteosantama did https://github.com/pandas-dev/pandas/pull/34302 close this?"
    },
    {
      "id": 659456186,
      "user": "matteosantama",
      "body": "> @matteosantama did #34302 close this?\r\n\r\n@TomAugspurger #34302 adds a test to detect regression in Series.replace() (issue 1a). \r\n"
    },
    {
      "id": 659481812,
      "user": "TomAugspurger",
      "body": "OK, thanks. 1b was the only one fixed but unchecked, so maybe everything has been fixed. If not, then we'll open a new issue."
    }
  ],
  "text_context": "# Assigning values breaks in different ways when duplicate column names\n\n#### Code Sample, a copy-pastable example if possible\r\n\r\nOur primary data with two columns with identical name:\r\n\r\n```python\r\ndf = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\ndf.columns = list('AABC')\r\nprint(df)\r\n\"\"\"\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n\"\"\"\r\n```\r\nIssue 1a: `Series.replace` throws `ValueError` when assigning:\r\n\r\n```python\r\nprint(df['B'].replace(6, np.nan))  # will work as expected with int as well\r\n\"\"\"\r\n0    NaN\r\n1    7.0\r\n2    8.0\r\nName: B, dtype: float64\r\n\"\"\"\r\n# ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\ndf['B'] = df['B'].replace(6, np.nan)  # inplace=True does not raise error, but no change\r\ndf['B'] = df['B'].replace(6, 5)\r\n```\r\nIssue 1b: Same `ValueError` as above thrown when assigning `np.nan` with `loc`:\r\n```python\r\n# ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\ndf.loc[df['B'] == 6, 'B'] = np.nan\r\n\r\n# Assigning int with loc will however work: \r\ndf.loc[df['B'] == 6, 'B'] = 5\r\n```\r\nIssue 2a: assigning `np.nan` with `iloc` on column with a duplicate will apply on both columns:\r\n\r\n```python\r\n# Assigning np.nan with iloc on column with a duplicate will apply on both columns:\r\ndf.iloc[0, 0] = np.nan\r\nprint(df)\r\n\"\"\"\r\n     A    A  B   C\r\n0  NaN  NaN  5   9\r\n1  1.0  4.0  7  10\r\n2  2.0  5.0  8  11\r\n\"\"\"\r\n```` \r\nIssue 2b: assigning `int` with `iloc` will work int `v0.22.0` but not `v0.23.4`\r\n\r\n```python\r\ndf.iloc[0, 0] = 10\r\nprint(df)\r\n\"\"\"\r\n0.22.0:\r\n    A  A  B   C\r\n0  10  3  5   9\r\n1   1  4  7  10\r\n2   2  5  8  11\r\n\r\n0.23.4:\r\n      A     A  B   C\r\n0  10.0  10.0  5   9\r\n1   1.0   4.0  7  10\r\n2   2.0   5.0  8  11\r\n\"\"\"\r\n# Assigning with iloc will not break if BOTH columns contain a nan:\r\nx = pd.DataFrame({'a': np.array([np.nan, 1, 2])})\r\ny = pd.DataFrame({'a': np.array([0, np.nan, 2])})\r\n\r\ndf = pd.concat([x, y], axis=1)\r\n\r\ndf.iloc[0, 0] = 10\r\nprint(df)\r\n\"\"\"\r\n      a    a \r\n0  10.0  0.0\r\n1   1.0  NaN\r\n2   2.0  2.0\r\n\"\"\"\r\n```\r\n#### Problem description\r\n\r\nThe main topic for this issue is assigning different values to a `DataFrame` that contains duplicate column names. List of issues reported:\r\n\r\n- [x] Issue 1a: `Series.replace` throws `ValueError` when assigning (#32477)\r\n- [x] Issue 1b: Same `ValueError` as `Issue 1a` thrown when assigning np.nan with loc (#34302)\r\n- [x] Issue 2a: assigning `np.nan` with `iloc` on column with a duplicate will apply on both columns (#22036, #15686 closed by #32477)\r\n- [x] Issue 2b: assigning `int` with `iloc` will work in `v0.22.0` but not `v0.23.4` (#22036, #15686 closed by #32477)\r\n\r\nhe issue with `iloc` and `np.nan` (above called `Issue 2a`) was reported and closed as fixed here: https://github.com/pandas-dev/pandas/issues/13423 per  `0.18.0` but I'm able to recreate that issue with `v0.23.4`.\r\n\r\n#### Expected Output\r\nEither the same output as we would expect if we had only unique names in our columns or a `DuplicateColumnWarning`/`DuplicateColumnException` when `DataFrame` contains duplicate columns.\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\npandas: 0.23.4\r\npytest: None\r\npip: 18.0\r\nsetuptools: 39.0.1\r\nCython: None\r\nnumpy: 1.16.0\r\nscipy: 1.1.0T\r\npyarrow: None\r\nxarray: None\r\nIPython: 6.3.1\r\nsphinx: None\r\npatsy: None\r\ndateutil: 2.7.2\r\npytz: 2018.3\r\nblosc: None\r\nbottleneck: None\r\ntables: None\r\nnumexpr: None\r\nfeather: None\r\nmatplotlib: 2.1.0\r\nopenpyxl: 2.5.1\r\nxlrd: 1.1.0\r\nxlwt: None\r\nxlsxwriter: None\r\nlxml: 4.2.1\r\nbs4: 4.6.0\r\nhtml5lib: 1.0.1\r\nsqlalchemy: 1.2.5\r\npymysql: None\r\npsycopg2: None\r\njinja2: 2.10\r\ns3fs: None\r\nfastparquet: None\r\npandas_gbq: None\r\npandas_datareader: None\r\n</details>\r\n\n\nIIUC correctly you have quite a few separate problems here - could you make a checklist of them to aid the discussion? As is now it's a little challenging to dissect the entire sample provided\n\nUpdated in an attempt to make it a little bit clearer.\n\n@user347 can you search to see if any of these are duplicate issues? Your 1a sounds familiar.\n\n> \r\n> \r\n> @user347 can you search to see if any of these are duplicate issues? Your 1a sounds familiar.\r\n\r\nMaybe I'm blind but I searched before posting and again now, and can't find any open issues that seem the same as either of the issues reported here.\n\nIssue 1A (ValueError: Buffer has wrong number of dimensions (expected 1, got 0)) is fixed on master\r\n\r\n```\r\n>>> import numpy as np\r\n>>>\r\n>>> import pandas as pd\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+1029.gbdf969cd6'\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> print(df[\"B\"].replace(6, np.nan))\r\n0    NaN\r\n1    7.0\r\n2    8.0\r\nName: B, dtype: float64\r\n>>>\r\n>>> df[\"B\"] = df[\"B\"].replace(6, np.nan)\r\n>>> print(df)\r\n   A  A    B   C\r\n0  0  3  NaN   9\r\n1  1  4  7.0  10\r\n2  2  5  8.0  11\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> df[\"B\"] = df[\"B\"].replace(6, 5)\r\n>>> df\r\n   A  A  B   C\r\n0  0  3  5   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n```\n\n> Issue 1A (ValueError: Buffer has wrong number of dimensions (expected 1, got 0)) is fixed on master\r\n\r\nfixed in #32477\r\n\r\n33f67d98aa74bdfdc4237930229b3dbe06d4fca7 is the first new commit\r\ncommit 33f67d98aa74bdfdc4237930229b3dbe06d4fca7\r\nAuthor: jbrockmendel <jbrockmendel@gmail.com>\r\nDate:   Tue Mar 10 19:35:21 2020 -0700\r\n\r\n    BUG: iloc.__setitem__ with duplicate columns (#32477)\r\n\r\nThis PR also fixed Issue 1b\r\n\r\n```\r\n>>> import numpy as np\r\n>>>\r\n>>> import pandas as pd\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+756.g33f67d98a'\r\n>>>\r\n>>> df = pd.DataFrame(np.arange(12).reshape(4, 3).T)\r\n>>> df.columns = list(\"AABC\")\r\n>>> print(df)\r\n   A  A  B   C\r\n0  0  3  6   9\r\n1  1  4  7  10\r\n2  2  5  8  11\r\n>>>\r\n>>> # ValueError: Buffer has wrong number of dimensions (expected 1, got 0):\r\n>>> df.loc[df[\"B\"] == 6, \"B\"] = np.nan\r\n>>> print(df)\r\n   A  A    B   C\r\n0  0  3  NaN   9\r\n1  1  4  7.0  10\r\n2  2  5  8.0  11\r\n>>>\r\n```\n\nIssue 2a (and Issue 2b) is a duplicate of #22036 and #15686 and also fixed by #32477 (no additional tests needed)\n\nIs there more work to be done here? Or is this ticket effectively closed?\n\n> Is there more work to be done here? Or is this ticket effectively closed?\r\n\r\nneed to add tests for 1A and 1B to prevent regression before closing issue.\r\n\r\nPRs welcome.\n\nHappy to take this. I imagine the test (at least for 1a) will live in tests/frame/methods/test_replace.py. This file doesn't seem to be passing tests currently. I'm trying to run `pytest test_replace.py` from within the /methods directory.\r\n\r\n`AttributeError: module 'pandas._libs.tslibs.offsets' has no attribute 'YearOffset'`\r\n\r\nAny advice on tracking this down? Or do you know if someone working on a fix?\n\nYou will need to rebuild the C extensions. Check here for more info:\r\n\r\nhttps://pandas.pydata.org/pandas-docs/stable/development/contributing.html#creating-a-python-environment\n\nThanks Will, that did it. \r\n\r\nWith the original problem statement in mind I've parametrized the test the run with inplace=[True, False], but it's causing a bit of a problem. \r\n```\r\nresult = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\nresult[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n    \r\nexpected = pd.DataFrame(\r\n    {\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [np.nan, 8, 9]}\r\n)\r\n```\r\nFails because the B column in `result` is object dtype, but float64 in `expected`. Doesn't happen when `inplace=False`.\r\n\r\nDo you think this is expected behavior? Or is there another issue lurking?\r\n\r\n**EDIT:** Solved the above issue by not assigning the column when using inplace=True.\r\n\r\nI've run into a second issue, though. I'm attempting to replace with `pd.NA` as well, and when I initialize `expected` as \r\n\r\n```\r\nexpected = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [pd.NA, 8, 9]})\r\n\r\nresult = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\nresult[\"B\"] = result[\"B\"].replace(7, pd.NA, inplace=False)\r\n\r\n```\r\n\r\nexpected column B has dtype object. This errors when I compare to `result`, which has dtype float64. I know the whole None/pd.NA/np.nan ecosystem is problematic. In short, replacing with pd.NA seems to maintain dtype, but initializing with pd.NA falls back on object dtype. \r\n\r\nDo you think it's better to leave out the pd.NA case, or ignore dtype when comparing the dataframes (at least for the pd.NA parameter)?\n\n@matteosantama Thanks for looking into this.\r\n\r\n> With the original problem statement in mind I've parametrized the test the run with inplace=[True, False], but it's causing a bit of a problem.\r\n> \r\n> ```\r\n> result = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n> result[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n>     \r\n> expected = pd.DataFrame(\r\n>     {\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [np.nan, 8, 9]}\r\n> )\r\n> ```\r\n> \r\n> Fails because the B column in `result` is object dtype, but float64 in `expected`. Doesn't happen when `inplace=False`.\r\n> \r\n> Do you think this is expected behavior? Or is there another issue lurking?\r\n\r\nThe return type is None, when inplace=True, so effectively assigning None to `B`\r\n\r\n```\r\n>>>\r\n>>> pd.__version__\r\n'1.1.0.dev0+1624.gc5ea16f302'\r\n>>>\r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result[\"B\"] = result[\"B\"].replace(7, np.nan, inplace=True)\r\n>>> result\r\n   A     B\r\n0  4  None\r\n1  5  None\r\n2  6  None\r\n>>>\r\n```\r\n\r\nto parameterise over inplace parameter you will need to use the the following pattern in the test\r\n\r\n```\r\n        if inplace:\r\n            result[\"B\"].replace(7, np.nan, inplace=True)\r\n        else:\r\n            result[\"B\"]= result[\"B\"].replace(7, np.nan, inplace=False)\r\n```\r\n\r\nalso note that `pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})` does NOT create a dataframe with duplicate column names.\r\n\r\n```\r\n>>> pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n   A  B\r\n0  4  7\r\n1  5  8\r\n2  6  9\r\n>>>\r\n```\r\n\r\nyou could use the same pattern in the OP to assign column names after creating the dataframe. maybe\r\n\r\n```\r\n>>> df = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> df.columns = list(\"AAB\")\r\n>>> df\r\n   A  A  B\r\n0  1  4  7\r\n1  2  5  8\r\n2  3  6  9\r\n>>>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\n\n> also note that pd.DataFrame({\"A\": [1, 2, 3], \"A\": [4, 5, 6], \"B\": [7, 8, 9]}) does NOT create a dataframe with duplicate column names.\r\n\r\n@simonjayhawkins Oops! Good catch, new here so trying to get my bearings. 1A) still seems to be partially broken.\r\n\r\n```\r\n>>> pd.__version__\r\n'1.1.0.dev0+1622.g23c7e85d8.dirty'\r\n>>> \r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result.columns = list(\"AAB\")\r\n>>> \r\n>>> result[\"B\"].replace(7, np.nan, inplace=True)\r\n/home/pandas/pandas/util/_decorators.py:355: SettingWithCopyWarning: \r\nA value is trying to be set on a copy of a slice from a DataFrame\r\n\r\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\r\n  return func(*args, **kwargs)\r\n>>>\r\n>>> result\r\n   A  A  B\r\n0  1  4  7\r\n1  2  5  8\r\n2  3  6  9\r\n```\r\n\r\nIf you point me in the right direction I can take a crack at it.\n\n> 1A) still seems to be partially broken.\r\n\r\ninplace was not included in the OP (only as a comment) and appears to still be broken. can you see if we have an issue for this. (maybe raise one)\r\n\r\nto close this issue, an more importantly to add tests to prevent regression from master for the working cases fixed in #32477 we can xfail the inplace tests for now if necessary.\r\n\r\ncan you submit your current changes as a PR as this will make it easier to review.\r\n\r\n> If you point me in the right direction I can take a crack at it.\r\n\r\nany fixes should be done separately, can we keep the PR scoped to adding tests.\n\nUnderstood, PR submitted. It's still failing one test, and the is issue that when a DataFrame column is initialized with a pd.NA entry, the dtype is object, but when you replace with pd.NA the dtype is float64.\r\n\r\n```\r\n>>> pd.__version__\r\n'1.1.0.dev0+1622.g23c7e85d8.dirty'\r\n>>> \r\n>>> expected = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [pd.NA, 8, 9]})\r\n>>> expected.columns = list(\"AAB\")\r\n>>> \r\n>>> result = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\r\n>>> result.columns = list(\"AAB\")\r\n>>> result[\"B\"] = result[\"B\"].replace(7, pd.NA, inplace=False)\r\n>>> \r\n>>> expected.dtypes\r\nA     int64\r\nA     int64\r\nB    object\r\ndtype: object\r\n>>> \r\n>>> result.dtypes\r\nA      int64\r\nA      int64\r\nB    float64\r\ndtype: object\r\n```\r\n\n\n@simonjayhawkins see if the refs on the checkboxes above make sense.\n\n@matteosantama did https://github.com/pandas-dev/pandas/pull/34302 close this?\n\n> @matteosantama did #34302 close this?\r\n\r\n@TomAugspurger #34302 adds a test to detect regression in Series.replace() (issue 1a). \r\n\n\nOK, thanks. 1b was the only one fixed but unchecked, so maybe everything has been fixed. If not, then we'll open a new issue.",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/34302",
  "code_context": [
    {
      "filename": "pandas/tests/frame/methods/test_replace.py",
      "content": "from datetime import datetime\nfrom io import StringIO\nimport re\nfrom typing import Dict, List, Union\n\nimport numpy as np\nimport pytest\n\nimport pandas as pd\nfrom pandas import DataFrame, Index, Series, Timestamp, date_range\nimport pandas._testing as tm\n\n\n@pytest.fixture\ndef mix_ab() -> Dict[str, List[Union[int, str]]]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\")}\n\n\n@pytest.fixture\ndef mix_abc() -> Dict[str, List[Union[float, str]]]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": [\"a\", \"b\", np.nan, \"d\"]}\n\n\nclass TestDataFrameReplace:\n    def test_replace_inplace(self, datetime_frame, float_string_frame):\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n\n        tsframe = datetime_frame.copy()\n        tsframe.replace(np.nan, 0, inplace=True)\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))\n\n        # mixed type\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, 0)\n        expected = float_string_frame.fillna(value=0)\n        tm.assert_frame_equal(result, expected)\n\n        tsframe = datetime_frame.copy()\n        tsframe.replace([np.nan], [0], inplace=True)\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))\n\n    def test_regex_replace_scalar(self, mix_ab):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\")}\n        dfobj = DataFrame(obj)\n        dfmix = DataFrame(mix_ab)\n\n        # simplest cases\n        # regex -> value\n        # obj frame\n        res = dfobj.replace(r\"\\s*\\.\\s*\", np.nan, regex=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.replace(r\"\\s*\\.\\s*\", np.nan, regex=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\")\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfmix.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfmix.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_scalar_inplace(self, mix_ab):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\")}\n        dfobj = DataFrame(obj)\n        dfmix = DataFrame(mix_ab)\n\n        # simplest cases\n        # regex -> value\n        # obj frame\n        res = dfobj.copy()\n        res.replace(r\"\\s*\\.\\s*\", np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(r\"\\s*\\.\\s*\", np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True, inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True, inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.copy()\n        res.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\", regex=True, inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\", regex=True, inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfobj.copy()\n        res.replace(regex=r\"\\s*\\.\\s*\", value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(regex=r\"\\s*\\.\\s*\", value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\", inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\", inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.copy()\n        res.replace(regex=re.compile(r\"\\s*\\.\\s*\"), value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(regex=re.compile(r\"\\s*\\.\\s*\"), value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\", inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\", inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_list_obj(self):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"e|f|g\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\"] * 3 + [\"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(e|f|g)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e_crap\", \"f_crap\", \"g_crap\", \"h\"],\n                \"c\": [\"h\", \"e_crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.replace(value=values, regex=to_replace_res)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_list_obj_inplace(self):\n        # same as above with inplace=True\n        # lists of regexes and values\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"e|f|g\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\"] * 3 + [\"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(e|f|g)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e_crap\", \"f_crap\", \"g_crap\", \"h\"],\n                \"c\": [\"h\", \"e_crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.copy()\n        res.replace(value=values, regex=to_replace_res, inplace=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_list_mixed(self, mix_ab):\n        # mixed frame to make sure this doesn't break things\n        dfmix = DataFrame(mix_ab)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        mix2 = {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": list(\"halo\")}\n        dfmix2 = DataFrame(mix2)\n        res = dfmix2.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": mix2[\"a\"],\n                \"b\": [\"crap\", \"b\", np.nan, np.nan],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(regex=to_replace_res, value=values)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_list_mixed_inplace(self, mix_ab):\n        dfmix = DataFrame(mix_ab)\n        # the same inplace\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b\", np.nan, np.nan]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(regex=to_replace_res, value=values, inplace=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_dict_mixed(self, mix_abc):\n        dfmix = DataFrame(mix_abc)\n\n        # dicts\n        # single dict {re1: v1}, search the whole frame\n        # need test for this...\n\n        # list of dicts {re1: v1, re2: v2, ..., re3: v3}, search the whole\n        # frame\n        res = dfmix.replace({\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace({\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, inplace=True, regex=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # list of dicts {re1: re11, re2: re12, ..., reN: re1N}, search the\n        # whole frame\n        res = dfmix.replace({\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace({\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, inplace=True, regex=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"})\n        res2 = dfmix.copy()\n        res2.replace(regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # scalar -> dict\n        # to_replace regex, {value: value}\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace(\"a\", {\"b\": np.nan}, regex=True, inplace=True)\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace(regex=\"a\", value={\"b\": np.nan}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n    def test_regex_replace_dict_nested(self, mix_abc):\n        # nested dicts will not work until this is implemented for Series\n        dfmix = DataFrame(mix_abc)\n        res = dfmix.replace({\"b\": {r\"\\s*\\.\\s*\": np.nan}}, regex=True)\n        res2 = dfmix.copy()\n        res4 = dfmix.copy()\n        res2.replace({\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True, regex=True)\n        res3 = dfmix.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}})\n        res4.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n        tm.assert_frame_equal(res4, expec)\n\n    def test_regex_replace_dict_nested_non_first_character(self):\n        # GH 25259\n        df = pd.DataFrame({\"first\": [\"abc\", \"bca\", \"cab\"]})\n        expected = pd.DataFrame({\"first\": [\".bc\", \"bc.\", \"c.b\"]})\n        result = df.replace({\"a\": \".\"}, regex=True)\n        tm.assert_frame_equal(result, expected)\n\n    def test_regex_replace_dict_nested_gh4115(self):\n        df = pd.DataFrame({\"Type\": [\"Q\", \"T\", \"Q\", \"Q\", \"T\"], \"tmp\": 2})\n        expected = DataFrame({\"Type\": [0, 1, 0, 0, 1], \"tmp\": 2})\n        result = df.replace({\"Type\": {\"Q\": 0, \"T\": 1}})\n        tm.assert_frame_equal(result, expected)\n\n    def test_regex_replace_list_to_scalar(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame(\n            {\n                \"a\": mix_abc[\"a\"],\n                \"b\": np.array([np.nan] * 4),\n                \"c\": [np.nan, np.nan, np.nan, \"d\"],\n            }\n        )\n        res = df.replace([r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True)\n        res2 = df.copy()\n        res3 = df.copy()\n        res2.replace([r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True, inplace=True)\n        res3.replace(regex=[r\"\\s*\\.\\s*\", \"a|b\"], value=np.nan, inplace=True)\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_str_to_numeric(self, mix_abc):\n        # what happens when you try to replace a numeric value with a regex?\n        df = DataFrame(mix_abc)\n        res = df.replace(r\"\\s*\\.\\s*\", 0, regex=True)\n        res2 = df.copy()\n        res2.replace(r\"\\s*\\.\\s*\", 0, inplace=True, regex=True)\n        res3 = df.copy()\n        res3.replace(regex=r\"\\s*\\.\\s*\", value=0, inplace=True)\n        expec = DataFrame({\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", 0, 0], \"c\": mix_abc[\"c\"]})\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_regex_list_to_numeric(self, mix_abc):\n        df = DataFrame(mix_abc)\n        res = df.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True)\n        res2 = df.copy()\n        res2.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True, inplace=True)\n        res3 = df.copy()\n        res3.replace(regex=[r\"\\s*\\.\\s*\", \"b\"], value=0, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", 0, 0, 0], \"c\": [\"a\", 0, np.nan, \"d\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_series_of_regexes(self, mix_abc):\n        df = DataFrame(mix_abc)\n        s1 = Series({\"b\": r\"\\s*\\.\\s*\"})\n        s2 = Series({\"b\": np.nan})\n        res = df.replace(s1, s2, regex=True)\n        res2 = df.copy()\n        res2.replace(s1, s2, inplace=True, regex=True)\n        res3 = df.copy()\n        res3.replace(regex=s1, value=s2, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_numeric_to_object_conversion(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame({\"a\": [\"a\", 1, 2, 3], \"b\": mix_abc[\"b\"], \"c\": mix_abc[\"c\"]})\n        res = df.replace(0, \"a\")\n        tm.assert_frame_equal(res, expec)\n        assert res.a.dtype == np.object_\n\n    @pytest.mark.parametrize(\"metachar\", [\"[]\", \"()\", r\"\\d\", r\"\\w\", r\"\\s\"])\n    def test_replace_regex_metachar(self, metachar):\n        df = DataFrame({\"a\": [metachar, \"else\"]})\n        result = df.replace({\"a\": {metachar: \"paren\"}})\n        expected = DataFrame({\"a\": [\"paren\", \"else\"]})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace(self, datetime_frame):\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n\n        zero_filled = datetime_frame.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, datetime_frame.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), datetime_frame)\n\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n        datetime_frame[\"B\"][:5] = -1e8\n\n        # empty\n        df = DataFrame(index=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, df.replace(5, 7))\n\n        # GH 11698\n        # test for mixed data types.\n        df = pd.DataFrame(\n            [(\"-\", pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        df1 = df.replace(\"-\", np.nan)\n        expected_df = pd.DataFrame(\n            [(np.nan, pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        tm.assert_frame_equal(df1, expected_df)\n\n    def test_replace_list(self):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [v1, v2, ..., vN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\".\", r\"e\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [v1, v2, ..., vN] -> [v1, v2, .., vN]\n        to_replace_res = [r\".\", r\"f\"]\n        values = [r\"..\", r\"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e\", \"crap\", \"g\", \"h\"],\n                \"c\": [\"h\", \"e\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n    def test_replace_with_empty_list(self):\n        # GH 21977\n        s = pd.Series([[\"a\", \"b\"], [], np.nan, [1]])\n        df = pd.DataFrame({\"col\": s})\n        expected = df\n        result = df.replace([], np.nan)\n        tm.assert_frame_equal(result, expected)\n\n        # GH 19266\n        with pytest.raises(ValueError, match=\"cannot assign mismatch\"):\n            df.replace({np.nan: []})\n        with pytest.raises(ValueError, match=\"cannot assign mismatch\"):\n            df.replace({np.nan: [\"dummy\", \"alt\"]})\n\n    def test_replace_series_dict(self):\n        # from GH 3064\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        result = df.replace(0, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 1.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, df.mean())\n        tm.assert_frame_equal(result, expected)\n\n        # series to series/dict\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        s = Series({\"zero\": 0.0, \"one\": 2.0})\n        result = df.replace(s, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 1.0, \"b\": 0.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(s, df.mean())\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_convert(self):\n        # gh 3907\n        df = DataFrame([[\"foo\", \"bar\", \"bah\"], [\"bar\", \"foo\", \"bah\"]])\n        m = {\"foo\": 1, \"bar\": 2, \"bah\": 3}\n        rep = df.replace(m)\n        expec = Series([np.int64] * 3)\n        res = rep.dtypes\n        tm.assert_series_equal(expec, res)\n\n    def test_replace_mixed(self, float_string_frame):\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, -18)\n        expected = float_string_frame.fillna(value=-18)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-18, np.nan), float_string_frame)\n\n        result = float_string_frame.replace(np.nan, -1e8)\n        expected = float_string_frame.fillna(value=-1e8)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-1e8, np.nan), float_string_frame)\n\n        # int block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n        df.replace(0, 0.5, inplace=True)\n        tm.assert_frame_equal(df, expected)\n\n        # int block splitting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n        # to object block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1, \"foo\"], dtype=\"object\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(2, \"foo\")\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            {\n                \"A\": Series([\"foo\", \"bar\"], dtype=\"object\"),\n                \"B\": Series([0, \"foo\"], dtype=\"object\"),\n            }\n        )\n        result = df.replace([1, 2], [\"foo\", \"bar\"])\n        tm.assert_frame_equal(result, expected)\n\n        # test case from\n        df = DataFrame(\n            {\"A\": Series([3, 0], dtype=\"int64\"), \"B\": Series([0, 3], dtype=\"int64\")}\n        )\n        result = df.replace(3, df.mean().to_dict())\n        expected = df.copy().astype(\"float64\")\n        m = df.mean()\n        expected.iloc[0, 0] = m[0]\n        expected.iloc[1, 1] = m[1]\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_simple_nested_dict(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({\"col\": {1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)\n\n        # in this case, should be the same as the not nested version\n        result = df.replace({1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)\n\n    def test_replace_simple_nested_dict_with_nonexistent_value(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({-1: \"-\", 1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)\n\n        result = df.replace({\"col\": {-1: \"-\", 1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)\n\n    def test_replace_value_is_none(self, datetime_frame):\n        orig_value = datetime_frame.iloc[0, 0]\n        orig2 = datetime_frame.iloc[1, 0]\n\n        datetime_frame.iloc[0, 0] = np.nan\n        datetime_frame.iloc[1, 0] = 1\n\n        result = datetime_frame.replace(to_replace={np.nan: 0})\n        expected = datetime_frame.T.replace(to_replace={np.nan: 0}).T\n        tm.assert_frame_equal(result, expected)\n\n        result = datetime_frame.replace(to_replace={np.nan: 0, 1: -1e8})\n        tsframe = datetime_frame.copy()\n        tsframe.iloc[0, 0] = 0\n        tsframe.iloc[1, 0] = -1e8\n        expected = tsframe\n        tm.assert_frame_equal(expected, result)\n        datetime_frame.iloc[0, 0] = orig_value\n        datetime_frame.iloc[1, 0] = orig2\n\n    def test_replace_for_new_dtypes(self, datetime_frame):\n\n        # dtypes\n        tsframe = datetime_frame.copy().astype(np.float32)\n        tsframe[\"A\"][:5] = np.nan\n        tsframe[\"A\"][-5:] = np.nan\n\n        zero_filled = tsframe.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, tsframe.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), tsframe)\n\n        tsframe[\"A\"][:5] = np.nan\n        tsframe[\"A\"][-5:] = np.nan\n        tsframe[\"B\"][:5] = -1e8\n\n        b = tsframe[\"B\"]\n        b[b == -1e8] = np.nan\n        tsframe[\"B\"] = b\n        result = tsframe.fillna(method=\"bfill\")\n        tm.assert_frame_equal(result, tsframe.fillna(method=\"bfill\"))\n\n    @pytest.mark.parametrize(\n        \"frame, to_replace, value, expected\",\n        [\n            (DataFrame({\"ints\": [1, 2, 3]}), 1, 0, DataFrame({\"ints\": [0, 2, 3]})),\n            (\n                DataFrame({\"ints\": [1, 2, 3]}, dtype=np.int32),\n                1,\n                0,\n                DataFrame({\"ints\": [0, 2, 3]}, dtype=np.int32),\n            ),\n            (\n                DataFrame({\"ints\": [1, 2, 3]}, dtype=np.int16),\n                1,\n                0,\n                DataFrame({\"ints\": [0, 2, 3]}, dtype=np.int16),\n            ),\n            (\n                DataFrame({\"bools\": [True, False, True]}),\n                False,\n                True,\n                DataFrame({\"bools\": [True, True, True]}),\n            ),\n            (\n                DataFrame({\"complex\": [1j, 2j, 3j]}),\n                1j,\n                0,\n                DataFrame({\"complex\": [0j, 2j, 3j]}),\n            ),\n            (\n                DataFrame(\n                    {\n                        \"datetime64\": Index(\n                            [\n                                datetime(2018, 5, 28),\n                                datetime(2018, 7, 28),\n                                datetime(2018, 5, 28),\n                            ]\n                        )\n                    }\n                ),\n                datetime(2018, 5, 28),\n                datetime(2018, 7, 28),\n                DataFrame({\"datetime64\": Index([datetime(2018, 7, 28)] * 3)}),\n            ),\n            # GH 20380\n            (\n                DataFrame({\"dt\": [datetime(3017, 12, 20)], \"str\": [\"foo\"]}),\n                \"foo\",\n                \"bar\",\n                DataFrame({\"dt\": [datetime(3017, 12, 20)], \"str\": [\"bar\"]}),\n            ),\n            (\n                DataFrame(\n                    {\n                        \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                        \"B\": [0, np.nan, 2],\n                    }\n                ),\n                Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                DataFrame(\n                    {\n                        \"A\": [\n                            Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                            Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                            Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                        ],\n                        \"B\": [0, np.nan, 2],\n                    }\n                ),\n            ),\n        ],\n    )\n    def test_replace_dtypes(self, frame, to_replace, value, expected):\n        result = getattr(frame, \"replace\")(to_replace, value)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_input_formats_listlike(self):\n        # both dicts\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(to_rep, values)\n        expected = {k: v.replace(to_rep[k], values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        result = df.replace([0, 2, 5], [5, 2, 0])\n        expected = DataFrame(\n            {\"A\": [np.nan, 5, np.inf], \"B\": [5, 2, 0], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # scalar to dict\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.nan], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(np.nan, values)\n        expected = {k: v.replace(np.nan, values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        # list to list\n        to_rep = [np.nan, 0, \"\"]\n        values = [-2, -1, \"missing\"]\n        result = df.replace(to_rep, values)\n        expected = df.copy()\n        for i in range(len(to_rep)):\n            expected.replace(to_rep[i], values[i], inplace=True)\n        tm.assert_frame_equal(result, expected)\n\n        msg = r\"Replacement lists must match in length\\. Expecting 3 got 2\"\n        with pytest.raises(ValueError, match=msg):\n            df.replace(to_rep, values[1:])\n\n    def test_replace_input_formats_scalar(self):\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n\n        # dict to scalar\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        filled = df.replace(to_rep, 0)\n        expected = {k: v.replace(to_rep[k], 0) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        msg = \"value argument must be scalar, dict, or Series\"\n        with pytest.raises(TypeError, match=msg):\n            df.replace(to_rep, [np.nan, 0, \"\"])\n\n        # list to scalar\n        to_rep = [np.nan, 0, \"\"]\n        result = df.replace(to_rep, -1)\n        expected = df.copy()\n        for i in range(len(to_rep)):\n            expected.replace(to_rep[i], -1, inplace=True)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_limit(self):\n        pass\n\n    def test_replace_dict_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = {\n            \"Agree\": 4,\n            \"Disagree\": 2,\n            \"Neutral\": 3,\n            \"Strongly Agree\": 5,\n            \"Strongly Disagree\": 1,\n        }\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)\n\n    def test_replace_series_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = Series(\n            {\n                \"Agree\": 4,\n                \"Disagree\": 2,\n                \"Neutral\": 3,\n                \"Strongly Agree\": 5,\n                \"Strongly Disagree\": 1,\n            }\n        )\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)\n\n    def test_replace_dict_tuple_list_ordering_remains_the_same(self):\n        df = DataFrame(dict(A=[np.nan, 1]))\n        res1 = df.replace(to_replace={np.nan: 0, 1: -1e8})\n        res2 = df.replace(to_replace=(1, np.nan), value=[-1e8, 0])\n        res3 = df.replace(to_replace=[1, np.nan], value=[-1e8, 0])\n\n        expected = DataFrame({\"A\": [0, -1e8]})\n        tm.assert_frame_equal(res1, res2)\n        tm.assert_frame_equal(res2, res3)\n        tm.assert_frame_equal(res3, expected)\n\n    def test_replace_doesnt_replace_without_regex(self):\n        raw = \"\"\"fol T_opp T_Dir T_Enh\n        0    1     0     0    vo\n        1    2    vr     0     0\n        2    2     0     0     0\n        3    3     0    bt     0\"\"\"\n        df = pd.read_csv(StringIO(raw), sep=r\"\\s+\")\n        res = df.replace({r\"\\D\": 1})\n        tm.assert_frame_equal(df, res)\n\n    def test_replace_bool_with_string(self):\n        df = DataFrame({\"a\": [True, False], \"b\": list(\"ab\")})\n        result = df.replace(True, \"a\")\n        expected = DataFrame({\"a\": [\"a\", False], \"b\": df.b})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_pure_bool_with_string_no_op(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(\"asdf\", \"fdsa\")\n        tm.assert_frame_equal(df, result)\n\n    def test_replace_bool_with_bool(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(False, True)\n        expected = DataFrame(np.ones((2, 2), dtype=bool))\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_dict_with_bool_keys(self):\n        df = DataFrame({0: [True, False], 1: [False, True]})\n        with pytest.raises(TypeError, match=\"Cannot compare types .+\"):\n            df.replace({\"asdf\": \"asdb\", True: \"yes\"})\n\n    def test_replace_truthy(self):\n        df = DataFrame({\"a\": [True, True]})\n        r = df.replace([np.inf, -np.inf], np.nan)\n        e = df\n        tm.assert_frame_equal(r, e)\n\n    def test_nested_dict_overlapping_keys_replace_int(self):\n        # GH 27660 keep behaviour consistent for simple dictionary and\n        # nested dictionary replacement\n        df = DataFrame({\"a\": list(range(1, 5))})\n\n        result = df.replace({\"a\": dict(zip(range(1, 5), range(2, 6)))})\n        expected = df.replace(dict(zip(range(1, 5), range(2, 6))))\n        tm.assert_frame_equal(result, expected)\n\n    def test_nested_dict_overlapping_keys_replace_str(self):\n        # GH 27660\n        a = np.arange(1, 5)\n        astr = a.astype(str)\n        bstr = np.arange(2, 6).astype(str)\n        df = DataFrame({\"a\": astr})\n        result = df.replace(dict(zip(astr, bstr)))\n        expected = df.replace({\"a\": dict(zip(astr, bstr))})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_swapping_bug(self):\n        df = pd.DataFrame({\"a\": [True, False, True]})\n        res = df.replace({\"a\": {True: \"Y\", False: \"N\"}})\n        expect = pd.DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)\n\n        df = pd.DataFrame({\"a\": [0, 1, 0]})\n        res = df.replace({\"a\": {0: \"Y\", 1: \"N\"}})\n        expect = pd.DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)\n\n    def test_replace_period(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": pd.Period(year=2011, month=8, freq=\"M\"),\n                \"out_augmented_JAN_2011.json\": pd.Period(year=2011, month=1, freq=\"M\"),\n                \"out_augmented_MAY_2012.json\": pd.Period(year=2012, month=5, freq=\"M\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": pd.Period(\n                    year=2011, month=4, freq=\"M\"\n                ),\n                \"out_augmented_AUG_2012.json\": pd.Period(year=2012, month=8, freq=\"M\"),\n                \"out_augmented_MAY_2011.json\": pd.Period(year=2011, month=5, freq=\"M\"),\n                \"out_augmented_SEP_2013.json\": pd.Period(year=2013, month=9, freq=\"M\"),\n            }\n        }\n\n        df = pd.DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n        # We don't support converting object -> specialized EA in\n        # replace yet.\n        expected = DataFrame(\n            {\"fname\": [d[\"fname\"][k] for k in df.fname.values]}, dtype=object\n        )\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_datetime(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": pd.Timestamp(\"2011-08\"),\n                \"out_augmented_JAN_2011.json\": pd.Timestamp(\"2011-01\"),\n                \"out_augmented_MAY_2012.json\": pd.Timestamp(\"2012-05\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": pd.Timestamp(\"2011-04\"),\n                \"out_augmented_AUG_2012.json\": pd.Timestamp(\"2012-08\"),\n                \"out_augmented_MAY_2011.json\": pd.Timestamp(\"2011-05\"),\n                \"out_augmented_SEP_2013.json\": pd.Timestamp(\"2013-09\"),\n            }\n        }\n\n        df = pd.DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n        expected = DataFrame({\"fname\": [d[\"fname\"][k] for k in df.fname.values]})\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_datetimetz(self):\n\n        # GH 11326\n        # behaving poorly when presented with a datetime64[ns, tz]\n        df = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        result = df.replace(np.nan, 1)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": Series([0, 1, 2], dtype=\"float64\"),\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.fillna(1)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, np.nan)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [np.nan, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(\n            Timestamp(\"20130102\", tz=\"US/Eastern\"),\n            Timestamp(\"20130104\", tz=\"US/Eastern\"),\n        )\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Eastern\"))\n        tm.assert_frame_equal(result, expected)\n\n        # coerce to object\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Pacific\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Pacific\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": np.nan}, Timestamp(\"20130104\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_empty_dictlike(self, mix_abc):\n        # GH 15289\n        df = DataFrame(mix_abc)\n        tm.assert_frame_equal(df, df.replace({}))\n        tm.assert_frame_equal(df, df.replace(Series([], dtype=object)))\n\n        tm.assert_frame_equal(df, df.replace({\"b\": {}}))\n        tm.assert_frame_equal(df, df.replace(Series({\"b\": {}})))\n\n    @pytest.mark.parametrize(\n        \"to_replace, method, expected\",\n        [\n            (0, \"bfill\", {\"A\": [1, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]}),\n            (\n                np.nan,\n                \"bfill\",\n                {\"A\": [0, 1, 2], \"B\": [5.0, 7.0, 7.0], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\"d\", \"ffill\", {\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]}),\n            (\n                [0, 2],\n                \"bfill\",\n                {\"A\": [1, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                [1, 2],\n                \"pad\",\n                {\"A\": [0, 0, 0], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                (1, 2),\n                \"bfill\",\n                {\"A\": [0, 2, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                [\"b\", \"c\"],\n                \"ffill\",\n                {\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"a\", \"a\"]},\n            ),\n        ],\n    )\n    def test_replace_method(self, to_replace, method, expected):\n        # GH 19632\n        df = DataFrame({\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]})\n\n        result = df.replace(to_replace=to_replace, value=None, method=method)\n        expected = DataFrame(expected)\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n\n        final_data = np.array(final_data)\n\n        a = pd.Categorical(final_data[:, 0], categories=[3, 2])\n\n        excat = [3, 2] if replace_dict[\"b\"] == 1 else [1, 3]\n        b = pd.Categorical(final_data[:, 1], categories=excat)\n\n        expected = DataFrame({\"a\": a, \"b\": b})\n        result = df.replace(replace_dict, 3)\n        tm.assert_frame_equal(result, expected)\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_frame_equal(df, expected)\n        df.replace(replace_dict, 3, inplace=True)\n        tm.assert_frame_equal(df, expected)\n\n    @pytest.mark.parametrize(\n        \"df, to_replace, exp\",\n        [\n            (\n                {\"col1\": [1, 2, 3], \"col2\": [4, 5, 6]},\n                {4: 5, 5: 6, 6: 7},\n                {\"col1\": [1, 2, 3], \"col2\": [5, 6, 7]},\n            ),\n            (\n                {\"col1\": [1, 2, 3], \"col2\": [\"4\", \"5\", \"6\"]},\n                {\"4\": \"5\", \"5\": \"6\", \"6\": \"7\"},\n                {\"col1\": [1, 2, 3], \"col2\": [\"5\", \"6\", \"7\"]},\n            ),\n        ],\n    )\n    def test_replace_commutative(self, df, to_replace, exp):\n        # GH 16051\n        # DataFrame.replace() overwrites when values are non-numeric\n        # also added to data frame whilst issue was for series\n\n        df = pd.DataFrame(df)\n\n        expected = pd.DataFrame(exp)\n        result = df.replace(to_replace)\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"replacer\",\n        [\n            pd.Timestamp(\"20170827\"),\n            np.int8(1),\n            np.int16(1),\n            np.float32(1),\n            np.float64(1),\n        ],\n    )\n    def test_replace_replacer_dtype(self, replacer):\n        # GH26632\n        df = pd.DataFrame([\"a\"])\n        result = df.replace({\"a\": replacer, \"b\": replacer})\n        expected = pd.DataFrame([replacer])\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_after_convert_dtypes(self):\n        # GH31517\n        df = pd.DataFrame({\"grp\": [1, 2, 3, 4, 5]}, dtype=\"Int64\")\n        result = df.replace(1, 10)\n        expected = pd.DataFrame({\"grp\": [10, 2, 3, 4, 5]}, dtype=\"Int64\")\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_invalid_to_replace(self):\n        # GH 18634\n        # API: replace() should raise an exception if invalid argument is given\n        df = pd.DataFrame({\"one\": [\"a\", \"b \", \"c\"], \"two\": [\"d \", \"e \", \"f \"]})\n        msg = (\n            r\"Expecting 'to_replace' to be either a scalar, array-like, \"\n            r\"dict or None, got invalid type.*\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.replace(lambda x: x.strip())\n\n    @pytest.mark.parametrize(\"dtype\", [\"float\", \"float64\", \"int64\", \"Int64\", \"boolean\"])\n    @pytest.mark.parametrize(\"value\", [np.nan, pd.NA])\n    def test_replace_no_replacement_dtypes(self, dtype, value):\n        # https://github.com/pandas-dev/pandas/issues/32988\n        df = pd.DataFrame(np.eye(2), dtype=dtype)\n        result = df.replace(to_replace=[None, -np.inf, np.inf], value=value)\n        tm.assert_frame_equal(result, df)\n\n    @pytest.mark.parametrize(\"replacement\", [np.nan, 5])\n    def test_replace_with_duplicate_columns(self, replacement):\n        # GH 24798\n        result = pd.DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\n        result.columns = list(\"AAB\")\n\n        expected = pd.DataFrame(\n            {\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [replacement, 8, 9]}\n        )\n        expected.columns = list(\"AAB\")\n\n        result[\"B\"] = result[\"B\"].replace(7, replacement)\n\n        tm.assert_frame_equal(result, expected)\n"
    }
  ]
}