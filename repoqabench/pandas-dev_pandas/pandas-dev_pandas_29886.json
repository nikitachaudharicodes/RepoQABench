{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "29886",
  "issue_description": "# Replace \"foo!r\" to \"repr(foo)\" syntax\n\nSince we are moving to f-strings and dropping old strings formats (```%``` and ```.format()```), we no longer need to have the redundant ```%r``` and ```!r``` specifiers, instead we use the ```repr()``` format.\r\n\r\n#### Notes:\r\n* Don't forget to link this issue in your PR, paste this ```https://github.com/pandas-dev/pandas/issues/29886``` in your PR.\r\n\r\n* If any of your changed files are related to #29547 , please make sure to link your pull request to that issue as well, simply paste this ```https://github.com/pandas-dev/pandas/issues/29547``` in your pull request's body message as well.\r\n\r\n* Please comment what you are planning to work on, so we won't do double work.\r\n\r\n* If a file/files that should be marked as done, is'nt marked, please comment letting me know.\r\n\r\n---\r\n\r\nTo check what files still needs to be fixed in the \"pandas\" directory:\r\n```\r\ngrep -R -e '%r' -e '!r}' -e \"'{}'\" --include=*.{py,pyx} pandas/\r\n```\r\n\r\n##### Tip:\r\nIf you want to see the line number of the occurrence, replace the ```-l``` with ```-n```\r\nfor example:\r\n```\r\ngrep -n -R '%r' --include=*.{py,pyx} pandas/\r\n```\r\n\r\n---\r\n\r\n### The current list is:\r\n\r\n- [x] ci/print_skipped.py\r\n\r\n- [x] pandas/_config/config.py\r\n\r\n- [x] pandas/conftest.py\r\n\r\n- [x] pandas/core/accessor.py\r\n\r\n- [x] pandas/core/algorithms.py\r\n\r\n- [x] pandas/core/arrays/categorical.py\r\n\r\n- [ ] pandas/core/arrays/datetimelike.py\r\n\r\n- [ ] pandas/core/arrays/period.py\r\n\r\n- [x] pandas/core/arrays/numpy_.py\r\n\r\n- [x] pandas/core/computation/align.py\r\n\r\n- [x] pandas/core/computation/eval.py\r\n\r\n- [x] pandas/core/computation/expressions.py\r\n\r\n- [x] pandas/core/computation/expr.py\r\n\r\n- [x] pandas/core/computation/ops.py\r\n\r\n- [x] pandas/core/computation/pytables.py\r\n\r\n- [x] pandas/core/dtypes/common.py\r\n\r\n- [x] pandas/core/dtypes/dtypes.py\r\n\r\n- [x] pandas/core/frame.py\r\n\r\n- [x] pandas/core/generic.py\r\n\r\n- [x] pandas/core/groupby/grouper.py\r\n\r\n- [x] pandas/core/indexes/base.py\r\n\r\n- [x] pandas/core/indexes/datetimelike.py\r\n\r\n- [x] pandas/core/indexes/interval.py\r\n\r\n- [x] pandas/core/indexes/numeric.py\r\n\r\n- [x] pandas/core/internals/concat.py\r\n\r\n- [x] pandas/core/internals/managers.py\r\n\r\n- [x] pandas/core/missing.py\r\n\r\n- [x] pandas/core/nanops.py\r\n\r\n- [x] pandas/core/reshape/concat.py\r\n\r\n- [x] pandas/core/reshape/merge.py\r\n\r\n- [x] pandas/core/reshape/tile.py\r\n\r\n- [x] pandas/core/series.py\r\n\r\n- [x] pandas/core/sorting.py\r\n\r\n- [x] pandas/core/strings.py\r\n\r\n- [x] pandas/core/window/rolling.py\r\n\r\n- [x] pandas/\\_\\_init\\_\\_.py\r\n\r\n- [x] pandas/io/formats/css.py\r\n\r\n- [x] pandas/io/formats/excel.py\r\n\r\n- [ ] pandas/io/formats/style.py\r\n\r\n- [x] pandas/io/html.py\r\n\r\n- [x] pandas/io/parsers.py\r\n\r\n- [x] pandas/_libs/interval.pyx\r\n\r\n- [x] pandas/plotting/_core.py\r\n\r\n- [x] pandas/tests/computation/test_eval.py\r\n\r\n- [x] pandas/tests/frame/test_alter_axes.py\r\n\r\n- [x] pandas/tests/frame/test_analytics.py\r\n\r\n- [x] pandas/tests/frame/test_query_eval.py\r\n\r\n- [x] pandas/tests/groupby/test_whitelist.py\r\n\r\n- [x] pandas/tests/indexes/datetimes/test_datetime.py\r\n\r\n- [x] pandas/tests/indexes/multi/test_integrity.py\r\n\r\n- [x] pandas/tests/indexes/period/test_period.py\r\n\r\n- [x] pandas/tests/indexes/test_common.py\r\n\r\n- [ ] pandas/tests/indexes/timedeltas/test_timedelta.py\r\n\r\n- [x] pandas/tests/io/msgpack/test_case.py\r\n\r\n- [x] pandas/tests/io/msgpack/test_extension.py\r\n\r\n- [x] pandas/tests/io/parser/test_unsupported.py\r\n\r\n- [x] pandas/tests/io/test_html.py\r\n\r\n- [x] pandas/tests/test_expressions.py\r\n\r\n- [x] pandas/tests/test_strings.py\r\n\r\n- [ ] pandas/tests/io/test_sql.py\r\n\r\n- [ ] pandas/tests/reshape/test_concat.py\r\n\r\n- [ ] pandas/tests/scalar/timedelta/test_timedelta.py\r\n\r\n- [x] pandas/tests/series/test_missing.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_fiscal.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_offsets.py\r\n\r\n- [x] pandas/tseries/offsets.py\r\n\r\n- [x] pandas/util/_decorators.py\r\n\r\n- [x] pandas/util/_test_decorators.py\r\n\r\n- [x] pandas/util/testing.py\r\n\r\n- [x] pandas/_version.py\r\n\r\n- [ ] /scripts/tests/test_validate_docstrings.py\r\n---\r\n\r\n#### Lastly:\r\n- [ ] Add a test case (so we won't regress)",
  "issue_comments": [
    {
      "id": 559283675,
      "user": "jbrockmendel",
      "body": "Another option that we use in quite a few places is single quotes `\"foo '{bar}' baz\"`"
    },
    {
      "id": 559286832,
      "user": "ShaharNaveh",
      "body": "> Another option that we use in quite a few places is single quotes `\"foo '{bar}' baz\"`\r\n\r\n@jbrockmendel I'm kinda obligated about how to find them systemically, meaning what if there's is a change to the ```repr()``` function, and the single quotas are there to differ from the ```repr()``` (If they're any). plus I'm not sure how to grep for this pattern."
    },
    {
      "id": 559963070,
      "user": "ShaharNaveh",
      "body": "I'll take:\r\n\r\n- [x] pandas/tests/tseries/offsets/test_fiscal.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_offsets.py\r\n\r\n- [x] pandas/tseries/offsets.py\r\n\r\n- [x] pandas/util/testing.py"
    },
    {
      "id": 561191826,
      "user": "souravs17031999",
      "body": "working on :\r\n- [x] pandas/core/sorting.py\r\n- [x] pandas/core/string.py\r\n- [x] pandas/core/series.py\r\n\r\ncurrently if no one has taken it yet.\r\nwill add more as i go further."
    },
    {
      "id": 561369524,
      "user": "kvn219",
      "body": "Working on: `pandas/core/sorting.py`\r\n\r\n"
    },
    {
      "id": 561473299,
      "user": "souravs17031999",
      "body": "hi @kvn219 , actually i am already working on three files one of which is what you have also mentioned , can you please work on some other file."
    },
    {
      "id": 561844414,
      "user": "JvPy",
      "body": "I`ll take \r\n\r\npandas/pandas/io/parsers.py\r\n\r\npandas/pandas/io/html.py"
    },
    {
      "id": 562346291,
      "user": "EydenVillanueva",
      "body": "Hi to everyone, I will take:\r\n\r\n- `pandas/_config/config.py`\r\n- `pandas/conftest.py`\r\n- `pandas/core/accessor.py`\r\n- `pandas/core/algorithms.py`\r\n\r\n"
    },
    {
      "id": 562414212,
      "user": "JvPy",
      "body": "Ill take \r\ncore/indexes/numeric.py\r\ncore/frame.py \r\n\r\nif possible.\r\n\r\nIll do them on saturday"
    },
    {
      "id": 562852768,
      "user": "nigeltart",
      "body": "I'm working on pandas/core/arrays/numpy_.py"
    },
    {
      "id": 562856674,
      "user": "chrisateen",
      "body": "I am going to do pandas/utils/_test_decorators.py which is not on the original list but seems not to be updated"
    },
    {
      "id": 562860071,
      "user": "ShaharNaveh",
      "body": "> I am going to do pandas/utils/_test_decorators.py which is not on the original list but seems not to be updated\r\n\r\nThanks @chrisateen "
    },
    {
      "id": 562871082,
      "user": "nigeltart",
      "body": "> I'm working on pandas/core/arrays/numpy_.py\r\n\r\nSorry, it was literally my first attempt at a pull request. I'll come back when I know enough to help. Cheers"
    },
    {
      "id": 564126375,
      "user": "EydenVillanueva",
      "body": "> Hi to everyone, I will take:\r\n> \r\n> * `pandas/_config/config.py`\r\n> * `pandas/conftest.py`\r\n> * `pandas/core/accessor.py`\r\n> * `pandas/core/algorithms.py`\r\n\r\nThese files were already finished with the replacement (it would be good if they appear checked in the list).\r\n\r\nSo I will take the following files to work with:\r\n\r\n- `pandas/tests/indexes/datetimes/test_partial_slicing.py` (not on the list, but not updated)\r\n- `pandas/core/nanops.py`\r\n- `pandas/core/missing.py`\r\n- `pandas/core/indexes/period.py` (not on the list, but not updated)\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
      "id": 564796650,
      "user": "lithomas1",
      "body": "I'm taking\r\n- [x] pandas/io/formats/excel.py\r\n- [x] pandas/io/formats/css.py\r\n- [x] pandas/io/formats/style.py\r\n"
    },
    {
      "id": 566374067,
      "user": "AncientRickles",
      "body": "I'll do:\r\n* [x] pandas/tests/test_expressions.py\r\n\r\nNot needed (according to grep expression):\r\n- pandas/core/indexes/numeric.py\r\n- pandas/core/indexes/interval.py\r\n- pandas/core/computation/eval.py\r\n- pandas/core/reshape/tile.py\r\n- pandas/core/indexes/base.py\r\n\r\nIf you run the grep string, there do not appear to be any more %r or !r's present.  \r\n\r\nThanks for the simple issue.  This was my first contribution to an open source project, as minimal as it is at this point. I have learned a lot."
    },
    {
      "id": 568231361,
      "user": "AncientRickles",
      "body": "Jumping on:\r\n* [ ] pandas/core/arrays/datetimelike.py\r\n* [x] pandas/io/formats/printing.py\r\n* [x] pandas/tests/extension/list/array.py\r\n* [x] pandas/tests/indexes/datetimes/test_ops.py\r\n* [x] pandas/tests/indexes/multi/test_analytics.py"
    },
    {
      "id": 568397567,
      "user": "ShaharNaveh",
      "body": "@WillAyd Can you please reopen this issue?\r\n\r\nIn [this PR](https://github.com/pandas-dev/pandas/pull/30420) there is a use of the word ```fix``` and after that this PR number, so it closed it."
    },
    {
      "id": 568399348,
      "user": "WillAyd",
      "body": "done - thanks!"
    },
    {
      "id": 568730494,
      "user": "AncientRickles",
      "body": "> @WillAyd Can you please reopen this issue?\r\n> \r\n> In [this PR](https://github.com/pandas-dev/pandas/pull/30420) there is a use of the word `fix` and after that this PR number, so it closed it.\r\n\r\nSorry about that. Still kinda new to this..."
    },
    {
      "id": 568740826,
      "user": "ShaharNaveh",
      "body": "> Sorry about that. Still kinda new to this...\r\n\r\nIt's perfectly fine :)"
    },
    {
      "id": 568919876,
      "user": "naomi172839",
      "body": "pandas/tests/test_strings.py was checked and already uses f-strings.\r\npandas/core/dtypes/common.py was checked and already uses f-strings.\r\npandas/tests/indexes/test_common.py was checked and already uses f-strings.\r\npandas/core/window/rolling.py was checked and already uses f-strings.\r\npandas/core/computation/pytables.py was checked and already uses f-strings.\r\npandas/tests/indexes/datetimes/test_datetime.py was checked and already uses f-strings.\r\npandas/core/generic.py was checked and already uses f-strings.\r\n\r\nIf possible, it would be great to update the master list.\r\n\r\n"
    },
    {
      "id": 568920082,
      "user": "ShaharNaveh",
      "body": "> pandas/tests/test_strings.py was checked and already uses f-strings.\r\n> pandas/core/dtypes/common.py was checked and already uses f-strings.\r\n> pandas/tests/indexes/test_common.py was checked and already uses f-strings.\r\n> pandas/core/window/rolling.py was checked and already uses f-strings.\r\n> pandas/core/computation/pytables.py was checked and already uses f-strings.\r\n> pandas/tests/indexes/datetimes/test_datetime.py was checked and already uses f-strings.\r\n> pandas/core/generic.py was checked and already uses f-strings.\r\n> \r\n> If possible, it would be great to update the master list.\r\n\r\nTY, really appreciate it"
    },
    {
      "id": 568935580,
      "user": "ShaharNaveh",
      "body": "@jreback Can you please reopen this issue?\r\n\r\nThe PR was suppose to contain two test cases, but it only contained one.\r\n\r\nThis should be reopen."
    },
    {
      "id": 568936525,
      "user": "ShaharNaveh",
      "body": "Thanks @jreback "
    },
    {
      "id": 568939917,
      "user": "naomi172839",
      "body": "pandas/core/arrays/datetimelike.py\r\npandas/core/arrays/period.py\r\n\r\nBoth of the above are free of the old style strings.\r\nI am working on:\r\npandas/__init__.py"
    },
    {
      "id": 569194197,
      "user": "naomi172839",
      "body": "I tackled the remaining files.  Did not implement a test though."
    },
    {
      "id": 569742549,
      "user": "TomAugspurger",
      "body": "So the only remaining item is a code check test for `!r` rather than repr?"
    },
    {
      "id": 569742681,
      "user": "TomAugspurger",
      "body": "Actually, it looks like we have a check for that. @MomIsBestFriend is there anything else to do here?"
    },
    {
      "id": 569780198,
      "user": "ShaharNaveh",
      "body": "@TomAugspurger I think not :smiley: \r\n\r\nThank you all for helping :heart: "
    }
  ],
  "text_context": "# Replace \"foo!r\" to \"repr(foo)\" syntax\n\nSince we are moving to f-strings and dropping old strings formats (```%``` and ```.format()```), we no longer need to have the redundant ```%r``` and ```!r``` specifiers, instead we use the ```repr()``` format.\r\n\r\n#### Notes:\r\n* Don't forget to link this issue in your PR, paste this ```https://github.com/pandas-dev/pandas/issues/29886``` in your PR.\r\n\r\n* If any of your changed files are related to #29547 , please make sure to link your pull request to that issue as well, simply paste this ```https://github.com/pandas-dev/pandas/issues/29547``` in your pull request's body message as well.\r\n\r\n* Please comment what you are planning to work on, so we won't do double work.\r\n\r\n* If a file/files that should be marked as done, is'nt marked, please comment letting me know.\r\n\r\n---\r\n\r\nTo check what files still needs to be fixed in the \"pandas\" directory:\r\n```\r\ngrep -R -e '%r' -e '!r}' -e \"'{}'\" --include=*.{py,pyx} pandas/\r\n```\r\n\r\n##### Tip:\r\nIf you want to see the line number of the occurrence, replace the ```-l``` with ```-n```\r\nfor example:\r\n```\r\ngrep -n -R '%r' --include=*.{py,pyx} pandas/\r\n```\r\n\r\n---\r\n\r\n### The current list is:\r\n\r\n- [x] ci/print_skipped.py\r\n\r\n- [x] pandas/_config/config.py\r\n\r\n- [x] pandas/conftest.py\r\n\r\n- [x] pandas/core/accessor.py\r\n\r\n- [x] pandas/core/algorithms.py\r\n\r\n- [x] pandas/core/arrays/categorical.py\r\n\r\n- [ ] pandas/core/arrays/datetimelike.py\r\n\r\n- [ ] pandas/core/arrays/period.py\r\n\r\n- [x] pandas/core/arrays/numpy_.py\r\n\r\n- [x] pandas/core/computation/align.py\r\n\r\n- [x] pandas/core/computation/eval.py\r\n\r\n- [x] pandas/core/computation/expressions.py\r\n\r\n- [x] pandas/core/computation/expr.py\r\n\r\n- [x] pandas/core/computation/ops.py\r\n\r\n- [x] pandas/core/computation/pytables.py\r\n\r\n- [x] pandas/core/dtypes/common.py\r\n\r\n- [x] pandas/core/dtypes/dtypes.py\r\n\r\n- [x] pandas/core/frame.py\r\n\r\n- [x] pandas/core/generic.py\r\n\r\n- [x] pandas/core/groupby/grouper.py\r\n\r\n- [x] pandas/core/indexes/base.py\r\n\r\n- [x] pandas/core/indexes/datetimelike.py\r\n\r\n- [x] pandas/core/indexes/interval.py\r\n\r\n- [x] pandas/core/indexes/numeric.py\r\n\r\n- [x] pandas/core/internals/concat.py\r\n\r\n- [x] pandas/core/internals/managers.py\r\n\r\n- [x] pandas/core/missing.py\r\n\r\n- [x] pandas/core/nanops.py\r\n\r\n- [x] pandas/core/reshape/concat.py\r\n\r\n- [x] pandas/core/reshape/merge.py\r\n\r\n- [x] pandas/core/reshape/tile.py\r\n\r\n- [x] pandas/core/series.py\r\n\r\n- [x] pandas/core/sorting.py\r\n\r\n- [x] pandas/core/strings.py\r\n\r\n- [x] pandas/core/window/rolling.py\r\n\r\n- [x] pandas/\\_\\_init\\_\\_.py\r\n\r\n- [x] pandas/io/formats/css.py\r\n\r\n- [x] pandas/io/formats/excel.py\r\n\r\n- [ ] pandas/io/formats/style.py\r\n\r\n- [x] pandas/io/html.py\r\n\r\n- [x] pandas/io/parsers.py\r\n\r\n- [x] pandas/_libs/interval.pyx\r\n\r\n- [x] pandas/plotting/_core.py\r\n\r\n- [x] pandas/tests/computation/test_eval.py\r\n\r\n- [x] pandas/tests/frame/test_alter_axes.py\r\n\r\n- [x] pandas/tests/frame/test_analytics.py\r\n\r\n- [x] pandas/tests/frame/test_query_eval.py\r\n\r\n- [x] pandas/tests/groupby/test_whitelist.py\r\n\r\n- [x] pandas/tests/indexes/datetimes/test_datetime.py\r\n\r\n- [x] pandas/tests/indexes/multi/test_integrity.py\r\n\r\n- [x] pandas/tests/indexes/period/test_period.py\r\n\r\n- [x] pandas/tests/indexes/test_common.py\r\n\r\n- [ ] pandas/tests/indexes/timedeltas/test_timedelta.py\r\n\r\n- [x] pandas/tests/io/msgpack/test_case.py\r\n\r\n- [x] pandas/tests/io/msgpack/test_extension.py\r\n\r\n- [x] pandas/tests/io/parser/test_unsupported.py\r\n\r\n- [x] pandas/tests/io/test_html.py\r\n\r\n- [x] pandas/tests/test_expressions.py\r\n\r\n- [x] pandas/tests/test_strings.py\r\n\r\n- [ ] pandas/tests/io/test_sql.py\r\n\r\n- [ ] pandas/tests/reshape/test_concat.py\r\n\r\n- [ ] pandas/tests/scalar/timedelta/test_timedelta.py\r\n\r\n- [x] pandas/tests/series/test_missing.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_fiscal.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_offsets.py\r\n\r\n- [x] pandas/tseries/offsets.py\r\n\r\n- [x] pandas/util/_decorators.py\r\n\r\n- [x] pandas/util/_test_decorators.py\r\n\r\n- [x] pandas/util/testing.py\r\n\r\n- [x] pandas/_version.py\r\n\r\n- [ ] /scripts/tests/test_validate_docstrings.py\r\n---\r\n\r\n#### Lastly:\r\n- [ ] Add a test case (so we won't regress)\n\nAnother option that we use in quite a few places is single quotes `\"foo '{bar}' baz\"`\n\n> Another option that we use in quite a few places is single quotes `\"foo '{bar}' baz\"`\r\n\r\n@jbrockmendel I'm kinda obligated about how to find them systemically, meaning what if there's is a change to the ```repr()``` function, and the single quotas are there to differ from the ```repr()``` (If they're any). plus I'm not sure how to grep for this pattern.\n\nI'll take:\r\n\r\n- [x] pandas/tests/tseries/offsets/test_fiscal.py\r\n\r\n- [x] pandas/tests/tseries/offsets/test_offsets.py\r\n\r\n- [x] pandas/tseries/offsets.py\r\n\r\n- [x] pandas/util/testing.py\n\nworking on :\r\n- [x] pandas/core/sorting.py\r\n- [x] pandas/core/string.py\r\n- [x] pandas/core/series.py\r\n\r\ncurrently if no one has taken it yet.\r\nwill add more as i go further.\n\nWorking on: `pandas/core/sorting.py`\r\n\r\n\n\nhi @kvn219 , actually i am already working on three files one of which is what you have also mentioned , can you please work on some other file.\n\nI`ll take \r\n\r\npandas/pandas/io/parsers.py\r\n\r\npandas/pandas/io/html.py\n\nHi to everyone, I will take:\r\n\r\n- `pandas/_config/config.py`\r\n- `pandas/conftest.py`\r\n- `pandas/core/accessor.py`\r\n- `pandas/core/algorithms.py`\r\n\r\n\n\nIll take \r\ncore/indexes/numeric.py\r\ncore/frame.py \r\n\r\nif possible.\r\n\r\nIll do them on saturday\n\nI'm working on pandas/core/arrays/numpy_.py\n\nI am going to do pandas/utils/_test_decorators.py which is not on the original list but seems not to be updated\n\n> I am going to do pandas/utils/_test_decorators.py which is not on the original list but seems not to be updated\r\n\r\nThanks @chrisateen \n\n> I'm working on pandas/core/arrays/numpy_.py\r\n\r\nSorry, it was literally my first attempt at a pull request. I'll come back when I know enough to help. Cheers\n\n> Hi to everyone, I will take:\r\n> \r\n> * `pandas/_config/config.py`\r\n> * `pandas/conftest.py`\r\n> * `pandas/core/accessor.py`\r\n> * `pandas/core/algorithms.py`\r\n\r\nThese files were already finished with the replacement (it would be good if they appear checked in the list).\r\n\r\nSo I will take the following files to work with:\r\n\r\n- `pandas/tests/indexes/datetimes/test_partial_slicing.py` (not on the list, but not updated)\r\n- `pandas/core/nanops.py`\r\n- `pandas/core/missing.py`\r\n- `pandas/core/indexes/period.py` (not on the list, but not updated)\r\n\r\n\r\n\r\n\r\n\r\n\n\nI'm taking\r\n- [x] pandas/io/formats/excel.py\r\n- [x] pandas/io/formats/css.py\r\n- [x] pandas/io/formats/style.py\r\n\n\nI'll do:\r\n* [x] pandas/tests/test_expressions.py\r\n\r\nNot needed (according to grep expression):\r\n- pandas/core/indexes/numeric.py\r\n- pandas/core/indexes/interval.py\r\n- pandas/core/computation/eval.py\r\n- pandas/core/reshape/tile.py\r\n- pandas/core/indexes/base.py\r\n\r\nIf you run the grep string, there do not appear to be any more %r or !r's present.  \r\n\r\nThanks for the simple issue.  This was my first contribution to an open source project, as minimal as it is at this point. I have learned a lot.\n\nJumping on:\r\n* [ ] pandas/core/arrays/datetimelike.py\r\n* [x] pandas/io/formats/printing.py\r\n* [x] pandas/tests/extension/list/array.py\r\n* [x] pandas/tests/indexes/datetimes/test_ops.py\r\n* [x] pandas/tests/indexes/multi/test_analytics.py\n\n@WillAyd Can you please reopen this issue?\r\n\r\nIn [this PR](https://github.com/pandas-dev/pandas/pull/30420) there is a use of the word ```fix``` and after that this PR number, so it closed it.\n\ndone - thanks!\n\n> @WillAyd Can you please reopen this issue?\r\n> \r\n> In [this PR](https://github.com/pandas-dev/pandas/pull/30420) there is a use of the word `fix` and after that this PR number, so it closed it.\r\n\r\nSorry about that. Still kinda new to this...\n\n> Sorry about that. Still kinda new to this...\r\n\r\nIt's perfectly fine :)\n\npandas/tests/test_strings.py was checked and already uses f-strings.\r\npandas/core/dtypes/common.py was checked and already uses f-strings.\r\npandas/tests/indexes/test_common.py was checked and already uses f-strings.\r\npandas/core/window/rolling.py was checked and already uses f-strings.\r\npandas/core/computation/pytables.py was checked and already uses f-strings.\r\npandas/tests/indexes/datetimes/test_datetime.py was checked and already uses f-strings.\r\npandas/core/generic.py was checked and already uses f-strings.\r\n\r\nIf possible, it would be great to update the master list.\r\n\r\n\n\n> pandas/tests/test_strings.py was checked and already uses f-strings.\r\n> pandas/core/dtypes/common.py was checked and already uses f-strings.\r\n> pandas/tests/indexes/test_common.py was checked and already uses f-strings.\r\n> pandas/core/window/rolling.py was checked and already uses f-strings.\r\n> pandas/core/computation/pytables.py was checked and already uses f-strings.\r\n> pandas/tests/indexes/datetimes/test_datetime.py was checked and already uses f-strings.\r\n> pandas/core/generic.py was checked and already uses f-strings.\r\n> \r\n> If possible, it would be great to update the master list.\r\n\r\nTY, really appreciate it\n\n@jreback Can you please reopen this issue?\r\n\r\nThe PR was suppose to contain two test cases, but it only contained one.\r\n\r\nThis should be reopen.\n\nThanks @jreback \n\npandas/core/arrays/datetimelike.py\r\npandas/core/arrays/period.py\r\n\r\nBoth of the above are free of the old style strings.\r\nI am working on:\r\npandas/__init__.py\n\nI tackled the remaining files.  Did not implement a test though.\n\nSo the only remaining item is a code check test for `!r` rather than repr?\n\nActually, it looks like we have a check for that. @MomIsBestFriend is there anything else to do here?\n\n@TomAugspurger I think not :smiley: \r\n\r\nThank you all for helping :heart: ",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/30420",
  "code_context": [
    {
      "filename": "pandas/tests/indexes/datetimes/test_ops.py",
      "content": "from datetime import datetime\nimport warnings\n\nimport numpy as np\nimport pytest\n\nfrom pandas.core.dtypes.generic import ABCDateOffset\n\nimport pandas as pd\nfrom pandas import (\n    DatetimeIndex,\n    Index,\n    PeriodIndex,\n    Series,\n    Timestamp,\n    bdate_range,\n    date_range,\n)\nfrom pandas.tests.base.test_ops import Ops\nimport pandas.util.testing as tm\n\nfrom pandas.tseries.offsets import BDay, BMonthEnd, CDay, Day, Hour\n\nSTART, END = datetime(2009, 1, 1), datetime(2010, 1, 1)\n\n\nclass TestDatetimeIndexOps(Ops):\n    def setup_method(self, method):\n        super().setup_method(method)\n        mask = lambda x: (isinstance(x, DatetimeIndex) or isinstance(x, PeriodIndex))\n        self.is_valid_objs = [o for o in self.objs if mask(o)]\n        self.not_valid_objs = [o for o in self.objs if not mask(o)]\n\n    def test_ops_properties(self):\n        f = lambda x: isinstance(x, DatetimeIndex)\n        self.check_ops_properties(DatetimeIndex._field_ops, f)\n        self.check_ops_properties(DatetimeIndex._object_ops, f)\n        self.check_ops_properties(DatetimeIndex._bool_ops, f)\n\n    def test_ops_properties_basic(self):\n\n        # sanity check that the behavior didn't change\n        # GH#7206\n        for op in [\"year\", \"day\", \"second\", \"weekday\"]:\n            msg = f\"'Series' object has no attribute '{op}'\"\n            with pytest.raises(AttributeError, match=msg):\n                getattr(self.dt_series, op)\n\n        # attribute access should still work!\n        s = Series(dict(year=2000, month=1, day=10))\n        assert s.year == 2000\n        assert s.month == 1\n        assert s.day == 10\n        msg = \"'Series' object has no attribute 'weekday'\"\n        with pytest.raises(AttributeError, match=msg):\n            s.weekday\n\n    def test_repeat_range(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        rng = date_range(\"1/1/2000\", \"1/1/2001\")\n\n        result = rng.repeat(5)\n        assert result.freq is None\n        assert len(result) == 5 * len(rng)\n\n        index = pd.date_range(\"2001-01-01\", periods=2, freq=\"D\", tz=tz)\n        exp = pd.DatetimeIndex(\n            [\"2001-01-01\", \"2001-01-01\", \"2001-01-02\", \"2001-01-02\"], tz=tz\n        )\n        for res in [index.repeat(2), np.repeat(index, 2)]:\n            tm.assert_index_equal(res, exp)\n            assert res.freq is None\n\n        index = pd.date_range(\"2001-01-01\", periods=2, freq=\"2D\", tz=tz)\n        exp = pd.DatetimeIndex(\n            [\"2001-01-01\", \"2001-01-01\", \"2001-01-03\", \"2001-01-03\"], tz=tz\n        )\n        for res in [index.repeat(2), np.repeat(index, 2)]:\n            tm.assert_index_equal(res, exp)\n            assert res.freq is None\n\n        index = pd.DatetimeIndex([\"2001-01-01\", \"NaT\", \"2003-01-01\"], tz=tz)\n        exp = pd.DatetimeIndex(\n            [\n                \"2001-01-01\",\n                \"2001-01-01\",\n                \"2001-01-01\",\n                \"NaT\",\n                \"NaT\",\n                \"NaT\",\n                \"2003-01-01\",\n                \"2003-01-01\",\n                \"2003-01-01\",\n            ],\n            tz=tz,\n        )\n        for res in [index.repeat(3), np.repeat(index, 3)]:\n            tm.assert_index_equal(res, exp)\n            assert res.freq is None\n\n    def test_repeat(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        reps = 2\n        msg = \"the 'axis' parameter is not supported\"\n\n        rng = pd.date_range(start=\"2016-01-01\", periods=2, freq=\"30Min\", tz=tz)\n\n        expected_rng = DatetimeIndex(\n            [\n                Timestamp(\"2016-01-01 00:00:00\", tz=tz, freq=\"30T\"),\n                Timestamp(\"2016-01-01 00:00:00\", tz=tz, freq=\"30T\"),\n                Timestamp(\"2016-01-01 00:30:00\", tz=tz, freq=\"30T\"),\n                Timestamp(\"2016-01-01 00:30:00\", tz=tz, freq=\"30T\"),\n            ]\n        )\n\n        res = rng.repeat(reps)\n        tm.assert_index_equal(res, expected_rng)\n        assert res.freq is None\n\n        tm.assert_index_equal(np.repeat(rng, reps), expected_rng)\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(rng, reps, axis=1)\n\n    def test_resolution(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        for freq, expected in zip(\n            [\"A\", \"Q\", \"M\", \"D\", \"H\", \"T\", \"S\", \"L\", \"U\"],\n            [\n                \"day\",\n                \"day\",\n                \"day\",\n                \"day\",\n                \"hour\",\n                \"minute\",\n                \"second\",\n                \"millisecond\",\n                \"microsecond\",\n            ],\n        ):\n            idx = pd.date_range(start=\"2013-04-01\", periods=30, freq=freq, tz=tz)\n            assert idx.resolution == expected\n\n    def test_value_counts_unique(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        # GH 7735\n        idx = pd.date_range(\"2011-01-01 09:00\", freq=\"H\", periods=10)\n        # create repeated values, 'n'th element is repeated by n+1 times\n        idx = DatetimeIndex(np.repeat(idx.values, range(1, len(idx) + 1)), tz=tz)\n\n        exp_idx = pd.date_range(\"2011-01-01 18:00\", freq=\"-1H\", periods=10, tz=tz)\n        expected = Series(range(10, 0, -1), index=exp_idx, dtype=\"int64\")\n\n        for obj in [idx, Series(idx)]:\n            tm.assert_series_equal(obj.value_counts(), expected)\n\n        expected = pd.date_range(\"2011-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        tm.assert_index_equal(idx.unique(), expected)\n\n        idx = DatetimeIndex(\n            [\n                \"2013-01-01 09:00\",\n                \"2013-01-01 09:00\",\n                \"2013-01-01 09:00\",\n                \"2013-01-01 08:00\",\n                \"2013-01-01 08:00\",\n                pd.NaT,\n            ],\n            tz=tz,\n        )\n\n        exp_idx = DatetimeIndex([\"2013-01-01 09:00\", \"2013-01-01 08:00\"], tz=tz)\n        expected = Series([3, 2], index=exp_idx)\n\n        for obj in [idx, Series(idx)]:\n            tm.assert_series_equal(obj.value_counts(), expected)\n\n        exp_idx = DatetimeIndex([\"2013-01-01 09:00\", \"2013-01-01 08:00\", pd.NaT], tz=tz)\n        expected = Series([3, 2, 1], index=exp_idx)\n\n        for obj in [idx, Series(idx)]:\n            tm.assert_series_equal(obj.value_counts(dropna=False), expected)\n\n        tm.assert_index_equal(idx.unique(), exp_idx)\n\n    def test_nonunique_contains(self):\n        # GH 9512\n        for idx in map(\n            DatetimeIndex,\n            (\n                [0, 1, 0],\n                [0, 0, -1],\n                [0, -1, -1],\n                [\"2015\", \"2015\", \"2016\"],\n                [\"2015\", \"2015\", \"2014\"],\n            ),\n        ):\n            assert idx[0] in idx\n\n    @pytest.mark.parametrize(\n        \"idx\",\n        [\n            DatetimeIndex(\n                [\"2011-01-01\", \"2011-01-02\", \"2011-01-03\"], freq=\"D\", name=\"idx\"\n            ),\n            DatetimeIndex(\n                [\"2011-01-01 09:00\", \"2011-01-01 10:00\", \"2011-01-01 11:00\"],\n                freq=\"H\",\n                name=\"tzidx\",\n                tz=\"Asia/Tokyo\",\n            ),\n        ],\n    )\n    def test_order_with_freq(self, idx):\n        ordered = idx.sort_values()\n        tm.assert_index_equal(ordered, idx)\n        assert ordered.freq == idx.freq\n\n        ordered = idx.sort_values(ascending=False)\n        expected = idx[::-1]\n        tm.assert_index_equal(ordered, expected)\n        assert ordered.freq == expected.freq\n        assert ordered.freq.n == -1\n\n        ordered, indexer = idx.sort_values(return_indexer=True)\n        tm.assert_index_equal(ordered, idx)\n        tm.assert_numpy_array_equal(indexer, np.array([0, 1, 2]), check_dtype=False)\n        assert ordered.freq == idx.freq\n\n        ordered, indexer = idx.sort_values(return_indexer=True, ascending=False)\n        expected = idx[::-1]\n        tm.assert_index_equal(ordered, expected)\n        tm.assert_numpy_array_equal(indexer, np.array([2, 1, 0]), check_dtype=False)\n        assert ordered.freq == expected.freq\n        assert ordered.freq.n == -1\n\n    @pytest.mark.parametrize(\n        \"index_dates,expected_dates\",\n        [\n            (\n                [\"2011-01-01\", \"2011-01-03\", \"2011-01-05\", \"2011-01-02\", \"2011-01-01\"],\n                [\"2011-01-01\", \"2011-01-01\", \"2011-01-02\", \"2011-01-03\", \"2011-01-05\"],\n            ),\n            (\n                [\"2011-01-01\", \"2011-01-03\", \"2011-01-05\", \"2011-01-02\", \"2011-01-01\"],\n                [\"2011-01-01\", \"2011-01-01\", \"2011-01-02\", \"2011-01-03\", \"2011-01-05\"],\n            ),\n            (\n                [pd.NaT, \"2011-01-03\", \"2011-01-05\", \"2011-01-02\", pd.NaT],\n                [pd.NaT, pd.NaT, \"2011-01-02\", \"2011-01-03\", \"2011-01-05\"],\n            ),\n        ],\n    )\n    def test_order_without_freq(self, index_dates, expected_dates, tz_naive_fixture):\n        tz = tz_naive_fixture\n\n        # without freq\n        index = DatetimeIndex(index_dates, tz=tz, name=\"idx\")\n        expected = DatetimeIndex(expected_dates, tz=tz, name=\"idx\")\n\n        ordered = index.sort_values()\n        tm.assert_index_equal(ordered, expected)\n        assert ordered.freq is None\n\n        ordered = index.sort_values(ascending=False)\n        tm.assert_index_equal(ordered, expected[::-1])\n        assert ordered.freq is None\n\n        ordered, indexer = index.sort_values(return_indexer=True)\n        tm.assert_index_equal(ordered, expected)\n\n        exp = np.array([0, 4, 3, 1, 2])\n        tm.assert_numpy_array_equal(indexer, exp, check_dtype=False)\n        assert ordered.freq is None\n\n        ordered, indexer = index.sort_values(return_indexer=True, ascending=False)\n        tm.assert_index_equal(ordered, expected[::-1])\n\n        exp = np.array([2, 1, 3, 4, 0])\n        tm.assert_numpy_array_equal(indexer, exp, check_dtype=False)\n        assert ordered.freq is None\n\n    def test_drop_duplicates_metadata(self):\n        # GH 10115\n        idx = pd.date_range(\"2011-01-01\", \"2011-01-31\", freq=\"D\", name=\"idx\")\n        result = idx.drop_duplicates()\n        tm.assert_index_equal(idx, result)\n        assert idx.freq == result.freq\n\n        idx_dup = idx.append(idx)\n        assert idx_dup.freq is None  # freq is reset\n        result = idx_dup.drop_duplicates()\n        tm.assert_index_equal(idx, result)\n        assert result.freq is None\n\n    def test_drop_duplicates(self):\n        # to check Index/Series compat\n        base = pd.date_range(\"2011-01-01\", \"2011-01-31\", freq=\"D\", name=\"idx\")\n        idx = base.append(base[:5])\n\n        res = idx.drop_duplicates()\n        tm.assert_index_equal(res, base)\n        res = Series(idx).drop_duplicates()\n        tm.assert_series_equal(res, Series(base))\n\n        res = idx.drop_duplicates(keep=\"last\")\n        exp = base[5:].append(base[:5])\n        tm.assert_index_equal(res, exp)\n        res = Series(idx).drop_duplicates(keep=\"last\")\n        tm.assert_series_equal(res, Series(exp, index=np.arange(5, 36)))\n\n        res = idx.drop_duplicates(keep=False)\n        tm.assert_index_equal(res, base[5:])\n        res = Series(idx).drop_duplicates(keep=False)\n        tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))\n\n    @pytest.mark.parametrize(\n        \"freq\",\n        [\n            \"A\",\n            \"2A\",\n            \"-2A\",\n            \"Q\",\n            \"-1Q\",\n            \"M\",\n            \"-1M\",\n            \"D\",\n            \"3D\",\n            \"-3D\",\n            \"W\",\n            \"-1W\",\n            \"H\",\n            \"2H\",\n            \"-2H\",\n            \"T\",\n            \"2T\",\n            \"S\",\n            \"-3S\",\n        ],\n    )\n    def test_infer_freq(self, freq):\n        # GH 11018\n        idx = pd.date_range(\"2011-01-01 09:00:00\", freq=freq, periods=10)\n        result = pd.DatetimeIndex(idx.asi8, freq=\"infer\")\n        tm.assert_index_equal(idx, result)\n        assert result.freq == freq\n\n    def test_nat(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        assert pd.DatetimeIndex._na_value is pd.NaT\n        assert pd.DatetimeIndex([])._na_value is pd.NaT\n\n        idx = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], tz=tz)\n        assert idx._can_hold_na\n\n        tm.assert_numpy_array_equal(idx._isnan, np.array([False, False]))\n        assert idx.hasnans is False\n        tm.assert_numpy_array_equal(idx._nan_idxs, np.array([], dtype=np.intp))\n\n        idx = pd.DatetimeIndex([\"2011-01-01\", \"NaT\"], tz=tz)\n        assert idx._can_hold_na\n\n        tm.assert_numpy_array_equal(idx._isnan, np.array([False, True]))\n        assert idx.hasnans is True\n        tm.assert_numpy_array_equal(idx._nan_idxs, np.array([1], dtype=np.intp))\n\n    def test_equals(self):\n        # GH 13107\n        idx = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\", \"NaT\"])\n        assert idx.equals(idx)\n        assert idx.equals(idx.copy())\n        assert idx.equals(idx.astype(object))\n        assert idx.astype(object).equals(idx)\n        assert idx.astype(object).equals(idx.astype(object))\n        assert not idx.equals(list(idx))\n        assert not idx.equals(pd.Series(idx))\n\n        idx2 = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\", \"NaT\"], tz=\"US/Pacific\")\n        assert not idx.equals(idx2)\n        assert not idx.equals(idx2.copy())\n        assert not idx.equals(idx2.astype(object))\n        assert not idx.astype(object).equals(idx2)\n        assert not idx.equals(list(idx2))\n        assert not idx.equals(pd.Series(idx2))\n\n        # same internal, different tz\n        idx3 = pd.DatetimeIndex._simple_new(idx.asi8, tz=\"US/Pacific\")\n        tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)\n        assert not idx.equals(idx3)\n        assert not idx.equals(idx3.copy())\n        assert not idx.equals(idx3.astype(object))\n        assert not idx.astype(object).equals(idx3)\n        assert not idx.equals(list(idx3))\n        assert not idx.equals(pd.Series(idx3))\n\n        # check that we do not raise when comparing with OutOfBounds objects\n        oob = pd.Index([datetime(2500, 1, 1)] * 3, dtype=object)\n        assert not idx.equals(oob)\n        assert not idx2.equals(oob)\n        assert not idx3.equals(oob)\n\n        # check that we do not raise when comparing with OutOfBounds dt64\n        oob2 = oob.map(np.datetime64)\n        assert not idx.equals(oob2)\n        assert not idx2.equals(oob2)\n        assert not idx3.equals(oob2)\n\n    @pytest.mark.parametrize(\"values\", [[\"20180101\", \"20180103\", \"20180105\"], []])\n    @pytest.mark.parametrize(\"freq\", [\"2D\", Day(2), \"2B\", BDay(2), \"48H\", Hour(48)])\n    @pytest.mark.parametrize(\"tz\", [None, \"US/Eastern\"])\n    def test_freq_setter(self, values, freq, tz):\n        # GH 20678\n        idx = DatetimeIndex(values, tz=tz)\n\n        # can set to an offset, converting from string if necessary\n        idx._data.freq = freq\n        assert idx.freq == freq\n        assert isinstance(idx.freq, ABCDateOffset)\n\n        # can reset to None\n        idx._data.freq = None\n        assert idx.freq is None\n\n    def test_freq_setter_errors(self):\n        # GH 20678\n        idx = DatetimeIndex([\"20180101\", \"20180103\", \"20180105\"])\n\n        # setting with an incompatible freq\n        msg = (\n            \"Inferred frequency 2D from passed values does not conform to \"\n            \"passed frequency 5D\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            idx._data.freq = \"5D\"\n\n        # setting with non-freq string\n        with pytest.raises(ValueError, match=\"Invalid frequency\"):\n            idx._data.freq = \"foo\"\n\n\nclass TestBusinessDatetimeIndex:\n    def setup_method(self, method):\n        self.rng = bdate_range(START, END)\n\n    def test_comparison(self):\n        d = self.rng[10]\n\n        comp = self.rng > d\n        assert comp[11]\n        assert not comp[9]\n\n    def test_pickle_unpickle(self):\n        unpickled = tm.round_trip_pickle(self.rng)\n        assert unpickled.freq is not None\n\n    def test_copy(self):\n        cp = self.rng.copy()\n        repr(cp)\n        tm.assert_index_equal(cp, self.rng)\n\n    def test_shift(self):\n        shifted = self.rng.shift(5)\n        assert shifted[0] == self.rng[5]\n        assert shifted.freq == self.rng.freq\n\n        shifted = self.rng.shift(-5)\n        assert shifted[5] == self.rng[0]\n        assert shifted.freq == self.rng.freq\n\n        shifted = self.rng.shift(0)\n        assert shifted[0] == self.rng[0]\n        assert shifted.freq == self.rng.freq\n\n        rng = date_range(START, END, freq=BMonthEnd())\n        shifted = rng.shift(1, freq=BDay())\n        assert shifted[0] == rng[0] + BDay()\n\n    def test_equals(self):\n        assert not self.rng.equals(list(self.rng))\n\n    def test_identical(self):\n        t1 = self.rng.copy()\n        t2 = self.rng.copy()\n        assert t1.identical(t2)\n\n        # name\n        t1 = t1.rename(\"foo\")\n        assert t1.equals(t2)\n        assert not t1.identical(t2)\n        t2 = t2.rename(\"foo\")\n        assert t1.identical(t2)\n\n        # freq\n        t2v = Index(t2.values)\n        assert t1.equals(t2v)\n        assert not t1.identical(t2v)\n\n\nclass TestCustomDatetimeIndex:\n    def setup_method(self, method):\n        self.rng = bdate_range(START, END, freq=\"C\")\n\n    def test_comparison(self):\n        d = self.rng[10]\n\n        comp = self.rng > d\n        assert comp[11]\n        assert not comp[9]\n\n    def test_copy(self):\n        cp = self.rng.copy()\n        repr(cp)\n        tm.assert_index_equal(cp, self.rng)\n\n    def test_shift(self):\n\n        shifted = self.rng.shift(5)\n        assert shifted[0] == self.rng[5]\n        assert shifted.freq == self.rng.freq\n\n        shifted = self.rng.shift(-5)\n        assert shifted[5] == self.rng[0]\n        assert shifted.freq == self.rng.freq\n\n        shifted = self.rng.shift(0)\n        assert shifted[0] == self.rng[0]\n        assert shifted.freq == self.rng.freq\n\n        with warnings.catch_warnings(record=True):\n            warnings.simplefilter(\"ignore\", pd.errors.PerformanceWarning)\n            rng = date_range(START, END, freq=BMonthEnd())\n            shifted = rng.shift(1, freq=CDay())\n            assert shifted[0] == rng[0] + CDay()\n\n    def test_shift_periods(self):\n        # GH#22458 : argument 'n' was deprecated in favor of 'periods'\n        idx = pd.date_range(start=START, end=END, periods=3)\n        tm.assert_index_equal(idx.shift(periods=0), idx)\n        tm.assert_index_equal(idx.shift(0), idx)\n\n    def test_pickle_unpickle(self):\n        unpickled = tm.round_trip_pickle(self.rng)\n        assert unpickled.freq is not None\n\n    def test_equals(self):\n        assert not self.rng.equals(list(self.rng))\n"
    }
  ]
}