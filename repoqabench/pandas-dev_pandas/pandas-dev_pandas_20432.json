{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "20432",
  "issue_description": "# BUG: DataFrame/Series.loc improperly allows lookups of boolean labels/slices\n\n#### Code Sample, a copy-pastable example if possible\r\nBasic example of the issue, specific to `TimedeltaIndex`, xref https://github.com/pandas-dev/pandas/pull/20408#discussion_r175627548\r\n```python\r\nIn [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n\r\nIn [3]: s.loc[True]\r\nOut[3]: 'b'\r\n\r\nIn [4]: s.loc[False:True]\r\nOut[4]:\r\n00:00:00           a\r\n00:00:00.000000    b\r\nFreq: N, dtype: object\r\n```\r\n\r\nIndexing with both boolean labels and slices was successful, which doesn't seem right.\r\n\r\nI investigated this same behavior across various index types for both `Series` and `DataFrame`, and produced the summary below.\r\n\r\n**Summary**\r\n- 'raises' column indicates if the indexing operation raised an exception\r\n-  'exception' column indicates the type of exception raised\r\n<details>\r\n\r\n```\r\n                                  raises  exception\r\nCategoricalIndex DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label   False        NaN\r\n                           slice    True   KeyError\r\nDatetimeIndex    DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nFloat64Index     DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nIndex            DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nInt64Index       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nIntervalIndex    DataFrame label    True  TypeError\r\n                           slice    True  TypeError\r\n                 Series    label    True  TypeError\r\n                           slice    True  TypeError\r\nMultiIndex       DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label    True   KeyError\r\n                           slice    True   KeyError\r\nPeriodIndex      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nRangeIndex       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nTimedeltaIndex   DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nUInt64Index      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\n```\r\n</details>\r\n\r\n<br />\r\n\r\n**Code to produce summary**\r\n<details>\r\n\r\n```python\r\nindexes = [\r\n    pd.RangeIndex(4),\r\n    pd.Int64Index(range(4)),\r\n    pd.UInt64Index(range(4)),\r\n    pd.Float64Index(range(4)),\r\n    pd.CategoricalIndex(range(4)),\r\n    pd.date_range(0, periods=4, freq='ns'),\r\n    pd.timedelta_range(0, periods=4, freq='ns'),\r\n    pd.interval_range(0, periods=4),\r\n    pd.Index([0, 1, 2, 3], dtype=object),\r\n    pd.MultiIndex.from_product([[0, 1], [0, 1]]),\r\n    pd.period_range('2018Q1', freq='Q', periods=4),  # need better example here\r\n]\r\n\r\nresult = {}\r\nfor index in indexes:\r\n    index_name = type(index).__name__\r\n    s = pd.Series(list('abcd'), index=index)\r\n    for obj in (s, s.to_frame()):\r\n        obj_name = type(obj).__name__\r\n\r\n        # check single label\r\n        key = (index_name, obj_name, 'label')\r\n        try:\r\n            obj.loc[True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\n        # check slice\r\n        key = (index_name, obj_name, 'slice')\r\n        try:\r\n            obj.loc[False:True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\nresult = pd.DataFrame.from_dict(result, orient='index')\r\n```\r\n</details>\r\n\r\n#### Expected Output\r\nI'd generally expect all of these operations to raise a `KeyError`, which a couple potential exceptions:\r\n\r\n- I'd be open to an argument for numeric indexes casting to integer equivalent.  Seems like this should at least be consistent for labels vs slices, which it is not right now.\r\n- Maybe we should allow conversion for the `object` dtype `Index`?",
  "issue_comments": [
    {
      "id": 375256564,
      "user": "jreback",
      "body": "yeah I agree slice should certainly raise, prob ``TypeError``. There is some small precedent for a label (or even list-indexer) of booleans to work on a *boolean* inferred index type (so very small exception here). \r\n\r\nBut I think making all of these TypeError is prob reasonable. I wouldn't cast."
    },
    {
      "id": 611869235,
      "user": "mroeschke",
      "body": "Looks like these raise sensible errors on master now. Could use a test\r\n\r\n```\r\nIn [39]: pd.__version__\r\nOut[39]: '1.1.0.dev0+1216.gd4d58f960'\r\n\r\nIn [40]: In [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n    ...:\r\n    ...: In [3]: s.loc[True]\r\nKeyError: True\r\n\r\nIn [41]: In [4]: s.loc[False:True]\r\nTypeError: Unexpected type for 'value': <class 'bool'>\r\n```"
    },
    {
      "id": 688889104,
      "user": "karuppiah7890",
      "body": "I'm going to give this a shot! ðŸ˜„ "
    },
    {
      "id": 688890368,
      "user": "karuppiah7890",
      "body": "take"
    },
    {
      "id": 704387458,
      "user": "karuppiah7890",
      "body": "Any suggestions on how to go about this? @mroeschke @MarcoGorelli \r\n\r\nI noticed some files related to `loc` method in these places\r\n\r\ncode - pandas/core/indexing.py\r\n\r\ntests:\r\npandas/tests/indexing/test_loc.py\r\npandas/tests/indexing/multiindex/test_loc.py\r\npandas/tests/series/indexing/test_loc.py\r\n\r\nI still have to understand the existing tests and then write the new ones. I'm pretty new to Python ðŸ˜… Let me know if this is a big issue to pickup. I can pickup something smaller in that case. \r\n\r\nPS: I'm still stuck at my machine setup - I tried VS Code Remote Containers setup but it didn't work out, I think it's because it took up lots of RAM and was killed because of Out Of Memory, as I have set some limits in my Docker Desktop, like 1GB RAM. I plan to setup the whole thing in my local. Is that okay? I hope it doesn't affect any of my other python related software / tools I use, given it is more sandboxed with virtualenv (I'm assuming. Python newbie here)"
    },
    {
      "id": 704389166,
      "user": "MarcoGorelli",
      "body": "Hi @karuppiah7890 \r\n\r\n> I plan to setup the whole thing in my local. Is that okay?\r\n\r\nYup, that's what I've done, I have a `pandas-dev` conda environment, feel free to ask if you have trouble setting up"
    },
    {
      "id": 714595559,
      "user": "karuppiah7890",
      "body": "I have setup the environment. I tried to run the tests, but there were tons, so stopped it in between. Can someone help me understand what kind of test is needed here?\r\n\r\nAre we looking for tests that assert for `KeyError` and `TypeError` ?\r\n\r\n```python\r\n\r\nIn [40]: In [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n    ...:\r\n    ...: In [3]: s.loc[True]\r\nKeyError: True\r\n\r\nIn [41]: In [4]: s.loc[False:True]\r\nTypeError: Unexpected type for 'value': <class 'bool'>\r\n```"
    },
    {
      "id": 714595956,
      "user": "karuppiah7890",
      "body": "I guess I'll have to first learn a bit more about the existing tests. I'll do that and get back here. I'll look for any suggestions over here, please do post if you have any"
    },
    {
      "id": 752031344,
      "user": "karuppiah7890",
      "body": "Since I'm not working on this anymore, I'll leave it for others to pick it up. ðŸ™ˆ"
    },
    {
      "id": 808756738,
      "user": "DriesSchaumont",
      "body": "take"
    },
    {
      "id": 808757376,
      "user": "DriesSchaumont",
      "body": "Seems like this is still not working for `IntervalIndex`:\r\n```python3\r\n>>> import pandas as pd\r\n>>> df = pd.DataFrame(range(4))\r\n>>> df.index = pd.interval_range(0, periods=4)\r\n>>> df.loc[True]\r\n0    0\r\nName: (0, 1], dtype: int64\r\n```\r\nSame as for the regular `Index`:\r\n```python3\r\ndf = pd.DataFrame(range(4))\r\ndf.index = pd.Index([0, 1, 2, 3], dtype=object)\r\ndf.loc[True]\r\n0    1\r\nName: 1, dtype: int64\r\n```\r\n\r\nDo these cases need seperate issues?"
    },
    {
      "id": 808767527,
      "user": "mzeitlin11",
      "body": "I don't think so, provided the same fix can handle both cases. Could open another issue if you find out one or the other needs some special attention for some reason."
    }
  ],
  "text_context": "# BUG: DataFrame/Series.loc improperly allows lookups of boolean labels/slices\n\n#### Code Sample, a copy-pastable example if possible\r\nBasic example of the issue, specific to `TimedeltaIndex`, xref https://github.com/pandas-dev/pandas/pull/20408#discussion_r175627548\r\n```python\r\nIn [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n\r\nIn [3]: s.loc[True]\r\nOut[3]: 'b'\r\n\r\nIn [4]: s.loc[False:True]\r\nOut[4]:\r\n00:00:00           a\r\n00:00:00.000000    b\r\nFreq: N, dtype: object\r\n```\r\n\r\nIndexing with both boolean labels and slices was successful, which doesn't seem right.\r\n\r\nI investigated this same behavior across various index types for both `Series` and `DataFrame`, and produced the summary below.\r\n\r\n**Summary**\r\n- 'raises' column indicates if the indexing operation raised an exception\r\n-  'exception' column indicates the type of exception raised\r\n<details>\r\n\r\n```\r\n                                  raises  exception\r\nCategoricalIndex DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label   False        NaN\r\n                           slice    True   KeyError\r\nDatetimeIndex    DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nFloat64Index     DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nIndex            DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nInt64Index       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nIntervalIndex    DataFrame label    True  TypeError\r\n                           slice    True  TypeError\r\n                 Series    label    True  TypeError\r\n                           slice    True  TypeError\r\nMultiIndex       DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label    True   KeyError\r\n                           slice    True   KeyError\r\nPeriodIndex      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nRangeIndex       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nTimedeltaIndex   DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nUInt64Index      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\n```\r\n</details>\r\n\r\n<br />\r\n\r\n**Code to produce summary**\r\n<details>\r\n\r\n```python\r\nindexes = [\r\n    pd.RangeIndex(4),\r\n    pd.Int64Index(range(4)),\r\n    pd.UInt64Index(range(4)),\r\n    pd.Float64Index(range(4)),\r\n    pd.CategoricalIndex(range(4)),\r\n    pd.date_range(0, periods=4, freq='ns'),\r\n    pd.timedelta_range(0, periods=4, freq='ns'),\r\n    pd.interval_range(0, periods=4),\r\n    pd.Index([0, 1, 2, 3], dtype=object),\r\n    pd.MultiIndex.from_product([[0, 1], [0, 1]]),\r\n    pd.period_range('2018Q1', freq='Q', periods=4),  # need better example here\r\n]\r\n\r\nresult = {}\r\nfor index in indexes:\r\n    index_name = type(index).__name__\r\n    s = pd.Series(list('abcd'), index=index)\r\n    for obj in (s, s.to_frame()):\r\n        obj_name = type(obj).__name__\r\n\r\n        # check single label\r\n        key = (index_name, obj_name, 'label')\r\n        try:\r\n            obj.loc[True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\n        # check slice\r\n        key = (index_name, obj_name, 'slice')\r\n        try:\r\n            obj.loc[False:True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\nresult = pd.DataFrame.from_dict(result, orient='index')\r\n```\r\n</details>\r\n\r\n#### Expected Output\r\nI'd generally expect all of these operations to raise a `KeyError`, which a couple potential exceptions:\r\n\r\n- I'd be open to an argument for numeric indexes casting to integer equivalent.  Seems like this should at least be consistent for labels vs slices, which it is not right now.\r\n- Maybe we should allow conversion for the `object` dtype `Index`?\n\nyeah I agree slice should certainly raise, prob ``TypeError``. There is some small precedent for a label (or even list-indexer) of booleans to work on a *boolean* inferred index type (so very small exception here). \r\n\r\nBut I think making all of these TypeError is prob reasonable. I wouldn't cast.\n\nLooks like these raise sensible errors on master now. Could use a test\r\n\r\n```\r\nIn [39]: pd.__version__\r\nOut[39]: '1.1.0.dev0+1216.gd4d58f960'\r\n\r\nIn [40]: In [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n    ...:\r\n    ...: In [3]: s.loc[True]\r\nKeyError: True\r\n\r\nIn [41]: In [4]: s.loc[False:True]\r\nTypeError: Unexpected type for 'value': <class 'bool'>\r\n```\n\nI'm going to give this a shot! ðŸ˜„ \n\ntake\n\nAny suggestions on how to go about this? @mroeschke @MarcoGorelli \r\n\r\nI noticed some files related to `loc` method in these places\r\n\r\ncode - pandas/core/indexing.py\r\n\r\ntests:\r\npandas/tests/indexing/test_loc.py\r\npandas/tests/indexing/multiindex/test_loc.py\r\npandas/tests/series/indexing/test_loc.py\r\n\r\nI still have to understand the existing tests and then write the new ones. I'm pretty new to Python ðŸ˜… Let me know if this is a big issue to pickup. I can pickup something smaller in that case. \r\n\r\nPS: I'm still stuck at my machine setup - I tried VS Code Remote Containers setup but it didn't work out, I think it's because it took up lots of RAM and was killed because of Out Of Memory, as I have set some limits in my Docker Desktop, like 1GB RAM. I plan to setup the whole thing in my local. Is that okay? I hope it doesn't affect any of my other python related software / tools I use, given it is more sandboxed with virtualenv (I'm assuming. Python newbie here)\n\nHi @karuppiah7890 \r\n\r\n> I plan to setup the whole thing in my local. Is that okay?\r\n\r\nYup, that's what I've done, I have a `pandas-dev` conda environment, feel free to ask if you have trouble setting up\n\nI have setup the environment. I tried to run the tests, but there were tons, so stopped it in between. Can someone help me understand what kind of test is needed here?\r\n\r\nAre we looking for tests that assert for `KeyError` and `TypeError` ?\r\n\r\n```python\r\n\r\nIn [40]: In [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n    ...:\r\n    ...: In [3]: s.loc[True]\r\nKeyError: True\r\n\r\nIn [41]: In [4]: s.loc[False:True]\r\nTypeError: Unexpected type for 'value': <class 'bool'>\r\n```\n\nI guess I'll have to first learn a bit more about the existing tests. I'll do that and get back here. I'll look for any suggestions over here, please do post if you have any\n\nSince I'm not working on this anymore, I'll leave it for others to pick it up. ðŸ™ˆ\n\ntake\n\nSeems like this is still not working for `IntervalIndex`:\r\n```python3\r\n>>> import pandas as pd\r\n>>> df = pd.DataFrame(range(4))\r\n>>> df.index = pd.interval_range(0, periods=4)\r\n>>> df.loc[True]\r\n0    0\r\nName: (0, 1], dtype: int64\r\n```\r\nSame as for the regular `Index`:\r\n```python3\r\ndf = pd.DataFrame(range(4))\r\ndf.index = pd.Index([0, 1, 2, 3], dtype=object)\r\ndf.loc[True]\r\n0    1\r\nName: 1, dtype: int64\r\n```\r\n\r\nDo these cases need seperate issues?\n\nI don't think so, provided the same fix can handle both cases. Could open another issue if you find out one or the other needs some special attention for some reason.",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/20408",
  "code_context": [
    {
      "filename": "pandas/core/indexes/timedeltas.py",
      "content": "\"\"\" implement the TimedeltaIndex \"\"\"\n\nfrom datetime import timedelta\n\nimport numpy as np\nfrom pandas.core.dtypes.common import (\n    _TD_DTYPE,\n    is_integer,\n    is_float,\n    is_bool_dtype,\n    is_list_like,\n    is_scalar,\n    is_timedelta64_dtype,\n    is_timedelta64_ns_dtype,\n    pandas_dtype,\n    _ensure_int64)\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.generic import ABCSeries\n\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.numeric import Int64Index\nimport pandas.compat as compat\nfrom pandas.compat import u\nfrom pandas.tseries.frequencies import to_offset\nfrom pandas.core.algorithms import checked_add_with_arr\nfrom pandas.core.base import _shared_docs\nfrom pandas.core.indexes.base import _index_shared_docs\nimport pandas.core.common as com\nimport pandas.core.dtypes.concat as _concat\nfrom pandas.util._decorators import Appender, Substitution, deprecate_kwarg\nfrom pandas.core.indexes.datetimelike import TimelikeOps, DatetimeIndexOpsMixin\nfrom pandas.core.tools.timedeltas import (\n    to_timedelta, _coerce_scalar_to_timedelta_type)\nfrom pandas.tseries.offsets import Tick, DateOffset\nfrom pandas._libs import (lib, index as libindex, tslib as libts,\n                          join as libjoin, Timedelta, NaT, iNaT)\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas._libs.tslibs.fields import get_timedelta_field\n\n\ndef _field_accessor(name, alias, docstring=None):\n    def f(self):\n        values = self.asi8\n        result = get_timedelta_field(values, alias)\n        if self.hasnans:\n            result = self._maybe_mask_results(result, convert='float64')\n\n        return Index(result, name=self.name)\n\n    f.__name__ = name\n    f.__doc__ = docstring\n    return property(f)\n\n\ndef _td_index_cmp(opname, cls):\n    \"\"\"\n    Wrap comparison operations to convert timedelta-like to timedelta64\n    \"\"\"\n    nat_result = True if opname == '__ne__' else False\n\n    def wrapper(self, other):\n        msg = \"cannot compare a {cls} with type {typ}\"\n        func = getattr(super(TimedeltaIndex, self), opname)\n        if _is_convertible_to_td(other) or other is NaT:\n            try:\n                other = _to_m8(other)\n            except ValueError:\n                # failed to parse as timedelta\n                raise TypeError(msg.format(cls=type(self).__name__,\n                                           typ=type(other).__name__))\n            result = func(other)\n            if isna(other):\n                result.fill(nat_result)\n\n        elif not is_list_like(other):\n            raise TypeError(msg.format(cls=type(self).__name__,\n                                       typ=type(other).__name__))\n        else:\n            other = TimedeltaIndex(other).values\n            result = func(other)\n            result = com._values_from_object(result)\n\n            o_mask = np.array(isna(other))\n            if o_mask.any():\n                result[o_mask] = nat_result\n\n        if self.hasnans:\n            result[self._isnan] = nat_result\n\n        # support of bool dtype indexers\n        if is_bool_dtype(result):\n            return result\n        return Index(result)\n\n    return compat.set_function_name(wrapper, opname, cls)\n\n\nclass TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):\n    \"\"\"\n    Immutable ndarray of timedelta64 data, represented internally as int64, and\n    which can be boxed to timedelta objects\n\n    Parameters\n    ----------\n    data  : array-like (1-dimensional), optional\n        Optional timedelta-like data to construct index with\n    unit: unit of the arg (D,h,m,s,ms,us,ns) denote the unit, optional\n        which is an integer/float number\n    freq: a frequency for the index, optional\n    copy  : bool\n        Make a copy of input ndarray\n    start : starting value, timedelta-like, optional\n        If data is None, start is used as the start point in generating regular\n        timedelta data.\n    periods  : int, optional, > 0\n        Number of periods to generate, if generating index. Takes precedence\n        over end argument\n    end   : end time, timedelta-like, optional\n        If periods is none, generated index will extend to first conforming\n        time on or just past end argument\n    closed : string or None, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None)\n    name : object\n        Name to be stored in the index\n\n    Notes\n    -----\n\n    To learn more about the frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases>`__.\n\n    See Also\n    ---------\n    Index : The base pandas Index type\n    Timedelta : Represents a duration between two dates or times.\n    DatetimeIndex : Index of datetime64 data\n    PeriodIndex : Index of Period data\n\n    Attributes\n    ----------\n    days\n    seconds\n    microseconds\n    nanoseconds\n    components\n    inferred_freq\n\n    Methods\n    -------\n    to_pytimedelta\n    to_series\n    round\n    floor\n    ceil\n    to_frame\n    \"\"\"\n\n    _typ = 'timedeltaindex'\n    _join_precedence = 10\n\n    def _join_i8_wrapper(joinf, **kwargs):\n        return DatetimeIndexOpsMixin._join_i8_wrapper(\n            joinf, dtype='m8[ns]', **kwargs)\n\n    _inner_indexer = _join_i8_wrapper(libjoin.inner_join_indexer_int64)\n    _outer_indexer = _join_i8_wrapper(libjoin.outer_join_indexer_int64)\n    _left_indexer = _join_i8_wrapper(libjoin.left_join_indexer_int64)\n    _left_indexer_unique = _join_i8_wrapper(\n        libjoin.left_join_indexer_unique_int64, with_indexers=False)\n\n    # define my properties & methods for delegation\n    _other_ops = []\n    _bool_ops = []\n    _object_ops = ['freq']\n    _field_ops = ['days', 'seconds', 'microseconds', 'nanoseconds']\n    _datetimelike_ops = _field_ops + _object_ops + _bool_ops\n    _datetimelike_methods = [\"to_pytimedelta\", \"total_seconds\",\n                             \"round\", \"floor\", \"ceil\"]\n\n    @classmethod\n    def _add_comparison_methods(cls):\n        \"\"\" add in comparison methods \"\"\"\n        cls.__eq__ = _td_index_cmp('__eq__', cls)\n        cls.__ne__ = _td_index_cmp('__ne__', cls)\n        cls.__lt__ = _td_index_cmp('__lt__', cls)\n        cls.__gt__ = _td_index_cmp('__gt__', cls)\n        cls.__le__ = _td_index_cmp('__le__', cls)\n        cls.__ge__ = _td_index_cmp('__ge__', cls)\n\n    _engine_type = libindex.TimedeltaEngine\n\n    _comparables = ['name', 'freq']\n    _attributes = ['name', 'freq']\n    _is_numeric_dtype = True\n    _infer_as_myclass = True\n\n    freq = None\n\n    def __new__(cls, data=None, unit=None, freq=None, start=None, end=None,\n                periods=None, closed=None, dtype=None, copy=False,\n                name=None, verify_integrity=True):\n\n        if isinstance(data, TimedeltaIndex) and freq is None and name is None:\n            if copy:\n                return data.copy()\n            else:\n                return data._shallow_copy()\n\n        freq_infer = False\n        if not isinstance(freq, DateOffset):\n\n            # if a passed freq is None, don't infer automatically\n            if freq != 'infer':\n                freq = to_offset(freq)\n            else:\n                freq_infer = True\n                freq = None\n\n        if periods is not None:\n            if is_float(periods):\n                periods = int(periods)\n            elif not is_integer(periods):\n                msg = 'periods must be a number, got {periods}'\n                raise TypeError(msg.format(periods=periods))\n\n        if data is None and freq is None:\n            raise ValueError(\"Must provide freq argument if no data is \"\n                             \"supplied\")\n\n        if data is None:\n            return cls._generate(start, end, periods, name, freq,\n                                 closed=closed)\n\n        if unit is not None:\n            data = to_timedelta(data, unit=unit, box=False)\n\n        if not isinstance(data, (np.ndarray, Index, ABCSeries)):\n            if is_scalar(data):\n                raise ValueError('TimedeltaIndex() must be called with a '\n                                 'collection of some kind, %s was passed'\n                                 % repr(data))\n\n        # convert if not already\n        if getattr(data, 'dtype', None) != _TD_DTYPE:\n            data = to_timedelta(data, unit=unit, box=False)\n        elif copy:\n            data = np.array(data, copy=True)\n\n        # check that we are matching freqs\n        if verify_integrity and len(data) > 0:\n            if freq is not None and not freq_infer:\n                index = cls._simple_new(data, name=name)\n                inferred = index.inferred_freq\n                if inferred != freq.freqstr:\n                    on_freq = cls._generate(\n                        index[0], None, len(index), name, freq)\n                    if not np.array_equal(index.asi8, on_freq.asi8):\n                        raise ValueError('Inferred frequency {0} from passed '\n                                         'timedeltas does not conform to '\n                                         'passed frequency {1}'\n                                         .format(inferred, freq.freqstr))\n                index.freq = freq\n                return index\n\n        if freq_infer:\n            index = cls._simple_new(data, name=name)\n            inferred = index.inferred_freq\n            if inferred:\n                index.freq = to_offset(inferred)\n            return index\n\n        return cls._simple_new(data, name=name, freq=freq)\n\n    @classmethod\n    def _generate(cls, start, end, periods, name, offset, closed=None):\n        if com._count_not_none(start, end, periods) != 2:\n            raise ValueError('Of the three parameters: start, end, and '\n                             'periods, exactly two must be specified')\n\n        if start is not None:\n            start = Timedelta(start)\n\n        if end is not None:\n            end = Timedelta(end)\n\n        left_closed = False\n        right_closed = False\n\n        if start is None and end is None:\n            if closed is not None:\n                raise ValueError(\"Closed has to be None if not both of start\"\n                                 \"and end are defined\")\n\n        if closed is None:\n            left_closed = True\n            right_closed = True\n        elif closed == \"left\":\n            left_closed = True\n        elif closed == \"right\":\n            right_closed = True\n        else:\n            raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n        index = _generate_regular_range(start, end, periods, offset)\n        index = cls._simple_new(index, name=name, freq=offset)\n\n        if not left_closed:\n            index = index[1:]\n        if not right_closed:\n            index = index[:-1]\n\n        return index\n\n    @property\n    def _box_func(self):\n        return lambda x: Timedelta(x, unit='ns')\n\n    @classmethod\n    def _simple_new(cls, values, name=None, freq=None, **kwargs):\n        values = np.array(values, copy=False)\n        if values.dtype == np.object_:\n            values = array_to_timedelta64(values)\n        if values.dtype != _TD_DTYPE:\n            values = _ensure_int64(values).view(_TD_DTYPE)\n\n        result = object.__new__(cls)\n        result._data = values\n        result.name = name\n        result.freq = freq\n        result._reset_identity()\n        return result\n\n    @property\n    def _formatter_func(self):\n        from pandas.io.formats.format import _get_format_timedelta64\n        return _get_format_timedelta64(self, box=True)\n\n    def __setstate__(self, state):\n        \"\"\"Necessary for making this object picklable\"\"\"\n        if isinstance(state, dict):\n            super(TimedeltaIndex, self).__setstate__(state)\n        else:\n            raise Exception(\"invalid pickle state\")\n    _unpickle_compat = __setstate__\n\n    def _maybe_update_attributes(self, attrs):\n        \"\"\" Update Index attributes (e.g. freq) depending on op \"\"\"\n        freq = attrs.get('freq', None)\n        if freq is not None:\n            # no need to infer if freq is None\n            attrs['freq'] = 'infer'\n        return attrs\n\n    def _add_offset(self, other):\n        assert not isinstance(other, Tick)\n        raise TypeError(\"cannot add the type {typ} to a {cls}\"\n                        .format(typ=type(other).__name__,\n                                cls=type(self).__name__))\n\n    def _add_delta(self, delta):\n        \"\"\"\n        Add a timedelta-like, Tick, or TimedeltaIndex-like object\n        to self.\n\n        Parameters\n        ----------\n        delta : {timedelta, np.timedelta64, Tick, TimedeltaIndex}\n\n        Returns\n        -------\n        result : TimedeltaIndex\n\n        Notes\n        -----\n        The result's name is set outside of _add_delta by the calling\n        method (__add__ or __sub__)\n        \"\"\"\n        if isinstance(delta, (Tick, timedelta, np.timedelta64)):\n            new_values = self._add_delta_td(delta)\n        elif isinstance(delta, TimedeltaIndex):\n            new_values = self._add_delta_tdi(delta)\n        elif is_timedelta64_dtype(delta):\n            # ndarray[timedelta64] --> wrap in TimedeltaIndex\n            delta = TimedeltaIndex(delta)\n            new_values = self._add_delta_tdi(delta)\n        else:\n            raise TypeError(\"cannot add the type {0} to a TimedeltaIndex\"\n                            .format(type(delta)))\n\n        return TimedeltaIndex(new_values, freq='infer')\n\n    def _evaluate_with_timedelta_like(self, other, op):\n        if isinstance(other, ABCSeries):\n            # GH#19042\n            return NotImplemented\n\n        opstr = '__{opname}__'.format(opname=op.__name__).replace('__r', '__')\n        # allow division by a timedelta\n        if opstr in ['__div__', '__truediv__', '__floordiv__']:\n            if _is_convertible_to_td(other):\n                other = Timedelta(other)\n                if isna(other):\n                    raise NotImplementedError(\n                        \"division by pd.NaT not implemented\")\n\n                i8 = self.asi8\n                left, right = i8, other.value\n\n                if opstr in ['__floordiv__']:\n                    result = op(left, right)\n                else:\n                    result = op(left, np.float64(right))\n                result = self._maybe_mask_results(result, convert='float64')\n                return Index(result, name=self.name, copy=False)\n\n        return NotImplemented\n\n    def _add_datelike(self, other):\n        # adding a timedeltaindex to a datetimelike\n        from pandas import Timestamp, DatetimeIndex\n        if isinstance(other, (DatetimeIndex, np.ndarray)):\n            # if other is an ndarray, we assume it is datetime64-dtype\n            # defer to implementation in DatetimeIndex\n            other = DatetimeIndex(other)\n            return other + self\n        else:\n            assert other is not NaT\n            other = Timestamp(other)\n            i8 = self.asi8\n            result = checked_add_with_arr(i8, other.value,\n                                          arr_mask=self._isnan)\n            result = self._maybe_mask_results(result, fill_value=iNaT)\n            return DatetimeIndex(result)\n\n    def _sub_datelike(self, other):\n        assert other is not NaT\n        raise TypeError(\"cannot subtract a datelike from a {cls}\"\n                        .format(cls=type(self).__name__))\n\n    def _addsub_offset_array(self, other, op):\n        # Add or subtract Array-like of DateOffset objects\n        try:\n            # TimedeltaIndex can only operate with a subset of DateOffset\n            # subclasses.  Incompatible classes will raise AttributeError,\n            # which we re-raise as TypeError\n            return DatetimeIndexOpsMixin._addsub_offset_array(self, other, op)\n        except AttributeError:\n            raise TypeError(\"Cannot add/subtract non-tick DateOffset to {cls}\"\n                            .format(cls=type(self).__name__))\n\n    def _format_native_types(self, na_rep=u('NaT'),\n                             date_format=None, **kwargs):\n        from pandas.io.formats.format import Timedelta64Formatter\n        return Timedelta64Formatter(values=self,\n                                    nat_rep=na_rep,\n                                    justify='all').get_result()\n\n    days = _field_accessor(\"days\", \"days\",\n                           \" Number of days for each element. \")\n    seconds = _field_accessor(\"seconds\", \"seconds\",\n                              \" Number of seconds (>= 0 and less than 1 day) \"\n                              \"for each element. \")\n    microseconds = _field_accessor(\"microseconds\", \"microseconds\",\n                                   \"\\nNumber of microseconds (>= 0 and less \"\n                                   \"than 1 second) for each\\nelement. \")\n    nanoseconds = _field_accessor(\"nanoseconds\", \"nanoseconds\",\n                                  \"\\nNumber of nanoseconds (>= 0 and less \"\n                                  \"than 1 microsecond) for each\\nelement.\\n\")\n\n    @property\n    def components(self):\n        \"\"\"\n        Return a dataframe of the components (days, hours, minutes,\n        seconds, milliseconds, microseconds, nanoseconds) of the Timedeltas.\n\n        Returns\n        -------\n        a DataFrame\n        \"\"\"\n        from pandas import DataFrame\n\n        columns = ['days', 'hours', 'minutes', 'seconds',\n                   'milliseconds', 'microseconds', 'nanoseconds']\n        hasnans = self.hasnans\n        if hasnans:\n            def f(x):\n                if isna(x):\n                    return [np.nan] * len(columns)\n                return x.components\n        else:\n            def f(x):\n                return x.components\n\n        result = DataFrame([f(x) for x in self])\n        result.columns = columns\n        if not hasnans:\n            result = result.astype('int64')\n        return result\n\n    def total_seconds(self):\n        \"\"\"\n        Return total duration of each element expressed in seconds.\n\n        This method is available directly on TimedeltaIndex and on Series\n        containing timedelta values under the ``.dt`` namespace.\n\n        Returns\n        -------\n        seconds : Float64Index or Series\n            When the calling object is a TimedeltaIndex, the return type is a\n            Float64Index. When the calling object is a Series, the return type\n            is Series of type `float64` whose index is the same as the\n            original.\n\n        See Also\n        --------\n        datetime.timedelta.total_seconds : Standard library version\n            of this method.\n        TimedeltaIndex.components : Return a DataFrame with components of\n            each Timedelta.\n\n        Examples\n        --------\n        **Series**\n\n        >>> s = pd.Series(pd.to_timedelta(np.arange(5), unit='d'))\n        >>> s\n        0   0 days\n        1   1 days\n        2   2 days\n        3   3 days\n        4   4 days\n        dtype: timedelta64[ns]\n\n        >>> s.dt.total_seconds()\n        0         0.0\n        1     86400.0\n        2    172800.0\n        3    259200.0\n        4    345600.0\n        dtype: float64\n\n        **TimedeltaIndex**\n\n        >>> idx = pd.to_timedelta(np.arange(5), unit='d')\n        >>> idx\n        TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'],\n                       dtype='timedelta64[ns]', freq=None)\n\n        >>> idx.total_seconds()\n        Float64Index([0.0, 86400.0, 172800.0, 259200.00000000003, 345600.0],\n                     dtype='float64')\n        \"\"\"\n        return Index(self._maybe_mask_results(1e-9 * self.asi8),\n                     name=self.name)\n\n    def to_pytimedelta(self):\n        \"\"\"\n        Return TimedeltaIndex as object ndarray of datetime.timedelta objects\n\n        Returns\n        -------\n        datetimes : ndarray\n        \"\"\"\n        return libts.ints_to_pytimedelta(self.asi8)\n\n    @Appender(_index_shared_docs['astype'])\n    def astype(self, dtype, copy=True):\n        dtype = pandas_dtype(dtype)\n        if is_timedelta64_dtype(dtype) and not is_timedelta64_ns_dtype(dtype):\n            # return an index (essentially this is division)\n            result = self.values.astype(dtype, copy=copy)\n            if self.hasnans:\n                values = self._maybe_mask_results(result, convert='float64')\n                return Index(values, name=self.name)\n            return Index(result.astype('i8'), name=self.name)\n        return super(TimedeltaIndex, self).astype(dtype, copy=copy)\n\n    def union(self, other):\n        \"\"\"\n        Specialized union for TimedeltaIndex objects. If combine\n        overlapping ranges with the same DateOffset, will be much\n        faster than Index.union\n\n        Parameters\n        ----------\n        other : TimedeltaIndex or array-like\n\n        Returns\n        -------\n        y : Index or TimedeltaIndex\n        \"\"\"\n        self._assert_can_do_setop(other)\n        if not isinstance(other, TimedeltaIndex):\n            try:\n                other = TimedeltaIndex(other)\n            except (TypeError, ValueError):\n                pass\n        this, other = self, other\n\n        if this._can_fast_union(other):\n            return this._fast_union(other)\n        else:\n            result = Index.union(this, other)\n            if isinstance(result, TimedeltaIndex):\n                if result.freq is None:\n                    result.freq = to_offset(result.inferred_freq)\n            return result\n\n    def join(self, other, how='left', level=None, return_indexers=False,\n             sort=False):\n        \"\"\"\n        See Index.join\n        \"\"\"\n        if _is_convertible_to_index(other):\n            try:\n                other = TimedeltaIndex(other)\n            except (TypeError, ValueError):\n                pass\n\n        return Index.join(self, other, how=how, level=level,\n                          return_indexers=return_indexers,\n                          sort=sort)\n\n    def _wrap_joined_index(self, joined, other):\n        name = self.name if self.name == other.name else None\n        if (isinstance(other, TimedeltaIndex) and self.freq == other.freq and\n                self._can_fast_union(other)):\n            joined = self._shallow_copy(joined, name=name)\n            return joined\n        else:\n            return self._simple_new(joined, name)\n\n    def _can_fast_union(self, other):\n        if not isinstance(other, TimedeltaIndex):\n            return False\n\n        freq = self.freq\n\n        if freq is None or freq != other.freq:\n            return False\n\n        if not self.is_monotonic or not other.is_monotonic:\n            return False\n\n        if len(self) == 0 or len(other) == 0:\n            return True\n\n        # to make our life easier, \"sort\" the two ranges\n        if self[0] <= other[0]:\n            left, right = self, other\n        else:\n            left, right = other, self\n\n        right_start = right[0]\n        left_end = left[-1]\n\n        # Only need to \"adjoin\", not overlap\n        return (right_start == left_end + freq) or right_start in left\n\n    def _fast_union(self, other):\n        if len(other) == 0:\n            return self.view(type(self))\n\n        if len(self) == 0:\n            return other.view(type(self))\n\n        # to make our life easier, \"sort\" the two ranges\n        if self[0] <= other[0]:\n            left, right = self, other\n        else:\n            left, right = other, self\n\n        left_end = left[-1]\n        right_end = right[-1]\n\n        # concatenate\n        if left_end < right_end:\n            loc = right.searchsorted(left_end, side='right')\n            right_chunk = right.values[loc:]\n            dates = _concat._concat_compat((left.values, right_chunk))\n            return self._shallow_copy(dates)\n        else:\n            return left\n\n    def _wrap_union_result(self, other, result):\n        name = self.name if self.name == other.name else None\n        return self._simple_new(result, name=name, freq=None)\n\n    def intersection(self, other):\n        \"\"\"\n        Specialized intersection for TimedeltaIndex objects. May be much faster\n        than Index.intersection\n\n        Parameters\n        ----------\n        other : TimedeltaIndex or array-like\n\n        Returns\n        -------\n        y : Index or TimedeltaIndex\n        \"\"\"\n        self._assert_can_do_setop(other)\n        if not isinstance(other, TimedeltaIndex):\n            try:\n                other = TimedeltaIndex(other)\n            except (TypeError, ValueError):\n                pass\n            result = Index.intersection(self, other)\n            return result\n\n        if len(self) == 0:\n            return self\n        if len(other) == 0:\n            return other\n        # to make our life easier, \"sort\" the two ranges\n        if self[0] <= other[0]:\n            left, right = self, other\n        else:\n            left, right = other, self\n\n        end = min(left[-1], right[-1])\n        start = right[0]\n\n        if end < start:\n            return type(self)(data=[])\n        else:\n            lslice = slice(*left.slice_locs(start, end))\n            left_chunk = left.values[lslice]\n            return self._shallow_copy(left_chunk)\n\n    def _maybe_promote(self, other):\n        if other.inferred_type == 'timedelta':\n            other = TimedeltaIndex(other)\n        return self, other\n\n    def get_value(self, series, key):\n        \"\"\"\n        Fast lookup of value from 1-dimensional ndarray. Only use this if you\n        know what you're doing\n        \"\"\"\n\n        if _is_convertible_to_td(key):\n            key = Timedelta(key)\n            return self.get_value_maybe_box(series, key)\n\n        try:\n            return com._maybe_box(self, Index.get_value(self, series, key),\n                                  series, key)\n        except KeyError:\n            try:\n                loc = self._get_string_slice(key)\n                return series[loc]\n            except (TypeError, ValueError, KeyError):\n                pass\n\n            try:\n                return self.get_value_maybe_box(series, key)\n            except (TypeError, ValueError, KeyError):\n                raise KeyError(key)\n\n    def get_value_maybe_box(self, series, key):\n        if not isinstance(key, Timedelta):\n            key = Timedelta(key)\n        values = self._engine.get_value(com._values_from_object(series), key)\n        return com._maybe_box(self, values, series, key)\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location for requested label\n\n        Returns\n        -------\n        loc : int\n        \"\"\"\n        if is_list_like(key):\n            raise TypeError\n\n        if isna(key):\n            key = NaT\n\n        if tolerance is not None:\n            # try converting tolerance now, so errors don't get swallowed by\n            # the try/except clauses below\n            tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n\n        if _is_convertible_to_td(key):\n            key = Timedelta(key)\n            return Index.get_loc(self, key, method, tolerance)\n\n        try:\n            return Index.get_loc(self, key, method, tolerance)\n        except (KeyError, ValueError, TypeError):\n            try:\n                return self._get_string_slice(key)\n            except (TypeError, KeyError, ValueError):\n                pass\n\n            try:\n                stamp = Timedelta(key)\n                return Index.get_loc(self, stamp, method, tolerance)\n            except (KeyError, ValueError):\n                raise KeyError(key)\n\n    def _maybe_cast_slice_bound(self, label, side, kind):\n        \"\"\"\n        If label is a string, cast it to timedelta according to resolution.\n\n\n        Parameters\n        ----------\n        label : object\n        side : {'left', 'right'}\n        kind : {'ix', 'loc', 'getitem'}\n\n        Returns\n        -------\n        label :  object\n\n        \"\"\"\n        assert kind in ['ix', 'loc', 'getitem', None]\n\n        if isinstance(label, compat.string_types):\n            parsed = _coerce_scalar_to_timedelta_type(label, box=True)\n            lbound = parsed.round(parsed.resolution)\n            if side == 'left':\n                return lbound\n            else:\n                return (lbound + to_offset(parsed.resolution) -\n                        Timedelta(1, 'ns'))\n        elif ((is_integer(label) or is_float(label)) and\n              not is_timedelta64_dtype(label)):\n            self._invalid_indexer('slice', label)\n\n        return label\n\n    def _get_string_slice(self, key, use_lhs=True, use_rhs=True):\n        freq = getattr(self, 'freqstr',\n                       getattr(self, 'inferred_freq', None))\n        if is_integer(key) or is_float(key) or key is NaT:\n            self._invalid_indexer('slice', key)\n        loc = self._partial_td_slice(key, freq, use_lhs=use_lhs,\n                                     use_rhs=use_rhs)\n        return loc\n\n    def _partial_td_slice(self, key, freq, use_lhs=True, use_rhs=True):\n\n        # given a key, try to figure out a location for a partial slice\n        if not isinstance(key, compat.string_types):\n            return key\n\n        raise NotImplementedError\n\n        # TODO(wesm): dead code\n        # parsed = _coerce_scalar_to_timedelta_type(key, box=True)\n\n        # is_monotonic = self.is_monotonic\n\n        # # figure out the resolution of the passed td\n        # # and round to it\n\n        # # t1 = parsed.round(reso)\n\n        # t2 = t1 + to_offset(parsed.resolution) - Timedelta(1, 'ns')\n\n        # stamps = self.asi8\n\n        # if is_monotonic:\n\n        #     # we are out of range\n        #     if (len(stamps) and ((use_lhs and t1.value < stamps[0] and\n        #                           t2.value < stamps[0]) or\n        #                          ((use_rhs and t1.value > stamps[-1] and\n        #                            t2.value > stamps[-1])))):\n        #         raise KeyError\n\n        #     # a monotonic (sorted) series can be sliced\n        #     left = (stamps.searchsorted(t1.value, side='left')\n        #             if use_lhs else None)\n        #     right = (stamps.searchsorted(t2.value, side='right')\n        #              if use_rhs else None)\n\n        #     return slice(left, right)\n\n        # lhs_mask = (stamps >= t1.value) if use_lhs else True\n        # rhs_mask = (stamps <= t2.value) if use_rhs else True\n\n        # # try to find a the dates\n        # return (lhs_mask & rhs_mask).nonzero()[0]\n\n    @Substitution(klass='TimedeltaIndex')\n    @Appender(_shared_docs['searchsorted'])\n    @deprecate_kwarg(old_arg_name='key', new_arg_name='value')\n    def searchsorted(self, value, side='left', sorter=None):\n        if isinstance(value, (np.ndarray, Index)):\n            value = np.array(value, dtype=_TD_DTYPE, copy=False)\n        else:\n            value = _to_m8(value)\n\n        return self.values.searchsorted(value, side=side, sorter=sorter)\n\n    def is_type_compatible(self, typ):\n        return typ == self.inferred_type or typ == 'timedelta'\n\n    @property\n    def inferred_type(self):\n        return 'timedelta64'\n\n    @property\n    def dtype(self):\n        return _TD_DTYPE\n\n    @property\n    def is_all_dates(self):\n        return True\n\n    def insert(self, loc, item):\n        \"\"\"\n        Make new Index inserting new item at location\n\n        Parameters\n        ----------\n        loc : int\n        item : object\n            if not either a Python datetime or a numpy integer-like, returned\n            Index dtype will be object rather than datetime.\n\n        Returns\n        -------\n        new_index : Index\n        \"\"\"\n        # try to convert if possible\n        if _is_convertible_to_td(item):\n            try:\n                item = Timedelta(item)\n            except Exception:\n                pass\n        elif is_scalar(item) and isna(item):\n            # GH 18295\n            item = self._na_value\n\n        freq = None\n        if isinstance(item, Timedelta) or (is_scalar(item) and isna(item)):\n\n            # check freq can be preserved on edge cases\n            if self.freq is not None:\n                if ((loc == 0 or loc == -len(self)) and\n                        item + self.freq == self[0]):\n                    freq = self.freq\n                elif (loc == len(self)) and item - self.freq == self[-1]:\n                    freq = self.freq\n            item = _to_m8(item)\n\n        try:\n            new_tds = np.concatenate((self[:loc].asi8, [item.view(np.int64)],\n                                      self[loc:].asi8))\n            return TimedeltaIndex(new_tds, name=self.name, freq=freq)\n\n        except (AttributeError, TypeError):\n\n            # fall back to object index\n            if isinstance(item, compat.string_types):\n                return self.astype(object).insert(loc, item)\n            raise TypeError(\n                \"cannot insert TimedeltaIndex with incompatible label\")\n\n    def delete(self, loc):\n        \"\"\"\n        Make a new TimedeltaIndex with passed location(s) deleted.\n\n        Parameters\n        ----------\n        loc: int, slice or array of ints\n            Indicate which sub-arrays to remove.\n\n        Returns\n        -------\n        new_index : TimedeltaIndex\n        \"\"\"\n        new_tds = np.delete(self.asi8, loc)\n\n        freq = 'infer'\n        if is_integer(loc):\n            if loc in (0, -len(self), -1, len(self) - 1):\n                freq = self.freq\n        else:\n            if is_list_like(loc):\n                loc = lib.maybe_indices_to_slice(\n                    _ensure_int64(np.array(loc)), len(self))\n            if isinstance(loc, slice) and loc.step in (1, None):\n                if (loc.start in (0, None) or loc.stop in (len(self), None)):\n                    freq = self.freq\n\n        return TimedeltaIndex(new_tds, name=self.name, freq=freq)\n\n\nTimedeltaIndex._add_comparison_methods()\nTimedeltaIndex._add_numeric_methods()\nTimedeltaIndex._add_logical_methods_disabled()\nTimedeltaIndex._add_datetimelike_methods()\n\n\ndef _is_convertible_to_index(other):\n    \"\"\"\n    return a boolean whether I can attempt conversion to a TimedeltaIndex\n    \"\"\"\n    if isinstance(other, TimedeltaIndex):\n        return True\n    elif (len(other) > 0 and\n          other.inferred_type not in ('floating', 'mixed-integer', 'integer',\n                                      'mixed-integer-float', 'mixed')):\n        return True\n    return False\n\n\ndef _is_convertible_to_td(key):\n    return isinstance(key, (Tick, timedelta,\n                            np.timedelta64, compat.string_types))\n\n\ndef _to_m8(key):\n    \"\"\"\n    Timedelta-like => dt64\n    \"\"\"\n    if not isinstance(key, Timedelta):\n        # this also converts strings\n        key = Timedelta(key)\n\n    # return an type that can be compared\n    return np.int64(key.value).view(_TD_DTYPE)\n\n\ndef _generate_regular_range(start, end, periods, offset):\n    stride = offset.nanos\n    if periods is None:\n        b = Timedelta(start).value\n        e = Timedelta(end).value\n        e += stride - e % stride\n    elif start is not None:\n        b = Timedelta(start).value\n        e = b + periods * stride\n    elif end is not None:\n        e = Timedelta(end).value + stride\n        b = e - periods * stride\n    else:\n        raise ValueError(\"at least 'start' or 'end' should be specified \"\n                         \"if a 'period' is given.\")\n\n    data = np.arange(b, e, stride, dtype=np.int64)\n    data = TimedeltaIndex._simple_new(data, None)\n\n    return data\n\n\ndef timedelta_range(start=None, end=None, periods=None, freq='D',\n                    name=None, closed=None):\n    \"\"\"\n    Return a fixed frequency TimedeltaIndex, with day as the default\n    frequency\n\n    Parameters\n    ----------\n    start : string or timedelta-like, default None\n        Left bound for generating timedeltas\n    end : string or timedelta-like, default None\n        Right bound for generating timedeltas\n    periods : integer, default None\n        Number of periods to generate\n    freq : string or DateOffset, default 'D' (calendar daily)\n        Frequency strings can have multiples, e.g. '5H'\n    name : string, default None\n        Name of the resulting TimedeltaIndex\n    closed : string, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None)\n\n    Returns\n    -------\n    rng : TimedeltaIndex\n\n    Notes\n    -----\n    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two\n    must be specified.\n\n    To learn more about the frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n\n    >>> pd.timedelta_range(start='1 day', periods=4)\n    TimedeltaIndex(['1 days', '2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``closed`` parameter specifies which endpoint is included.  The default\n    behavior is to include both endpoints.\n\n    >>> pd.timedelta_range(start='1 day', periods=4, closed='right')\n    TimedeltaIndex(['2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``freq`` parameter specifies the frequency of the TimedeltaIndex.\n    Only fixed frequencies can be passed, non-fixed frequencies such as\n    'M' (month end) will raise.\n\n    >>> pd.timedelta_range(start='1 day', end='2 days', freq='6H')\n    TimedeltaIndex(['1 days 00:00:00', '1 days 06:00:00', '1 days 12:00:00',\n                    '1 days 18:00:00', '2 days 00:00:00'],\n                   dtype='timedelta64[ns]', freq='6H')\n    \"\"\"\n    return TimedeltaIndex(start=start, end=end, periods=periods,\n                          freq=freq, name=name, closed=closed)\n"
    },
    {
      "filename": "pandas/tests/indexing/test_timedelta.py",
      "content": "import pytest\n\nimport pandas as pd\nfrom pandas.util import testing as tm\nimport numpy as np\n\n\nclass TestTimedeltaIndexing(object):\n    def test_boolean_indexing(self):\n        # GH 14946\n        df = pd.DataFrame({'x': range(10)})\n        df.index = pd.to_timedelta(range(10), unit='s')\n        conditions = [df['x'] > 3, df['x'] == 3, df['x'] < 3]\n        expected_data = [[0, 1, 2, 3, 10, 10, 10, 10, 10, 10],\n                         [0, 1, 2, 10, 4, 5, 6, 7, 8, 9],\n                         [10, 10, 10, 3, 4, 5, 6, 7, 8, 9]]\n        for cond, data in zip(conditions, expected_data):\n            result = df.assign(x=df.mask(cond, 10).astype('int64'))\n            expected = pd.DataFrame(data,\n                                    index=pd.to_timedelta(range(10), unit='s'),\n                                    columns=['x'],\n                                    dtype='int64')\n            tm.assert_frame_equal(expected, result)\n\n    @pytest.mark.parametrize(\n        \"indexer, expected\",\n        [(0, [20, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n         (slice(4, 8), [0, 1, 2, 3, 20, 20, 20, 20, 8, 9]),\n         ([3, 5], [0, 1, 2, 20, 4, 20, 6, 7, 8, 9])])\n    def test_list_like_indexing(self, indexer, expected):\n        # GH 16637\n        df = pd.DataFrame({'x': range(10)}, dtype=\"int64\")\n        df.index = pd.to_timedelta(range(10), unit='s')\n\n        df.loc[df.index[indexer], 'x'] = 20\n\n        expected = pd.DataFrame(expected,\n                                index=pd.to_timedelta(range(10), unit='s'),\n                                columns=['x'],\n                                dtype=\"int64\")\n\n        tm.assert_frame_equal(expected, df)\n\n    def test_string_indexing(self):\n        # GH 16896\n        df = pd.DataFrame({'x': range(3)},\n                          index=pd.to_timedelta(range(3), unit='days'))\n        expected = df.iloc[0]\n        sliced = df.loc['0 days']\n        tm.assert_series_equal(sliced, expected)\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [None, pd.NaT, np.nan])\n    def test_masked_setitem(self, value):\n        # issue (#18586)\n        series = pd.Series([0, 1, 2], dtype='timedelta64[ns]')\n        series[series == series[0]] = value\n        expected = pd.Series([pd.NaT, 1, 2], dtype='timedelta64[ns]')\n        tm.assert_series_equal(series, expected)\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [None, pd.NaT, np.nan])\n    def test_listlike_setitem(self, value):\n        # issue (#18586)\n        series = pd.Series([0, 1, 2], dtype='timedelta64[ns]')\n        series.iloc[0] = value\n        expected = pd.Series([pd.NaT, 1, 2], dtype='timedelta64[ns]')\n        tm.assert_series_equal(series, expected)\n\n    @pytest.mark.parametrize('start,stop, expected_slice', [\n        [np.timedelta64(0, 'ns'), None, slice(0, 11)],\n        [np.timedelta64(1, 'D'), np.timedelta64(6, 'D'), slice(1, 7)],\n        [None, np.timedelta64(4, 'D'), slice(0, 5)]])\n    def test_numpy_timedelta_scalar_indexing(self, start, stop,\n                                             expected_slice):\n        # GH 20393\n        s = pd.Series(range(11), pd.timedelta_range('0 days', '10 days'))\n        result = s.loc[slice(start, stop)]\n        expected = s.iloc[expected_slice]\n        tm.assert_series_equal(result, expected)\n"
    }
  ],
  "questions": [
    "Any suggestions on how to go about this? @mroeschke @MarcoGorelli \r\n\r\nI noticed some files related to `loc` method in these places\r\n\r\ncode - pandas/core/indexing.py\r\n\r\ntests:\r\npandas/tests/indexing/test_loc.py\r\npandas/tests/indexing/multiindex/test_loc.py\r\npandas/tests/series/indexing/test_loc.py\r\n\r\nI still have to understand the existing tests and then write the new ones. I'm pretty new to Python ðŸ˜… Let me know if this is a big issue to pickup. I can pickup something smaller in that case. \r\n\r\nPS: I'm still stuck at my machine setup - I tried VS Code Remote Containers setup but it didn't work out, I think it's because it took up lots of RAM and was killed because of Out Of Memory, as I have set some limits in my Docker Desktop, like 1GB RAM. I plan to setup the whole thing in my local. Is that okay? I hope it doesn't affect any of my other python related software / tools I use, given it is more sandboxed with virtualenv (I'm assuming. Python newbie here)",
    "Hi @karuppiah7890 \r\n\r\n> I plan to setup the whole thing in my local. Is that okay?\r\n\r\nYup, that's what I've done, I have a `pandas-dev` conda environment, feel free to ask if you have trouble setting up",
    "#### Code Sample, a copy-pastable example if possible\r\nBasic example of the issue, specific to `TimedeltaIndex`, xref https://github.com/pandas-dev/pandas/pull/20408#discussion_r175627548\r\n```python\r\nIn [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n\r\nIn [3]: s.loc[True]\r\nOut[3]: 'b'\r\n\r\nIn [4]: s.loc[False:True]\r\nOut[4]:\r\n00:00:00           a\r\n00:00:00.000000    b\r\nFreq: N, dtype: object\r\n```\r\n\r\nIndexing with both boolean labels and slices was successful, which doesn't seem right.\r\n\r\nI investigated this same behavior across various index types for both `Series` and `DataFrame`, and produced the summary below.\r\n\r\n**Summary**\r\n- 'raises' column indicates if the indexing operation raised an exception\r\n-  'exception' column indicates the type of exception raised\r\n<details>\r\n\r\n```\r\n                                  raises  exception\r\nCategoricalIndex DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label   False        NaN\r\n                           slice    True   KeyError\r\nDatetimeIndex    DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nFloat64Index     DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nIndex            DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nInt64Index       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nIntervalIndex    DataFrame label    True  TypeError\r\n                           slice    True  TypeError\r\n                 Series    label    True  TypeError\r\n                           slice    True  TypeError\r\nMultiIndex       DataFrame label    True   KeyError\r\n                           slice    True   KeyError\r\n                 Series    label    True   KeyError\r\n                           slice    True   KeyError\r\nPeriodIndex      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nRangeIndex       DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\nTimedeltaIndex   DataFrame label   False        NaN\r\n                           slice   False        NaN\r\n                 Series    label   False        NaN\r\n                           slice   False        NaN\r\nUInt64Index      DataFrame label    True   KeyError\r\n                           slice   False        NaN\r\n                 Series    label    True   KeyError\r\n                           slice   False        NaN\r\n```\r\n</details>\r\n\r\n<br />\r\n\r\n**Code to produce summary**\r\n<details>\r\n\r\n```python\r\nindexes = [\r\n    pd.RangeIndex(4),\r\n    pd.Int64Index(range(4)),\r\n    pd.UInt64Index(range(4)),\r\n    pd.Float64Index(range(4)),\r\n    pd.CategoricalIndex(range(4)),\r\n    pd.date_range(0, periods=4, freq='ns'),\r\n    pd.timedelta_range(0, periods=4, freq='ns'),\r\n    pd.interval_range(0, periods=4),\r\n    pd.Index([0, 1, 2, 3], dtype=object),\r\n    pd.MultiIndex.from_product([[0, 1], [0, 1]]),\r\n    pd.period_range('2018Q1', freq='Q', periods=4),  # need better example here\r\n]\r\n\r\nresult = {}\r\nfor index in indexes:\r\n    index_name = type(index).__name__\r\n    s = pd.Series(list('abcd'), index=index)\r\n    for obj in (s, s.to_frame()):\r\n        obj_name = type(obj).__name__\r\n\r\n        # check single label\r\n        key = (index_name, obj_name, 'label')\r\n        try:\r\n            obj.loc[True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\n        # check slice\r\n        key = (index_name, obj_name, 'slice')\r\n        try:\r\n            obj.loc[False:True]\r\n            result[key] = {'raises': False}\r\n        except Exception as e:\r\n            result[key] = {'raises': True, 'exception': type(e).__name__}\r\n\r\nresult = pd.DataFrame.from_dict(result, orient='index')\r\n```\r\n</details>\r\n\r\n#### Expected Output\r\nI'd generally expect all of these operations to raise a `KeyError`, which a couple potential exceptions:\r\n\r\n- I'd be open to an argument for numeric indexes casting to integer equivalent.  Seems like this should at least be consistent for labels vs slices, which it is not right now.\r\n- Maybe we should allow conversion for the `object` dtype `Index`?"
  ],
  "golden_answers": [
    "Hi @karuppiah7890 \r\n\r\n> I plan to setup the whole thing in my local. Is that okay?\r\n\r\nYup, that's what I've done, I have a `pandas-dev` conda environment, feel free to ask if you have trouble setting up",
    "I have setup the environment. I tried to run the tests, but there were tons, so stopped it in between. Can someone help me understand what kind of test is needed here?\r\n\r\nAre we looking for tests that assert for `KeyError` and `TypeError` ?\r\n\r\n```python\r\n\r\nIn [40]: In [2]: s = pd.Series(list('abcde'), pd.timedelta_range(0, 4, freq='ns'))\r\n    ...:\r\n    ...: In [3]: s.loc[True]\r\nKeyError: True\r\n\r\nIn [41]: In [4]: s.loc[False:True]\r\nTypeError: Unexpected type for 'value': <class 'bool'>\r\n```",
    "yeah I agree slice should certainly raise, prob ``TypeError``. There is some small precedent for a label (or even list-indexer) of booleans to work on a *boolean* inferred index type (so very small exception here). \r\n\r\nBut I think making all of these TypeError is prob reasonable. I wouldn't cast."
  ],
  "questions_generated": [
    "Why does the TimedeltaIndex allow boolean labels and slices without raising an exception?",
    "What kind of exception is generally expected when attempting to use boolean labels or slices with DataFrame/Series.loc?",
    "How does the handling of boolean indexing differ between TimedeltaIndex and other index types like Int64Index or CategoricalIndex?",
    "What could be the implications of allowing boolean indexers in TimedeltaIndex without raising exceptions?",
    "What changes might be necessary in the pandas codebase to ensure consistent handling of boolean indexers across different index types?"
  ],
  "golden_answers_generated": [
    "In the current implementation of TimedeltaIndex, both boolean labels and slices are treated as valid indexers. This behavior is inconsistent with other index types, where such operations usually raise a KeyError. The code does not have checks in place to restrict boolean indexing for TimedeltaIndex, leading to unintended behavior.",
    "The expected behavior when using boolean labels or slices with DataFrame/Series.loc is to raise a KeyError, as boolean values are not typically valid keys for most index types. This is evident from the summary table where most other index types raise a KeyError under similar circumstances.",
    "For TimedeltaIndex, boolean labels and slices do not raise exceptions and are allowed, whereas for other index types like Int64Index or CategoricalIndex, using boolean labels raises a KeyError. This inconsistency highlights a potential bug in how TimedeltaIndex handles boolean indexing.",
    "Allowing boolean indexers in TimedeltaIndex without raising exceptions can lead to unexpected behavior and data integrity issues. Users might mistakenly assume that boolean indexing is valid and meaningful for TimedeltaIndex, leading to incorrect data access or manipulation. It also creates inconsistency across the pandas library, potentially causing confusion and bugs.",
    "To ensure consistency, the pandas codebase would need to add checks in the TimedeltaIndex implementation to raise KeyError when boolean indexers are used, aligning its behavior with other index types. This would likely involve adding conditional logic to detect boolean inputs and respond with appropriate exceptions, possibly requiring updates to index validation routines."
  ]
}