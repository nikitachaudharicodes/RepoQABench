{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "47953",
  "issue_description": "# BUG: inconsistent behavior of DateOffset\n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [X] I have confirmed this bug exists on the main branch of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n\r\ndf = pd.DataFrame({\r\n   'S':[pd.Timestamp('2019-04-30')],\r\n   'A':[pd.DateOffset(months=1)]\r\n   })\r\n\r\n# FIRST TEST\r\n>>> df['S'] + 26 * df['A']\r\n0   2021-06-30\r\ndtype: datetime64[ns]\r\n\r\n# SECOND TEST\r\n>>> df['S'].iloc[0] + 26 * df['A'].iloc[0]\r\nTimestamp('2021-06-28 00:00:00')\n```\n\n\n### Issue Description\n\nIt seems like multiplying a DateOffset by constant leads to an inconsistent behavior: the first test gives 30/6 while the second 28/6 \n\n### Expected Behavior\n\nIn any case it should be 2021-06-30\n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 66e3805b8cabe977f40c05259cc3fcf7ead5687d\r\npython           : 3.10.1.final.0\r\npython-bits      : 64\r\nOS               : Windows\r\nOS-release       : 10\r\nVersion          : 10.0.19042\r\nmachine          : AMD64\r\nprocessor        : Intel64 Family 6 Model 126 Stepping 5, GenuineIntel\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : None\r\nLOCALE           : Italian_Italy.1252\r\n\r\npandas           : 1.3.5\r\nnumpy            : 1.21.5\r\npytz             : 2021.3\r\ndateutil         : 2.8.2\r\npip              : 21.3.1\r\nsetuptools       : 58.1.0\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : 4.8.0\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : None\r\nIPython          : 8.1.1\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nfsspec           : None\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.5.1\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : 3.0.9\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.7.3\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 1208953272,
      "user": "pratyushsharan",
      "body": "While this is a bug, I would say that the second test actually gives the correct results (because you're adding one month at a time, when you add 1 month to 30-Jan-2020, you get 29-Feb-2020, and next year it'd be 28-Feb-2021).\r\nBut it is a bug because the results mismatch when you add offsets to a series v/s a Timestamp.\r\nThis would require a bug fix and maybe some test cases."
    },
    {
      "id": 1209000821,
      "user": "pratyushsharan",
      "body": "I had another look into this, looks like the problem is inside cython code. Applying offset to`df['S']` does this:\r\n`months = (kwds.get(\"years\", 0) * 12 + kwds.get(\"months\", 0)) * self.n` inside offsets.pyx, so in essence it calculates months=1*26=26months and then applies the offset as `months=26` rather than applying `months=1` offset 26 times (which is what happens when offset is applied to a Timestamp rather than DatetimeArray).\r\n\r\nSummary: When applying multiple offsets to DatetimeArray, Cython tries to accumulate months/weeks/days first and then applies one single offset. But when offset is applied to a Timestamp object, the offsets are applied iteratively, which is more accurate when providing multiple offsets.\r\n\r\nSolution: changes to offsets.pyx along with test cases.\r\n\r\nWould like to know your views @jreback, @jbrockmendel \r\n"
    },
    {
      "id": 1209047417,
      "user": "colomb8",
      "body": "> While this is a bug, I would say that the second test actually gives the correct results (because you're adding one month at a time, when you add 1 month to 30-Jan-2020, you get 29-Feb-2020, and next year it'd be 28-Feb-2021). But it is a bug because the results mismatch when you add offsets to a series v/s a Timestamp. This would require a bug fix and maybe some test cases.\r\n\r\nhi, I would say that the correct result should be 2021-06-30, since it is coherent with datatime relativedelta.\r\nMoreover, please consider the use case when you have a column with number of months and a column with a monthly dateoffset and let's imagine I have to obtain the 2021-06-30 effect; in such case I have to multiply the two columns and I have no other alternatives...(except creating different dateoffset rowwise, that is not so clean..)"
    },
    {
      "id": 1209051512,
      "user": "colomb8",
      "body": "> \r\n\r\nhi I would add that the dataframe gives 2021-06-30 if it has 1 row and 2021-06-28 in case of 2 identical rows...\r\n\r\nthere are several bugs here, however imho the right result should be 2021-06-30 (coherent with relativedelta). \"2 * 1 month\" intuitively should be equal to \"2 months\", no?"
    },
    {
      "id": 1209114011,
      "user": "pratyushsharan",
      "body": "It all comes down to how one interprets multiplying a offset/relativedelta by a scalar. I'll try to show by examples:\r\n```python\r\nimport pandas as pd\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nbase_date = pd.Timestamp('2020-01-30')\r\n\r\noffset_1month = pd.DateOffset(months=1)\r\noffset_2month = pd.DateOffset(months=2)\r\ndelta_1month = relativedelta(months=1)\r\ndelta_2month = relativedelta(months=2)\r\n\r\nbase_date + 2 * offset_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + offset_1month + offset_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + offset_2month\r\n>>> Timestamp('2020-03-30 00:00:00')\r\n\r\nbase_date + 2 * delta_1month\r\n>>> Timestamp('2020-03-30 00:00:00')\r\n\r\nbase_date + delta_1month + delta_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + delta_2month\r\n>>>Timestamp('2020-03-30 00:00:00')\r\n```\r\n\r\nAs you can see, multiplying `pd.DateOffset` by scalar `n` basically means applying the `pd.Offset` `n` times. However, relativedelta operates in a different way, where if you multiply `relativedelta` by scalar `n`, they first re-calculate the `relativedelta` and then apply to the `base_date`, hence you see different values for 4th and 5th statements.\r\n\r\nI think we need to first decide what we want to do when a `pd.Offset` is multiplied by a scalar `n` (apply `pd.Offset` `n` times or recalculate `pd.Offset` and then move the `base_date`)."
    },
    {
      "id": 1224911195,
      "user": "srotondo",
      "body": "The difference arises due to the fact that in the `offset.pyx` file, where the addition is done, the scalar case uses a loop with a variable `n` in the `RelativeDeltaOffset` function `_apply` to calculate with multiplication, and an array simply multiplies the whole offset value by `n` in the `RelativeDeltaOffset` function `_apply_array` before adding."
    },
    {
      "id": 1226003600,
      "user": "srotondo",
      "body": "take"
    },
    {
      "id": 1226600830,
      "user": "srotondo",
      "body": "Other similar instances of this operation in other related classes to `DateOffset` use the method where they calculate the combined offset of all `n` multiplications and move the date as such, so I think this instance should function the same way.  I also think it's more in line with what a user performing this operation would want."
    },
    {
      "id": 1227169905,
      "user": "colomb8",
      "body": "> Other similar instances of this operation in other related classes to `DateOffset` use the method where they calculate the combined offset of all `n` multiplications and move the date as such, so I think this instance should function the same way. I also think it's more in line with what a user performing this operation would want.\r\n\r\ngreat.\r\n\r\nplease consider also this strange behavior: 1 row df differs from 2 rows df, even if these rows are equal\r\n\r\n\r\n```\r\n>>> df = pd.DataFrame({\r\n   'S':[pd.Timestamp('2019-04-30')],\r\n   'A':[pd.DateOffset(months=1)]\r\n   })\r\n\r\n>>> df['S'] + 26 * df['A']\r\n\r\n0   2021-06-30\r\ndtype: datetime64[ns]\r\n\r\n>>> df2 = df.append(df)\r\n\r\n>>> df2['S'] + 26 * df2['A']\r\n\r\n0   2021-06-28\r\n0   2021-06-28\r\ndtype: datetime64[ns]\r\n```\r\n"
    },
    {
      "id": 1227861509,
      "user": "jbrockmendel",
      "body": "> please consider also this strange behavior: 1 row df differs from 2 rows df, even if these rows are equal\r\n\r\nI expect this is bc of a fastpath in _addsub_object_array.  id be OK with removing that fastpath."
    },
    {
      "id": 1227863136,
      "user": "jbrockmendel",
      "body": "for RelativeDeltaOffset._apply let's just multiply _offset by n instead of the loop.  Will that be consistent with apply_array?  If we can share anyhting with apply_array that'd be ideal"
    },
    {
      "id": 1525086380,
      "user": "MarcoGorelli",
      "body": "this PR looked pretty close, if anyone wants to take it forward https://github.com/pandas-dev/pandas/pull/50542"
    },
    {
      "id": 1588892364,
      "user": "rsm-23",
      "body": "take"
    },
    {
      "id": 1588895847,
      "user": "rsm-23",
      "body": "@MarcoGorelli this is my first open source contribution. Is it okay to follow the same steps as in [#50542](https://github.com/pandas-dev/pandas/pull/50542) and resolve the comments in my branch?"
    },
    {
      "id": 1589065029,
      "user": "MarcoGorelli",
      "body": "yeah probably"
    }
  ],
  "text_context": "# BUG: inconsistent behavior of DateOffset\n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [X] I have confirmed this bug exists on the main branch of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n\r\ndf = pd.DataFrame({\r\n   'S':[pd.Timestamp('2019-04-30')],\r\n   'A':[pd.DateOffset(months=1)]\r\n   })\r\n\r\n# FIRST TEST\r\n>>> df['S'] + 26 * df['A']\r\n0   2021-06-30\r\ndtype: datetime64[ns]\r\n\r\n# SECOND TEST\r\n>>> df['S'].iloc[0] + 26 * df['A'].iloc[0]\r\nTimestamp('2021-06-28 00:00:00')\n```\n\n\n### Issue Description\n\nIt seems like multiplying a DateOffset by constant leads to an inconsistent behavior: the first test gives 30/6 while the second 28/6 \n\n### Expected Behavior\n\nIn any case it should be 2021-06-30\n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 66e3805b8cabe977f40c05259cc3fcf7ead5687d\r\npython           : 3.10.1.final.0\r\npython-bits      : 64\r\nOS               : Windows\r\nOS-release       : 10\r\nVersion          : 10.0.19042\r\nmachine          : AMD64\r\nprocessor        : Intel64 Family 6 Model 126 Stepping 5, GenuineIntel\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : None\r\nLOCALE           : Italian_Italy.1252\r\n\r\npandas           : 1.3.5\r\nnumpy            : 1.21.5\r\npytz             : 2021.3\r\ndateutil         : 2.8.2\r\npip              : 21.3.1\r\nsetuptools       : 58.1.0\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : 4.8.0\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : None\r\nIPython          : 8.1.1\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nfsspec           : None\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.5.1\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : 3.0.9\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.7.3\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n\r\n</details>\r\n\n\nWhile this is a bug, I would say that the second test actually gives the correct results (because you're adding one month at a time, when you add 1 month to 30-Jan-2020, you get 29-Feb-2020, and next year it'd be 28-Feb-2021).\r\nBut it is a bug because the results mismatch when you add offsets to a series v/s a Timestamp.\r\nThis would require a bug fix and maybe some test cases.\n\nI had another look into this, looks like the problem is inside cython code. Applying offset to`df['S']` does this:\r\n`months = (kwds.get(\"years\", 0) * 12 + kwds.get(\"months\", 0)) * self.n` inside offsets.pyx, so in essence it calculates months=1*26=26months and then applies the offset as `months=26` rather than applying `months=1` offset 26 times (which is what happens when offset is applied to a Timestamp rather than DatetimeArray).\r\n\r\nSummary: When applying multiple offsets to DatetimeArray, Cython tries to accumulate months/weeks/days first and then applies one single offset. But when offset is applied to a Timestamp object, the offsets are applied iteratively, which is more accurate when providing multiple offsets.\r\n\r\nSolution: changes to offsets.pyx along with test cases.\r\n\r\nWould like to know your views @jreback, @jbrockmendel \r\n\n\n> While this is a bug, I would say that the second test actually gives the correct results (because you're adding one month at a time, when you add 1 month to 30-Jan-2020, you get 29-Feb-2020, and next year it'd be 28-Feb-2021). But it is a bug because the results mismatch when you add offsets to a series v/s a Timestamp. This would require a bug fix and maybe some test cases.\r\n\r\nhi, I would say that the correct result should be 2021-06-30, since it is coherent with datatime relativedelta.\r\nMoreover, please consider the use case when you have a column with number of months and a column with a monthly dateoffset and let's imagine I have to obtain the 2021-06-30 effect; in such case I have to multiply the two columns and I have no other alternatives...(except creating different dateoffset rowwise, that is not so clean..)\n\n> \r\n\r\nhi I would add that the dataframe gives 2021-06-30 if it has 1 row and 2021-06-28 in case of 2 identical rows...\r\n\r\nthere are several bugs here, however imho the right result should be 2021-06-30 (coherent with relativedelta). \"2 * 1 month\" intuitively should be equal to \"2 months\", no?\n\nIt all comes down to how one interprets multiplying a offset/relativedelta by a scalar. I'll try to show by examples:\r\n```python\r\nimport pandas as pd\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\nbase_date = pd.Timestamp('2020-01-30')\r\n\r\noffset_1month = pd.DateOffset(months=1)\r\noffset_2month = pd.DateOffset(months=2)\r\ndelta_1month = relativedelta(months=1)\r\ndelta_2month = relativedelta(months=2)\r\n\r\nbase_date + 2 * offset_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + offset_1month + offset_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + offset_2month\r\n>>> Timestamp('2020-03-30 00:00:00')\r\n\r\nbase_date + 2 * delta_1month\r\n>>> Timestamp('2020-03-30 00:00:00')\r\n\r\nbase_date + delta_1month + delta_1month\r\n>>> Timestamp('2020-03-29 00:00:00')\r\n\r\nbase_date + delta_2month\r\n>>>Timestamp('2020-03-30 00:00:00')\r\n```\r\n\r\nAs you can see, multiplying `pd.DateOffset` by scalar `n` basically means applying the `pd.Offset` `n` times. However, relativedelta operates in a different way, where if you multiply `relativedelta` by scalar `n`, they first re-calculate the `relativedelta` and then apply to the `base_date`, hence you see different values for 4th and 5th statements.\r\n\r\nI think we need to first decide what we want to do when a `pd.Offset` is multiplied by a scalar `n` (apply `pd.Offset` `n` times or recalculate `pd.Offset` and then move the `base_date`).\n\nThe difference arises due to the fact that in the `offset.pyx` file, where the addition is done, the scalar case uses a loop with a variable `n` in the `RelativeDeltaOffset` function `_apply` to calculate with multiplication, and an array simply multiplies the whole offset value by `n` in the `RelativeDeltaOffset` function `_apply_array` before adding.\n\ntake\n\nOther similar instances of this operation in other related classes to `DateOffset` use the method where they calculate the combined offset of all `n` multiplications and move the date as such, so I think this instance should function the same way.  I also think it's more in line with what a user performing this operation would want.\n\n> Other similar instances of this operation in other related classes to `DateOffset` use the method where they calculate the combined offset of all `n` multiplications and move the date as such, so I think this instance should function the same way. I also think it's more in line with what a user performing this operation would want.\r\n\r\ngreat.\r\n\r\nplease consider also this strange behavior: 1 row df differs from 2 rows df, even if these rows are equal\r\n\r\n\r\n```\r\n>>> df = pd.DataFrame({\r\n   'S':[pd.Timestamp('2019-04-30')],\r\n   'A':[pd.DateOffset(months=1)]\r\n   })\r\n\r\n>>> df['S'] + 26 * df['A']\r\n\r\n0   2021-06-30\r\ndtype: datetime64[ns]\r\n\r\n>>> df2 = df.append(df)\r\n\r\n>>> df2['S'] + 26 * df2['A']\r\n\r\n0   2021-06-28\r\n0   2021-06-28\r\ndtype: datetime64[ns]\r\n```\r\n\n\n> please consider also this strange behavior: 1 row df differs from 2 rows df, even if these rows are equal\r\n\r\nI expect this is bc of a fastpath in _addsub_object_array.  id be OK with removing that fastpath.\n\nfor RelativeDeltaOffset._apply let's just multiply _offset by n instead of the loop.  Will that be consistent with apply_array?  If we can share anyhting with apply_array that'd be ideal\n\nthis PR looked pretty close, if anyone wants to take it forward https://github.com/pandas-dev/pandas/pull/50542\n\ntake\n\n@MarcoGorelli this is my first open source contribution. Is it okay to follow the same steps as in [#50542](https://github.com/pandas-dev/pandas/pull/50542) and resolve the comments in my branch?\n\nyeah probably",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/50542",
  "code_context": [
    {
      "filename": "pandas/tests/tseries/offsets/test_offsets.py",
      "content": "\"\"\"\nTests of pandas.tseries.offsets\n\"\"\"\nfrom __future__ import annotations\n\nfrom datetime import (\n    datetime,\n    timedelta,\n)\nfrom typing import (\n    Dict,\n    List,\n    Tuple,\n)\nimport warnings\n\nimport numpy as np\nimport pytest\n\nfrom pandas._libs.tslibs import (\n    NaT,\n    Timedelta,\n    Timestamp,\n    conversion,\n    timezones,\n)\nimport pandas._libs.tslibs.offsets as liboffsets\nfrom pandas._libs.tslibs.offsets import (\n    _get_offset,\n    _offset_map,\n)\nfrom pandas._libs.tslibs.period import INVALID_FREQ_ERR_MSG\nfrom pandas.errors import PerformanceWarning\n\nfrom pandas import (\n    DataFrame,\n    DatetimeIndex,\n    Series,\n    date_range,\n)\nimport pandas._testing as tm\nfrom pandas.tests.tseries.offsets.common import WeekDay\n\nfrom pandas.tseries import offsets\nfrom pandas.tseries.offsets import (\n    FY5253,\n    BaseOffset,\n    BDay,\n    BMonthEnd,\n    BusinessHour,\n    CustomBusinessDay,\n    CustomBusinessHour,\n    CustomBusinessMonthBegin,\n    CustomBusinessMonthEnd,\n    DateOffset,\n    Easter,\n    FY5253Quarter,\n    LastWeekOfMonth,\n    MonthBegin,\n    Nano,\n    Tick,\n    Week,\n    WeekOfMonth,\n)\n\n_ApplyCases = List[Tuple[BaseOffset, Dict[datetime, datetime]]]\n\n_ARITHMETIC_DATE_OFFSET = [\n    \"years\",\n    \"months\",\n    \"weeks\",\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\",\n    \"microseconds\",\n]\n\n\ndef _create_offset(klass, value=1, normalize=False):\n    # create instance from offset class\n    if klass is FY5253:\n        klass = klass(\n            n=value,\n            startingMonth=1,\n            weekday=1,\n            variation=\"last\",\n            normalize=normalize,\n        )\n    elif klass is FY5253Quarter:\n        klass = klass(\n            n=value,\n            startingMonth=1,\n            weekday=1,\n            qtr_with_extra_week=1,\n            variation=\"last\",\n            normalize=normalize,\n        )\n    elif klass is LastWeekOfMonth:\n        klass = klass(n=value, weekday=5, normalize=normalize)\n    elif klass is WeekOfMonth:\n        klass = klass(n=value, week=1, weekday=5, normalize=normalize)\n    elif klass is Week:\n        klass = klass(n=value, weekday=5, normalize=normalize)\n    elif klass is DateOffset:\n        klass = klass(days=value, normalize=normalize)\n    else:\n        klass = klass(value, normalize=normalize)\n    return klass\n\n\n@pytest.fixture\ndef dt():\n    return Timestamp(datetime(2008, 1, 2))\n\n\n@pytest.fixture\ndef expecteds():\n    # executed value created by _create_offset\n    # are applied to 2011/01/01 09:00 (Saturday)\n    # used for .apply and .rollforward\n    return {\n        \"Day\": Timestamp(\"2011-01-02 09:00:00\"),\n        \"DateOffset\": Timestamp(\"2011-01-02 09:00:00\"),\n        \"BusinessDay\": Timestamp(\"2011-01-03 09:00:00\"),\n        \"CustomBusinessDay\": Timestamp(\"2011-01-03 09:00:00\"),\n        \"CustomBusinessMonthEnd\": Timestamp(\"2011-01-31 09:00:00\"),\n        \"CustomBusinessMonthBegin\": Timestamp(\"2011-01-03 09:00:00\"),\n        \"MonthBegin\": Timestamp(\"2011-02-01 09:00:00\"),\n        \"BusinessMonthBegin\": Timestamp(\"2011-01-03 09:00:00\"),\n        \"MonthEnd\": Timestamp(\"2011-01-31 09:00:00\"),\n        \"SemiMonthEnd\": Timestamp(\"2011-01-15 09:00:00\"),\n        \"SemiMonthBegin\": Timestamp(\"2011-01-15 09:00:00\"),\n        \"BusinessMonthEnd\": Timestamp(\"2011-01-31 09:00:00\"),\n        \"YearBegin\": Timestamp(\"2012-01-01 09:00:00\"),\n        \"BYearBegin\": Timestamp(\"2011-01-03 09:00:00\"),\n        \"YearEnd\": Timestamp(\"2011-12-31 09:00:00\"),\n        \"BYearEnd\": Timestamp(\"2011-12-30 09:00:00\"),\n        \"QuarterBegin\": Timestamp(\"2011-03-01 09:00:00\"),\n        \"BQuarterBegin\": Timestamp(\"2011-03-01 09:00:00\"),\n        \"QuarterEnd\": Timestamp(\"2011-03-31 09:00:00\"),\n        \"BQuarterEnd\": Timestamp(\"2011-03-31 09:00:00\"),\n        \"BusinessHour\": Timestamp(\"2011-01-03 10:00:00\"),\n        \"CustomBusinessHour\": Timestamp(\"2011-01-03 10:00:00\"),\n        \"WeekOfMonth\": Timestamp(\"2011-01-08 09:00:00\"),\n        \"LastWeekOfMonth\": Timestamp(\"2011-01-29 09:00:00\"),\n        \"FY5253Quarter\": Timestamp(\"2011-01-25 09:00:00\"),\n        \"FY5253\": Timestamp(\"2011-01-25 09:00:00\"),\n        \"Week\": Timestamp(\"2011-01-08 09:00:00\"),\n        \"Easter\": Timestamp(\"2011-04-24 09:00:00\"),\n        \"Hour\": Timestamp(\"2011-01-01 10:00:00\"),\n        \"Minute\": Timestamp(\"2011-01-01 09:01:00\"),\n        \"Second\": Timestamp(\"2011-01-01 09:00:01\"),\n        \"Milli\": Timestamp(\"2011-01-01 09:00:00.001000\"),\n        \"Micro\": Timestamp(\"2011-01-01 09:00:00.000001\"),\n        \"Nano\": Timestamp(\"2011-01-01T09:00:00.000000001\"),\n    }\n\n\nclass TestCommon:\n    def test_immutable(self, offset_types):\n        # GH#21341 check that __setattr__ raises\n        offset = _create_offset(offset_types)\n        msg = \"objects is not writable|DateOffset objects are immutable\"\n        with pytest.raises(AttributeError, match=msg):\n            offset.normalize = True\n        with pytest.raises(AttributeError, match=msg):\n            offset.n = 91\n\n    def test_return_type(self, offset_types):\n        offset = _create_offset(offset_types)\n\n        # make sure that we are returning a Timestamp\n        result = Timestamp(\"20080101\") + offset\n        assert isinstance(result, Timestamp)\n\n        # make sure that we are returning NaT\n        assert NaT + offset is NaT\n        assert offset + NaT is NaT\n\n        assert NaT - offset is NaT\n        assert (-offset)._apply(NaT) is NaT\n\n    def test_offset_n(self, offset_types):\n        offset = _create_offset(offset_types)\n        assert offset.n == 1\n\n        neg_offset = offset * -1\n        assert neg_offset.n == -1\n\n        mul_offset = offset * 3\n        assert mul_offset.n == 3\n\n    def test_offset_timedelta64_arg(self, offset_types):\n        # check that offset._validate_n raises TypeError on a timedelt64\n        #  object\n        off = _create_offset(offset_types)\n\n        td64 = np.timedelta64(4567, \"s\")\n        with pytest.raises(TypeError, match=\"argument must be an integer\"):\n            type(off)(n=td64, **off.kwds)\n\n    def test_offset_mul_ndarray(self, offset_types):\n        off = _create_offset(offset_types)\n\n        expected = np.array([[off, off * 2], [off * 3, off * 4]])\n\n        result = np.array([[1, 2], [3, 4]]) * off\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = off * np.array([[1, 2], [3, 4]])\n        tm.assert_numpy_array_equal(result, expected)\n\n    def test_offset_freqstr(self, offset_types):\n        offset = _create_offset(offset_types)\n\n        freqstr = offset.freqstr\n        if freqstr not in (\"<Easter>\", \"<DateOffset: days=1>\", \"LWOM-SAT\"):\n            code = _get_offset(freqstr)\n            assert offset.rule_code == code\n\n    def _check_offsetfunc_works(self, offset, funcname, dt, expected, normalize=False):\n\n        if normalize and issubclass(offset, Tick):\n            # normalize=True disallowed for Tick subclasses GH#21427\n            return\n\n        offset_s = _create_offset(offset, normalize=normalize)\n        func = getattr(offset_s, funcname)\n\n        result = func(dt)\n        assert isinstance(result, Timestamp)\n        assert result == expected\n\n        result = func(Timestamp(dt))\n        assert isinstance(result, Timestamp)\n        assert result == expected\n\n        # see gh-14101\n        exp_warning = None\n        ts = Timestamp(dt) + Nano(5)\n\n        if (\n            type(offset_s).__name__ == \"DateOffset\"\n            and (funcname in [\"apply\", \"_apply\"] or normalize)\n            and ts.nanosecond > 0\n        ):\n            exp_warning = UserWarning\n\n        # test nanosecond is preserved\n        with tm.assert_produces_warning(exp_warning):\n            result = func(ts)\n\n        assert isinstance(result, Timestamp)\n        if normalize is False:\n            assert result == expected + Nano(5)\n        else:\n            assert result == expected\n\n        if isinstance(dt, np.datetime64):\n            # test tz when input is datetime or Timestamp\n            return\n\n        for tz in [\n            None,\n            \"UTC\",\n            \"Asia/Tokyo\",\n            \"US/Eastern\",\n            \"dateutil/Asia/Tokyo\",\n            \"dateutil/US/Pacific\",\n        ]:\n            expected_localize = expected.tz_localize(tz)\n            tz_obj = timezones.maybe_get_tz(tz)\n            dt_tz = conversion.localize_pydatetime(dt, tz_obj)\n\n            result = func(dt_tz)\n            assert isinstance(result, Timestamp)\n            assert result == expected_localize\n\n            result = func(Timestamp(dt, tz=tz))\n            assert isinstance(result, Timestamp)\n            assert result == expected_localize\n\n            # see gh-14101\n            exp_warning = None\n            ts = Timestamp(dt, tz=tz) + Nano(5)\n\n            if (\n                type(offset_s).__name__ == \"DateOffset\"\n                and (funcname in [\"apply\", \"_apply\"] or normalize)\n                and ts.nanosecond > 0\n            ):\n                exp_warning = UserWarning\n\n            # test nanosecond is preserved\n            with tm.assert_produces_warning(exp_warning):\n                result = func(ts)\n            assert isinstance(result, Timestamp)\n            if normalize is False:\n                assert result == expected_localize + Nano(5)\n            else:\n                assert result == expected_localize\n\n    def test_apply(self, offset_types, expecteds):\n        sdt = datetime(2011, 1, 1, 9, 0)\n        ndt = np.datetime64(\"2011-01-01 09:00\")\n\n        expected = expecteds[offset_types.__name__]\n        expected_norm = Timestamp(expected.date())\n\n        for dt in [sdt, ndt]:\n            self._check_offsetfunc_works(offset_types, \"_apply\", dt, expected)\n\n            self._check_offsetfunc_works(\n                offset_types, \"_apply\", dt, expected_norm, normalize=True\n            )\n\n    def test_rollforward(self, offset_types, expecteds):\n        expecteds = expecteds.copy()\n\n        # result will not be changed if the target is on the offset\n        no_changes = [\n            \"Day\",\n            \"MonthBegin\",\n            \"SemiMonthBegin\",\n            \"YearBegin\",\n            \"Week\",\n            \"Hour\",\n            \"Minute\",\n            \"Second\",\n            \"Milli\",\n            \"Micro\",\n            \"Nano\",\n            \"DateOffset\",\n        ]\n        for n in no_changes:\n            expecteds[n] = Timestamp(\"2011/01/01 09:00\")\n\n        expecteds[\"BusinessHour\"] = Timestamp(\"2011-01-03 09:00:00\")\n        expecteds[\"CustomBusinessHour\"] = Timestamp(\"2011-01-03 09:00:00\")\n\n        # but be changed when normalize=True\n        norm_expected = expecteds.copy()\n        for k in norm_expected:\n            norm_expected[k] = Timestamp(norm_expected[k].date())\n\n        normalized = {\n            \"Day\": Timestamp(\"2011-01-02 00:00:00\"),\n            \"DateOffset\": Timestamp(\"2011-01-02 00:00:00\"),\n            \"MonthBegin\": Timestamp(\"2011-02-01 00:00:00\"),\n            \"SemiMonthBegin\": Timestamp(\"2011-01-15 00:00:00\"),\n            \"YearBegin\": Timestamp(\"2012-01-01 00:00:00\"),\n            \"Week\": Timestamp(\"2011-01-08 00:00:00\"),\n            \"Hour\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Minute\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Second\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Milli\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Micro\": Timestamp(\"2011-01-01 00:00:00\"),\n        }\n        norm_expected.update(normalized)\n\n        sdt = datetime(2011, 1, 1, 9, 0)\n        ndt = np.datetime64(\"2011-01-01 09:00\")\n\n        for dt in [sdt, ndt]:\n            expected = expecteds[offset_types.__name__]\n            self._check_offsetfunc_works(offset_types, \"rollforward\", dt, expected)\n            expected = norm_expected[offset_types.__name__]\n            self._check_offsetfunc_works(\n                offset_types, \"rollforward\", dt, expected, normalize=True\n            )\n\n    def test_rollback(self, offset_types):\n        expecteds = {\n            \"BusinessDay\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"CustomBusinessDay\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"CustomBusinessMonthEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"CustomBusinessMonthBegin\": Timestamp(\"2010-12-01 09:00:00\"),\n            \"BusinessMonthBegin\": Timestamp(\"2010-12-01 09:00:00\"),\n            \"MonthEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"SemiMonthEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"BusinessMonthEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"BYearBegin\": Timestamp(\"2010-01-01 09:00:00\"),\n            \"YearEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"BYearEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"QuarterBegin\": Timestamp(\"2010-12-01 09:00:00\"),\n            \"BQuarterBegin\": Timestamp(\"2010-12-01 09:00:00\"),\n            \"QuarterEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"BQuarterEnd\": Timestamp(\"2010-12-31 09:00:00\"),\n            \"BusinessHour\": Timestamp(\"2010-12-31 17:00:00\"),\n            \"CustomBusinessHour\": Timestamp(\"2010-12-31 17:00:00\"),\n            \"WeekOfMonth\": Timestamp(\"2010-12-11 09:00:00\"),\n            \"LastWeekOfMonth\": Timestamp(\"2010-12-25 09:00:00\"),\n            \"FY5253Quarter\": Timestamp(\"2010-10-26 09:00:00\"),\n            \"FY5253\": Timestamp(\"2010-01-26 09:00:00\"),\n            \"Easter\": Timestamp(\"2010-04-04 09:00:00\"),\n        }\n\n        # result will not be changed if the target is on the offset\n        for n in [\n            \"Day\",\n            \"MonthBegin\",\n            \"SemiMonthBegin\",\n            \"YearBegin\",\n            \"Week\",\n            \"Hour\",\n            \"Minute\",\n            \"Second\",\n            \"Milli\",\n            \"Micro\",\n            \"Nano\",\n            \"DateOffset\",\n        ]:\n            expecteds[n] = Timestamp(\"2011/01/01 09:00\")\n\n        # but be changed when normalize=True\n        norm_expected = expecteds.copy()\n        for k in norm_expected:\n            norm_expected[k] = Timestamp(norm_expected[k].date())\n\n        normalized = {\n            \"Day\": Timestamp(\"2010-12-31 00:00:00\"),\n            \"DateOffset\": Timestamp(\"2010-12-31 00:00:00\"),\n            \"MonthBegin\": Timestamp(\"2010-12-01 00:00:00\"),\n            \"SemiMonthBegin\": Timestamp(\"2010-12-15 00:00:00\"),\n            \"YearBegin\": Timestamp(\"2010-01-01 00:00:00\"),\n            \"Week\": Timestamp(\"2010-12-25 00:00:00\"),\n            \"Hour\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Minute\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Second\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Milli\": Timestamp(\"2011-01-01 00:00:00\"),\n            \"Micro\": Timestamp(\"2011-01-01 00:00:00\"),\n        }\n        norm_expected.update(normalized)\n\n        sdt = datetime(2011, 1, 1, 9, 0)\n        ndt = np.datetime64(\"2011-01-01 09:00\")\n\n        for dt in [sdt, ndt]:\n            expected = expecteds[offset_types.__name__]\n            self._check_offsetfunc_works(offset_types, \"rollback\", dt, expected)\n\n            expected = norm_expected[offset_types.__name__]\n            self._check_offsetfunc_works(\n                offset_types, \"rollback\", dt, expected, normalize=True\n            )\n\n    def test_is_on_offset(self, offset_types, expecteds):\n        dt = expecteds[offset_types.__name__]\n        offset_s = _create_offset(offset_types)\n        assert offset_s.is_on_offset(dt)\n\n        # when normalize=True, is_on_offset checks time is 00:00:00\n        if issubclass(offset_types, Tick):\n            # normalize=True disallowed for Tick subclasses GH#21427\n            return\n        offset_n = _create_offset(offset_types, normalize=True)\n        assert not offset_n.is_on_offset(dt)\n\n        if offset_types in (BusinessHour, CustomBusinessHour):\n            # In default BusinessHour (9:00-17:00), normalized time\n            # cannot be in business hour range\n            return\n        date = datetime(dt.year, dt.month, dt.day)\n        assert offset_n.is_on_offset(date)\n\n    def test_add(self, offset_types, tz_naive_fixture, expecteds):\n        tz = tz_naive_fixture\n        dt = datetime(2011, 1, 1, 9, 0)\n\n        offset_s = _create_offset(offset_types)\n        expected = expecteds[offset_types.__name__]\n\n        result_dt = dt + offset_s\n        result_ts = Timestamp(dt) + offset_s\n        for result in [result_dt, result_ts]:\n            assert isinstance(result, Timestamp)\n            assert result == expected\n\n        expected_localize = expected.tz_localize(tz)\n        result = Timestamp(dt, tz=tz) + offset_s\n        assert isinstance(result, Timestamp)\n        assert result == expected_localize\n\n        # normalize=True, disallowed for Tick subclasses GH#21427\n        if issubclass(offset_types, Tick):\n            return\n        offset_s = _create_offset(offset_types, normalize=True)\n        expected = Timestamp(expected.date())\n\n        result_dt = dt + offset_s\n        result_ts = Timestamp(dt) + offset_s\n        for result in [result_dt, result_ts]:\n            assert isinstance(result, Timestamp)\n            assert result == expected\n\n        expected_localize = expected.tz_localize(tz)\n        result = Timestamp(dt, tz=tz) + offset_s\n        assert isinstance(result, Timestamp)\n        assert result == expected_localize\n\n    def test_add_empty_datetimeindex(self, offset_types, tz_naive_fixture):\n        # GH#12724, GH#30336\n        offset_s = _create_offset(offset_types)\n\n        dti = DatetimeIndex([], tz=tz_naive_fixture)\n\n        warn = None\n        if isinstance(\n            offset_s,\n            (\n                Easter,\n                WeekOfMonth,\n                LastWeekOfMonth,\n                CustomBusinessDay,\n                BusinessHour,\n                CustomBusinessHour,\n                CustomBusinessMonthBegin,\n                CustomBusinessMonthEnd,\n                FY5253,\n                FY5253Quarter,\n            ),\n        ):\n            # We don't have an optimized apply_index\n            warn = PerformanceWarning\n\n        with tm.assert_produces_warning(warn):\n            result = dti + offset_s\n        tm.assert_index_equal(result, dti)\n        with tm.assert_produces_warning(warn):\n            result = offset_s + dti\n        tm.assert_index_equal(result, dti)\n\n        dta = dti._data\n        with tm.assert_produces_warning(warn):\n            result = dta + offset_s\n        tm.assert_equal(result, dta)\n        with tm.assert_produces_warning(warn):\n            result = offset_s + dta\n        tm.assert_equal(result, dta)\n\n    def test_pickle_roundtrip(self, offset_types):\n        off = _create_offset(offset_types)\n        res = tm.round_trip_pickle(off)\n        assert off == res\n        if type(off) is not DateOffset:\n            for attr in off._attributes:\n                if attr == \"calendar\":\n                    # np.busdaycalendar __eq__ will return False;\n                    #  we check holidays and weekmask attrs so are OK\n                    continue\n                # Make sure nothings got lost from _params (which __eq__) is based on\n                assert getattr(off, attr) == getattr(res, attr)\n\n    def test_pickle_dateoffset_odd_inputs(self):\n        # GH#34511\n        off = DateOffset(months=12)\n        res = tm.round_trip_pickle(off)\n        assert off == res\n\n        base_dt = datetime(2020, 1, 1)\n        assert base_dt + off == base_dt + res\n\n    def test_offsets_hashable(self, offset_types):\n        # GH: 37267\n        off = _create_offset(offset_types)\n        assert hash(off) is not None\n\n    @pytest.mark.parametrize(\"unit\", [\"s\", \"ms\", \"us\"])\n    def test_add_dt64_ndarray_non_nano(self, offset_types, unit, request):\n        # check that the result with non-nano matches nano\n        off = _create_offset(offset_types)\n\n        dti = date_range(\"2016-01-01\", periods=35, freq=\"D\")\n\n        arr = dti._data._ndarray.astype(f\"M8[{unit}]\")\n        dta = type(dti._data)._simple_new(arr, dtype=arr.dtype)\n\n        with warnings.catch_warnings(record=True) as w:\n            expected = dti._data + off\n            result = dta + off\n\n        exp_unit = unit\n        if isinstance(off, Tick) and off._creso > dta._creso:\n            # cast to higher reso like we would with Timedelta scalar\n            exp_unit = Timedelta(off).unit\n        expected = expected.as_unit(exp_unit)\n\n        if len(w):\n            # PerformanceWarning was issued bc _apply_array raised, so we\n            #  fell back to object dtype, for which the code path does\n            #  not yet cast back to the original resolution\n            mark = pytest.mark.xfail(\n                reason=\"Goes through object dtype in DatetimeArray._add_offset, \"\n                \"doesn't restore reso in result\"\n            )\n            request.node.add_marker(mark)\n\n        tm.assert_numpy_array_equal(result._ndarray, expected._ndarray)\n\n\nclass TestDateOffset:\n    def setup_method(self):\n        _offset_map.clear()\n\n    def test_repr(self):\n        repr(DateOffset())\n        repr(DateOffset(2))\n        repr(2 * DateOffset())\n        repr(2 * DateOffset(months=2))\n\n    def test_mul(self):\n        assert DateOffset(2) == 2 * DateOffset(1)\n        assert DateOffset(2) == DateOffset(1) * 2\n\n    @pytest.mark.parametrize(\"kwd\", sorted(liboffsets._relativedelta_kwds))\n    def test_constructor(self, kwd, request):\n        if kwd == \"millisecond\":\n            request.node.add_marker(\n                pytest.mark.xfail(\n                    raises=NotImplementedError,\n                    reason=\"Constructing DateOffset object with `millisecond` is not \"\n                    \"yet supported.\",\n                )\n            )\n        offset = DateOffset(**{kwd: 2})\n        assert offset.kwds == {kwd: 2}\n        assert getattr(offset, kwd) == 2\n\n    def test_default_constructor(self, dt):\n        assert (dt + DateOffset(2)) == datetime(2008, 1, 4)\n\n    def test_is_anchored(self):\n        assert not DateOffset(2).is_anchored()\n        assert DateOffset(1).is_anchored()\n\n    def test_copy(self):\n        assert DateOffset(months=2).copy() == DateOffset(months=2)\n        assert DateOffset(milliseconds=1).copy() == DateOffset(milliseconds=1)\n\n    @pytest.mark.parametrize(\n        \"arithmatic_offset_type, expected\",\n        zip(\n            _ARITHMETIC_DATE_OFFSET,\n            [\n                \"2009-01-02\",\n                \"2008-02-02\",\n                \"2008-01-09\",\n                \"2008-01-03\",\n                \"2008-01-02 01:00:00\",\n                \"2008-01-02 00:01:00\",\n                \"2008-01-02 00:00:01\",\n                \"2008-01-02 00:00:00.001000000\",\n                \"2008-01-02 00:00:00.000001000\",\n            ],\n        ),\n    )\n    def test_add(self, arithmatic_offset_type, expected, dt):\n        assert DateOffset(**{arithmatic_offset_type: 1}) + dt == Timestamp(expected)\n        assert dt + DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)\n\n    @pytest.mark.parametrize(\n        \"arithmatic_offset_type, expected\",\n        zip(\n            _ARITHMETIC_DATE_OFFSET,\n            [\n                \"2007-01-02\",\n                \"2007-12-02\",\n                \"2007-12-26\",\n                \"2008-01-01\",\n                \"2008-01-01 23:00:00\",\n                \"2008-01-01 23:59:00\",\n                \"2008-01-01 23:59:59\",\n                \"2008-01-01 23:59:59.999000000\",\n                \"2008-01-01 23:59:59.999999000\",\n            ],\n        ),\n    )\n    def test_sub(self, arithmatic_offset_type, expected, dt):\n        assert dt - DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)\n        with pytest.raises(TypeError, match=\"Cannot subtract datetime from offset\"):\n            DateOffset(**{arithmatic_offset_type: 1}) - dt\n\n    @pytest.mark.parametrize(\n        \"arithmatic_offset_type, n, expected\",\n        zip(\n            _ARITHMETIC_DATE_OFFSET,\n            range(1, 10),\n            [\n                \"2009-01-02\",\n                \"2008-03-02\",\n                \"2008-01-23\",\n                \"2008-01-06\",\n                \"2008-01-02 05:00:00\",\n                \"2008-01-02 00:06:00\",\n                \"2008-01-02 00:00:07\",\n                \"2008-01-02 00:00:00.008000000\",\n                \"2008-01-02 00:00:00.000009000\",\n            ],\n        ),\n    )\n    def test_mul_add(self, arithmatic_offset_type, n, expected, dt):\n        assert DateOffset(**{arithmatic_offset_type: 1}) * n + dt == Timestamp(expected)\n        assert n * DateOffset(**{arithmatic_offset_type: 1}) + dt == Timestamp(expected)\n        assert dt + DateOffset(**{arithmatic_offset_type: 1}) * n == Timestamp(expected)\n        assert dt + n * DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)\n\n    @pytest.mark.parametrize(\n        \"arithmatic_offset_type, n, expected\",\n        zip(\n            _ARITHMETIC_DATE_OFFSET,\n            range(1, 10),\n            [\n                \"2007-01-02\",\n                \"2007-11-02\",\n                \"2007-12-12\",\n                \"2007-12-29\",\n                \"2008-01-01 19:00:00\",\n                \"2008-01-01 23:54:00\",\n                \"2008-01-01 23:59:53\",\n                \"2008-01-01 23:59:59.992000000\",\n                \"2008-01-01 23:59:59.999991000\",\n            ],\n        ),\n    )\n    def test_mul_sub(self, arithmatic_offset_type, n, expected, dt):\n        assert dt - DateOffset(**{arithmatic_offset_type: 1}) * n == Timestamp(expected)\n        assert dt - n * DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)\n\n    def test_leap_year(self):\n        d = datetime(2008, 1, 31)\n        assert (d + DateOffset(months=1)) == datetime(2008, 2, 29)\n\n    def test_eq(self):\n        offset1 = DateOffset(days=1)\n        offset2 = DateOffset(days=365)\n\n        assert offset1 != offset2\n\n        assert DateOffset(milliseconds=3) != DateOffset(milliseconds=7)\n\n    @pytest.mark.parametrize(\n        \"offset_kwargs, expected_arg\",\n        [\n            ({\"microseconds\": 1, \"milliseconds\": 1}, \"2022-01-01 00:00:00.001001\"),\n            ({\"seconds\": 1, \"milliseconds\": 1}, \"2022-01-01 00:00:01.001\"),\n            ({\"minutes\": 1, \"milliseconds\": 1}, \"2022-01-01 00:01:00.001\"),\n            ({\"hours\": 1, \"milliseconds\": 1}, \"2022-01-01 01:00:00.001\"),\n            ({\"days\": 1, \"milliseconds\": 1}, \"2022-01-02 00:00:00.001\"),\n            ({\"weeks\": 1, \"milliseconds\": 1}, \"2022-01-08 00:00:00.001\"),\n            ({\"months\": 1, \"milliseconds\": 1}, \"2022-02-01 00:00:00.001\"),\n            ({\"years\": 1, \"milliseconds\": 1}, \"2023-01-01 00:00:00.001\"),\n        ],\n    )\n    def test_milliseconds_combination(self, offset_kwargs, expected_arg):\n        # GH 49897\n        offset = DateOffset(**offset_kwargs)\n        ts = Timestamp(\"2022-01-01\")\n        result = ts + offset\n        expected = Timestamp(expected_arg)\n\n        assert result == expected\n\n    def test_offset_invalid_arguments(self):\n        msg = \"^Invalid argument/s or bad combination of arguments\"\n        with pytest.raises(ValueError, match=msg):\n            DateOffset(picoseconds=1)\n\n\nclass TestOffsetNames:\n    def test_get_offset_name(self):\n        assert BDay().freqstr == \"B\"\n        assert BDay(2).freqstr == \"2B\"\n        assert BMonthEnd().freqstr == \"BM\"\n        assert Week(weekday=0).freqstr == \"W-MON\"\n        assert Week(weekday=1).freqstr == \"W-TUE\"\n        assert Week(weekday=2).freqstr == \"W-WED\"\n        assert Week(weekday=3).freqstr == \"W-THU\"\n        assert Week(weekday=4).freqstr == \"W-FRI\"\n\n        assert LastWeekOfMonth(weekday=WeekDay.SUN).freqstr == \"LWOM-SUN\"\n\n\ndef test_get_offset():\n    with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):\n        _get_offset(\"gibberish\")\n    with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):\n        _get_offset(\"QS-JAN-B\")\n\n    pairs = [\n        (\"B\", BDay()),\n        (\"b\", BDay()),\n        (\"bm\", BMonthEnd()),\n        (\"Bm\", BMonthEnd()),\n        (\"W-MON\", Week(weekday=0)),\n        (\"W-TUE\", Week(weekday=1)),\n        (\"W-WED\", Week(weekday=2)),\n        (\"W-THU\", Week(weekday=3)),\n        (\"W-FRI\", Week(weekday=4)),\n    ]\n\n    for name, expected in pairs:\n        offset = _get_offset(name)\n        assert offset == expected, (\n            f\"Expected {repr(name)} to yield {repr(expected)} \"\n            f\"(actual: {repr(offset)})\"\n        )\n\n\ndef test_get_offset_legacy():\n    pairs = [(\"w@Sat\", Week(weekday=5))]\n    for name, expected in pairs:\n        with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):\n            _get_offset(name)\n\n\nclass TestOffsetAliases:\n    def setup_method(self):\n        _offset_map.clear()\n\n    def test_alias_equality(self):\n        for k, v in _offset_map.items():\n            if v is None:\n                continue\n            assert k == v.copy()\n\n    def test_rule_code(self):\n        lst = [\"M\", \"MS\", \"BM\", \"BMS\", \"D\", \"B\", \"H\", \"T\", \"S\", \"L\", \"U\"]\n        for k in lst:\n            assert k == _get_offset(k).rule_code\n            # should be cached - this is kind of an internals test...\n            assert k in _offset_map\n            assert k == (_get_offset(k) * 3).rule_code\n\n        suffix_lst = [\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\"]\n        base = \"W\"\n        for v in suffix_lst:\n            alias = \"-\".join([base, v])\n            assert alias == _get_offset(alias).rule_code\n            assert alias == (_get_offset(alias) * 5).rule_code\n\n        suffix_lst = [\n            \"JAN\",\n            \"FEB\",\n            \"MAR\",\n            \"APR\",\n            \"MAY\",\n            \"JUN\",\n            \"JUL\",\n            \"AUG\",\n            \"SEP\",\n            \"OCT\",\n            \"NOV\",\n            \"DEC\",\n        ]\n        base_lst = [\"A\", \"AS\", \"BA\", \"BAS\", \"Q\", \"QS\", \"BQ\", \"BQS\"]\n        for base in base_lst:\n            for v in suffix_lst:\n                alias = \"-\".join([base, v])\n                assert alias == _get_offset(alias).rule_code\n                assert alias == (_get_offset(alias) * 5).rule_code\n\n\ndef test_freq_offsets():\n    off = BDay(1, offset=timedelta(0, 1800))\n    assert off.freqstr == \"B+30Min\"\n\n    off = BDay(1, offset=timedelta(0, -1800))\n    assert off.freqstr == \"B-30Min\"\n\n\nclass TestReprNames:\n    def test_str_for_named_is_name(self):\n        # look at all the amazing combinations!\n        month_prefixes = [\"A\", \"AS\", \"BA\", \"BAS\", \"Q\", \"BQ\", \"BQS\", \"QS\"]\n        names = [\n            prefix + \"-\" + month\n            for prefix in month_prefixes\n            for month in [\n                \"JAN\",\n                \"FEB\",\n                \"MAR\",\n                \"APR\",\n                \"MAY\",\n                \"JUN\",\n                \"JUL\",\n                \"AUG\",\n                \"SEP\",\n                \"OCT\",\n                \"NOV\",\n                \"DEC\",\n            ]\n        ]\n        days = [\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\"]\n        names += [\"W-\" + day for day in days]\n        names += [\"WOM-\" + week + day for week in (\"1\", \"2\", \"3\", \"4\") for day in days]\n        _offset_map.clear()\n        for name in names:\n            offset = _get_offset(name)\n            assert offset.freqstr == name\n\n\n# ---------------------------------------------------------------------\n\n\ndef test_valid_default_arguments(offset_types):\n    # GH#19142 check that the calling the constructors without passing\n    # any keyword arguments produce valid offsets\n    cls = offset_types\n    cls()\n\n\n@pytest.mark.parametrize(\"kwd\", sorted(liboffsets._relativedelta_kwds))\ndef test_valid_month_attributes(kwd, month_classes):\n    # GH#18226\n    cls = month_classes\n    # check that we cannot create e.g. MonthEnd(weeks=3)\n    msg = rf\"__init__\\(\\) got an unexpected keyword argument '{kwd}'\"\n    with pytest.raises(TypeError, match=msg):\n        cls(**{kwd: 3})\n\n\ndef test_month_offset_name(month_classes):\n    # GH#33757 off.name with n != 1 should not raise AttributeError\n    obj = month_classes(1)\n    obj2 = month_classes(2)\n    assert obj2.name == obj.name\n\n\n@pytest.mark.parametrize(\"kwd\", sorted(liboffsets._relativedelta_kwds))\ndef test_valid_relativedelta_kwargs(kwd, request):\n    if kwd == \"millisecond\":\n        request.node.add_marker(\n            pytest.mark.xfail(\n                raises=NotImplementedError,\n                reason=\"Constructing DateOffset object with `millisecond` is not \"\n                \"yet supported.\",\n            )\n        )\n    # Check that all the arguments specified in liboffsets._relativedelta_kwds\n    # are in fact valid relativedelta keyword args\n    DateOffset(**{kwd: 1})\n\n\n@pytest.mark.parametrize(\"kwd\", sorted(liboffsets._relativedelta_kwds))\ndef test_valid_tick_attributes(kwd, tick_classes):\n    # GH#18226\n    cls = tick_classes\n    # check that we cannot create e.g. Hour(weeks=3)\n    msg = rf\"__init__\\(\\) got an unexpected keyword argument '{kwd}'\"\n    with pytest.raises(TypeError, match=msg):\n        cls(**{kwd: 3})\n\n\ndef test_validate_n_error():\n    with pytest.raises(TypeError, match=\"argument must be an integer\"):\n        DateOffset(n=\"Doh!\")\n\n    with pytest.raises(TypeError, match=\"argument must be an integer\"):\n        MonthBegin(n=timedelta(1))\n\n    with pytest.raises(TypeError, match=\"argument must be an integer\"):\n        BDay(n=np.array([1, 2], dtype=np.int64))\n\n\ndef test_require_integers(offset_types):\n    cls = offset_types\n    with pytest.raises(ValueError, match=\"argument must be an integer\"):\n        cls(n=1.5)\n\n\ndef test_tick_normalize_raises(tick_classes):\n    # check that trying to create a Tick object with normalize=True raises\n    # GH#21427\n    cls = tick_classes\n    msg = \"Tick offset with `normalize=True` are not allowed.\"\n    with pytest.raises(ValueError, match=msg):\n        cls(n=3, normalize=True)\n\n\n@pytest.mark.parametrize(\n    \"offset_kwargs, expected_arg\",\n    [\n        ({\"nanoseconds\": 1}, \"1970-01-01 00:00:00.000000001\"),\n        ({\"nanoseconds\": 5}, \"1970-01-01 00:00:00.000000005\"),\n        ({\"nanoseconds\": -1}, \"1969-12-31 23:59:59.999999999\"),\n        ({\"microseconds\": 1}, \"1970-01-01 00:00:00.000001\"),\n        ({\"microseconds\": -1}, \"1969-12-31 23:59:59.999999\"),\n        ({\"seconds\": 1}, \"1970-01-01 00:00:01\"),\n        ({\"seconds\": -1}, \"1969-12-31 23:59:59\"),\n        ({\"minutes\": 1}, \"1970-01-01 00:01:00\"),\n        ({\"minutes\": -1}, \"1969-12-31 23:59:00\"),\n        ({\"hours\": 1}, \"1970-01-01 01:00:00\"),\n        ({\"hours\": -1}, \"1969-12-31 23:00:00\"),\n        ({\"days\": 1}, \"1970-01-02 00:00:00\"),\n        ({\"days\": -1}, \"1969-12-31 00:00:00\"),\n        ({\"weeks\": 1}, \"1970-01-08 00:00:00\"),\n        ({\"weeks\": -1}, \"1969-12-25 00:00:00\"),\n        ({\"months\": 1}, \"1970-02-01 00:00:00\"),\n        ({\"months\": -1}, \"1969-12-01 00:00:00\"),\n        ({\"years\": 1}, \"1971-01-01 00:00:00\"),\n        ({\"years\": -1}, \"1969-01-01 00:00:00\"),\n    ],\n)\ndef test_dateoffset_add_sub(offset_kwargs, expected_arg):\n    offset = DateOffset(**offset_kwargs)\n    ts = Timestamp(0)\n    result = ts + offset\n    expected = Timestamp(expected_arg)\n    assert result == expected\n    result -= offset\n    assert result == ts\n    result = offset + ts\n    assert result == expected\n\n\ndef test_dateoffset_add_sub_timestamp_with_nano():\n    offset = DateOffset(minutes=2, nanoseconds=9)\n    ts = Timestamp(4)\n    result = ts + offset\n    expected = Timestamp(\"1970-01-01 00:02:00.000000013\")\n    assert result == expected\n    result -= offset\n    assert result == ts\n    result = offset + ts\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"attribute\",\n    [\n        \"hours\",\n        \"days\",\n        \"weeks\",\n        \"months\",\n        \"years\",\n    ],\n)\ndef test_dateoffset_immutable(attribute):\n    offset = DateOffset(**{attribute: 0})\n    msg = \"DateOffset objects are immutable\"\n    with pytest.raises(AttributeError, match=msg):\n        setattr(offset, attribute, 5)\n\n\ndef test_dateoffset_misc():\n    oset = offsets.DateOffset(months=2, days=4)\n    # it works\n    oset.freqstr\n\n    assert not offsets.DateOffset(months=2) == 2\n\n\n@pytest.mark.parametrize(\"n\", [-1, 1, 3])\ndef test_construct_int_arg_no_kwargs_assumed_days(n):\n    # GH 45890, 45643\n    offset = DateOffset(n)\n    assert offset._offset == timedelta(1)\n    result = Timestamp(2022, 1, 2) + offset\n    expected = Timestamp(2022, 1, 2 + n)\n    assert result == expected\n\n\ndef test_offset_multiplication():\n    # GH#47953\n    mo1 = DateOffset(months=1)\n    mo2 = DateOffset(months=2)\n\n    startscalar = Timestamp(\"2020-01-30\")\n    startarray = Series([Timestamp(\"2020-01-30\")])\n\n    resultscalar1 = startscalar + (mo1 * 2)\n    resultscalar2 = startscalar + mo2\n    resultarray1 = startarray + (mo1 * 2)\n    resultarray2 = startarray + mo2\n\n    expectedscalar = Timestamp(\"2020-03-30\")\n    expectedarray = Series([Timestamp(\"2020-03-30\")])\n    assert resultscalar1 == expectedscalar\n    assert resultscalar2 == expectedscalar\n    tm.assert_series_equal(resultarray1, expectedarray)\n    tm.assert_series_equal(resultarray2, expectedarray)\n\n    df = DataFrame({\"T\": [Timestamp(\"2019-04-30\")], \"D\": [DateOffset(months=1)]})\n    frameresult1 = df[\"T\"] + 26 * df[\"D\"]\n    df2 = DataFrame(\n        {\n            \"T\": [Timestamp(\"2019-04-30\"), Timestamp(\"2019-04-30\")],\n            \"D\": [DateOffset(months=1), DateOffset(months=1)],\n        }\n    )\n    frameresult2 = df2[\"T\"] + 26 * df2[\"D\"]\n    assert frameresult1[0] == frameresult2[0]\n\n\n@pytest.mark.parametrize(\n    \"offset, expected\",\n    [\n        (\n            DateOffset(minutes=7, nanoseconds=18),\n            Timestamp(\"2022-01-01 00:07:00.000000018\"),\n        ),\n        (DateOffset(nanoseconds=3), Timestamp(\"2022-01-01 00:00:00.000000003\")),\n    ],\n)\ndef test_dateoffset_add_sub_timestamp_series_with_nano(offset, expected):\n    # GH 47856\n    start_time = Timestamp(\"2022-01-01\")\n    teststamp = start_time\n    testseries = Series([start_time])\n    testseries = testseries + offset\n    assert testseries[0] == expected\n    testseries -= offset\n    assert testseries[0] == teststamp\n    testseries = offset + testseries\n    assert testseries[0] == expected\n"
    }
  ]
}