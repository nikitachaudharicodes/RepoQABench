{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "38969",
  "issue_description": "# REGR: Bar plot from Series with IntervalIndex fails in pandas 1.2.0\n\n- [x] I have checked that this issue has not already been reported.\r\n\r\n- [x] I have confirmed this bug exists on the latest version of pandas.\r\n\r\n- [x] (optional) I have confirmed this bug exists on the master branch of pandas.\r\n\r\n---\r\n\r\n**Note**: Please read [this guide](https://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports) detailing how to provide the necessary information for us to reproduce your bug.\r\n\r\n#### Code Sample, a copy-pastable example\r\n\r\n```python\r\nimport pandas as pd\r\n\r\npd.Series(\r\n    [1,2],\r\n    index=pd.interval_range(0,2)\r\n).plot.bar()\r\n```\r\n\r\n#### Problem description\r\n\r\nThe following error is raised in pandas 1.2.0\r\nTypeError: Cannot cast IntervalIndex to dtype int32\r\n\r\npandas 1.1.5 does not have the same issue\r\n\r\nstack trace:\r\n\r\n<details>\r\n\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\arrays\\interval.py in astype(self, dtype, copy)\r\n    777         try:\r\n--> 778             return np.asarray(self).astype(dtype, copy=copy)\r\n    779         except (TypeError, ValueError) as err:\r\n\r\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'pandas._libs.interval.Interval'\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-4-fc9e0f28d9be> in <module>\r\n      1 pd.Series(\r\n      2     [1,2],\r\n----> 3     index=pd.interval_range(0,2)\r\n      4 ).plot.bar()\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_core.py in bar(self, x, y, **kwargs)\r\n   1111         other axis represents a measured value.\r\n   1112         \"\"\"\r\n-> 1113         return self(kind=\"bar\", x=x, y=y, **kwargs)\r\n   1114 \r\n   1115     @Appender(\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_core.py in __call__(self, *args, **kwargs)\r\n    953                     data.columns = label_name\r\n    954 \r\n--> 955         return plot_backend.plot(data, kind=kind, **kwargs)\r\n    956 \r\n    957     __call__.__doc__ = __doc__\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\__init__.py in plot(data, kind, **kwargs)\r\n     59             kwargs[\"ax\"] = getattr(ax, \"left_ax\", ax)\r\n     60     plot_obj = PLOT_CLASSES[kind](data, **kwargs)\r\n---> 61     plot_obj.generate()\r\n     62     plot_obj.draw()\r\n     63     return plot_obj.result\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\core.py in generate(self)\r\n    278         self._compute_plot_data()\r\n    279         self._setup_subplots()\r\n--> 280         self._make_plot()\r\n    281         self._add_table()\r\n    282         self._make_legend()\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\core.py in _make_plot(self)\r\n   1432             if self.orientation == \"vertical\":\r\n   1433                 ax.xaxis.update_units(self.ax_index)\r\n-> 1434                 self.tick_pos = ax.convert_xunits(self.ax_index).astype(np.int)\r\n   1435             elif self.orientation == \"horizontal\":\r\n   1436                 ax.yaxis.update_units(self.ax_index)\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\indexes\\interval.py in astype(self, dtype, copy)\r\n    368     def astype(self, dtype, copy: bool = True):\r\n    369         with rewrite_exception(\"IntervalArray\", type(self).__name__):\r\n--> 370             new_values = self._values.astype(dtype, copy=copy)\r\n    371         return Index(new_values, dtype=new_values.dtype, name=self.name)\r\n    372 \r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\arrays\\interval.py in astype(self, dtype, copy)\r\n    779         except (TypeError, ValueError) as err:\r\n    780             msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\r\n--> 781             raise TypeError(msg) from err\r\n    782 \r\n    783     def equals(self, other) -> bool:\r\n\r\nTypeError: Cannot cast IntervalIndex to dtype int32\r\n\r\n</details>\r\n\r\n\r\n#### Expected Output\r\n\r\nA bar plot (produced with pandas 1.1.5):\r\n![barplot](https://user-images.githubusercontent.com/51399800/103641842-791c5f00-4fa6-11eb-9993-999ea26d47ef.PNG)\r\n\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 3e89b4c4b1580aa890023fc550774e63d499da25\r\npython           : 3.7.5.final.0\r\npython-bits      : 64\r\nOS               : Windows\r\nOS-release       : 10\r\nVersion          : 10.0.18362\r\nmachine          : AMD64\r\nprocessor        : Intel64 Family 6 Model 158 Stepping 10, GenuineIntel\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : None\r\nLOCALE           : None.None\r\n\r\npandas           : 1.2.0\r\nnumpy            : 1.19.4\r\npytz             : 2020.5\r\ndateutil         : 2.8.1\r\npip              : 19.2.3\r\nsetuptools       : 41.2.0\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : None\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : None\r\nIPython          : None\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nfsspec           : None\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.3.3\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : None\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : None\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 754593913,
      "user": "MarcoGorelli",
      "body": "Thanks @venaturum for the report - could you put a descriptive title too please? Also, show the full traceback, not just the final part with the error message?"
    },
    {
      "id": 754596324,
      "user": "jorisvandenbossche",
      "body": "Didn't check, but given the other reports, I suppose this is similarly as https://github.com/pandas-dev/pandas/issues/38947, https://github.com/pandas-dev/pandas/issues/38865, https://github.com/pandas-dev/pandas/issues/38736 caused by https://github.com/pandas-dev/pandas/pull/28733\r\n"
    },
    {
      "id": 754605971,
      "user": "venaturum",
      "body": "@MarcoGorelli , done now, sorry about that!\r\n\r\n@jorisvandenbossche, I think you're right, looks especially similar to 38947. "
    },
    {
      "id": 755317333,
      "user": "simonjayhawkins",
      "body": "> @jorisvandenbossche, I think you're right, looks especially similar to 38947.\r\n\r\nboth these fail from `self.tick_pos = ax.convert_xunits(self.ax_index).astype(np.int)` in `_make_plot` in `pandas\\plotting\\_matplotlib\\core.py`\r\n\r\ncould close as duplicate or leave open to ensure additional test coverage"
    },
    {
      "id": 760962249,
      "user": "jorisvandenbossche",
      "body": "(let's keep open until we actually fix + add a test for this specific case)"
    },
    {
      "id": 760973307,
      "user": "venaturum",
      "body": "No problem, I thought the closing candidate tag might have been a subtle hint ðŸ˜‚"
    },
    {
      "id": 762316492,
      "user": "simonjayhawkins",
      "body": "> Didn't check, but given the other reports, I suppose this is similarly as #38947, #38865, #38736 caused by #28733\r\n\r\n#28733 has been reverted. needs test to prevent regression."
    },
    {
      "id": 1053707071,
      "user": "mariana-LJ",
      "body": "Could anyone please clarify what's needed here? Are we only missing a regression test? I'd be happy to help with this issue."
    },
    {
      "id": 1053711432,
      "user": "MarcoGorelli",
      "body": "Yes, that's right"
    },
    {
      "id": 1066161045,
      "user": "mariana-LJ",
      "body": "Thank you @MarcoGorelli! In that case, I'll take this issue and start to work on it as soon as I can."
    },
    {
      "id": 1066161192,
      "user": "mariana-LJ",
      "body": "To ensure this issue is assigned to me: take."
    },
    {
      "id": 1073302562,
      "user": "mariana-LJ",
      "body": "@simonjayhawkins, @mroeschke, @MarcoGorelli: I left a comment above with the keyword 'take' but this issue was not assigned to me. Am I missing some step? Could any of you please assign it to me? Thanks!"
    },
    {
      "id": 1073302929,
      "user": "MarcoGorelli",
      "body": "the comment should only have a single word: take\r\n\r\nif your comment includes other words, it won't work"
    },
    {
      "id": 1079783984,
      "user": "mariana-LJ",
      "body": "I see. Thanks!"
    },
    {
      "id": 1079784002,
      "user": "mariana-LJ",
      "body": "take"
    },
    {
      "id": 1152473636,
      "user": "noatamir",
      "body": "take"
    }
  ],
  "text_context": "# REGR: Bar plot from Series with IntervalIndex fails in pandas 1.2.0\n\n- [x] I have checked that this issue has not already been reported.\r\n\r\n- [x] I have confirmed this bug exists on the latest version of pandas.\r\n\r\n- [x] (optional) I have confirmed this bug exists on the master branch of pandas.\r\n\r\n---\r\n\r\n**Note**: Please read [this guide](https://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports) detailing how to provide the necessary information for us to reproduce your bug.\r\n\r\n#### Code Sample, a copy-pastable example\r\n\r\n```python\r\nimport pandas as pd\r\n\r\npd.Series(\r\n    [1,2],\r\n    index=pd.interval_range(0,2)\r\n).plot.bar()\r\n```\r\n\r\n#### Problem description\r\n\r\nThe following error is raised in pandas 1.2.0\r\nTypeError: Cannot cast IntervalIndex to dtype int32\r\n\r\npandas 1.1.5 does not have the same issue\r\n\r\nstack trace:\r\n\r\n<details>\r\n\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\arrays\\interval.py in astype(self, dtype, copy)\r\n    777         try:\r\n--> 778             return np.asarray(self).astype(dtype, copy=copy)\r\n    779         except (TypeError, ValueError) as err:\r\n\r\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'pandas._libs.interval.Interval'\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-4-fc9e0f28d9be> in <module>\r\n      1 pd.Series(\r\n      2     [1,2],\r\n----> 3     index=pd.interval_range(0,2)\r\n      4 ).plot.bar()\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_core.py in bar(self, x, y, **kwargs)\r\n   1111         other axis represents a measured value.\r\n   1112         \"\"\"\r\n-> 1113         return self(kind=\"bar\", x=x, y=y, **kwargs)\r\n   1114 \r\n   1115     @Appender(\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_core.py in __call__(self, *args, **kwargs)\r\n    953                     data.columns = label_name\r\n    954 \r\n--> 955         return plot_backend.plot(data, kind=kind, **kwargs)\r\n    956 \r\n    957     __call__.__doc__ = __doc__\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\__init__.py in plot(data, kind, **kwargs)\r\n     59             kwargs[\"ax\"] = getattr(ax, \"left_ax\", ax)\r\n     60     plot_obj = PLOT_CLASSES[kind](data, **kwargs)\r\n---> 61     plot_obj.generate()\r\n     62     plot_obj.draw()\r\n     63     return plot_obj.result\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\core.py in generate(self)\r\n    278         self._compute_plot_data()\r\n    279         self._setup_subplots()\r\n--> 280         self._make_plot()\r\n    281         self._add_table()\r\n    282         self._make_legend()\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\plotting\\_matplotlib\\core.py in _make_plot(self)\r\n   1432             if self.orientation == \"vertical\":\r\n   1433                 ax.xaxis.update_units(self.ax_index)\r\n-> 1434                 self.tick_pos = ax.convert_xunits(self.ax_index).astype(np.int)\r\n   1435             elif self.orientation == \"horizontal\":\r\n   1436                 ax.yaxis.update_units(self.ax_index)\r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\indexes\\interval.py in astype(self, dtype, copy)\r\n    368     def astype(self, dtype, copy: bool = True):\r\n    369         with rewrite_exception(\"IntervalArray\", type(self).__name__):\r\n--> 370             new_values = self._values.astype(dtype, copy=copy)\r\n    371         return Index(new_values, dtype=new_values.dtype, name=self.name)\r\n    372 \r\n\r\nc:\\users\\rclement\\documents\\.venv\\lib\\site-packages\\pandas\\core\\arrays\\interval.py in astype(self, dtype, copy)\r\n    779         except (TypeError, ValueError) as err:\r\n    780             msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\r\n--> 781             raise TypeError(msg) from err\r\n    782 \r\n    783     def equals(self, other) -> bool:\r\n\r\nTypeError: Cannot cast IntervalIndex to dtype int32\r\n\r\n</details>\r\n\r\n\r\n#### Expected Output\r\n\r\nA bar plot (produced with pandas 1.1.5):\r\n![barplot](https://user-images.githubusercontent.com/51399800/103641842-791c5f00-4fa6-11eb-9993-999ea26d47ef.PNG)\r\n\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 3e89b4c4b1580aa890023fc550774e63d499da25\r\npython           : 3.7.5.final.0\r\npython-bits      : 64\r\nOS               : Windows\r\nOS-release       : 10\r\nVersion          : 10.0.18362\r\nmachine          : AMD64\r\nprocessor        : Intel64 Family 6 Model 158 Stepping 10, GenuineIntel\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : None\r\nLOCALE           : None.None\r\n\r\npandas           : 1.2.0\r\nnumpy            : 1.19.4\r\npytz             : 2020.5\r\ndateutil         : 2.8.1\r\npip              : 19.2.3\r\nsetuptools       : 41.2.0\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : None\r\nlxml.etree       : None\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : None\r\njinja2           : None\r\nIPython          : None\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nfsspec           : None\r\nfastparquet      : None\r\ngcsfs            : None\r\nmatplotlib       : 3.3.3\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : None\r\npandas_gbq       : None\r\npyarrow          : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : None\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : None\r\nxarray           : None\r\nxlrd             : None\r\nxlwt             : None\r\nnumba            : None\r\n\r\n</details>\r\n\n\nThanks @venaturum for the report - could you put a descriptive title too please? Also, show the full traceback, not just the final part with the error message?\n\nDidn't check, but given the other reports, I suppose this is similarly as https://github.com/pandas-dev/pandas/issues/38947, https://github.com/pandas-dev/pandas/issues/38865, https://github.com/pandas-dev/pandas/issues/38736 caused by https://github.com/pandas-dev/pandas/pull/28733\r\n\n\n@MarcoGorelli , done now, sorry about that!\r\n\r\n@jorisvandenbossche, I think you're right, looks especially similar to 38947. \n\n> @jorisvandenbossche, I think you're right, looks especially similar to 38947.\r\n\r\nboth these fail from `self.tick_pos = ax.convert_xunits(self.ax_index).astype(np.int)` in `_make_plot` in `pandas\\plotting\\_matplotlib\\core.py`\r\n\r\ncould close as duplicate or leave open to ensure additional test coverage\n\n(let's keep open until we actually fix + add a test for this specific case)\n\nNo problem, I thought the closing candidate tag might have been a subtle hint ðŸ˜‚\n\n> Didn't check, but given the other reports, I suppose this is similarly as #38947, #38865, #38736 caused by #28733\r\n\r\n#28733 has been reverted. needs test to prevent regression.\n\nCould anyone please clarify what's needed here? Are we only missing a regression test? I'd be happy to help with this issue.\n\nYes, that's right\n\nThank you @MarcoGorelli! In that case, I'll take this issue and start to work on it as soon as I can.\n\nTo ensure this issue is assigned to me: take.\n\n@simonjayhawkins, @mroeschke, @MarcoGorelli: I left a comment above with the keyword 'take' but this issue was not assigned to me. Am I missing some step? Could any of you please assign it to me? Thanks!\n\nthe comment should only have a single word: take\r\n\r\nif your comment includes other words, it won't work\n\nI see. Thanks!\n\ntake\n\ntake",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/28733",
  "code_context": [
    {
      "filename": "pandas/plotting/_matplotlib/core.py",
      "content": "from typing import TYPE_CHECKING, List, Optional, Tuple\nimport warnings\n\nfrom matplotlib.artist import Artist\nimport numpy as np\n\nfrom pandas._typing import Label\nfrom pandas.errors import AbstractMethodError\nfrom pandas.util._decorators import cache_readonly\n\nfrom pandas.core.dtypes.common import (\n    is_float,\n    is_hashable,\n    is_integer,\n    is_iterator,\n    is_list_like,\n    is_number,\n    is_numeric_dtype,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna, notna\n\nimport pandas.core.common as com\n\nfrom pandas.io.formats.printing import pprint_thing\nfrom pandas.plotting._matplotlib.compat import mpl_ge_3_0_0\nfrom pandas.plotting._matplotlib.converter import register_pandas_matplotlib_converters\nfrom pandas.plotting._matplotlib.style import get_standard_colors\nfrom pandas.plotting._matplotlib.timeseries import (\n    decorate_axes,\n    format_dateaxis,\n    maybe_convert_index,\n    maybe_resample,\n    use_dynamic_x,\n)\nfrom pandas.plotting._matplotlib.tools import (\n    create_subplots,\n    flatten_axes,\n    format_date_labels,\n    get_all_lines,\n    get_xlim,\n    handle_shared_axes,\n    table,\n)\n\nif TYPE_CHECKING:\n    from matplotlib.axes import Axes\n    from matplotlib.axis import Axis\n\n\ndef _color_in_style(style: str) -> bool:\n    \"\"\"\n    Check if there is a color letter in the style string.\n    \"\"\"\n    from matplotlib.colors import BASE_COLORS\n\n    return not set(BASE_COLORS).isdisjoint(style)\n\n\nclass MPLPlot:\n    \"\"\"\n    Base class for assembling a pandas plot using matplotlib\n\n    Parameters\n    ----------\n    data :\n\n    \"\"\"\n\n    @property\n    def _kind(self):\n        \"\"\"Specify kind str. Must be overridden in child class\"\"\"\n        raise NotImplementedError\n\n    _layout_type = \"vertical\"\n    _default_rot = 0\n    orientation: Optional[str] = None\n\n    axes: np.ndarray  # of Axes objects\n\n    def __init__(\n        self,\n        data,\n        kind=None,\n        by=None,\n        subplots=False,\n        sharex=None,\n        sharey=False,\n        use_index=True,\n        figsize=None,\n        grid=None,\n        legend=True,\n        rot=None,\n        ax=None,\n        fig=None,\n        title=None,\n        xlim=None,\n        ylim=None,\n        xticks=None,\n        yticks=None,\n        xlabel: Optional[Label] = None,\n        ylabel: Optional[Label] = None,\n        sort_columns=False,\n        fontsize=None,\n        secondary_y=False,\n        colormap=None,\n        table=False,\n        layout=None,\n        include_bool=False,\n        **kwds,\n    ):\n\n        import matplotlib.pyplot as plt\n\n        self.data = data\n        self.by = by\n\n        self.kind = kind\n\n        self.sort_columns = sort_columns\n\n        self.subplots = subplots\n\n        if sharex is None:\n            if ax is None:\n                self.sharex = True\n            else:\n                # if we get an axis, the users should do the visibility\n                # setting...\n                self.sharex = False\n        else:\n            self.sharex = sharex\n\n        self.sharey = sharey\n        self.figsize = figsize\n        self.layout = layout\n\n        self.xticks = xticks\n        self.yticks = yticks\n        self.xlim = xlim\n        self.ylim = ylim\n        self.title = title\n        self.use_index = use_index\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n        self.fontsize = fontsize\n\n        if rot is not None:\n            self.rot = rot\n            # need to know for format_date_labels since it's rotated to 30 by\n            # default\n            self._rot_set = True\n        else:\n            self._rot_set = False\n            self.rot = self._default_rot\n\n        if grid is None:\n            grid = False if secondary_y else plt.rcParams[\"axes.grid\"]\n\n        self.grid = grid\n        self.legend = legend\n        self.legend_handles: List[Artist] = []\n        self.legend_labels: List[Label] = []\n\n        self.logx = kwds.pop(\"logx\", False)\n        self.logy = kwds.pop(\"logy\", False)\n        self.loglog = kwds.pop(\"loglog\", False)\n        self.label = kwds.pop(\"label\", None)\n        self.style = kwds.pop(\"style\", None)\n        self.mark_right = kwds.pop(\"mark_right\", True)\n        self.stacked = kwds.pop(\"stacked\", False)\n\n        self.ax = ax\n        self.fig = fig\n        self.axes = np.array([], dtype=object)  # \"real\" version get set in `generate`\n\n        # parse errorbar input if given\n        xerr = kwds.pop(\"xerr\", None)\n        yerr = kwds.pop(\"yerr\", None)\n        self.errors = {\n            kw: self._parse_errorbars(kw, err)\n            for kw, err in zip([\"xerr\", \"yerr\"], [xerr, yerr])\n        }\n\n        if not isinstance(secondary_y, (bool, tuple, list, np.ndarray, ABCIndexClass)):\n            secondary_y = [secondary_y]\n        self.secondary_y = secondary_y\n\n        # ugly TypeError if user passes matplotlib's `cmap` name.\n        # Probably better to accept either.\n        if \"cmap\" in kwds and colormap:\n            raise TypeError(\"Only specify one of `cmap` and `colormap`.\")\n        elif \"cmap\" in kwds:\n            self.colormap = kwds.pop(\"cmap\")\n        else:\n            self.colormap = colormap\n\n        self.table = table\n        self.include_bool = include_bool\n\n        self.kwds = kwds\n\n        self._validate_color_args()\n\n    def _validate_color_args(self):\n        if (\n            \"color\" in self.kwds\n            and self.nseries == 1\n            and not is_list_like(self.kwds[\"color\"])\n        ):\n            # support series.plot(color='green')\n            self.kwds[\"color\"] = [self.kwds[\"color\"]]\n\n        if (\n            \"color\" in self.kwds\n            and isinstance(self.kwds[\"color\"], tuple)\n            and self.nseries == 1\n            and len(self.kwds[\"color\"]) in (3, 4)\n        ):\n            # support RGB and RGBA tuples in series plot\n            self.kwds[\"color\"] = [self.kwds[\"color\"]]\n\n        if (\n            \"color\" in self.kwds or \"colors\" in self.kwds\n        ) and self.colormap is not None:\n            warnings.warn(\n                \"'color' and 'colormap' cannot be used simultaneously. Using 'color'\"\n            )\n\n        if \"color\" in self.kwds and self.style is not None:\n            if is_list_like(self.style):\n                styles = self.style\n            else:\n                styles = [self.style]\n            # need only a single match\n            for s in styles:\n                if _color_in_style(s):\n                    raise ValueError(\n                        \"Cannot pass 'style' string with a color symbol and \"\n                        \"'color' keyword argument. Please use one or the \"\n                        \"other or pass 'style' without a color symbol\"\n                    )\n\n    def _iter_data(self, data=None, keep_index=False, fillna=None):\n        if data is None:\n            data = self.data\n        if fillna is not None:\n            data = data.fillna(fillna)\n\n        for col, values in data.items():\n            if keep_index is True:\n                yield col, values\n            else:\n                yield col, values.values\n\n    @property\n    def nseries(self) -> int:\n        if self.data.ndim == 1:\n            return 1\n        else:\n            return self.data.shape[1]\n\n    def draw(self):\n        self.plt.draw_if_interactive()\n\n    def generate(self):\n        self._args_adjust()\n        self._compute_plot_data()\n        self._setup_subplots()\n        self._make_plot()\n        self._add_table()\n        self._make_legend()\n        self._adorn_subplots()\n\n        for ax in self.axes:\n            self._post_plot_logic_common(ax, self.data)\n            self._post_plot_logic(ax, self.data)\n\n    def _args_adjust(self):\n        pass\n\n    def _has_plotted_object(self, ax: \"Axes\") -> bool:\n        \"\"\"check whether ax has data\"\"\"\n        return len(ax.lines) != 0 or len(ax.artists) != 0 or len(ax.containers) != 0\n\n    def _maybe_right_yaxis(self, ax: \"Axes\", axes_num):\n        if not self.on_right(axes_num):\n            # secondary axes may be passed via ax kw\n            return self._get_ax_layer(ax)\n\n        if hasattr(ax, \"right_ax\"):\n            # if it has right_ax property, ``ax`` must be left axes\n            return ax.right_ax\n        elif hasattr(ax, \"left_ax\"):\n            # if it has left_ax property, ``ax`` must be right axes\n            return ax\n        else:\n            # otherwise, create twin axes\n            orig_ax, new_ax = ax, ax.twinx()\n            # TODO: use Matplotlib public API when available\n            new_ax._get_lines = orig_ax._get_lines\n            new_ax._get_patches_for_fill = orig_ax._get_patches_for_fill\n            orig_ax.right_ax, new_ax.left_ax = new_ax, orig_ax\n\n            if not self._has_plotted_object(orig_ax):  # no data on left y\n                orig_ax.get_yaxis().set_visible(False)\n\n            if self.logy is True or self.loglog is True:\n                new_ax.set_yscale(\"log\")\n            elif self.logy == \"sym\" or self.loglog == \"sym\":\n                new_ax.set_yscale(\"symlog\")\n            return new_ax\n\n    def _setup_subplots(self):\n        if self.subplots:\n            fig, axes = create_subplots(\n                naxes=self.nseries,\n                sharex=self.sharex,\n                sharey=self.sharey,\n                figsize=self.figsize,\n                ax=self.ax,\n                layout=self.layout,\n                layout_type=self._layout_type,\n            )\n        else:\n            if self.ax is None:\n                fig = self.plt.figure(figsize=self.figsize)\n                axes = fig.add_subplot(111)\n            else:\n                fig = self.ax.get_figure()\n                if self.figsize is not None:\n                    fig.set_size_inches(self.figsize)\n                axes = self.ax\n\n        axes = flatten_axes(axes)\n\n        valid_log = {False, True, \"sym\", None}\n        input_log = {self.logx, self.logy, self.loglog}\n        if input_log - valid_log:\n            invalid_log = next(iter(input_log - valid_log))\n            raise ValueError(\n                f\"Boolean, None and 'sym' are valid options, '{invalid_log}' is given.\"\n            )\n\n        if self.logx is True or self.loglog is True:\n            [a.set_xscale(\"log\") for a in axes]\n        elif self.logx == \"sym\" or self.loglog == \"sym\":\n            [a.set_xscale(\"symlog\") for a in axes]\n\n        if self.logy is True or self.loglog is True:\n            [a.set_yscale(\"log\") for a in axes]\n        elif self.logy == \"sym\" or self.loglog == \"sym\":\n            [a.set_yscale(\"symlog\") for a in axes]\n\n        self.fig = fig\n        self.axes = axes\n\n    @property\n    def result(self):\n        \"\"\"\n        Return result axes\n        \"\"\"\n        if self.subplots:\n            if self.layout is not None and not is_list_like(self.ax):\n                return self.axes.reshape(*self.layout)\n            else:\n                return self.axes\n        else:\n            sec_true = isinstance(self.secondary_y, bool) and self.secondary_y\n            all_sec = (\n                is_list_like(self.secondary_y) and len(self.secondary_y) == self.nseries\n            )\n            if sec_true or all_sec:\n                # if all data is plotted on secondary, return right axes\n                return self._get_ax_layer(self.axes[0], primary=False)\n            else:\n                return self.axes[0]\n\n    def _compute_plot_data(self):\n        data = self.data\n\n        if isinstance(data, ABCSeries):\n            label = self.label\n            if label is None and data.name is None:\n                label = \"None\"\n            data = data.to_frame(name=label)\n\n        # GH16953, _convert is needed as fallback, for ``Series``\n        # with ``dtype == object``\n        data = data._convert(datetime=True, timedelta=True)\n        include_type = [np.number, \"datetime\", \"datetimetz\", \"timedelta\"]\n\n        # GH23719, allow plotting boolean\n        if self.include_bool is True:\n            include_type.append(np.bool_)\n\n        # GH22799, exclude datetime-like type for boxplot\n        exclude_type = None\n        if self._kind == \"box\":\n            # TODO: change after solving issue 27881\n            include_type = [np.number]\n            exclude_type = [\"timedelta\"]\n\n        # GH 18755, include object and category type for scatter plot\n        if self._kind == \"scatter\":\n            include_type.extend([\"object\", \"category\"])\n\n        numeric_data = data.select_dtypes(include=include_type, exclude=exclude_type)\n\n        try:\n            is_empty = numeric_data.columns.empty\n        except AttributeError:\n            is_empty = not len(numeric_data)\n\n        # no non-numeric frames or series allowed\n        if is_empty:\n            raise TypeError(\"no numeric data to plot\")\n\n        # GH25587: cast ExtensionArray of pandas (IntegerArray, etc.) to\n        # np.ndarray before plot.\n        numeric_data = numeric_data.copy()\n        for col in numeric_data:\n            numeric_data[col] = np.asarray(numeric_data[col])\n\n        self.data = numeric_data\n\n    def _make_plot(self):\n        raise AbstractMethodError(self)\n\n    def _add_table(self):\n        if self.table is False:\n            return\n        elif self.table is True:\n            data = self.data.transpose()\n        else:\n            data = self.table\n        ax = self._get_ax(0)\n        table(ax, data)\n\n    def _post_plot_logic_common(self, ax, data):\n        \"\"\"Common post process for each axes\"\"\"\n        if self.orientation == \"vertical\" or self.orientation is None:\n            self._apply_axis_properties(ax.xaxis, rot=self.rot, fontsize=self.fontsize)\n            self._apply_axis_properties(ax.yaxis, fontsize=self.fontsize)\n\n            if hasattr(ax, \"right_ax\"):\n                self._apply_axis_properties(ax.right_ax.yaxis, fontsize=self.fontsize)\n\n        elif self.orientation == \"horizontal\":\n            self._apply_axis_properties(ax.yaxis, rot=self.rot, fontsize=self.fontsize)\n            self._apply_axis_properties(ax.xaxis, fontsize=self.fontsize)\n\n            if hasattr(ax, \"right_ax\"):\n                self._apply_axis_properties(ax.right_ax.yaxis, fontsize=self.fontsize)\n        else:  # pragma no cover\n            raise ValueError\n\n    def _post_plot_logic(self, ax, data):\n        \"\"\"Post process for each axes. Overridden in child classes\"\"\"\n        pass\n\n    def _adorn_subplots(self):\n        \"\"\"Common post process unrelated to data\"\"\"\n        if len(self.axes) > 0:\n            all_axes = self._get_subplots()\n            nrows, ncols = self._get_axes_layout()\n            handle_shared_axes(\n                axarr=all_axes,\n                nplots=len(all_axes),\n                naxes=nrows * ncols,\n                nrows=nrows,\n                ncols=ncols,\n                sharex=self.sharex,\n                sharey=self.sharey,\n            )\n\n        for ax in self.axes:\n            if self.yticks is not None:\n                ax.set_yticks(self.yticks)\n\n            if self.xticks is not None:\n                ax.set_xticks(self.xticks)\n\n            if self.ylim is not None:\n                ax.set_ylim(self.ylim)\n\n            if self.xlim is not None:\n                ax.set_xlim(self.xlim)\n\n            # GH9093, currently Pandas does not show ylabel, so if users provide\n            # ylabel will set it as ylabel in the plot.\n            if self.ylabel is not None:\n                ax.set_ylabel(pprint_thing(self.ylabel))\n\n            ax.grid(self.grid)\n\n        if self.title:\n            if self.subplots:\n                if is_list_like(self.title):\n                    if len(self.title) != self.nseries:\n                        raise ValueError(\n                            \"The length of `title` must equal the number \"\n                            \"of columns if using `title` of type `list` \"\n                            \"and `subplots=True`.\\n\"\n                            f\"length of title = {len(self.title)}\\n\"\n                            f\"number of columns = {self.nseries}\"\n                        )\n\n                    for (ax, title) in zip(self.axes, self.title):\n                        ax.set_title(title)\n                else:\n                    self.fig.suptitle(self.title)\n            else:\n                if is_list_like(self.title):\n                    msg = (\n                        \"Using `title` of type `list` is not supported \"\n                        \"unless `subplots=True` is passed\"\n                    )\n                    raise ValueError(msg)\n                self.axes[0].set_title(self.title)\n\n    def _apply_axis_properties(self, axis: \"Axis\", rot=None, fontsize=None):\n        \"\"\"\n        Tick creation within matplotlib is reasonably expensive and is\n        internally deferred until accessed as Ticks are created/destroyed\n        multiple times per draw. It's therefore beneficial for us to avoid\n        accessing unless we will act on the Tick.\n        \"\"\"\n        if rot is not None or fontsize is not None:\n            # rot=0 is a valid setting, hence the explicit None check\n            labels = axis.get_majorticklabels() + axis.get_minorticklabels()\n            for label in labels:\n                if rot is not None:\n                    label.set_rotation(rot)\n                if fontsize is not None:\n                    label.set_fontsize(fontsize)\n\n    @property\n    def legend_title(self) -> Optional[str]:\n        if not isinstance(self.data.columns, ABCMultiIndex):\n            name = self.data.columns.name\n            if name is not None:\n                name = pprint_thing(name)\n            return name\n        else:\n            stringified = map(pprint_thing, self.data.columns.names)\n            return \",\".join(stringified)\n\n    def _add_legend_handle(self, handle, label, index=None):\n        if label is not None:\n            if self.mark_right and index is not None:\n                if self.on_right(index):\n                    label = label + \" (right)\"\n            self.legend_handles.append(handle)\n            self.legend_labels.append(label)\n\n    def _make_legend(self):\n        ax, leg, handle = self._get_ax_legend_handle(self.axes[0])\n\n        handles = []\n        labels = []\n        title = \"\"\n\n        if not self.subplots:\n            if leg is not None:\n                title = leg.get_title().get_text()\n                # Replace leg.LegendHandles because it misses marker info\n                handles.extend(handle)\n                labels = [x.get_text() for x in leg.get_texts()]\n\n            if self.legend:\n                if self.legend == \"reverse\":\n                    # pandas\\plotting\\_matplotlib\\core.py:578: error:\n                    # Incompatible types in assignment (expression has type\n                    # \"Iterator[Any]\", variable has type \"List[Any]\")\n                    # [assignment]\n                    self.legend_handles = reversed(  # type: ignore[assignment]\n                        self.legend_handles\n                    )\n                    # pandas\\plotting\\_matplotlib\\core.py:579: error:\n                    # Incompatible types in assignment (expression has type\n                    # \"Iterator[Optional[Hashable]]\", variable has type\n                    # \"List[Optional[Hashable]]\")  [assignment]\n                    self.legend_labels = reversed(  # type: ignore[assignment]\n                        self.legend_labels\n                    )\n\n                handles += self.legend_handles\n                labels += self.legend_labels\n\n                if self.legend_title is not None:\n                    title = self.legend_title\n\n            if len(handles) > 0:\n                ax.legend(handles, labels, loc=\"best\", title=title)\n\n        elif self.subplots and self.legend:\n            for ax in self.axes:\n                if ax.get_visible():\n                    ax.legend(loc=\"best\")\n\n    def _get_ax_legend_handle(self, ax: \"Axes\"):\n        \"\"\"\n        Take in axes and return ax, legend and handle under different scenarios\n        \"\"\"\n        leg = ax.get_legend()\n\n        # Get handle from axes\n        handle, _ = ax.get_legend_handles_labels()\n        other_ax = getattr(ax, \"left_ax\", None) or getattr(ax, \"right_ax\", None)\n        other_leg = None\n        if other_ax is not None:\n            other_leg = other_ax.get_legend()\n        if leg is None and other_leg is not None:\n            leg = other_leg\n            ax = other_ax\n        return ax, leg, handle\n\n    @cache_readonly\n    def plt(self):\n        import matplotlib.pyplot as plt\n\n        return plt\n\n    _need_to_set_index = False\n\n    def _get_xticks(self, convert_period: bool = False):\n        index = self.data.index\n        is_datetype = index.inferred_type in (\"datetime\", \"date\", \"datetime64\", \"time\")\n\n        if self.use_index:\n            if convert_period and isinstance(index, ABCPeriodIndex):\n                self.data = self.data.reindex(index=index.sort_values())\n                x = self.data.index.to_timestamp()._mpl_repr()\n            elif index.is_numeric():\n                \"\"\"\n                Matplotlib supports numeric values or datetime objects as\n                xaxis values. Taking LBYL approach here, by the time\n                matplotlib raises exception when using non numeric/datetime\n                values for xaxis, several actions are already taken by plt.\n                \"\"\"\n                x = index._mpl_repr()\n            elif is_datetype:\n                self.data = self.data[notna(self.data.index)]\n                self.data = self.data.sort_index()\n                x = self.data.index._mpl_repr()\n            else:\n                self._need_to_set_index = True\n                x = list(range(len(index)))\n        else:\n            x = list(range(len(index)))\n\n        return x\n\n    @classmethod\n    @register_pandas_matplotlib_converters\n    def _plot(cls, ax: \"Axes\", x, y, style=None, is_errorbar: bool = False, **kwds):\n        mask = isna(y)\n        if mask.any():\n            y = np.ma.array(y)\n            y = np.ma.masked_where(mask, y)\n\n        if isinstance(x, ABCIndexClass):\n            x = x._mpl_repr()\n\n        if is_errorbar:\n            if \"xerr\" in kwds:\n                kwds[\"xerr\"] = np.array(kwds.get(\"xerr\"))\n            if \"yerr\" in kwds:\n                kwds[\"yerr\"] = np.array(kwds.get(\"yerr\"))\n            return ax.errorbar(x, y, **kwds)\n        else:\n            # prevent style kwarg from going to errorbar, where it is\n            # unsupported\n            if style is not None:\n                args = (x, y, style)\n            else:\n                args = (x, y)  # type: ignore[assignment]\n            return ax.plot(*args, **kwds)\n\n    def _get_index_name(self) -> Optional[str]:\n        if isinstance(self.data.index, ABCMultiIndex):\n            name = self.data.index.names\n            if com.any_not_none(*name):\n                name = \",\".join(pprint_thing(x) for x in name)\n            else:\n                name = None\n        else:\n            name = self.data.index.name\n            if name is not None:\n                name = pprint_thing(name)\n\n        # GH 9093, override the default xlabel if xlabel is provided.\n        if self.xlabel is not None:\n            name = pprint_thing(self.xlabel)\n\n        return name\n\n    @classmethod\n    def _get_ax_layer(cls, ax, primary=True):\n        \"\"\"get left (primary) or right (secondary) axes\"\"\"\n        if primary:\n            return getattr(ax, \"left_ax\", ax)\n        else:\n            return getattr(ax, \"right_ax\", ax)\n\n    def _get_ax(self, i: int):\n        # get the twinx ax if appropriate\n        if self.subplots:\n            ax = self.axes[i]\n            ax = self._maybe_right_yaxis(ax, i)\n            self.axes[i] = ax\n        else:\n            ax = self.axes[0]\n            ax = self._maybe_right_yaxis(ax, i)\n\n        ax.get_yaxis().set_visible(True)\n        return ax\n\n    @classmethod\n    def get_default_ax(cls, ax):\n        import matplotlib.pyplot as plt\n\n        if ax is None and len(plt.get_fignums()) > 0:\n            with plt.rc_context():\n                ax = plt.gca()\n            ax = cls._get_ax_layer(ax)\n\n    def on_right(self, i):\n        if isinstance(self.secondary_y, bool):\n            return self.secondary_y\n\n        if isinstance(self.secondary_y, (tuple, list, np.ndarray, ABCIndexClass)):\n            return self.data.columns[i] in self.secondary_y\n\n    def _apply_style_colors(self, colors, kwds, col_num, label):\n        \"\"\"\n        Manage style and color based on column number and its label.\n        Returns tuple of appropriate style and kwds which \"color\" may be added.\n        \"\"\"\n        style = None\n        if self.style is not None:\n            if isinstance(self.style, list):\n                try:\n                    style = self.style[col_num]\n                except IndexError:\n                    pass\n            elif isinstance(self.style, dict):\n                style = self.style.get(label, style)\n            else:\n                style = self.style\n\n        has_color = \"color\" in kwds or self.colormap is not None\n        nocolor_style = style is None or not _color_in_style(style)\n        if (has_color or self.subplots) and nocolor_style:\n            if isinstance(colors, dict):\n                kwds[\"color\"] = colors[label]\n            else:\n                kwds[\"color\"] = colors[col_num % len(colors)]\n        return style, kwds\n\n    def _get_colors(self, num_colors=None, color_kwds=\"color\"):\n        if num_colors is None:\n            num_colors = self.nseries\n\n        return get_standard_colors(\n            num_colors=num_colors,\n            colormap=self.colormap,\n            color=self.kwds.get(color_kwds),\n        )\n\n    def _parse_errorbars(self, label, err):\n        \"\"\"\n        Look for error keyword arguments and return the actual errorbar data\n        or return the error DataFrame/dict\n\n        Error bars can be specified in several ways:\n            Series: the user provides a pandas.Series object of the same\n                    length as the data\n            ndarray: provides a np.ndarray of the same length as the data\n            DataFrame/dict: error values are paired with keys matching the\n                    key in the plotted DataFrame\n            str: the name of the column within the plotted DataFrame\n\n        Asymmetrical error bars are also supported, however raw error values\n        must be provided in this case. For a ``N`` length :class:`Series`, a\n        ``2xN`` array should be provided indicating lower and upper (or left\n        and right) errors. For a ``MxN`` :class:`DataFrame`, asymmetrical errors\n        should be in a ``Mx2xN`` array.\n        \"\"\"\n        if err is None:\n            return None\n\n        def match_labels(data, e):\n            e = e.reindex(data.index)\n            return e\n\n        # key-matched DataFrame\n        if isinstance(err, ABCDataFrame):\n\n            err = match_labels(self.data, err)\n        # key-matched dict\n        elif isinstance(err, dict):\n            pass\n\n        # Series of error values\n        elif isinstance(err, ABCSeries):\n            # broadcast error series across data\n            err = match_labels(self.data, err)\n            err = np.atleast_2d(err)\n            err = np.tile(err, (self.nseries, 1))\n\n        # errors are a column in the dataframe\n        elif isinstance(err, str):\n            evalues = self.data[err].values\n            self.data = self.data[self.data.columns.drop(err)]\n            err = np.atleast_2d(evalues)\n            err = np.tile(err, (self.nseries, 1))\n\n        elif is_list_like(err):\n            if is_iterator(err):\n                err = np.atleast_2d(list(err))\n            else:\n                # raw error values\n                err = np.atleast_2d(err)\n\n            err_shape = err.shape\n\n            # asymmetrical error bars\n            if isinstance(self.data, ABCSeries) and err_shape[0] == 2:\n                err = np.expand_dims(err, 0)\n                err_shape = err.shape\n                if err_shape[2] != len(self.data):\n                    raise ValueError(\n                        \"Asymmetrical error bars should be provided \"\n                        f\"with the shape (2, {len(self.data)})\"\n                    )\n            elif isinstance(self.data, ABCDataFrame) and err.ndim == 3:\n                if (\n                    (err_shape[0] != self.nseries)\n                    or (err_shape[1] != 2)\n                    or (err_shape[2] != len(self.data))\n                ):\n                    raise ValueError(\n                        \"Asymmetrical error bars should be provided \"\n                        f\"with the shape ({self.nseries}, 2, {len(self.data)})\"\n                    )\n\n            # broadcast errors to each data series\n            if len(err) == 1:\n                err = np.tile(err, (self.nseries, 1))\n\n        elif is_number(err):\n            err = np.tile([err], (self.nseries, len(self.data)))\n\n        else:\n            msg = f\"No valid {label} detected\"\n            raise ValueError(msg)\n\n        return err\n\n    def _get_errorbars(self, label=None, index=None, xerr=True, yerr=True):\n        errors = {}\n\n        for kw, flag in zip([\"xerr\", \"yerr\"], [xerr, yerr]):\n            if flag:\n                err = self.errors[kw]\n                # user provided label-matched dataframe of errors\n                if isinstance(err, (ABCDataFrame, dict)):\n                    if label is not None and label in err.keys():\n                        err = err[label]\n                    else:\n                        err = None\n                elif index is not None and err is not None:\n                    err = err[index]\n\n                if err is not None:\n                    errors[kw] = err\n        return errors\n\n    def _get_subplots(self):\n        from matplotlib.axes import Subplot\n\n        return [\n            ax for ax in self.axes[0].get_figure().get_axes() if isinstance(ax, Subplot)\n        ]\n\n    def _get_axes_layout(self) -> Tuple[int, int]:\n        axes = self._get_subplots()\n        x_set = set()\n        y_set = set()\n        for ax in axes:\n            # check axes coordinates to estimate layout\n            points = ax.get_position().get_points()\n            x_set.add(points[0][0])\n            y_set.add(points[0][1])\n        return (len(y_set), len(x_set))\n\n\nclass PlanePlot(MPLPlot):\n    \"\"\"\n    Abstract class for plotting on plane, currently scatter and hexbin.\n    \"\"\"\n\n    _layout_type = \"single\"\n\n    def __init__(self, data, x, y, **kwargs):\n        MPLPlot.__init__(self, data, **kwargs)\n        if x is None or y is None:\n            raise ValueError(self._kind + \" requires an x and y column\")\n        if is_integer(x) and not self.data.columns.holds_integer():\n            x = self.data.columns[x]\n        if is_integer(y) and not self.data.columns.holds_integer():\n            y = self.data.columns[y]\n\n        # Scatter plot allows to plot objects data\n        if self._kind == \"hexbin\":\n            if len(self.data[x]._get_numeric_data()) == 0:\n                raise ValueError(self._kind + \" requires x column to be numeric\")\n            if len(self.data[y]._get_numeric_data()) == 0:\n                raise ValueError(self._kind + \" requires y column to be numeric\")\n\n        self.x = x\n        self.y = y\n\n    @property\n    def nseries(self) -> int:\n        return 1\n\n    def _post_plot_logic(self, ax: \"Axes\", data):\n        x, y = self.x, self.y\n        xlabel = self.xlabel if self.xlabel is not None else pprint_thing(x)\n        ylabel = self.ylabel if self.ylabel is not None else pprint_thing(y)\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(ylabel)\n\n    def _plot_colorbar(self, ax: \"Axes\", **kwds):\n        # Addresses issues #10611 and #10678:\n        # When plotting scatterplots and hexbinplots in IPython\n        # inline backend the colorbar axis height tends not to\n        # exactly match the parent axis height.\n        # The difference is due to small fractional differences\n        # in floating points with similar representation.\n        # To deal with this, this method forces the colorbar\n        # height to take the height of the parent axes.\n        # For a more detailed description of the issue\n        # see the following link:\n        # https://github.com/ipython/ipython/issues/11215\n\n        # GH33389, if ax is used multiple times, we should always\n        # use the last one which contains the latest information\n        # about the ax\n        img = ax.collections[-1]\n        cbar = self.fig.colorbar(img, ax=ax, **kwds)\n\n        if mpl_ge_3_0_0():\n            # The workaround below is no longer necessary.\n            return\n\n        points = ax.get_position().get_points()\n        cbar_points = cbar.ax.get_position().get_points()\n\n        cbar.ax.set_position(\n            [\n                cbar_points[0, 0],\n                points[0, 1],\n                cbar_points[1, 0] - cbar_points[0, 0],\n                points[1, 1] - points[0, 1],\n            ]\n        )\n        # To see the discrepancy in axis heights uncomment\n        # the following two lines:\n        # print(points[1, 1] - points[0, 1])\n        # print(cbar_points[1, 1] - cbar_points[0, 1])\n\n\nclass ScatterPlot(PlanePlot):\n    _kind = \"scatter\"\n\n    def __init__(self, data, x, y, s=None, c=None, **kwargs):\n        if s is None:\n            # hide the matplotlib default for size, in case we want to change\n            # the handling of this argument later\n            s = 20\n        elif is_hashable(s) and s in data.columns:\n            s = data[s]\n        super().__init__(data, x, y, s=s, **kwargs)\n        if is_integer(c) and not self.data.columns.holds_integer():\n            c = self.data.columns[c]\n        self.c = c\n\n    def _make_plot(self):\n        x, y, c, data = self.x, self.y, self.c, self.data\n        ax = self.axes[0]\n\n        c_is_column = is_hashable(c) and c in self.data.columns\n\n        # pandas uses colormap, matplotlib uses cmap.\n        cmap = self.colormap or \"Greys\"\n        cmap = self.plt.cm.get_cmap(cmap)\n        color = self.kwds.pop(\"color\", None)\n        if c is not None and color is not None:\n            raise TypeError(\"Specify exactly one of `c` and `color`\")\n        elif c is None and color is None:\n            c_values = self.plt.rcParams[\"patch.facecolor\"]\n        elif color is not None:\n            c_values = color\n        elif c_is_column:\n            c_values = self.data[c].values\n        else:\n            c_values = c\n\n        # plot colorbar if\n        # 1. colormap is assigned, and\n        # 2.`c` is a column containing only numeric values\n        plot_colorbar = self.colormap or c_is_column\n        cb = self.kwds.pop(\"colorbar\", is_numeric_dtype(c_values) and plot_colorbar)\n\n        if self.legend and hasattr(self, \"label\"):\n            label = self.label\n        else:\n            label = None\n        scatter = ax.scatter(\n            data[x].values,\n            data[y].values,\n            c=c_values,\n            label=label,\n            cmap=cmap,\n            **self.kwds,\n        )\n        if cb:\n            cbar_label = c if c_is_column else \"\"\n            self._plot_colorbar(ax, label=cbar_label)\n\n        if label is not None:\n            self._add_legend_handle(scatter, label)\n        else:\n            self.legend = False\n\n        errors_x = self._get_errorbars(label=x, index=0, yerr=False)\n        errors_y = self._get_errorbars(label=y, index=0, xerr=False)\n        if len(errors_x) > 0 or len(errors_y) > 0:\n            err_kwds = dict(errors_x, **errors_y)\n            err_kwds[\"ecolor\"] = scatter.get_facecolor()[0]\n            ax.errorbar(data[x].values, data[y].values, linestyle=\"none\", **err_kwds)\n\n\nclass HexBinPlot(PlanePlot):\n    _kind = \"hexbin\"\n\n    def __init__(self, data, x, y, C=None, **kwargs):\n        super().__init__(data, x, y, **kwargs)\n        if is_integer(C) and not self.data.columns.holds_integer():\n            C = self.data.columns[C]\n        self.C = C\n\n    def _make_plot(self):\n        x, y, data, C = self.x, self.y, self.data, self.C\n        ax = self.axes[0]\n        # pandas uses colormap, matplotlib uses cmap.\n        cmap = self.colormap or \"BuGn\"\n        cmap = self.plt.cm.get_cmap(cmap)\n        cb = self.kwds.pop(\"colorbar\", True)\n\n        if C is None:\n            c_values = None\n        else:\n            c_values = data[C].values\n\n        ax.hexbin(data[x].values, data[y].values, C=c_values, cmap=cmap, **self.kwds)\n        if cb:\n            self._plot_colorbar(ax)\n\n    def _make_legend(self):\n        pass\n\n\nclass LinePlot(MPLPlot):\n    _kind = \"line\"\n    _default_rot = 0\n    orientation = \"vertical\"\n\n    def __init__(self, data, **kwargs):\n        from pandas.plotting import plot_params\n\n        MPLPlot.__init__(self, data, **kwargs)\n        if self.stacked:\n            self.data = self.data.fillna(value=0)\n        self.x_compat = plot_params[\"x_compat\"]\n        if \"x_compat\" in self.kwds:\n            self.x_compat = bool(self.kwds.pop(\"x_compat\"))\n\n    def _is_ts_plot(self) -> bool:\n        # this is slightly deceptive\n        return not self.x_compat and self.use_index and self._use_dynamic_x()\n\n    def _use_dynamic_x(self):\n        return use_dynamic_x(self._get_ax(0), self.data)\n\n    def _make_plot(self):\n        if self._is_ts_plot():\n            data = maybe_convert_index(self._get_ax(0), self.data)\n\n            x = data.index  # dummy, not used\n            plotf = self._ts_plot\n            it = self._iter_data(data=data, keep_index=True)\n        else:\n            x = self._get_xticks(convert_period=True)\n            # pandas\\plotting\\_matplotlib\\core.py:1100: error: Incompatible\n            # types in assignment (expression has type \"Callable[[Any, Any,\n            # Any, Any, Any, Any, KwArg(Any)], Any]\", variable has type\n            # \"Callable[[Any, Any, Any, Any, KwArg(Any)], Any]\")  [assignment]\n            plotf = self._plot  # type: ignore[assignment]\n            it = self._iter_data()\n\n        stacking_id = self._get_stacking_id()\n        is_errorbar = com.any_not_none(*self.errors.values())\n\n        colors = self._get_colors()\n        for i, (label, y) in enumerate(it):\n            ax = self._get_ax(i)\n            kwds = self.kwds.copy()\n            style, kwds = self._apply_style_colors(colors, kwds, i, label)\n\n            errors = self._get_errorbars(label=label, index=i)\n            kwds = dict(kwds, **errors)\n\n            label = pprint_thing(label)  # .encode('utf-8')\n            kwds[\"label\"] = label\n\n            newlines = plotf(\n                ax,\n                x,\n                y,\n                style=style,\n                column_num=i,\n                stacking_id=stacking_id,\n                is_errorbar=is_errorbar,\n                **kwds,\n            )\n            self._add_legend_handle(newlines[0], label, index=i)\n\n            if self._is_ts_plot():\n\n                # reset of xlim should be used for ts data\n                # TODO: GH28021, should find a way to change view limit on xaxis\n                lines = get_all_lines(ax)\n                left, right = get_xlim(lines)\n                ax.set_xlim(left, right)\n\n    @classmethod\n    def _plot(\n        cls, ax: \"Axes\", x, y, style=None, column_num=None, stacking_id=None, **kwds\n    ):\n        # column_num is used to get the target column from plotf in line and\n        # area plots\n        if column_num == 0:\n            cls._initialize_stacker(ax, stacking_id, len(y))\n        y_values = cls._get_stacked_values(ax, stacking_id, y, kwds[\"label\"])\n        lines = MPLPlot._plot(ax, x, y_values, style=style, **kwds)\n        cls._update_stacker(ax, stacking_id, y)\n        return lines\n\n    @classmethod\n    def _ts_plot(cls, ax: \"Axes\", x, data, style=None, **kwds):\n        # accept x to be consistent with normal plot func,\n        # x is not passed to tsplot as it uses data.index as x coordinate\n        # column_num must be in kwds for stacking purpose\n        freq, data = maybe_resample(data, ax, kwds)\n\n        # Set ax with freq info\n        decorate_axes(ax, freq, kwds)\n        # digging deeper\n        if hasattr(ax, \"left_ax\"):\n            decorate_axes(ax.left_ax, freq, kwds)\n        if hasattr(ax, \"right_ax\"):\n            decorate_axes(ax.right_ax, freq, kwds)\n        ax._plot_data.append((data, cls._kind, kwds))\n\n        lines = cls._plot(ax, data.index, data.values, style=style, **kwds)\n        # set date formatter, locators and rescale limits\n        format_dateaxis(ax, ax.freq, data.index)\n        return lines\n\n    def _get_stacking_id(self):\n        if self.stacked:\n            return id(self.data)\n        else:\n            return None\n\n    @classmethod\n    def _initialize_stacker(cls, ax: \"Axes\", stacking_id, n: int):\n        if stacking_id is None:\n            return\n        if not hasattr(ax, \"_stacker_pos_prior\"):\n            ax._stacker_pos_prior = {}\n        if not hasattr(ax, \"_stacker_neg_prior\"):\n            ax._stacker_neg_prior = {}\n        ax._stacker_pos_prior[stacking_id] = np.zeros(n)\n        ax._stacker_neg_prior[stacking_id] = np.zeros(n)\n\n    @classmethod\n    def _get_stacked_values(cls, ax: \"Axes\", stacking_id, values, label):\n        if stacking_id is None:\n            return values\n        if not hasattr(ax, \"_stacker_pos_prior\"):\n            # stacker may not be initialized for subplots\n            cls._initialize_stacker(ax, stacking_id, len(values))\n\n        if (values >= 0).all():\n            return ax._stacker_pos_prior[stacking_id] + values\n        elif (values <= 0).all():\n            return ax._stacker_neg_prior[stacking_id] + values\n\n        raise ValueError(\n            \"When stacked is True, each column must be either \"\n            \"all positive or negative.\"\n            f\"{label} contains both positive and negative values\"\n        )\n\n    @classmethod\n    def _update_stacker(cls, ax: \"Axes\", stacking_id, values):\n        if stacking_id is None:\n            return\n        if (values >= 0).all():\n            ax._stacker_pos_prior[stacking_id] += values\n        elif (values <= 0).all():\n            ax._stacker_neg_prior[stacking_id] += values\n\n    def _post_plot_logic(self, ax: \"Axes\", data):\n        from matplotlib.ticker import FixedLocator\n\n        def get_label(i):\n            if is_float(i) and i.is_integer():\n                i = int(i)\n            try:\n                return pprint_thing(data.index[i])\n            except Exception:\n                return \"\"\n\n        if self._need_to_set_index:\n            xticks = ax.get_xticks()\n            xticklabels = [get_label(x) for x in xticks]\n            ax.xaxis.set_major_locator(FixedLocator(xticks))\n            ax.set_xticklabels(xticklabels)\n\n        # If the index is an irregular time series, then by default\n        # we rotate the tick labels. The exception is if there are\n        # subplots which don't share their x-axes, in which we case\n        # we don't rotate the ticklabels as by default the subplots\n        # would be too close together.\n        condition = (\n            not self._use_dynamic_x()\n            and (data.index._is_all_dates and self.use_index)\n            and (not self.subplots or (self.subplots and self.sharex))\n        )\n\n        index_name = self._get_index_name()\n\n        if condition:\n            # irregular TS rotated 30 deg. by default\n            # probably a better place to check / set this.\n            if not self._rot_set:\n                self.rot = 30\n            format_date_labels(ax, rot=self.rot)\n\n        if index_name is not None and self.use_index:\n            ax.set_xlabel(index_name)\n\n\nclass AreaPlot(LinePlot):\n    _kind = \"area\"\n\n    def __init__(self, data, **kwargs):\n        kwargs.setdefault(\"stacked\", True)\n        data = data.fillna(value=0)\n        LinePlot.__init__(self, data, **kwargs)\n\n        if not self.stacked:\n            # use smaller alpha to distinguish overlap\n            self.kwds.setdefault(\"alpha\", 0.5)\n\n        if self.logy or self.loglog:\n            raise ValueError(\"Log-y scales are not supported in area plot\")\n\n    @classmethod\n    def _plot(\n        cls,\n        ax: \"Axes\",\n        x,\n        y,\n        style=None,\n        column_num=None,\n        stacking_id=None,\n        is_errorbar=False,\n        **kwds,\n    ):\n\n        if column_num == 0:\n            cls._initialize_stacker(ax, stacking_id, len(y))\n        y_values = cls._get_stacked_values(ax, stacking_id, y, kwds[\"label\"])\n\n        # need to remove label, because subplots uses mpl legend as it is\n        line_kwds = kwds.copy()\n        line_kwds.pop(\"label\")\n        lines = MPLPlot._plot(ax, x, y_values, style=style, **line_kwds)\n\n        # get data from the line to get coordinates for fill_between\n        xdata, y_values = lines[0].get_data(orig=False)\n\n        # unable to use ``_get_stacked_values`` here to get starting point\n        if stacking_id is None:\n            start = np.zeros(len(y))\n        elif (y >= 0).all():\n            start = ax._stacker_pos_prior[stacking_id]\n        elif (y <= 0).all():\n            start = ax._stacker_neg_prior[stacking_id]\n        else:\n            start = np.zeros(len(y))\n\n        if \"color\" not in kwds:\n            kwds[\"color\"] = lines[0].get_color()\n\n        rect = ax.fill_between(xdata, start, y_values, **kwds)\n        cls._update_stacker(ax, stacking_id, y)\n\n        # LinePlot expects list of artists\n        res = [rect]\n        return res\n\n    def _post_plot_logic(self, ax: \"Axes\", data):\n        LinePlot._post_plot_logic(self, ax, data)\n\n        is_shared_y = len(list(ax.get_shared_y_axes())) > 0\n        # do not override the default axis behaviour in case of shared y axes\n        if self.ylim is None and not is_shared_y:\n            if (data >= 0).all().all():\n                ax.set_ylim(0, None)\n            elif (data <= 0).all().all():\n                ax.set_ylim(None, 0)\n\n\nclass BarPlot(MPLPlot):\n    _kind = \"bar\"\n    _default_rot = 90\n    orientation = \"vertical\"\n\n    def __init__(self, data, **kwargs):\n        # we have to treat a series differently than a\n        # 1-column DataFrame w.r.t. color handling\n        self._is_series = isinstance(data, ABCSeries)\n        self.bar_width = kwargs.pop(\"width\", 0.5)\n        pos = kwargs.pop(\"position\", 0.5)\n        kwargs.setdefault(\"align\", \"center\")\n\n        self.bottom = kwargs.pop(\"bottom\", 0)\n        self.left = kwargs.pop(\"left\", 0)\n\n        self.log = kwargs.pop(\"log\", False)\n        MPLPlot.__init__(self, data, **kwargs)\n\n        if self.stacked or self.subplots:\n            self.tickoffset = self.bar_width * pos\n            if kwargs[\"align\"] == \"edge\":\n                self.lim_offset = self.bar_width / 2\n            else:\n                self.lim_offset = 0\n        else:\n            if kwargs[\"align\"] == \"edge\":\n                w = self.bar_width / self.nseries\n                self.tickoffset = self.bar_width * (pos - 0.5) + w * 0.5\n                self.lim_offset = w * 0.5\n            else:\n                self.tickoffset = self.bar_width * pos\n                self.lim_offset = 0\n\n        if isinstance(self.data.index, ABCMultiIndex):\n            if kwargs[\"ax\"] is not None and kwargs[\"ax\"].has_data():\n                warnings.warn(\n                    \"Redrawing a bar plot with a MultiIndex is not supported \"\n                    + \"and may lead to inconsistent label positions.\",\n                    UserWarning,\n                )\n            self.ax_index = np.arange(len(data))\n        else:\n            self.ax_index = self.data.index\n\n    def _args_adjust(self):\n        if is_list_like(self.bottom):\n            self.bottom = np.array(self.bottom)\n        if is_list_like(self.left):\n            self.left = np.array(self.left)\n\n    @classmethod\n    def _plot(cls, ax: \"Axes\", x, y, w, start=0, log=False, **kwds):\n        return ax.bar(x, y, w, bottom=start, log=log, **kwds)\n\n    @property\n    def _start_base(self):\n        return self.bottom\n\n    def _make_plot(self):\n        import matplotlib as mpl\n\n        colors = self._get_colors()\n        ncolors = len(colors)\n\n        pos_prior = neg_prior = np.zeros(len(self.data))\n        K = self.nseries\n\n        for i, (label, y) in enumerate(self._iter_data(fillna=0)):\n            ax = self._get_ax(i)\n\n            if self.orientation == \"vertical\":\n                ax.xaxis.update_units(self.ax_index)\n                self.tick_pos = ax.convert_xunits(self.ax_index).astype(np.int)\n            elif self.orientation == \"horizontal\":\n                ax.yaxis.update_units(self.ax_index)\n                self.tick_pos = ax.convert_yunits(self.ax_index).astype(np.int)\n            self.ax_pos = self.tick_pos - self.tickoffset\n\n            kwds = self.kwds.copy()\n            if self._is_series:\n                kwds[\"color\"] = colors\n            elif isinstance(colors, dict):\n                kwds[\"color\"] = colors[label]\n            else:\n                kwds[\"color\"] = colors[i % ncolors]\n\n            errors = self._get_errorbars(label=label, index=i)\n            kwds = dict(kwds, **errors)\n\n            label = pprint_thing(label)\n\n            if ((\"yerr\" in kwds) or (\"xerr\" in kwds)) and (kwds.get(\"ecolor\") is None):\n                kwds[\"ecolor\"] = mpl.rcParams[\"xtick.color\"]\n\n            start = 0\n            if self.log and (y >= 1).all():\n                start = 1\n            start = start + self._start_base\n\n            if self.subplots:\n                w = self.bar_width / 2\n                rect = self._plot(\n                    ax,\n                    self.ax_pos + w,\n                    y,\n                    self.bar_width,\n                    start=start,\n                    label=label,\n                    log=self.log,\n                    **kwds,\n                )\n                ax.set_title(label)\n            elif self.stacked:\n                mask = y > 0\n                start = np.where(mask, pos_prior, neg_prior) + self._start_base\n                w = self.bar_width / 2\n                rect = self._plot(\n                    ax,\n                    self.ax_pos + w,\n                    y,\n                    self.bar_width,\n                    start=start,\n                    label=label,\n                    log=self.log,\n                    **kwds,\n                )\n                pos_prior = pos_prior + np.where(mask, y, 0)\n                neg_prior = neg_prior + np.where(mask, 0, y)\n            else:\n                w = self.bar_width / K\n                rect = self._plot(\n                    ax,\n                    self.ax_pos + (i + 0.5) * w,\n                    y,\n                    w,\n                    start=start,\n                    label=label,\n                    log=self.log,\n                    **kwds,\n                )\n            self._add_legend_handle(rect, label, index=i)\n\n    def _post_plot_logic(self, ax: \"Axes\", data):\n        if self.use_index:\n            str_index = [pprint_thing(key) for key in data.index]\n        else:\n            str_index = [pprint_thing(key) for key in range(data.shape[0])]\n        name = self._get_index_name()\n\n        s_edge = self.ax_pos.min() - 0.25 + self.lim_offset\n        e_edge = self.ax_pos.max() + 0.25 + self.bar_width + self.lim_offset\n\n        self._decorate_ticks(ax, name, str_index, s_edge, e_edge)\n\n    def _decorate_ticks(self, ax: \"Axes\", name, ticklabels, start_edge, end_edge):\n        ax.set_xlim((start_edge, end_edge))\n\n        if self.xticks is not None:\n            ax.set_xticks(np.array(self.xticks))\n        else:\n            ax.set_xticks(self.tick_pos)\n            ax.set_xticklabels(ticklabels)\n\n        if name is not None and self.use_index:\n            ax.set_xlabel(name)\n\n\nclass BarhPlot(BarPlot):\n    _kind = \"barh\"\n    _default_rot = 0\n    orientation = \"horizontal\"\n\n    @property\n    def _start_base(self):\n        return self.left\n\n    @classmethod\n    def _plot(cls, ax: \"Axes\", x, y, w, start=0, log=False, **kwds):\n        return ax.barh(x, y, w, left=start, log=log, **kwds)\n\n    def _decorate_ticks(self, ax: \"Axes\", name, ticklabels, start_edge, end_edge):\n        # horizontal bars\n        ax.set_ylim((start_edge, end_edge))\n        ax.set_yticks(self.tick_pos)\n        ax.set_yticklabels(ticklabels)\n        if name is not None and self.use_index:\n            ax.set_ylabel(name)\n\n\nclass PiePlot(MPLPlot):\n    _kind = \"pie\"\n    _layout_type = \"horizontal\"\n\n    def __init__(self, data, kind=None, **kwargs):\n        data = data.fillna(value=0)\n        if (data < 0).any().any():\n            raise ValueError(f\"{kind} doesn't allow negative values\")\n        MPLPlot.__init__(self, data, kind=kind, **kwargs)\n\n    def _args_adjust(self):\n        self.grid = False\n        self.logy = False\n        self.logx = False\n        self.loglog = False\n\n    def _validate_color_args(self):\n        pass\n\n    def _make_plot(self):\n        colors = self._get_colors(num_colors=len(self.data), color_kwds=\"colors\")\n        self.kwds.setdefault(\"colors\", colors)\n\n        for i, (label, y) in enumerate(self._iter_data()):\n            ax = self._get_ax(i)\n            if label is not None:\n                label = pprint_thing(label)\n                ax.set_ylabel(label)\n\n            kwds = self.kwds.copy()\n\n            def blank_labeler(label, value):\n                if value == 0:\n                    return \"\"\n                else:\n                    return label\n\n            idx = [pprint_thing(v) for v in self.data.index]\n            labels = kwds.pop(\"labels\", idx)\n            # labels is used for each wedge's labels\n            # Blank out labels for values of 0 so they don't overlap\n            # with nonzero wedges\n            if labels is not None:\n                blabels = [blank_labeler(l, value) for l, value in zip(labels, y)]\n            else:\n                # pandas\\plotting\\_matplotlib\\core.py:1546: error: Incompatible\n                # types in assignment (expression has type \"None\", variable has\n                # type \"List[Any]\")  [assignment]\n                blabels = None  # type: ignore[assignment]\n            results = ax.pie(y, labels=blabels, **kwds)\n\n            if kwds.get(\"autopct\", None) is not None:\n                patches, texts, autotexts = results\n            else:\n                patches, texts = results\n                autotexts = []\n\n            if self.fontsize is not None:\n                for t in texts + autotexts:\n                    t.set_fontsize(self.fontsize)\n\n            # leglabels is used for legend labels\n            leglabels = labels if labels is not None else idx\n            for p, l in zip(patches, leglabels):\n                self._add_legend_handle(p, l)\n"
    },
    {
      "filename": "pandas/tests/plotting/frame/test_frame.py",
      "content": "\"\"\" Test cases for DataFrame.plot \"\"\"\n\nfrom datetime import date, datetime\nimport itertools\nimport string\nimport warnings\n\nimport numpy as np\nimport pytest\n\nimport pandas.util._test_decorators as td\n\nfrom pandas.core.dtypes.api import is_list_like\n\nimport pandas as pd\nfrom pandas import DataFrame, MultiIndex, PeriodIndex, Series, bdate_range, date_range\nimport pandas._testing as tm\nfrom pandas.core.arrays import integer_array\nfrom pandas.tests.plotting.common import TestPlotBase, _check_plot_works\n\nfrom pandas.io.formats.printing import pprint_thing\nimport pandas.plotting as plotting\n\n\n@td.skip_if_no_mpl\nclass TestDataFramePlots(TestPlotBase):\n    def setup_method(self, method):\n        TestPlotBase.setup_method(self, method)\n        import matplotlib as mpl\n\n        mpl.rcdefaults()\n\n        self.tdf = tm.makeTimeDataFrame()\n        self.hexbin_df = DataFrame(\n            {\n                \"A\": np.random.uniform(size=20),\n                \"B\": np.random.uniform(size=20),\n                \"C\": np.arange(20) + np.random.uniform(size=20),\n            }\n        )\n\n    @pytest.mark.slow\n    def test_plot(self):\n        from pandas.plotting._matplotlib.compat import mpl_ge_3_1_0\n\n        df = self.tdf\n        _check_plot_works(df.plot, grid=False)\n\n        # _check_plot_works adds an ax so use default_axes=True to avoid warning\n        axes = _check_plot_works(df.plot, default_axes=True, subplots=True)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        axes = _check_plot_works(\n            df.plot,\n            default_axes=True,\n            subplots=True,\n            layout=(-1, 2),\n        )\n        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))\n\n        axes = _check_plot_works(\n            df.plot,\n            default_axes=True,\n            subplots=True,\n            use_index=False,\n        )\n        self._check_ticks_props(axes, xrot=0)\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        df = DataFrame({\"x\": [1, 2], \"y\": [3, 4]})\n        if mpl_ge_3_1_0():\n            msg = \"'Line2D' object has no property 'blarg'\"\n        else:\n            msg = \"Unknown property blarg\"\n        with pytest.raises(AttributeError, match=msg):\n            df.plot.line(blarg=True)\n\n        df = DataFrame(np.random.rand(10, 3), index=list(string.ascii_letters[:10]))\n\n        ax = _check_plot_works(df.plot, use_index=True)\n        self._check_ticks_props(ax, xrot=0)\n        _check_plot_works(df.plot, sort_columns=False)\n        _check_plot_works(df.plot, yticks=[1, 5, 10])\n        _check_plot_works(df.plot, xticks=[1, 5, 10])\n        _check_plot_works(df.plot, ylim=(-100, 100), xlim=(-100, 100))\n\n        _check_plot_works(df.plot, default_axes=True, subplots=True, title=\"blah\")\n\n        # We have to redo it here because _check_plot_works does two plots,\n        # once without an ax kwarg and once with an ax kwarg and the new sharex\n        # behaviour does not remove the visibility of the latter axis (as ax is\n        # present).  see: https://github.com/pandas-dev/pandas/issues/9737\n\n        axes = df.plot(subplots=True, title=\"blah\")\n        self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n        # axes[0].figure.savefig(\"test.png\")\n        for ax in axes[:2]:\n            self._check_visible(ax.xaxis)  # xaxis must be visible for grid\n            self._check_visible(ax.get_xticklabels(), visible=False)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=False)\n            self._check_visible([ax.xaxis.get_label()], visible=False)\n        for ax in [axes[2]]:\n            self._check_visible(ax.xaxis)\n            self._check_visible(ax.get_xticklabels())\n            self._check_visible([ax.xaxis.get_label()])\n            self._check_ticks_props(ax, xrot=0)\n\n        _check_plot_works(df.plot, title=\"blah\")\n\n        tuples = zip(string.ascii_letters[:10], range(10))\n        df = DataFrame(np.random.rand(10, 3), index=MultiIndex.from_tuples(tuples))\n        ax = _check_plot_works(df.plot, use_index=True)\n        self._check_ticks_props(ax, xrot=0)\n\n        # unicode\n        index = MultiIndex.from_tuples(\n            [\n                (\"\\u03b1\", 0),\n                (\"\\u03b1\", 1),\n                (\"\\u03b2\", 2),\n                (\"\\u03b2\", 3),\n                (\"\\u03b3\", 4),\n                (\"\\u03b3\", 5),\n                (\"\\u03b4\", 6),\n                (\"\\u03b4\", 7),\n            ],\n            names=[\"i0\", \"i1\"],\n        )\n        columns = MultiIndex.from_tuples(\n            [(\"bar\", \"\\u0394\"), (\"bar\", \"\\u0395\")], names=[\"c0\", \"c1\"]\n        )\n        df = DataFrame(np.random.randint(0, 10, (8, 2)), columns=columns, index=index)\n        _check_plot_works(df.plot, title=\"\\u03A3\")\n\n        # GH 6951\n        # Test with single column\n        df = DataFrame({\"x\": np.random.rand(10)})\n        axes = _check_plot_works(df.plot.bar, subplots=True)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n        axes = _check_plot_works(df.plot.bar, subplots=True, layout=(-1, 1))\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n        # When ax is supplied and required number of axes is 1,\n        # passed ax should be used:\n        fig, ax = self.plt.subplots()\n        axes = df.plot.bar(subplots=True, ax=ax)\n        assert len(axes) == 1\n        result = ax.axes\n        assert result is axes[0]\n\n    def test_integer_array_plot(self):\n        # GH 25587\n        arr = integer_array([1, 2, 3, 4], dtype=\"UInt32\")\n\n        s = Series(arr)\n        _check_plot_works(s.plot.line)\n        _check_plot_works(s.plot.bar)\n        _check_plot_works(s.plot.hist)\n        _check_plot_works(s.plot.pie)\n\n        df = DataFrame({\"x\": arr, \"y\": arr})\n        _check_plot_works(df.plot.line)\n        _check_plot_works(df.plot.bar)\n        _check_plot_works(df.plot.hist)\n        _check_plot_works(df.plot.pie, y=\"y\")\n        _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\")\n        _check_plot_works(df.plot.hexbin, x=\"x\", y=\"y\")\n\n    def test_nonnumeric_exclude(self):\n        df = DataFrame({\"A\": [\"x\", \"y\", \"z\"], \"B\": [1, 2, 3]})\n        ax = df.plot()\n        assert len(ax.get_lines()) == 1  # B was plotted\n\n    @pytest.mark.slow\n    def test_implicit_label(self):\n        df = DataFrame(np.random.randn(10, 3), columns=[\"a\", \"b\", \"c\"])\n        ax = df.plot(x=\"a\", y=\"b\")\n        self._check_text_labels(ax.xaxis.get_label(), \"a\")\n\n    @pytest.mark.slow\n    def test_donot_overwrite_index_name(self):\n        # GH 8494\n        df = DataFrame(np.random.randn(2, 2), columns=[\"a\", \"b\"])\n        df.index.name = \"NAME\"\n        df.plot(y=\"b\", label=\"LABEL\")\n        assert df.index.name == \"NAME\"\n\n    @pytest.mark.slow\n    def test_plot_xy(self):\n        # columns.inferred_type == 'string'\n        df = self.tdf\n        self._check_data(df.plot(x=0, y=1), df.set_index(\"A\")[\"B\"].plot())\n        self._check_data(df.plot(x=0), df.set_index(\"A\").plot())\n        self._check_data(df.plot(y=0), df.B.plot())\n        self._check_data(df.plot(x=\"A\", y=\"B\"), df.set_index(\"A\").B.plot())\n        self._check_data(df.plot(x=\"A\"), df.set_index(\"A\").plot())\n        self._check_data(df.plot(y=\"B\"), df.B.plot())\n\n        # columns.inferred_type == 'integer'\n        df.columns = np.arange(1, len(df.columns) + 1)\n        self._check_data(df.plot(x=1, y=2), df.set_index(1)[2].plot())\n        self._check_data(df.plot(x=1), df.set_index(1).plot())\n        self._check_data(df.plot(y=1), df[1].plot())\n\n        # figsize and title\n        ax = df.plot(x=1, y=2, title=\"Test\", figsize=(16, 8))\n        self._check_text_labels(ax.title, \"Test\")\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16.0, 8.0))\n\n        # columns.inferred_type == 'mixed'\n        # TODO add MultiIndex test\n\n    @pytest.mark.slow\n    @pytest.mark.parametrize(\n        \"input_log, expected_log\", [(True, \"log\"), (\"sym\", \"symlog\")]\n    )\n    def test_logscales(self, input_log, expected_log):\n        df = DataFrame({\"a\": np.arange(100)}, index=np.arange(100))\n\n        ax = df.plot(logy=input_log)\n        self._check_ax_scales(ax, yaxis=expected_log)\n        assert ax.get_yscale() == expected_log\n\n        ax = df.plot(logx=input_log)\n        self._check_ax_scales(ax, xaxis=expected_log)\n        assert ax.get_xscale() == expected_log\n\n        ax = df.plot(loglog=input_log)\n        self._check_ax_scales(ax, xaxis=expected_log, yaxis=expected_log)\n        assert ax.get_xscale() == expected_log\n        assert ax.get_yscale() == expected_log\n\n    @pytest.mark.parametrize(\"input_param\", [\"logx\", \"logy\", \"loglog\"])\n    def test_invalid_logscale(self, input_param):\n        # GH: 24867\n        df = DataFrame({\"a\": np.arange(100)}, index=np.arange(100))\n\n        msg = \"Boolean, None and 'sym' are valid options, 'sm' is given.\"\n        with pytest.raises(ValueError, match=msg):\n            df.plot(**{input_param: \"sm\"})\n\n    @pytest.mark.slow\n    def test_xcompat(self):\n        import pandas as pd\n\n        df = self.tdf\n        ax = df.plot(x_compat=True)\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        self._check_ticks_props(ax, xrot=30)\n\n        tm.close()\n        pd.plotting.plot_params[\"xaxis.compat\"] = True\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        self._check_ticks_props(ax, xrot=30)\n\n        tm.close()\n        pd.plotting.plot_params[\"x_compat\"] = False\n\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)\n\n        tm.close()\n        # useful if you're plotting a bunch together\n        with pd.plotting.plot_params.use(\"x_compat\", True):\n            ax = df.plot()\n            lines = ax.get_lines()\n            assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n            self._check_ticks_props(ax, xrot=30)\n\n        tm.close()\n        ax = df.plot()\n        lines = ax.get_lines()\n        assert not isinstance(lines[0].get_xdata(), PeriodIndex)\n        assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)\n        self._check_ticks_props(ax, xrot=0)\n\n    def test_period_compat(self):\n        # GH 9012\n        # period-array conversions\n        df = DataFrame(\n            np.random.rand(21, 2),\n            index=bdate_range(datetime(2000, 1, 1), datetime(2000, 1, 31)),\n            columns=[\"a\", \"b\"],\n        )\n\n        df.plot()\n        self.plt.axhline(y=0)\n        tm.close()\n\n    def test_unsorted_index(self):\n        df = DataFrame(\n            {\"y\": np.arange(100)}, index=np.arange(99, -1, -1), dtype=np.int64\n        )\n        ax = df.plot()\n        lines = ax.get_lines()[0]\n        rs = lines.get_xydata()\n        rs = Series(rs[:, 1], rs[:, 0], dtype=np.int64, name=\"y\")\n        tm.assert_series_equal(rs, df.y, check_index_type=False)\n        tm.close()\n\n        df.index = pd.Index(np.arange(99, -1, -1), dtype=np.float64)\n        ax = df.plot()\n        lines = ax.get_lines()[0]\n        rs = lines.get_xydata()\n        rs = Series(rs[:, 1], rs[:, 0], dtype=np.int64, name=\"y\")\n        tm.assert_series_equal(rs, df.y)\n\n    def test_unsorted_index_lims(self):\n        df = DataFrame({\"y\": [0.0, 1.0, 2.0, 3.0]}, index=[1.0, 0.0, 3.0, 2.0])\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n        df = DataFrame(\n            {\"y\": [0.0, 1.0, np.nan, 3.0, 4.0, 5.0, 6.0]},\n            index=[1.0, 0.0, 3.0, 2.0, np.nan, 3.0, 2.0],\n        )\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n        df = DataFrame({\"y\": [0.0, 1.0, 2.0, 3.0], \"z\": [91.0, 90.0, 93.0, 92.0]})\n        ax = df.plot(x=\"z\", y=\"y\")\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data()[0])\n        assert xmax >= np.nanmax(lines[0].get_data()[0])\n\n    def test_negative_log(self):\n        df = -DataFrame(\n            np.random.rand(6, 4),\n            index=list(string.ascii_letters[:6]),\n            columns=[\"x\", \"y\", \"z\", \"four\"],\n        )\n\n        with pytest.raises(ValueError):\n            df.plot.area(logy=True)\n        with pytest.raises(ValueError):\n            df.plot.area(loglog=True)\n\n    def _compare_stacked_y_cood(self, normal_lines, stacked_lines):\n        base = np.zeros(len(normal_lines[0].get_data()[1]))\n        for nl, sl in zip(normal_lines, stacked_lines):\n            base += nl.get_data()[1]  # get y coordinates\n            sy = sl.get_data()[1]\n            tm.assert_numpy_array_equal(base, sy)\n\n    def test_line_area_stacked(self):\n        with tm.RNGContext(42):\n            df = DataFrame(np.random.rand(6, 4), columns=[\"w\", \"x\", \"y\", \"z\"])\n            neg_df = -df\n            # each column has either positive or negative value\n            sep_df = DataFrame(\n                {\n                    \"w\": np.random.rand(6),\n                    \"x\": np.random.rand(6),\n                    \"y\": -np.random.rand(6),\n                    \"z\": -np.random.rand(6),\n                }\n            )\n            # each column has positive-negative mixed value\n            mixed_df = DataFrame(\n                np.random.randn(6, 4),\n                index=list(string.ascii_letters[:6]),\n                columns=[\"w\", \"x\", \"y\", \"z\"],\n            )\n\n            for kind in [\"line\", \"area\"]:\n                ax1 = _check_plot_works(df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines, ax2.lines)\n\n                ax1 = _check_plot_works(neg_df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(neg_df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines, ax2.lines)\n\n                ax1 = _check_plot_works(sep_df.plot, kind=kind, stacked=False)\n                ax2 = _check_plot_works(sep_df.plot, kind=kind, stacked=True)\n                self._compare_stacked_y_cood(ax1.lines[:2], ax2.lines[:2])\n                self._compare_stacked_y_cood(ax1.lines[2:], ax2.lines[2:])\n\n                _check_plot_works(mixed_df.plot, stacked=False)\n                with pytest.raises(ValueError):\n                    mixed_df.plot(stacked=True)\n\n                # Use an index with strictly positive values, preventing\n                #  matplotlib from warning about ignoring xlim\n                df2 = df.set_index(df.index + 1)\n                _check_plot_works(df2.plot, kind=kind, logx=True, stacked=True)\n\n    def test_line_area_nan_df(self):\n        values1 = [1, 2, np.nan, 3]\n        values2 = [3, np.nan, 2, 1]\n        df = DataFrame({\"a\": values1, \"b\": values2})\n        tdf = DataFrame({\"a\": values1, \"b\": values2}, index=tm.makeDateIndex(k=4))\n\n        for d in [df, tdf]:\n            ax = _check_plot_works(d.plot)\n            masked1 = ax.lines[0].get_ydata()\n            masked2 = ax.lines[1].get_ydata()\n            # remove nan for comparison purpose\n\n            exp = np.array([1, 2, 3], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked1.data, 2), exp)\n\n            exp = np.array([3, 2, 1], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked2.data, 1), exp)\n            tm.assert_numpy_array_equal(\n                masked1.mask, np.array([False, False, True, False])\n            )\n            tm.assert_numpy_array_equal(\n                masked2.mask, np.array([False, True, False, False])\n            )\n\n            expected1 = np.array([1, 2, 0, 3], dtype=np.float64)\n            expected2 = np.array([3, 0, 2, 1], dtype=np.float64)\n\n            ax = _check_plot_works(d.plot, stacked=True)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected1 + expected2)\n\n            ax = _check_plot_works(d.plot.area)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected1 + expected2)\n\n            ax = _check_plot_works(d.plot.area, stacked=False)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)\n            tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected2)\n\n    def test_line_lim(self):\n        df = DataFrame(np.random.rand(6, 3), columns=[\"x\", \"y\", \"z\"])\n        ax = df.plot()\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data()[0][0]\n        assert xmax >= lines[0].get_data()[0][-1]\n\n        ax = df.plot(secondary_y=True)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data()[0][0]\n        assert xmax >= lines[0].get_data()[0][-1]\n\n        axes = df.plot(secondary_y=True, subplots=True)\n        self._check_axes_shape(axes, axes_num=3, layout=(3, 1))\n        for ax in axes:\n            assert hasattr(ax, \"left_ax\")\n            assert not hasattr(ax, \"right_ax\")\n            xmin, xmax = ax.get_xlim()\n            lines = ax.get_lines()\n            assert xmin <= lines[0].get_data()[0][0]\n            assert xmax >= lines[0].get_data()[0][-1]\n\n    def test_area_lim(self):\n        df = DataFrame(np.random.rand(6, 4), columns=[\"x\", \"y\", \"z\", \"four\"])\n\n        neg_df = -df\n        for stacked in [True, False]:\n            ax = _check_plot_works(df.plot.area, stacked=stacked)\n            xmin, xmax = ax.get_xlim()\n            ymin, ymax = ax.get_ylim()\n            lines = ax.get_lines()\n            assert xmin <= lines[0].get_data()[0][0]\n            assert xmax >= lines[0].get_data()[0][-1]\n            assert ymin == 0\n\n            ax = _check_plot_works(neg_df.plot.area, stacked=stacked)\n            ymin, ymax = ax.get_ylim()\n            assert ymax == 0\n\n    def test_area_sharey_dont_overwrite(self):\n        # GH37942\n        df = DataFrame(np.random.rand(4, 2), columns=[\"x\", \"y\"])\n        fig, (ax1, ax2) = self.plt.subplots(1, 2, sharey=True)\n\n        df.plot(ax=ax1, kind=\"area\")\n        df.plot(ax=ax2, kind=\"area\")\n\n        assert ax1._shared_y_axes.joined(ax1, ax2)\n        assert ax2._shared_y_axes.joined(ax1, ax2)\n\n    @pytest.mark.slow\n    def test_bar_linewidth(self):\n        df = DataFrame(np.random.randn(5, 5))\n\n        # regular\n        ax = df.plot.bar(linewidth=2)\n        for r in ax.patches:\n            assert r.get_linewidth() == 2\n\n        # stacked\n        ax = df.plot.bar(stacked=True, linewidth=2)\n        for r in ax.patches:\n            assert r.get_linewidth() == 2\n\n        # subplots\n        axes = df.plot.bar(linewidth=2, subplots=True)\n        self._check_axes_shape(axes, axes_num=5, layout=(5, 1))\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_linewidth() == 2\n\n    @pytest.mark.slow\n    def test_bar_barwidth(self):\n        df = DataFrame(np.random.randn(5, 5))\n\n        width = 0.9\n\n        # regular\n        ax = df.plot.bar(width=width)\n        for r in ax.patches:\n            assert r.get_width() == width / len(df.columns)\n\n        # stacked\n        ax = df.plot.bar(stacked=True, width=width)\n        for r in ax.patches:\n            assert r.get_width() == width\n\n        # horizontal regular\n        ax = df.plot.barh(width=width)\n        for r in ax.patches:\n            assert r.get_height() == width / len(df.columns)\n\n        # horizontal stacked\n        ax = df.plot.barh(stacked=True, width=width)\n        for r in ax.patches:\n            assert r.get_height() == width\n\n        # subplots\n        axes = df.plot.bar(width=width, subplots=True)\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_width() == width\n\n        # horizontal subplots\n        axes = df.plot.barh(width=width, subplots=True)\n        for ax in axes:\n            for r in ax.patches:\n                assert r.get_height() == width\n\n    @pytest.mark.slow\n    def test_bar_bottom_left(self):\n        df = DataFrame(np.random.rand(5, 5))\n        ax = df.plot.bar(stacked=False, bottom=1)\n        result = [p.get_y() for p in ax.patches]\n        assert result == [1] * 25\n\n        ax = df.plot.bar(stacked=True, bottom=[-1, -2, -3, -4, -5])\n        result = [p.get_y() for p in ax.patches[:5]]\n        assert result == [-1, -2, -3, -4, -5]\n\n        ax = df.plot.barh(stacked=False, left=np.array([1, 1, 1, 1, 1]))\n        result = [p.get_x() for p in ax.patches]\n        assert result == [1] * 25\n\n        ax = df.plot.barh(stacked=True, left=[1, 2, 3, 4, 5])\n        result = [p.get_x() for p in ax.patches[:5]]\n        assert result == [1, 2, 3, 4, 5]\n\n        axes = df.plot.bar(subplots=True, bottom=-1)\n        for ax in axes:\n            result = [p.get_y() for p in ax.patches]\n            assert result == [-1] * 5\n\n        axes = df.plot.barh(subplots=True, left=np.array([1, 1, 1, 1, 1]))\n        for ax in axes:\n            result = [p.get_x() for p in ax.patches]\n            assert result == [1] * 5\n\n    @pytest.mark.slow\n    def test_bar_nan(self):\n        df = DataFrame({\"A\": [10, np.nan, 20], \"B\": [5, 10, 20], \"C\": [1, 2, 3]})\n        ax = df.plot.bar()\n        expected = [10, 0, 20, 5, 10, 20, 1, 2, 3]\n        result = [p.get_height() for p in ax.patches]\n        assert result == expected\n\n        ax = df.plot.bar(stacked=True)\n        result = [p.get_height() for p in ax.patches]\n        assert result == expected\n\n        result = [p.get_y() for p in ax.patches]\n        expected = [0.0, 0.0, 0.0, 10.0, 0.0, 20.0, 15.0, 10.0, 40.0]\n        assert result == expected\n\n    @pytest.mark.slow\n    def test_bar_categorical(self):\n        # GH 13019\n        df1 = DataFrame(\n            np.random.randn(6, 5),\n            index=pd.Index(list(\"ABCDEF\")),\n            columns=pd.Index(list(\"abcde\")),\n        )\n        # categorical index must behave the same\n        df2 = DataFrame(\n            np.random.randn(6, 5),\n            index=pd.CategoricalIndex(list(\"ABCDEF\")),\n            columns=pd.CategoricalIndex(list(\"abcde\")),\n        )\n\n        for df in [df1, df2]:\n            ax = df.plot.bar()\n            ticks = ax.xaxis.get_ticklocs()\n            tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))\n            assert ax.get_xlim() == (-0.5, 5.5)\n            # check left-edge of bars\n            assert ax.patches[0].get_x() == -0.25\n            assert ax.patches[-1].get_x() == 5.15\n\n            ax = df.plot.bar(stacked=True)\n            tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))\n            assert ax.get_xlim() == (-0.5, 5.5)\n            assert ax.patches[0].get_x() == -0.25\n            assert ax.patches[-1].get_x() == 4.75\n\n    @pytest.mark.slow\n    def test_plot_scatter(self):\n        df = DataFrame(\n            np.random.randn(6, 4),\n            index=list(string.ascii_letters[:6]),\n            columns=[\"x\", \"y\", \"z\", \"four\"],\n        )\n\n        _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\")\n        _check_plot_works(df.plot.scatter, x=1, y=2)\n\n        with pytest.raises(TypeError):\n            df.plot.scatter(x=\"x\")\n        with pytest.raises(TypeError):\n            df.plot.scatter(y=\"y\")\n\n        # GH 6951\n        axes = df.plot(x=\"x\", y=\"y\", kind=\"scatter\", subplots=True)\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n    def test_raise_error_on_datetime_time_data(self):\n        # GH 8113, datetime.time type is not supported by matplotlib in scatter\n        df = DataFrame(np.random.randn(10), columns=[\"a\"])\n        df[\"dtime\"] = pd.date_range(start=\"2014-01-01\", freq=\"h\", periods=10).time\n        msg = \"must be a string or a number, not 'datetime.time'\"\n\n        with pytest.raises(TypeError, match=msg):\n            df.plot(kind=\"scatter\", x=\"dtime\", y=\"a\")\n\n    def test_scatterplot_datetime_data(self):\n        # GH 30391\n        dates = pd.date_range(start=date(2019, 1, 1), periods=12, freq=\"W\")\n        vals = np.random.normal(0, 1, len(dates))\n        df = DataFrame({\"dates\": dates, \"vals\": vals})\n\n        _check_plot_works(df.plot.scatter, x=\"dates\", y=\"vals\")\n        _check_plot_works(df.plot.scatter, x=0, y=1)\n\n    def test_scatterplot_object_data(self):\n        # GH 18755\n        df = DataFrame(dict(a=[\"A\", \"B\", \"C\"], b=[2, 3, 4]))\n\n        _check_plot_works(df.plot.scatter, x=\"a\", y=\"b\")\n        _check_plot_works(df.plot.scatter, x=0, y=1)\n\n        df = DataFrame(dict(a=[\"A\", \"B\", \"C\"], b=[\"a\", \"b\", \"c\"]))\n\n        _check_plot_works(df.plot.scatter, x=\"a\", y=\"b\")\n        _check_plot_works(df.plot.scatter, x=0, y=1)\n\n    @pytest.mark.parametrize(\"x, y\", [(\"x\", \"y\"), (\"y\", \"x\"), (\"y\", \"y\")])\n    @pytest.mark.slow\n    def test_plot_scatter_with_categorical_data(self, x, y):\n        # after fixing GH 18755, should be able to plot categorical data\n        df = DataFrame({\"x\": [1, 2, 3, 4], \"y\": pd.Categorical([\"a\", \"b\", \"a\", \"c\"])})\n\n        _check_plot_works(df.plot.scatter, x=x, y=y)\n\n    @pytest.mark.slow\n    def test_plot_scatter_with_c(self):\n        df = DataFrame(\n            np.random.randn(6, 4),\n            index=list(string.ascii_letters[:6]),\n            columns=[\"x\", \"y\", \"z\", \"four\"],\n        )\n\n        axes = [df.plot.scatter(x=\"x\", y=\"y\", c=\"z\"), df.plot.scatter(x=0, y=1, c=2)]\n        for ax in axes:\n            # default to Greys\n            assert ax.collections[0].cmap.name == \"Greys\"\n\n            # n.b. there appears to be no public method\n            # to get the colorbar label\n            assert ax.collections[0].colorbar._label == \"z\"\n\n        cm = \"cubehelix\"\n        ax = df.plot.scatter(x=\"x\", y=\"y\", c=\"z\", colormap=cm)\n        assert ax.collections[0].cmap.name == cm\n\n        # verify turning off colorbar works\n        ax = df.plot.scatter(x=\"x\", y=\"y\", c=\"z\", colorbar=False)\n        assert ax.collections[0].colorbar is None\n\n        # verify that we can still plot a solid color\n        ax = df.plot.scatter(x=0, y=1, c=\"red\")\n        assert ax.collections[0].colorbar is None\n        self._check_colors(ax.collections, facecolors=[\"r\"])\n\n        # Ensure that we can pass an np.array straight through to matplotlib,\n        # this functionality was accidentally removed previously.\n        # See https://github.com/pandas-dev/pandas/issues/8852 for bug report\n        #\n        # Exercise colormap path and non-colormap path as they are independent\n        #\n        df = DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\n        red_rgba = [1.0, 0.0, 0.0, 1.0]\n        green_rgba = [0.0, 1.0, 0.0, 1.0]\n        rgba_array = np.array([red_rgba, green_rgba])\n        ax = df.plot.scatter(x=\"A\", y=\"B\", c=rgba_array)\n        # expect the face colors of the points in the non-colormap path to be\n        # identical to the values we supplied, normally we'd be on shaky ground\n        # comparing floats for equality but here we expect them to be\n        # identical.\n        tm.assert_numpy_array_equal(ax.collections[0].get_facecolor(), rgba_array)\n        # we don't test the colors of the faces in this next plot because they\n        # are dependent on the spring colormap, which may change its colors\n        # later.\n        float_array = np.array([0.0, 1.0])\n        df.plot.scatter(x=\"A\", y=\"B\", c=float_array, cmap=\"spring\")\n\n    def test_plot_scatter_with_s(self):\n        # this refers to GH 32904\n        df = DataFrame(np.random.random((10, 3)) * 100, columns=[\"a\", \"b\", \"c\"])\n\n        ax = df.plot.scatter(x=\"a\", y=\"b\", s=\"c\")\n        tm.assert_numpy_array_equal(df[\"c\"].values, right=ax.collections[0].get_sizes())\n\n    @pytest.mark.slow\n    def test_plot_bar(self):\n        df = DataFrame(\n            np.random.randn(6, 4),\n            index=list(string.ascii_letters[:6]),\n            columns=[\"one\", \"two\", \"three\", \"four\"],\n        )\n\n        _check_plot_works(df.plot.bar)\n        _check_plot_works(df.plot.bar, legend=False)\n        _check_plot_works(df.plot.bar, default_axes=True, subplots=True)\n        _check_plot_works(df.plot.bar, stacked=True)\n\n        df = DataFrame(\n            np.random.randn(10, 15),\n            index=list(string.ascii_letters[:10]),\n            columns=range(15),\n        )\n        _check_plot_works(df.plot.bar)\n\n        df = DataFrame({\"a\": [0, 1], \"b\": [1, 0]})\n        ax = _check_plot_works(df.plot.bar)\n        self._check_ticks_props(ax, xrot=90)\n\n        ax = df.plot.bar(rot=35, fontsize=10)\n        self._check_ticks_props(ax, xrot=35, xlabelsize=10, ylabelsize=10)\n\n        ax = _check_plot_works(df.plot.barh)\n        self._check_ticks_props(ax, yrot=0)\n\n        ax = df.plot.barh(rot=55, fontsize=11)\n        self._check_ticks_props(ax, yrot=55, ylabelsize=11, xlabelsize=11)\n\n    @pytest.mark.slow\n    def test_boxplot(self):\n        df = self.hist_df\n        series = df[\"height\"]\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n\n        ax = _check_plot_works(df.plot.box)\n        self._check_text_labels(ax.get_xticklabels(), labels)\n        tm.assert_numpy_array_equal(\n            ax.xaxis.get_ticklocs(), np.arange(1, len(numeric_cols) + 1)\n        )\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n        tm.close()\n\n        axes = series.plot.box(rot=40)\n        self._check_ticks_props(axes, xrot=40, yrot=0)\n        tm.close()\n\n        ax = _check_plot_works(series.plot.box)\n\n        positions = np.array([1, 6, 7])\n        ax = df.plot.box(positions=positions)\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n        self._check_text_labels(ax.get_xticklabels(), labels)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), positions)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n    @pytest.mark.slow\n    def test_boxplot_vertical(self):\n        df = self.hist_df\n        numeric_cols = df._get_numeric_data().columns\n        labels = [pprint_thing(c) for c in numeric_cols]\n\n        # if horizontal, yticklabels are rotated\n        ax = df.plot.box(rot=50, fontsize=8, vert=False)\n        self._check_ticks_props(ax, xrot=0, yrot=50, ylabelsize=8)\n        self._check_text_labels(ax.get_yticklabels(), labels)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n        axes = _check_plot_works(\n            df.plot.box,\n            default_axes=True,\n            subplots=True,\n            vert=False,\n            logx=True,\n        )\n        self._check_axes_shape(axes, axes_num=3, layout=(1, 3))\n        self._check_ax_scales(axes, xaxis=\"log\")\n        for ax, label in zip(axes, labels):\n            self._check_text_labels(ax.get_yticklabels(), [label])\n            assert len(ax.lines) == self.bp_n_objects\n\n        positions = np.array([3, 2, 8])\n        ax = df.plot.box(positions=positions, vert=False)\n        self._check_text_labels(ax.get_yticklabels(), labels)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), positions)\n        assert len(ax.lines) == self.bp_n_objects * len(numeric_cols)\n\n    @pytest.mark.slow\n    def test_boxplot_return_type(self):\n        df = DataFrame(\n            np.random.randn(6, 4),\n            index=list(string.ascii_letters[:6]),\n            columns=[\"one\", \"two\", \"three\", \"four\"],\n        )\n        with pytest.raises(ValueError):\n            df.plot.box(return_type=\"NOTATYPE\")\n\n        result = df.plot.box(return_type=\"dict\")\n        self._check_box_return_type(result, \"dict\")\n\n        result = df.plot.box(return_type=\"axes\")\n        self._check_box_return_type(result, \"axes\")\n\n        result = df.plot.box()  # default axes\n        self._check_box_return_type(result, \"axes\")\n\n        result = df.plot.box(return_type=\"both\")\n        self._check_box_return_type(result, \"both\")\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_df(self):\n        df = DataFrame(np.random.randn(100, 4))\n        ax = _check_plot_works(df.plot, kind=\"kde\")\n        expected = [pprint_thing(c) for c in df.columns]\n        self._check_legend_labels(ax, labels=expected)\n        self._check_ticks_props(ax, xrot=0)\n\n        ax = df.plot(kind=\"kde\", rot=20, fontsize=5)\n        self._check_ticks_props(ax, xrot=20, xlabelsize=5, ylabelsize=5)\n\n        axes = _check_plot_works(\n            df.plot,\n            default_axes=True,\n            kind=\"kde\",\n            subplots=True,\n        )\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        axes = df.plot(kind=\"kde\", logy=True, subplots=True)\n        self._check_ax_scales(axes, yaxis=\"log\")\n\n    @pytest.mark.slow\n    @td.skip_if_no_scipy\n    def test_kde_missing_vals(self):\n        df = DataFrame(np.random.uniform(size=(100, 4)))\n        df.loc[0, 0] = np.nan\n        _check_plot_works(df.plot, kind=\"kde\")\n\n    @pytest.mark.slow\n    def test_hist_df(self):\n        from matplotlib.patches import Rectangle\n\n        df = DataFrame(np.random.randn(100, 4))\n        series = df[0]\n\n        ax = _check_plot_works(df.plot.hist)\n        expected = [pprint_thing(c) for c in df.columns]\n        self._check_legend_labels(ax, labels=expected)\n\n        axes = _check_plot_works(\n            df.plot.hist,\n            default_axes=True,\n            subplots=True,\n            logy=True,\n        )\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n        self._check_ax_scales(axes, yaxis=\"log\")\n\n        axes = series.plot.hist(rot=40)\n        self._check_ticks_props(axes, xrot=40, yrot=0)\n        tm.close()\n\n        ax = series.plot.hist(cumulative=True, bins=4, density=True)\n        # height of last bin (index 5) must be 1.0\n        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]\n        tm.assert_almost_equal(rects[-1].get_height(), 1.0)\n        tm.close()\n\n        ax = series.plot.hist(cumulative=True, bins=4)\n        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]\n\n        tm.assert_almost_equal(rects[-2].get_height(), 100.0)\n        tm.close()\n\n        # if horizontal, yticklabels are rotated\n        axes = df.plot.hist(rot=50, fontsize=8, orientation=\"horizontal\")\n        self._check_ticks_props(axes, xrot=0, yrot=50, ylabelsize=8)\n\n    @pytest.mark.parametrize(\n        \"weights\", [0.1 * np.ones(shape=(100,)), 0.1 * np.ones(shape=(100, 2))]\n    )\n    def test_hist_weights(self, weights):\n        # GH 33173\n        np.random.seed(0)\n        df = DataFrame(dict(zip([\"A\", \"B\"], np.random.randn(2, 100))))\n\n        ax1 = _check_plot_works(df.plot, kind=\"hist\", weights=weights)\n        ax2 = _check_plot_works(df.plot, kind=\"hist\")\n\n        patch_height_with_weights = [patch.get_height() for patch in ax1.patches]\n\n        # original heights with no weights, and we manually multiply with example\n        # weights, so after multiplication, they should be almost same\n        expected_patch_height = [0.1 * patch.get_height() for patch in ax2.patches]\n\n        tm.assert_almost_equal(patch_height_with_weights, expected_patch_height)\n\n    def _check_box_coord(\n        self,\n        patches,\n        expected_y=None,\n        expected_h=None,\n        expected_x=None,\n        expected_w=None,\n    ):\n        result_y = np.array([p.get_y() for p in patches])\n        result_height = np.array([p.get_height() for p in patches])\n        result_x = np.array([p.get_x() for p in patches])\n        result_width = np.array([p.get_width() for p in patches])\n        # dtype is depending on above values, no need to check\n\n        if expected_y is not None:\n            tm.assert_numpy_array_equal(result_y, expected_y, check_dtype=False)\n        if expected_h is not None:\n            tm.assert_numpy_array_equal(result_height, expected_h, check_dtype=False)\n        if expected_x is not None:\n            tm.assert_numpy_array_equal(result_x, expected_x, check_dtype=False)\n        if expected_w is not None:\n            tm.assert_numpy_array_equal(result_width, expected_w, check_dtype=False)\n\n    @pytest.mark.slow\n    def test_hist_df_coord(self):\n        normal_df = DataFrame(\n            {\n                \"A\": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([10, 9, 8, 7, 6])),\n                \"B\": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([8, 8, 8, 8, 8])),\n                \"C\": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([6, 7, 8, 9, 10])),\n            },\n            columns=[\"A\", \"B\", \"C\"],\n        )\n\n        nan_df = DataFrame(\n            {\n                \"A\": np.repeat(\n                    np.array([np.nan, 1, 2, 3, 4, 5]), np.array([3, 10, 9, 8, 7, 6])\n                ),\n                \"B\": np.repeat(\n                    np.array([1, np.nan, 2, 3, 4, 5]), np.array([8, 3, 8, 8, 8, 8])\n                ),\n                \"C\": np.repeat(\n                    np.array([1, 2, 3, np.nan, 4, 5]), np.array([6, 7, 8, 3, 9, 10])\n                ),\n            },\n            columns=[\"A\", \"B\", \"C\"],\n        )\n\n        for df in [normal_df, nan_df]:\n            ax = df.plot.hist(bins=5)\n            self._check_box_coord(\n                ax.patches[:5],\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                ax.patches[5:10],\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                ax.patches[10:],\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([6, 7, 8, 9, 10]),\n            )\n\n            ax = df.plot.hist(bins=5, stacked=True)\n            self._check_box_coord(\n                ax.patches[:5],\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                ax.patches[5:10],\n                expected_y=np.array([10, 9, 8, 7, 6]),\n                expected_h=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                ax.patches[10:],\n                expected_y=np.array([18, 17, 16, 15, 14]),\n                expected_h=np.array([6, 7, 8, 9, 10]),\n            )\n\n            axes = df.plot.hist(bins=5, stacked=True, subplots=True)\n            self._check_box_coord(\n                axes[0].patches,\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                axes[1].patches,\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                axes[2].patches,\n                expected_y=np.array([0, 0, 0, 0, 0]),\n                expected_h=np.array([6, 7, 8, 9, 10]),\n            )\n\n            # horizontal\n            ax = df.plot.hist(bins=5, orientation=\"horizontal\")\n            self._check_box_coord(\n                ax.patches[:5],\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                ax.patches[5:10],\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                ax.patches[10:],\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([6, 7, 8, 9, 10]),\n            )\n\n            ax = df.plot.hist(bins=5, stacked=True, orientation=\"horizontal\")\n            self._check_box_coord(\n                ax.patches[:5],\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                ax.patches[5:10],\n                expected_x=np.array([10, 9, 8, 7, 6]),\n                expected_w=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                ax.patches[10:],\n                expected_x=np.array([18, 17, 16, 15, 14]),\n                expected_w=np.array([6, 7, 8, 9, 10]),\n            )\n\n            axes = df.plot.hist(\n                bins=5, stacked=True, subplots=True, orientation=\"horizontal\"\n            )\n            self._check_box_coord(\n                axes[0].patches,\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([10, 9, 8, 7, 6]),\n            )\n            self._check_box_coord(\n                axes[1].patches,\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([8, 8, 8, 8, 8]),\n            )\n            self._check_box_coord(\n                axes[2].patches,\n                expected_x=np.array([0, 0, 0, 0, 0]),\n                expected_w=np.array([6, 7, 8, 9, 10]),\n            )\n\n    @pytest.mark.slow\n    def test_plot_int_columns(self):\n        df = DataFrame(np.random.randn(100, 4)).cumsum()\n        _check_plot_works(df.plot, legend=True)\n\n    @pytest.mark.slow\n    def test_df_legend_labels(self):\n        kinds = [\"line\", \"bar\", \"barh\", \"kde\", \"area\", \"hist\"]\n        df = DataFrame(np.random.rand(3, 3), columns=[\"a\", \"b\", \"c\"])\n        df2 = DataFrame(np.random.rand(3, 3), columns=[\"d\", \"e\", \"f\"])\n        df3 = DataFrame(np.random.rand(3, 3), columns=[\"g\", \"h\", \"i\"])\n        df4 = DataFrame(np.random.rand(3, 3), columns=[\"j\", \"k\", \"l\"])\n\n        for kind in kinds:\n\n            ax = df.plot(kind=kind, legend=True)\n            self._check_legend_labels(ax, labels=df.columns)\n\n            ax = df2.plot(kind=kind, legend=False, ax=ax)\n            self._check_legend_labels(ax, labels=df.columns)\n\n            ax = df3.plot(kind=kind, legend=True, ax=ax)\n            self._check_legend_labels(ax, labels=df.columns.union(df3.columns))\n\n            ax = df4.plot(kind=kind, legend=\"reverse\", ax=ax)\n            expected = list(df.columns.union(df3.columns)) + list(reversed(df4.columns))\n            self._check_legend_labels(ax, labels=expected)\n\n        # Secondary Y\n        ax = df.plot(legend=True, secondary_y=\"b\")\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\", \"c\"])\n        ax = df2.plot(legend=False, ax=ax)\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\", \"c\"])\n        ax = df3.plot(kind=\"bar\", legend=True, secondary_y=\"h\", ax=ax)\n        self._check_legend_labels(\n            ax, labels=[\"a\", \"b (right)\", \"c\", \"g\", \"h (right)\", \"i\"]\n        )\n\n        # Time Series\n        ind = date_range(\"1/1/2014\", periods=3)\n        df = DataFrame(np.random.randn(3, 3), columns=[\"a\", \"b\", \"c\"], index=ind)\n        df2 = DataFrame(np.random.randn(3, 3), columns=[\"d\", \"e\", \"f\"], index=ind)\n        df3 = DataFrame(np.random.randn(3, 3), columns=[\"g\", \"h\", \"i\"], index=ind)\n        ax = df.plot(legend=True, secondary_y=\"b\")\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\", \"c\"])\n        ax = df2.plot(legend=False, ax=ax)\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\", \"c\"])\n        ax = df3.plot(legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\", \"c\", \"g\", \"h\", \"i\"])\n\n        # scatter\n        ax = df.plot.scatter(x=\"a\", y=\"b\", label=\"data1\")\n        self._check_legend_labels(ax, labels=[\"data1\"])\n        ax = df2.plot.scatter(x=\"d\", y=\"e\", legend=False, label=\"data2\", ax=ax)\n        self._check_legend_labels(ax, labels=[\"data1\"])\n        ax = df3.plot.scatter(x=\"g\", y=\"h\", label=\"data3\", ax=ax)\n        self._check_legend_labels(ax, labels=[\"data1\", \"data3\"])\n\n        # ensure label args pass through and\n        # index name does not mutate\n        # column names don't mutate\n        df5 = df.set_index(\"a\")\n        ax = df5.plot(y=\"b\")\n        self._check_legend_labels(ax, labels=[\"b\"])\n        ax = df5.plot(y=\"b\", label=\"LABEL_b\")\n        self._check_legend_labels(ax, labels=[\"LABEL_b\"])\n        self._check_text_labels(ax.xaxis.get_label(), \"a\")\n        ax = df5.plot(y=\"c\", label=\"LABEL_c\", ax=ax)\n        self._check_legend_labels(ax, labels=[\"LABEL_b\", \"LABEL_c\"])\n        assert df5.columns.tolist() == [\"b\", \"c\"]\n\n    def test_missing_marker_multi_plots_on_same_ax(self):\n        # GH 18222\n        df = DataFrame(data=[[1, 1, 1, 1], [2, 2, 4, 8]], columns=[\"x\", \"r\", \"g\", \"b\"])\n        fig, ax = self.plt.subplots(nrows=1, ncols=3)\n        # Left plot\n        df.plot(x=\"x\", y=\"r\", linewidth=0, marker=\"o\", color=\"r\", ax=ax[0])\n        df.plot(x=\"x\", y=\"g\", linewidth=1, marker=\"x\", color=\"g\", ax=ax[0])\n        df.plot(x=\"x\", y=\"b\", linewidth=1, marker=\"o\", color=\"b\", ax=ax[0])\n        self._check_legend_labels(ax[0], labels=[\"r\", \"g\", \"b\"])\n        self._check_legend_marker(ax[0], expected_markers=[\"o\", \"x\", \"o\"])\n        # Center plot\n        df.plot(x=\"x\", y=\"b\", linewidth=1, marker=\"o\", color=\"b\", ax=ax[1])\n        df.plot(x=\"x\", y=\"r\", linewidth=0, marker=\"o\", color=\"r\", ax=ax[1])\n        df.plot(x=\"x\", y=\"g\", linewidth=1, marker=\"x\", color=\"g\", ax=ax[1])\n        self._check_legend_labels(ax[1], labels=[\"b\", \"r\", \"g\"])\n        self._check_legend_marker(ax[1], expected_markers=[\"o\", \"o\", \"x\"])\n        # Right plot\n        df.plot(x=\"x\", y=\"g\", linewidth=1, marker=\"x\", color=\"g\", ax=ax[2])\n        df.plot(x=\"x\", y=\"b\", linewidth=1, marker=\"o\", color=\"b\", ax=ax[2])\n        df.plot(x=\"x\", y=\"r\", linewidth=0, marker=\"o\", color=\"r\", ax=ax[2])\n        self._check_legend_labels(ax[2], labels=[\"g\", \"b\", \"r\"])\n        self._check_legend_marker(ax[2], expected_markers=[\"x\", \"o\", \"o\"])\n\n    def test_legend_name(self):\n        multi = DataFrame(\n            np.random.randn(4, 4),\n            columns=[np.array([\"a\", \"a\", \"b\", \"b\"]), np.array([\"x\", \"y\", \"x\", \"y\"])],\n        )\n        multi.columns.names = [\"group\", \"individual\"]\n\n        ax = multi.plot()\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, \"group,individual\")\n\n        df = DataFrame(np.random.randn(5, 5))\n        ax = df.plot(legend=True, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, \"group,individual\")\n\n        df.columns.name = \"new\"\n        ax = df.plot(legend=False, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, \"group,individual\")\n\n        ax = df.plot(legend=True, ax=ax)\n        leg_title = ax.legend_.get_title()\n        self._check_text_labels(leg_title, \"new\")\n\n    @pytest.mark.slow\n    def test_no_legend(self):\n        kinds = [\"line\", \"bar\", \"barh\", \"kde\", \"area\", \"hist\"]\n        df = DataFrame(np.random.rand(3, 3), columns=[\"a\", \"b\", \"c\"])\n\n        for kind in kinds:\n            ax = df.plot(kind=kind, legend=False)\n            self._check_legend_labels(ax, visible=False)\n\n    @pytest.mark.slow\n    def test_style_by_column(self):\n        import matplotlib.pyplot as plt\n\n        fig = plt.gcf()\n\n        df = DataFrame(np.random.randn(100, 3))\n        for markers in [\n            {0: \"^\", 1: \"+\", 2: \"o\"},\n            {0: \"^\", 1: \"+\"},\n            [\"^\", \"+\", \"o\"],\n            [\"^\", \"+\"],\n        ]:\n            fig.clf()\n            fig.add_subplot(111)\n            ax = df.plot(style=markers)\n            for idx, line in enumerate(ax.get_lines()[: len(markers)]):\n                assert line.get_marker() == markers[idx]\n\n    @pytest.mark.slow\n    def test_line_label_none(self):\n        s = Series([1, 2])\n        ax = s.plot()\n        assert ax.get_legend() is None\n\n        ax = s.plot(legend=True)\n        assert ax.get_legend().get_texts()[0].get_text() == \"None\"\n\n    @pytest.mark.parametrize(\n        \"props, expected\",\n        [\n            (\"boxprops\", \"boxes\"),\n            (\"whiskerprops\", \"whiskers\"),\n            (\"capprops\", \"caps\"),\n            (\"medianprops\", \"medians\"),\n        ],\n    )\n    def test_specified_props_kwd_plot_box(self, props, expected):\n        # GH 30346\n        df = DataFrame({k: np.random.random(100) for k in \"ABC\"})\n        kwd = {props: dict(color=\"C1\")}\n        result = df.plot.box(return_type=\"dict\", **kwd)\n\n        assert result[expected][0].get_color() == \"C1\"\n\n    def test_unordered_ts(self):\n        df = DataFrame(\n            np.array([3.0, 2.0, 1.0]),\n            index=[date(2012, 10, 1), date(2012, 9, 1), date(2012, 8, 1)],\n            columns=[\"test\"],\n        )\n        ax = df.plot()\n        xticks = ax.lines[0].get_xdata()\n        assert xticks[0] < xticks[1]\n        ydata = ax.lines[0].get_ydata()\n        tm.assert_numpy_array_equal(ydata, np.array([1.0, 2.0, 3.0]))\n\n    @td.skip_if_no_scipy\n    def test_kind_both_ways(self):\n        df = DataFrame({\"x\": [1, 2, 3]})\n        for kind in plotting.PlotAccessor._common_kinds:\n\n            df.plot(kind=kind)\n            getattr(df.plot, kind)()\n        for kind in [\"scatter\", \"hexbin\"]:\n            df.plot(\"x\", \"x\", kind=kind)\n            getattr(df.plot, kind)(\"x\", \"x\")\n\n    def test_all_invalid_plot_data(self):\n        df = DataFrame(list(\"abcd\"))\n        for kind in plotting.PlotAccessor._common_kinds:\n\n            msg = \"no numeric data to plot\"\n            with pytest.raises(TypeError, match=msg):\n                df.plot(kind=kind)\n\n    @pytest.mark.slow\n    def test_partially_invalid_plot_data(self):\n        with tm.RNGContext(42):\n            df = DataFrame(np.random.randn(10, 2), dtype=object)\n            df[np.random.rand(df.shape[0]) > 0.5] = \"a\"\n            for kind in plotting.PlotAccessor._common_kinds:\n\n                msg = \"no numeric data to plot\"\n                with pytest.raises(TypeError, match=msg):\n                    df.plot(kind=kind)\n\n        with tm.RNGContext(42):\n            # area plot doesn't support positive/negative mixed data\n            kinds = [\"area\"]\n            df = DataFrame(np.random.rand(10, 2), dtype=object)\n            df[np.random.rand(df.shape[0]) > 0.5] = \"a\"\n            for kind in kinds:\n                with pytest.raises(TypeError):\n                    df.plot(kind=kind)\n\n    def test_invalid_kind(self):\n        df = DataFrame(np.random.randn(10, 2))\n        with pytest.raises(ValueError):\n            df.plot(kind=\"aasdf\")\n\n    @pytest.mark.parametrize(\n        \"x,y,lbl\",\n        [\n            ([\"B\", \"C\"], \"A\", \"a\"),\n            ([\"A\"], [\"B\", \"C\"], [\"b\", \"c\"]),\n            (\"A\", [\"B\", \"C\"], \"badlabel\"),\n        ],\n    )\n    def test_invalid_xy_args(self, x, y, lbl):\n        # GH 18671, 19699 allows y to be list-like but not x\n        df = DataFrame({\"A\": [1, 2], \"B\": [3, 4], \"C\": [5, 6]})\n        with pytest.raises(ValueError):\n            df.plot(x=x, y=y, label=lbl)\n\n    @pytest.mark.parametrize(\"x,y\", [(\"A\", \"B\"), ([\"A\"], \"B\")])\n    def test_invalid_xy_args_dup_cols(self, x, y):\n        # GH 18671, 19699 allows y to be list-like but not x\n        df = DataFrame([[1, 3, 5], [2, 4, 6]], columns=list(\"AAB\"))\n        with pytest.raises(ValueError):\n            df.plot(x=x, y=y)\n\n    @pytest.mark.parametrize(\n        \"x,y,lbl,colors\",\n        [\n            (\"A\", [\"B\"], [\"b\"], [\"red\"]),\n            (\"A\", [\"B\", \"C\"], [\"b\", \"c\"], [\"red\", \"blue\"]),\n            (0, [1, 2], [\"bokeh\", \"cython\"], [\"green\", \"yellow\"]),\n        ],\n    )\n    def test_y_listlike(self, x, y, lbl, colors):\n        # GH 19699: tests list-like y and verifies lbls & colors\n        df = DataFrame({\"A\": [1, 2], \"B\": [3, 4], \"C\": [5, 6]})\n        _check_plot_works(df.plot, x=\"A\", y=y, label=lbl)\n\n        ax = df.plot(x=x, y=y, label=lbl, color=colors)\n        assert len(ax.lines) == len(y)\n        self._check_colors(ax.get_lines(), linecolors=colors)\n\n    @pytest.mark.parametrize(\"x,y,colnames\", [(0, 1, [\"A\", \"B\"]), (1, 0, [0, 1])])\n    def test_xy_args_integer(self, x, y, colnames):\n        # GH 20056: tests integer args for xy and checks col names\n        df = DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\n        df.columns = colnames\n        _check_plot_works(df.plot, x=x, y=y)\n\n    @pytest.mark.slow\n    def test_hexbin_basic(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x=\"A\", y=\"B\", gridsize=10)\n        # TODO: need better way to test. This just does existence.\n        assert len(ax.collections) == 1\n\n        # GH 6951\n        axes = df.plot.hexbin(x=\"A\", y=\"B\", subplots=True)\n        # hexbin should have 2 axes in the figure, 1 for plotting and another\n        # is colorbar\n        assert len(axes[0].figure.axes) == 2\n        # return value is single axes\n        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))\n\n    @pytest.mark.slow\n    def test_hexbin_with_c(self):\n        df = self.hexbin_df\n\n        ax = df.plot.hexbin(x=\"A\", y=\"B\", C=\"C\")\n        assert len(ax.collections) == 1\n\n        ax = df.plot.hexbin(x=\"A\", y=\"B\", C=\"C\", reduce_C_function=np.std)\n        assert len(ax.collections) == 1\n\n    @pytest.mark.slow\n    @pytest.mark.parametrize(\n        \"kwargs, expected\",\n        [\n            ({}, \"BuGn\"),  # default cmap\n            ({\"colormap\": \"cubehelix\"}, \"cubehelix\"),\n            ({\"cmap\": \"YlGn\"}, \"YlGn\"),\n        ],\n    )\n    def test_hexbin_cmap(self, kwargs, expected):\n        df = self.hexbin_df\n        ax = df.plot.hexbin(x=\"A\", y=\"B\", **kwargs)\n        assert ax.collections[0].cmap.name == expected\n\n    @pytest.mark.slow\n    def test_pie_df(self):\n        df = DataFrame(\n            np.random.rand(5, 3),\n            columns=[\"X\", \"Y\", \"Z\"],\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n        )\n        with pytest.raises(ValueError):\n            df.plot.pie()\n\n        ax = _check_plot_works(df.plot.pie, y=\"Y\")\n        self._check_text_labels(ax.texts, df.index)\n\n        ax = _check_plot_works(df.plot.pie, y=2)\n        self._check_text_labels(ax.texts, df.index)\n\n        axes = _check_plot_works(\n            df.plot.pie,\n            default_axes=True,\n            subplots=True,\n        )\n        assert len(axes) == len(df.columns)\n        for ax in axes:\n            self._check_text_labels(ax.texts, df.index)\n        for ax, ylabel in zip(axes, df.columns):\n            assert ax.get_ylabel() == ylabel\n\n        labels = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n        color_args = [\"r\", \"g\", \"b\", \"c\", \"m\"]\n        axes = _check_plot_works(\n            df.plot.pie,\n            default_axes=True,\n            subplots=True,\n            labels=labels,\n            colors=color_args,\n        )\n        assert len(axes) == len(df.columns)\n\n        for ax in axes:\n            self._check_text_labels(ax.texts, labels)\n            self._check_colors(ax.patches, facecolors=color_args)\n\n    def test_pie_df_nan(self):\n        import matplotlib as mpl\n\n        df = DataFrame(np.random.rand(4, 4))\n        for i in range(4):\n            df.iloc[i, i] = np.nan\n        fig, axes = self.plt.subplots(ncols=4)\n\n        # GH 37668\n        kwargs = {}\n        if mpl.__version__ >= \"3.3\":\n            kwargs = {\"normalize\": True}\n\n        with tm.assert_produces_warning(None):\n            df.plot.pie(subplots=True, ax=axes, legend=True, **kwargs)\n\n        base_expected = [\"0\", \"1\", \"2\", \"3\"]\n        for i, ax in enumerate(axes):\n            expected = list(base_expected)  # force copy\n            expected[i] = \"\"\n            result = [x.get_text() for x in ax.texts]\n            assert result == expected\n\n            # legend labels\n            # NaN's not included in legend with subplots\n            # see https://github.com/pandas-dev/pandas/issues/8390\n            result_labels = [x.get_text() for x in ax.get_legend().get_texts()]\n            expected_labels = base_expected[:i] + base_expected[i + 1 :]\n            assert result_labels == expected_labels\n\n    @pytest.mark.slow\n    def test_errorbar_plot(self):\n        d = {\"x\": np.arange(12), \"y\": np.arange(12, 0, -1)}\n        df = DataFrame(d)\n        d_err = {\"x\": np.ones(12) * 0.2, \"y\": np.ones(12) * 0.4}\n        df_err = DataFrame(d_err)\n\n        # check line plots\n        ax = _check_plot_works(df.plot, yerr=df_err, logy=True)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(df.plot, yerr=df_err, logx=True, logy=True)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(df.plot, yerr=df_err, loglog=True)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(\n            (df + 1).plot, yerr=df_err, xerr=df_err, kind=\"bar\", log=True\n        )\n        self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n        # yerr is raw error values\n        ax = _check_plot_works(df[\"y\"].plot, yerr=np.ones(12) * 0.4)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        ax = _check_plot_works(df.plot, yerr=np.ones((2, 12)) * 0.4)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        # yerr is column name\n        for yerr in [\"yerr\", \"èª¤å·®\"]:\n            s_df = df.copy()\n            s_df[yerr] = np.ones(12) * 0.2\n\n            ax = _check_plot_works(s_df.plot, yerr=yerr)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n            ax = _check_plot_works(s_df.plot, y=\"y\", x=\"x\", yerr=yerr)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        with pytest.raises(ValueError):\n            df.plot(yerr=np.random.randn(11))\n\n        df_err = DataFrame({\"x\": [\"zzz\"] * 12, \"y\": [\"zzz\"] * 12})\n        with pytest.raises((ValueError, TypeError)):\n            df.plot(yerr=df_err)\n\n    @pytest.mark.slow\n    @pytest.mark.parametrize(\"kind\", [\"line\", \"bar\", \"barh\"])\n    def test_errorbar_plot_different_kinds(self, kind):\n        d = {\"x\": np.arange(12), \"y\": np.arange(12, 0, -1)}\n        df = DataFrame(d)\n        d_err = {\"x\": np.ones(12) * 0.2, \"y\": np.ones(12) * 0.4}\n        df_err = DataFrame(d_err)\n\n        ax = _check_plot_works(df.plot, yerr=df_err[\"x\"], kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(df.plot, yerr=d_err, kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(df.plot, yerr=df_err, xerr=df_err, kind=kind)\n        self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n        ax = _check_plot_works(df.plot, yerr=df_err[\"x\"], xerr=df_err[\"x\"], kind=kind)\n        self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n        ax = _check_plot_works(df.plot, xerr=0.2, yerr=0.2, kind=kind)\n        self._check_has_errorbars(ax, xerr=2, yerr=2)\n\n        axes = _check_plot_works(\n            df.plot,\n            default_axes=True,\n            yerr=df_err,\n            xerr=df_err,\n            subplots=True,\n            kind=kind,\n        )\n        self._check_has_errorbars(axes, xerr=1, yerr=1)\n\n    @pytest.mark.xfail(reason=\"Iterator is consumed\", raises=ValueError)\n    @pytest.mark.slow\n    def test_errorbar_plot_iterator(self):\n        with warnings.catch_warnings():\n            d = {\"x\": np.arange(12), \"y\": np.arange(12, 0, -1)}\n            df = DataFrame(d)\n\n            # yerr is iterator\n            ax = _check_plot_works(df.plot, yerr=itertools.repeat(0.1, len(df)))\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n    @pytest.mark.slow\n    def test_errorbar_with_integer_column_names(self):\n        # test with integer column names\n        df = DataFrame(np.random.randn(10, 2))\n        df_err = DataFrame(np.random.randn(10, 2))\n        ax = _check_plot_works(df.plot, yerr=df_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n        ax = _check_plot_works(df.plot, y=0, yerr=1)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n    @pytest.mark.slow\n    def test_errorbar_with_partial_columns(self):\n        df = DataFrame(np.random.randn(10, 3))\n        df_err = DataFrame(np.random.randn(10, 2), columns=[0, 2])\n        kinds = [\"line\", \"bar\"]\n        for kind in kinds:\n            ax = _check_plot_works(df.plot, yerr=df_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ix = date_range(\"1/1/2000\", periods=10, freq=\"M\")\n        df.set_index(ix, inplace=True)\n        df_err.set_index(ix, inplace=True)\n        ax = _check_plot_works(df.plot, yerr=df_err, kind=\"line\")\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        d = {\"x\": np.arange(12), \"y\": np.arange(12, 0, -1)}\n        df = DataFrame(d)\n        d_err = {\"x\": np.ones(12) * 0.2, \"z\": np.ones(12) * 0.4}\n        df_err = DataFrame(d_err)\n        for err in [d_err, df_err]:\n            ax = _check_plot_works(df.plot, yerr=err)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n    @pytest.mark.slow\n    @pytest.mark.parametrize(\"kind\", [\"line\", \"bar\", \"barh\"])\n    def test_errorbar_timeseries(self, kind):\n        d = {\"x\": np.arange(12), \"y\": np.arange(12, 0, -1)}\n        d_err = {\"x\": np.ones(12) * 0.2, \"y\": np.ones(12) * 0.4}\n\n        # check time-series plots\n        ix = date_range(\"1/1/2000\", \"1/1/2001\", freq=\"M\")\n        tdf = DataFrame(d, index=ix)\n        tdf_err = DataFrame(d_err, index=ix)\n\n        ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(tdf.plot, yerr=d_err, kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        ax = _check_plot_works(tdf.plot, y=\"y\", yerr=tdf_err[\"x\"], kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        ax = _check_plot_works(tdf.plot, y=\"y\", yerr=\"x\", kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)\n        self._check_has_errorbars(ax, xerr=0, yerr=2)\n\n        axes = _check_plot_works(\n            tdf.plot,\n            default_axes=True,\n            kind=kind,\n            yerr=tdf_err,\n            subplots=True,\n        )\n        self._check_has_errorbars(axes, xerr=0, yerr=1)\n\n    def test_errorbar_asymmetrical(self):\n        np.random.seed(0)\n        err = np.random.rand(3, 2, 5)\n\n        # each column is [0, 1, 2, 3, 4], [3, 4, 5, 6, 7]...\n        df = DataFrame(np.arange(15).reshape(3, 5)).T\n\n        ax = df.plot(yerr=err, xerr=err / 2)\n\n        yerr_0_0 = ax.collections[1].get_paths()[0].vertices[:, 1]\n        expected_0_0 = err[0, :, 0] * np.array([-1, 1])\n        tm.assert_almost_equal(yerr_0_0, expected_0_0)\n\n        with pytest.raises(ValueError):\n            df.plot(yerr=err.T)\n\n        tm.close()\n\n    def test_table(self):\n        df = DataFrame(np.random.rand(10, 3), index=list(string.ascii_letters[:10]))\n        _check_plot_works(df.plot, table=True)\n        _check_plot_works(df.plot, table=df)\n\n        # GH 35945 UserWarning\n        with tm.assert_produces_warning(None):\n            ax = df.plot()\n            assert len(ax.tables) == 0\n            plotting.table(ax, df.T)\n            assert len(ax.tables) == 1\n\n    def test_errorbar_scatter(self):\n        df = DataFrame(np.random.randn(5, 2), index=range(5), columns=[\"x\", \"y\"])\n        df_err = DataFrame(\n            np.random.randn(5, 2) / 5, index=range(5), columns=[\"x\", \"y\"]\n        )\n\n        ax = _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\")\n        self._check_has_errorbars(ax, xerr=0, yerr=0)\n        ax = _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\", xerr=df_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=0)\n\n        ax = _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\", yerr=df_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        ax = _check_plot_works(df.plot.scatter, x=\"x\", y=\"y\", xerr=df_err, yerr=df_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=1)\n\n        def _check_errorbar_color(containers, expected, has_err=\"has_xerr\"):\n            lines = []\n            errs = [c.lines for c in ax.containers if getattr(c, has_err, False)][0]\n            for el in errs:\n                if is_list_like(el):\n                    lines.extend(el)\n                else:\n                    lines.append(el)\n            err_lines = [x for x in lines if x in ax.collections]\n            self._check_colors(\n                err_lines, linecolors=np.array([expected] * len(err_lines))\n            )\n\n        # GH 8081\n        df = DataFrame(np.random.randn(10, 5), columns=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n        ax = df.plot.scatter(x=\"a\", y=\"b\", xerr=\"d\", yerr=\"e\", c=\"red\")\n        self._check_has_errorbars(ax, xerr=1, yerr=1)\n        _check_errorbar_color(ax.containers, \"red\", has_err=\"has_xerr\")\n        _check_errorbar_color(ax.containers, \"red\", has_err=\"has_yerr\")\n\n        ax = df.plot.scatter(x=\"a\", y=\"b\", yerr=\"e\", color=\"green\")\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        _check_errorbar_color(ax.containers, \"green\", has_err=\"has_yerr\")\n\n    @pytest.mark.slow\n    def test_sharex_and_ax(self):\n        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,\n        # the axis in fig.get_axis() are sorted differently than pandas\n        # expected them, so make sure that only the right ones are removed\n        import matplotlib.pyplot as plt\n\n        plt.close(\"all\")\n        gs, axes = _generate_4_axes_via_gridspec()\n\n        df = DataFrame(\n            {\n                \"a\": [1, 2, 3, 4, 5, 6],\n                \"b\": [1, 2, 3, 4, 5, 6],\n                \"c\": [1, 2, 3, 4, 5, 6],\n                \"d\": [1, 2, 3, 4, 5, 6],\n            }\n        )\n\n        def _check(axes):\n            for ax in axes:\n                assert len(ax.lines) == 1\n                self._check_visible(ax.get_yticklabels(), visible=True)\n            for ax in [axes[0], axes[2]]:\n                self._check_visible(ax.get_xticklabels(), visible=False)\n                self._check_visible(ax.get_xticklabels(minor=True), visible=False)\n            for ax in [axes[1], axes[3]]:\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax, sharex=True)\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharex=True)\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        # without sharex, no labels should be touched!\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax)\n\n        gs.tight_layout(plt.gcf())\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n    @pytest.mark.slow\n    def test_sharey_and_ax(self):\n        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,\n        # the axis in fig.get_axis() are sorted differently than pandas\n        # expected them, so make sure that only the right ones are removed\n        import matplotlib.pyplot as plt\n\n        gs, axes = _generate_4_axes_via_gridspec()\n\n        df = DataFrame(\n            {\n                \"a\": [1, 2, 3, 4, 5, 6],\n                \"b\": [1, 2, 3, 4, 5, 6],\n                \"c\": [1, 2, 3, 4, 5, 6],\n                \"d\": [1, 2, 3, 4, 5, 6],\n            }\n        )\n\n        def _check(axes):\n            for ax in axes:\n                assert len(ax.lines) == 1\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n            for ax in [axes[0], axes[1]]:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n            for ax in [axes[2], axes[3]]:\n                self._check_visible(ax.get_yticklabels(), visible=False)\n\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax, sharey=True)\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharey=True)\n\n        gs.tight_layout(plt.gcf())\n        _check(axes)\n        tm.close()\n\n        gs, axes = _generate_4_axes_via_gridspec()\n        # without sharex, no labels should be touched!\n        for ax in axes:\n            df.plot(x=\"a\", y=\"b\", title=\"title\", ax=ax)\n\n        gs.tight_layout(plt.gcf())\n        for ax in axes:\n            assert len(ax.lines) == 1\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n\n    @td.skip_if_no_scipy\n    def test_memory_leak(self):\n        \"\"\" Check that every plot type gets properly collected. \"\"\"\n        import gc\n        import weakref\n\n        results = {}\n        for kind in plotting.PlotAccessor._all_kinds:\n\n            args = {}\n            if kind in [\"hexbin\", \"scatter\", \"pie\"]:\n                df = self.hexbin_df\n                args = {\"x\": \"A\", \"y\": \"B\"}\n            elif kind == \"area\":\n                df = self.tdf.abs()\n            else:\n                df = self.tdf\n\n            # Use a weakref so we can see if the object gets collected without\n            # also preventing it from being collected\n            results[kind] = weakref.proxy(df.plot(kind=kind, **args))\n\n        # have matplotlib delete all the figures\n        tm.close()\n        # force a garbage collection\n        gc.collect()\n        for key in results:\n            # check that every plot was collected\n            with pytest.raises(ReferenceError):\n                # need to actually access something to get an error\n                results[key].lines\n\n    @pytest.mark.slow\n    def test_df_gridspec_patterns(self):\n        # GH 10819\n        import matplotlib.gridspec as gridspec\n        import matplotlib.pyplot as plt\n\n        ts = Series(np.random.randn(10), index=date_range(\"1/1/2000\", periods=10))\n\n        df = DataFrame(np.random.randn(10, 2), index=ts.index, columns=list(\"AB\"))\n\n        def _get_vertical_grid():\n            gs = gridspec.GridSpec(3, 1)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:2, :])\n            ax2 = fig.add_subplot(gs[2, :])\n            return ax1, ax2\n\n        def _get_horizontal_grid():\n            gs = gridspec.GridSpec(1, 3)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:, :2])\n            ax2 = fig.add_subplot(gs[:, 2])\n            return ax1, ax2\n\n        for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:\n            ax1 = ts.plot(ax=ax1)\n            assert len(ax1.lines) == 1\n            ax2 = df.plot(ax=ax2)\n            assert len(ax2.lines) == 2\n            for ax in [ax1, ax2]:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n            tm.close()\n\n        # subplots=True\n        for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:\n            axes = df.plot(subplots=True, ax=[ax1, ax2])\n            assert len(ax1.lines) == 1\n            assert len(ax2.lines) == 1\n            for ax in axes:\n                self._check_visible(ax.get_yticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(), visible=True)\n                self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n            tm.close()\n\n        # vertical / subplots / sharex=True / sharey=True\n        ax1, ax2 = _get_vertical_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True, sharey=True)\n        assert len(axes[0].lines) == 1\n        assert len(axes[1].lines) == 1\n        for ax in [ax1, ax2]:\n            # yaxis are visible because there is only one column\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        # xaxis of axes0 (top) are hidden\n        self._check_visible(axes[0].get_xticklabels(), visible=False)\n        self._check_visible(axes[0].get_xticklabels(minor=True), visible=False)\n        self._check_visible(axes[1].get_xticklabels(), visible=True)\n        self._check_visible(axes[1].get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # horizontal / subplots / sharex=True / sharey=True\n        ax1, ax2 = _get_horizontal_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True, sharey=True)\n        assert len(axes[0].lines) == 1\n        assert len(axes[1].lines) == 1\n        self._check_visible(axes[0].get_yticklabels(), visible=True)\n        # yaxis of axes1 (right) are hidden\n        self._check_visible(axes[1].get_yticklabels(), visible=False)\n        for ax in [ax1, ax2]:\n            # xaxis are visible because there is only one column\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # boxed\n        def _get_boxed_grid():\n            gs = gridspec.GridSpec(3, 3)\n            fig = plt.figure()\n            ax1 = fig.add_subplot(gs[:2, :2])\n            ax2 = fig.add_subplot(gs[:2, 2])\n            ax3 = fig.add_subplot(gs[2, :2])\n            ax4 = fig.add_subplot(gs[2, 2])\n            return ax1, ax2, ax3, ax4\n\n        axes = _get_boxed_grid()\n        df = DataFrame(np.random.randn(10, 4), index=ts.index, columns=list(\"ABCD\"))\n        axes = df.plot(subplots=True, ax=axes)\n        for ax in axes:\n            assert len(ax.lines) == 1\n            # axis are visible because these are not shared\n            self._check_visible(ax.get_yticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n        # subplots / sharex=True / sharey=True\n        axes = _get_boxed_grid()\n        with tm.assert_produces_warning(UserWarning):\n            axes = df.plot(subplots=True, ax=axes, sharex=True, sharey=True)\n        for ax in axes:\n            assert len(ax.lines) == 1\n        for ax in [axes[0], axes[2]]:  # left column\n            self._check_visible(ax.get_yticklabels(), visible=True)\n        for ax in [axes[1], axes[3]]:  # right column\n            self._check_visible(ax.get_yticklabels(), visible=False)\n        for ax in [axes[0], axes[1]]:  # top row\n            self._check_visible(ax.get_xticklabels(), visible=False)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=False)\n        for ax in [axes[2], axes[3]]:  # bottom row\n            self._check_visible(ax.get_xticklabels(), visible=True)\n            self._check_visible(ax.get_xticklabels(minor=True), visible=True)\n        tm.close()\n\n    @pytest.mark.slow\n    def test_df_grid_settings(self):\n        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792\n        self._check_grid_settings(\n            DataFrame({\"a\": [1, 2, 3], \"b\": [2, 3, 4]}),\n            plotting.PlotAccessor._dataframe_kinds,\n            kws={\"x\": \"a\", \"y\": \"b\"},\n        )\n\n    def test_plain_axes(self):\n\n        # supplied ax itself is a SubplotAxes, but figure contains also\n        # a plain Axes object (GH11556)\n        fig, ax = self.plt.subplots()\n        fig.add_axes([0.2, 0.2, 0.2, 0.2])\n        Series(np.random.rand(10)).plot(ax=ax)\n\n        # supplied ax itself is a plain Axes, but because the cmap keyword\n        # a new ax is created for the colorbar -> also multiples axes (GH11520)\n        df = DataFrame({\"a\": np.random.randn(8), \"b\": np.random.randn(8)})\n        fig = self.plt.figure()\n        ax = fig.add_axes((0, 0, 1, 1))\n        df.plot(kind=\"scatter\", ax=ax, x=\"a\", y=\"b\", c=\"a\", cmap=\"hsv\")\n\n        # other examples\n        fig, ax = self.plt.subplots()\n        from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n        divider = make_axes_locatable(ax)\n        cax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        Series(np.random.rand(10)).plot(ax=ax)\n        Series(np.random.rand(10)).plot(ax=cax)\n\n        fig, ax = self.plt.subplots()\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        iax = inset_axes(ax, width=\"30%\", height=1.0, loc=3)\n        Series(np.random.rand(10)).plot(ax=ax)\n        Series(np.random.rand(10)).plot(ax=iax)\n\n    @pytest.mark.parametrize(\"method\", [\"line\", \"barh\", \"bar\"])\n    def test_secondary_axis_font_size(self, method):\n        # GH: 12565\n        df = (\n            DataFrame(np.random.randn(15, 2), columns=list(\"AB\"))\n            .assign(C=lambda df: df.B.cumsum())\n            .assign(D=lambda df: df.C * 1.1)\n        )\n\n        fontsize = 20\n        sy = [\"C\", \"D\"]\n\n        kwargs = dict(secondary_y=sy, fontsize=fontsize, mark_right=True)\n        ax = getattr(df.plot, method)(**kwargs)\n        self._check_ticks_props(axes=ax.right_ax, ylabelsize=fontsize)\n\n    @pytest.mark.slow\n    def test_x_string_values_ticks(self):\n        # Test if string plot index have a fixed xtick position\n        # GH: 7612, GH: 22334\n        df = DataFrame(\n            {\n                \"sales\": [3, 2, 3],\n                \"visits\": [20, 42, 28],\n                \"day\": [\"Monday\", \"Tuesday\", \"Wednesday\"],\n            }\n        )\n        ax = df.plot.area(x=\"day\")\n        ax.set_xlim(-1, 3)\n        xticklabels = [t.get_text() for t in ax.get_xticklabels()]\n        labels_position = dict(zip(xticklabels, ax.get_xticks()))\n        # Testing if the label stayed at the right position\n        assert labels_position[\"Monday\"] == 0.0\n        assert labels_position[\"Tuesday\"] == 1.0\n        assert labels_position[\"Wednesday\"] == 2.0\n\n    @pytest.mark.slow\n    def test_x_multiindex_values_ticks(self):\n        # Test if multiindex plot index have a fixed xtick position\n        # GH: 15912\n        index = pd.MultiIndex.from_product([[2012, 2013], [1, 2]])\n        df = DataFrame(np.random.randn(4, 2), columns=[\"A\", \"B\"], index=index)\n        ax = df.plot()\n        ax.set_xlim(-1, 4)\n        xticklabels = [t.get_text() for t in ax.get_xticklabels()]\n        labels_position = dict(zip(xticklabels, ax.get_xticks()))\n        # Testing if the label stayed at the right position\n        assert labels_position[\"(2012, 1)\"] == 0.0\n        assert labels_position[\"(2012, 2)\"] == 1.0\n        assert labels_position[\"(2013, 1)\"] == 2.0\n        assert labels_position[\"(2013, 2)\"] == 3.0\n\n    @pytest.mark.parametrize(\"kind\", [\"line\", \"area\"])\n    def test_xlim_plot_line(self, kind):\n        # test if xlim is set correctly in plot.line and plot.area\n        # GH 27686\n        df = DataFrame([2, 4], index=[1, 2])\n        ax = df.plot(kind=kind)\n        xlims = ax.get_xlim()\n        assert xlims[0] < 1\n        assert xlims[1] > 2\n\n    def test_xlim_plot_line_correctly_in_mixed_plot_type(self):\n        # test if xlim is set correctly when ax contains multiple different kinds\n        # of plots, GH 27686\n        fig, ax = self.plt.subplots()\n\n        indexes = [\"k1\", \"k2\", \"k3\", \"k4\"]\n        df = DataFrame(\n            {\n                \"s1\": [1000, 2000, 1500, 2000],\n                \"s2\": [900, 1400, 2000, 3000],\n                \"s3\": [1500, 1500, 1600, 1200],\n                \"secondary_y\": [1, 3, 4, 3],\n            },\n            index=indexes,\n        )\n        df[[\"s1\", \"s2\", \"s3\"]].plot.bar(ax=ax, stacked=False)\n        df[[\"secondary_y\"]].plot(ax=ax, secondary_y=True)\n\n        xlims = ax.get_xlim()\n        assert xlims[0] < 0\n        assert xlims[1] > 3\n\n        # make sure axis labels are plotted correctly as well\n        xticklabels = [t.get_text() for t in ax.get_xticklabels()]\n        assert xticklabels == indexes\n\n    def test_plot_no_rows(self):\n        # GH 27758\n        df = DataFrame(columns=[\"foo\"], dtype=int)\n        assert df.empty\n        ax = df.plot()\n        assert len(ax.get_lines()) == 1\n        line = ax.get_lines()[0]\n        assert len(line.get_xdata()) == 0\n        assert len(line.get_ydata()) == 0\n\n    def test_plot_no_numeric_data(self):\n        df = DataFrame([\"a\", \"b\", \"c\"])\n        with pytest.raises(TypeError):\n            df.plot()\n\n    def test_missing_markers_legend(self):\n        # 14958\n        df = DataFrame(np.random.randn(8, 3), columns=[\"A\", \"B\", \"C\"])\n        ax = df.plot(y=[\"A\"], marker=\"x\", linestyle=\"solid\")\n        df.plot(y=[\"B\"], marker=\"o\", linestyle=\"dotted\", ax=ax)\n        df.plot(y=[\"C\"], marker=\"<\", linestyle=\"dotted\", ax=ax)\n\n        self._check_legend_labels(ax, labels=[\"A\", \"B\", \"C\"])\n        self._check_legend_marker(ax, expected_markers=[\"x\", \"o\", \"<\"])\n\n    def test_missing_markers_legend_using_style(self):\n        # 14563\n        df = DataFrame(\n            {\n                \"A\": [1, 2, 3, 4, 5, 6],\n                \"B\": [2, 4, 1, 3, 2, 4],\n                \"C\": [3, 3, 2, 6, 4, 2],\n                \"X\": [1, 2, 3, 4, 5, 6],\n            }\n        )\n\n        fig, ax = self.plt.subplots()\n        for kind in \"ABC\":\n            df.plot(\"X\", kind, label=kind, ax=ax, style=\".\")\n\n        self._check_legend_labels(ax, labels=[\"A\", \"B\", \"C\"])\n        self._check_legend_marker(ax, expected_markers=[\".\", \".\", \".\"])\n\n    @pytest.mark.parametrize(\n        \"index_name, old_label, new_label\",\n        [\n            (None, \"\", \"new\"),\n            (\"old\", \"old\", \"new\"),\n            (None, \"\", \"\"),\n            (None, \"\", 1),\n            (None, \"\", [1, 2]),\n        ],\n    )\n    @pytest.mark.parametrize(\"kind\", [\"line\", \"area\", \"bar\"])\n    def test_xlabel_ylabel_dataframe_single_plot(\n        self, kind, index_name, old_label, new_label\n    ):\n        # GH 9093\n        df = DataFrame([[1, 2], [2, 5]], columns=[\"Type A\", \"Type B\"])\n        df.index.name = index_name\n\n        # default is the ylabel is not shown and xlabel is index name\n        ax = df.plot(kind=kind)\n        assert ax.get_xlabel() == old_label\n        assert ax.get_ylabel() == \"\"\n\n        # old xlabel will be overriden and assigned ylabel will be used as ylabel\n        ax = df.plot(kind=kind, ylabel=new_label, xlabel=new_label)\n        assert ax.get_ylabel() == str(new_label)\n        assert ax.get_xlabel() == str(new_label)\n\n    @pytest.mark.parametrize(\n        \"xlabel, ylabel\",\n        [\n            (None, None),\n            (\"X Label\", None),\n            (None, \"Y Label\"),\n            (\"X Label\", \"Y Label\"),\n        ],\n    )\n    @pytest.mark.parametrize(\"kind\", [\"scatter\", \"hexbin\"])\n    def test_xlabel_ylabel_dataframe_plane_plot(self, kind, xlabel, ylabel):\n        # GH 37001\n        xcol = \"Type A\"\n        ycol = \"Type B\"\n        df = DataFrame([[1, 2], [2, 5]], columns=[xcol, ycol])\n\n        # default is the labels are column names\n        ax = df.plot(kind=kind, x=xcol, y=ycol, xlabel=xlabel, ylabel=ylabel)\n        assert ax.get_xlabel() == (xcol if xlabel is None else xlabel)\n        assert ax.get_ylabel() == (ycol if ylabel is None else ylabel)\n\n    @pytest.mark.slow\n    @pytest.mark.parametrize(\"method\", [\"bar\", \"barh\"])\n    def test_bar_ticklabel_consistence(self, method):\n        # Draw two consecutiv bar plot with consistent ticklabels\n        # The labels positions should not move between two drawing on the same axis\n        # GH: 26186\n        def get_main_axis(ax):\n            if method == \"barh\":\n                return ax.yaxis\n            elif method == \"bar\":\n                return ax.xaxis\n\n        # Plot the first bar plot\n        data = {\"A\": 0, \"B\": 3, \"C\": -4}\n        df = DataFrame.from_dict(data, orient=\"index\", columns=[\"Value\"])\n        ax = getattr(df.plot, method)()\n        ax.get_figure().canvas.draw()\n\n        # Retrieve the label positions for the first drawing\n        xticklabels = [t.get_text() for t in get_main_axis(ax).get_ticklabels()]\n        label_positions_1 = dict(zip(xticklabels, get_main_axis(ax).get_ticklocs()))\n\n        # Modify the dataframe order and values and plot on same axis\n        df = df.sort_values(\"Value\") * -2\n        ax = getattr(df.plot, method)(ax=ax, color=\"red\")\n        ax.get_figure().canvas.draw()\n\n        # Retrieve the label positions for the second drawing\n        xticklabels = [t.get_text() for t in get_main_axis(ax).get_ticklabels()]\n        label_positions_2 = dict(zip(xticklabels, get_main_axis(ax).get_ticklocs()))\n\n        # Assert that the label positions did not change between the plotting\n        assert label_positions_1 == label_positions_2\n\n    def test_bar_numeric(self):\n        # Bar plot with numeric index have tick location values equal to index\n        # values\n        # GH: 11465\n        df = DataFrame(np.random.rand(10), index=np.arange(10, 20))\n        ax = df.plot.bar()\n        ticklocs = ax.xaxis.get_ticklocs()\n        expected = np.arange(10, 20, dtype=np.int64)\n        tm.assert_numpy_array_equal(ticklocs, expected)\n\n    def test_bar_multiindex(self):\n        # Test from pandas/doc/source/user_guide/visualization.rst\n        # at section Plotting With Error Bars\n        # Related to issue GH: 26186\n\n        ix3 = pd.MultiIndex.from_arrays(\n            [\n                [\"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\"],\n                [\"foo\", \"foo\", \"bar\", \"bar\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            ],\n            names=[\"letter\", \"word\"],\n        )\n\n        df3 = DataFrame(\n            {\"data1\": [3, 2, 4, 3, 2, 4, 3, 2], \"data2\": [6, 5, 7, 5, 4, 5, 6, 5]},\n            index=ix3,\n        )\n\n        # Group by index labels and take the means and standard deviations\n        # for each group\n        gp3 = df3.groupby(level=(\"letter\", \"word\"))\n        means = gp3.mean()\n        errors = gp3.std()\n\n        # No assertion we just ensure that we can plot a MultiIndex bar plot\n        # and are getting a UserWarning if redrawing\n        with tm.assert_produces_warning(None):\n            ax = means.plot.bar(yerr=errors, capsize=4)\n        with tm.assert_produces_warning(UserWarning):\n            means.plot.bar(yerr=errors, capsize=4, ax=ax)\n\n\ndef _generate_4_axes_via_gridspec():\n    import matplotlib as mpl\n    import matplotlib.gridspec\n    import matplotlib.pyplot as plt\n\n    gs = mpl.gridspec.GridSpec(2, 2)\n    ax_tl = plt.subplot(gs[0, 0])\n    ax_ll = plt.subplot(gs[1, 0])\n    ax_tr = plt.subplot(gs[0, 1])\n    ax_lr = plt.subplot(gs[1, 1])\n\n    return gs, [ax_tl, ax_ll, ax_tr, ax_lr]\n"
    }
  ]
}