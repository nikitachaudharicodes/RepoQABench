{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "53147",
  "issue_description": "# BUG: to_datetime ignores \"AM\" and \"PM\" unless format is explicitly set\n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [X] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n>>> df = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\n>>> df\r\n                       0\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n>>> pd.to_datetime(df[0])\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 01:00:48  # PM is ignored, parsing as 01:00 instead of 13:00\r\n3   2023-04-21 02:35:37\n```\n\n\n### Issue Description\n\n`to_datetime` ignores the `AM` and `PM` particles, hence parsing both as 24H format.\n\n### Expected Behavior\n\n```python\r\n>>> df = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\n>>> df\r\n                       0\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n>>> pd.to_datetime(df[0])\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 13:00:48\r\n3   2023-04-21 14:35:37\r\n```\r\n\n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 37ea63d540fd27274cad6585082c91b1283f963d\r\npython           : 3.10.4.final.0\r\npython-bits      : 64\r\nOS               : Darwin\r\nOS-release       : 21.6.0\r\nVersion          : Darwin Kernel Version 21.6.0: Thu Mar  9 20:12:21 PST 2023; root:xnu-8020.240.18.700.8~1/RELEASE_ARM64_T6000\r\nmachine          : arm64\r\nprocessor        : arm\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : en_US.UTF-8\r\nLOCALE           : en_US.UTF-8\r\n\r\npandas           : 2.0.1\r\nnumpy            : 1.24.2\r\npytz             : 2023.3\r\ndateutil         : 2.8.2\r\nsetuptools       : 67.4.0\r\npip              : 23.0.1\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : 3.0.9\r\nlxml.etree       : 4.9.2\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : 2.9.5\r\njinja2           : None\r\nIPython          : None\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nbrotli           : None\r\nfastparquet      : None\r\nfsspec           : None\r\ngcsfs            : None\r\nmatplotlib       : None\r\nnumba            : None\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : 3.1.2\r\npandas_gbq       : None\r\npyarrow          : None\r\npyreadstat       : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.10.1\r\nsnappy           : None\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : 0.9.0\r\nxarray           : None\r\nxlrd             : 2.0.1\r\nzstandard        : None\r\ntzdata           : 2023.3\r\nqtpy             : None\r\npyqt5            : None\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 1539631525,
      "user": "davep33l",
      "body": "Hi @juli4nb4dillo, I am new here so apologies if I misunderstand the bug you have raised. \r\n\r\nUsing the format parameter would get the desired result\r\n\r\nI recreated your code with the format parameter and returned the following:\r\n\r\nimport pandas as pd\r\ndf = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\nprint(df)\r\ndf[0] = pd.to_datetime(df[0],format='%m/%d/%Y %I:%M:%S %p')\r\nprint(df)\r\n\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n\r\n0 2023-04-21 11:06:35\r\n1 2023-04-21 12:06:35\r\n2 2023-04-21 13:00:48\r\n3 2023-04-21 14:35:37\r\n\r\n\r\n"
    },
    {
      "id": 1540035654,
      "user": "juli4nb4dillo",
      "body": "@rainman33 That's correct, it's not a big deal if I manually set the format. However it used to work (without format parameter) with pandas 1.5.3, hence it triggered a few hidden bugs in our software once we upgraded to pandas 2.x.\r\nI suggest raising a warning in case of no format?"
    },
    {
      "id": 1547743096,
      "user": "lithomas1",
      "body": "Hi @juli4nb4dillo,\r\nNot at all an expert with our datetime code, but the code changes you're seeing might be a consequence of PDEP-4. \r\nYou can read about it here https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html\r\n\r\nIf I pass in ``format=\"mixed\"``, I get\r\n```\r\n>>> pd.to_datetime(df[0], format=\"mixed\")\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 13:00:48\r\n3   2023-04-21 14:35:37\r\nName: 0, dtype: datetime64[ns]\r\n```\r\nwhich I think is what you expected. \r\n\r\nIt's strange that the parsing didn't throw an error, though. cc @MarcoGorelli who probably knows whether this is a bug or not."
    },
    {
      "id": 1547801111,
      "user": "MarcoGorelli",
      "body": "thanks @juli4nb4dillo for the report (and @lithomas1 for the ping!)\r\n\r\nthis looks like a bug: we have\r\n```python\r\nIn [2]: guess_datetime_format('4/21/2023 11:06:35 AM')\r\nOut[2]: '%m/%d/%Y %H:%M:%S %p'\r\n```\r\nand it looks like this should instead have been\r\n```python\r\n'%m/%d/%Y %I:%M:%S %p'\r\n```\r\n?"
    },
    {
      "id": 1547984789,
      "user": "MarcoGorelli",
      "body": "This is the part of the code which would need changing\r\n\r\n[pandas/_libs/tslibs/parsing.pyx](https://github.com/pandas-dev/pandas/blob/d389bd814b1fba0fd112f2cc40c8a915855e02bc/pandas/_libs/tslibs/parsing.pyx#L867-L1035)\r\n\r\nNot sure whether to suggest special-casing '`%H'` to become `'%I'` if there's `%p`, or to just stop guessing `'%p'` for safety. Tempted to go with the latter"
    },
    {
      "id": 1547987868,
      "user": "MarcoGorelli",
      "body": "cc @davesque @mroeschke "
    },
    {
      "id": 1548291649,
      "user": "mroeschke",
      "body": "If AM/PM is in the guessing string, then switching to `%I` where relevant makes sense. Otherwise I don't think it's safe to ever guess `%p` if it's not"
    },
    {
      "id": 1548303864,
      "user": "MarcoGorelli",
      "body": "so something like\r\n- if %I is in the guessed format and %H is there too, replace %H with %I\r\n- if %I is in the guessed format, and neither %H nor %I are, then return `None`\r\n\r\nAnyone fancy making a PR?"
    },
    {
      "id": 1548537774,
      "user": "juli4nb4dillo",
      "body": "@MarcoGorelli https://github.com/pandas-dev/pandas/pull/53244\r\nSorry it took me a while to setup my environment."
    },
    {
      "id": 1549736513,
      "user": "sanketsarwade",
      "body": "import pandas as pd\r\n\r\ndf = pd.DataFrame(['4/21/2023 11:06:35 AM', '4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'], columns=['datetime_string'])\r\ndf['datetime'] = pd.to_datetime(df['datetime_string'], infer_datetime_format=True)\r\n\r\nprint(df)\r\n\r\n\r\n\r\nresult :\r\n\r\n       datetime_string            datetime\r\n0  4/21/2023 11:06:35 AM 2023-04-21 11:06:35\r\n1  4/21/2023 12:06:35 PM 2023-04-21 12:06:35\r\n2   4/21/2023 1:00:48 PM 2023-04-21 13:00:48\r\n3   4/21/2023 2:35:37 PM 2023-04-21 14:35:37\r\n\r\n\r\n In this code, we import the pandas library, create a DataFrame called df with the datetime strings, and add a new column called 'datetime'. The pd.to_datetime() function is used to convert the datetime strings to datetime objects. By setting infer_datetime_format=True, pandas will automatically infer the format of the datetime strings, including the AM/PM indicator."
    }
  ],
  "text_context": "# BUG: to_datetime ignores \"AM\" and \"PM\" unless format is explicitly set\n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [X] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n>>> df = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\n>>> df\r\n                       0\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n>>> pd.to_datetime(df[0])\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 01:00:48  # PM is ignored, parsing as 01:00 instead of 13:00\r\n3   2023-04-21 02:35:37\n```\n\n\n### Issue Description\n\n`to_datetime` ignores the `AM` and `PM` particles, hence parsing both as 24H format.\n\n### Expected Behavior\n\n```python\r\n>>> df = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\n>>> df\r\n                       0\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n>>> pd.to_datetime(df[0])\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 13:00:48\r\n3   2023-04-21 14:35:37\r\n```\r\n\n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : 37ea63d540fd27274cad6585082c91b1283f963d\r\npython           : 3.10.4.final.0\r\npython-bits      : 64\r\nOS               : Darwin\r\nOS-release       : 21.6.0\r\nVersion          : Darwin Kernel Version 21.6.0: Thu Mar  9 20:12:21 PST 2023; root:xnu-8020.240.18.700.8~1/RELEASE_ARM64_T6000\r\nmachine          : arm64\r\nprocessor        : arm\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : en_US.UTF-8\r\nLOCALE           : en_US.UTF-8\r\n\r\npandas           : 2.0.1\r\nnumpy            : 1.24.2\r\npytz             : 2023.3\r\ndateutil         : 2.8.2\r\nsetuptools       : 67.4.0\r\npip              : 23.0.1\r\nCython           : None\r\npytest           : None\r\nhypothesis       : None\r\nsphinx           : None\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : 3.0.9\r\nlxml.etree       : 4.9.2\r\nhtml5lib         : None\r\npymysql          : None\r\npsycopg2         : 2.9.5\r\njinja2           : None\r\nIPython          : None\r\npandas_datareader: None\r\nbs4              : None\r\nbottleneck       : None\r\nbrotli           : None\r\nfastparquet      : None\r\nfsspec           : None\r\ngcsfs            : None\r\nmatplotlib       : None\r\nnumba            : None\r\nnumexpr          : None\r\nodfpy            : None\r\nopenpyxl         : 3.1.2\r\npandas_gbq       : None\r\npyarrow          : None\r\npyreadstat       : None\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.10.1\r\nsnappy           : None\r\nsqlalchemy       : None\r\ntables           : None\r\ntabulate         : 0.9.0\r\nxarray           : None\r\nxlrd             : 2.0.1\r\nzstandard        : None\r\ntzdata           : 2023.3\r\nqtpy             : None\r\npyqt5            : None\r\n\r\n</details>\r\n\n\nHi @juli4nb4dillo, I am new here so apologies if I misunderstand the bug you have raised. \r\n\r\nUsing the format parameter would get the desired result\r\n\r\nI recreated your code with the format parameter and returned the following:\r\n\r\nimport pandas as pd\r\ndf = pd.DataFrame(['4/21/2023 11:06:35 AM','4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'])\r\nprint(df)\r\ndf[0] = pd.to_datetime(df[0],format='%m/%d/%Y %I:%M:%S %p')\r\nprint(df)\r\n\r\n0  4/21/2023 11:06:35 AM\r\n1  4/21/2023 12:06:35 PM\r\n2   4/21/2023 1:00:48 PM\r\n3   4/21/2023 2:35:37 PM\r\n\r\n0 2023-04-21 11:06:35\r\n1 2023-04-21 12:06:35\r\n2 2023-04-21 13:00:48\r\n3 2023-04-21 14:35:37\r\n\r\n\r\n\n\n@rainman33 That's correct, it's not a big deal if I manually set the format. However it used to work (without format parameter) with pandas 1.5.3, hence it triggered a few hidden bugs in our software once we upgraded to pandas 2.x.\r\nI suggest raising a warning in case of no format?\n\nHi @juli4nb4dillo,\r\nNot at all an expert with our datetime code, but the code changes you're seeing might be a consequence of PDEP-4. \r\nYou can read about it here https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html\r\n\r\nIf I pass in ``format=\"mixed\"``, I get\r\n```\r\n>>> pd.to_datetime(df[0], format=\"mixed\")\r\n0   2023-04-21 11:06:35\r\n1   2023-04-21 12:06:35\r\n2   2023-04-21 13:00:48\r\n3   2023-04-21 14:35:37\r\nName: 0, dtype: datetime64[ns]\r\n```\r\nwhich I think is what you expected. \r\n\r\nIt's strange that the parsing didn't throw an error, though. cc @MarcoGorelli who probably knows whether this is a bug or not.\n\nthanks @juli4nb4dillo for the report (and @lithomas1 for the ping!)\r\n\r\nthis looks like a bug: we have\r\n```python\r\nIn [2]: guess_datetime_format('4/21/2023 11:06:35 AM')\r\nOut[2]: '%m/%d/%Y %H:%M:%S %p'\r\n```\r\nand it looks like this should instead have been\r\n```python\r\n'%m/%d/%Y %I:%M:%S %p'\r\n```\r\n?\n\nThis is the part of the code which would need changing\r\n\r\n[pandas/_libs/tslibs/parsing.pyx](https://github.com/pandas-dev/pandas/blob/d389bd814b1fba0fd112f2cc40c8a915855e02bc/pandas/_libs/tslibs/parsing.pyx#L867-L1035)\r\n\r\nNot sure whether to suggest special-casing '`%H'` to become `'%I'` if there's `%p`, or to just stop guessing `'%p'` for safety. Tempted to go with the latter\n\ncc @davesque @mroeschke \n\nIf AM/PM is in the guessing string, then switching to `%I` where relevant makes sense. Otherwise I don't think it's safe to ever guess `%p` if it's not\n\nso something like\r\n- if %I is in the guessed format and %H is there too, replace %H with %I\r\n- if %I is in the guessed format, and neither %H nor %I are, then return `None`\r\n\r\nAnyone fancy making a PR?\n\n@MarcoGorelli https://github.com/pandas-dev/pandas/pull/53244\r\nSorry it took me a while to setup my environment.\n\nimport pandas as pd\r\n\r\ndf = pd.DataFrame(['4/21/2023 11:06:35 AM', '4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'], columns=['datetime_string'])\r\ndf['datetime'] = pd.to_datetime(df['datetime_string'], infer_datetime_format=True)\r\n\r\nprint(df)\r\n\r\n\r\n\r\nresult :\r\n\r\n       datetime_string            datetime\r\n0  4/21/2023 11:06:35 AM 2023-04-21 11:06:35\r\n1  4/21/2023 12:06:35 PM 2023-04-21 12:06:35\r\n2   4/21/2023 1:00:48 PM 2023-04-21 13:00:48\r\n3   4/21/2023 2:35:37 PM 2023-04-21 14:35:37\r\n\r\n\r\n In this code, we import the pandas library, create a DataFrame called df with the datetime strings, and add a new column called 'datetime'. The pd.to_datetime() function is used to convert the datetime strings to datetime objects. By setting infer_datetime_format=True, pandas will automatically infer the format of the datetime strings, including the AM/PM indicator.",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/53244",
  "code_context": [
    {
      "filename": "pandas/tests/tools/test_to_datetime.py",
      "content": "\"\"\" test to_datetime \"\"\"\n\nimport calendar\nfrom collections import deque\nfrom datetime import (\n    date,\n    datetime,\n    timedelta,\n    timezone,\n)\nfrom decimal import Decimal\nimport locale\n\nfrom dateutil.parser import parse\nfrom dateutil.tz.tz import tzoffset\nimport numpy as np\nimport pytest\nimport pytz\n\nfrom pandas._libs import tslib\nfrom pandas._libs.tslibs import (\n    iNaT,\n    parsing,\n)\nfrom pandas.errors import (\n    OutOfBoundsDatetime,\n    OutOfBoundsTimedelta,\n)\nimport pandas.util._test_decorators as td\n\nfrom pandas.core.dtypes.common import is_datetime64_ns_dtype\n\nimport pandas as pd\nfrom pandas import (\n    DataFrame,\n    DatetimeIndex,\n    Index,\n    NaT,\n    Series,\n    Timestamp,\n    date_range,\n    isna,\n    to_datetime,\n)\nimport pandas._testing as tm\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.tools import datetimes as tools\nfrom pandas.core.tools.datetimes import start_caching_at\n\nPARSING_ERR_MSG = (\n    r\"You might want to try:\\n\"\n    r\"    - passing `format` if your strings have a consistent format;\\n\"\n    r\"    - passing `format=\\'ISO8601\\'` if your strings are all ISO8601 \"\n    r\"but not necessarily in exactly the same format;\\n\"\n    r\"    - passing `format=\\'mixed\\'`, and the format will be inferred \"\n    r\"for each element individually. You might want to use `dayfirst` \"\n    r\"alongside this.\"\n)\n\n\n@pytest.fixture(params=[True, False])\ndef cache(request):\n    \"\"\"\n    cache keyword to pass to to_datetime.\n    \"\"\"\n    return request.param\n\n\nclass TestTimeConversionFormats:\n    @pytest.mark.parametrize(\"readonly\", [True, False])\n    def test_to_datetime_readonly(self, readonly):\n        # GH#34857\n        arr = np.array([], dtype=object)\n        if readonly:\n            arr.setflags(write=False)\n        result = to_datetime(arr)\n        expected = to_datetime([])\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"format, expected\",\n        [\n            [\n                \"%d/%m/%Y\",\n                [Timestamp(\"20000101\"), Timestamp(\"20000201\"), Timestamp(\"20000301\")],\n            ],\n            [\n                \"%m/%d/%Y\",\n                [Timestamp(\"20000101\"), Timestamp(\"20000102\"), Timestamp(\"20000103\")],\n            ],\n        ],\n    )\n    def test_to_datetime_format(self, cache, index_or_series, format, expected):\n        values = index_or_series([\"1/1/2000\", \"1/2/2000\", \"1/3/2000\"])\n        result = to_datetime(values, format=format, cache=cache)\n        expected = index_or_series(expected)\n        if isinstance(expected, Series):\n            tm.assert_series_equal(result, expected)\n        else:\n            tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"arg, expected, format\",\n        [\n            [\"1/1/2000\", \"20000101\", \"%d/%m/%Y\"],\n            [\"1/1/2000\", \"20000101\", \"%m/%d/%Y\"],\n            [\"1/2/2000\", \"20000201\", \"%d/%m/%Y\"],\n            [\"1/2/2000\", \"20000102\", \"%m/%d/%Y\"],\n            [\"1/3/2000\", \"20000301\", \"%d/%m/%Y\"],\n            [\"1/3/2000\", \"20000103\", \"%m/%d/%Y\"],\n        ],\n    )\n    def test_to_datetime_format_scalar(self, cache, arg, expected, format):\n        result = to_datetime(arg, format=format, cache=cache)\n        expected = Timestamp(expected)\n        assert result == expected\n\n    def test_to_datetime_format_YYYYMMDD(self, cache):\n        ser = Series([19801222, 19801222] + [19810105] * 5)\n        expected = Series([Timestamp(x) for x in ser.apply(str)])\n\n        result = to_datetime(ser, format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        result = to_datetime(ser.apply(str), format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_format_YYYYMMDD_with_nat(self, cache):\n        # Explicit cast to float to explicit cast when setting np.nan\n        ser = Series([19801222, 19801222] + [19810105] * 5, dtype=\"float\")\n        # with NaT\n        expected = Series(\n            [Timestamp(\"19801222\"), Timestamp(\"19801222\")] + [Timestamp(\"19810105\")] * 5\n        )\n        expected[2] = np.nan\n        ser[2] = np.nan\n\n        result = to_datetime(ser, format=\"%Y%m%d\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        # string with NaT\n        ser2 = ser.apply(str)\n        ser2[2] = \"nat\"\n        with pytest.raises(\n            ValueError,\n            match=(\n                'unconverted data remains when parsing with format \"%Y%m%d\": \".0\", '\n                \"at position 0\"\n            ),\n        ):\n            # https://github.com/pandas-dev/pandas/issues/50051\n            to_datetime(ser2, format=\"%Y%m%d\", cache=cache)\n\n    def test_to_datetime_format_YYYYMM_with_nat(self, cache):\n        # https://github.com/pandas-dev/pandas/issues/50237\n        # Explicit cast to float to explicit cast when setting np.nan\n        ser = Series([198012, 198012] + [198101] * 5, dtype=\"float\")\n        expected = Series(\n            [Timestamp(\"19801201\"), Timestamp(\"19801201\")] + [Timestamp(\"19810101\")] * 5\n        )\n        expected[2] = np.nan\n        ser[2] = np.nan\n        result = to_datetime(ser, format=\"%Y%m\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_format_YYYYMMDD_ignore(self, cache):\n        # coercion\n        # GH 7930, GH 14487\n        ser = Series([20121231, 20141231, 99991231])\n        result = to_datetime(ser, format=\"%Y%m%d\", errors=\"ignore\", cache=cache)\n        expected = Series(\n            [20121231, 20141231, 99991231],\n            dtype=object,\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_format_YYYYMMDD_ignore_with_outofbounds(self, cache):\n        # https://github.com/pandas-dev/pandas/issues/26493\n        result = to_datetime(\n            [\"15010101\", \"20150101\", np.nan],\n            format=\"%Y%m%d\",\n            errors=\"ignore\",\n            cache=cache,\n        )\n        expected = Index([\"15010101\", \"20150101\", np.nan])\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_format_YYYYMMDD_coercion(self, cache):\n        # coercion\n        # GH 7930\n        ser = Series([20121231, 20141231, 99991231])\n        result = to_datetime(ser, format=\"%Y%m%d\", errors=\"coerce\", cache=cache)\n        expected = Series([\"20121231\", \"20141231\", \"NaT\"], dtype=\"M8[ns]\")\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"input_s\",\n        [\n            # Null values with Strings\n            [\"19801222\", \"20010112\", None],\n            [\"19801222\", \"20010112\", np.nan],\n            [\"19801222\", \"20010112\", NaT],\n            [\"19801222\", \"20010112\", \"NaT\"],\n            # Null values with Integers\n            [19801222, 20010112, None],\n            [19801222, 20010112, np.nan],\n            [19801222, 20010112, NaT],\n            [19801222, 20010112, \"NaT\"],\n        ],\n    )\n    def test_to_datetime_format_YYYYMMDD_with_none(self, input_s):\n        # GH 30011\n        # format='%Y%m%d'\n        # with None\n        expected = Series([Timestamp(\"19801222\"), Timestamp(\"20010112\"), NaT])\n        result = Series(to_datetime(input_s, format=\"%Y%m%d\"))\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"input_s, expected\",\n        [\n            # NaN before strings with invalid date values\n            [\n                Series([\"19801222\", np.nan, \"20010012\", \"10019999\"]),\n                Series([Timestamp(\"19801222\"), np.nan, np.nan, np.nan]),\n            ],\n            # NaN after strings with invalid date values\n            [\n                Series([\"19801222\", \"20010012\", \"10019999\", np.nan]),\n                Series([Timestamp(\"19801222\"), np.nan, np.nan, np.nan]),\n            ],\n            # NaN before integers with invalid date values\n            [\n                Series([20190813, np.nan, 20010012, 20019999]),\n                Series([Timestamp(\"20190813\"), np.nan, np.nan, np.nan]),\n            ],\n            # NaN after integers with invalid date values\n            [\n                Series([20190813, 20010012, np.nan, 20019999]),\n                Series([Timestamp(\"20190813\"), np.nan, np.nan, np.nan]),\n            ],\n        ],\n    )\n    def test_to_datetime_format_YYYYMMDD_overflow(self, input_s, expected):\n        # GH 25512\n        # format='%Y%m%d', errors='coerce'\n        result = to_datetime(input_s, format=\"%Y%m%d\", errors=\"coerce\")\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"data, format, expected\",\n        [\n            ([pd.NA], \"%Y%m%d%H%M%S\", DatetimeIndex([\"NaT\"])),\n            ([pd.NA], None, DatetimeIndex([\"NaT\"])),\n            (\n                [pd.NA, \"20210202202020\"],\n                \"%Y%m%d%H%M%S\",\n                DatetimeIndex([\"NaT\", \"2021-02-02 20:20:20\"]),\n            ),\n            ([\"201010\", pd.NA], \"%y%m%d\", DatetimeIndex([\"2020-10-10\", \"NaT\"])),\n            ([\"201010\", pd.NA], \"%d%m%y\", DatetimeIndex([\"2010-10-20\", \"NaT\"])),\n            ([None, np.nan, pd.NA], None, DatetimeIndex([\"NaT\", \"NaT\", \"NaT\"])),\n            ([None, np.nan, pd.NA], \"%Y%m%d\", DatetimeIndex([\"NaT\", \"NaT\", \"NaT\"])),\n        ],\n    )\n    def test_to_datetime_with_NA(self, data, format, expected):\n        # GH#42957\n        result = to_datetime(data, format=format)\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_with_NA_with_warning(self):\n        # GH#42957\n        result = to_datetime([\"201010\", pd.NA])\n        expected = DatetimeIndex([\"2010-10-20\", \"NaT\"])\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_format_integer(self, cache):\n        # GH 10178\n        ser = Series([2000, 2001, 2002])\n        expected = Series([Timestamp(x) for x in ser.apply(str)])\n\n        result = to_datetime(ser, format=\"%Y\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n        ser = Series([200001, 200105, 200206])\n        expected = Series([Timestamp(x[:4] + \"-\" + x[4:]) for x in ser.apply(str)])\n\n        result = to_datetime(ser, format=\"%Y%m\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"int_date, expected\",\n        [\n            # valid date, length == 8\n            [20121030, datetime(2012, 10, 30)],\n            # short valid date, length == 6\n            [199934, datetime(1999, 3, 4)],\n            # long integer date partially parsed to datetime(2012,1,1), length > 8\n            [2012010101, 2012010101],\n            # invalid date partially parsed to datetime(2012,9,9), length == 8\n            [20129930, 20129930],\n            # short integer date partially parsed to datetime(2012,9,9), length < 8\n            [2012993, 2012993],\n            # short invalid date, length == 4\n            [2121, 2121],\n        ],\n    )\n    def test_int_to_datetime_format_YYYYMMDD_typeerror(self, int_date, expected):\n        # GH 26583\n        result = to_datetime(int_date, format=\"%Y%m%d\", errors=\"ignore\")\n        assert result == expected\n\n    def test_to_datetime_format_microsecond(self, cache):\n        month_abbr = calendar.month_abbr[4]\n        val = f\"01-{month_abbr}-2011 00:00:01.978\"\n\n        format = \"%d-%b-%Y %H:%M:%S.%f\"\n        result = to_datetime(val, format=format, cache=cache)\n        exp = datetime.strptime(val, format)\n        assert result == exp\n\n    @pytest.mark.parametrize(\n        \"value, format, dt\",\n        [\n            [\"01/10/2010 15:20\", \"%m/%d/%Y %H:%M\", Timestamp(\"2010-01-10 15:20\")],\n            [\"01/10/2010 05:43\", \"%m/%d/%Y %I:%M\", Timestamp(\"2010-01-10 05:43\")],\n            [\n                \"01/10/2010 13:56:01\",\n                \"%m/%d/%Y %H:%M:%S\",\n                Timestamp(\"2010-01-10 13:56:01\"),\n            ],\n            # The 3 tests below are locale-dependent.\n            # They pass, except when the machine locale is zh_CN or it_IT .\n            pytest.param(\n                \"01/10/2010 08:14 PM\",\n                \"%m/%d/%Y %I:%M %p\",\n                Timestamp(\"2010-01-10 20:14\"),\n                marks=pytest.mark.xfail(\n                    locale.getlocale()[0] in (\"zh_CN\", \"it_IT\"),\n                    reason=\"fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8\",\n                    strict=False,\n                ),\n            ),\n            pytest.param(\n                \"01/10/2010 07:40 AM\",\n                \"%m/%d/%Y %I:%M %p\",\n                Timestamp(\"2010-01-10 07:40\"),\n                marks=pytest.mark.xfail(\n                    locale.getlocale()[0] in (\"zh_CN\", \"it_IT\"),\n                    reason=\"fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8\",\n                    strict=False,\n                ),\n            ),\n            pytest.param(\n                \"01/10/2010 09:12:56 AM\",\n                \"%m/%d/%Y %I:%M:%S %p\",\n                Timestamp(\"2010-01-10 09:12:56\"),\n                marks=pytest.mark.xfail(\n                    locale.getlocale()[0] in (\"zh_CN\", \"it_IT\"),\n                    reason=\"fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8\",\n                    strict=False,\n                ),\n            ),\n        ],\n    )\n    def test_to_datetime_format_time(self, cache, value, format, dt):\n        assert to_datetime(value, format=format, cache=cache) == dt\n\n    @td.skip_if_not_us_locale\n    def test_to_datetime_with_non_exact(self, cache):\n        # GH 10834\n        # 8904\n        # exact kw\n        ser = Series(\n            [\"19MAY11\", \"foobar19MAY11\", \"19MAY11:00:00:00\", \"19MAY11 00:00:00Z\"]\n        )\n        result = to_datetime(ser, format=\"%d%b%y\", exact=False, cache=cache)\n        expected = to_datetime(\n            ser.str.extract(r\"(\\d+\\w+\\d+)\", expand=False), format=\"%d%b%y\", cache=cache\n        )\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"format, expected\",\n        [\n            (\"%Y-%m-%d\", Timestamp(2000, 1, 3)),\n            (\"%Y-%d-%m\", Timestamp(2000, 3, 1)),\n            (\"%Y-%m-%d %H\", Timestamp(2000, 1, 3, 12)),\n            (\"%Y-%d-%m %H\", Timestamp(2000, 3, 1, 12)),\n            (\"%Y-%m-%d %H:%M\", Timestamp(2000, 1, 3, 12, 34)),\n            (\"%Y-%d-%m %H:%M\", Timestamp(2000, 3, 1, 12, 34)),\n            (\"%Y-%m-%d %H:%M:%S\", Timestamp(2000, 1, 3, 12, 34, 56)),\n            (\"%Y-%d-%m %H:%M:%S\", Timestamp(2000, 3, 1, 12, 34, 56)),\n            (\"%Y-%m-%d %H:%M:%S.%f\", Timestamp(2000, 1, 3, 12, 34, 56, 123456)),\n            (\"%Y-%d-%m %H:%M:%S.%f\", Timestamp(2000, 3, 1, 12, 34, 56, 123456)),\n            (\n                \"%Y-%m-%d %H:%M:%S.%f%z\",\n                Timestamp(2000, 1, 3, 12, 34, 56, 123456, tz=\"UTC+01:00\"),\n            ),\n            (\n                \"%Y-%d-%m %H:%M:%S.%f%z\",\n                Timestamp(2000, 3, 1, 12, 34, 56, 123456, tz=\"UTC+01:00\"),\n            ),\n        ],\n    )\n    def test_non_exact_doesnt_parse_whole_string(self, cache, format, expected):\n        # https://github.com/pandas-dev/pandas/issues/50412\n        # the formats alternate between ISO8601 and non-ISO8601 to check both paths\n        result = to_datetime(\n            \"2000-01-03 12:34:56.123456+01:00\", format=format, exact=False\n        )\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"arg\",\n        [\n            \"2012-01-01 09:00:00.000000001\",\n            \"2012-01-01 09:00:00.000001\",\n            \"2012-01-01 09:00:00.001\",\n            \"2012-01-01 09:00:00.001000\",\n            \"2012-01-01 09:00:00.001000000\",\n        ],\n    )\n    def test_parse_nanoseconds_with_formula(self, cache, arg):\n        # GH8989\n        # truncating the nanoseconds when a format was provided\n        expected = to_datetime(arg, cache=cache)\n        result = to_datetime(arg, format=\"%Y-%m-%d %H:%M:%S.%f\", cache=cache)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"value,fmt,expected\",\n        [\n            [\"2009324\", \"%Y%W%w\", Timestamp(\"2009-08-13\")],\n            [\"2013020\", \"%Y%U%w\", Timestamp(\"2013-01-13\")],\n        ],\n    )\n    def test_to_datetime_format_weeks(self, value, fmt, expected, cache):\n        assert to_datetime(value, format=fmt, cache=cache) == expected\n\n    @pytest.mark.parametrize(\n        \"fmt,dates,expected_dates\",\n        [\n            [\n                \"%Y-%m-%d %H:%M:%S %Z\",\n                [\"2010-01-01 12:00:00 UTC\"] * 2,\n                [Timestamp(\"2010-01-01 12:00:00\", tz=\"UTC\")] * 2,\n            ],\n            [\n                \"%Y-%m-%d %H:%M:%S %Z\",\n                [\n                    \"2010-01-01 12:00:00 UTC\",\n                    \"2010-01-01 12:00:00 GMT\",\n                    \"2010-01-01 12:00:00 US/Pacific\",\n                ],\n                [\n                    Timestamp(\"2010-01-01 12:00:00\", tz=\"UTC\"),\n                    Timestamp(\"2010-01-01 12:00:00\", tz=\"GMT\"),\n                    Timestamp(\"2010-01-01 12:00:00\", tz=\"US/Pacific\"),\n                ],\n            ],\n            [\n                \"%Y-%m-%d %H:%M:%S%z\",\n                [\"2010-01-01 12:00:00+0100\"] * 2,\n                [\n                    Timestamp(\n                        \"2010-01-01 12:00:00\", tzinfo=timezone(timedelta(minutes=60))\n                    )\n                ]\n                * 2,\n            ],\n            [\n                \"%Y-%m-%d %H:%M:%S %z\",\n                [\"2010-01-01 12:00:00 +0100\"] * 2,\n                [\n                    Timestamp(\n                        \"2010-01-01 12:00:00\", tzinfo=timezone(timedelta(minutes=60))\n                    )\n                ]\n                * 2,\n            ],\n            [\n                \"%Y-%m-%d %H:%M:%S %z\",\n                [\"2010-01-01 12:00:00 +0100\", \"2010-01-01 12:00:00 -0100\"],\n                [\n                    Timestamp(\n                        \"2010-01-01 12:00:00\", tzinfo=timezone(timedelta(minutes=60))\n                    ),\n                    Timestamp(\n                        \"2010-01-01 12:00:00\", tzinfo=timezone(timedelta(minutes=-60))\n                    ),\n                ],\n            ],\n            [\n                \"%Y-%m-%d %H:%M:%S %z\",\n                [\"2010-01-01 12:00:00 Z\", \"2010-01-01 12:00:00 Z\"],\n                [\n                    Timestamp(\n                        \"2010-01-01 12:00:00\", tzinfo=pytz.FixedOffset(0)\n                    ),  # pytz coerces to UTC\n                    Timestamp(\"2010-01-01 12:00:00\", tzinfo=pytz.FixedOffset(0)),\n                ],\n            ],\n        ],\n    )\n    def test_to_datetime_parse_tzname_or_tzoffset(self, fmt, dates, expected_dates):\n        # GH 13486\n        result = to_datetime(dates, format=fmt)\n        expected = Index(expected_dates)\n        tm.assert_equal(result, expected)\n\n    def test_to_datetime_parse_tzname_or_tzoffset_different_tz_to_utc(self):\n        # GH 32792\n        dates = [\n            \"2010-01-01 12:00:00 +0100\",\n            \"2010-01-01 12:00:00 -0100\",\n            \"2010-01-01 12:00:00 +0300\",\n            \"2010-01-01 12:00:00 +0400\",\n        ]\n        expected_dates = [\n            \"2010-01-01 11:00:00+00:00\",\n            \"2010-01-01 13:00:00+00:00\",\n            \"2010-01-01 09:00:00+00:00\",\n            \"2010-01-01 08:00:00+00:00\",\n        ]\n        fmt = \"%Y-%m-%d %H:%M:%S %z\"\n\n        result = to_datetime(dates, format=fmt, utc=True)\n        expected = DatetimeIndex(expected_dates)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"offset\", [\"+0\", \"-1foo\", \"UTCbar\", \":10\", \"+01:000:01\", \"\"]\n    )\n    def test_to_datetime_parse_timezone_malformed(self, offset):\n        fmt = \"%Y-%m-%d %H:%M:%S %z\"\n        date = \"2010-01-01 12:00:00 \" + offset\n\n        msg = \"|\".join(\n            [\n                r'^time data \".*\" doesn\\'t match format \".*\", at position 0. '\n                f\"{PARSING_ERR_MSG}$\",\n                r'^unconverted data remains when parsing with format \".*\": \".*\", '\n                f\"at position 0. {PARSING_ERR_MSG}$\",\n            ]\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([date], format=fmt)\n\n    def test_to_datetime_parse_timezone_keeps_name(self):\n        # GH 21697\n        fmt = \"%Y-%m-%d %H:%M:%S %z\"\n        arg = Index([\"2010-01-01 12:00:00 Z\"], name=\"foo\")\n        result = to_datetime(arg, format=fmt)\n        expected = DatetimeIndex([\"2010-01-01 12:00:00\"], tz=\"UTC\", name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n\nclass TestToDatetime:\n    @pytest.mark.filterwarnings(\"ignore:Could not infer format\")\n    def test_to_datetime_overflow(self):\n        # we should get an OutOfBoundsDatetime, NOT OverflowError\n        # TODO: Timestamp raises ValueError(\"could not convert string to Timestamp\")\n        #  can we make these more consistent?\n        arg = \"08335394550\"\n        msg = 'Parsing \"08335394550\" to datetime overflows, at position 0'\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(arg)\n\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime([arg])\n\n        res = to_datetime(arg, errors=\"coerce\")\n        assert res is NaT\n        res = to_datetime([arg], errors=\"coerce\")\n        tm.assert_index_equal(res, Index([NaT]))\n\n        res = to_datetime(arg, errors=\"ignore\")\n        assert isinstance(res, str) and res == arg\n        res = to_datetime([arg], errors=\"ignore\")\n        tm.assert_index_equal(res, Index([arg], dtype=object))\n\n    def test_to_datetime_mixed_datetime_and_string(self):\n        # GH#47018 adapted old doctest with new behavior\n        d1 = datetime(2020, 1, 1, 17, tzinfo=timezone(-timedelta(hours=1)))\n        d2 = datetime(2020, 1, 1, 18, tzinfo=timezone(-timedelta(hours=1)))\n        res = to_datetime([\"2020-01-01 17:00 -0100\", d2])\n        expected = to_datetime([d1, d2]).tz_convert(timezone(timedelta(minutes=-60)))\n        tm.assert_index_equal(res, expected)\n\n    @pytest.mark.parametrize(\n        \"format\", [\"%Y-%m-%d\", \"%Y-%d-%m\"], ids=[\"ISO8601\", \"non-ISO8601\"]\n    )\n    def test_to_datetime_mixed_date_and_string(self, format):\n        # https://github.com/pandas-dev/pandas/issues/50108\n        d1 = date(2020, 1, 2)\n        res = to_datetime([\"2020-01-01\", d1], format=format)\n        expected = DatetimeIndex([\"2020-01-01\", \"2020-01-02\"])\n        tm.assert_index_equal(res, expected)\n\n    @pytest.mark.parametrize(\n        \"fmt\",\n        [\"%Y-%d-%m %H:%M:%S%z\", \"%Y-%m-%d %H:%M:%S%z\"],\n        ids=[\"non-ISO8601 format\", \"ISO8601 format\"],\n    )\n    @pytest.mark.parametrize(\n        \"utc, args, expected\",\n        [\n            pytest.param(\n                True,\n                [\"2000-01-01 01:00:00-08:00\", \"2000-01-01 02:00:00-08:00\"],\n                DatetimeIndex(\n                    [\"2000-01-01 09:00:00+00:00\", \"2000-01-01 10:00:00+00:00\"],\n                    dtype=\"datetime64[ns, UTC]\",\n                ),\n                id=\"all tz-aware, with utc\",\n            ),\n            pytest.param(\n                False,\n                [\"2000-01-01 01:00:00+00:00\", \"2000-01-01 02:00:00+00:00\"],\n                DatetimeIndex(\n                    [\"2000-01-01 01:00:00+00:00\", \"2000-01-01 02:00:00+00:00\"],\n                ),\n                id=\"all tz-aware, without utc\",\n            ),\n            pytest.param(\n                True,\n                [\"2000-01-01 01:00:00-08:00\", \"2000-01-01 02:00:00+00:00\"],\n                DatetimeIndex(\n                    [\"2000-01-01 09:00:00+00:00\", \"2000-01-01 02:00:00+00:00\"],\n                    dtype=\"datetime64[ns, UTC]\",\n                ),\n                id=\"all tz-aware, mixed offsets, with utc\",\n            ),\n            pytest.param(\n                False,\n                [\"2000-01-01 01:00:00\", \"2000-01-01 02:00:00+00:00\"],\n                Index(\n                    [\n                        Timestamp(\"2000-01-01 01:00:00\"),\n                        Timestamp(\"2000-01-01 02:00:00+0000\", tz=\"UTC\"),\n                    ],\n                ),\n                id=\"tz-aware string, naive pydatetime, without utc\",\n            ),\n            pytest.param(\n                True,\n                [\"2000-01-01 01:00:00\", \"2000-01-01 02:00:00+00:00\"],\n                DatetimeIndex(\n                    [\"2000-01-01 01:00:00+00:00\", \"2000-01-01 02:00:00+00:00\"],\n                    dtype=\"datetime64[ns, UTC]\",\n                ),\n                id=\"tz-aware string, naive pydatetime, with utc\",\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\n        \"constructor\",\n        [Timestamp, lambda x: Timestamp(x).to_pydatetime()],\n    )\n    def test_to_datetime_mixed_datetime_and_string_with_format(\n        self, fmt, utc, args, expected, constructor\n    ):\n        # https://github.com/pandas-dev/pandas/issues/49298\n        # https://github.com/pandas-dev/pandas/issues/50254\n        # note: ISO8601 formats go down a fastpath, so we need to check both\n        # a ISO8601 format and a non-ISO8601 one\n        ts1 = constructor(args[0])\n        ts2 = args[1]\n        result = to_datetime([ts1, ts2], format=fmt, utc=utc)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"fmt, utc, expected\",\n        [\n            pytest.param(\n                \"%Y-%m-%d %H:%M:%S%z\",\n                True,\n                DatetimeIndex(\n                    [\"2000-01-01 08:00:00+00:00\", \"2000-01-02 00:00:00+00:00\", \"NaT\"],\n                    dtype=\"datetime64[ns, UTC]\",\n                ),\n                id=\"ISO8601, UTC\",\n            ),\n            pytest.param(\n                \"%Y-%m-%d %H:%M:%S%z\",\n                False,\n                Index(\n                    [\n                        Timestamp(\"2000-01-01 09:00:00+0100\", tz=\"UTC+01:00\"),\n                        Timestamp(\"2000-01-02 02:00:00+0200\", tz=\"UTC+02:00\"),\n                        NaT,\n                    ]\n                ),\n                id=\"ISO8601, non-UTC\",\n            ),\n            pytest.param(\n                \"%Y-%d-%m %H:%M:%S%z\",\n                True,\n                DatetimeIndex(\n                    [\"2000-01-01 08:00:00+00:00\", \"2000-02-01 00:00:00+00:00\", \"NaT\"],\n                    dtype=\"datetime64[ns, UTC]\",\n                ),\n                id=\"non-ISO8601, UTC\",\n            ),\n            pytest.param(\n                \"%Y-%d-%m %H:%M:%S%z\",\n                False,\n                Index(\n                    [\n                        Timestamp(\"2000-01-01 09:00:00+0100\", tz=\"UTC+01:00\"),\n                        Timestamp(\"2000-02-01 02:00:00+0200\", tz=\"UTC+02:00\"),\n                        NaT,\n                    ]\n                ),\n                id=\"non-ISO8601, non-UTC\",\n            ),\n        ],\n    )\n    def test_to_datetime_mixed_offsets_with_none(self, fmt, utc, expected):\n        # https://github.com/pandas-dev/pandas/issues/50071\n        result = to_datetime(\n            [\"2000-01-01 09:00:00+01:00\", \"2000-01-02 02:00:00+02:00\", None],\n            format=fmt,\n            utc=utc,\n        )\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"fmt\",\n        [\"%Y-%d-%m %H:%M:%S%z\", \"%Y-%m-%d %H:%M:%S%z\"],\n        ids=[\"non-ISO8601 format\", \"ISO8601 format\"],\n    )\n    @pytest.mark.parametrize(\n        \"args\",\n        [\n            pytest.param(\n                [\"2000-01-01 01:00:00-08:00\", \"2000-01-01 02:00:00-07:00\"],\n                id=\"all tz-aware, mixed timezones, without utc\",\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\n        \"constructor\",\n        [Timestamp, lambda x: Timestamp(x).to_pydatetime()],\n    )\n    def test_to_datetime_mixed_datetime_and_string_with_format_raises(\n        self, fmt, args, constructor\n    ):\n        # https://github.com/pandas-dev/pandas/issues/49298\n        # note: ISO8601 formats go down a fastpath, so we need to check both\n        # a ISO8601 format and a non-ISO8601 one\n        ts1 = constructor(args[0])\n        ts2 = constructor(args[1])\n        with pytest.raises(\n            ValueError, match=\"cannot be converted to datetime64 unless utc=True\"\n        ):\n            to_datetime([ts1, ts2], format=fmt, utc=False)\n\n    def test_to_datetime_np_str(self):\n        # GH#32264\n        # GH#48969\n        value = np.str_(\"2019-02-04 10:18:46.297000+0000\")\n\n        ser = Series([value])\n\n        exp = Timestamp(\"2019-02-04 10:18:46.297000\", tz=\"UTC\")\n\n        assert to_datetime(value) == exp\n        assert to_datetime(ser.iloc[0]) == exp\n\n        res = to_datetime([value])\n        expected = Index([exp])\n        tm.assert_index_equal(res, expected)\n\n        res = to_datetime(ser)\n        expected = Series(expected)\n        tm.assert_series_equal(res, expected)\n\n    @pytest.mark.parametrize(\n        \"s, _format, dt\",\n        [\n            [\"2015-1-1\", \"%G-%V-%u\", datetime(2014, 12, 29, 0, 0)],\n            [\"2015-1-4\", \"%G-%V-%u\", datetime(2015, 1, 1, 0, 0)],\n            [\"2015-1-7\", \"%G-%V-%u\", datetime(2015, 1, 4, 0, 0)],\n        ],\n    )\n    def test_to_datetime_iso_week_year_format(self, s, _format, dt):\n        # See GH#16607\n        assert to_datetime(s, format=_format) == dt\n\n    @pytest.mark.parametrize(\n        \"msg, s, _format\",\n        [\n            [\n                \"ISO week directive '%V' is incompatible with the year directive \"\n                \"'%Y'. Use the ISO year '%G' instead.\",\n                \"1999 50\",\n                \"%Y %V\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 51\",\n                \"%G %V\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 Monday\",\n                \"%G %A\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 Mon\",\n                \"%G %a\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 6\",\n                \"%G %w\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 6\",\n                \"%G %u\",\n            ],\n            [\n                \"ISO year directive '%G' must be used with the ISO week directive \"\n                \"'%V' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"2051\",\n                \"%G\",\n            ],\n            [\n                \"Day of the year directive '%j' is not compatible with ISO year \"\n                \"directive '%G'. Use '%Y' instead.\",\n                \"1999 51 6 256\",\n                \"%G %V %u %j\",\n            ],\n            [\n                \"ISO week directive '%V' is incompatible with the year directive \"\n                \"'%Y'. Use the ISO year '%G' instead.\",\n                \"1999 51 Sunday\",\n                \"%Y %V %A\",\n            ],\n            [\n                \"ISO week directive '%V' is incompatible with the year directive \"\n                \"'%Y'. Use the ISO year '%G' instead.\",\n                \"1999 51 Sun\",\n                \"%Y %V %a\",\n            ],\n            [\n                \"ISO week directive '%V' is incompatible with the year directive \"\n                \"'%Y'. Use the ISO year '%G' instead.\",\n                \"1999 51 1\",\n                \"%Y %V %w\",\n            ],\n            [\n                \"ISO week directive '%V' is incompatible with the year directive \"\n                \"'%Y'. Use the ISO year '%G' instead.\",\n                \"1999 51 1\",\n                \"%Y %V %u\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"20\",\n                \"%V\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 51 Sunday\",\n                \"%V %A\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 51 Sun\",\n                \"%V %a\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 51 1\",\n                \"%V %w\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"1999 51 1\",\n                \"%V %u\",\n            ],\n            [\n                \"Day of the year directive '%j' is not compatible with ISO year \"\n                \"directive '%G'. Use '%Y' instead.\",\n                \"1999 50\",\n                \"%G %j\",\n            ],\n            [\n                \"ISO week directive '%V' must be used with the ISO year directive \"\n                \"'%G' and a weekday directive '%A', '%a', '%w', or '%u'.\",\n                \"20 Monday\",\n                \"%V %A\",\n            ],\n        ],\n    )\n    @pytest.mark.parametrize(\"errors\", [\"raise\", \"coerce\", \"ignore\"])\n    def test_error_iso_week_year(self, msg, s, _format, errors):\n        # See GH#16607, GH#50308\n        # This test checks for errors thrown when giving the wrong format\n        # However, as discussed on PR#25541, overriding the locale\n        # causes a different error to be thrown due to the format being\n        # locale specific, but the test data is in english.\n        # Therefore, the tests only run when locale is not overwritten,\n        # as a sort of solution to this problem.\n        if locale.getlocale() != (\"zh_CN\", \"UTF-8\") and locale.getlocale() != (\n            \"it_IT\",\n            \"UTF-8\",\n        ):\n            with pytest.raises(ValueError, match=msg):\n                to_datetime(s, format=_format, errors=errors)\n\n    @pytest.mark.parametrize(\"tz\", [None, \"US/Central\"])\n    def test_to_datetime_dtarr(self, tz):\n        # DatetimeArray\n        dti = date_range(\"1965-04-03\", periods=19, freq=\"2W\", tz=tz)\n        arr = DatetimeArray(dti)\n\n        result = to_datetime(arr)\n        assert result is arr\n\n    def test_to_datetime_pydatetime(self):\n        actual = to_datetime(datetime(2008, 1, 15))\n        assert actual == datetime(2008, 1, 15)\n\n    def test_to_datetime_YYYYMMDD(self):\n        actual = to_datetime(\"20080115\")\n        assert actual == datetime(2008, 1, 15)\n\n    def test_to_datetime_unparsable_ignore(self):\n        # unparsable\n        ser = \"Month 1, 1999\"\n        assert to_datetime(ser, errors=\"ignore\") == ser\n\n    @td.skip_if_windows  # `tm.set_timezone` does not work in windows\n    def test_to_datetime_now(self):\n        # See GH#18666\n        with tm.set_timezone(\"US/Eastern\"):\n            # GH#18705\n            now = Timestamp(\"now\")\n            pdnow = to_datetime(\"now\")\n            pdnow2 = to_datetime([\"now\"])[0]\n\n            # These should all be equal with infinite perf; this gives\n            # a generous margin of 10 seconds\n            assert abs(pdnow._value - now._value) < 1e10\n            assert abs(pdnow2._value - now._value) < 1e10\n\n            assert pdnow.tzinfo is None\n            assert pdnow2.tzinfo is None\n\n    @td.skip_if_windows  # `tm.set_timezone` does not work in windows\n    @pytest.mark.parametrize(\"tz\", [\"Pacific/Auckland\", \"US/Samoa\"])\n    def test_to_datetime_today(self, tz):\n        # See GH#18666\n        # Test with one timezone far ahead of UTC and another far behind, so\n        # one of these will _almost_ always be in a different day from UTC.\n        # Unfortunately this test between 12 and 1 AM Samoa time\n        # this both of these timezones _and_ UTC will all be in the same day,\n        # so this test will not detect the regression introduced in #18666.\n        with tm.set_timezone(tz):\n            nptoday = np.datetime64(\"today\").astype(\"datetime64[ns]\").astype(np.int64)\n            pdtoday = to_datetime(\"today\")\n            pdtoday2 = to_datetime([\"today\"])[0]\n\n            tstoday = Timestamp(\"today\")\n            tstoday2 = Timestamp.today().as_unit(\"ns\")\n\n            # These should all be equal with infinite perf; this gives\n            # a generous margin of 10 seconds\n            assert abs(pdtoday.normalize()._value - nptoday) < 1e10\n            assert abs(pdtoday2.normalize()._value - nptoday) < 1e10\n            assert abs(pdtoday._value - tstoday._value) < 1e10\n            assert abs(pdtoday._value - tstoday2._value) < 1e10\n\n            assert pdtoday.tzinfo is None\n            assert pdtoday2.tzinfo is None\n\n    @pytest.mark.parametrize(\"arg\", [\"now\", \"today\"])\n    def test_to_datetime_today_now_unicode_bytes(self, arg):\n        to_datetime([arg])\n\n    @pytest.mark.parametrize(\n        \"format, expected_ds\",\n        [\n            (\"%Y-%m-%d %H:%M:%S%z\", \"2020-01-03\"),\n            (\"%Y-%d-%m %H:%M:%S%z\", \"2020-03-01\"),\n            (None, \"2020-01-03\"),\n        ],\n    )\n    @pytest.mark.parametrize(\n        \"string, attribute\",\n        [\n            (\"now\", \"utcnow\"),\n            (\"today\", \"today\"),\n        ],\n    )\n    def test_to_datetime_now_with_format(self, format, expected_ds, string, attribute):\n        # https://github.com/pandas-dev/pandas/issues/50359\n        result = to_datetime([\"2020-01-03 00:00:00Z\", string], format=format, utc=True)\n        expected = DatetimeIndex(\n            [expected_ds, getattr(Timestamp, attribute)()], dtype=\"datetime64[ns, UTC]\"\n        )\n        assert (expected - result).max().total_seconds() < 1\n\n    @pytest.mark.parametrize(\n        \"dt\", [np.datetime64(\"2000-01-01\"), np.datetime64(\"2000-01-02\")]\n    )\n    def test_to_datetime_dt64s(self, cache, dt):\n        assert to_datetime(dt, cache=cache) == Timestamp(dt)\n\n    @pytest.mark.parametrize(\n        \"arg, format\",\n        [\n            (\"2001-01-01\", \"%Y-%m-%d\"),\n            (\"01-01-2001\", \"%d-%m-%Y\"),\n        ],\n    )\n    def test_to_datetime_dt64s_and_str(self, arg, format):\n        # https://github.com/pandas-dev/pandas/issues/50036\n        result = to_datetime([arg, np.datetime64(\"2020-01-01\")], format=format)\n        expected = DatetimeIndex([\"2001-01-01\", \"2020-01-01\"])\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"dt\", [np.datetime64(\"1000-01-01\"), np.datetime64(\"5000-01-02\")]\n    )\n    @pytest.mark.parametrize(\"errors\", [\"raise\", \"ignore\", \"coerce\"])\n    def test_to_datetime_dt64s_out_of_ns_bounds(self, cache, dt, errors):\n        # GH#50369 We cast to the nearest supported reso, i.e. \"s\"\n        ts = to_datetime(dt, errors=errors, cache=cache)\n        assert isinstance(ts, Timestamp)\n        assert ts.unit == \"s\"\n        assert ts.asm8 == dt\n\n        ts = Timestamp(dt)\n        assert ts.unit == \"s\"\n        assert ts.asm8 == dt\n\n    def test_to_datetime_dt64d_out_of_bounds(self, cache):\n        dt64 = np.datetime64(np.iinfo(np.int64).max, \"D\")\n\n        msg = \"Out of bounds nanosecond timestamp\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            Timestamp(dt64)\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(dt64, errors=\"raise\", cache=cache)\n\n        assert to_datetime(dt64, errors=\"coerce\", cache=cache) is NaT\n\n    @pytest.mark.parametrize(\"unit\", [\"s\", \"D\"])\n    def test_to_datetime_array_of_dt64s(self, cache, unit):\n        # https://github.com/pandas-dev/pandas/issues/31491\n        # Need at least 50 to ensure cache is used.\n        dts = [\n            np.datetime64(\"2000-01-01\", unit),\n            np.datetime64(\"2000-01-02\", unit),\n        ] * 30\n        # Assuming all datetimes are in bounds, to_datetime() returns\n        # an array that is equal to Timestamp() parsing\n        result = to_datetime(dts, cache=cache)\n        if cache:\n            # FIXME: behavior should not depend on cache\n            expected = DatetimeIndex([Timestamp(x).asm8 for x in dts], dtype=\"M8[s]\")\n        else:\n            expected = DatetimeIndex([Timestamp(x).asm8 for x in dts], dtype=\"M8[ns]\")\n\n        tm.assert_index_equal(result, expected)\n\n        # A list of datetimes where the last one is out of bounds\n        dts_with_oob = dts + [np.datetime64(\"9999-01-01\")]\n\n        # As of GH#51978 we do not raise in this case\n        to_datetime(dts_with_oob, errors=\"raise\")\n\n        result = to_datetime(dts_with_oob, errors=\"coerce\", cache=cache)\n        if not cache:\n            # FIXME: shouldn't depend on cache!\n            expected = DatetimeIndex(\n                [Timestamp(dts_with_oob[0]).asm8, Timestamp(dts_with_oob[1]).asm8] * 30\n                + [NaT],\n            )\n        else:\n            expected = DatetimeIndex(np.array(dts_with_oob, dtype=\"M8[s]\"))\n        tm.assert_index_equal(result, expected)\n\n        # With errors='ignore', out of bounds datetime64s\n        # are converted to their .item(), which depending on the version of\n        # numpy is either a python datetime.datetime or datetime.date\n        result = to_datetime(dts_with_oob, errors=\"ignore\", cache=cache)\n        if not cache:\n            # FIXME: shouldn't depend on cache!\n            expected = Index(dts_with_oob)\n        tm.assert_index_equal(result, expected)\n\n    def test_out_of_bounds_errors_ignore(self):\n        # https://github.com/pandas-dev/pandas/issues/50587\n        result = to_datetime(np.datetime64(\"9999-01-01\"), errors=\"ignore\")\n        expected = np.datetime64(\"9999-01-01\")\n        assert result == expected\n\n    def test_to_datetime_tz(self, cache):\n        # xref 8260\n        # uniform returns a DatetimeIndex\n        arr = [\n            Timestamp(\"2013-01-01 13:00:00-0800\", tz=\"US/Pacific\"),\n            Timestamp(\"2013-01-02 14:00:00-0800\", tz=\"US/Pacific\"),\n        ]\n        result = to_datetime(arr, cache=cache)\n        expected = DatetimeIndex(\n            [\"2013-01-01 13:00:00\", \"2013-01-02 14:00:00\"], tz=\"US/Pacific\"\n        )\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_tz_mixed(self, cache):\n        # mixed tzs will raise if errors='raise'\n        # https://github.com/pandas-dev/pandas/issues/50585\n        arr = [\n            Timestamp(\"2013-01-01 13:00:00\", tz=\"US/Pacific\"),\n            Timestamp(\"2013-01-02 14:00:00\", tz=\"US/Eastern\"),\n        ]\n        msg = (\n            \"Tz-aware datetime.datetime cannot be \"\n            \"converted to datetime64 unless utc=True\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(arr, cache=cache)\n\n        result = to_datetime(arr, cache=cache, errors=\"ignore\")\n        expected = Index(\n            [\n                Timestamp(\"2013-01-01 13:00:00-08:00\"),\n                Timestamp(\"2013-01-02 14:00:00-05:00\"),\n            ],\n            dtype=\"object\",\n        )\n        tm.assert_index_equal(result, expected)\n        result = to_datetime(arr, cache=cache, errors=\"coerce\")\n        expected = DatetimeIndex(\n            [\"2013-01-01 13:00:00-08:00\", \"NaT\"], dtype=\"datetime64[ns, US/Pacific]\"\n        )\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_different_offsets(self, cache):\n        # inspired by asv timeseries.ToDatetimeNONISO8601 benchmark\n        # see GH-26097 for more\n        ts_string_1 = \"March 1, 2018 12:00:00+0400\"\n        ts_string_2 = \"March 1, 2018 12:00:00+0500\"\n        arr = [ts_string_1] * 5 + [ts_string_2] * 5\n        expected = Index([parse(x) for x in arr])\n        result = to_datetime(arr, cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_tz_pytz(self, cache):\n        # see gh-8260\n        us_eastern = pytz.timezone(\"US/Eastern\")\n        arr = np.array(\n            [\n                us_eastern.localize(\n                    datetime(year=2000, month=1, day=1, hour=3, minute=0)\n                ),\n                us_eastern.localize(\n                    datetime(year=2000, month=6, day=1, hour=3, minute=0)\n                ),\n            ],\n            dtype=object,\n        )\n        result = to_datetime(arr, utc=True, cache=cache)\n        expected = DatetimeIndex(\n            [\"2000-01-01 08:00:00+00:00\", \"2000-06-01 07:00:00+00:00\"],\n            dtype=\"datetime64[ns, UTC]\",\n            freq=None,\n        )\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"init_constructor, end_constructor\",\n        [\n            (Index, DatetimeIndex),\n            (list, DatetimeIndex),\n            (np.array, DatetimeIndex),\n            (Series, Series),\n        ],\n    )\n    def test_to_datetime_utc_true(self, cache, init_constructor, end_constructor):\n        # See gh-11934 & gh-6415\n        data = [\"20100102 121314\", \"20100102 121315\"]\n        expected_data = [\n            Timestamp(\"2010-01-02 12:13:14\", tz=\"utc\"),\n            Timestamp(\"2010-01-02 12:13:15\", tz=\"utc\"),\n        ]\n\n        result = to_datetime(\n            init_constructor(data), format=\"%Y%m%d %H%M%S\", utc=True, cache=cache\n        )\n        expected = end_constructor(expected_data)\n        tm.assert_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"scalar, expected\",\n        [\n            [\"20100102 121314\", Timestamp(\"2010-01-02 12:13:14\", tz=\"utc\")],\n            [\"20100102 121315\", Timestamp(\"2010-01-02 12:13:15\", tz=\"utc\")],\n        ],\n    )\n    def test_to_datetime_utc_true_scalar(self, cache, scalar, expected):\n        # Test scalar case as well\n        result = to_datetime(scalar, format=\"%Y%m%d %H%M%S\", utc=True, cache=cache)\n        assert result == expected\n\n    def test_to_datetime_utc_true_with_series_single_value(self, cache):\n        # GH 15760 UTC=True with Series\n        ts = 1.5e18\n        result = to_datetime(Series([ts]), utc=True, cache=cache)\n        expected = Series([Timestamp(ts, tz=\"utc\")])\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_utc_true_with_series_tzaware_string(self, cache):\n        ts = \"2013-01-01 00:00:00-01:00\"\n        expected_ts = \"2013-01-01 01:00:00\"\n        data = Series([ts] * 3)\n        result = to_datetime(data, utc=True, cache=cache)\n        expected = Series([Timestamp(expected_ts, tz=\"utc\")] * 3)\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"date, dtype\",\n        [\n            (\"2013-01-01 01:00:00\", \"datetime64[ns]\"),\n            (\"2013-01-01 01:00:00\", \"datetime64[ns, UTC]\"),\n        ],\n    )\n    def test_to_datetime_utc_true_with_series_datetime_ns(self, cache, date, dtype):\n        expected = Series([Timestamp(\"2013-01-01 01:00:00\", tz=\"UTC\")])\n        result = to_datetime(Series([date], dtype=dtype), utc=True, cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_tz_psycopg2(self, request, cache):\n        # xref 8260\n        psycopg2_tz = pytest.importorskip(\"psycopg2.tz\")\n\n        # misc cases\n        tz1 = psycopg2_tz.FixedOffsetTimezone(offset=-300, name=None)\n        tz2 = psycopg2_tz.FixedOffsetTimezone(offset=-240, name=None)\n        arr = np.array(\n            [\n                datetime(2000, 1, 1, 3, 0, tzinfo=tz1),\n                datetime(2000, 6, 1, 3, 0, tzinfo=tz2),\n            ],\n            dtype=object,\n        )\n\n        result = to_datetime(arr, errors=\"coerce\", utc=True, cache=cache)\n        expected = DatetimeIndex(\n            [\"2000-01-01 08:00:00+00:00\", \"2000-06-01 07:00:00+00:00\"],\n            dtype=\"datetime64[ns, UTC]\",\n            freq=None,\n        )\n        tm.assert_index_equal(result, expected)\n\n        # dtype coercion\n        i = DatetimeIndex(\n            [\"2000-01-01 08:00:00\"],\n            tz=psycopg2_tz.FixedOffsetTimezone(offset=-300, name=None),\n        )\n        assert is_datetime64_ns_dtype(i)\n\n        # tz coercion\n        result = to_datetime(i, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, i)\n\n        result = to_datetime(i, errors=\"coerce\", utc=True, cache=cache)\n        expected = DatetimeIndex([\"2000-01-01 13:00:00\"], dtype=\"datetime64[ns, UTC]\")\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\"arg\", [True, False])\n    def test_datetime_bool(self, cache, arg):\n        # GH13176\n        msg = r\"dtype bool cannot be converted to datetime64\\[ns\\]\"\n        with pytest.raises(TypeError, match=msg):\n            to_datetime(arg)\n        assert to_datetime(arg, errors=\"coerce\", cache=cache) is NaT\n        assert to_datetime(arg, errors=\"ignore\", cache=cache) is arg\n\n    def test_datetime_bool_arrays_mixed(self, cache):\n        msg = f\"{type(cache)} is not convertible to datetime\"\n        with pytest.raises(TypeError, match=msg):\n            to_datetime([False, datetime.today()], cache=cache)\n        with pytest.raises(\n            ValueError,\n            match=(\n                r'^time data \"True\" doesn\\'t match format \"%Y%m%d\", '\n                f\"at position 1. {PARSING_ERR_MSG}$\"\n            ),\n        ):\n            to_datetime([\"20130101\", True], cache=cache)\n        tm.assert_index_equal(\n            to_datetime([0, False, NaT, 0.0], errors=\"coerce\", cache=cache),\n            DatetimeIndex(\n                [to_datetime(0, cache=cache), NaT, NaT, to_datetime(0, cache=cache)]\n            ),\n        )\n\n    @pytest.mark.parametrize(\"arg\", [bool, to_datetime])\n    def test_datetime_invalid_datatype(self, arg):\n        # GH13176\n        msg = \"is not convertible to datetime\"\n        with pytest.raises(TypeError, match=msg):\n            to_datetime(arg)\n\n    @pytest.mark.parametrize(\"errors\", [\"coerce\", \"raise\", \"ignore\"])\n    def test_invalid_format_raises(self, errors):\n        # https://github.com/pandas-dev/pandas/issues/50255\n        with pytest.raises(\n            ValueError, match=\"':' is a bad directive in format 'H%:M%:S%\"\n        ):\n            to_datetime([\"00:00:00\"], format=\"H%:M%:S%\", errors=errors)\n\n    @pytest.mark.parametrize(\"value\", [\"a\", \"00:01:99\"])\n    @pytest.mark.parametrize(\"format\", [None, \"%H:%M:%S\"])\n    def test_datetime_invalid_scalar(self, value, format):\n        # GH24763\n        res = to_datetime(value, errors=\"ignore\", format=format)\n        assert res == value\n\n        res = to_datetime(value, errors=\"coerce\", format=format)\n        assert res is NaT\n\n        msg = \"|\".join(\n            [\n                r'^time data \"a\" doesn\\'t match format \"%H:%M:%S\", at position 0. '\n                f\"{PARSING_ERR_MSG}$\",\n                r'^Given date string \"a\" not likely a datetime, at position 0$',\n                r'^unconverted data remains when parsing with format \"%H:%M:%S\": \"9\", '\n                f\"at position 0. {PARSING_ERR_MSG}$\",\n                r\"^second must be in 0..59: 00:01:99, at position 0$\",\n            ]\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(value, errors=\"raise\", format=format)\n\n    @pytest.mark.parametrize(\"value\", [\"3000/12/11 00:00:00\"])\n    @pytest.mark.parametrize(\"format\", [None, \"%H:%M:%S\"])\n    def test_datetime_outofbounds_scalar(self, value, format):\n        # GH24763\n        res = to_datetime(value, errors=\"ignore\", format=format)\n        assert res == value\n\n        res = to_datetime(value, errors=\"coerce\", format=format)\n        assert res is NaT\n\n        if format is not None:\n            msg = r'^time data \".*\" doesn\\'t match format \".*\", at position 0.'\n            with pytest.raises(ValueError, match=msg):\n                to_datetime(value, errors=\"raise\", format=format)\n        else:\n            msg = \"^Out of bounds .*, at position 0$\"\n            with pytest.raises(OutOfBoundsDatetime, match=msg):\n                to_datetime(value, errors=\"raise\", format=format)\n\n    @pytest.mark.parametrize(\n        (\"values\"), [([\"a\"]), ([\"00:01:99\"]), ([\"a\", \"b\", \"99:00:00\"])]\n    )\n    @pytest.mark.parametrize(\"format\", [(None), (\"%H:%M:%S\")])\n    def test_datetime_invalid_index(self, values, format):\n        # GH24763\n        # Not great to have logic in tests, but this one's hard to\n        # parametrise over\n        if format is None and len(values) > 1:\n            warn = UserWarning\n        else:\n            warn = None\n        with tm.assert_produces_warning(warn, match=\"Could not infer format\"):\n            res = to_datetime(values, errors=\"ignore\", format=format)\n        tm.assert_index_equal(res, Index(values))\n\n        with tm.assert_produces_warning(warn, match=\"Could not infer format\"):\n            res = to_datetime(values, errors=\"coerce\", format=format)\n        tm.assert_index_equal(res, DatetimeIndex([NaT] * len(values)))\n\n        msg = \"|\".join(\n            [\n                r'^Given date string \"a\" not likely a datetime, at position 0$',\n                r'^time data \"a\" doesn\\'t match format \"%H:%M:%S\", at position 0. '\n                f\"{PARSING_ERR_MSG}$\",\n                r'^unconverted data remains when parsing with format \"%H:%M:%S\": \"9\", '\n                f\"at position 0. {PARSING_ERR_MSG}$\",\n                r\"^second must be in 0..59: 00:01:99, at position 0$\",\n            ]\n        )\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(warn, match=\"Could not infer format\"):\n                to_datetime(values, errors=\"raise\", format=format)\n\n    @pytest.mark.parametrize(\"utc\", [True, None])\n    @pytest.mark.parametrize(\"format\", [\"%Y%m%d %H:%M:%S\", None])\n    @pytest.mark.parametrize(\"constructor\", [list, tuple, np.array, Index, deque])\n    def test_to_datetime_cache(self, utc, format, constructor):\n        date = \"20130101 00:00:00\"\n        test_dates = [date] * 10**5\n        data = constructor(test_dates)\n\n        result = to_datetime(data, utc=utc, format=format, cache=True)\n        expected = to_datetime(data, utc=utc, format=format, cache=False)\n\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_from_deque(self):\n        # GH 29403\n        result = to_datetime(deque([Timestamp(\"2010-06-02 09:30:00\")] * 51))\n        expected = to_datetime([Timestamp(\"2010-06-02 09:30:00\")] * 51)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\"utc\", [True, None])\n    @pytest.mark.parametrize(\"format\", [\"%Y%m%d %H:%M:%S\", None])\n    def test_to_datetime_cache_series(self, utc, format):\n        date = \"20130101 00:00:00\"\n        test_dates = [date] * 10**5\n        data = Series(test_dates)\n        result = to_datetime(data, utc=utc, format=format, cache=True)\n        expected = to_datetime(data, utc=utc, format=format, cache=False)\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_cache_scalar(self):\n        date = \"20130101 00:00:00\"\n        result = to_datetime(date, cache=True)\n        expected = Timestamp(\"20130101 00:00:00\")\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"datetimelikes,expected_values\",\n        (\n            (\n                (None, np.nan) + (NaT,) * start_caching_at,\n                (NaT,) * (start_caching_at + 2),\n            ),\n            (\n                (None, Timestamp(\"2012-07-26\")) + (NaT,) * start_caching_at,\n                (NaT, Timestamp(\"2012-07-26\")) + (NaT,) * start_caching_at,\n            ),\n            (\n                (None,)\n                + (NaT,) * start_caching_at\n                + (\"2012 July 26\", Timestamp(\"2012-07-26\")),\n                (NaT,) * (start_caching_at + 1)\n                + (Timestamp(\"2012-07-26\"), Timestamp(\"2012-07-26\")),\n            ),\n        ),\n    )\n    def test_convert_object_to_datetime_with_cache(\n        self, datetimelikes, expected_values\n    ):\n        # GH#39882\n        ser = Series(\n            datetimelikes,\n            dtype=\"object\",\n        )\n        result_series = to_datetime(ser, errors=\"coerce\")\n        expected_series = Series(\n            expected_values,\n            dtype=\"datetime64[ns]\",\n        )\n        tm.assert_series_equal(result_series, expected_series)\n\n    @pytest.mark.parametrize(\"cache\", [True, False])\n    @pytest.mark.parametrize(\n        (\"input\", \"expected\"),\n        (\n            (\n                Series([NaT] * 20 + [None] * 20, dtype=\"object\"),\n                Series([NaT] * 40, dtype=\"datetime64[ns]\"),\n            ),\n            (\n                Series([NaT] * 60 + [None] * 60, dtype=\"object\"),\n                Series([NaT] * 120, dtype=\"datetime64[ns]\"),\n            ),\n            (Series([None] * 20), Series([NaT] * 20, dtype=\"datetime64[ns]\")),\n            (Series([None] * 60), Series([NaT] * 60, dtype=\"datetime64[ns]\")),\n            (Series([\"\"] * 20), Series([NaT] * 20, dtype=\"datetime64[ns]\")),\n            (Series([\"\"] * 60), Series([NaT] * 60, dtype=\"datetime64[ns]\")),\n            (Series([pd.NA] * 20), Series([NaT] * 20, dtype=\"datetime64[ns]\")),\n            (Series([pd.NA] * 60), Series([NaT] * 60, dtype=\"datetime64[ns]\")),\n            (Series([np.NaN] * 20), Series([NaT] * 20, dtype=\"datetime64[ns]\")),\n            (Series([np.NaN] * 60), Series([NaT] * 60, dtype=\"datetime64[ns]\")),\n        ),\n    )\n    def test_to_datetime_converts_null_like_to_nat(self, cache, input, expected):\n        # GH35888\n        result = to_datetime(input, cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"date, format\",\n        [\n            (\"2017-20\", \"%Y-%W\"),\n            (\"20 Sunday\", \"%W %A\"),\n            (\"20 Sun\", \"%W %a\"),\n            (\"2017-21\", \"%Y-%U\"),\n            (\"20 Sunday\", \"%U %A\"),\n            (\"20 Sun\", \"%U %a\"),\n        ],\n    )\n    def test_week_without_day_and_calendar_year(self, date, format):\n        # GH16774\n\n        msg = \"Cannot use '%W' or '%U' without day and year\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(date, format=format)\n\n    def test_to_datetime_coerce(self):\n        # GH 26122\n        ts_strings = [\n            \"March 1, 2018 12:00:00+0400\",\n            \"March 1, 2018 12:00:00+0500\",\n            \"20100240\",\n        ]\n        result = to_datetime(ts_strings, errors=\"coerce\")\n        expected = Index(\n            [\n                datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 14400)),\n                datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 18000)),\n                NaT,\n            ]\n        )\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"string_arg, format\",\n        [(\"March 1, 2018\", \"%B %d, %Y\"), (\"2018-03-01\", \"%Y-%m-%d\")],\n    )\n    @pytest.mark.parametrize(\n        \"outofbounds\",\n        [\n            datetime(9999, 1, 1),\n            date(9999, 1, 1),\n            np.datetime64(\"9999-01-01\"),\n            \"January 1, 9999\",\n            \"9999-01-01\",\n        ],\n    )\n    def test_to_datetime_coerce_oob(self, string_arg, format, outofbounds):\n        # https://github.com/pandas-dev/pandas/issues/50255\n        ts_strings = [string_arg, outofbounds]\n        result = to_datetime(ts_strings, errors=\"coerce\", format=format)\n        expected = DatetimeIndex([datetime(2018, 3, 1), NaT])\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"errors, expected\",\n        [\n            (\"coerce\", Index([NaT, NaT])),\n            (\"ignore\", Index([\"200622-12-31\", \"111111-24-11\"])),\n        ],\n    )\n    def test_to_datetime_malformed_no_raise(self, errors, expected):\n        # GH 28299\n        # GH 48633\n        ts_strings = [\"200622-12-31\", \"111111-24-11\"]\n        with tm.assert_produces_warning(UserWarning, match=\"Could not infer format\"):\n            result = to_datetime(ts_strings, errors=errors)\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_malformed_raise(self):\n        # GH 48633\n        ts_strings = [\"200622-12-31\", \"111111-24-11\"]\n        msg = (\n            'Parsed string \"200622-12-31\" gives an invalid tzoffset, which must '\n            r\"be between -timedelta\\(hours=24\\) and timedelta\\(hours=24\\), \"\n            \"at position 0\"\n        )\n        with pytest.raises(\n            ValueError,\n            match=msg,\n        ):\n            with tm.assert_produces_warning(\n                UserWarning, match=\"Could not infer format\"\n            ):\n                to_datetime(\n                    ts_strings,\n                    errors=\"raise\",\n                )\n\n    def test_iso_8601_strings_with_same_offset(self):\n        # GH 17697, 11736\n        ts_str = \"2015-11-18 15:30:00+05:30\"\n        result = to_datetime(ts_str)\n        expected = Timestamp(ts_str)\n        assert result == expected\n\n        expected = DatetimeIndex([Timestamp(ts_str)] * 2)\n        result = to_datetime([ts_str] * 2)\n        tm.assert_index_equal(result, expected)\n\n        result = DatetimeIndex([ts_str] * 2)\n        tm.assert_index_equal(result, expected)\n\n    def test_iso_8601_strings_with_different_offsets(self):\n        # GH 17697, 11736\n        ts_strings = [\"2015-11-18 15:30:00+05:30\", \"2015-11-18 16:30:00+06:30\", NaT]\n        result = to_datetime(ts_strings)\n        expected = np.array(\n            [\n                datetime(2015, 11, 18, 15, 30, tzinfo=tzoffset(None, 19800)),\n                datetime(2015, 11, 18, 16, 30, tzinfo=tzoffset(None, 23400)),\n                NaT,\n            ],\n            dtype=object,\n        )\n        # GH 21864\n        expected = Index(expected)\n        tm.assert_index_equal(result, expected)\n\n    def test_iso_8601_strings_with_different_offsets_utc(self):\n        ts_strings = [\"2015-11-18 15:30:00+05:30\", \"2015-11-18 16:30:00+06:30\", NaT]\n        result = to_datetime(ts_strings, utc=True)\n        expected = DatetimeIndex(\n            [Timestamp(2015, 11, 18, 10), Timestamp(2015, 11, 18, 10), NaT], tz=\"UTC\"\n        )\n        tm.assert_index_equal(result, expected)\n\n    def test_mixed_offsets_with_native_datetime_raises(self):\n        # GH 25978\n\n        vals = [\n            \"nan\",\n            Timestamp(\"1990-01-01\"),\n            \"2015-03-14T16:15:14.123-08:00\",\n            \"2019-03-04T21:56:32.620-07:00\",\n            None,\n            \"today\",\n            \"now\",\n        ]\n        ser = Series(vals)\n        assert all(ser[i] is vals[i] for i in range(len(vals)))  # GH#40111\n\n        now = Timestamp(\"now\")\n        today = Timestamp(\"today\")\n        mixed = to_datetime(ser)\n        expected = Series(\n            [\n                \"NaT\",\n                Timestamp(\"1990-01-01\"),\n                Timestamp(\"2015-03-14T16:15:14.123-08:00\").to_pydatetime(),\n                Timestamp(\"2019-03-04T21:56:32.620-07:00\").to_pydatetime(),\n                None,\n            ],\n            dtype=object,\n        )\n        tm.assert_series_equal(mixed[:-2], expected)\n        # we'll check mixed[-1] and mixed[-2] match now and today to within\n        # call-timing tolerances\n        assert (now - mixed.iloc[-1]).total_seconds() <= 0.1\n        assert (today - mixed.iloc[-2]).total_seconds() <= 0.1\n\n        with pytest.raises(ValueError, match=\"Tz-aware datetime.datetime\"):\n            to_datetime(mixed)\n\n    def test_non_iso_strings_with_tz_offset(self):\n        result = to_datetime([\"March 1, 2018 12:00:00+0400\"] * 2)\n        expected = DatetimeIndex(\n            [datetime(2018, 3, 1, 12, tzinfo=timezone(timedelta(minutes=240)))] * 2\n        )\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"ts, expected\",\n        [\n            (Timestamp(\"2018-01-01\"), Timestamp(\"2018-01-01\", tz=\"UTC\")),\n            (\n                Timestamp(\"2018-01-01\", tz=\"US/Pacific\"),\n                Timestamp(\"2018-01-01 08:00\", tz=\"UTC\"),\n            ),\n        ],\n    )\n    def test_timestamp_utc_true(self, ts, expected):\n        # GH 24415\n        result = to_datetime(ts, utc=True)\n        assert result == expected\n\n    @pytest.mark.parametrize(\"dt_str\", [\"00010101\", \"13000101\", \"30000101\", \"99990101\"])\n    def test_to_datetime_with_format_out_of_bounds(self, dt_str):\n        # GH 9107\n        msg = \"Out of bounds nanosecond timestamp\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(dt_str, format=\"%Y%m%d\")\n\n    def test_to_datetime_utc(self):\n        arr = np.array([parse(\"2012-06-13T01:39:00Z\")], dtype=object)\n\n        result = to_datetime(arr, utc=True)\n        assert result.tz is timezone.utc\n\n    def test_to_datetime_fixed_offset(self):\n        from pandas.tests.indexes.datetimes.test_timezones import fixed_off\n\n        dates = [\n            datetime(2000, 1, 1, tzinfo=fixed_off),\n            datetime(2000, 1, 2, tzinfo=fixed_off),\n            datetime(2000, 1, 3, tzinfo=fixed_off),\n        ]\n        result = to_datetime(dates)\n        assert result.tz == fixed_off\n\n\nclass TestToDatetimeUnit:\n    @pytest.mark.parametrize(\"unit\", [\"Y\", \"M\"])\n    @pytest.mark.parametrize(\"item\", [150, float(150)])\n    def test_to_datetime_month_or_year_unit_int(self, cache, unit, item):\n        # GH#50870 Note we have separate tests that pd.Timestamp gets these right\n        ts = Timestamp(item, unit=unit)\n        expected = DatetimeIndex([ts])\n\n        result = to_datetime([item], unit=unit, cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        # TODO: this should also work\n        #  result = to_datetime(np.array([item]), unit=unit, cache=cache)\n        #  tm.assert_index_equal(result, expected)\n\n        result = to_datetime(np.array([item], dtype=object), unit=unit, cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\"unit\", [\"Y\", \"M\"])\n    def test_to_datetime_month_or_year_unit_non_round_float(self, cache, unit):\n        # GH#50301\n        # Match Timestamp behavior in disallowing non-round floats with\n        #  Y or M unit\n        warn_msg = \"strings will be parsed as datetime strings\"\n        msg = f\"Conversion of non-round float with unit={unit} is ambiguous\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1.5], unit=unit, errors=\"raise\")\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(FutureWarning, match=warn_msg):\n                to_datetime([\"1.5\"], unit=unit, errors=\"raise\")\n\n        # with errors=\"ignore\" we also end up raising within the Timestamp\n        #  constructor; this may not be ideal\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1.5], unit=unit, errors=\"ignore\")\n        # TODO: we are NOT consistent with the Timestamp behavior in the\n        #  float-like string case\n        # with pytest.raises(ValueError, match=msg):\n        #    to_datetime([\"1.5\"], unit=unit, errors=\"ignore\")\n\n        res = to_datetime([1.5], unit=unit, errors=\"coerce\")\n        expected = Index([NaT], dtype=\"M8[ns]\")\n        tm.assert_index_equal(res, expected)\n\n        with tm.assert_produces_warning(FutureWarning, match=warn_msg):\n            res = to_datetime([\"1.5\"], unit=unit, errors=\"coerce\")\n        tm.assert_index_equal(res, expected)\n\n        # round floats are OK\n        res = to_datetime([1.0], unit=unit)\n        expected = to_datetime([1], unit=unit)\n        tm.assert_index_equal(res, expected)\n\n    def test_unit(self, cache):\n        # GH 11758\n        # test proper behavior with errors\n        msg = \"cannot specify both format and unit\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1], unit=\"D\", format=\"%Y%m%d\", cache=cache)\n\n    def test_unit_array_mixed_nans(self, cache):\n        values = [11111111111111111, 1, 1.0, iNaT, NaT, np.nan, \"NaT\", \"\"]\n        result = to_datetime(values, unit=\"D\", errors=\"ignore\", cache=cache)\n        expected = Index(\n            [\n                11111111111111111,\n                Timestamp(\"1970-01-02\"),\n                Timestamp(\"1970-01-02\"),\n                NaT,\n                NaT,\n                NaT,\n                NaT,\n                NaT,\n            ],\n            dtype=object,\n        )\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime(values, unit=\"D\", errors=\"coerce\", cache=cache)\n        expected = DatetimeIndex(\n            [\"NaT\", \"1970-01-02\", \"1970-01-02\", \"NaT\", \"NaT\", \"NaT\", \"NaT\", \"NaT\"]\n        )\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot convert input 11111111111111111 with the unit 'D'\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(values, unit=\"D\", errors=\"raise\", cache=cache)\n\n    def test_unit_array_mixed_nans_large_int(self, cache):\n        values = [1420043460000000000000000, iNaT, NaT, np.nan, \"NaT\"]\n\n        result = to_datetime(values, errors=\"ignore\", unit=\"s\", cache=cache)\n        expected = Index([1420043460000000000000000, NaT, NaT, NaT, NaT], dtype=object)\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime(values, errors=\"coerce\", unit=\"s\", cache=cache)\n        expected = DatetimeIndex([\"NaT\", \"NaT\", \"NaT\", \"NaT\", \"NaT\"])\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot convert input 1420043460000000000000000 with the unit 's'\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(values, errors=\"raise\", unit=\"s\", cache=cache)\n\n    def test_to_datetime_invalid_str_not_out_of_bounds_valuerror(self, cache):\n        # if we have a string, then we raise a ValueError\n        # and NOT an OutOfBoundsDatetime\n        msg = \"non convertible value foo with the unit 's'\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"foo\", errors=\"raise\", unit=\"s\", cache=cache)\n\n    @pytest.mark.parametrize(\"error\", [\"raise\", \"coerce\", \"ignore\"])\n    def test_unit_consistency(self, cache, error):\n        # consistency of conversions\n        expected = Timestamp(\"1970-05-09 14:25:11\")\n        result = to_datetime(11111111, unit=\"s\", errors=error, cache=cache)\n        assert result == expected\n        assert isinstance(result, Timestamp)\n\n    @pytest.mark.parametrize(\"errors\", [\"ignore\", \"raise\", \"coerce\"])\n    @pytest.mark.parametrize(\"dtype\", [\"float64\", \"int64\"])\n    def test_unit_with_numeric(self, cache, errors, dtype):\n        # GH 13180\n        # coercions from floats/ints are ok\n        expected = DatetimeIndex([\"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\"])\n        arr = np.array([1.434692e18, 1.432766e18]).astype(dtype)\n        result = to_datetime(arr, errors=errors, cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"exp, arr, warning\",\n        [\n            [\n                [\"NaT\", \"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\"],\n                [\"foo\", 1.434692e18, 1.432766e18],\n                UserWarning,\n            ],\n            [\n                [\"2015-06-19 05:33:20\", \"2015-05-27 22:33:20\", \"NaT\", \"NaT\"],\n                [1.434692e18, 1.432766e18, \"foo\", \"NaT\"],\n                None,\n            ],\n        ],\n    )\n    def test_unit_with_numeric_coerce(self, cache, exp, arr, warning):\n        # but we want to make sure that we are coercing\n        # if we have ints/strings\n        expected = DatetimeIndex(exp)\n        with tm.assert_produces_warning(warning, match=\"Could not infer format\"):\n            result = to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"arr\",\n        [\n            [Timestamp(\"20130101\"), 1.434692e18, 1.432766e18],\n            [1.434692e18, 1.432766e18, Timestamp(\"20130101\")],\n        ],\n    )\n    def test_unit_mixed(self, cache, arr):\n        # GH#50453 pre-2.0 with mixed numeric/datetimes and errors=\"coerce\"\n        #  the numeric entries would be coerced to NaT, was never clear exactly\n        #  why.\n        # mixed integers/datetimes\n        expected = Index([Timestamp(x) for x in arr], dtype=\"M8[ns]\")\n        result = to_datetime(arr, errors=\"coerce\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        # GH#49037 pre-2.0 this raised, but it always worked with Series,\n        #  was never clear why it was disallowed\n        result = to_datetime(arr, errors=\"raise\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n        result = DatetimeIndex(arr)\n        tm.assert_index_equal(result, expected)\n\n    def test_unit_rounding(self, cache):\n        # GH 14156 & GH 20445: argument will incur floating point errors\n        # but no premature rounding\n        result = to_datetime(1434743731.8770001, unit=\"s\", cache=cache)\n        expected = Timestamp(\"2015-06-19 19:55:31.877000192\")\n        assert result == expected\n\n    def test_unit_ignore_keeps_name(self, cache):\n        # GH 21697\n        expected = Index([15e9] * 2, name=\"name\")\n        result = to_datetime(expected, errors=\"ignore\", unit=\"s\", cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    def test_to_datetime_errors_ignore_utc_true(self):\n        # GH#23758\n        result = to_datetime([1], unit=\"s\", utc=True, errors=\"ignore\")\n        expected = DatetimeIndex([\"1970-01-01 00:00:01\"], tz=\"UTC\")\n        tm.assert_index_equal(result, expected)\n\n    # TODO: this is moved from tests.series.test_timeseries, may be redundant\n    @pytest.mark.parametrize(\"dtype\", [int, float])\n    def test_to_datetime_unit(self, dtype):\n        epoch = 1370745748\n        ser = Series([epoch + t for t in range(20)]).astype(dtype)\n        result = to_datetime(ser, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n        )\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"null\", [iNaT, np.nan])\n    def test_to_datetime_unit_with_nulls(self, null):\n        epoch = 1370745748\n        ser = Series([epoch + t for t in range(20)] + [null])\n        result = to_datetime(ser, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n            + [NaT]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_unit_fractional_seconds(self):\n        # GH13834\n        epoch = 1370745748\n        ser = Series([epoch + t for t in np.arange(0, 2, 0.25)] + [iNaT]).astype(float)\n        result = to_datetime(ser, unit=\"s\")\n        expected = Series(\n            [\n                Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t)\n                for t in np.arange(0, 2, 0.25)\n            ]\n            + [NaT]\n        )\n        # GH20455 argument will incur floating point errors but no premature rounding\n        result = result.round(\"ms\")\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_unit_na_values(self):\n        result = to_datetime([1, 2, \"NaT\", NaT, np.nan], unit=\"D\")\n        expected = DatetimeIndex(\n            [Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")] + [\"NaT\"] * 3\n        )\n        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize(\"bad_val\", [\"foo\", 111111111])\n    def test_to_datetime_unit_invalid(self, bad_val):\n        msg = f\"{bad_val} with the unit 'D'\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1, 2, bad_val], unit=\"D\")\n\n    @pytest.mark.parametrize(\"bad_val\", [\"foo\", 111111111])\n    def test_to_timestamp_unit_coerce(self, bad_val):\n        # coerce we can process\n        expected = DatetimeIndex(\n            [Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")] + [\"NaT\"] * 1\n        )\n        result = to_datetime([1, 2, bad_val], unit=\"D\", errors=\"coerce\")\n        tm.assert_index_equal(result, expected)\n\n    def test_float_to_datetime_raise_near_bounds(self):\n        # GH50183\n        msg = \"cannot convert input with unit 'D'\"\n        oneday_in_ns = 1e9 * 60 * 60 * 24\n        tsmax_in_days = 2**63 / oneday_in_ns  # 2**63 ns, in days\n        # just in bounds\n        should_succeed = Series(\n            [0, tsmax_in_days - 0.005, -tsmax_in_days + 0.005], dtype=float\n        )\n        expected = (should_succeed * oneday_in_ns).astype(np.int64)\n        for error_mode in [\"raise\", \"coerce\", \"ignore\"]:\n            result1 = to_datetime(should_succeed, unit=\"D\", errors=error_mode)\n            tm.assert_almost_equal(result1.astype(np.int64), expected, rtol=1e-10)\n        # just out of bounds\n        should_fail1 = Series([0, tsmax_in_days + 0.005], dtype=float)\n        should_fail2 = Series([0, -tsmax_in_days - 0.005], dtype=float)\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(should_fail1, unit=\"D\", errors=\"raise\")\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(should_fail2, unit=\"D\", errors=\"raise\")\n\n\nclass TestToDatetimeDataFrame:\n    @pytest.fixture\n    def df(self):\n        return DataFrame(\n            {\n                \"year\": [2015, 2016],\n                \"month\": [2, 3],\n                \"day\": [4, 5],\n                \"hour\": [6, 7],\n                \"minute\": [58, 59],\n                \"second\": [10, 11],\n                \"ms\": [1, 1],\n                \"us\": [2, 2],\n                \"ns\": [3, 3],\n            }\n        )\n\n    def test_dataframe(self, df, cache):\n        result = to_datetime(\n            {\"year\": df[\"year\"], \"month\": df[\"month\"], \"day\": df[\"day\"]}, cache=cache\n        )\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:0:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # dict-like\n        result = to_datetime(df[[\"year\", \"month\", \"day\"]].to_dict(), cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_dict_with_constructable(self, df, cache):\n        # dict but with constructable\n        df2 = df[[\"year\", \"month\", \"day\"]].to_dict()\n        df2[\"month\"] = 2\n        result = to_datetime(df2, cache=cache)\n        expected2 = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160205 00:0:00\")]\n        )\n        tm.assert_series_equal(result, expected2)\n\n    @pytest.mark.parametrize(\n        \"unit\",\n        [\n            {\n                \"year\": \"years\",\n                \"month\": \"months\",\n                \"day\": \"days\",\n                \"hour\": \"hours\",\n                \"minute\": \"minutes\",\n                \"second\": \"seconds\",\n            },\n            {\n                \"year\": \"year\",\n                \"month\": \"month\",\n                \"day\": \"day\",\n                \"hour\": \"hour\",\n                \"minute\": \"minute\",\n                \"second\": \"second\",\n            },\n        ],\n    )\n    def test_dataframe_field_aliases_column_subset(self, df, cache, unit):\n        # unit mappings\n        result = to_datetime(df[list(unit.keys())].rename(columns=unit), cache=cache)\n        expected = Series(\n            [Timestamp(\"20150204 06:58:10\"), Timestamp(\"20160305 07:59:11\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_field_aliases(self, df, cache):\n        d = {\n            \"year\": \"year\",\n            \"month\": \"month\",\n            \"day\": \"day\",\n            \"hour\": \"hour\",\n            \"minute\": \"minute\",\n            \"second\": \"second\",\n            \"ms\": \"ms\",\n            \"us\": \"us\",\n            \"ns\": \"ns\",\n        }\n\n        result = to_datetime(df.rename(columns=d), cache=cache)\n        expected = Series(\n            [\n                Timestamp(\"20150204 06:58:10.001002003\"),\n                Timestamp(\"20160305 07:59:11.001002003\"),\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_str_dtype(self, df, cache):\n        # coerce back to int\n        result = to_datetime(df.astype(str), cache=cache)\n        expected = Series(\n            [\n                Timestamp(\"20150204 06:58:10.001002003\"),\n                Timestamp(\"20160305 07:59:11.001002003\"),\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_coerce(self, cache):\n        # passing coerce\n        df2 = DataFrame({\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5]})\n\n        msg = (\n            r'^cannot assemble the datetimes: time data \".+\" doesn\\'t '\n            r'match format \"%Y%m%d\", at position 1\\.'\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)\n\n        result = to_datetime(df2, errors=\"coerce\", cache=cache)\n        expected = Series([Timestamp(\"20150204 00:00:00\"), NaT])\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_extra_keys_raisesm(self, df, cache):\n        # extra columns\n        msg = r\"extra keys have been passed to the datetime assemblage: \\[foo\\]\"\n        with pytest.raises(ValueError, match=msg):\n            df2 = df.copy()\n            df2[\"foo\"] = 1\n            to_datetime(df2, cache=cache)\n\n    @pytest.mark.parametrize(\n        \"cols\",\n        [\n            [\"year\"],\n            [\"year\", \"month\"],\n            [\"year\", \"month\", \"second\"],\n            [\"month\", \"day\"],\n            [\"year\", \"day\", \"second\"],\n        ],\n    )\n    def test_dataframe_missing_keys_raises(self, df, cache, cols):\n        # not enough\n        msg = (\n            r\"to assemble mappings requires at least that \\[year, month, \"\n            r\"day\\] be specified: \\[.+\\] is missing\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df[cols], cache=cache)\n\n    def test_dataframe_duplicate_columns_raises(self, cache):\n        # duplicates\n        msg = \"cannot assemble with duplicate keys\"\n        df2 = DataFrame({\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5]})\n        df2.columns = [\"year\", \"year\", \"day\"]\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)\n\n        df2 = DataFrame(\n            {\"year\": [2015, 2016], \"month\": [2, 20], \"day\": [4, 5], \"hour\": [4, 5]}\n        )\n        df2.columns = [\"year\", \"month\", \"day\", \"day\"]\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df2, cache=cache)\n\n    def test_dataframe_int16(self, cache):\n        # GH#13451\n        df = DataFrame({\"year\": [2015, 2016], \"month\": [2, 3], \"day\": [4, 5]})\n\n        # int16\n        result = to_datetime(df.astype(\"int16\"), cache=cache)\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:00:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_mixed(self, cache):\n        # mixed dtypes\n        df = DataFrame({\"year\": [2015, 2016], \"month\": [2, 3], \"day\": [4, 5]})\n        df[\"month\"] = df[\"month\"].astype(\"int8\")\n        df[\"day\"] = df[\"day\"].astype(\"int8\")\n        result = to_datetime(df, cache=cache)\n        expected = Series(\n            [Timestamp(\"20150204 00:00:00\"), Timestamp(\"20160305 00:00:00\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_dataframe_float(self, cache):\n        # float\n        df = DataFrame({\"year\": [2000, 2001], \"month\": [1.5, 1], \"day\": [1, 1]})\n        msg = (\n            r\"^cannot assemble the datetimes: unconverted data remains when parsing \"\n            r'with format \".*\": \"1\", at position 0.'\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(df, cache=cache)\n\n    def test_dataframe_utc_true(self):\n        # GH#23760\n        df = DataFrame({\"year\": [2015, 2016], \"month\": [2, 3], \"day\": [4, 5]})\n        result = to_datetime(df, utc=True)\n        expected = Series(\n            np.array([\"2015-02-04\", \"2016-03-05\"], dtype=\"datetime64[ns]\")\n        ).dt.tz_localize(\"UTC\")\n        tm.assert_series_equal(result, expected)\n\n\nclass TestToDatetimeMisc:\n    def test_to_datetime_barely_out_of_bounds(self):\n        # GH#19529\n        # GH#19382 close enough to bounds that dropping nanos would result\n        # in an in-bounds datetime\n        arr = np.array([\"2262-04-11 23:47:16.854775808\"], dtype=object)\n\n        msg = \"^Out of bounds nanosecond timestamp: .*, at position 0\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(arr)\n\n    @pytest.mark.parametrize(\n        \"arg, exp_str\",\n        [\n            [\"2012-01-01 00:00:00\", \"2012-01-01 00:00:00\"],\n            [\"20121001\", \"2012-10-01\"],  # bad iso 8601\n        ],\n    )\n    def test_to_datetime_iso8601(self, cache, arg, exp_str):\n        result = to_datetime([arg], cache=cache)\n        exp = Timestamp(exp_str)\n        assert result[0] == exp\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2012\", \"%Y-%m\"),\n            (\"2012-01\", \"%Y-%m-%d\"),\n            (\"2012-01-01\", \"%Y-%m-%d %H\"),\n            (\"2012-01-01 10\", \"%Y-%m-%d %H:%M\"),\n            (\"2012-01-01 10:00\", \"%Y-%m-%d %H:%M:%S\"),\n            (\"2012-01-01 10:00:00\", \"%Y-%m-%d %H:%M:%S.%f\"),\n            (\"2012-01-01 10:00:00.123\", \"%Y-%m-%d %H:%M:%S.%f%z\"),\n            (0, \"%Y-%m-%d\"),\n        ],\n    )\n    @pytest.mark.parametrize(\"exact\", [True, False])\n    def test_to_datetime_iso8601_fails(self, input, format, exact):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        # `format` is longer than the string, so this fails regardless of `exact`\n        with pytest.raises(\n            ValueError,\n            match=(\n                rf\"time data \\\"{input}\\\" doesn't match format \"\n                rf\"\\\"{format}\\\", at position 0\"\n            ),\n        ):\n            to_datetime(input, format=format, exact=exact)\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2012-01-01\", \"%Y-%m\"),\n            (\"2012-01-01 10\", \"%Y-%m-%d\"),\n            (\"2012-01-01 10:00\", \"%Y-%m-%d %H\"),\n            (\"2012-01-01 10:00:00\", \"%Y-%m-%d %H:%M\"),\n            (0, \"%Y-%m-%d\"),\n        ],\n    )\n    def test_to_datetime_iso8601_exact_fails(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        # `format` is shorter than the date string, so only fails with `exact=True`\n        msg = \"|\".join(\n            [\n                '^unconverted data remains when parsing with format \".*\": \".*\"'\n                f\", at position 0. {PARSING_ERR_MSG}$\",\n                f'^time data \".*\" doesn\\'t match format \".*\", at position 0. '\n                f\"{PARSING_ERR_MSG}$\",\n            ]\n        )\n        with pytest.raises(\n            ValueError,\n            match=(msg),\n        ):\n            to_datetime(input, format=format)\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2012-01-01\", \"%Y-%m\"),\n            (\"2012-01-01 00\", \"%Y-%m-%d\"),\n            (\"2012-01-01 00:00\", \"%Y-%m-%d %H\"),\n            (\"2012-01-01 00:00:00\", \"%Y-%m-%d %H:%M\"),\n        ],\n    )\n    def test_to_datetime_iso8601_non_exact(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        expected = Timestamp(2012, 1, 1)\n        result = to_datetime(input, format=format, exact=False)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2020-01\", \"%Y/%m\"),\n            (\"2020-01-01\", \"%Y/%m/%d\"),\n            (\"2020-01-01 00\", \"%Y/%m/%dT%H\"),\n            (\"2020-01-01T00\", \"%Y/%m/%d %H\"),\n            (\"2020-01-01 00:00\", \"%Y/%m/%dT%H:%M\"),\n            (\"2020-01-01T00:00\", \"%Y/%m/%d %H:%M\"),\n            (\"2020-01-01 00:00:00\", \"%Y/%m/%dT%H:%M:%S\"),\n            (\"2020-01-01T00:00:00\", \"%Y/%m/%d %H:%M:%S\"),\n        ],\n    )\n    def test_to_datetime_iso8601_separator(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        with pytest.raises(\n            ValueError,\n            match=(\n                rf\"time data \\\"{input}\\\" doesn\\'t match format \"\n                rf\"\\\"{format}\\\", at position 0\"\n            ),\n        ):\n            to_datetime(input, format=format)\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2020-01\", \"%Y-%m\"),\n            (\"2020-01-01\", \"%Y-%m-%d\"),\n            (\"2020-01-01 00\", \"%Y-%m-%d %H\"),\n            (\"2020-01-01T00\", \"%Y-%m-%dT%H\"),\n            (\"2020-01-01 00:00\", \"%Y-%m-%d %H:%M\"),\n            (\"2020-01-01T00:00\", \"%Y-%m-%dT%H:%M\"),\n            (\"2020-01-01 00:00:00\", \"%Y-%m-%d %H:%M:%S\"),\n            (\"2020-01-01T00:00:00\", \"%Y-%m-%dT%H:%M:%S\"),\n            (\"2020-01-01T00:00:00.000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n            (\"2020-01-01T00:00:00.000000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n            (\"2020-01-01T00:00:00.000000000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n        ],\n    )\n    def test_to_datetime_iso8601_valid(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        expected = Timestamp(2020, 1, 1)\n        result = to_datetime(input, format=format)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2020-1\", \"%Y-%m\"),\n            (\"2020-1-1\", \"%Y-%m-%d\"),\n            (\"2020-1-1 0\", \"%Y-%m-%d %H\"),\n            (\"2020-1-1T0\", \"%Y-%m-%dT%H\"),\n            (\"2020-1-1 0:0\", \"%Y-%m-%d %H:%M\"),\n            (\"2020-1-1T0:0\", \"%Y-%m-%dT%H:%M\"),\n            (\"2020-1-1 0:0:0\", \"%Y-%m-%d %H:%M:%S\"),\n            (\"2020-1-1T0:0:0\", \"%Y-%m-%dT%H:%M:%S\"),\n            (\"2020-1-1T0:0:0.000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n            (\"2020-1-1T0:0:0.000000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n            (\"2020-1-1T0:0:0.000000000\", \"%Y-%m-%dT%H:%M:%S.%f\"),\n        ],\n    )\n    def test_to_datetime_iso8601_non_padded(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/21422\n        expected = Timestamp(2020, 1, 1)\n        result = to_datetime(input, format=format)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"input, format\",\n        [\n            (\"2020-01-01T00:00:00.000000000+00:00\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n            (\"2020-01-01T00:00:00+00:00\", \"%Y-%m-%dT%H:%M:%S%z\"),\n            (\"2020-01-01T00:00:00Z\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        ],\n    )\n    def test_to_datetime_iso8601_with_timezone_valid(self, input, format):\n        # https://github.com/pandas-dev/pandas/issues/12649\n        expected = Timestamp(2020, 1, 1, tzinfo=pytz.UTC)\n        result = to_datetime(input, format=format)\n        assert result == expected\n\n    def test_to_datetime_default(self, cache):\n        rs = to_datetime(\"2001\", cache=cache)\n        xp = datetime(2001, 1, 1)\n        assert rs == xp\n\n    @pytest.mark.xfail(reason=\"fails to enforce dayfirst=True, which would raise\")\n    def test_to_datetime_respects_dayfirst(self, cache):\n        # dayfirst is essentially broken\n\n        # The msg here is not important since it isn't actually raised yet.\n        msg = \"Invalid date specified\"\n        with pytest.raises(ValueError, match=msg):\n            # if dayfirst is respected, then this would parse as month=13, which\n            #  would raise\n            with tm.assert_produces_warning(UserWarning, match=\"Provide format\"):\n                to_datetime(\"01-13-2012\", dayfirst=True, cache=cache)\n\n    def test_to_datetime_on_datetime64_series(self, cache):\n        # #2699\n        ser = Series(date_range(\"1/1/2000\", periods=10))\n\n        result = to_datetime(ser, cache=cache)\n        assert result[0] == ser[0]\n\n    def test_to_datetime_with_space_in_series(self, cache):\n        # GH 6428\n        ser = Series([\"10/18/2006\", \"10/18/2008\", \" \"])\n        msg = (\n            r'^time data \" \" doesn\\'t match format \"%m/%d/%Y\", '\n            rf\"at position 2. {PARSING_ERR_MSG}$\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(ser, errors=\"raise\", cache=cache)\n        result_coerce = to_datetime(ser, errors=\"coerce\", cache=cache)\n        expected_coerce = Series([datetime(2006, 10, 18), datetime(2008, 10, 18), NaT])\n        tm.assert_series_equal(result_coerce, expected_coerce)\n        result_ignore = to_datetime(ser, errors=\"ignore\", cache=cache)\n        tm.assert_series_equal(result_ignore, ser)\n\n    @td.skip_if_not_us_locale\n    def test_to_datetime_with_apply(self, cache):\n        # this is only locale tested with US/None locales\n        # GH 5195\n        # with a format and coerce a single item to_datetime fails\n        td = Series([\"May 04\", \"Jun 02\", \"Dec 11\"], index=[1, 2, 3])\n        expected = to_datetime(td, format=\"%b %y\", cache=cache)\n        result = td.apply(to_datetime, format=\"%b %y\", cache=cache)\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_timezone_name(self):\n        # https://github.com/pandas-dev/pandas/issues/49748\n        result = to_datetime(\"2020-01-01 00:00:00UTC\", format=\"%Y-%m-%d %H:%M:%S%Z\")\n        expected = Timestamp(2020, 1, 1).tz_localize(\"UTC\")\n        assert result == expected\n\n    @td.skip_if_not_us_locale\n    @pytest.mark.parametrize(\"errors\", [\"raise\", \"coerce\", \"ignore\"])\n    def test_to_datetime_with_apply_with_empty_str(self, cache, errors):\n        # this is only locale tested with US/None locales\n        # GH 5195, GH50251\n        # with a format and coerce a single item to_datetime fails\n        td = Series([\"May 04\", \"Jun 02\", \"\"], index=[1, 2, 3])\n        expected = to_datetime(td, format=\"%b %y\", errors=errors, cache=cache)\n\n        result = td.apply(\n            lambda x: to_datetime(x, format=\"%b %y\", errors=\"coerce\", cache=cache)\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_empty_stt(self, cache):\n        # empty string\n        result = to_datetime(\"\", cache=cache)\n        assert result is NaT\n\n    def test_to_datetime_empty_str_list(self, cache):\n        result = to_datetime([\"\", \"\"], cache=cache)\n        assert isna(result).all()\n\n    def test_to_datetime_zero(self, cache):\n        # ints\n        result = Timestamp(0)\n        expected = to_datetime(0, cache=cache)\n        assert result == expected\n\n    def test_to_datetime_strings(self, cache):\n        # GH 3888 (strings)\n        expected = to_datetime([\"2012\"], cache=cache)[0]\n        result = to_datetime(\"2012\", cache=cache)\n        assert result == expected\n\n    def test_to_datetime_strings_variation(self, cache):\n        array = [\"2012\", \"20120101\", \"20120101 12:01:01\"]\n        expected = [to_datetime(dt_str, cache=cache) for dt_str in array]\n        result = [Timestamp(date_str) for date_str in array]\n        tm.assert_almost_equal(result, expected)\n\n    @pytest.mark.parametrize(\"result\", [Timestamp(\"2012\"), to_datetime(\"2012\")])\n    def test_to_datetime_strings_vs_constructor(self, result):\n        expected = Timestamp(2012, 1, 1)\n        assert result == expected\n\n    def test_to_datetime_unprocessable_input(self, cache):\n        # GH 4928\n        # GH 21864\n        result = to_datetime([1, \"1\"], errors=\"ignore\", cache=cache)\n\n        expected = Index(np.array([1, \"1\"], dtype=\"O\"))\n        tm.assert_equal(result, expected)\n        msg = '^Given date string \"1\" not likely a datetime, at position 1$'\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1, \"1\"], errors=\"raise\", cache=cache)\n\n    def test_to_datetime_unhashable_input(self, cache):\n        series = Series([[\"a\"]] * 100)\n        result = to_datetime(series, errors=\"ignore\", cache=cache)\n        tm.assert_series_equal(series, result)\n\n    def test_to_datetime_other_datetime64_units(self):\n        # 5/25/2012\n        scalar = np.int64(1337904000000000).view(\"M8[us]\")\n        as_obj = scalar.astype(\"O\")\n\n        index = DatetimeIndex([scalar])\n        assert index[0] == scalar.astype(\"O\")\n\n        value = Timestamp(scalar)\n        assert value == as_obj\n\n    def test_to_datetime_list_of_integers(self):\n        rng = date_range(\"1/1/2000\", periods=20)\n        rng = DatetimeIndex(rng.values)\n\n        ints = list(rng.asi8)\n\n        result = DatetimeIndex(ints)\n\n        tm.assert_index_equal(rng, result)\n\n    def test_to_datetime_overflow(self):\n        # gh-17637\n        # we are overflowing Timedelta range here\n        msg = \"Cannot cast 139999 days 00:00:00 to unit='ns' without overflow\"\n        with pytest.raises(OutOfBoundsTimedelta, match=msg):\n            date_range(start=\"1/1/1700\", freq=\"B\", periods=100000)\n\n    def test_string_invalid_operation(self, cache):\n        invalid = np.array([\"87156549591102612381000001219H5\"], dtype=object)\n        # GH #51084\n\n        with pytest.raises(ValueError, match=\"Unknown datetime string format\"):\n            to_datetime(invalid, errors=\"raise\", cache=cache)\n\n    def test_string_na_nat_conversion(self, cache):\n        # GH #999, #858\n\n        strings = np.array([\"1/1/2000\", \"1/2/2000\", np.nan, \"1/4/2000\"], dtype=object)\n\n        expected = np.empty(4, dtype=\"M8[ns]\")\n        for i, val in enumerate(strings):\n            if isna(val):\n                expected[i] = iNaT\n            else:\n                expected[i] = parse(val)\n\n        result = tslib.array_to_datetime(strings)[0]\n        tm.assert_almost_equal(result, expected)\n\n        result2 = to_datetime(strings, cache=cache)\n        assert isinstance(result2, DatetimeIndex)\n        tm.assert_numpy_array_equal(result, result2.values)\n\n    def test_string_na_nat_conversion_malformed(self, cache):\n        malformed = np.array([\"1/100/2000\", np.nan], dtype=object)\n\n        # GH 10636, default is now 'raise'\n        msg = r\"Unknown datetime string format\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(malformed, errors=\"raise\", cache=cache)\n\n        result = to_datetime(malformed, errors=\"ignore\", cache=cache)\n        # GH 21864\n        expected = Index(malformed)\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(malformed, errors=\"raise\", cache=cache)\n\n    def test_string_na_nat_conversion_with_name(self, cache):\n        idx = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n        series = Series(\n            [\"1/1/2000\", np.nan, \"1/3/2000\", np.nan, \"1/5/2000\"], index=idx, name=\"foo\"\n        )\n        dseries = Series(\n            [\n                to_datetime(\"1/1/2000\", cache=cache),\n                np.nan,\n                to_datetime(\"1/3/2000\", cache=cache),\n                np.nan,\n                to_datetime(\"1/5/2000\", cache=cache),\n            ],\n            index=idx,\n            name=\"foo\",\n        )\n\n        result = to_datetime(series, cache=cache)\n        dresult = to_datetime(dseries, cache=cache)\n\n        expected = Series(np.empty(5, dtype=\"M8[ns]\"), index=idx)\n        for i in range(5):\n            x = series[i]\n            if isna(x):\n                expected[i] = NaT\n            else:\n                expected[i] = to_datetime(x, cache=cache)\n\n        tm.assert_series_equal(result, expected, check_names=False)\n        assert result.name == \"foo\"\n\n        tm.assert_series_equal(dresult, expected, check_names=False)\n        assert dresult.name == \"foo\"\n\n    @pytest.mark.parametrize(\n        \"unit\",\n        [\"h\", \"m\", \"s\", \"ms\", \"us\", \"ns\"],\n    )\n    def test_dti_constructor_numpy_timeunits(self, cache, unit):\n        # GH 9114\n        dtype = np.dtype(f\"M8[{unit}]\")\n        base = to_datetime([\"2000-01-01T00:00\", \"2000-01-02T00:00\", \"NaT\"], cache=cache)\n\n        values = base.values.astype(dtype)\n\n        if unit in [\"h\", \"m\"]:\n            # we cast to closest supported unit\n            unit = \"s\"\n        exp_dtype = np.dtype(f\"M8[{unit}]\")\n        expected = DatetimeIndex(base.astype(exp_dtype))\n        assert expected.dtype == exp_dtype\n\n        tm.assert_index_equal(DatetimeIndex(values), expected)\n        tm.assert_index_equal(to_datetime(values, cache=cache), expected)\n\n    def test_dayfirst(self, cache):\n        # GH 5917\n        arr = [\"10/02/2014\", \"11/02/2014\", \"12/02/2014\"]\n        expected = DatetimeIndex(\n            [datetime(2014, 2, 10), datetime(2014, 2, 11), datetime(2014, 2, 12)]\n        )\n        idx1 = DatetimeIndex(arr, dayfirst=True)\n        idx2 = DatetimeIndex(np.array(arr), dayfirst=True)\n        idx3 = to_datetime(arr, dayfirst=True, cache=cache)\n        idx4 = to_datetime(np.array(arr), dayfirst=True, cache=cache)\n        idx5 = DatetimeIndex(Index(arr), dayfirst=True)\n        idx6 = DatetimeIndex(Series(arr), dayfirst=True)\n        tm.assert_index_equal(expected, idx1)\n        tm.assert_index_equal(expected, idx2)\n        tm.assert_index_equal(expected, idx3)\n        tm.assert_index_equal(expected, idx4)\n        tm.assert_index_equal(expected, idx5)\n        tm.assert_index_equal(expected, idx6)\n\n    def test_dayfirst_warnings_valid_input(self):\n        # GH 12585\n        warning_msg = (\n            \"Parsing dates in .* format when dayfirst=.* was specified. \"\n            \"Pass `dayfirst=.*` or specify a format to silence this warning.\"\n        )\n\n        # CASE 1: valid input\n        arr = [\"31/12/2014\", \"10/03/2011\"]\n        expected = DatetimeIndex(\n            [\"2014-12-31\", \"2011-03-10\"], dtype=\"datetime64[ns]\", freq=None\n        )\n\n        # A. dayfirst arg correct, no warning\n        res1 = to_datetime(arr, dayfirst=True)\n        tm.assert_index_equal(expected, res1)\n\n        # B. dayfirst arg incorrect, warning\n        with tm.assert_produces_warning(UserWarning, match=warning_msg):\n            res2 = to_datetime(arr, dayfirst=False)\n        tm.assert_index_equal(expected, res2)\n\n    def test_dayfirst_warnings_invalid_input(self):\n        # CASE 2: invalid input\n        # cannot consistently process with single format\n        # ValueError *always* raised\n\n        # first in DD/MM/YYYY, second in MM/DD/YYYY\n        arr = [\"31/12/2014\", \"03/30/2011\"]\n\n        with pytest.raises(\n            ValueError,\n            match=(\n                r'^time data \"03/30/2011\" doesn\\'t match format '\n                rf'\"%d/%m/%Y\", at position 1. {PARSING_ERR_MSG}$'\n            ),\n        ):\n            to_datetime(arr, dayfirst=True)\n\n    @pytest.mark.parametrize(\"klass\", [DatetimeIndex, DatetimeArray])\n    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n\n        obj = klass(dti)\n        expected = klass(expected)\n\n        result = to_datetime(obj, utc=True)\n        tm.assert_equal(result, expected)\n\n\nclass TestGuessDatetimeFormat:\n    @pytest.mark.parametrize(\n        \"test_list\",\n        [\n            [\n                \"2011-12-30 00:00:00.000000\",\n                \"2011-12-30 00:00:00.000000\",\n                \"2011-12-30 00:00:00.000000\",\n            ],\n            [np.nan, np.nan, \"2011-12-30 00:00:00.000000\"],\n            [\"\", \"2011-12-30 00:00:00.000000\"],\n            [\"NaT\", \"2011-12-30 00:00:00.000000\"],\n            [\"2011-12-30 00:00:00.000000\", \"random_string\"],\n            [\"now\", \"2011-12-30 00:00:00.000000\"],\n            [\"today\", \"2011-12-30 00:00:00.000000\"],\n        ],\n    )\n    def test_guess_datetime_format_for_array(self, test_list):\n        expected_format = \"%Y-%m-%d %H:%M:%S.%f\"\n        test_array = np.array(test_list, dtype=object)\n        assert tools._guess_datetime_format_for_array(test_array) == expected_format\n\n    @td.skip_if_not_us_locale\n    def test_guess_datetime_format_for_array_all_nans(self):\n        format_for_string_of_nans = tools._guess_datetime_format_for_array(\n            np.array([np.nan, np.nan, np.nan], dtype=\"O\")\n        )\n        assert format_for_string_of_nans is None\n\n\nclass TestToDatetimeInferFormat:\n    @pytest.mark.parametrize(\n        \"test_format\", [\"%m-%d-%Y\", \"%m/%d/%Y %H:%M:%S.%f\", \"%Y-%m-%dT%H:%M:%S.%f\"]\n    )\n    def test_to_datetime_infer_datetime_format_consistent_format(\n        self, cache, test_format\n    ):\n        ser = Series(date_range(\"20000101\", periods=50, freq=\"H\"))\n\n        s_as_dt_strings = ser.apply(lambda x: x.strftime(test_format))\n\n        with_format = to_datetime(s_as_dt_strings, format=test_format, cache=cache)\n        without_format = to_datetime(s_as_dt_strings, cache=cache)\n\n        # Whether the format is explicitly passed, or\n        # it is inferred, the results should all be the same\n        tm.assert_series_equal(with_format, without_format)\n\n    def test_to_datetime_inconsistent_format(self, cache):\n        data = [\"01/01/2011 00:00:00\", \"01-02-2011 00:00:00\", \"2011-01-03T00:00:00\"]\n        ser = Series(np.array(data))\n        msg = (\n            r'^time data \"01-02-2011 00:00:00\" doesn\\'t match format '\n            rf'\"%m/%d/%Y %H:%M:%S\", at position 1. {PARSING_ERR_MSG}$'\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(ser, cache=cache)\n\n    def test_to_datetime_consistent_format(self, cache):\n        data = [\"Jan/01/2011\", \"Feb/01/2011\", \"Mar/01/2011\"]\n        ser = Series(np.array(data))\n        result = to_datetime(ser, cache=cache)\n        expected = Series(\n            [\"2011-01-01\", \"2011-02-01\", \"2011-03-01\"], dtype=\"datetime64[ns]\"\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_series_with_nans(self, cache):\n        ser = Series(\n            np.array(\n                [\"01/01/2011 00:00:00\", np.nan, \"01/03/2011 00:00:00\", np.nan],\n                dtype=object,\n            )\n        )\n        result = to_datetime(ser, cache=cache)\n        expected = Series(\n            [\"2011-01-01\", NaT, \"2011-01-03\", NaT], dtype=\"datetime64[ns]\"\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_to_datetime_series_start_with_nans(self, cache):\n        ser = Series(\n            np.array(\n                [\n                    np.nan,\n                    np.nan,\n                    \"01/01/2011 00:00:00\",\n                    \"01/02/2011 00:00:00\",\n                    \"01/03/2011 00:00:00\",\n                ],\n                dtype=object,\n            )\n        )\n\n        result = to_datetime(ser, cache=cache)\n        expected = Series(\n            [NaT, NaT, \"2011-01-01\", \"2011-01-02\", \"2011-01-03\"], dtype=\"datetime64[ns]\"\n        )\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"tz_name, offset\",\n        [(\"UTC\", 0), (\"UTC-3\", 180), (\"UTC+3\", -180)],\n    )\n    def test_infer_datetime_format_tz_name(self, tz_name, offset):\n        # GH 33133\n        ser = Series([f\"2019-02-02 08:07:13 {tz_name}\"])\n        result = to_datetime(ser)\n        tz = timezone(timedelta(minutes=offset))\n        expected = Series([Timestamp(\"2019-02-02 08:07:13\").tz_localize(tz)])\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"ts,zero_tz\",\n        [\n            (\"2019-02-02 08:07:13\", \"Z\"),\n            (\"2019-02-02 08:07:13\", \"\"),\n            (\"2019-02-02 08:07:13.012345\", \"Z\"),\n            (\"2019-02-02 08:07:13.012345\", \"\"),\n        ],\n    )\n    def test_infer_datetime_format_zero_tz(self, ts, zero_tz):\n        # GH 41047\n        ser = Series([ts + zero_tz])\n        result = to_datetime(ser)\n        tz = pytz.utc if zero_tz == \"Z\" else None\n        expected = Series([Timestamp(ts, tz=tz)])\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\"format\", [None, \"%Y-%m-%d\"])\n    def test_to_datetime_iso8601_noleading_0s(self, cache, format):\n        # GH 11871\n        ser = Series([\"2014-1-1\", \"2014-2-2\", \"2015-3-3\"])\n        expected = Series(\n            [\n                Timestamp(\"2014-01-01\"),\n                Timestamp(\"2014-02-02\"),\n                Timestamp(\"2015-03-03\"),\n            ]\n        )\n        tm.assert_series_equal(to_datetime(ser, format=format, cache=cache), expected)\n\n    def test_parse_dates_infer_datetime_format_warning(self):\n        # GH 49024\n        with tm.assert_produces_warning(\n            UserWarning,\n            match=\"The argument 'infer_datetime_format' is deprecated\",\n        ):\n            to_datetime([\"10-10-2000\"], infer_datetime_format=True)\n\n\nclass TestDaysInMonth:\n    # tests for issue #10154\n\n    @pytest.mark.parametrize(\n        \"arg, format\",\n        [\n            [\"2015-02-29\", None],\n            [\"2015-02-29\", \"%Y-%m-%d\"],\n            [\"2015-02-32\", \"%Y-%m-%d\"],\n            [\"2015-04-31\", \"%Y-%m-%d\"],\n        ],\n    )\n    def test_day_not_in_month_coerce(self, cache, arg, format):\n        assert isna(to_datetime(arg, errors=\"coerce\", format=format, cache=cache))\n\n    def test_day_not_in_month_raise(self, cache):\n        msg = \"day is out of range for month: 2015-02-29, at position 0\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2015-02-29\", errors=\"raise\", cache=cache)\n\n    @pytest.mark.parametrize(\n        \"arg, format, msg\",\n        [\n            (\n                \"2015-02-29\",\n                \"%Y-%m-%d\",\n                f\"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$\",\n            ),\n            (\n                \"2015-29-02\",\n                \"%Y-%d-%m\",\n                f\"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$\",\n            ),\n            (\n                \"2015-02-32\",\n                \"%Y-%m-%d\",\n                '^unconverted data remains when parsing with format \"%Y-%m-%d\": \"2\", '\n                f\"at position 0. {PARSING_ERR_MSG}$\",\n            ),\n            (\n                \"2015-32-02\",\n                \"%Y-%d-%m\",\n                '^time data \"2015-32-02\" doesn\\'t match format \"%Y-%d-%m\", '\n                f\"at position 0. {PARSING_ERR_MSG}$\",\n            ),\n            (\n                \"2015-04-31\",\n                \"%Y-%m-%d\",\n                f\"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$\",\n            ),\n            (\n                \"2015-31-04\",\n                \"%Y-%d-%m\",\n                f\"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$\",\n            ),\n        ],\n    )\n    def test_day_not_in_month_raise_value(self, cache, arg, format, msg):\n        # https://github.com/pandas-dev/pandas/issues/50462\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(arg, errors=\"raise\", format=format, cache=cache)\n\n    @pytest.mark.parametrize(\n        \"expected, format\",\n        [\n            [\"2015-02-29\", None],\n            [\"2015-02-29\", \"%Y-%m-%d\"],\n            [\"2015-02-29\", \"%Y-%m-%d\"],\n            [\"2015-04-31\", \"%Y-%m-%d\"],\n        ],\n    )\n    def test_day_not_in_month_ignore(self, cache, expected, format):\n        result = to_datetime(expected, errors=\"ignore\", format=format, cache=cache)\n        assert result == expected\n\n\nclass TestDatetimeParsingWrappers:\n    @pytest.mark.parametrize(\n        \"date_str, expected\",\n        [\n            (\"2011-01-01\", datetime(2011, 1, 1)),\n            (\"2Q2005\", datetime(2005, 4, 1)),\n            (\"2Q05\", datetime(2005, 4, 1)),\n            (\"2005Q1\", datetime(2005, 1, 1)),\n            (\"05Q1\", datetime(2005, 1, 1)),\n            (\"2011Q3\", datetime(2011, 7, 1)),\n            (\"11Q3\", datetime(2011, 7, 1)),\n            (\"3Q2011\", datetime(2011, 7, 1)),\n            (\"3Q11\", datetime(2011, 7, 1)),\n            # quarterly without space\n            (\"2000Q4\", datetime(2000, 10, 1)),\n            (\"00Q4\", datetime(2000, 10, 1)),\n            (\"4Q2000\", datetime(2000, 10, 1)),\n            (\"4Q00\", datetime(2000, 10, 1)),\n            (\"2000q4\", datetime(2000, 10, 1)),\n            (\"2000-Q4\", datetime(2000, 10, 1)),\n            (\"00-Q4\", datetime(2000, 10, 1)),\n            (\"4Q-2000\", datetime(2000, 10, 1)),\n            (\"4Q-00\", datetime(2000, 10, 1)),\n            (\"00q4\", datetime(2000, 10, 1)),\n            (\"2005\", datetime(2005, 1, 1)),\n            (\"2005-11\", datetime(2005, 11, 1)),\n            (\"2005 11\", datetime(2005, 11, 1)),\n            (\"11-2005\", datetime(2005, 11, 1)),\n            (\"11 2005\", datetime(2005, 11, 1)),\n            (\"200511\", datetime(2020, 5, 11)),\n            (\"20051109\", datetime(2005, 11, 9)),\n            (\"20051109 10:15\", datetime(2005, 11, 9, 10, 15)),\n            (\"20051109 08H\", datetime(2005, 11, 9, 8, 0)),\n            (\"2005-11-09 10:15\", datetime(2005, 11, 9, 10, 15)),\n            (\"2005-11-09 08H\", datetime(2005, 11, 9, 8, 0)),\n            (\"2005/11/09 10:15\", datetime(2005, 11, 9, 10, 15)),\n            (\"2005/11/09 10:15:32\", datetime(2005, 11, 9, 10, 15, 32)),\n            (\"2005/11/09 08H\", datetime(2005, 11, 9, 8, 0)),\n            (\"Thu Sep 25 10:36:28 2003\", datetime(2003, 9, 25, 10, 36, 28)),\n            (\"Thu Sep 25 2003\", datetime(2003, 9, 25)),\n            (\"Sep 25 2003\", datetime(2003, 9, 25)),\n            (\"January 1 2014\", datetime(2014, 1, 1)),\n            # GHE10537\n            (\"2014-06\", datetime(2014, 6, 1)),\n            (\"06-2014\", datetime(2014, 6, 1)),\n            (\"2014-6\", datetime(2014, 6, 1)),\n            (\"6-2014\", datetime(2014, 6, 1)),\n            (\"20010101 12\", datetime(2001, 1, 1, 12)),\n            (\"20010101 1234\", datetime(2001, 1, 1, 12, 34)),\n            (\"20010101 123456\", datetime(2001, 1, 1, 12, 34, 56)),\n        ],\n    )\n    def test_parsers(self, date_str, expected, cache):\n        # dateutil >= 2.5.0 defaults to yearfirst=True\n        # https://github.com/dateutil/dateutil/issues/217\n        yearfirst = True\n\n        result1, _ = parsing.parse_datetime_string_with_reso(\n            date_str, yearfirst=yearfirst\n        )\n        result2 = to_datetime(date_str, yearfirst=yearfirst)\n        result3 = to_datetime([date_str], yearfirst=yearfirst)\n        # result5 is used below\n        result4 = to_datetime(\n            np.array([date_str], dtype=object), yearfirst=yearfirst, cache=cache\n        )\n        result6 = DatetimeIndex([date_str], yearfirst=yearfirst)\n        # result7 is used below\n        result8 = DatetimeIndex(Index([date_str]), yearfirst=yearfirst)\n        result9 = DatetimeIndex(Series([date_str]), yearfirst=yearfirst)\n\n        for res in [result1, result2]:\n            assert res == expected\n        for res in [result3, result4, result6, result8, result9]:\n            exp = DatetimeIndex([Timestamp(expected)])\n            tm.assert_index_equal(res, exp)\n\n        # these really need to have yearfirst, but we don't support\n        if not yearfirst:\n            result5 = Timestamp(date_str)\n            assert result5 == expected\n            result7 = date_range(date_str, freq=\"S\", periods=1, yearfirst=yearfirst)\n            assert result7 == expected\n\n    def test_na_values_with_cache(\n        self, cache, unique_nulls_fixture, unique_nulls_fixture2\n    ):\n        # GH22305\n        expected = Index([NaT, NaT], dtype=\"datetime64[ns]\")\n        result = to_datetime([unique_nulls_fixture, unique_nulls_fixture2], cache=cache)\n        tm.assert_index_equal(result, expected)\n\n    def test_parsers_nat(self):\n        # Test that each of several string-accepting methods return pd.NaT\n        result1, _ = parsing.parse_datetime_string_with_reso(\"NaT\")\n        result2 = to_datetime(\"NaT\")\n        result3 = Timestamp(\"NaT\")\n        result4 = DatetimeIndex([\"NaT\"])[0]\n        assert result1 is NaT\n        assert result2 is NaT\n        assert result3 is NaT\n        assert result4 is NaT\n\n    @pytest.mark.parametrize(\n        \"date_str, dayfirst, yearfirst, expected\",\n        [\n            (\"10-11-12\", False, False, datetime(2012, 10, 11)),\n            (\"10-11-12\", True, False, datetime(2012, 11, 10)),\n            (\"10-11-12\", False, True, datetime(2010, 11, 12)),\n            (\"10-11-12\", True, True, datetime(2010, 12, 11)),\n            (\"20/12/21\", False, False, datetime(2021, 12, 20)),\n            (\"20/12/21\", True, False, datetime(2021, 12, 20)),\n            (\"20/12/21\", False, True, datetime(2020, 12, 21)),\n            (\"20/12/21\", True, True, datetime(2020, 12, 21)),\n        ],\n    )\n    def test_parsers_dayfirst_yearfirst(\n        self, cache, date_str, dayfirst, yearfirst, expected\n    ):\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2012-10-11 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00\n\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00\n\n        # bug fix in 2.5.2\n        # 2.5.1 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-11-12 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00\n\n        # OK\n        # 2.5.1 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n        # 2.5.2 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n        # 2.5.3 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00\n\n        # revert of bug in 2.5.2\n        # 2.5.1 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=1, yearfirst=1] -> month must be in 1..12\n        # 2.5.3 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00\n\n        # OK\n        # 2.5.1 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.2 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n        # 2.5.3 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00\n\n        # str : dayfirst, yearfirst, expected\n\n        # compare with dateutil result\n        dateutil_result = parse(date_str, dayfirst=dayfirst, yearfirst=yearfirst)\n        assert dateutil_result == expected\n\n        result1, _ = parsing.parse_datetime_string_with_reso(\n            date_str, dayfirst=dayfirst, yearfirst=yearfirst\n        )\n\n        # we don't support dayfirst/yearfirst here:\n        if not dayfirst and not yearfirst:\n            result2 = Timestamp(date_str)\n            assert result2 == expected\n\n        result3 = to_datetime(\n            date_str, dayfirst=dayfirst, yearfirst=yearfirst, cache=cache\n        )\n\n        result4 = DatetimeIndex([date_str], dayfirst=dayfirst, yearfirst=yearfirst)[0]\n\n        assert result1 == expected\n        assert result3 == expected\n        assert result4 == expected\n\n    @pytest.mark.parametrize(\n        \"date_str, exp_def\",\n        [[\"10:15\", datetime(1, 1, 1, 10, 15)], [\"9:05\", datetime(1, 1, 1, 9, 5)]],\n    )\n    def test_parsers_timestring(self, date_str, exp_def):\n        # must be the same as dateutil result\n        exp_now = parse(date_str)\n\n        result1, _ = parsing.parse_datetime_string_with_reso(date_str)\n        result2 = to_datetime(date_str)\n        result3 = to_datetime([date_str])\n        result4 = Timestamp(date_str)\n        result5 = DatetimeIndex([date_str])[0]\n        # parse time string return time string based on default date\n        # others are not, and can't be changed because it is used in\n        # time series plot\n        assert result1 == exp_def\n        assert result2 == exp_now\n        assert result3 == exp_now\n        assert result4 == exp_now\n        assert result5 == exp_now\n\n    @pytest.mark.parametrize(\n        \"dt_string, tz, dt_string_repr\",\n        [\n            (\n                \"2013-01-01 05:45+0545\",\n                timezone(timedelta(minutes=345)),\n                \"Timestamp('2013-01-01 05:45:00+0545', tz='UTC+05:45')\",\n            ),\n            (\n                \"2013-01-01 05:30+0530\",\n                timezone(timedelta(minutes=330)),\n                \"Timestamp('2013-01-01 05:30:00+0530', tz='UTC+05:30')\",\n            ),\n        ],\n    )\n    def test_parsers_timezone_minute_offsets_roundtrip(\n        self, cache, dt_string, tz, dt_string_repr\n    ):\n        # GH11708\n        base = to_datetime(\"2013-01-01 00:00:00\", cache=cache)\n        base = base.tz_localize(\"UTC\").tz_convert(tz)\n        dt_time = to_datetime(dt_string, cache=cache)\n        assert base == dt_time\n        assert dt_string_repr == repr(dt_time)\n\n\n@pytest.fixture(params=[\"D\", \"s\", \"ms\", \"us\", \"ns\"])\ndef units(request):\n    \"\"\"Day and some time units.\n\n    * D\n    * s\n    * ms\n    * us\n    * ns\n    \"\"\"\n    return request.param\n\n\n@pytest.fixture\ndef epoch_1960():\n    \"\"\"Timestamp at 1960-01-01.\"\"\"\n    return Timestamp(\"1960-01-01\")\n\n\n@pytest.fixture\ndef units_from_epochs():\n    return list(range(5))\n\n\n@pytest.fixture(params=[\"timestamp\", \"pydatetime\", \"datetime64\", \"str_1960\"])\ndef epochs(epoch_1960, request):\n    \"\"\"Timestamp at 1960-01-01 in various forms.\n\n    * Timestamp\n    * datetime.datetime\n    * numpy.datetime64\n    * str\n    \"\"\"\n    assert request.param in {\"timestamp\", \"pydatetime\", \"datetime64\", \"str_1960\"}\n    if request.param == \"timestamp\":\n        return epoch_1960\n    elif request.param == \"pydatetime\":\n        return epoch_1960.to_pydatetime()\n    elif request.param == \"datetime64\":\n        return epoch_1960.to_datetime64()\n    else:\n        return str(epoch_1960)\n\n\n@pytest.fixture\ndef julian_dates():\n    return date_range(\"2014-1-1\", periods=10).to_julian_date().values\n\n\nclass TestOrigin:\n    def test_origin_and_unit(self):\n        # GH#42624\n        ts = to_datetime(1, unit=\"s\", origin=1)\n        expected = Timestamp(\"1970-01-01 00:00:02\")\n        assert ts == expected\n\n        ts = to_datetime(1, unit=\"s\", origin=1_000_000_000)\n        expected = Timestamp(\"2001-09-09 01:46:41\")\n        assert ts == expected\n\n    def test_julian(self, julian_dates):\n        # gh-11276, gh-11745\n        # for origin as julian\n\n        result = Series(to_datetime(julian_dates, unit=\"D\", origin=\"julian\"))\n        expected = Series(\n            to_datetime(julian_dates - Timestamp(0).to_julian_date(), unit=\"D\")\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_unix(self):\n        result = Series(to_datetime([0, 1, 2], unit=\"D\", origin=\"unix\"))\n        expected = Series(\n            [Timestamp(\"1970-01-01\"), Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n    def test_julian_round_trip(self):\n        result = to_datetime(2456658, origin=\"julian\", unit=\"D\")\n        assert result.to_julian_date() == 2456658\n\n        # out-of-bounds\n        msg = \"1 is Out of Bounds for origin='julian'\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(1, origin=\"julian\", unit=\"D\")\n\n    def test_invalid_unit(self, units, julian_dates):\n        # checking for invalid combination of origin='julian' and unit != D\n        if units != \"D\":\n            msg = \"unit must be 'D' for origin='julian'\"\n            with pytest.raises(ValueError, match=msg):\n                to_datetime(julian_dates, unit=units, origin=\"julian\")\n\n    @pytest.mark.parametrize(\"unit\", [\"ns\", \"D\"])\n    def test_invalid_origin(self, unit):\n        # need to have a numeric specified\n        msg = \"it must be numeric with a unit specified\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime(\"2005-01-01\", origin=\"1960-01-01\", unit=unit)\n\n    def test_epoch(self, units, epochs, epoch_1960, units_from_epochs):\n        expected = Series(\n            [pd.Timedelta(x, unit=units) + epoch_1960 for x in units_from_epochs]\n        )\n\n        result = Series(to_datetime(units_from_epochs, unit=units, origin=epochs))\n        tm.assert_series_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"origin, exc\",\n        [\n            (\"random_string\", ValueError),\n            (\"epoch\", ValueError),\n            (\"13-24-1990\", ValueError),\n            (datetime(1, 1, 1), OutOfBoundsDatetime),\n        ],\n    )\n    def test_invalid_origins(self, origin, exc, units, units_from_epochs):\n        msg = \"|\".join(\n            [\n                f\"origin {origin} is Out of Bounds\",\n                f\"origin {origin} cannot be converted to a Timestamp\",\n                \"Cannot cast .* to unit='ns' without overflow\",\n            ]\n        )\n        with pytest.raises(exc, match=msg):\n            to_datetime(units_from_epochs, unit=units, origin=origin)\n\n    def test_invalid_origins_tzinfo(self):\n        # GH16842\n        with pytest.raises(ValueError, match=\"must be tz-naive\"):\n            to_datetime(1, unit=\"D\", origin=datetime(2000, 1, 1, tzinfo=pytz.utc))\n\n    def test_incorrect_value_exception(self):\n        # GH47495\n        msg = (\n            \"Unknown datetime string format, unable to parse: yesterday, at position 1\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([\"today\", \"yesterday\"])\n\n    @pytest.mark.parametrize(\n        \"format, warning\",\n        [\n            (None, UserWarning),\n            (\"%Y-%m-%d %H:%M:%S\", None),\n            (\"%Y-%d-%m %H:%M:%S\", None),\n        ],\n    )\n    def test_to_datetime_out_of_bounds_with_format_arg(self, format, warning):\n        # see gh-23830\n        msg = r\"^Out of bounds nanosecond timestamp: 2417-10-10 00:00:00, at position 0\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime(\"2417-10-10 00:00:00\", format=format)\n\n    @pytest.mark.parametrize(\n        \"arg, origin, expected_str\",\n        [\n            [200 * 365, \"unix\", \"2169-11-13 00:00:00\"],\n            [200 * 365, \"1870-01-01\", \"2069-11-13 00:00:00\"],\n            [300 * 365, \"1870-01-01\", \"2169-10-20 00:00:00\"],\n        ],\n    )\n    def test_processing_order(self, arg, origin, expected_str):\n        # make sure we handle out-of-bounds *before*\n        # constructing the dates\n\n        result = to_datetime(arg, unit=\"D\", origin=origin)\n        expected = Timestamp(expected_str)\n        assert result == expected\n\n        result = to_datetime(200 * 365, unit=\"D\", origin=\"1870-01-01\")\n        expected = Timestamp(\"2069-11-13 00:00:00\")\n        assert result == expected\n\n        result = to_datetime(300 * 365, unit=\"D\", origin=\"1870-01-01\")\n        expected = Timestamp(\"2169-10-20 00:00:00\")\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"offset,utc,exp\",\n        [\n            [\"Z\", True, \"2019-01-01T00:00:00.000Z\"],\n            [\"Z\", None, \"2019-01-01T00:00:00.000Z\"],\n            [\"-01:00\", True, \"2019-01-01T01:00:00.000Z\"],\n            [\"-01:00\", None, \"2019-01-01T00:00:00.000-01:00\"],\n        ],\n    )\n    def test_arg_tz_ns_unit(self, offset, utc, exp):\n        # GH 25546\n        arg = \"2019-01-01T00:00:00.000\" + offset\n        result = to_datetime([arg], unit=\"ns\", utc=utc)\n        expected = to_datetime([exp])\n        tm.assert_index_equal(result, expected)\n\n\nclass TestShouldCache:\n    @pytest.mark.parametrize(\n        \"listlike,do_caching\",\n        [\n            ([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], False),\n            ([1, 1, 1, 1, 4, 5, 6, 7, 8, 9], True),\n        ],\n    )\n    def test_should_cache(self, listlike, do_caching):\n        assert (\n            tools.should_cache(listlike, check_count=len(listlike), unique_share=0.7)\n            == do_caching\n        )\n\n    @pytest.mark.parametrize(\n        \"unique_share,check_count, err_message\",\n        [\n            (0.5, 11, r\"check_count must be in next bounds: \\[0; len\\(arg\\)\\]\"),\n            (10, 2, r\"unique_share must be in next bounds: \\(0; 1\\)\"),\n        ],\n    )\n    def test_should_cache_errors(self, unique_share, check_count, err_message):\n        arg = [5] * 10\n\n        with pytest.raises(AssertionError, match=err_message):\n            tools.should_cache(arg, unique_share, check_count)\n\n    @pytest.mark.parametrize(\n        \"listlike\",\n        [\n            (deque([Timestamp(\"2010-06-02 09:30:00\")] * 51)),\n            ([Timestamp(\"2010-06-02 09:30:00\")] * 51),\n            (tuple([Timestamp(\"2010-06-02 09:30:00\")] * 51)),\n        ],\n    )\n    def test_no_slicing_errors_in_should_cache(self, listlike):\n        # GH#29403\n        assert tools.should_cache(listlike) is True\n\n\ndef test_nullable_integer_to_datetime():\n    # Test for #30050\n    ser = Series([1, 2, None, 2**61, None])\n    ser = ser.astype(\"Int64\")\n    ser_copy = ser.copy()\n\n    res = to_datetime(ser, unit=\"ns\")\n\n    expected = Series(\n        [\n            np.datetime64(\"1970-01-01 00:00:00.000000001\"),\n            np.datetime64(\"1970-01-01 00:00:00.000000002\"),\n            np.datetime64(\"NaT\"),\n            np.datetime64(\"2043-01-25 23:56:49.213693952\"),\n            np.datetime64(\"NaT\"),\n        ]\n    )\n    tm.assert_series_equal(res, expected)\n    # Check that ser isn't mutated\n    tm.assert_series_equal(ser, ser_copy)\n\n\n@pytest.mark.parametrize(\"klass\", [np.array, list])\ndef test_na_to_datetime(nulls_fixture, klass):\n    if isinstance(nulls_fixture, Decimal):\n        with pytest.raises(TypeError, match=\"not convertible to datetime\"):\n            to_datetime(klass([nulls_fixture]))\n\n    else:\n        result = to_datetime(klass([nulls_fixture]))\n\n        assert result[0] is NaT\n\n\n@pytest.mark.parametrize(\"errors\", [\"raise\", \"coerce\", \"ignore\"])\n@pytest.mark.parametrize(\n    \"args, format\",\n    [\n        ([\"03/24/2016\", \"03/25/2016\", \"\"], \"%m/%d/%Y\"),\n        ([\"2016-03-24\", \"2016-03-25\", \"\"], \"%Y-%m-%d\"),\n    ],\n    ids=[\"non-ISO8601\", \"ISO8601\"],\n)\ndef test_empty_string_datetime(errors, args, format):\n    # GH13044, GH50251\n    td = Series(args)\n\n    # coerce empty string to pd.NaT\n    result = to_datetime(td, format=format, errors=errors)\n    expected = Series([\"2016-03-24\", \"2016-03-25\", NaT], dtype=\"datetime64[ns]\")\n    tm.assert_series_equal(expected, result)\n\n\ndef test_empty_string_datetime_coerce__unit():\n    # GH13044\n    # coerce empty string to pd.NaT\n    result = to_datetime([1, \"\"], unit=\"s\", errors=\"coerce\")\n    expected = DatetimeIndex([\"1970-01-01 00:00:01\", \"NaT\"], dtype=\"datetime64[ns]\")\n    tm.assert_index_equal(expected, result)\n\n    # verify that no exception is raised even when errors='raise' is set\n    result = to_datetime([1, \"\"], unit=\"s\", errors=\"raise\")\n    tm.assert_index_equal(expected, result)\n\n\n@td.skip_if_no(\"xarray\")\ndef test_xarray_coerce_unit():\n    # GH44053\n    import xarray as xr\n\n    arr = xr.DataArray([1, 2, 3])\n    result = to_datetime(arr, unit=\"ns\")\n    expected = DatetimeIndex(\n        [\n            \"1970-01-01 00:00:00.000000001\",\n            \"1970-01-01 00:00:00.000000002\",\n            \"1970-01-01 00:00:00.000000003\",\n        ],\n        dtype=\"datetime64[ns]\",\n        freq=None,\n    )\n    tm.assert_index_equal(result, expected)\n\n\n@pytest.mark.parametrize(\"cache\", [True, False])\ndef test_to_datetime_monotonic_increasing_index(cache):\n    # GH28238\n    cstart = start_caching_at\n    times = date_range(Timestamp(\"1980\"), periods=cstart, freq=\"YS\")\n    times = times.to_frame(index=False, name=\"DT\").sample(n=cstart, random_state=1)\n    times.index = times.index.to_series().astype(float) / 1000\n    result = to_datetime(times.iloc[:, 0], cache=cache)\n    expected = times.iloc[:, 0]\n    tm.assert_series_equal(result, expected)\n\n\n@pytest.mark.parametrize(\n    \"series_length\",\n    [40, start_caching_at, (start_caching_at + 1), (start_caching_at + 5)],\n)\ndef test_to_datetime_cache_coerce_50_lines_outofbounds(series_length):\n    # GH#45319\n    s = Series(\n        [datetime.fromisoformat(\"1446-04-12 00:00:00+00:00\")]\n        + ([datetime.fromisoformat(\"1991-10-20 00:00:00+00:00\")] * series_length)\n    )\n    result1 = to_datetime(s, errors=\"coerce\", utc=True)\n\n    expected1 = Series(\n        [NaT] + ([Timestamp(\"1991-10-20 00:00:00+00:00\")] * series_length)\n    )\n\n    tm.assert_series_equal(result1, expected1)\n\n    result2 = to_datetime(s, errors=\"ignore\", utc=True)\n\n    expected2 = Series(\n        [datetime.fromisoformat(\"1446-04-12 00:00:00+00:00\")]\n        + ([datetime.fromisoformat(\"1991-10-20 00:00:00+00:00\")] * series_length)\n    )\n\n    tm.assert_series_equal(result2, expected2)\n\n    with pytest.raises(OutOfBoundsDatetime, match=\"Out of bounds nanosecond timestamp\"):\n        to_datetime(s, errors=\"raise\", utc=True)\n\n\ndef test_to_datetime_format_f_parse_nanos():\n    # GH 48767\n    timestamp = \"15/02/2020 02:03:04.123456789\"\n    timestamp_format = \"%d/%m/%Y %H:%M:%S.%f\"\n    result = to_datetime(timestamp, format=timestamp_format)\n    expected = Timestamp(\n        year=2020,\n        month=2,\n        day=15,\n        hour=2,\n        minute=3,\n        second=4,\n        microsecond=123456,\n        nanosecond=789,\n    )\n    assert result == expected\n\n\ndef test_to_datetime_mixed_iso8601():\n    # https://github.com/pandas-dev/pandas/issues/50411\n    result = to_datetime([\"2020-01-01\", \"2020-01-01 05:00:00\"], format=\"ISO8601\")\n    expected = DatetimeIndex([\"2020-01-01 00:00:00\", \"2020-01-01 05:00:00\"])\n    tm.assert_index_equal(result, expected)\n\n\ndef test_to_datetime_mixed_other():\n    # https://github.com/pandas-dev/pandas/issues/50411\n    result = to_datetime([\"01/11/2000\", \"12 January 2000\"], format=\"mixed\")\n    expected = DatetimeIndex([\"2000-01-11\", \"2000-01-12\"])\n    tm.assert_index_equal(result, expected)\n\n\n@pytest.mark.parametrize(\"exact\", [True, False])\n@pytest.mark.parametrize(\"format\", [\"ISO8601\", \"mixed\"])\ndef test_to_datetime_mixed_or_iso_exact(exact, format):\n    msg = \"Cannot use 'exact' when 'format' is 'mixed' or 'ISO8601'\"\n    with pytest.raises(ValueError, match=msg):\n        to_datetime([\"2020-01-01\"], exact=exact, format=format)\n\n\ndef test_to_datetime_mixed_not_necessarily_iso8601_raise():\n    # https://github.com/pandas-dev/pandas/issues/50411\n    with pytest.raises(\n        ValueError, match=\"Time data 01-01-2000 is not ISO8601 format, at position 1\"\n    ):\n        to_datetime([\"2020-01-01\", \"01-01-2000\"], format=\"ISO8601\")\n\n\n@pytest.mark.parametrize(\n    (\"errors\", \"expected\"),\n    [\n        (\"coerce\", DatetimeIndex([\"2020-01-01 00:00:00\", NaT])),\n        (\"ignore\", Index([\"2020-01-01\", \"01-01-2000\"])),\n    ],\n)\ndef test_to_datetime_mixed_not_necessarily_iso8601_coerce(errors, expected):\n    # https://github.com/pandas-dev/pandas/issues/50411\n    result = to_datetime([\"2020-01-01\", \"01-01-2000\"], format=\"ISO8601\", errors=errors)\n    tm.assert_index_equal(result, expected)\n\n\ndef test_ignoring_unknown_tz_deprecated():\n    # GH#18702, GH#51476\n    dtstr = \"2014 Jan 9 05:15 FAKE\"\n    msg = 'un-recognized timezone \"FAKE\". Dropping unrecognized timezones is deprecated'\n    with tm.assert_produces_warning(FutureWarning, match=msg):\n        res = Timestamp(dtstr)\n    assert res == Timestamp(dtstr[:-5])\n\n    with tm.assert_produces_warning(FutureWarning):\n        res = to_datetime(dtstr)\n    assert res == to_datetime(dtstr[:-5])\n    with tm.assert_produces_warning(FutureWarning):\n        res = to_datetime([dtstr])\n    tm.assert_index_equal(res, to_datetime([dtstr[:-5]]))\n\n\ndef test_from_numeric_arrow_dtype(any_numeric_ea_dtype):\n    # GH 52425\n    pytest.importorskip(\"pyarrow\")\n    ser = Series([1, 2], dtype=f\"{any_numeric_ea_dtype.lower()}[pyarrow]\")\n    result = to_datetime(ser)\n    expected = Series([1, 2], dtype=\"datetime64[ns]\")\n    tm.assert_series_equal(result, expected)\n"
    },
    {
      "filename": "pandas/tests/tslibs/test_parsing.py",
      "content": "\"\"\"\nTests for Timestamp parsing, aimed at pandas/_libs/tslibs/parsing.pyx\n\"\"\"\nfrom datetime import datetime\nimport re\n\nfrom dateutil.parser import parse as du_parse\nfrom dateutil.tz import tzlocal\nimport numpy as np\nimport pytest\n\nfrom pandas._libs.tslibs import (\n    parsing,\n    strptime,\n)\nfrom pandas._libs.tslibs.parsing import parse_datetime_string_with_reso\nfrom pandas.compat import (\n    ISMUSL,\n    is_platform_windows,\n)\nimport pandas.util._test_decorators as td\n\nimport pandas._testing as tm\n\n\n@pytest.mark.skipif(\n    is_platform_windows() or ISMUSL,\n    reason=\"TZ setting incorrect on Windows and MUSL Linux\",\n)\ndef test_parsing_tzlocal_deprecated():\n    # GH#50791\n    msg = \"Pass the 'tz' keyword or call tz_localize after construction instead\"\n    dtstr = \"Jan 15 2004 03:00 EST\"\n\n    with tm.set_timezone(\"US/Eastern\"):\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            res, _ = parse_datetime_string_with_reso(dtstr)\n\n        assert isinstance(res.tzinfo, tzlocal)\n\n        with tm.assert_produces_warning(FutureWarning, match=msg):\n            res = parsing.py_parse_datetime_string(dtstr)\n        assert isinstance(res.tzinfo, tzlocal)\n\n\ndef test_parse_datetime_string_with_reso():\n    (parsed, reso) = parse_datetime_string_with_reso(\"4Q1984\")\n    (parsed_lower, reso_lower) = parse_datetime_string_with_reso(\"4q1984\")\n\n    assert reso == reso_lower\n    assert parsed == parsed_lower\n\n\ndef test_parse_datetime_string_with_reso_nanosecond_reso():\n    # GH#46811\n    parsed, reso = parse_datetime_string_with_reso(\"2022-04-20 09:19:19.123456789\")\n    assert reso == \"nanosecond\"\n\n\ndef test_parse_datetime_string_with_reso_invalid_type():\n    # Raise on invalid input, don't just return it\n    msg = \"Argument 'date_string' has incorrect type (expected str, got tuple)\"\n    with pytest.raises(TypeError, match=re.escape(msg)):\n        parse_datetime_string_with_reso((4, 5))\n\n\n@pytest.mark.parametrize(\n    \"dashed,normal\", [(\"1988-Q2\", \"1988Q2\"), (\"2Q-1988\", \"2Q1988\")]\n)\ndef test_parse_time_quarter_with_dash(dashed, normal):\n    # see gh-9688\n    (parsed_dash, reso_dash) = parse_datetime_string_with_reso(dashed)\n    (parsed, reso) = parse_datetime_string_with_reso(normal)\n\n    assert parsed_dash == parsed\n    assert reso_dash == reso\n\n\n@pytest.mark.parametrize(\"dashed\", [\"-2Q1992\", \"2-Q1992\", \"4-4Q1992\"])\ndef test_parse_time_quarter_with_dash_error(dashed):\n    msg = f\"Unknown datetime string format, unable to parse: {dashed}\"\n\n    with pytest.raises(parsing.DateParseError, match=msg):\n        parse_datetime_string_with_reso(dashed)\n\n\n@pytest.mark.parametrize(\n    \"date_string,expected\",\n    [\n        (\"123.1234\", False),\n        (\"-50000\", False),\n        (\"999\", False),\n        (\"m\", False),\n        (\"T\", False),\n        (\"Mon Sep 16, 2013\", True),\n        (\"2012-01-01\", True),\n        (\"01/01/2012\", True),\n        (\"01012012\", True),\n        (\"0101\", True),\n        (\"1-1\", True),\n    ],\n)\ndef test_does_not_convert_mixed_integer(date_string, expected):\n    assert parsing._does_string_look_like_datetime(date_string) is expected\n\n\n@pytest.mark.parametrize(\n    \"date_str,kwargs,msg\",\n    [\n        (\n            \"2013Q5\",\n            {},\n            (\n                \"Incorrect quarterly string is given, \"\n                \"quarter must be between 1 and 4: 2013Q5\"\n            ),\n        ),\n        # see gh-5418\n        (\n            \"2013Q1\",\n            {\"freq\": \"INVLD-L-DEC-SAT\"},\n            (\n                \"Unable to retrieve month information \"\n                \"from given freq: INVLD-L-DEC-SAT\"\n            ),\n        ),\n    ],\n)\ndef test_parsers_quarterly_with_freq_error(date_str, kwargs, msg):\n    with pytest.raises(parsing.DateParseError, match=msg):\n        parsing.parse_datetime_string_with_reso(date_str, **kwargs)\n\n\n@pytest.mark.parametrize(\n    \"date_str,freq,expected\",\n    [\n        (\"2013Q2\", None, datetime(2013, 4, 1)),\n        (\"2013Q2\", \"A-APR\", datetime(2012, 8, 1)),\n        (\"2013-Q2\", \"A-DEC\", datetime(2013, 4, 1)),\n    ],\n)\ndef test_parsers_quarterly_with_freq(date_str, freq, expected):\n    result, _ = parsing.parse_datetime_string_with_reso(date_str, freq=freq)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"date_str\", [\"2Q 2005\", \"2Q-200A\", \"2Q-200\", \"22Q2005\", \"2Q200.\", \"6Q-20\"]\n)\ndef test_parsers_quarter_invalid(date_str):\n    if date_str == \"6Q-20\":\n        msg = (\n            \"Incorrect quarterly string is given, quarter \"\n            f\"must be between 1 and 4: {date_str}\"\n        )\n    else:\n        msg = f\"Unknown datetime string format, unable to parse: {date_str}\"\n\n    with pytest.raises(ValueError, match=msg):\n        parsing.parse_datetime_string_with_reso(date_str)\n\n\n@pytest.mark.parametrize(\n    \"date_str,expected\",\n    [(\"201101\", datetime(2011, 1, 1, 0, 0)), (\"200005\", datetime(2000, 5, 1, 0, 0))],\n)\ndef test_parsers_month_freq(date_str, expected):\n    result, _ = parsing.parse_datetime_string_with_reso(date_str, freq=\"M\")\n    assert result == expected\n\n\n@td.skip_if_not_us_locale\n@pytest.mark.parametrize(\n    \"string,fmt\",\n    [\n        (\"20111230\", \"%Y%m%d\"),\n        (\"201112300000\", \"%Y%m%d%H%M\"),\n        (\"20111230000000\", \"%Y%m%d%H%M%S\"),\n        (\"20111230T00\", \"%Y%m%dT%H\"),\n        (\"20111230T0000\", \"%Y%m%dT%H%M\"),\n        (\"20111230T000000\", \"%Y%m%dT%H%M%S\"),\n        (\"2011-12-30\", \"%Y-%m-%d\"),\n        (\"2011\", \"%Y\"),\n        (\"2011-01\", \"%Y-%m\"),\n        (\"30-12-2011\", \"%d-%m-%Y\"),\n        (\"2011-12-30 00:00:00\", \"%Y-%m-%d %H:%M:%S\"),\n        (\"2011-12-30T00:00:00\", \"%Y-%m-%dT%H:%M:%S\"),\n        (\"2011-12-30T00:00:00UTC\", \"%Y-%m-%dT%H:%M:%S%Z\"),\n        (\"2011-12-30T00:00:00Z\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+9\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+09\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+090\", None),\n        (\"2011-12-30T00:00:00+0900\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00-0900\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+09:00\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+09:000\", None),\n        (\"2011-12-30T00:00:00+9:0\", \"%Y-%m-%dT%H:%M:%S%z\"),\n        (\"2011-12-30T00:00:00+09:\", None),\n        (\"2011-12-30T00:00:00.000000UTC\", \"%Y-%m-%dT%H:%M:%S.%f%Z\"),\n        (\"2011-12-30T00:00:00.000000Z\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+9\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+09\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+090\", None),\n        (\"2011-12-30T00:00:00.000000+0900\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000-0900\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+09:00\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+09:000\", None),\n        (\"2011-12-30T00:00:00.000000+9:0\", \"%Y-%m-%dT%H:%M:%S.%f%z\"),\n        (\"2011-12-30T00:00:00.000000+09:\", None),\n        (\"2011-12-30 00:00:00.000000\", \"%Y-%m-%d %H:%M:%S.%f\"),\n        (\"Tue 24 Aug 2021 01:30:48\", \"%a %d %b %Y %H:%M:%S\"),\n        (\"Tuesday 24 Aug 2021 01:30:48\", \"%A %d %b %Y %H:%M:%S\"),\n        (\"Tue 24 Aug 2021 01:30:48 AM\", None),\n        (\"Tuesday 24 Aug 2021 01:30:48 AM\", None),\n        (\"27.03.2003 14:55:00.000\", \"%d.%m.%Y %H:%M:%S.%f\"),  # GH50317\n    ],\n)\ndef test_guess_datetime_format_with_parseable_formats(string, fmt):\n    with tm.maybe_produces_warning(\n        UserWarning, fmt is not None and re.search(r\"%d.*%m\", fmt)\n    ):\n        result = parsing.guess_datetime_format(string)\n    assert result == fmt\n\n\n@pytest.mark.parametrize(\"dayfirst,expected\", [(True, \"%d/%m/%Y\"), (False, \"%m/%d/%Y\")])\ndef test_guess_datetime_format_with_dayfirst(dayfirst, expected):\n    ambiguous_string = \"01/01/2011\"\n    result = parsing.guess_datetime_format(ambiguous_string, dayfirst=dayfirst)\n    assert result == expected\n\n\n@td.skip_if_not_us_locale\n@pytest.mark.parametrize(\n    \"string,fmt\",\n    [\n        (\"30/Dec/2011\", \"%d/%b/%Y\"),\n        (\"30/December/2011\", \"%d/%B/%Y\"),\n        (\"30/Dec/2011 00:00:00\", \"%d/%b/%Y %H:%M:%S\"),\n    ],\n)\ndef test_guess_datetime_format_with_locale_specific_formats(string, fmt):\n    result = parsing.guess_datetime_format(string)\n    assert result == fmt\n\n\n@pytest.mark.parametrize(\n    \"invalid_dt\",\n    [\n        \"01/2013\",\n        \"12:00:00\",\n        \"1/1/1/1\",\n        \"this_is_not_a_datetime\",\n        \"51a\",\n        \"13/2019\",\n        \"202001\",  # YYYYMM isn't ISO8601\n        \"2020/01\",  # YYYY/MM isn't ISO8601 either\n        \"87156549591102612381000001219H5\",\n    ],\n)\ndef test_guess_datetime_format_invalid_inputs(invalid_dt):\n    # A datetime string must include a year, month and a day for it to be\n    # guessable, in addition to being a string that looks like a datetime.\n    assert parsing.guess_datetime_format(invalid_dt) is None\n\n\n@pytest.mark.parametrize(\"invalid_type_dt\", [9, datetime(2011, 1, 1)])\ndef test_guess_datetime_format_wrong_type_inputs(invalid_type_dt):\n    # A datetime string must include a year, month and a day for it to be\n    # guessable, in addition to being a string that looks like a datetime.\n    with pytest.raises(\n        TypeError,\n        match=r\"^Argument 'dt_str' has incorrect type \\(expected str, got .*\\)$\",\n    ):\n        parsing.guess_datetime_format(invalid_type_dt)\n\n\n@pytest.mark.parametrize(\n    \"string,fmt,dayfirst,warning\",\n    [\n        (\"2011-1-1\", \"%Y-%m-%d\", False, None),\n        (\"2011-1-1\", \"%Y-%d-%m\", True, None),\n        (\"1/1/2011\", \"%m/%d/%Y\", False, None),\n        (\"1/1/2011\", \"%d/%m/%Y\", True, None),\n        (\"30-1-2011\", \"%d-%m-%Y\", False, UserWarning),\n        (\"30-1-2011\", \"%d-%m-%Y\", True, None),\n        (\"2011-1-1 0:0:0\", \"%Y-%m-%d %H:%M:%S\", False, None),\n        (\"2011-1-1 0:0:0\", \"%Y-%d-%m %H:%M:%S\", True, None),\n        (\"2011-1-3T00:00:0\", \"%Y-%m-%dT%H:%M:%S\", False, None),\n        (\"2011-1-3T00:00:0\", \"%Y-%d-%mT%H:%M:%S\", True, None),\n        (\"2011-1-1 00:00:00\", \"%Y-%m-%d %H:%M:%S\", False, None),\n        (\"2011-1-1 00:00:00\", \"%Y-%d-%m %H:%M:%S\", True, None),\n    ],\n)\ndef test_guess_datetime_format_no_padding(string, fmt, dayfirst, warning):\n    # see gh-11142\n    msg = (\n        rf\"Parsing dates in {fmt} format when dayfirst=False \\(the default\\) \"\n        \"was specified. \"\n        \"Pass `dayfirst=True` or specify a format to silence this warning.\"\n    )\n    with tm.assert_produces_warning(warning, match=msg):\n        result = parsing.guess_datetime_format(string, dayfirst=dayfirst)\n    assert result == fmt\n\n\ndef test_try_parse_dates():\n    arr = np.array([\"5/1/2000\", \"6/1/2000\", \"7/1/2000\"], dtype=object)\n    result = parsing.try_parse_dates(arr, parser=lambda x: du_parse(x, dayfirst=True))\n\n    expected = np.array([du_parse(d, dayfirst=True) for d in arr])\n    tm.assert_numpy_array_equal(result, expected)\n\n\ndef test_parse_datetime_string_with_reso_check_instance_type_raise_exception():\n    # issue 20684\n    msg = \"Argument 'date_string' has incorrect type (expected str, got tuple)\"\n    with pytest.raises(TypeError, match=re.escape(msg)):\n        parse_datetime_string_with_reso((1, 2, 3))\n\n    result = parse_datetime_string_with_reso(\"2019\")\n    expected = (datetime(2019, 1, 1), \"year\")\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"fmt,expected\",\n    [\n        (\"%Y %m %d %H:%M:%S\", True),\n        (\"%Y/%m/%d %H:%M:%S\", True),\n        (r\"%Y\\%m\\%d %H:%M:%S\", True),\n        (\"%Y-%m-%d %H:%M:%S\", True),\n        (\"%Y.%m.%d %H:%M:%S\", True),\n        (\"%Y%m%d %H:%M:%S\", True),\n        (\"%Y-%m-%dT%H:%M:%S\", True),\n        (\"%Y-%m-%dT%H:%M:%S%z\", True),\n        (\"%Y-%m-%dT%H:%M:%S%Z\", False),\n        (\"%Y-%m-%dT%H:%M:%S.%f\", True),\n        (\"%Y-%m-%dT%H:%M:%S.%f%z\", True),\n        (\"%Y-%m-%dT%H:%M:%S.%f%Z\", False),\n        (\"%Y%m%d\", True),\n        (\"%Y%m\", False),\n        (\"%Y\", True),\n        (\"%Y-%m-%d\", True),\n        (\"%Y-%m\", True),\n    ],\n)\ndef test_is_iso_format(fmt, expected):\n    # see gh-41047\n    result = strptime._test_format_is_iso(fmt)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"input\",\n    [\n        \"2018-01-01T00:00:00.123456789\",\n        \"2018-01-01T00:00:00.123456\",\n        \"2018-01-01T00:00:00.123\",\n    ],\n)\ndef test_guess_datetime_format_f(input):\n    # https://github.com/pandas-dev/pandas/issues/49043\n    result = parsing.guess_datetime_format(input)\n    expected = \"%Y-%m-%dT%H:%M:%S.%f\"\n    assert result == expected\n"
    }
  ],
  "questions": [
    "thanks @juli4nb4dillo for the report (and @lithomas1 for the ping!)\r\n\r\nthis looks like a bug: we have\r\n```python\r\nIn [2]: guess_datetime_format('4/21/2023 11:06:35 AM')\r\nOut[2]: '%m/%d/%Y %H:%M:%S %p'\r\n```\r\nand it looks like this should instead have been\r\n```python\r\n'%m/%d/%Y %I:%M:%S %p'\r\n```\r\n?",
    "so something like\r\n- if %I is in the guessed format and %H is there too, replace %H with %I\r\n- if %I is in the guessed format, and neither %H nor %I are, then return `None`\r\n\r\nAnyone fancy making a PR?"
  ],
  "golden_answers": [
    "This is the part of the code which would need changing\r\n\r\n[pandas/_libs/tslibs/parsing.pyx](https://github.com/pandas-dev/pandas/blob/d389bd814b1fba0fd112f2cc40c8a915855e02bc/pandas/_libs/tslibs/parsing.pyx#L867-L1035)\r\n\r\nNot sure whether to suggest special-casing '`%H'` to become `'%I'` if there's `%p`, or to just stop guessing `'%p'` for safety. Tempted to go with the latter",
    "import pandas as pd\r\n\r\ndf = pd.DataFrame(['4/21/2023 11:06:35 AM', '4/21/2023 12:06:35 PM', '4/21/2023 1:00:48 PM', '4/21/2023 2:35:37 PM'], columns=['datetime_string'])\r\ndf['datetime'] = pd.to_datetime(df['datetime_string'], infer_datetime_format=True)\r\n\r\nprint(df)\r\n\r\n\r\n\r\nresult :\r\n\r\n       datetime_string            datetime\r\n0  4/21/2023 11:06:35 AM 2023-04-21 11:06:35\r\n1  4/21/2023 12:06:35 PM 2023-04-21 12:06:35\r\n2   4/21/2023 1:00:48 PM 2023-04-21 13:00:48\r\n3   4/21/2023 2:35:37 PM 2023-04-21 14:35:37\r\n\r\n\r\n In this code, we import the pandas library, create a DataFrame called df with the datetime strings, and add a new column called 'datetime'. The pd.to_datetime() function is used to convert the datetime strings to datetime objects. By setting infer_datetime_format=True, pandas will automatically infer the format of the datetime strings, including the AM/PM indicator."
  ],
  "questions_generated": [
    "What functionality is affected by the bug in the 'pandas-dev/pandas' repository, and how does it manifest?",
    "In the context of the provided example, how does the expected behavior of 'to_datetime' differ from the actual behavior due to the bug?",
    "How does the code structure of 'pandas/tests/tools/test_to_datetime.py' relate to testing the issue described in the bug report?",
    "What strategies could be employed to address the issue where 'to_datetime' ignores 'AM' and 'PM' indicators?",
    "Why is it important to set explicit formats in date-time parsing functions, and how does it relate to the bug in this issue?"
  ],
  "golden_answers_generated": [
    "The functionality affected by the bug is the 'to_datetime' function in the Pandas library. This function is supposed to convert a string representation of dates and times into Pandas datetime objects. The bug manifests when 'AM' and 'PM' indicators are ignored unless the 'format' parameter is explicitly set, leading to incorrect conversion where times like '1:00 PM' are interpreted as '01:00' instead of '13:00'.",
    "In the provided example, the expected behavior of 'to_datetime' is to convert times with 'PM' indicators to their 24-hour equivalents (e.g., '1:00 PM' to '13:00'). However, due to the bug, the actual behavior is that 'to_datetime' ignores the 'PM' indicator and interprets '1:00 PM' as '01:00', resulting in an incorrect conversion.",
    "The file 'pandas/tests/tools/test_to_datetime.py' contains tests related to the 'to_datetime' function, which is at the core of the issue described in the bug report. This file includes tests that verify the correct conversion of various date-time formats, and it likely needs to be updated to include test cases that ensure 'AM' and 'PM' indicators are correctly interpreted without explicitly setting the 'format' parameter.",
    "To address this issue, developers could modify the 'to_datetime' function to automatically detect and correctly interpret 'AM' and 'PM' indicators in the input strings. This might involve enhancing the parsing logic to recognize 12-hour time formats and convert them to 24-hour time formats correctly. Additionally, implementing more comprehensive tests in 'pandas/tests/tools/test_to_datetime.py' would ensure that the parsing logic handles 'AM' and 'PM' as expected.",
    "Setting explicit formats in date-time parsing functions is important because it provides a clear blueprint for how the input strings should be interpreted, reducing ambiguity and the likelihood of errors. In the context of this bug, the need for an explicit format arises because the 'to_datetime' function fails to automatically handle 'AM' and 'PM' indicators, leading to incorrect conversions. By setting an explicit format, users can circumvent this issue, though ideally, the function should handle common time formats automatically."
  ]
}