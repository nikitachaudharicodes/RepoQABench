{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "13919",
  "issue_description": "# ERR: Categoricals should not allow non-strings when an object dtype is passed\n\nHDF Store (with `table`) doesn't support categories with mixed type inside a category \n\nEven though it is possible to store category type using `to_hdf` with `table`, you can't do that when you have mixed types inside the category. It would be nice to mention this at least on docs.\n#### Code Sample, a copy-pastable example if possible\n\n```\nimport pandas as pd\ndf = pd.DataFrame({'a':[1, 'string']})\ndf['a'] = df['a'].astype('category')\ndf.to_hdf('play.hdf', 'main', format='table')\n```\n\nthe error:\n\n```\nTypeError: Cannot serialize the column [values] because\nits data contents are [mixed-integer] object dtype\n```\n#### Expected Output\n\nNo error, saved file.\n#### output of `pd.show_versions()`\n\n```\nINSTALLED VERSIONS\n------------------\ncommit: None\npython: 3.5.1.final.0\npython-bits: 64\nOS: Linux\nOS-release: 4.6.4-1-ARCH\nmachine: x86_64\nprocessor: \nbyteorder: little\nLC_ALL: None\nLANG: en_US.UTF-8\n\npandas: 0.18.0\nnose: 1.3.7\npip: 8.1.1\nsetuptools: 20.3\nCython: None\nnumpy: 1.10.4\nscipy: 0.17.0\nstatsmodels: None\nxarray: None\nIPython: 4.1.2\nsphinx: 1.4.1\npatsy: None\ndateutil: 2.5.2\npytz: 2016.3\nblosc: None\nbottleneck: None\ntables: 3.2.2\nnumexpr: 2.5.1\nmatplotlib: 1.5.1\nopenpyxl: None\nxlrd: 1.0.0\nxlwt: None\nxlsxwriter: None\nlxml: None\nbs4: 4.4.1\nhtml5lib: 0.999\nhttplib2: None\napiclient: None\nsqlalchemy: None\npymysql: None\npsycopg2: None\njinja2: 2.8\nboto: None\n```\n",
  "issue_comments": [
    {
      "id": 237853795,
      "user": "jreback",
      "body": "this is in general a completely bad idea. categories are by-definition single dtypes (and not object), except for strings.\n\nThese should raise actually on creation.\n"
    },
    {
      "id": 237853922,
      "user": "jreback",
      "body": "if you'd like to push a PR for error reporting in catetgorical creation that would be great.\n"
    },
    {
      "id": 237856436,
      "user": "hnykda",
      "body": "Yeah, I agree with you that it should be raised on creation. \n\nI had a thousands of columns loaded from CSV and was converting them automatically to categories based on something like `len(column.unique())>3: column.astype('category')`. And when there is e.g. `np.nan` and 'string' in the column, it leads to what I have reported.\n\nWill think about doing that PR.\n\nThanks Jeff!\n"
    },
    {
      "id": 238109451,
      "user": "hnykda",
      "body": "Sorry, I can't do it in a near future (say, month). But I am marking it down and maybe come back to it. If anyone wants to help here, it's very welcome.\n"
    },
    {
      "id": 240616945,
      "user": "wcwagner",
      "body": "@jreback Can you clarify what you mean by saying _\"Categoricals should not allow non-strings when an object dtype is passed\"_\n\nMy PR above takes this literally, which breaks many tests, [particularly here](https://github.com/pydata/pandas/blob/master/pandas/indexes/multi.py#L867) . That list comprehension  passes in `arr` to `Categorical.from_array`, which is often of type `object`, but all the individual values are homogenous \n\nIn my PR, should I just check if all the values are of the same type?\n\nThanks\n"
    },
    {
      "id": 240639045,
      "user": "hnykda",
      "body": "Hello @wcwagner . Thank you for taking a look on this.\n\nI believe that it was more like the second option - individual values should be homogenous (in the terms of dtypes). So don't allow something like this: `1, '2', 3` (mixing int with string), while `'1', '2', '3'` (all str/objects) or `1, 2, 3` (all ints) are valid.\n\nIf I should implement it extremely naively, I would do something like: \n\n``` python\ncategories_types = [type(x) for x in categories]\nif len(categories_types) > 1: \n    raise ValueError('Categories must be all of the same type. They are %s', categories_types)\n```\n"
    },
    {
      "id": 240681661,
      "user": "jreback",
      "body": "@hnykda we don't allow for `object` dtypes an inferred type of non (`string`, `unicode`, `period` (will be removed later, pls add a TODO)).\n\n```\nIn [9]: pd.lib.infer_dtype([1, '2', 3.0])\nOut[9]: 'mixed-integer'\n\nIn [10]: pd.lib.infer_dtype([pd.Timestamp('20130101'), 3.0])\nOut[10]: 'mixed'\n\nIn [12]: pd.lib.infer_dtype(['foo', 'bar'])\nOut[12]: 'string'\n\nIn [13]: pd.lib.infer_dtype([u'foo', u'bar'])\nOut[13]: 'unicode'\n\nIn [16]: pd.lib.infer_dtype([pd.Period('2016','M')])\nOut[16]: 'period'\n```\n\nnote this should only be done on the categories as these are already coerced as much as possible.\n"
    },
    {
      "id": 246852385,
      "user": "jorisvandenbossche",
      "body": "Repeating what I said in the PR (https://github.com/pydata/pandas/pull/14047): personally, I don't think we should check this at Categorical construction, I would rather check for this in the hdf code itself.\n"
    },
    {
      "id": 246853262,
      "user": "jreback",
      "body": "I don't think it's ever useful to support mixed dtypes inside a Categorical even if it's technically possible. \n"
    },
    {
      "id": 246855629,
      "user": "jorisvandenbossche",
      "body": "Given the comments on the PR, it's not technically impossible to disallow, but it would make the implementation (which is mixed with MultiIndex) more complex. \nBut, more fundamentally, I don't see any reason to disallow it, even if we could. I could for example imagine a case where you want to put custom objects (eg your own Interval objects) as categories, which is something we would (currently) identify as mixed.\n"
    },
    {
      "id": 246883231,
      "user": "jreback",
      "body": "well, we are not tested at all for mixed type categoricals. I think its pretty reasonable to disallow them; makes them easier to deal with, more meaningful and pure.\n"
    },
    {
      "id": 998464390,
      "user": "jbrockmendel",
      "body": "im with @jorisvandenbossche on this one.  pd.Categorical can accept pretty much anything that pd.Index can accept."
    }
  ],
  "text_context": "# ERR: Categoricals should not allow non-strings when an object dtype is passed\n\nHDF Store (with `table`) doesn't support categories with mixed type inside a category \n\nEven though it is possible to store category type using `to_hdf` with `table`, you can't do that when you have mixed types inside the category. It would be nice to mention this at least on docs.\n#### Code Sample, a copy-pastable example if possible\n\n```\nimport pandas as pd\ndf = pd.DataFrame({'a':[1, 'string']})\ndf['a'] = df['a'].astype('category')\ndf.to_hdf('play.hdf', 'main', format='table')\n```\n\nthe error:\n\n```\nTypeError: Cannot serialize the column [values] because\nits data contents are [mixed-integer] object dtype\n```\n#### Expected Output\n\nNo error, saved file.\n#### output of `pd.show_versions()`\n\n```\nINSTALLED VERSIONS\n------------------\ncommit: None\npython: 3.5.1.final.0\npython-bits: 64\nOS: Linux\nOS-release: 4.6.4-1-ARCH\nmachine: x86_64\nprocessor: \nbyteorder: little\nLC_ALL: None\nLANG: en_US.UTF-8\n\npandas: 0.18.0\nnose: 1.3.7\npip: 8.1.1\nsetuptools: 20.3\nCython: None\nnumpy: 1.10.4\nscipy: 0.17.0\nstatsmodels: None\nxarray: None\nIPython: 4.1.2\nsphinx: 1.4.1\npatsy: None\ndateutil: 2.5.2\npytz: 2016.3\nblosc: None\nbottleneck: None\ntables: 3.2.2\nnumexpr: 2.5.1\nmatplotlib: 1.5.1\nopenpyxl: None\nxlrd: 1.0.0\nxlwt: None\nxlsxwriter: None\nlxml: None\nbs4: 4.4.1\nhtml5lib: 0.999\nhttplib2: None\napiclient: None\nsqlalchemy: None\npymysql: None\npsycopg2: None\njinja2: 2.8\nboto: None\n```\n\n\nthis is in general a completely bad idea. categories are by-definition single dtypes (and not object), except for strings.\n\nThese should raise actually on creation.\n\n\nif you'd like to push a PR for error reporting in catetgorical creation that would be great.\n\n\nYeah, I agree with you that it should be raised on creation. \n\nI had a thousands of columns loaded from CSV and was converting them automatically to categories based on something like `len(column.unique())>3: column.astype('category')`. And when there is e.g. `np.nan` and 'string' in the column, it leads to what I have reported.\n\nWill think about doing that PR.\n\nThanks Jeff!\n\n\nSorry, I can't do it in a near future (say, month). But I am marking it down and maybe come back to it. If anyone wants to help here, it's very welcome.\n\n\n@jreback Can you clarify what you mean by saying _\"Categoricals should not allow non-strings when an object dtype is passed\"_\n\nMy PR above takes this literally, which breaks many tests, [particularly here](https://github.com/pydata/pandas/blob/master/pandas/indexes/multi.py#L867) . That list comprehension  passes in `arr` to `Categorical.from_array`, which is often of type `object`, but all the individual values are homogenous \n\nIn my PR, should I just check if all the values are of the same type?\n\nThanks\n\n\nHello @wcwagner . Thank you for taking a look on this.\n\nI believe that it was more like the second option - individual values should be homogenous (in the terms of dtypes). So don't allow something like this: `1, '2', 3` (mixing int with string), while `'1', '2', '3'` (all str/objects) or `1, 2, 3` (all ints) are valid.\n\nIf I should implement it extremely naively, I would do something like: \n\n``` python\ncategories_types = [type(x) for x in categories]\nif len(categories_types) > 1: \n    raise ValueError('Categories must be all of the same type. They are %s', categories_types)\n```\n\n\n@hnykda we don't allow for `object` dtypes an inferred type of non (`string`, `unicode`, `period` (will be removed later, pls add a TODO)).\n\n```\nIn [9]: pd.lib.infer_dtype([1, '2', 3.0])\nOut[9]: 'mixed-integer'\n\nIn [10]: pd.lib.infer_dtype([pd.Timestamp('20130101'), 3.0])\nOut[10]: 'mixed'\n\nIn [12]: pd.lib.infer_dtype(['foo', 'bar'])\nOut[12]: 'string'\n\nIn [13]: pd.lib.infer_dtype([u'foo', u'bar'])\nOut[13]: 'unicode'\n\nIn [16]: pd.lib.infer_dtype([pd.Period('2016','M')])\nOut[16]: 'period'\n```\n\nnote this should only be done on the categories as these are already coerced as much as possible.\n\n\nRepeating what I said in the PR (https://github.com/pydata/pandas/pull/14047): personally, I don't think we should check this at Categorical construction, I would rather check for this in the hdf code itself.\n\n\nI don't think it's ever useful to support mixed dtypes inside a Categorical even if it's technically possible. \n\n\nGiven the comments on the PR, it's not technically impossible to disallow, but it would make the implementation (which is mixed with MultiIndex) more complex. \nBut, more fundamentally, I don't see any reason to disallow it, even if we could. I could for example imagine a case where you want to put custom objects (eg your own Interval objects) as categories, which is something we would (currently) identify as mixed.\n\n\nwell, we are not tested at all for mixed type categoricals. I think its pretty reasonable to disallow them; makes them easier to deal with, more meaningful and pure.\n\n\nim with @jorisvandenbossche on this one.  pd.Categorical can accept pretty much anything that pd.Index can accept.",
  "pr_link": "https://github.com/pydata/pandas/pull/14047",
  "code_context": [
    {
      "filename": "pandas/core/categorical.py",
      "content": "# pylint: disable=E1101,W0232\n\nimport numpy as np\nfrom warnings import warn\nimport types\n\nfrom pandas import compat, lib\nfrom pandas.compat import u\n\nfrom pandas.types.generic import ABCSeries, ABCIndexClass, ABCCategoricalIndex\nfrom pandas.types.missing import isnull, notnull\nfrom pandas.types.cast import (_possibly_infer_to_datetimelike,\n                               _coerce_indexer_dtype)\nfrom pandas.types.dtypes import CategoricalDtype\nfrom pandas.types.common import (_ensure_int64,\n                                 _ensure_object,\n                                 _ensure_platform_int,\n                                 is_dtype_equal,\n                                 is_datetimelike,\n                                 is_categorical_dtype,\n                                 is_integer_dtype, is_bool,\n                                 is_list_like, is_sequence,\n                                 is_scalar,\n                                 is_object_dtype)\nfrom pandas.core.common import is_null_slice\n\nfrom pandas.core.algorithms import factorize, take_1d\nfrom pandas.core.base import (PandasObject, PandasDelegate,\n                              NoNewAttributesMixin, _shared_docs)\nimport pandas.core.common as com\nfrom pandas.core.missing import interpolate_2d\nfrom pandas.compat.numpy import function as nv\nfrom pandas.util.decorators import (Appender, cache_readonly,\n                                    deprecate_kwarg, Substitution)\n\nfrom pandas.util.terminal import get_terminal_size\nfrom pandas.core.config import get_option\n\n\ndef _cat_compare_op(op):\n    def f(self, other):\n        # On python2, you can usually compare any type to any type, and\n        # Categoricals can be seen as a custom type, but having different\n        # results depending whether categories are the same or not is kind of\n        # insane, so be a bit stricter here and use the python3 idea of\n        # comparing only things of equal type.\n        if not self.ordered:\n            if op in ['__lt__', '__gt__', '__le__', '__ge__']:\n                raise TypeError(\"Unordered Categoricals can only compare \"\n                                \"equality or not\")\n        if isinstance(other, Categorical):\n            # Two Categoricals can only be be compared if the categories are\n            # the same\n            if ((len(self.categories) != len(other.categories)) or\n                    not ((self.categories == other.categories).all())):\n                raise TypeError(\"Categoricals can only be compared if \"\n                                \"'categories' are the same\")\n            if not (self.ordered == other.ordered):\n                raise TypeError(\"Categoricals can only be compared if \"\n                                \"'ordered' is the same\")\n            na_mask = (self._codes == -1) | (other._codes == -1)\n            f = getattr(self._codes, op)\n            ret = f(other._codes)\n            if na_mask.any():\n                # In other series, the leads to False, so do that here too\n                ret[na_mask] = False\n            return ret\n\n        # Numpy-1.9 and earlier may convert a scalar to a zerodim array during\n        # comparison operation when second arg has higher priority, e.g.\n        #\n        #     cat[0] < cat\n        #\n        # With cat[0], for example, being ``np.int64(1)`` by the time it gets\n        # into this function would become ``np.array(1)``.\n        other = lib.item_from_zerodim(other)\n        if is_scalar(other):\n            if other in self.categories:\n                i = self.categories.get_loc(other)\n                return getattr(self._codes, op)(i)\n            else:\n                if op == '__eq__':\n                    return np.repeat(False, len(self))\n                elif op == '__ne__':\n                    return np.repeat(True, len(self))\n                else:\n                    msg = (\"Cannot compare a Categorical for op {op} with a \"\n                           \"scalar, which is not a category.\")\n                    raise TypeError(msg.format(op=op))\n        else:\n\n            # allow categorical vs object dtype array comparisons for equality\n            # these are only positional comparisons\n            if op in ['__eq__', '__ne__']:\n                return getattr(np.array(self), op)(np.array(other))\n\n            msg = (\"Cannot compare a Categorical for op {op} with type {typ}.\"\n                   \"\\nIf you want to compare values, use 'np.asarray(cat) \"\n                   \"<op> other'.\")\n            raise TypeError(msg.format(op=op, typ=type(other)))\n\n    f.__name__ = op\n\n    return f\n\n\ndef maybe_to_categorical(array):\n    \"\"\" coerce to a categorical if a series is given \"\"\"\n    if isinstance(array, (ABCSeries, ABCCategoricalIndex)):\n        return array._values\n    return array\n\n\n_codes_doc = \"\"\"The category codes of this categorical.\n\nLevel codes are an array if integer which are the positions of the real\nvalues in the categories array.\n\nThere is not setter, use the other categorical methods and the normal item\nsetter to change values in the categorical.\n\"\"\"\n\n_categories_doc = \"\"\"The categories of this categorical.\n\nSetting assigns new values to each category (effectively a rename of\neach individual category).\n\nThe assigned value has to be a list-like object. All items must be unique and\nthe number of items in the new categories must be the same as the number of\nitems in the old categories.\n\nAssigning to `categories` is a inplace operation!\n\nRaises\n------\nValueError\n    If the new categories do not validate as categories or if the number of new\n    categories is unequal the number of old categories\n\nSee also\n--------\nrename_categories\nreorder_categories\nadd_categories\nremove_categories\nremove_unused_categories\nset_categories\n\"\"\"\n\n\nclass Categorical(PandasObject):\n    \"\"\"\n    Represents a categorical variable in classic R / S-plus fashion\n\n    `Categoricals` can only take on only a limited, and usually fixed, number\n    of possible values (`categories`). In contrast to statistical categorical\n    variables, a `Categorical` might have an order, but numerical operations\n    (additions, divisions, ...) are not possible.\n\n    All values of the `Categorical` are either in `categories` or `np.nan`.\n    Assigning values outside of `categories` will raise a `ValueError`. Order\n    is defined by the order of the `categories`, not lexical order of the\n    values.\n\n    Parameters\n    ----------\n    values : list-like\n        The values of the categorical. If categories are given, values not in\n        categories will be replaced with NaN.\n    categories : Index-like (unique), optional\n        The unique categories for this categorical. If not given, the\n        categories are assumed to be the unique values of values.\n    ordered : boolean, (default False)\n        Whether or not this categorical is treated as a ordered categorical.\n        If not given, the resulting categorical will not be ordered.\n\n    Attributes\n    ----------\n    categories : Index\n        The categories of this categorical\n    codes : ndarray\n        The codes (integer positions, which point to the categories) of this\n        categorical, read only.\n    ordered : boolean\n        Whether or not this Categorical is ordered.\n\n    Raises\n    ------\n    ValueError\n        If the categories do not validate.\n    TypeError\n        If an explicit ``ordered=True`` is given but no `categories` and the\n        `values` are not sortable.\n\n        If an `object` dtype is passed and `values` contains dtypes other\n        than all strings or all periods.\n\n    Examples\n    --------\n    >>> from pandas import Categorical\n    >>> Categorical([1, 2, 3, 1, 2, 3])\n    [1, 2, 3, 1, 2, 3]\n    Categories (3, int64): [1 < 2 < 3]\n\n    >>> Categorical(['a', 'b', 'c', 'a', 'b', 'c'])\n    [a, b, c, a, b, c]\n    Categories (3, object): [a < b < c]\n\n    >>> a = Categorical(['a','b','c','a','b','c'], ['c', 'b', 'a'],\n                        ordered=True)\n    >>> a.min()\n    'c'\n    \"\"\"\n    dtype = CategoricalDtype()\n    \"\"\"The dtype (always \"category\")\"\"\"\n    \"\"\"Whether or not this Categorical is ordered.\n\n    Only ordered `Categoricals` can be sorted (according to the order\n    of the categories) and have a min and max value.\n\n    See also\n    --------\n    Categorical.sort\n    Categorical.order\n    Categorical.min\n    Categorical.max\n    \"\"\"\n\n    # For comparisons, so that numpy uses our implementation if the compare\n    # ops, which raise\n    __array_priority__ = 1000\n    _typ = 'categorical'\n\n    def __init__(self, values, categories=None, ordered=False,\n                 name=None, fastpath=False):\n\n        if fastpath:\n            # fast path\n            self._codes = _coerce_indexer_dtype(values, categories)\n            self._categories = self._validate_categories(\n                categories, fastpath=isinstance(categories, ABCIndexClass))\n            self._ordered = ordered\n            return\n\n        if name is not None:\n            msg = (\"the 'name' keyword is removed, use 'name' with consumers \"\n                   \"of the categorical instead (e.g. 'Series(cat, \"\n                   \"name=\\\"something\\\")'\")\n            warn(msg, UserWarning, stacklevel=2)\n\n        # sanitize input\n        if is_categorical_dtype(values):\n\n            # we are either a Series or a CategoricalIndex\n            if isinstance(values, (ABCSeries, ABCCategoricalIndex)):\n                values = values._values\n\n            if ordered is None:\n                ordered = values.ordered\n            if categories is None:\n                categories = values.categories\n            values = values.__array__()\n\n        elif isinstance(values, (ABCIndexClass, ABCSeries)):\n            pass\n\n        else:\n\n            # on numpy < 1.6 datetimelike get inferred to all i8 by\n            # _sanitize_array which is fine, but since factorize does this\n            # correctly no need here this is an issue because _sanitize_array\n            # also coerces np.nan to a string under certain versions of numpy\n            # as well\n            values = _possibly_infer_to_datetimelike(values,\n                                                     convert_dates=True)\n            if not isinstance(values, np.ndarray):\n                values = _convert_to_list_like(values)\n                from pandas.core.series import _sanitize_array\n                # On list with NaNs, int values will be converted to float. Use\n                # \"object\" dtype to prevent this. In the end objects will be\n                # casted to int/... in the category assignment step.\n                dtype = 'object' if isnull(values).any() else None\n                values = _sanitize_array(values, None, dtype=dtype)\n\n        if categories is None:\n            try:\n                codes, categories = factorize(values, sort=True)\n            except TypeError:\n                codes, categories = factorize(values, sort=False)\n                if ordered:\n                    # raise, as we don't have a sortable data structure and so\n                    # the user should give us one by specifying categories\n                    raise TypeError(\"'values' is not ordered, please \"\n                                    \"explicitly specify the categories order \"\n                                    \"by passing in a categories argument.\")\n            except ValueError:\n\n                # FIXME\n                raise NotImplementedError(\"> 1 ndim Categorical are not \"\n                                          \"supported at this time\")\n\n            categories = self._validate_categories(categories)\n\n        else:\n            # there were two ways if categories are present\n            # - the old one, where each value is a int pointer to the levels\n            #   array -> not anymore possible, but code outside of pandas could\n            #   call us like that, so make some checks\n            # - the new one, where each value is also in the categories array\n            #   (or np.nan)\n\n            # make sure that we always have the same type here, no matter what\n            # we get passed in\n            categories = self._validate_categories(categories)\n            codes = _get_codes_for_values(values, categories)\n\n            # TODO: check for old style usage. These warnings should be removes\n            # after 0.18/ in 2016\n            if is_integer_dtype(values) and not is_integer_dtype(categories):\n                warn(\"Values and categories have different dtypes. Did you \"\n                     \"mean to use\\n'Categorical.from_codes(codes, \"\n                     \"categories)'?\", RuntimeWarning, stacklevel=2)\n\n            if (len(values) and is_integer_dtype(values) and\n                    (codes == -1).all()):\n                warn(\"None of the categories were found in values. Did you \"\n                     \"mean to use\\n'Categorical.from_codes(codes, \"\n                     \"categories)'?\", RuntimeWarning, stacklevel=2)\n\n        # TODO: disallow period when they stop being handled as object dtype\n        # categoricals w/ object dtype shouldn't allow non-strings\n        if is_object_dtype(categories) and len(categories) > 0:\n            from pandas.lib import infer_dtype\n            mask = notnull(categories)\n            if infer_dtype(categories[mask]) not in ['period',\n                                                     'unicode',\n                                                     'string']:\n                raise TypeError(\n                    \"Categoricals cannot be object dtype unless\"\n                    \" all values are strings or all are periods.\")\n\n        self.set_ordered(ordered or False, inplace=True)\n        self._categories = categories\n        self._codes = _coerce_indexer_dtype(codes, categories)\n\n    @property\n    def _constructor(self):\n        return Categorical\n\n    def copy(self):\n        \"\"\" Copy constructor. \"\"\"\n        return self._constructor(values=self._codes.copy(),\n                                 categories=self.categories,\n                                 ordered=self.ordered,\n                                 fastpath=True)\n\n    def astype(self, dtype, copy=True):\n        \"\"\"\n        Coerce this type to another dtype\n\n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n\n            .. versionadded:: 0.19.0\n\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            if copy is True:\n                return self.copy()\n            return self\n        return np.array(self, dtype=dtype, copy=copy)\n\n    @cache_readonly\n    def ndim(self):\n        \"\"\"Number of dimensions of the Categorical \"\"\"\n        return self._codes.ndim\n\n    @cache_readonly\n    def size(self):\n        \"\"\" return the len of myself \"\"\"\n        return len(self)\n\n    @cache_readonly\n    def itemsize(self):\n        \"\"\" return the size of a single category \"\"\"\n        return self.categories.itemsize\n\n    def reshape(self, new_shape, *args, **kwargs):\n        \"\"\"\n        DEPRECATED: calling this method will raise an error in a\n        future release.\n\n        An ndarray-compatible method that returns `self` because\n        `Categorical` instances cannot actually be reshaped.\n\n        Parameters\n        ----------\n        new_shape : int or tuple of ints\n            A 1-D array of integers that correspond to the new\n            shape of the `Categorical`. For more information on\n            the parameter, please refer to `np.reshape`.\n        \"\"\"\n        warn(\"reshape is deprecated and will raise \"\n             \"in a subsequent release\", FutureWarning, stacklevel=2)\n\n        nv.validate_reshape(args, kwargs)\n\n        # while the 'new_shape' parameter has no effect,\n        # we should still enforce valid shape parameters\n        np.reshape(self.codes, new_shape)\n\n        return self\n\n    @property\n    def base(self):\n        \"\"\" compat, we are always our own object \"\"\"\n        return None\n\n    @classmethod\n    def from_array(cls, data, **kwargs):\n        \"\"\"\n        Make a Categorical type from a single array-like object.\n\n        For internal compatibility with numpy arrays.\n\n        Parameters\n        ----------\n        data : array-like\n            Can be an Index or array-like. The categories are assumed to be\n            the unique values of `data`.\n        \"\"\"\n        return cls(data, **kwargs)\n\n    @classmethod\n    def from_codes(cls, codes, categories, ordered=False, name=None):\n        \"\"\"\n        Make a Categorical type from codes and categories arrays.\n\n        This constructor is useful if you already have codes and categories and\n        so do not need the (computation intensive) factorization step, which is\n        usually done on the constructor.\n\n        If your data does not follow this convention, please use the normal\n        constructor.\n\n        Parameters\n        ----------\n        codes : array-like, integers\n            An integer array, where each integer points to a category in\n            categories or -1 for NaN\n        categories : index-like\n            The categories for the categorical. Items need to be unique.\n        ordered : boolean, (default False)\n            Whether or not this categorical is treated as a ordered\n            categorical. If not given, the resulting categorical will be\n            unordered.\n        \"\"\"\n        if name is not None:\n            msg = (\"the 'name' keyword is removed, use 'name' with consumers \"\n                   \"of the categorical instead (e.g. 'Series(cat, \"\n                   \"name=\\\"something\\\")'\")\n            warn(msg, UserWarning, stacklevel=2)\n\n        try:\n            codes = np.asarray(codes, np.int64)\n        except:\n            raise ValueError(\n                \"codes need to be convertible to an arrays of integers\")\n\n        categories = cls._validate_categories(categories)\n\n        if len(codes) and (codes.max() >= len(categories) or codes.min() < -1):\n            raise ValueError(\"codes need to be between -1 and \"\n                             \"len(categories)-1\")\n\n        return cls(codes, categories=categories, ordered=ordered,\n                   fastpath=True)\n\n    _codes = None\n\n    def _get_codes(self):\n        \"\"\" Get the codes.\n\n        Returns\n        -------\n        codes : integer array view\n            A non writable view of the `codes` array.\n        \"\"\"\n        v = self._codes.view()\n        v.flags.writeable = False\n        return v\n\n    def _set_codes(self, codes):\n        \"\"\"\n        Not settable by the user directly\n        \"\"\"\n        raise ValueError(\"cannot set Categorical codes directly\")\n\n    codes = property(fget=_get_codes, fset=_set_codes, doc=_codes_doc)\n\n    def _get_labels(self):\n        \"\"\"\n        Get the category labels (deprecated).\n\n        Deprecated, use .codes!\n        \"\"\"\n        warn(\"'labels' is deprecated. Use 'codes' instead\", FutureWarning,\n             stacklevel=2)\n        return self.codes\n\n    labels = property(fget=_get_labels, fset=_set_codes)\n\n    _categories = None\n\n    @classmethod\n    def _validate_categories(cls, categories, fastpath=False):\n        \"\"\"\n        Validates that we have good categories\n\n        Parameters\n        ----------\n        fastpath : boolean (default: False)\n           Don't perform validation of the categories for uniqueness or nulls\n\n        \"\"\"\n        if not isinstance(categories, ABCIndexClass):\n            dtype = None\n            if not hasattr(categories, \"dtype\"):\n                categories = _convert_to_list_like(categories)\n                # On categories with NaNs, int values would be converted to\n                # float. Use \"object\" dtype to prevent this.\n                if isnull(categories).any():\n                    without_na = np.array([x for x in categories\n                                           if notnull(x)])\n                    with_na = np.array(categories)\n                    if with_na.dtype != without_na.dtype:\n                        dtype = \"object\"\n\n            from pandas import Index\n            categories = Index(categories, dtype=dtype)\n\n        if not fastpath:\n\n            # check properties of the categories\n            # we don't allow NaNs in the categories themselves\n\n            if categories.hasnans:\n                # NaNs in cats deprecated in 0.17,\n                # remove in 0.18 or 0.19 GH 10748\n                msg = ('\\nSetting NaNs in `categories` is deprecated and '\n                       'will be removed in a future version of pandas.')\n                warn(msg, FutureWarning, stacklevel=3)\n\n            # categories must be unique\n\n            if not categories.is_unique:\n                raise ValueError('Categorical categories must be unique')\n\n        return categories\n\n    def _set_categories(self, categories, fastpath=False):\n        \"\"\" Sets new categories\n\n        Parameters\n        ----------\n        fastpath : boolean (default: False)\n           Don't perform validation of the categories for uniqueness or nulls\n\n        \"\"\"\n\n        categories = self._validate_categories(categories, fastpath=fastpath)\n        if (not fastpath and self._categories is not None and\n                len(categories) != len(self._categories)):\n            raise ValueError(\"new categories need to have the same number of \"\n                             \"items than the old categories!\")\n\n        self._categories = categories\n\n    def _get_categories(self):\n        \"\"\" Gets the categories \"\"\"\n        # categories is an Index, which is immutable -> no need to copy\n        return self._categories\n\n    categories = property(fget=_get_categories, fset=_set_categories,\n                          doc=_categories_doc)\n\n    _ordered = None\n\n    def set_ordered(self, value, inplace=False):\n        \"\"\"\n        Sets the ordered attribute to the boolean value\n\n        Parameters\n        ----------\n        value : boolean to set whether this categorical is ordered (True) or\n           not (False)\n        inplace : boolean (default: False)\n           Whether or not to set the ordered attribute inplace or return a copy\n           of this categorical with ordered set to the value\n        \"\"\"\n        if not is_bool(value):\n            raise TypeError(\"ordered must be a boolean value\")\n        cat = self if inplace else self.copy()\n        cat._ordered = value\n        if not inplace:\n            return cat\n\n    def as_ordered(self, inplace=False):\n        \"\"\"\n        Sets the Categorical to be ordered\n\n        Parameters\n        ----------\n        inplace : boolean (default: False)\n           Whether or not to set the ordered attribute inplace or return a copy\n           of this categorical with ordered set to True\n        \"\"\"\n        return self.set_ordered(True, inplace=inplace)\n\n    def as_unordered(self, inplace=False):\n        \"\"\"\n        Sets the Categorical to be unordered\n\n        Parameters\n        ----------\n        inplace : boolean (default: False)\n           Whether or not to set the ordered attribute inplace or return a copy\n           of this categorical with ordered set to False\n        \"\"\"\n        return self.set_ordered(False, inplace=inplace)\n\n    def _get_ordered(self):\n        \"\"\" Gets the ordered attribute \"\"\"\n        return self._ordered\n\n    ordered = property(fget=_get_ordered)\n\n    def set_categories(self, new_categories, ordered=None, rename=False,\n                       inplace=False):\n        \"\"\" Sets the categories to the specified new_categories.\n\n        `new_categories` can include new categories (which will result in\n        unused categories) or remove old categories (which results in values\n        set to NaN). If `rename==True`, the categories will simple be renamed\n        (less or more items than in old categories will result in values set to\n        NaN or in unused categories respectively).\n\n        This method can be used to perform more than one action of adding,\n        removing, and reordering simultaneously and is therefore faster than\n        performing the individual steps via the more specialised methods.\n\n        On the other hand this methods does not do checks (e.g., whether the\n        old categories are included in the new categories on a reorder), which\n        can result in surprising changes, for example when using special string\n        dtypes on python3, which does not considers a S1 string equal to a\n        single char python string.\n\n        Raises\n        ------\n        ValueError\n            If new_categories does not validate as categories\n\n        Parameters\n        ----------\n        new_categories : Index-like\n           The categories in new order.\n        ordered : boolean, (default: False)\n           Whether or not the categorical is treated as a ordered categorical.\n           If not given, do not change the ordered information.\n        rename : boolean (default: False)\n           Whether or not the new_categories should be considered as a rename\n           of the old  categories or as reordered categories.\n        inplace : boolean (default: False)\n           Whether or not to reorder the categories inplace or return a copy of\n           this categorical with reordered categories.\n\n        Returns\n        -------\n        cat : Categorical with reordered categories or None if inplace.\n\n        See also\n        --------\n        rename_categories\n        reorder_categories\n        add_categories\n        remove_categories\n        remove_unused_categories\n        \"\"\"\n        new_categories = self._validate_categories(new_categories)\n        cat = self if inplace else self.copy()\n        if rename:\n            if (cat._categories is not None and\n                    len(new_categories) < len(cat._categories)):\n                # remove all _codes which are larger and set to -1/NaN\n                self._codes[self._codes >= len(new_categories)] = -1\n        else:\n            values = cat.__array__()\n            cat._codes = _get_codes_for_values(values, new_categories)\n        cat._categories = new_categories\n\n        if ordered is None:\n            ordered = self.ordered\n        cat.set_ordered(ordered, inplace=True)\n\n        if not inplace:\n            return cat\n\n    def rename_categories(self, new_categories, inplace=False):\n        \"\"\" Renames categories.\n\n        The new categories has to be a list-like object. All items must be\n        unique and the number of items in the new categories must be the same\n        as the number of items in the old categories.\n\n        Raises\n        ------\n        ValueError\n            If the new categories do not have the same number of items than the\n            current categories or do not validate as categories\n\n        Parameters\n        ----------\n        new_categories : Index-like\n           The renamed categories.\n        inplace : boolean (default: False)\n           Whether or not to rename the categories inplace or return a copy of\n           this categorical with renamed categories.\n\n        Returns\n        -------\n        cat : Categorical with renamed categories added or None if inplace.\n\n        See also\n        --------\n        reorder_categories\n        add_categories\n        remove_categories\n        remove_unused_categories\n        set_categories\n        \"\"\"\n        cat = self if inplace else self.copy()\n        cat.categories = new_categories\n        if not inplace:\n            return cat\n\n    def reorder_categories(self, new_categories, ordered=None, inplace=False):\n        \"\"\" Reorders categories as specified in new_categories.\n\n        `new_categories` need to include all old categories and no new category\n        items.\n\n        Raises\n        ------\n        ValueError\n            If the new categories do not contain all old category items or any\n            new ones\n\n        Parameters\n        ----------\n        new_categories : Index-like\n           The categories in new order.\n        ordered : boolean, optional\n           Whether or not the categorical is treated as a ordered categorical.\n           If not given, do not change the ordered information.\n        inplace : boolean (default: False)\n           Whether or not to reorder the categories inplace or return a copy of\n           this categorical with reordered categories.\n\n        Returns\n        -------\n        cat : Categorical with reordered categories or None if inplace.\n\n        See also\n        --------\n        rename_categories\n        add_categories\n        remove_categories\n        remove_unused_categories\n        set_categories\n        \"\"\"\n        if set(self._categories) != set(new_categories):\n            raise ValueError(\"items in new_categories are not the same as in \"\n                             \"old categories\")\n        return self.set_categories(new_categories, ordered=ordered,\n                                   inplace=inplace)\n\n    def add_categories(self, new_categories, inplace=False):\n        \"\"\" Add new categories.\n\n        `new_categories` will be included at the last/highest place in the\n        categories and will be unused directly after this call.\n\n        Raises\n        ------\n        ValueError\n            If the new categories include old categories or do not validate as\n            categories\n\n        Parameters\n        ----------\n        new_categories : category or list-like of category\n           The new categories to be included.\n        inplace : boolean (default: False)\n           Whether or not to add the categories inplace or return a copy of\n           this categorical with added categories.\n\n        Returns\n        -------\n        cat : Categorical with new categories added or None if inplace.\n\n        See also\n        --------\n        rename_categories\n        reorder_categories\n        remove_categories\n        remove_unused_categories\n        set_categories\n        \"\"\"\n        if not is_list_like(new_categories):\n            new_categories = [new_categories]\n        already_included = set(new_categories) & set(self._categories)\n        if len(already_included) != 0:\n            msg = (\"new categories must not include old categories: %s\" %\n                   str(already_included))\n            raise ValueError(msg)\n        new_categories = list(self._categories) + list(new_categories)\n        cat = self if inplace else self.copy()\n        cat._categories = self._validate_categories(new_categories)\n        cat._codes = _coerce_indexer_dtype(cat._codes, new_categories)\n        if not inplace:\n            return cat\n\n    def remove_categories(self, removals, inplace=False):\n        \"\"\" Removes the specified categories.\n\n        `removals` must be included in the old categories. Values which were in\n        the removed categories will be set to NaN\n\n        Raises\n        ------\n        ValueError\n            If the removals are not contained in the categories\n\n        Parameters\n        ----------\n        removals : category or list of categories\n           The categories which should be removed.\n        inplace : boolean (default: False)\n           Whether or not to remove the categories inplace or return a copy of\n           this categorical with removed categories.\n\n        Returns\n        -------\n        cat : Categorical with removed categories or None if inplace.\n\n        See also\n        --------\n        rename_categories\n        reorder_categories\n        add_categories\n        remove_unused_categories\n        set_categories\n        \"\"\"\n        if not is_list_like(removals):\n            removals = [removals]\n\n        removal_set = set(list(removals))\n        not_included = removal_set - set(self._categories)\n        new_categories = [c for c in self._categories if c not in removal_set]\n\n        # GH 10156\n        if any(isnull(removals)):\n            not_included = [x for x in not_included if notnull(x)]\n            new_categories = [x for x in new_categories if notnull(x)]\n\n        if len(not_included) != 0:\n            raise ValueError(\"removals must all be in old categories: %s\" %\n                             str(not_included))\n\n        return self.set_categories(new_categories, ordered=self.ordered,\n                                   rename=False, inplace=inplace)\n\n    def remove_unused_categories(self, inplace=False):\n        \"\"\" Removes categories which are not used.\n\n        Parameters\n        ----------\n        inplace : boolean (default: False)\n           Whether or not to drop unused categories inplace or return a copy of\n           this categorical with unused categories dropped.\n\n        Returns\n        -------\n        cat : Categorical with unused categories dropped or None if inplace.\n\n        See also\n        --------\n        rename_categories\n        reorder_categories\n        add_categories\n        remove_categories\n        set_categories\n        \"\"\"\n        cat = self if inplace else self.copy()\n        idx, inv = np.unique(cat._codes, return_inverse=True)\n\n        if idx.size != 0 and idx[0] == -1:  # na sentinel\n            idx, inv = idx[1:], inv - 1\n\n        cat._categories = cat.categories.take(idx)\n        cat._codes = _coerce_indexer_dtype(inv, self._categories)\n\n        if not inplace:\n            return cat\n\n    def map(self, mapper):\n        \"\"\"\n        Apply mapper function to its categories (not codes).\n\n        Parameters\n        ----------\n        mapper : callable\n            Function to be applied. When all categories are mapped\n            to different categories, the result will be Categorical which has\n            the same order property as the original. Otherwise, the result will\n            be np.ndarray.\n\n        Returns\n        -------\n        applied : Categorical or np.ndarray.\n        \"\"\"\n        new_categories = self.categories.map(mapper)\n        try:\n            return self.from_codes(self._codes.copy(),\n                                   categories=new_categories,\n                                   ordered=self.ordered)\n        except ValueError:\n            return np.take(new_categories, self._codes)\n\n    __eq__ = _cat_compare_op('__eq__')\n    __ne__ = _cat_compare_op('__ne__')\n    __lt__ = _cat_compare_op('__lt__')\n    __gt__ = _cat_compare_op('__gt__')\n    __le__ = _cat_compare_op('__le__')\n    __ge__ = _cat_compare_op('__ge__')\n\n    # for Series/ndarray like compat\n    @property\n    def shape(self):\n        \"\"\" Shape of the Categorical.\n\n        For internal compatibility with numpy arrays.\n\n        Returns\n        -------\n        shape : tuple\n        \"\"\"\n\n        return tuple([len(self._codes)])\n\n    def shift(self, periods):\n        \"\"\"\n        Shift Categorical by desired number of periods.\n\n        Parameters\n        ----------\n        periods : int\n            Number of periods to move, can be positive or negative\n\n        Returns\n        -------\n        shifted : Categorical\n        \"\"\"\n        # since categoricals always have ndim == 1, an axis parameter\n        # doesnt make any sense here.\n        codes = self.codes\n        if codes.ndim > 1:\n            raise NotImplementedError(\"Categorical with ndim > 1.\")\n        if np.prod(codes.shape) and (periods != 0):\n            codes = np.roll(codes, _ensure_platform_int(periods), axis=0)\n            if periods > 0:\n                codes[:periods] = -1\n            else:\n                codes[periods:] = -1\n\n        return self.from_codes(codes, categories=self.categories,\n                               ordered=self.ordered)\n\n    def __array__(self, dtype=None):\n        \"\"\"\n        The numpy array interface.\n\n        Returns\n        -------\n        values : numpy array\n            A numpy array of either the specified dtype or,\n            if dtype==None (default), the same dtype as\n            categorical.categories.dtype\n        \"\"\"\n        ret = take_1d(self.categories.values, self._codes)\n        if dtype and not is_dtype_equal(dtype, self.categories.dtype):\n            return np.asarray(ret, dtype)\n        return ret\n\n    def __setstate__(self, state):\n        \"\"\"Necessary for making this object picklable\"\"\"\n        if not isinstance(state, dict):\n            raise Exception('invalid pickle state')\n\n        # Provide compatibility with pre-0.15.0 Categoricals.\n        if '_categories' not in state and '_levels' in state:\n            state['_categories'] = self._validate_categories(state.pop(\n                '_levels'))\n        if '_codes' not in state and 'labels' in state:\n            state['_codes'] = _coerce_indexer_dtype(state.pop('labels'),\n                                                    state['_categories'])\n\n        # 0.16.0 ordered change\n        if '_ordered' not in state:\n\n            # >=15.0 < 0.16.0\n            if 'ordered' in state:\n                state['_ordered'] = state.pop('ordered')\n            else:\n                state['_ordered'] = False\n\n        for k, v in compat.iteritems(state):\n            setattr(self, k, v)\n\n    @property\n    def T(self):\n        return self\n\n    @property\n    def nbytes(self):\n        return self._codes.nbytes + self._categories.values.nbytes\n\n    def memory_usage(self, deep=False):\n        \"\"\"\n        Memory usage of my values\n\n        Parameters\n        ----------\n        deep : bool\n            Introspect the data deeply, interrogate\n            `object` dtypes for system-level memory consumption\n\n        Returns\n        -------\n        bytes used\n\n        Notes\n        -----\n        Memory usage does not include memory consumed by elements that\n        are not components of the array if deep=False\n\n        See Also\n        --------\n        numpy.ndarray.nbytes\n        \"\"\"\n        return self._codes.nbytes + self._categories.memory_usage(deep=deep)\n\n    @Substitution(klass='Categorical', value='v')\n    @Appender(_shared_docs['searchsorted'])\n    def searchsorted(self, v, side='left', sorter=None):\n        if not self.ordered:\n            raise ValueError(\"Categorical not ordered\\nyou can use \"\n                             \".as_ordered() to change the Categorical to an \"\n                             \"ordered one\")\n\n        from pandas.core.series import Series\n        values_as_codes = self.categories.values.searchsorted(\n            Series(v).values, side=side)\n\n        return self.codes.searchsorted(values_as_codes, sorter=sorter)\n\n    def isnull(self):\n        \"\"\"\n        Detect missing values\n\n        Both missing values (-1 in .codes) and NA as a category are detected.\n\n        Returns\n        -------\n        a boolean array of whether my values are null\n\n        See also\n        --------\n        pandas.isnull : pandas version\n        Categorical.notnull : boolean inverse of Categorical.isnull\n        \"\"\"\n\n        ret = self._codes == -1\n\n        # String/object and float categories can hold np.nan\n        if self.categories.dtype.kind in ['S', 'O', 'f']:\n            if np.nan in self.categories:\n                nan_pos = np.where(isnull(self.categories))[0]\n                # we only have one NA in categories\n                ret = np.logical_or(ret, self._codes == nan_pos)\n        return ret\n\n    def notnull(self):\n        \"\"\"\n        Reverse of isnull\n\n        Both missing values (-1 in .codes) and NA as a category are detected as\n        null.\n\n        Returns\n        -------\n        a boolean array of whether my values are not null\n\n        See also\n        --------\n        pandas.notnull : pandas version\n        Categorical.isnull : boolean inverse of Categorical.notnull\n        \"\"\"\n        return ~self.isnull()\n\n    def put(self, *args, **kwargs):\n        \"\"\"\n        Replace specific elements in the Categorical with given values.\n        \"\"\"\n        raise NotImplementedError((\"'put' is not yet implemented \"\n                                   \"for Categorical\"))\n\n    def dropna(self):\n        \"\"\"\n        Return the Categorical without null values.\n\n        Both missing values (-1 in .codes) and NA as a category are detected.\n        NA is removed from the categories if present.\n\n        Returns\n        -------\n        valid : Categorical\n        \"\"\"\n        result = self[self.notnull()]\n        if isnull(result.categories).any():\n            result = result.remove_categories([np.nan])\n        return result\n\n    def value_counts(self, dropna=True):\n        \"\"\"\n        Returns a Series containing counts of each category.\n\n        Every category will have an entry, even those with a count of 0.\n\n        Parameters\n        ----------\n        dropna : boolean, default True\n            Don't include counts of NaN, even if NaN is a category.\n\n        Returns\n        -------\n        counts : Series\n        \"\"\"\n        from numpy import bincount\n        from pandas.types.missing import isnull\n        from pandas.core.series import Series\n        from pandas.core.index import CategoricalIndex\n\n        obj = (self.remove_categories([np.nan]) if dropna and\n               isnull(self.categories).any() else self)\n        code, cat = obj._codes, obj.categories\n        ncat, mask = len(cat), 0 <= code\n        ix, clean = np.arange(ncat), mask.all()\n\n        if dropna or clean:\n            obs = code if clean else code[mask]\n            count = bincount(obs, minlength=ncat or None)\n        else:\n            count = bincount(np.where(mask, code, ncat))\n            ix = np.append(ix, -1)\n\n        ix = self._constructor(ix, categories=cat, ordered=obj.ordered,\n                               fastpath=True)\n\n        return Series(count, index=CategoricalIndex(ix), dtype='int64')\n\n    def get_values(self):\n        \"\"\" Return the values.\n\n        For internal compatibility with pandas formatting.\n\n        Returns\n        -------\n        values : numpy array\n            A numpy array of the same dtype as categorical.categories.dtype or\n            Index if datetime / periods\n        \"\"\"\n        # if we are a datetime and period index, return Index to keep metadata\n        if is_datetimelike(self.categories):\n            return self.categories.take(self._codes, fill_value=np.nan)\n        return np.array(self)\n\n    def check_for_ordered(self, op):\n        \"\"\" assert that we are ordered \"\"\"\n        if not self.ordered:\n            raise TypeError(\"Categorical is not ordered for operation {op}\\n\"\n                            \"you can use .as_ordered() to change the \"\n                            \"Categorical to an ordered one\\n\".format(op=op))\n\n    def argsort(self, ascending=True, *args, **kwargs):\n        \"\"\"\n        Returns the indices that would sort the Categorical instance if\n        'sort_values' was called. This function is implemented to provide\n        compatibility with numpy ndarray objects.\n\n        While an ordering is applied to the category values, arg-sorting\n        in this context refers more to organizing and grouping together\n        based on matching category values. Thus, this function can be\n        called on an unordered Categorical instance unlike the functions\n        'Categorical.min' and 'Categorical.max'.\n\n        Returns\n        -------\n        argsorted : numpy array\n\n        See also\n        --------\n        numpy.ndarray.argsort\n        \"\"\"\n        ascending = nv.validate_argsort_with_ascending(ascending, args, kwargs)\n        result = np.argsort(self._codes.copy(), **kwargs)\n        if not ascending:\n            result = result[::-1]\n        return result\n\n    def sort_values(self, inplace=False, ascending=True, na_position='last'):\n        \"\"\" Sorts the Categorical by category value returning a new\n        Categorical by default.\n\n        While an ordering is applied to the category values, sorting in this\n        context refers more to organizing and grouping together based on\n        matching category values. Thus, this function can be called on an\n        unordered Categorical instance unlike the functions 'Categorical.min'\n        and 'Categorical.max'.\n\n        Parameters\n        ----------\n        inplace : boolean, default False\n            Do operation in place.\n        ascending : boolean, default True\n            Order ascending. Passing False orders descending. The\n            ordering parameter provides the method by which the\n            category values are organized.\n        na_position : {'first', 'last'} (optional, default='last')\n            'first' puts NaNs at the beginning\n            'last' puts NaNs at the end\n\n        Returns\n        -------\n        y : Categorical or None\n\n        See Also\n        --------\n        Categorical.sort\n\n        Examples\n        --------\n        >>> c = pd.Categorical([1, 2, 2, 1, 5])\n        >>> c\n        [1, 2, 2, 1, 5]\n        Categories (3, int64): [1, 2, 5]\n        >>> c.sort_values()\n        [1, 1, 2, 2, 5]\n        Categories (3, int64): [1, 2, 5]\n        >>> c.sort_values(ascending=False)\n        [5, 2, 2, 1, 1]\n        Categories (3, int64): [1, 2, 5]\n\n        Inplace sorting can be done as well:\n\n        >>> c.sort_values(inplace=True)\n        >>> c\n        [1, 1, 2, 2, 5]\n        Categories (3, int64): [1, 2, 5]\n        >>>\n        >>> c = pd.Categorical([1, 2, 2, 1, 5])\n\n        'sort_values' behaviour with NaNs. Note that 'na_position'\n        is independent of the 'ascending' parameter:\n\n        >>> c = pd.Categorical([np.nan, 2, 2, np.nan, 5])\n        >>> c\n        [NaN, 2.0, 2.0, NaN, 5.0]\n        Categories (2, int64): [2, 5]\n        >>> c.sort_values()\n        [2.0, 2.0, 5.0, NaN, NaN]\n        Categories (2, int64): [2, 5]\n        >>> c.sort_values(ascending=False)\n        [5.0, 2.0, 2.0, NaN, NaN]\n        Categories (2, int64): [2, 5]\n        >>> c.sort_values(na_position='first')\n        [NaN, NaN, 2.0, 2.0, 5.0]\n        Categories (2, int64): [2, 5]\n        >>> c.sort_values(ascending=False, na_position='first')\n        [NaN, NaN, 5.0, 2.0, 2.0]\n        Categories (2, int64): [2, 5]\n        \"\"\"\n        if na_position not in ['last', 'first']:\n            raise ValueError('invalid na_position: {!r}'.format(na_position))\n\n        codes = np.sort(self._codes)\n        if not ascending:\n            codes = codes[::-1]\n\n        # NaN handling\n        na_mask = (codes == -1)\n        if na_mask.any():\n            n_nans = len(codes[na_mask])\n            if na_position == \"first\":\n                # in this case sort to the front\n                new_codes = codes.copy()\n                new_codes[0:n_nans] = -1\n                new_codes[n_nans:] = codes[~na_mask]\n                codes = new_codes\n            elif na_position == \"last\":\n                # ... and to the end\n                new_codes = codes.copy()\n                pos = len(codes) - n_nans\n                new_codes[0:pos] = codes[~na_mask]\n                new_codes[pos:] = -1\n                codes = new_codes\n        if inplace:\n            self._codes = codes\n            return\n        else:\n            return self._constructor(values=codes, categories=self.categories,\n                                     ordered=self.ordered, fastpath=True)\n\n    def order(self, inplace=False, ascending=True, na_position='last'):\n        \"\"\"\n        DEPRECATED: use :meth:`Categorical.sort_values`. That function\n        is entirely equivalent to this one.\n\n        See Also\n        --------\n        Categorical.sort_values\n        \"\"\"\n        warn(\"order is deprecated, use sort_values(...)\", FutureWarning,\n             stacklevel=2)\n        return self.sort_values(inplace=inplace, ascending=ascending,\n                                na_position=na_position)\n\n    def sort(self, inplace=True, ascending=True, na_position='last', **kwargs):\n        \"\"\"\n        DEPRECATED: use :meth:`Categorical.sort_values`. That function\n        is just like this one, except that a new Categorical is returned\n        by default, so make sure to pass in 'inplace=True' to get\n        inplace sorting.\n\n        See Also\n        --------\n        Categorical.sort_values\n        \"\"\"\n        warn(\"sort is deprecated, use sort_values(...)\", FutureWarning,\n             stacklevel=2)\n        nv.validate_sort(tuple(), kwargs)\n        return self.sort_values(inplace=inplace, ascending=ascending,\n                                na_position=na_position)\n\n    def ravel(self, order='C'):\n        \"\"\" Return a flattened (numpy) array.\n\n        For internal compatibility with numpy arrays.\n\n        Returns\n        -------\n        raveled : numpy array\n        \"\"\"\n        return np.array(self)\n\n    def view(self):\n        \"\"\"Return a view of myself.\n\n        For internal compatibility with numpy arrays.\n\n        Returns\n        -------\n        view : Categorical\n           Returns `self`!\n        \"\"\"\n        return self\n\n    def to_dense(self):\n        \"\"\"Return my 'dense' representation\n\n        For internal compatibility with numpy arrays.\n\n        Returns\n        -------\n        dense : array\n        \"\"\"\n        return np.asarray(self)\n\n    @deprecate_kwarg(old_arg_name='fill_value', new_arg_name='value')\n    def fillna(self, value=None, method=None, limit=None):\n        \"\"\" Fill NA/NaN values using the specified method.\n\n        Parameters\n        ----------\n        method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n            Method to use for filling holes in reindexed Series\n            pad / ffill: propagate last valid observation forward to next valid\n            backfill / bfill: use NEXT valid observation to fill gap\n        value : scalar\n            Value to use to fill holes (e.g. 0)\n        limit : int, default None\n            (Not implemented yet for Categorical!)\n            If method is specified, this is the maximum number of consecutive\n            NaN values to forward/backward fill. In other words, if there is\n            a gap with more than this number of consecutive NaNs, it will only\n            be partially filled. If method is not specified, this is the\n            maximum number of entries along the entire axis where NaNs will be\n            filled.\n\n        Returns\n        -------\n        filled : Categorical with NA/NaN filled\n        \"\"\"\n\n        if value is None:\n            value = np.nan\n        if limit is not None:\n            raise NotImplementedError(\"specifying a limit for fillna has not \"\n                                      \"been implemented yet\")\n\n        values = self._codes\n\n        # Make sure that we also get NA in categories\n        if self.categories.dtype.kind in ['S', 'O', 'f']:\n            if np.nan in self.categories:\n                values = values.copy()\n                nan_pos = np.where(isnull(self.categories))[0]\n                # we only have one NA in categories\n                values[values == nan_pos] = -1\n\n        # pad / bfill\n        if method is not None:\n\n            values = self.to_dense().reshape(-1, len(self))\n            values = interpolate_2d(values, method, 0, None,\n                                    value).astype(self.categories.dtype)[0]\n            values = _get_codes_for_values(values, self.categories)\n\n        else:\n\n            if not isnull(value) and value not in self.categories:\n                raise ValueError(\"fill value must be in categories\")\n\n            mask = values == -1\n            if mask.any():\n                values = values.copy()\n                values[mask] = self.categories.get_loc(value)\n\n        return self._constructor(values, categories=self.categories,\n                                 ordered=self.ordered, fastpath=True)\n\n    def take_nd(self, indexer, allow_fill=True, fill_value=None):\n        \"\"\" Take the codes by the indexer, fill with the fill_value.\n\n        For internal compatibility with numpy arrays.\n        \"\"\"\n\n        # filling must always be None/nan here\n        # but is passed thru internally\n        assert isnull(fill_value)\n\n        codes = take_1d(self._codes, indexer, allow_fill=True, fill_value=-1)\n        result = self._constructor(codes, categories=self.categories,\n                                   ordered=self.ordered, fastpath=True)\n        return result\n\n    take = take_nd\n\n    def _slice(self, slicer):\n        \"\"\" Return a slice of myself.\n\n        For internal compatibility with numpy arrays.\n        \"\"\"\n\n        # only allow 1 dimensional slicing, but can\n        # in a 2-d case be passd (slice(None),....)\n        if isinstance(slicer, tuple) and len(slicer) == 2:\n            if not is_null_slice(slicer[0]):\n                raise AssertionError(\"invalid slicing for a 1-ndim \"\n                                     \"categorical\")\n            slicer = slicer[1]\n\n        _codes = self._codes[slicer]\n        return self._constructor(values=_codes, categories=self.categories,\n                                 ordered=self.ordered, fastpath=True)\n\n    def __len__(self):\n        \"\"\"The length of this Categorical.\"\"\"\n        return len(self._codes)\n\n    def __iter__(self):\n        \"\"\"Returns an Iterator over the values of this Categorical.\"\"\"\n        return iter(self.get_values())\n\n    def _tidy_repr(self, max_vals=10, footer=True):\n        \"\"\" a short repr displaying only max_vals and an optional (but default\n        footer)\n        \"\"\"\n        num = max_vals // 2\n        head = self[:num]._get_repr(length=False, footer=False)\n        tail = self[-(max_vals - num):]._get_repr(length=False, footer=False)\n\n        result = '%s, ..., %s' % (head[:-1], tail[1:])\n        if footer:\n            result = '%s\\n%s' % (result, self._repr_footer())\n\n        return compat.text_type(result)\n\n    def _repr_categories(self):\n        \"\"\" return the base repr for the categories \"\"\"\n        max_categories = (10 if get_option(\"display.max_categories\") == 0 else\n                          get_option(\"display.max_categories\"))\n        from pandas.formats import format as fmt\n        if len(self.categories) > max_categories:\n            num = max_categories // 2\n            head = fmt.format_array(self.categories[:num], None)\n            tail = fmt.format_array(self.categories[-num:], None)\n            category_strs = head + [\"...\"] + tail\n        else:\n            category_strs = fmt.format_array(self.categories, None)\n\n        # Strip all leading spaces, which format_array adds for columns...\n        category_strs = [x.strip() for x in category_strs]\n        return category_strs\n\n    def _repr_categories_info(self):\n        \"\"\" Returns a string representation of the footer.\"\"\"\n\n        category_strs = self._repr_categories()\n        dtype = getattr(self.categories, 'dtype_str',\n                        str(self.categories.dtype))\n\n        levheader = \"Categories (%d, %s): \" % (len(self.categories), dtype)\n        width, height = get_terminal_size()\n        max_width = get_option(\"display.width\") or width\n        if com.in_ipython_frontend():\n            # 0 = no breaks\n            max_width = 0\n        levstring = \"\"\n        start = True\n        cur_col_len = len(levheader)  # header\n        sep_len, sep = (3, \" < \") if self.ordered else (2, \", \")\n        linesep = sep.rstrip() + \"\\n\"  # remove whitespace\n        for val in category_strs:\n            if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:\n                levstring += linesep + (\" \" * (len(levheader) + 1))\n                cur_col_len = len(levheader) + 1  # header + a whitespace\n            elif not start:\n                levstring += sep\n                cur_col_len += len(val)\n            levstring += val\n            start = False\n        # replace to simple save space by\n        return levheader + \"[\" + levstring.replace(\" < ... < \", \" ... \") + \"]\"\n\n    def _repr_footer(self):\n\n        return u('Length: %d\\n%s') % (len(self), self._repr_categories_info())\n\n    def _get_repr(self, length=True, na_rep='NaN', footer=True):\n        from pandas.formats import format as fmt\n        formatter = fmt.CategoricalFormatter(self, length=length,\n                                             na_rep=na_rep, footer=footer)\n        result = formatter.to_string()\n        return compat.text_type(result)\n\n    def __unicode__(self):\n        \"\"\" Unicode representation. \"\"\"\n        _maxlen = 10\n        if len(self._codes) > _maxlen:\n            result = self._tidy_repr(_maxlen)\n        elif len(self._codes) > 0:\n            result = self._get_repr(length=len(self) > _maxlen)\n        else:\n            result = ('[], %s' %\n                      self._get_repr(length=False,\n                                     footer=True, ).replace(\"\\n\", \", \"))\n\n        return result\n\n    def _maybe_coerce_indexer(self, indexer):\n        \"\"\" return an indexer coerced to the codes dtype \"\"\"\n        if isinstance(indexer, np.ndarray) and indexer.dtype.kind == 'i':\n            indexer = indexer.astype(self._codes.dtype)\n        return indexer\n\n    def __getitem__(self, key):\n        \"\"\" Return an item. \"\"\"\n        if isinstance(key, (int, np.integer)):\n            i = self._codes[key]\n            if i == -1:\n                return np.nan\n            else:\n                return self.categories[i]\n        else:\n            return self._constructor(values=self._codes[key],\n                                     categories=self.categories,\n                                     ordered=self.ordered, fastpath=True)\n\n    def __setitem__(self, key, value):\n        \"\"\" Item assignment.\n\n\n        Raises\n        ------\n        ValueError\n            If (one or more) Value is not in categories or if a assigned\n            `Categorical` does not have the same categories\n        \"\"\"\n\n        # require identical categories set\n        if isinstance(value, Categorical):\n            if not value.categories.equals(self.categories):\n                raise ValueError(\"Cannot set a Categorical with another, \"\n                                 \"without identical categories\")\n\n        rvalue = value if is_list_like(value) else [value]\n\n        from pandas import Index\n        to_add = Index(rvalue).difference(self.categories)\n\n        # no assignments of values not in categories, but it's always ok to set\n        # something to np.nan\n        if len(to_add) and not isnull(to_add).all():\n            raise ValueError(\"Cannot setitem on a Categorical with a new \"\n                             \"category, set the categories first\")\n\n        # set by position\n        if isinstance(key, (int, np.integer)):\n            pass\n\n        # tuple of indexers (dataframe)\n        elif isinstance(key, tuple):\n            # only allow 1 dimensional slicing, but can\n            # in a 2-d case be passd (slice(None),....)\n            if len(key) == 2:\n                if not is_null_slice(key[0]):\n                    raise AssertionError(\"invalid slicing for a 1-ndim \"\n                                         \"categorical\")\n                key = key[1]\n            elif len(key) == 1:\n                key = key[0]\n            else:\n                raise AssertionError(\"invalid slicing for a 1-ndim \"\n                                     \"categorical\")\n\n        # slicing in Series or Categorical\n        elif isinstance(key, slice):\n            pass\n\n        # Array of True/False in Series or Categorical\n        else:\n            # There is a bug in numpy, which does not accept a Series as a\n            # indexer\n            # https://github.com/pydata/pandas/issues/6168\n            # https://github.com/numpy/numpy/issues/4240 -> fixed in numpy 1.9\n            # FIXME: remove when numpy 1.9 is the lowest numpy version pandas\n            # accepts...\n            key = np.asarray(key)\n\n        lindexer = self.categories.get_indexer(rvalue)\n\n        # FIXME: the following can be removed after GH7820 is fixed:\n        # https://github.com/pydata/pandas/issues/7820\n        # float categories do currently return -1 for np.nan, even if np.nan is\n        # included in the index -> \"repair\" this here\n        if isnull(rvalue).any() and isnull(self.categories).any():\n            nan_pos = np.where(isnull(self.categories))[0]\n            lindexer[lindexer == -1] = nan_pos\n\n        lindexer = self._maybe_coerce_indexer(lindexer)\n        self._codes[key] = lindexer\n\n    # reduction ops #\n    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None,\n                filter_type=None, **kwds):\n        \"\"\" perform the reduction type operation \"\"\"\n        func = getattr(self, name, None)\n        if func is None:\n            raise TypeError(\"Categorical cannot perform the operation \"\n                            \"{op}\".format(op=name))\n        return func(numeric_only=numeric_only, **kwds)\n\n    def min(self, numeric_only=None, **kwargs):\n        \"\"\" The minimum value of the object.\n\n        Only ordered `Categoricals` have a minimum!\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        min : the minimum of this `Categorical`\n        \"\"\"\n        self.check_for_ordered('min')\n        if numeric_only:\n            good = self._codes != -1\n            pointer = self._codes[good].min(**kwargs)\n        else:\n            pointer = self._codes.min(**kwargs)\n        if pointer == -1:\n            return np.nan\n        else:\n            return self.categories[pointer]\n\n    def max(self, numeric_only=None, **kwargs):\n        \"\"\" The maximum value of the object.\n\n        Only ordered `Categoricals` have a maximum!\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        max : the maximum of this `Categorical`\n        \"\"\"\n        self.check_for_ordered('max')\n        if numeric_only:\n            good = self._codes != -1\n            pointer = self._codes[good].max(**kwargs)\n        else:\n            pointer = self._codes.max(**kwargs)\n        if pointer == -1:\n            return np.nan\n        else:\n            return self.categories[pointer]\n\n    def mode(self):\n        \"\"\"\n        Returns the mode(s) of the Categorical.\n\n        Empty if nothing occurs at least 2 times.  Always returns `Categorical`\n        even if only one value.\n\n        Returns\n        -------\n        modes : `Categorical` (sorted)\n        \"\"\"\n\n        import pandas.hashtable as htable\n        good = self._codes != -1\n        values = sorted(htable.mode_int64(_ensure_int64(self._codes[good])))\n        result = self._constructor(values=values, categories=self.categories,\n                                   ordered=self.ordered, fastpath=True)\n        return result\n\n    def unique(self):\n        \"\"\"\n        Return the ``Categorical`` which ``categories`` and ``codes`` are\n        unique. Unused categories are NOT returned.\n\n        - unordered category: values and categories are sorted by appearance\n          order.\n        - ordered category: values are sorted by appearance order, categories\n          keeps existing order.\n\n        Returns\n        -------\n        unique values : ``Categorical``\n        \"\"\"\n\n        from pandas.core.nanops import unique1d\n        # unlike np.unique, unique1d does not sort\n        unique_codes = unique1d(self.codes)\n        cat = self.copy()\n        # keep nan in codes\n        cat._codes = unique_codes\n        # exclude nan from indexer for categories\n        take_codes = unique_codes[unique_codes != -1]\n        if self.ordered:\n            take_codes = sorted(take_codes)\n        return cat.set_categories(cat.categories.take(take_codes))\n\n    def equals(self, other):\n        \"\"\"\n        Returns True if categorical arrays are equal.\n\n        Parameters\n        ----------\n        other : `Categorical`\n\n        Returns\n        -------\n        are_equal : boolean\n        \"\"\"\n        return (self.is_dtype_equal(other) and\n                np.array_equal(self._codes, other._codes))\n\n    def is_dtype_equal(self, other):\n        \"\"\"\n        Returns True if categoricals are the same dtype\n          same categories, and same ordered\n\n        Parameters\n        ----------\n        other : Categorical\n\n        Returns\n        -------\n        are_equal : boolean\n        \"\"\"\n\n        try:\n            return (self.categories.equals(other.categories) and\n                    self.ordered == other.ordered)\n        except (AttributeError, TypeError):\n            return False\n\n    def describe(self):\n        \"\"\" Describes this Categorical\n\n        Returns\n        -------\n        description: `DataFrame`\n            A dataframe with frequency and counts by category.\n        \"\"\"\n        counts = self.value_counts(dropna=False)\n        freqs = counts / float(counts.sum())\n\n        from pandas.tools.merge import concat\n        result = concat([counts, freqs], axis=1)\n        result.columns = ['counts', 'freqs']\n        result.index.name = 'categories'\n\n        return result\n\n    def repeat(self, repeats, *args, **kwargs):\n        \"\"\"\n        Repeat elements of a Categorical.\n\n        See also\n        --------\n        numpy.ndarray.repeat\n\n        \"\"\"\n        nv.validate_repeat(args, kwargs)\n        codes = self._codes.repeat(repeats)\n        return self._constructor(values=codes, categories=self.categories,\n                                 ordered=self.ordered, fastpath=True)\n\n# The Series.cat accessor\n\n\nclass CategoricalAccessor(PandasDelegate, NoNewAttributesMixin):\n    \"\"\"\n    Accessor object for categorical properties of the Series values.\n\n    Be aware that assigning to `categories` is a inplace operation, while all\n    methods return new categorical data per default (but can be called with\n    `inplace=True`).\n\n    Examples\n    --------\n    >>> s.cat.categories\n    >>> s.cat.categories = list('abc')\n    >>> s.cat.rename_categories(list('cab'))\n    >>> s.cat.reorder_categories(list('cab'))\n    >>> s.cat.add_categories(['d','e'])\n    >>> s.cat.remove_categories(['d'])\n    >>> s.cat.remove_unused_categories()\n    >>> s.cat.set_categories(list('abcde'))\n    >>> s.cat.as_ordered()\n    >>> s.cat.as_unordered()\n\n    \"\"\"\n\n    def __init__(self, values, index):\n        self.categorical = values\n        self.index = index\n        self._freeze()\n\n    def _delegate_property_get(self, name):\n        return getattr(self.categorical, name)\n\n    def _delegate_property_set(self, name, new_values):\n        return setattr(self.categorical, name, new_values)\n\n    @property\n    def codes(self):\n        from pandas import Series\n        return Series(self.categorical.codes, index=self.index)\n\n    def _delegate_method(self, name, *args, **kwargs):\n        from pandas import Series\n        method = getattr(self.categorical, name)\n        res = method(*args, **kwargs)\n        if res is not None:\n            return Series(res, index=self.index)\n\n\nCategoricalAccessor._add_delegate_accessors(delegate=Categorical,\n                                            accessors=[\"categories\",\n                                                       \"ordered\"],\n                                            typ='property')\nCategoricalAccessor._add_delegate_accessors(delegate=Categorical, accessors=[\n    \"rename_categories\", \"reorder_categories\", \"add_categories\",\n    \"remove_categories\", \"remove_unused_categories\", \"set_categories\",\n    \"as_ordered\", \"as_unordered\"], typ='method')\n\n# utility routines\n\n\ndef _get_codes_for_values(values, categories):\n    \"\"\"\n    utility routine to turn values into codes given the specified categories\n    \"\"\"\n\n    from pandas.core.algorithms import _get_data_algo, _hashtables\n    if not is_dtype_equal(values.dtype, categories.dtype):\n        values = _ensure_object(values)\n        categories = _ensure_object(categories)\n\n    (hash_klass, vec_klass), vals = _get_data_algo(values, _hashtables)\n    (_, _), cats = _get_data_algo(categories, _hashtables)\n    t = hash_klass(len(cats))\n    t.map_locations(cats)\n    return _coerce_indexer_dtype(t.lookup(vals), cats)\n\n\ndef _convert_to_list_like(list_like):\n    if hasattr(list_like, \"dtype\"):\n        return list_like\n    if isinstance(list_like, list):\n        return list_like\n    if (is_sequence(list_like) or isinstance(list_like, tuple) or\n            isinstance(list_like, types.GeneratorType)):\n        return list(list_like)\n    elif is_scalar(list_like):\n        return [list_like]\n    else:\n        # is this reached?\n        return [list_like]\n"
    },
    {
      "filename": "pandas/tests/test_categorical.py",
      "content": "# -*- coding: utf-8 -*-\n# pylint: disable=E1101,E1103,W0232\n\nimport sys\nfrom datetime import datetime\nfrom distutils.version import LooseVersion\n\nimport numpy as np\n\nfrom pandas.types.dtypes import CategoricalDtype\nfrom pandas.types.common import (is_categorical_dtype,\n                                 is_object_dtype,\n                                 is_float_dtype,\n                                 is_integer_dtype)\n\nimport pandas as pd\nimport pandas.compat as compat\nimport pandas.util.testing as tm\nfrom pandas import (Categorical, Index, Series, DataFrame, PeriodIndex,\n                    Timestamp, CategoricalIndex, isnull)\nfrom pandas.compat import range, lrange, u, PY3\nfrom pandas.core.config import option_context\n\n# GH 12066\n# flake8: noqa\n\n\nclass TestCategorical(tm.TestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.factor = Categorical.from_array(['a', 'b', 'b', 'a',\n                                              'a', 'c', 'c', 'c'],\n                                             ordered=True)\n\n    def test_getitem(self):\n        self.assertEqual(self.factor[0], 'a')\n        self.assertEqual(self.factor[-1], 'c')\n\n        subf = self.factor[[0, 1, 2]]\n        tm.assert_numpy_array_equal(subf._codes,\n                                    np.array([0, 1, 1], dtype=np.int8))\n\n        subf = self.factor[np.asarray(self.factor) == 'c']\n        tm.assert_numpy_array_equal(subf._codes,\n                                    np.array([2, 2, 2], dtype=np.int8))\n\n    def test_getitem_listlike(self):\n\n        # GH 9469\n        # properly coerce the input indexers\n        np.random.seed(1)\n        c = Categorical(np.random.randint(0, 5, size=150000).astype(np.int8))\n        result = c.codes[np.array([100000]).astype(np.int64)]\n        expected = c[np.array([100000]).astype(np.int64)].codes\n        self.assert_numpy_array_equal(result, expected)\n\n    def test_setitem(self):\n\n        # int/positional\n        c = self.factor.copy()\n        c[0] = 'b'\n        self.assertEqual(c[0], 'b')\n        c[-1] = 'a'\n        self.assertEqual(c[-1], 'a')\n\n        # boolean\n        c = self.factor.copy()\n        indexer = np.zeros(len(c), dtype='bool')\n        indexer[0] = True\n        indexer[-1] = True\n        c[indexer] = 'c'\n        expected = Categorical.from_array(['c', 'b', 'b', 'a',\n                                           'a', 'c', 'c', 'c'], ordered=True)\n\n        self.assert_categorical_equal(c, expected)\n\n    def test_setitem_listlike(self):\n\n        # GH 9469\n        # properly coerce the input indexers\n        np.random.seed(1)\n        c = Categorical(np.random.randint(0, 5, size=150000).astype(\n            np.int8)).add_categories([-1000])\n        indexer = np.array([100000]).astype(np.int64)\n        c[indexer] = -1000\n\n        # we are asserting the code result here\n        # which maps to the -1000 category\n        result = c.codes[np.array([100000]).astype(np.int64)]\n        self.assertEqual(result, np.array([5], dtype='int8'))\n\n    def test_constructor_unsortable(self):\n\n        # it works!\n        arr = np.array([1, 2, 3, datetime.now()], dtype='O')\n        msg = \"Categoricals cannot be object dtype unless all values are \" \\\n              \"strings or all are periods.\"\n        with tm.assertRaisesRegexp(TypeError, msg):\n            factor = Categorical.from_array(arr, ordered=False)\n\n        # this however will raise as cannot be sorted\n        self.assertRaises(\n            TypeError, lambda: Categorical.from_array(arr, ordered=True))\n\n    def test_constructor_object_dtype(self):\n        #GH 13919\n\n        #categories must be of single dtype\n        arr = np.array([1, 2, 3, 's'], dtype=object)\n        msg = \"Categoricals cannot be object dtype unless all values are \" \\\n              \"strings or all are periods.\"\n        with tm.assertRaisesRegexp(TypeError, msg):\n            c = Categorical.from_array(arr)\n\n        # object dtype allowed when all strs\n        exp_arr = np.array(list('abcd'), dtype=object)\n        c = Categorical.from_array(exp_arr)\n        tm.assert_numpy_array_equal(c.__array__(), exp_arr)\n\n        # object dtype also allowed when all periods\n        idx = pd.period_range('1/1/2000', freq='D', periods=5)\n        c = Categorical(idx)\n        tm.assert_index_equal(c.categories, idx)\n\n    def test_is_equal_dtype(self):\n\n        # test dtype comparisons between cats\n\n        c1 = Categorical(list('aabca'), categories=list('abc'), ordered=False)\n        c2 = Categorical(list('aabca'), categories=list('cab'), ordered=False)\n        c3 = Categorical(list('aabca'), categories=list('cab'), ordered=True)\n        self.assertTrue(c1.is_dtype_equal(c1))\n        self.assertTrue(c2.is_dtype_equal(c2))\n        self.assertTrue(c3.is_dtype_equal(c3))\n        self.assertFalse(c1.is_dtype_equal(c2))\n        self.assertFalse(c1.is_dtype_equal(c3))\n        self.assertFalse(c1.is_dtype_equal(Index(list('aabca'))))\n        self.assertFalse(c1.is_dtype_equal(c1.astype(object)))\n        self.assertTrue(c1.is_dtype_equal(CategoricalIndex(c1)))\n        self.assertFalse(c1.is_dtype_equal(\n            CategoricalIndex(c1, categories=list('cab'))))\n        self.assertFalse(c1.is_dtype_equal(CategoricalIndex(c1, ordered=True)))\n\n    def test_constructor(self):\n\n        exp_arr = np.array([\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"], dtype=np.object_)\n        c1 = Categorical(exp_arr)\n        self.assert_numpy_array_equal(c1.__array__(), exp_arr)\n        c2 = Categorical(exp_arr, categories=[\"a\", \"b\", \"c\"])\n        self.assert_numpy_array_equal(c2.__array__(), exp_arr)\n        c2 = Categorical(exp_arr, categories=[\"c\", \"b\", \"a\"])\n        self.assert_numpy_array_equal(c2.__array__(), exp_arr)\n\n        # categories must be unique\n        def f():\n            Categorical([1, 2], [1, 2, 2])\n\n        self.assertRaises(ValueError, f)\n\n        def f():\n            Categorical([\"a\", \"b\"], [\"a\", \"b\", \"b\"])\n\n        self.assertRaises(ValueError, f)\n\n        def f():\n            with tm.assert_produces_warning(FutureWarning):\n                Categorical([1, 2], [1, 2, np.nan, np.nan])\n\n        self.assertRaises(ValueError, f)\n\n        # The default should be unordered\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        self.assertFalse(c1.ordered)\n\n        # Categorical as input\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(c1)\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(c1, categories=[\"a\", \"b\", \"c\"])\n        self.assert_numpy_array_equal(c1.__array__(), c2.__array__())\n        self.assert_index_equal(c2.categories, Index([\"a\", \"b\", \"c\"]))\n\n        # Series of dtype category\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(Series(c1))\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"c\", \"b\"])\n        c2 = Categorical(Series(c1))\n        tm.assert_categorical_equal(c1, c2)\n\n        # Series\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        c2 = Categorical(Series([\"a\", \"b\", \"c\", \"a\"]))\n        tm.assert_categorical_equal(c1, c2)\n\n        c1 = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        c2 = Categorical(Series([\"a\", \"b\", \"c\", \"a\"]),\n                         categories=[\"a\", \"b\", \"c\", \"d\"])\n        tm.assert_categorical_equal(c1, c2)\n\n        # This should result in integer categories, not float!\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        self.assertTrue(is_integer_dtype(cat.categories))\n\n        # https://github.com/pydata/pandas/issues/3678\n        cat = pd.Categorical([np.nan, 1, 2, 3])\n        self.assertTrue(is_integer_dtype(cat.categories))\n\n        # this should result in floats\n        cat = pd.Categorical([np.nan, 1, 2., 3])\n        self.assertTrue(is_float_dtype(cat.categories))\n\n        cat = pd.Categorical([np.nan, 1., 2., 3.])\n        self.assertTrue(is_float_dtype(cat.categories))\n\n        # Deprecating NaNs in categoires (GH #10748)\n        # preserve int as far as possible by converting to object if NaN is in\n        # categories\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([np.nan, 1, 2, 3],\n                                 categories=[np.nan, 1, 2, 3])\n        self.assertTrue(is_object_dtype(cat.categories))\n\n        # This doesn't work -> this would probably need some kind of \"remember\n        # the original type\" feature to try to cast the array interface result\n        # to...\n\n        # vals = np.asarray(cat[cat.notnull()])\n        # self.assertTrue(is_integer_dtype(vals))\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([np.nan, \"a\", \"b\", \"c\"],\n                                 categories=[np.nan, \"a\", \"b\", \"c\"])\n        self.assertTrue(is_object_dtype(cat.categories))\n        # but don't do it for floats\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([np.nan, 1., 2., 3.],\n                                 categories=[np.nan, 1., 2., 3.])\n        self.assertTrue(is_float_dtype(cat.categories))\n\n        # corner cases\n        cat = pd.Categorical([1])\n        self.assertTrue(len(cat.categories) == 1)\n        self.assertTrue(cat.categories[0] == 1)\n        self.assertTrue(len(cat.codes) == 1)\n        self.assertTrue(cat.codes[0] == 0)\n\n        cat = pd.Categorical([\"a\"])\n        self.assertTrue(len(cat.categories) == 1)\n        self.assertTrue(cat.categories[0] == \"a\")\n        self.assertTrue(len(cat.codes) == 1)\n        self.assertTrue(cat.codes[0] == 0)\n\n        # Scalars should be converted to lists\n        cat = pd.Categorical(1)\n        self.assertTrue(len(cat.categories) == 1)\n        self.assertTrue(cat.categories[0] == 1)\n        self.assertTrue(len(cat.codes) == 1)\n        self.assertTrue(cat.codes[0] == 0)\n\n        cat = pd.Categorical([1], categories=1)\n        self.assertTrue(len(cat.categories) == 1)\n        self.assertTrue(cat.categories[0] == 1)\n        self.assertTrue(len(cat.codes) == 1)\n        self.assertTrue(cat.codes[0] == 0)\n\n        # Catch old style constructor useage: two arrays, codes + categories\n        # We can only catch two cases:\n        #  - when the first is an integer dtype and the second is not\n        #  - when the resulting codes are all -1/NaN\n        with tm.assert_produces_warning(RuntimeWarning):\n            c_old = Categorical([0, 1, 2, 0, 1, 2],\n                                categories=[\"a\", \"b\", \"c\"])  # noqa\n\n        with tm.assert_produces_warning(RuntimeWarning):\n            c_old = Categorical([0, 1, 2, 0, 1, 2],  # noqa\n                                categories=[3, 4, 5])\n\n        # the next one are from the old docs, but unfortunately these don't\n        # trigger :-(\n        with tm.assert_produces_warning(None):\n            c_old2 = Categorical([0, 1, 2, 0, 1, 2], [1, 2, 3])  # noqa\n            cat = Categorical([1, 2], categories=[1, 2, 3])\n\n        # this is a legitimate constructor\n        with tm.assert_produces_warning(None):\n            c = Categorical(np.array([], dtype='int64'),  # noqa\n                            categories=[3, 2, 1], ordered=True)\n\n    def test_constructor_with_index(self):\n        ci = CategoricalIndex(list('aabbca'), categories=list('cab'))\n        tm.assert_categorical_equal(ci.values, Categorical(ci))\n\n        ci = CategoricalIndex(list('aabbca'), categories=list('cab'))\n        tm.assert_categorical_equal(ci.values,\n                                    Categorical(ci.astype(object),\n                                                categories=ci.categories))\n\n    def test_constructor_with_generator(self):\n        # This was raising an Error in isnull(single_val).any() because isnull\n        # returned a scalar for a generator\n        xrange = range\n\n        exp = Categorical([0, 1, 2])\n        cat = Categorical((x for x in [0, 1, 2]))\n        tm.assert_categorical_equal(cat, exp)\n        cat = Categorical(xrange(3))\n        tm.assert_categorical_equal(cat, exp)\n\n        # This uses xrange internally\n        from pandas.core.index import MultiIndex\n        MultiIndex.from_product([range(5), ['a', 'b', 'c']])\n\n        # check that categories accept generators and sequences\n        cat = pd.Categorical([0, 1, 2], categories=(x for x in [0, 1, 2]))\n        tm.assert_categorical_equal(cat, exp)\n        cat = pd.Categorical([0, 1, 2], categories=xrange(3))\n        tm.assert_categorical_equal(cat, exp)\n\n    def test_constructor_with_datetimelike(self):\n\n        # 12077\n        # constructor wwth a datetimelike and NaT\n\n        for dtl in [pd.date_range('1995-01-01 00:00:00',\n                                  periods=5, freq='s'),\n                    pd.date_range('1995-01-01 00:00:00',\n                                  periods=5, freq='s', tz='US/Eastern'),\n                    pd.timedelta_range('1 day', periods=5, freq='s')]:\n\n            s = Series(dtl)\n            c = Categorical(s)\n            expected = type(dtl)(s)\n            expected.freq = None\n            tm.assert_index_equal(c.categories, expected)\n            self.assert_numpy_array_equal(c.codes, np.arange(5, dtype='int8'))\n\n            # with NaT\n            s2 = s.copy()\n            s2.iloc[-1] = pd.NaT\n            c = Categorical(s2)\n            expected = type(dtl)(s2.dropna())\n            expected.freq = None\n            tm.assert_index_equal(c.categories, expected)\n\n            exp = np.array([0, 1, 2, 3, -1], dtype=np.int8)\n            self.assert_numpy_array_equal(c.codes, exp)\n\n            result = repr(c)\n            self.assertTrue('NaT' in result)\n\n    def test_constructor_from_index_series_datetimetz(self):\n        idx = pd.date_range('2015-01-01 10:00', freq='D', periods=3,\n                            tz='US/Eastern')\n        result = pd.Categorical.from_array(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = pd.Categorical.from_array(pd.Series(idx))\n        tm.assert_index_equal(result.categories, idx)\n\n    def test_constructor_from_index_series_timedelta(self):\n        idx = pd.timedelta_range('1 days', freq='D', periods=3)\n        result = pd.Categorical.from_array(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = pd.Categorical.from_array(pd.Series(idx))\n        tm.assert_index_equal(result.categories, idx)\n\n    def test_constructor_from_index_series_period(self):\n        idx = pd.period_range('2015-01-01', freq='D', periods=3)\n        result = pd.Categorical.from_array(idx)\n        tm.assert_index_equal(result.categories, idx)\n\n        result = pd.Categorical.from_array(pd.Series(idx))\n        tm.assert_index_equal(result.categories, idx)\n\n    def test_from_codes(self):\n\n        # too few categories\n        def f():\n            Categorical.from_codes([1, 2], [1, 2])\n\n        self.assertRaises(ValueError, f)\n\n        # no int codes\n        def f():\n            Categorical.from_codes([\"a\"], [1, 2])\n\n        self.assertRaises(ValueError, f)\n\n        # no unique categories\n        def f():\n            Categorical.from_codes([0, 1, 2], [\"a\", \"a\", \"b\"])\n\n        self.assertRaises(ValueError, f)\n\n        # too negative\n        def f():\n            Categorical.from_codes([-2, 1, 2], [\"a\", \"b\", \"c\"])\n\n        self.assertRaises(ValueError, f)\n\n        exp = Categorical([\"a\", \"b\", \"c\"], ordered=False)\n        res = Categorical.from_codes([0, 1, 2], [\"a\", \"b\", \"c\"])\n        tm.assert_categorical_equal(exp, res)\n\n        # Not available in earlier numpy versions\n        if hasattr(np.random, \"choice\"):\n            codes = np.random.choice([0, 1], 5, p=[0.9, 0.1])\n            pd.Categorical.from_codes(codes, categories=[\"train\", \"test\"])\n\n    def test_comparisons(self):\n\n        result = self.factor[self.factor == 'a']\n        expected = self.factor[np.asarray(self.factor) == 'a']\n        tm.assert_categorical_equal(result, expected)\n\n        result = self.factor[self.factor != 'a']\n        expected = self.factor[np.asarray(self.factor) != 'a']\n        tm.assert_categorical_equal(result, expected)\n\n        result = self.factor[self.factor < 'c']\n        expected = self.factor[np.asarray(self.factor) < 'c']\n        tm.assert_categorical_equal(result, expected)\n\n        result = self.factor[self.factor > 'a']\n        expected = self.factor[np.asarray(self.factor) > 'a']\n        tm.assert_categorical_equal(result, expected)\n\n        result = self.factor[self.factor >= 'b']\n        expected = self.factor[np.asarray(self.factor) >= 'b']\n        tm.assert_categorical_equal(result, expected)\n\n        result = self.factor[self.factor <= 'b']\n        expected = self.factor[np.asarray(self.factor) <= 'b']\n        tm.assert_categorical_equal(result, expected)\n\n        n = len(self.factor)\n\n        other = self.factor[np.random.permutation(n)]\n        result = self.factor == other\n        expected = np.asarray(self.factor) == np.asarray(other)\n        self.assert_numpy_array_equal(result, expected)\n\n        result = self.factor == 'd'\n        expected = np.repeat(False, len(self.factor))\n        self.assert_numpy_array_equal(result, expected)\n\n        # comparisons with categoricals\n        cat_rev = pd.Categorical([\"a\", \"b\", \"c\"], categories=[\"c\", \"b\", \"a\"],\n                                 ordered=True)\n        cat_rev_base = pd.Categorical(\n            [\"b\", \"b\", \"b\"], categories=[\"c\", \"b\", \"a\"], ordered=True)\n        cat = pd.Categorical([\"a\", \"b\", \"c\"], ordered=True)\n        cat_base = pd.Categorical([\"b\", \"b\", \"b\"], categories=cat.categories,\n                                  ordered=True)\n\n        # comparisons need to take categories ordering into account\n        res_rev = cat_rev > cat_rev_base\n        exp_rev = np.array([True, False, False])\n        self.assert_numpy_array_equal(res_rev, exp_rev)\n\n        res_rev = cat_rev < cat_rev_base\n        exp_rev = np.array([False, False, True])\n        self.assert_numpy_array_equal(res_rev, exp_rev)\n\n        res = cat > cat_base\n        exp = np.array([False, False, True])\n        self.assert_numpy_array_equal(res, exp)\n\n        # Only categories with same categories can be compared\n        def f():\n            cat > cat_rev\n\n        self.assertRaises(TypeError, f)\n\n        cat_rev_base2 = pd.Categorical(\n            [\"b\", \"b\", \"b\"], categories=[\"c\", \"b\", \"a\", \"d\"])\n\n        def f():\n            cat_rev > cat_rev_base2\n\n        self.assertRaises(TypeError, f)\n\n        # Only categories with same ordering information can be compared\n        cat_unorderd = cat.set_ordered(False)\n        self.assertFalse((cat > cat).any())\n\n        def f():\n            cat > cat_unorderd\n\n        self.assertRaises(TypeError, f)\n\n        # comparison (in both directions) with Series will raise\n        s = Series([\"b\", \"b\", \"b\"])\n        self.assertRaises(TypeError, lambda: cat > s)\n        self.assertRaises(TypeError, lambda: cat_rev > s)\n        self.assertRaises(TypeError, lambda: s < cat)\n        self.assertRaises(TypeError, lambda: s < cat_rev)\n\n        # comparison with numpy.array will raise in both direction, but only on\n        # newer numpy versions\n        a = np.array([\"b\", \"b\", \"b\"])\n        self.assertRaises(TypeError, lambda: cat > a)\n        self.assertRaises(TypeError, lambda: cat_rev > a)\n\n        # The following work via '__array_priority__ = 1000'\n        # works only on numpy >= 1.7.1\n        if LooseVersion(np.__version__) > \"1.7.1\":\n            self.assertRaises(TypeError, lambda: a < cat)\n            self.assertRaises(TypeError, lambda: a < cat_rev)\n\n        # Make sure that unequal comparison take the categories order in\n        # account\n        cat_rev = pd.Categorical(\n            list(\"abc\"), categories=list(\"cba\"), ordered=True)\n        exp = np.array([True, False, False])\n        res = cat_rev > \"b\"\n        self.assert_numpy_array_equal(res, exp)\n\n    def test_argsort(self):\n        c = Categorical([5, 3, 1, 4, 2], ordered=True)\n\n        expected = np.array([2, 4, 1, 3, 0])\n        tm.assert_numpy_array_equal(c.argsort(ascending=True), expected,\n                                    check_dtype=False)\n\n        expected = expected[::-1]\n        tm.assert_numpy_array_equal(c.argsort(ascending=False), expected,\n                                    check_dtype=False)\n\n    def test_numpy_argsort(self):\n        c = Categorical([5, 3, 1, 4, 2], ordered=True)\n\n        expected = np.array([2, 4, 1, 3, 0])\n        tm.assert_numpy_array_equal(np.argsort(c), expected,\n                                    check_dtype=False)\n\n        msg = \"the 'kind' parameter is not supported\"\n        tm.assertRaisesRegexp(ValueError, msg, np.argsort,\n                              c, kind='mergesort')\n\n        msg = \"the 'axis' parameter is not supported\"\n        tm.assertRaisesRegexp(ValueError, msg, np.argsort,\n                              c, axis=0)\n\n        msg = \"the 'order' parameter is not supported\"\n        tm.assertRaisesRegexp(ValueError, msg, np.argsort,\n                              c, order='C')\n\n    def test_na_flags_int_categories(self):\n        # #1457\n\n        categories = lrange(10)\n        labels = np.random.randint(0, 10, 20)\n        labels[::5] = -1\n\n        cat = Categorical(labels, categories, fastpath=True)\n        repr(cat)\n\n        self.assert_numpy_array_equal(isnull(cat), labels == -1)\n\n    def test_categories_none(self):\n        factor = Categorical(['a', 'b', 'b', 'a',\n                              'a', 'c', 'c', 'c'], ordered=True)\n        tm.assert_categorical_equal(factor, self.factor)\n\n    def test_describe(self):\n        # string type\n        desc = self.factor.describe()\n        self.assertTrue(self.factor.ordered)\n        exp_index = pd.CategoricalIndex(['a', 'b', 'c'], name='categories',\n                                        ordered=self.factor.ordered)\n        expected = DataFrame({'counts': [3, 2, 3],\n                              'freqs': [3 / 8., 2 / 8., 3 / 8.]},\n                             index=exp_index)\n        tm.assert_frame_equal(desc, expected)\n\n        # check unused categories\n        cat = self.factor.copy()\n        cat.set_categories([\"a\", \"b\", \"c\", \"d\"], inplace=True)\n        desc = cat.describe()\n\n        exp_index = pd.CategoricalIndex(['a', 'b', 'c', 'd'],\n                                        ordered=self.factor.ordered,\n                                        name='categories')\n        expected = DataFrame({'counts': [3, 2, 3, 0],\n                              'freqs': [3 / 8., 2 / 8., 3 / 8., 0]},\n                             index=exp_index)\n        tm.assert_frame_equal(desc, expected)\n\n        # check an integer one\n        cat = Categorical([1, 2, 3, 1, 2, 3, 3, 2, 1, 1, 1])\n        desc = cat.describe()\n        exp_index = pd.CategoricalIndex([1, 2, 3], ordered=cat.ordered,\n                                        name='categories')\n        expected = DataFrame({'counts': [5, 3, 3],\n                              'freqs': [5 / 11., 3 / 11., 3 / 11.]},\n                             index=exp_index)\n        tm.assert_frame_equal(desc, expected)\n\n        # https://github.com/pydata/pandas/issues/3678\n        # describe should work with NaN\n        cat = pd.Categorical([np.nan, 1, 2, 2])\n        desc = cat.describe()\n        expected = DataFrame({'counts': [1, 2, 1],\n                              'freqs': [1 / 4., 2 / 4., 1 / 4.]},\n                             index=pd.CategoricalIndex([1, 2, np.nan],\n                                                       categories=[1, 2],\n                                                       name='categories'))\n        tm.assert_frame_equal(desc, expected)\n\n        # NA as a category\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([\"a\", \"c\", \"c\", np.nan],\n                                 categories=[\"b\", \"a\", \"c\", np.nan])\n            result = cat.describe()\n\n        expected = DataFrame([[0, 0], [1, 0.25], [2, 0.5], [1, 0.25]],\n                             columns=['counts', 'freqs'],\n                             index=pd.CategoricalIndex(['b', 'a', 'c', np.nan],\n                                                       name='categories'))\n        tm.assert_frame_equal(result, expected, check_categorical=False)\n\n        # NA as an unused category\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([\"a\", \"c\", \"c\"],\n                                 categories=[\"b\", \"a\", \"c\", np.nan])\n            result = cat.describe()\n\n        exp_idx = pd.CategoricalIndex(\n            ['b', 'a', 'c', np.nan], name='categories')\n        expected = DataFrame([[0, 0], [1, 1 / 3.], [2, 2 / 3.], [0, 0]],\n                             columns=['counts', 'freqs'], index=exp_idx)\n        tm.assert_frame_equal(result, expected, check_categorical=False)\n\n    def test_print(self):\n        expected = [\"[a, b, b, a, a, c, c, c]\",\n                    \"Categories (3, object): [a < b < c]\"]\n        expected = \"\\n\".join(expected)\n        actual = repr(self.factor)\n        self.assertEqual(actual, expected)\n\n    def test_big_print(self):\n        factor = Categorical([0, 1, 2, 0, 1, 2] * 100, ['a', 'b', 'c'],\n                             name='cat', fastpath=True)\n        expected = [\"[a, b, c, a, b, ..., b, c, a, b, c]\", \"Length: 600\",\n                    \"Categories (3, object): [a, b, c]\"]\n        expected = \"\\n\".join(expected)\n\n        actual = repr(factor)\n\n        self.assertEqual(actual, expected)\n\n    def test_empty_print(self):\n        factor = Categorical([], [\"a\", \"b\", \"c\"])\n        expected = (\"[], Categories (3, object): [a, b, c]\")\n        # hack because array_repr changed in numpy > 1.6.x\n        actual = repr(factor)\n        self.assertEqual(actual, expected)\n\n        self.assertEqual(expected, actual)\n        factor = Categorical([], [\"a\", \"b\", \"c\"], ordered=True)\n        expected = (\"[], Categories (3, object): [a < b < c]\")\n        actual = repr(factor)\n        self.assertEqual(expected, actual)\n\n        factor = Categorical([], [])\n        expected = (\"[], Categories (0, object): []\")\n        self.assertEqual(expected, repr(factor))\n\n    def test_print_none_width(self):\n        # GH10087\n        a = pd.Series(pd.Categorical([1, 2, 3, 4]))\n        exp = u(\"0    1\\n1    2\\n2    3\\n3    4\\n\" +\n                \"dtype: category\\nCategories (4, int64): [1, 2, 3, 4]\")\n\n        with option_context(\"display.width\", None):\n            self.assertEqual(exp, repr(a))\n\n    def test_unicode_print(self):\n        if PY3:\n            _rep = repr\n        else:\n            _rep = unicode  # noqa\n\n        c = pd.Categorical(['aaaaa', 'bb', 'cccc'] * 20)\n        expected = u\"\"\"\\\n[aaaaa, bb, cccc, aaaaa, bb, ..., bb, cccc, aaaaa, bb, cccc]\nLength: 60\nCategories (3, object): [aaaaa, bb, cccc]\"\"\"\n\n        self.assertEqual(_rep(c), expected)\n\n        c = pd.Categorical([u'ああああ', u'いいいいい', u'ううううううう']\n                           * 20)\n        expected = u\"\"\"\\\n[ああああ, いいいいい, ううううううう, ああああ, いいいいい, ..., いいいいい, ううううううう, ああああ, いいいいい, ううううううう]\nLength: 60\nCategories (3, object): [ああああ, いいいいい, ううううううう]\"\"\"  # noqa\n\n        self.assertEqual(_rep(c), expected)\n\n        # unicode option should not affect to Categorical, as it doesn't care\n        # the repr width\n        with option_context('display.unicode.east_asian_width', True):\n\n            c = pd.Categorical([u'ああああ', u'いいいいい', u'ううううううう']\n                               * 20)\n            expected = u\"\"\"[ああああ, いいいいい, ううううううう, ああああ, いいいいい, ..., いいいいい, ううううううう, ああああ, いいいいい, ううううううう]\nLength: 60\nCategories (3, object): [ああああ, いいいいい, ううううううう]\"\"\"  # noqa\n\n            self.assertEqual(_rep(c), expected)\n\n    def test_periodindex(self):\n        idx1 = PeriodIndex(['2014-01', '2014-01', '2014-02', '2014-02',\n                            '2014-03', '2014-03'], freq='M')\n\n        cat1 = Categorical.from_array(idx1)\n        str(cat1)\n        exp_arr = np.array([0, 0, 1, 1, 2, 2], dtype=np.int8)\n        exp_idx = PeriodIndex(['2014-01', '2014-02', '2014-03'], freq='M')\n        self.assert_numpy_array_equal(cat1._codes, exp_arr)\n        self.assert_index_equal(cat1.categories, exp_idx)\n\n        idx2 = PeriodIndex(['2014-03', '2014-03', '2014-02', '2014-01',\n                            '2014-03', '2014-01'], freq='M')\n        cat2 = Categorical.from_array(idx2, ordered=True)\n        str(cat2)\n        exp_arr = np.array([2, 2, 1, 0, 2, 0], dtype=np.int8)\n        exp_idx2 = PeriodIndex(['2014-01', '2014-02', '2014-03'], freq='M')\n        self.assert_numpy_array_equal(cat2._codes, exp_arr)\n        self.assert_index_equal(cat2.categories, exp_idx2)\n\n        idx3 = PeriodIndex(['2013-12', '2013-11', '2013-10', '2013-09',\n                            '2013-08', '2013-07', '2013-05'], freq='M')\n        cat3 = Categorical.from_array(idx3, ordered=True)\n        exp_arr = np.array([6, 5, 4, 3, 2, 1, 0], dtype=np.int8)\n        exp_idx = PeriodIndex(['2013-05', '2013-07', '2013-08', '2013-09',\n                               '2013-10', '2013-11', '2013-12'], freq='M')\n        self.assert_numpy_array_equal(cat3._codes, exp_arr)\n        self.assert_index_equal(cat3.categories, exp_idx)\n\n    def test_categories_assigments(self):\n        s = pd.Categorical([\"a\", \"b\", \"c\", \"a\"])\n        exp = np.array([1, 2, 3, 1], dtype=np.int64)\n        s.categories = [1, 2, 3]\n        self.assert_numpy_array_equal(s.__array__(), exp)\n        self.assert_index_equal(s.categories, Index([1, 2, 3]))\n\n        # lengthen\n        def f():\n            s.categories = [1, 2, 3, 4]\n\n        self.assertRaises(ValueError, f)\n\n        # shorten\n        def f():\n            s.categories = [1, 2]\n\n        self.assertRaises(ValueError, f)\n\n    def test_construction_with_ordered(self):\n        # GH 9347, 9190\n        cat = Categorical([0, 1, 2])\n        self.assertFalse(cat.ordered)\n        cat = Categorical([0, 1, 2], ordered=False)\n        self.assertFalse(cat.ordered)\n        cat = Categorical([0, 1, 2], ordered=True)\n        self.assertTrue(cat.ordered)\n\n    def test_ordered_api(self):\n        # GH 9347\n        cat1 = pd.Categorical([\"a\", \"c\", \"b\"], ordered=False)\n        self.assert_index_equal(cat1.categories, Index(['a', 'b', 'c']))\n        self.assertFalse(cat1.ordered)\n\n        cat2 = pd.Categorical([\"a\", \"c\", \"b\"], categories=['b', 'c', 'a'],\n                              ordered=False)\n        self.assert_index_equal(cat2.categories, Index(['b', 'c', 'a']))\n        self.assertFalse(cat2.ordered)\n\n        cat3 = pd.Categorical([\"a\", \"c\", \"b\"], ordered=True)\n        self.assert_index_equal(cat3.categories, Index(['a', 'b', 'c']))\n        self.assertTrue(cat3.ordered)\n\n        cat4 = pd.Categorical([\"a\", \"c\", \"b\"], categories=['b', 'c', 'a'],\n                              ordered=True)\n        self.assert_index_equal(cat4.categories, Index(['b', 'c', 'a']))\n        self.assertTrue(cat4.ordered)\n\n    def test_set_ordered(self):\n\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        cat2 = cat.as_unordered()\n        self.assertFalse(cat2.ordered)\n        cat2 = cat.as_ordered()\n        self.assertTrue(cat2.ordered)\n        cat2.as_unordered(inplace=True)\n        self.assertFalse(cat2.ordered)\n        cat2.as_ordered(inplace=True)\n        self.assertTrue(cat2.ordered)\n\n        self.assertTrue(cat2.set_ordered(True).ordered)\n        self.assertFalse(cat2.set_ordered(False).ordered)\n        cat2.set_ordered(True, inplace=True)\n        self.assertTrue(cat2.ordered)\n        cat2.set_ordered(False, inplace=True)\n        self.assertFalse(cat2.ordered)\n\n        # removed in 0.19.0\n        msg = \"can\\'t set attribute\"\n        with tm.assertRaisesRegexp(AttributeError, msg):\n            cat.ordered = True\n        with tm.assertRaisesRegexp(AttributeError, msg):\n            cat.ordered = False\n\n    def test_set_categories(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        exp_categories = Index([\"c\", \"b\", \"a\"])\n        exp_values = np.array([\"a\", \"b\", \"c\", \"a\"], dtype=np.object_)\n\n        res = cat.set_categories([\"c\", \"b\", \"a\"], inplace=True)\n        self.assert_index_equal(cat.categories, exp_categories)\n        self.assert_numpy_array_equal(cat.__array__(), exp_values)\n        self.assertIsNone(res)\n\n        res = cat.set_categories([\"a\", \"b\", \"c\"])\n        # cat must be the same as before\n        self.assert_index_equal(cat.categories, exp_categories)\n        self.assert_numpy_array_equal(cat.__array__(), exp_values)\n        # only res is changed\n        exp_categories_back = Index([\"a\", \"b\", \"c\"])\n        self.assert_index_equal(res.categories, exp_categories_back)\n        self.assert_numpy_array_equal(res.__array__(), exp_values)\n\n        # not all \"old\" included in \"new\" -> all not included ones are now\n        # np.nan\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        res = cat.set_categories([\"a\"])\n        self.assert_numpy_array_equal(res.codes,\n                                      np.array([0, -1, -1, 0], dtype=np.int8))\n\n        # still not all \"old\" in \"new\"\n        res = cat.set_categories([\"a\", \"b\", \"d\"])\n        self.assert_numpy_array_equal(res.codes,\n                                      np.array([0, 1, -1, 0], dtype=np.int8))\n        self.assert_index_equal(res.categories, Index([\"a\", \"b\", \"d\"]))\n\n        # all \"old\" included in \"new\"\n        cat = cat.set_categories([\"a\", \"b\", \"c\", \"d\"])\n        exp_categories = Index([\"a\", \"b\", \"c\", \"d\"])\n        self.assert_index_equal(cat.categories, exp_categories)\n\n        # internals...\n        c = Categorical([1, 2, 3, 4, 1], categories=[1, 2, 3, 4], ordered=True)\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, 2, 3, 0], dtype=np.int8))\n        self.assert_index_equal(c.categories, Index([1, 2, 3, 4]))\n\n        exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(c.get_values(), exp)\n\n        # all \"pointers\" to '4' must be changed from 3 to 0,...\n        c = c.set_categories([4, 3, 2, 1])\n\n        # positions are changed\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([3, 2, 1, 0, 3], dtype=np.int8))\n\n        # categories are now in new order\n        self.assert_index_equal(c.categories, Index([4, 3, 2, 1]))\n\n        # output is the same\n        exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(c.get_values(), exp)\n        self.assertTrue(c.min(), 4)\n        self.assertTrue(c.max(), 1)\n\n        # set_categories should set the ordering if specified\n        c2 = c.set_categories([4, 3, 2, 1], ordered=False)\n        self.assertFalse(c2.ordered)\n        self.assert_numpy_array_equal(c.get_values(), c2.get_values())\n\n        # set_categories should pass thru the ordering\n        c2 = c.set_ordered(False).set_categories([4, 3, 2, 1])\n        self.assertFalse(c2.ordered)\n        self.assert_numpy_array_equal(c.get_values(), c2.get_values())\n\n    def test_rename_categories(self):\n        cat = pd.Categorical([\"a\", \"b\", \"c\", \"a\"])\n\n        # inplace=False: the old one must not be changed\n        res = cat.rename_categories([1, 2, 3])\n        self.assert_numpy_array_equal(res.__array__(),\n                                      np.array([1, 2, 3, 1], dtype=np.int64))\n        self.assert_index_equal(res.categories, Index([1, 2, 3]))\n\n        exp_cat = np.array([\"a\", \"b\", \"c\", \"a\"], dtype=np.object_)\n        self.assert_numpy_array_equal(cat.__array__(), exp_cat)\n\n        exp_cat = Index([\"a\", \"b\", \"c\"])\n        self.assert_index_equal(cat.categories, exp_cat)\n        res = cat.rename_categories([1, 2, 3], inplace=True)\n\n        # and now inplace\n        self.assertIsNone(res)\n        self.assert_numpy_array_equal(cat.__array__(),\n                                      np.array([1, 2, 3, 1], dtype=np.int64))\n        self.assert_index_equal(cat.categories, Index([1, 2, 3]))\n\n        # lengthen\n        def f():\n            cat.rename_categories([1, 2, 3, 4])\n\n        self.assertRaises(ValueError, f)\n\n        # shorten\n        def f():\n            cat.rename_categories([1, 2])\n\n        self.assertRaises(ValueError, f)\n\n    def test_reorder_categories(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        old = cat.copy()\n        new = Categorical([\"a\", \"b\", \"c\", \"a\"], categories=[\"c\", \"b\", \"a\"],\n                          ordered=True)\n\n        # first inplace == False\n        res = cat.reorder_categories([\"c\", \"b\", \"a\"])\n        # cat must be the same as before\n        self.assert_categorical_equal(cat, old)\n        # only res is changed\n        self.assert_categorical_equal(res, new)\n\n        # inplace == True\n        res = cat.reorder_categories([\"c\", \"b\", \"a\"], inplace=True)\n        self.assertIsNone(res)\n        self.assert_categorical_equal(cat, new)\n\n        # not all \"old\" included in \"new\"\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n\n        def f():\n            cat.reorder_categories([\"a\"])\n\n        self.assertRaises(ValueError, f)\n\n        # still not all \"old\" in \"new\"\n        def f():\n            cat.reorder_categories([\"a\", \"b\", \"d\"])\n\n        self.assertRaises(ValueError, f)\n\n        # all \"old\" included in \"new\", but too long\n        def f():\n            cat.reorder_categories([\"a\", \"b\", \"c\", \"d\"])\n\n        self.assertRaises(ValueError, f)\n\n    def test_add_categories(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        old = cat.copy()\n        new = Categorical([\"a\", \"b\", \"c\", \"a\"],\n                          categories=[\"a\", \"b\", \"c\", \"d\"], ordered=True)\n\n        # first inplace == False\n        res = cat.add_categories(\"d\")\n        self.assert_categorical_equal(cat, old)\n        self.assert_categorical_equal(res, new)\n\n        res = cat.add_categories([\"d\"])\n        self.assert_categorical_equal(cat, old)\n        self.assert_categorical_equal(res, new)\n\n        # inplace == True\n        res = cat.add_categories(\"d\", inplace=True)\n        self.assert_categorical_equal(cat, new)\n        self.assertIsNone(res)\n\n        # new is in old categories\n        def f():\n            cat.add_categories([\"d\"])\n\n        self.assertRaises(ValueError, f)\n\n        # GH 9927\n        cat = Categorical(list(\"abc\"), ordered=True)\n        expected = Categorical(\n            list(\"abc\"), categories=list(\"abcde\"), ordered=True)\n        # test with Series, np.array, index, list\n        res = cat.add_categories(Series([\"d\", \"e\"]))\n        self.assert_categorical_equal(res, expected)\n        res = cat.add_categories(np.array([\"d\", \"e\"]))\n        self.assert_categorical_equal(res, expected)\n        res = cat.add_categories(Index([\"d\", \"e\"]))\n        self.assert_categorical_equal(res, expected)\n        res = cat.add_categories([\"d\", \"e\"])\n        self.assert_categorical_equal(res, expected)\n\n    def test_remove_categories(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True)\n        old = cat.copy()\n        new = Categorical([\"a\", \"b\", np.nan, \"a\"], categories=[\"a\", \"b\"],\n                          ordered=True)\n\n        # first inplace == False\n        res = cat.remove_categories(\"c\")\n        self.assert_categorical_equal(cat, old)\n        self.assert_categorical_equal(res, new)\n\n        res = cat.remove_categories([\"c\"])\n        self.assert_categorical_equal(cat, old)\n        self.assert_categorical_equal(res, new)\n\n        # inplace == True\n        res = cat.remove_categories(\"c\", inplace=True)\n        self.assert_categorical_equal(cat, new)\n        self.assertIsNone(res)\n\n        # removal is not in categories\n        def f():\n            cat.remove_categories([\"c\"])\n\n        self.assertRaises(ValueError, f)\n\n    def test_remove_unused_categories(self):\n        c = Categorical([\"a\", \"b\", \"c\", \"d\", \"a\"],\n                        categories=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n        exp_categories_all = Index([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        exp_categories_dropped = Index([\"a\", \"b\", \"c\", \"d\"])\n\n        self.assert_index_equal(c.categories, exp_categories_all)\n\n        res = c.remove_unused_categories()\n        self.assert_index_equal(res.categories, exp_categories_dropped)\n        self.assert_index_equal(c.categories, exp_categories_all)\n\n        res = c.remove_unused_categories(inplace=True)\n        self.assert_index_equal(c.categories, exp_categories_dropped)\n        self.assertIsNone(res)\n\n        # with NaN values (GH11599)\n        c = Categorical([\"a\", \"b\", \"c\", np.nan],\n                        categories=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n        res = c.remove_unused_categories()\n        self.assert_index_equal(res.categories,\n                                Index(np.array([\"a\", \"b\", \"c\"])))\n        exp_codes = np.array([0, 1, 2, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(res.codes, exp_codes)\n        self.assert_index_equal(c.categories, exp_categories_all)\n\n        val = ['F', np.nan, 'D', 'B', 'D', 'F', np.nan]\n        cat = pd.Categorical(values=val, categories=list('ABCDEFG'))\n        out = cat.remove_unused_categories()\n        self.assert_index_equal(out.categories, Index(['B', 'D', 'F']))\n        exp_codes = np.array([2, -1, 1, 0, 1, 2, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(out.codes, exp_codes)\n        self.assertEqual(out.get_values().tolist(), val)\n\n        alpha = list('abcdefghijklmnopqrstuvwxyz')\n        val = np.random.choice(alpha[::2], 10000).astype('object')\n        val[np.random.choice(len(val), 100)] = np.nan\n\n        cat = pd.Categorical(values=val, categories=alpha)\n        out = cat.remove_unused_categories()\n        self.assertEqual(out.get_values().tolist(), val.tolist())\n\n    def test_nan_handling(self):\n\n        # Nans are represented as -1 in codes\n        c = Categorical([\"a\", \"b\", np.nan, \"a\"])\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\"]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, -1, 0], dtype=np.int8))\n        c[1] = np.nan\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\"]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, -1, -1, 0], dtype=np.int8))\n\n        # If categories have nan included, the code should point to that\n        # instead\n        with tm.assert_produces_warning(FutureWarning):\n            c = Categorical([\"a\", \"b\", np.nan, \"a\"],\n                            categories=[\"a\", \"b\", np.nan])\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\", np.nan]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, 2, 0], dtype=np.int8))\n        c[1] = np.nan\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\", np.nan]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 2, 2, 0], dtype=np.int8))\n\n        # Changing categories should also make the replaced category np.nan\n        c = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        with tm.assert_produces_warning(FutureWarning):\n            c.categories = [\"a\", \"b\", np.nan]  # noqa\n\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\", np.nan]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, 2, 0], dtype=np.int8))\n\n        # Adding nan to categories should make assigned nan point to the\n        # category!\n        c = Categorical([\"a\", \"b\", np.nan, \"a\"])\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\"]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, -1, 0], dtype=np.int8))\n        with tm.assert_produces_warning(FutureWarning):\n            c.set_categories([\"a\", \"b\", np.nan], rename=True, inplace=True)\n\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\", np.nan]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 1, -1, 0], dtype=np.int8))\n        c[1] = np.nan\n        self.assert_index_equal(c.categories, Index([\"a\", \"b\", np.nan]))\n        self.assert_numpy_array_equal(c._codes,\n                                      np.array([0, 2, -1, 0], dtype=np.int8))\n\n        # Remove null categories (GH 10156)\n        cases = [([1.0, 2.0, np.nan], [1.0, 2.0]),\n                 (['a', 'b', None], ['a', 'b']),\n                 ([pd.Timestamp('2012-05-01'), pd.NaT],\n                  [pd.Timestamp('2012-05-01')])]\n\n        null_values = [np.nan, None, pd.NaT]\n\n        for with_null, without in cases:\n            with tm.assert_produces_warning(FutureWarning):\n                base = Categorical([], with_null)\n            expected = Categorical([], without)\n\n            for nullval in null_values:\n                result = base.remove_categories(nullval)\n            self.assert_categorical_equal(result, expected)\n\n        # Different null values are indistinguishable\n        for i, j in [(0, 1), (0, 2), (1, 2)]:\n            nulls = [null_values[i], null_values[j]]\n\n            def f():\n                with tm.assert_produces_warning(FutureWarning):\n                    Categorical([], categories=nulls)\n\n            self.assertRaises(ValueError, f)\n\n    def test_isnull(self):\n        exp = np.array([False, False, True])\n        c = Categorical([\"a\", \"b\", np.nan])\n        res = c.isnull()\n        self.assert_numpy_array_equal(res, exp)\n\n        with tm.assert_produces_warning(FutureWarning):\n            c = Categorical([\"a\", \"b\", np.nan], categories=[\"a\", \"b\", np.nan])\n        res = c.isnull()\n        self.assert_numpy_array_equal(res, exp)\n\n        # test both nan in categories and as -1\n        exp = np.array([True, False, True])\n        c = Categorical([\"a\", \"b\", np.nan])\n        with tm.assert_produces_warning(FutureWarning):\n            c.set_categories([\"a\", \"b\", np.nan], rename=True, inplace=True)\n        c[0] = np.nan\n        res = c.isnull()\n        self.assert_numpy_array_equal(res, exp)\n\n    def test_codes_immutable(self):\n\n        # Codes should be read only\n        c = Categorical([\"a\", \"b\", \"c\", \"a\", np.nan])\n        exp = np.array([0, 1, 2, 0, -1], dtype='int8')\n        self.assert_numpy_array_equal(c.codes, exp)\n\n        # Assignments to codes should raise\n        def f():\n            c.codes = np.array([0, 1, 2, 0, 1], dtype='int8')\n\n        self.assertRaises(ValueError, f)\n\n        # changes in the codes array should raise\n        # np 1.6.1 raises RuntimeError rather than ValueError\n        codes = c.codes\n\n        def f():\n            codes[4] = 1\n\n        self.assertRaises(ValueError, f)\n\n        # But even after getting the codes, the original array should still be\n        # writeable!\n        c[4] = \"a\"\n        exp = np.array([0, 1, 2, 0, 0], dtype='int8')\n        self.assert_numpy_array_equal(c.codes, exp)\n        c._codes[4] = 2\n        exp = np.array([0, 1, 2, 0, 2], dtype='int8')\n        self.assert_numpy_array_equal(c.codes, exp)\n\n    def test_min_max(self):\n\n        # unordered cats have no min/max\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\"], ordered=False)\n        self.assertRaises(TypeError, lambda: cat.min())\n        self.assertRaises(TypeError, lambda: cat.max())\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\"], ordered=True)\n        _min = cat.min()\n        _max = cat.max()\n        self.assertEqual(_min, \"a\")\n        self.assertEqual(_max, \"d\")\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\"],\n                          categories=['d', 'c', 'b', 'a'], ordered=True)\n        _min = cat.min()\n        _max = cat.max()\n        self.assertEqual(_min, \"d\")\n        self.assertEqual(_max, \"a\")\n        cat = Categorical([np.nan, \"b\", \"c\", np.nan],\n                          categories=['d', 'c', 'b', 'a'], ordered=True)\n        _min = cat.min()\n        _max = cat.max()\n        self.assertTrue(np.isnan(_min))\n        self.assertEqual(_max, \"b\")\n\n        _min = cat.min(numeric_only=True)\n        self.assertEqual(_min, \"c\")\n        _max = cat.max(numeric_only=True)\n        self.assertEqual(_max, \"b\")\n\n        cat = Categorical([np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1],\n                          ordered=True)\n        _min = cat.min()\n        _max = cat.max()\n        self.assertTrue(np.isnan(_min))\n        self.assertEqual(_max, 1)\n\n        _min = cat.min(numeric_only=True)\n        self.assertEqual(_min, 2)\n        _max = cat.max(numeric_only=True)\n        self.assertEqual(_max, 1)\n\n    def test_unique(self):\n        # categories are reordered based on value when ordered=False\n        cat = Categorical([\"a\", \"b\"])\n        exp = Index([\"a\", \"b\"])\n        res = cat.unique()\n        self.assert_index_equal(res.categories, exp)\n        self.assert_categorical_equal(res, cat)\n\n        cat = Categorical([\"a\", \"b\", \"a\", \"a\"], categories=[\"a\", \"b\", \"c\"])\n        res = cat.unique()\n        self.assert_index_equal(res.categories, exp)\n        tm.assert_categorical_equal(res, Categorical(exp))\n\n        cat = Categorical([\"c\", \"a\", \"b\", \"a\", \"a\"],\n                          categories=[\"a\", \"b\", \"c\"])\n        exp = Index([\"c\", \"a\", \"b\"])\n        res = cat.unique()\n        self.assert_index_equal(res.categories, exp)\n        exp_cat = Categorical(exp, categories=['c', 'a', 'b'])\n        tm.assert_categorical_equal(res, exp_cat)\n\n        # nan must be removed\n        cat = Categorical([\"b\", np.nan, \"b\", np.nan, \"a\"],\n                          categories=[\"a\", \"b\", \"c\"])\n        res = cat.unique()\n        exp = Index([\"b\", \"a\"])\n        self.assert_index_equal(res.categories, exp)\n        exp_cat = Categorical([\"b\", np.nan, \"a\"], categories=[\"b\", \"a\"])\n        tm.assert_categorical_equal(res, exp_cat)\n\n    def test_unique_ordered(self):\n        # keep categories order when ordered=True\n        cat = Categorical(['b', 'a', 'b'], categories=['a', 'b'], ordered=True)\n        res = cat.unique()\n        exp_cat = Categorical(['b', 'a'], categories=['a', 'b'], ordered=True)\n        tm.assert_categorical_equal(res, exp_cat)\n\n        cat = Categorical(['c', 'b', 'a', 'a'], categories=['a', 'b', 'c'],\n                          ordered=True)\n        res = cat.unique()\n        exp_cat = Categorical(['c', 'b', 'a'], categories=['a', 'b', 'c'],\n                              ordered=True)\n        tm.assert_categorical_equal(res, exp_cat)\n\n        cat = Categorical(['b', 'a', 'a'], categories=['a', 'b', 'c'],\n                          ordered=True)\n        res = cat.unique()\n        exp_cat = Categorical(['b', 'a'], categories=['a', 'b'], ordered=True)\n        tm.assert_categorical_equal(res, exp_cat)\n\n        cat = Categorical(['b', 'b', np.nan, 'a'], categories=['a', 'b', 'c'],\n                          ordered=True)\n        res = cat.unique()\n        exp_cat = Categorical(['b', np.nan, 'a'], categories=['a', 'b'],\n                              ordered=True)\n        tm.assert_categorical_equal(res, exp_cat)\n\n    def test_mode(self):\n        s = Categorical([1, 1, 2, 4, 5, 5, 5], categories=[5, 4, 3, 2, 1],\n                        ordered=True)\n        res = s.mode()\n        exp = Categorical([5], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n        s = Categorical([1, 1, 1, 4, 5, 5, 5], categories=[5, 4, 3, 2, 1],\n                        ordered=True)\n        res = s.mode()\n        exp = Categorical([5, 1], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n        s = Categorical([1, 2, 3, 4, 5], categories=[5, 4, 3, 2, 1],\n                        ordered=True)\n        res = s.mode()\n        exp = Categorical([], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n        # NaN should not become the mode!\n        s = Categorical([np.nan, np.nan, np.nan, 4, 5],\n                        categories=[5, 4, 3, 2, 1], ordered=True)\n        res = s.mode()\n        exp = Categorical([], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n        s = Categorical([np.nan, np.nan, np.nan, 4, 5, 4],\n                        categories=[5, 4, 3, 2, 1], ordered=True)\n        res = s.mode()\n        exp = Categorical([4], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n        s = Categorical([np.nan, np.nan, 4, 5, 4], categories=[5, 4, 3, 2, 1],\n                        ordered=True)\n        res = s.mode()\n        exp = Categorical([4], categories=[5, 4, 3, 2, 1], ordered=True)\n        tm.assert_categorical_equal(res, exp)\n\n    def test_sort_values(self):\n\n        # unordered cats are sortable\n        cat = Categorical([\"a\", \"b\", \"b\", \"a\"], ordered=False)\n        cat.sort_values()\n\n        cat = Categorical([\"a\", \"c\", \"b\", \"d\"], ordered=True)\n\n        # sort_values\n        res = cat.sort_values()\n        exp = np.array([\"a\", \"b\", \"c\", \"d\"], dtype=object)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, cat.categories)\n\n        cat = Categorical([\"a\", \"c\", \"b\", \"d\"],\n                          categories=[\"a\", \"b\", \"c\", \"d\"], ordered=True)\n        res = cat.sort_values()\n        exp = np.array([\"a\", \"b\", \"c\", \"d\"], dtype=object)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, cat.categories)\n\n        res = cat.sort_values(ascending=False)\n        exp = np.array([\"d\", \"c\", \"b\", \"a\"], dtype=object)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, cat.categories)\n\n        # sort (inplace order)\n        cat1 = cat.copy()\n        cat1.sort_values(inplace=True)\n        exp = np.array([\"a\", \"b\", \"c\", \"d\"], dtype=object)\n        self.assert_numpy_array_equal(cat1.__array__(), exp)\n        self.assert_index_equal(res.categories, cat.categories)\n\n        # reverse\n        cat = Categorical([\"a\", \"c\", \"c\", \"b\", \"d\"], ordered=True)\n        res = cat.sort_values(ascending=False)\n        exp_val = np.array([\"d\", \"c\", \"c\", \"b\", \"a\"], dtype=object)\n        exp_categories = Index([\"a\", \"b\", \"c\", \"d\"])\n        self.assert_numpy_array_equal(res.__array__(), exp_val)\n        self.assert_index_equal(res.categories, exp_categories)\n\n    def test_sort_values_na_position(self):\n        # see gh-12882\n        cat = Categorical([5, 2, np.nan, 2, np.nan], ordered=True)\n        exp_categories = Index([2, 5])\n\n        exp = np.array([2.0, 2.0, 5.0, np.nan, np.nan])\n        res = cat.sort_values()  # default arguments\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        exp = np.array([np.nan, np.nan, 2.0, 2.0, 5.0])\n        res = cat.sort_values(ascending=True, na_position='first')\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        exp = np.array([np.nan, np.nan, 5.0, 2.0, 2.0])\n        res = cat.sort_values(ascending=False, na_position='first')\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        exp = np.array([2.0, 2.0, 5.0, np.nan, np.nan])\n        res = cat.sort_values(ascending=True, na_position='last')\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        exp = np.array([5.0, 2.0, 2.0, np.nan, np.nan])\n        res = cat.sort_values(ascending=False, na_position='last')\n        self.assert_numpy_array_equal(res.__array__(), exp)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        cat = Categorical([\"a\", \"c\", \"b\", \"d\", np.nan], ordered=True)\n        res = cat.sort_values(ascending=False, na_position='last')\n        exp_val = np.array([\"d\", \"c\", \"b\", \"a\", np.nan], dtype=object)\n        exp_categories = Index([\"a\", \"b\", \"c\", \"d\"])\n        self.assert_numpy_array_equal(res.__array__(), exp_val)\n        self.assert_index_equal(res.categories, exp_categories)\n\n        cat = Categorical([\"a\", \"c\", \"b\", \"d\", np.nan], ordered=True)\n        res = cat.sort_values(ascending=False, na_position='first')\n        exp_val = np.array([np.nan, \"d\", \"c\", \"b\", \"a\"], dtype=object)\n        exp_categories = Index([\"a\", \"b\", \"c\", \"d\"])\n        self.assert_numpy_array_equal(res.__array__(), exp_val)\n        self.assert_index_equal(res.categories, exp_categories)\n\n    def test_slicing_directly(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\"])\n        sliced = cat[3]\n        self.assertEqual(sliced, \"d\")\n        sliced = cat[3:5]\n        expected = Categorical([\"d\", \"a\"], categories=['a', 'b', 'c', 'd'])\n        self.assert_numpy_array_equal(sliced._codes, expected._codes)\n        tm.assert_index_equal(sliced.categories, expected.categories)\n\n    def test_set_item_nan(self):\n        cat = pd.Categorical([1, 2, 3])\n        exp = pd.Categorical([1, np.nan, 3], categories=[1, 2, 3])\n        cat[1] = np.nan\n        tm.assert_categorical_equal(cat, exp)\n\n        # if nan in categories, the proper code should be set!\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.set_categories([1, 2, 3, np.nan], rename=True, inplace=True)\n        cat[1] = np.nan\n        exp = np.array([0, 3, 2, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(cat.codes, exp)\n\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.set_categories([1, 2, 3, np.nan], rename=True, inplace=True)\n        cat[1:3] = np.nan\n        exp = np.array([0, 3, 3, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(cat.codes, exp)\n\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.set_categories([1, 2, 3, np.nan], rename=True, inplace=True)\n        cat[1:3] = [np.nan, 1]\n        exp = np.array([0, 3, 0, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(cat.codes, exp)\n\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.set_categories([1, 2, 3, np.nan], rename=True, inplace=True)\n        cat[1:3] = [np.nan, np.nan]\n        exp = np.array([0, 3, 3, -1], dtype=np.int8)\n        self.assert_numpy_array_equal(cat.codes, exp)\n\n        cat = pd.Categorical([1, 2, np.nan, 3], categories=[1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.set_categories([1, 2, 3, np.nan], rename=True, inplace=True)\n        cat[pd.isnull(cat)] = np.nan\n        exp = np.array([0, 1, 3, 2], dtype=np.int8)\n        self.assert_numpy_array_equal(cat.codes, exp)\n\n    def test_shift(self):\n        # GH 9416\n        cat = pd.Categorical(['a', 'b', 'c', 'd', 'a'])\n\n        # shift forward\n        sp1 = cat.shift(1)\n        xp1 = pd.Categorical([np.nan, 'a', 'b', 'c', 'd'])\n        self.assert_categorical_equal(sp1, xp1)\n        self.assert_categorical_equal(cat[:-1], sp1[1:])\n\n        # shift back\n        sn2 = cat.shift(-2)\n        xp2 = pd.Categorical(['c', 'd', 'a', np.nan, np.nan],\n                             categories=['a', 'b', 'c', 'd'])\n        self.assert_categorical_equal(sn2, xp2)\n        self.assert_categorical_equal(cat[2:], sn2[:-2])\n\n        # shift by zero\n        self.assert_categorical_equal(cat, cat.shift(0))\n\n    def test_nbytes(self):\n        cat = pd.Categorical([1, 2, 3])\n        exp = cat._codes.nbytes + cat._categories.values.nbytes\n        self.assertEqual(cat.nbytes, exp)\n\n    def test_memory_usage(self):\n        cat = pd.Categorical([1, 2, 3])\n        self.assertEqual(cat.nbytes, cat.memory_usage())\n        self.assertEqual(cat.nbytes, cat.memory_usage(deep=True))\n\n        cat = pd.Categorical(['foo', 'foo', 'bar'])\n        self.assertEqual(cat.nbytes, cat.memory_usage())\n        self.assertTrue(cat.memory_usage(deep=True) > cat.nbytes)\n\n        # sys.getsizeof will call the .memory_usage with\n        # deep=True, and add on some GC overhead\n        diff = cat.memory_usage(deep=True) - sys.getsizeof(cat)\n        self.assertTrue(abs(diff) < 100)\n\n    def test_searchsorted(self):\n        # https://github.com/pydata/pandas/issues/8420\n        s1 = pd.Series(['apple', 'bread', 'bread', 'cheese', 'milk'])\n        s2 = pd.Series(['apple', 'bread', 'bread', 'cheese', 'milk', 'donuts'])\n        c1 = pd.Categorical(s1, ordered=True)\n        c2 = pd.Categorical(s2, ordered=True)\n\n        # Single item array\n        res = c1.searchsorted(['bread'])\n        chk = s1.searchsorted(['bread'])\n        exp = np.array([1], dtype=np.intp)\n        self.assert_numpy_array_equal(res, exp)\n        self.assert_numpy_array_equal(res, chk)\n\n        # Scalar version of single item array\n        # Categorical return np.array like pd.Series, but different from\n        # np.array.searchsorted()\n        res = c1.searchsorted('bread')\n        chk = s1.searchsorted('bread')\n        exp = np.array([1], dtype=np.intp)\n        self.assert_numpy_array_equal(res, exp)\n        self.assert_numpy_array_equal(res, chk)\n\n        # Searching for a value that is not present in the Categorical\n        res = c1.searchsorted(['bread', 'eggs'])\n        chk = s1.searchsorted(['bread', 'eggs'])\n        exp = np.array([1, 4], dtype=np.intp)\n        self.assert_numpy_array_equal(res, exp)\n        self.assert_numpy_array_equal(res, chk)\n\n        # Searching for a value that is not present, to the right\n        res = c1.searchsorted(['bread', 'eggs'], side='right')\n        chk = s1.searchsorted(['bread', 'eggs'], side='right')\n        exp = np.array([3, 4], dtype=np.intp)  # eggs before milk\n        self.assert_numpy_array_equal(res, exp)\n        self.assert_numpy_array_equal(res, chk)\n\n        # As above, but with a sorter array to reorder an unsorted array\n        res = c2.searchsorted(['bread', 'eggs'], side='right',\n                              sorter=[0, 1, 2, 3, 5, 4])\n        chk = s2.searchsorted(['bread', 'eggs'], side='right',\n                              sorter=[0, 1, 2, 3, 5, 4])\n        # eggs after donuts, after switching milk and donuts\n        exp = np.array([3, 5], dtype=np.intp)\n        self.assert_numpy_array_equal(res, exp)\n        self.assert_numpy_array_equal(res, chk)\n\n    def test_deprecated_labels(self):\n        # TODO: labels is deprecated and should be removed in 0.18 or 2017,\n        # whatever is earlier\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        exp = cat.codes\n        with tm.assert_produces_warning(FutureWarning):\n            res = cat.labels\n        self.assert_numpy_array_equal(res, exp)\n\n    def test_removed_names_produces_warning(self):\n\n        # 10482\n        with tm.assert_produces_warning(UserWarning):\n            Categorical([0, 1], name=\"a\")\n\n        with tm.assert_produces_warning(UserWarning):\n            Categorical.from_codes([1, 2], [\"a\", \"b\", \"c\"], name=\"a\")\n\n    def test_datetime_categorical_comparison(self):\n        dt_cat = pd.Categorical(\n            pd.date_range('2014-01-01', periods=3), ordered=True)\n        self.assert_numpy_array_equal(dt_cat > dt_cat[0],\n                                      np.array([False, True, True]))\n        self.assert_numpy_array_equal(dt_cat[0] < dt_cat,\n                                      np.array([False, True, True]))\n\n    def test_reflected_comparison_with_scalars(self):\n        # GH8658\n        cat = pd.Categorical([1, 2, 3], ordered=True)\n        self.assert_numpy_array_equal(cat > cat[0],\n                                      np.array([False, True, True]))\n        self.assert_numpy_array_equal(cat[0] < cat,\n                                      np.array([False, True, True]))\n\n    def test_comparison_with_unknown_scalars(self):\n        # https://github.com/pydata/pandas/issues/9836#issuecomment-92123057\n        # and following comparisons with scalars not in categories should raise\n        # for unequal comps, but not for equal/not equal\n        cat = pd.Categorical([1, 2, 3], ordered=True)\n\n        self.assertRaises(TypeError, lambda: cat < 4)\n        self.assertRaises(TypeError, lambda: cat > 4)\n        self.assertRaises(TypeError, lambda: 4 < cat)\n        self.assertRaises(TypeError, lambda: 4 > cat)\n\n        self.assert_numpy_array_equal(cat == 4,\n                                      np.array([False, False, False]))\n        self.assert_numpy_array_equal(cat != 4,\n                                      np.array([True, True, True]))\n\n    def test_map(self):\n        c = pd.Categorical(list('ABABC'), categories=list('CBA'),\n                           ordered=True)\n        result = c.map(lambda x: x.lower())\n        exp = pd.Categorical(list('ababc'), categories=list('cba'),\n                             ordered=True)\n        tm.assert_categorical_equal(result, exp)\n\n        c = pd.Categorical(list('ABABC'), categories=list('ABC'),\n                           ordered=False)\n        result = c.map(lambda x: x.lower())\n        exp = pd.Categorical(list('ababc'), categories=list('abc'),\n                             ordered=False)\n        tm.assert_categorical_equal(result, exp)\n\n        result = c.map(lambda x: 1)\n        tm.assert_numpy_array_equal(result, np.array([1] * 5, dtype=np.int64))\n\n\nclass TestCategoricalAsBlock(tm.TestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.factor = Categorical.from_array(['a', 'b', 'b', 'a', 'a', 'c',\n                                              'c', 'c'])\n\n        df = DataFrame({'value': np.random.randint(0, 10000, 100)})\n        labels = [\"{0} - {1}\".format(i, i + 499) for i in range(0, 10000, 500)]\n\n        df = df.sort_values(by=['value'], ascending=True)\n        df['value_group'] = pd.cut(df.value, range(0, 10500, 500), right=False,\n                                   labels=labels)\n        self.cat = df\n\n    def test_dtypes(self):\n\n        # GH8143\n        index = ['cat', 'obj', 'num']\n        cat = pd.Categorical(['a', 'b', 'c'])\n        obj = pd.Series(['a', 'b', 'c'])\n        num = pd.Series([1, 2, 3])\n        df = pd.concat([pd.Series(cat), obj, num], axis=1, keys=index)\n\n        result = df.dtypes == 'object'\n        expected = Series([False, True, False], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == 'int64'\n        expected = Series([False, False, True], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == 'category'\n        expected = Series([True, False, False], index=index)\n        tm.assert_series_equal(result, expected)\n\n    def test_codes_dtypes(self):\n\n        # GH 8453\n        result = Categorical(['foo', 'bar', 'baz'])\n        self.assertTrue(result.codes.dtype == 'int8')\n\n        result = Categorical(['foo%05d' % i for i in range(400)])\n        self.assertTrue(result.codes.dtype == 'int16')\n\n        result = Categorical(['foo%05d' % i for i in range(40000)])\n        self.assertTrue(result.codes.dtype == 'int32')\n\n        # adding cats\n        result = Categorical(['foo', 'bar', 'baz'])\n        self.assertTrue(result.codes.dtype == 'int8')\n        result = result.add_categories(['foo%05d' % i for i in range(400)])\n        self.assertTrue(result.codes.dtype == 'int16')\n\n        # removing cats\n        result = result.remove_categories(['foo%05d' % i for i in range(300)])\n        self.assertTrue(result.codes.dtype == 'int8')\n\n    def test_basic(self):\n\n        # test basic creation / coercion of categoricals\n        s = Series(self.factor, name='A')\n        self.assertEqual(s.dtype, 'category')\n        self.assertEqual(len(s), len(self.factor))\n        str(s.values)\n        str(s)\n\n        # in a frame\n        df = DataFrame({'A': self.factor})\n        result = df['A']\n        tm.assert_series_equal(result, s)\n        result = df.iloc[:, 0]\n        tm.assert_series_equal(result, s)\n        self.assertEqual(len(df), len(self.factor))\n        str(df.values)\n        str(df)\n\n        df = DataFrame({'A': s})\n        result = df['A']\n        tm.assert_series_equal(result, s)\n        self.assertEqual(len(df), len(self.factor))\n        str(df.values)\n        str(df)\n\n        # multiples\n        df = DataFrame({'A': s, 'B': s, 'C': 1})\n        result1 = df['A']\n        result2 = df['B']\n        tm.assert_series_equal(result1, s)\n        tm.assert_series_equal(result2, s, check_names=False)\n        self.assertEqual(result2.name, 'B')\n        self.assertEqual(len(df), len(self.factor))\n        str(df.values)\n        str(df)\n\n        # GH8623\n        x = pd.DataFrame([[1, 'John P. Doe'], [2, 'Jane Dove'],\n                          [1, 'John P. Doe']],\n                         columns=['person_id', 'person_name'])\n        x['person_name'] = pd.Categorical(x.person_name\n                                          )  # doing this breaks transform\n\n        expected = x.iloc[0].person_name\n        result = x.person_name.iloc[0]\n        self.assertEqual(result, expected)\n\n        result = x.person_name[0]\n        self.assertEqual(result, expected)\n\n        result = x.person_name.loc[0]\n        self.assertEqual(result, expected)\n\n    def test_creation_astype(self):\n        l = [\"a\", \"b\", \"c\", \"a\"]\n        s = pd.Series(l)\n        exp = pd.Series(Categorical(l))\n        res = s.astype('category')\n        tm.assert_series_equal(res, exp)\n\n        l = [1, 2, 3, 1]\n        s = pd.Series(l)\n        exp = pd.Series(Categorical(l))\n        res = s.astype('category')\n        tm.assert_series_equal(res, exp)\n\n        df = pd.DataFrame({\"cats\": [1, 2, 3, 4, 5, 6],\n                           \"vals\": [1, 2, 3, 4, 5, 6]})\n        cats = Categorical([1, 2, 3, 4, 5, 6])\n        exp_df = pd.DataFrame({\"cats\": cats, \"vals\": [1, 2, 3, 4, 5, 6]})\n        df[\"cats\"] = df[\"cats\"].astype(\"category\")\n        tm.assert_frame_equal(exp_df, df)\n\n        df = pd.DataFrame({\"cats\": ['a', 'b', 'b', 'a', 'a', 'd'],\n                           \"vals\": [1, 2, 3, 4, 5, 6]})\n        cats = Categorical(['a', 'b', 'b', 'a', 'a', 'd'])\n        exp_df = pd.DataFrame({\"cats\": cats, \"vals\": [1, 2, 3, 4, 5, 6]})\n        df[\"cats\"] = df[\"cats\"].astype(\"category\")\n        tm.assert_frame_equal(exp_df, df)\n\n        # with keywords\n        l = [\"a\", \"b\", \"c\", \"a\"]\n        s = pd.Series(l)\n        exp = pd.Series(Categorical(l, ordered=True))\n        res = s.astype('category', ordered=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = pd.Series(Categorical(\n            l, categories=list('abcdef'), ordered=True))\n        res = s.astype('category', categories=list('abcdef'), ordered=True)\n        tm.assert_series_equal(res, exp)\n\n    def test_construction_series(self):\n\n        l = [1, 2, 3, 1]\n        exp = Series(l).astype('category')\n        res = Series(l, dtype='category')\n        tm.assert_series_equal(res, exp)\n\n        l = [\"a\", \"b\", \"c\", \"a\"]\n        exp = Series(l).astype('category')\n        res = Series(l, dtype='category')\n        tm.assert_series_equal(res, exp)\n\n        # insert into frame with different index\n        # GH 8076\n        index = pd.date_range('20000101', periods=3)\n        expected = Series(Categorical(values=[np.nan, np.nan, np.nan],\n                                      categories=['a', 'b', 'c']))\n        expected.index = index\n\n        expected = DataFrame({'x': expected})\n        df = DataFrame(\n            {'x': Series(['a', 'b', 'c'], dtype='category')}, index=index)\n        tm.assert_frame_equal(df, expected)\n\n    def test_construction_frame(self):\n\n        # GH8626\n\n        # dict creation\n        df = DataFrame({'A': list('abc')}, dtype='category')\n        expected = Series(list('abc'), dtype='category', name='A')\n        tm.assert_series_equal(df['A'], expected)\n\n        # to_frame\n        s = Series(list('abc'), dtype='category')\n        result = s.to_frame()\n        expected = Series(list('abc'), dtype='category', name=0)\n        tm.assert_series_equal(result[0], expected)\n        result = s.to_frame(name='foo')\n        expected = Series(list('abc'), dtype='category', name='foo')\n        tm.assert_series_equal(result['foo'], expected)\n\n        # list-like creation\n        df = DataFrame(list('abc'), dtype='category')\n        expected = Series(list('abc'), dtype='category', name=0)\n        tm.assert_series_equal(df[0], expected)\n\n        # ndim != 1\n        df = DataFrame([pd.Categorical(list('abc'))])\n        expected = DataFrame({0: Series(list('abc'), dtype='category')})\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame([pd.Categorical(list('abc')), pd.Categorical(list(\n            'abd'))])\n        expected = DataFrame({0: Series(list('abc'), dtype='category'),\n                              1: Series(list('abd'), dtype='category')},\n                             columns=[0, 1])\n        tm.assert_frame_equal(df, expected)\n\n        # mixed\n        df = DataFrame([pd.Categorical(list('abc')), list('def')])\n        expected = DataFrame({0: Series(list('abc'), dtype='category'),\n                              1: list('def')}, columns=[0, 1])\n        tm.assert_frame_equal(df, expected)\n\n        # invalid (shape)\n        self.assertRaises(\n            ValueError,\n            lambda: DataFrame([pd.Categorical(list('abc')),\n                               pd.Categorical(list('abdefg'))]))\n\n        # ndim > 1\n        self.assertRaises(NotImplementedError,\n                          lambda: pd.Categorical(np.array([list('abcd')])))\n\n    def test_reshaping(self):\n\n        p = tm.makePanel()\n        p['str'] = 'foo'\n        df = p.to_frame()\n        df['category'] = df['str'].astype('category')\n        result = df['category'].unstack()\n\n        c = Categorical(['foo'] * len(p.major_axis))\n        expected = DataFrame({'A': c.copy(),\n                              'B': c.copy(),\n                              'C': c.copy(),\n                              'D': c.copy()},\n                             columns=Index(list('ABCD'), name='minor'),\n                             index=p.major_axis.set_names('major'))\n        tm.assert_frame_equal(result, expected)\n\n    def test_reindex(self):\n\n        index = pd.date_range('20000101', periods=3)\n\n        # reindexing to an invalid Categorical\n        s = Series(['a', 'b', 'c'], dtype='category')\n        result = s.reindex(index)\n        expected = Series(Categorical(values=[np.nan, np.nan, np.nan],\n                                      categories=['a', 'b', 'c']))\n        expected.index = index\n        tm.assert_series_equal(result, expected)\n\n        # partial reindexing\n        expected = Series(Categorical(values=['b', 'c'], categories=['a', 'b',\n                                                                     'c']))\n        expected.index = [1, 2]\n        result = s.reindex([1, 2])\n        tm.assert_series_equal(result, expected)\n\n        expected = Series(Categorical(\n            values=['c', np.nan], categories=['a', 'b', 'c']))\n        expected.index = [2, 3]\n        result = s.reindex([2, 3])\n        tm.assert_series_equal(result, expected)\n\n    def test_sideeffects_free(self):\n        # Passing a categorical to a Series and then changing values in either\n        # the series or the categorical should not change the values in the\n        # other one, IF you specify copy!\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        s = pd.Series(cat, copy=True)\n        self.assertFalse(s.cat is cat)\n        s.cat.categories = [1, 2, 3]\n        exp_s = np.array([1, 2, 3, 1], dtype=np.int64)\n        exp_cat = np.array([\"a\", \"b\", \"c\", \"a\"], dtype=np.object_)\n        self.assert_numpy_array_equal(s.__array__(), exp_s)\n        self.assert_numpy_array_equal(cat.__array__(), exp_cat)\n\n        # setting\n        s[0] = 2\n        exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(s.__array__(), exp_s2)\n        self.assert_numpy_array_equal(cat.__array__(), exp_cat)\n\n        # however, copy is False by default\n        # so this WILL change values\n        cat = Categorical([\"a\", \"b\", \"c\", \"a\"])\n        s = pd.Series(cat)\n        self.assertTrue(s.values is cat)\n        s.cat.categories = [1, 2, 3]\n        exp_s = np.array([1, 2, 3, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(s.__array__(), exp_s)\n        self.assert_numpy_array_equal(cat.__array__(), exp_s)\n\n        s[0] = 2\n        exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(s.__array__(), exp_s2)\n        self.assert_numpy_array_equal(cat.__array__(), exp_s2)\n\n    def test_nan_handling(self):\n\n        # Nans are represented as -1 in labels\n        s = Series(Categorical([\"a\", \"b\", np.nan, \"a\"]))\n        self.assert_index_equal(s.cat.categories, Index([\"a\", \"b\"]))\n        self.assert_numpy_array_equal(s.values.codes,\n                                      np.array([0, 1, -1, 0], dtype=np.int8))\n\n        # If categories have nan included, the label should point to that\n        # instead\n        with tm.assert_produces_warning(FutureWarning):\n            s2 = Series(Categorical([\"a\", \"b\", np.nan, \"a\"],\n                                    categories=[\"a\", \"b\", np.nan]))\n\n        exp_cat = Index([\"a\", \"b\", np.nan])\n        self.assert_index_equal(s2.cat.categories, exp_cat)\n        self.assert_numpy_array_equal(s2.values.codes,\n                                      np.array([0, 1, 2, 0], dtype=np.int8))\n\n        # Changing categories should also make the replaced category np.nan\n        s3 = Series(Categorical([\"a\", \"b\", \"c\", \"a\"]))\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            s3.cat.categories = [\"a\", \"b\", np.nan]\n\n        exp_cat = Index([\"a\", \"b\", np.nan])\n        self.assert_index_equal(s3.cat.categories, exp_cat)\n        self.assert_numpy_array_equal(s3.values.codes,\n                                      np.array([0, 1, 2, 0], dtype=np.int8))\n\n    def test_cat_accessor(self):\n        s = Series(Categorical([\"a\", \"b\", np.nan, \"a\"]))\n        self.assert_index_equal(s.cat.categories, Index([\"a\", \"b\"]))\n        self.assertEqual(s.cat.ordered, False)\n        exp = Categorical([\"a\", \"b\", np.nan, \"a\"], categories=[\"b\", \"a\"])\n        s.cat.set_categories([\"b\", \"a\"], inplace=True)\n        tm.assert_categorical_equal(s.values, exp)\n\n        res = s.cat.set_categories([\"b\", \"a\"])\n        tm.assert_categorical_equal(res.values, exp)\n\n        exp = Categorical([\"a\", \"b\", np.nan, \"a\"], categories=[\"b\", \"a\"])\n        s[:] = \"a\"\n        s = s.cat.remove_unused_categories()\n        self.assert_index_equal(s.cat.categories, Index([\"a\"]))\n\n    def test_sequence_like(self):\n\n        # GH 7839\n        # make sure can iterate\n        df = DataFrame({\"id\": [1, 2, 3, 4, 5, 6],\n                        \"raw_grade\": ['a', 'b', 'b', 'a', 'a', 'e']})\n        df['grade'] = Categorical(df['raw_grade'])\n\n        # basic sequencing testing\n        result = list(df.grade.values)\n        expected = np.array(df.grade.values).tolist()\n        tm.assert_almost_equal(result, expected)\n\n        # iteration\n        for t in df.itertuples(index=False):\n            str(t)\n\n        for row, s in df.iterrows():\n            str(s)\n\n        for c, col in df.iteritems():\n            str(s)\n\n    def test_series_delegations(self):\n\n        # invalid accessor\n        self.assertRaises(AttributeError, lambda: Series([1, 2, 3]).cat)\n        tm.assertRaisesRegexp(\n            AttributeError,\n            r\"Can only use .cat accessor with a 'category' dtype\",\n            lambda: Series([1, 2, 3]).cat)\n        self.assertRaises(AttributeError, lambda: Series(['a', 'b', 'c']).cat)\n        self.assertRaises(AttributeError, lambda: Series(np.arange(5.)).cat)\n        self.assertRaises(AttributeError,\n                          lambda: Series([Timestamp('20130101')]).cat)\n\n        # Series should delegate calls to '.categories', '.codes', '.ordered'\n        # and the methods '.set_categories()' 'drop_unused_categories()' to the\n        # categorical\n        s = Series(Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True))\n        exp_categories = Index([\"a\", \"b\", \"c\"])\n        tm.assert_index_equal(s.cat.categories, exp_categories)\n        s.cat.categories = [1, 2, 3]\n        exp_categories = Index([1, 2, 3])\n        self.assert_index_equal(s.cat.categories, exp_categories)\n\n        exp_codes = Series([0, 1, 2, 0], dtype='int8')\n        tm.assert_series_equal(s.cat.codes, exp_codes)\n\n        self.assertEqual(s.cat.ordered, True)\n        s = s.cat.as_unordered()\n        self.assertEqual(s.cat.ordered, False)\n        s.cat.as_ordered(inplace=True)\n        self.assertEqual(s.cat.ordered, True)\n\n        # reorder\n        s = Series(Categorical([\"a\", \"b\", \"c\", \"a\"], ordered=True))\n        exp_categories = Index([\"c\", \"b\", \"a\"])\n        exp_values = np.array([\"a\", \"b\", \"c\", \"a\"], dtype=np.object_)\n        s = s.cat.set_categories([\"c\", \"b\", \"a\"])\n        tm.assert_index_equal(s.cat.categories, exp_categories)\n        self.assert_numpy_array_equal(s.values.__array__(), exp_values)\n        self.assert_numpy_array_equal(s.__array__(), exp_values)\n\n        # remove unused categories\n        s = Series(Categorical([\"a\", \"b\", \"b\", \"a\"], categories=[\"a\", \"b\", \"c\"\n                                                                 ]))\n        exp_categories = Index([\"a\", \"b\"])\n        exp_values = np.array([\"a\", \"b\", \"b\", \"a\"], dtype=np.object_)\n        s = s.cat.remove_unused_categories()\n        self.assert_index_equal(s.cat.categories, exp_categories)\n        self.assert_numpy_array_equal(s.values.__array__(), exp_values)\n        self.assert_numpy_array_equal(s.__array__(), exp_values)\n\n        # This method is likely to be confused, so test that it raises an error\n        # on wrong inputs:\n        def f():\n            s.set_categories([4, 3, 2, 1])\n\n        self.assertRaises(Exception, f)\n        # right: s.cat.set_categories([4,3,2,1])\n\n    def test_series_functions_no_warnings(self):\n        df = pd.DataFrame({'value': np.random.randint(0, 100, 20)})\n        labels = [\"{0} - {1}\".format(i, i + 9) for i in range(0, 100, 10)]\n        with tm.assert_produces_warning(False):\n            df['group'] = pd.cut(df.value, range(0, 105, 10), right=False,\n                                 labels=labels)\n\n    def test_assignment_to_dataframe(self):\n        # assignment\n        df = DataFrame({'value': np.array(\n            np.random.randint(0, 10000, 100), dtype='int32')})\n        labels = [\"{0} - {1}\".format(i, i + 499) for i in range(0, 10000, 500)]\n\n        df = df.sort_values(by=['value'], ascending=True)\n        s = pd.cut(df.value, range(0, 10500, 500), right=False, labels=labels)\n        d = s.values\n        df['D'] = d\n        str(df)\n\n        result = df.dtypes\n        expected = Series(\n            [np.dtype('int32'), CategoricalDtype()], index=['value', 'D'])\n        tm.assert_series_equal(result, expected)\n\n        df['E'] = s\n        str(df)\n\n        result = df.dtypes\n        expected = Series([np.dtype('int32'), CategoricalDtype(),\n                           CategoricalDtype()],\n                          index=['value', 'D', 'E'])\n        tm.assert_series_equal(result, expected)\n\n        result1 = df['D']\n        result2 = df['E']\n        self.assert_categorical_equal(result1._data._block.values, d)\n\n        # sorting\n        s.name = 'E'\n        self.assert_series_equal(result2.sort_index(), s.sort_index())\n\n        cat = pd.Categorical([1, 2, 3, 10], categories=[1, 2, 3, 4, 10])\n        df = pd.DataFrame(pd.Series(cat))\n\n    def test_describe(self):\n\n        # Categoricals should not show up together with numerical columns\n        result = self.cat.describe()\n        self.assertEqual(len(result.columns), 1)\n\n        # In a frame, describe() for the cat should be the same as for string\n        # arrays (count, unique, top, freq)\n\n        cat = Categorical([\"a\", \"b\", \"b\", \"b\"], categories=['a', 'b', 'c'],\n                          ordered=True)\n        s = Series(cat)\n        result = s.describe()\n        expected = Series([4, 2, \"b\", 3],\n                          index=['count', 'unique', 'top', 'freq'])\n        tm.assert_series_equal(result, expected)\n\n        cat = pd.Series(pd.Categorical([\"a\", \"b\", \"c\", \"c\"]))\n        df3 = pd.DataFrame({\"cat\": cat, \"s\": [\"a\", \"b\", \"c\", \"c\"]})\n        res = df3.describe()\n        self.assert_numpy_array_equal(res[\"cat\"].values, res[\"s\"].values)\n\n    def test_repr(self):\n        a = pd.Series(pd.Categorical([1, 2, 3, 4]))\n        exp = u(\"0    1\\n1    2\\n2    3\\n3    4\\n\" +\n                \"dtype: category\\nCategories (4, int64): [1, 2, 3, 4]\")\n\n        self.assertEqual(exp, a.__unicode__())\n\n        a = pd.Series(pd.Categorical([\"a\", \"b\"] * 25))\n        exp = u(\"0     a\\n1     b\\n\" + \"     ..\\n\" + \"48    a\\n49    b\\n\" +\n                \"dtype: category\\nCategories (2, object): [a, b]\")\n        with option_context(\"display.max_rows\", 5):\n            self.assertEqual(exp, repr(a))\n\n        levs = list(\"abcdefghijklmnopqrstuvwxyz\")\n        a = pd.Series(pd.Categorical(\n            [\"a\", \"b\"], categories=levs, ordered=True))\n        exp = u(\"0    a\\n1    b\\n\" + \"dtype: category\\n\"\n                \"Categories (26, object): [a < b < c < d ... w < x < y < z]\")\n        self.assertEqual(exp, a.__unicode__())\n\n    def test_categorical_repr(self):\n        c = pd.Categorical([1, 2, 3])\n        exp = \"\"\"[1, 2, 3]\nCategories (3, int64): [1, 2, 3]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical([1, 2, 3, 1, 2, 3], categories=[1, 2, 3])\n        exp = \"\"\"[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1, 2, 3]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical([1, 2, 3, 4, 5] * 10)\n        exp = \"\"\"[1, 2, 3, 4, 5, ..., 1, 2, 3, 4, 5]\nLength: 50\nCategories (5, int64): [1, 2, 3, 4, 5]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(np.arange(20))\n        exp = \"\"\"[0, 1, 2, 3, 4, ..., 15, 16, 17, 18, 19]\nLength: 20\nCategories (20, int64): [0, 1, 2, 3, ..., 16, 17, 18, 19]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_ordered(self):\n        c = pd.Categorical([1, 2, 3], ordered=True)\n        exp = \"\"\"[1, 2, 3]\nCategories (3, int64): [1 < 2 < 3]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical([1, 2, 3, 1, 2, 3], categories=[1, 2, 3],\n                           ordered=True)\n        exp = \"\"\"[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1 < 2 < 3]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical([1, 2, 3, 4, 5] * 10, ordered=True)\n        exp = \"\"\"[1, 2, 3, 4, 5, ..., 1, 2, 3, 4, 5]\nLength: 50\nCategories (5, int64): [1 < 2 < 3 < 4 < 5]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(np.arange(20), ordered=True)\n        exp = \"\"\"[0, 1, 2, 3, 4, ..., 15, 16, 17, 18, 19]\nLength: 20\nCategories (20, int64): [0 < 1 < 2 < 3 ... 16 < 17 < 18 < 19]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_datetime(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        c = pd.Categorical(idx)\n\n        # TODO(wesm): exceeding 80 characters in the console is not good\n        # behavior\n        exp = (\n            \"[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, \"\n            \"2011-01-01 12:00:00, 2011-01-01 13:00:00]\\n\"\n            \"Categories (5, datetime64[ns]): [2011-01-01 09:00:00, \"\n            \"2011-01-01 10:00:00, 2011-01-01 11:00:00,\\n\"\n            \"                                 2011-01-01 12:00:00, \"\n            \"2011-01-01 13:00:00]\"\"\")\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = (\n            \"[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, \"\n            \"2011-01-01 12:00:00, 2011-01-01 13:00:00, 2011-01-01 09:00:00, \"\n            \"2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, \"\n            \"2011-01-01 13:00:00]\\n\"\n            \"Categories (5, datetime64[ns]): [2011-01-01 09:00:00, \"\n            \"2011-01-01 10:00:00, 2011-01-01 11:00:00,\\n\"\n            \"                                 2011-01-01 12:00:00, \"\n            \"2011-01-01 13:00:00]\")\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        c = pd.Categorical(idx)\n        exp = (\n            \"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, \"\n            \"2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, \"\n            \"2011-01-01 13:00:00-05:00]\\n\"\n            \"Categories (5, datetime64[ns, US/Eastern]): \"\n            \"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00,\\n\"\n            \"                                             \"\n            \"2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00,\\n\"\n            \"                                             \"\n            \"2011-01-01 13:00:00-05:00]\")\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = (\n            \"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, \"\n            \"2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, \"\n            \"2011-01-01 13:00:00-05:00, 2011-01-01 09:00:00-05:00, \"\n            \"2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, \"\n            \"2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00]\\n\"\n            \"Categories (5, datetime64[ns, US/Eastern]): \"\n            \"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00,\\n\"\n            \"                                             \"\n            \"2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00,\\n\"\n            \"                                             \"\n            \"2011-01-01 13:00:00-05:00]\")\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_datetime_ordered(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, 2011-01-01 13:00:00]\nCategories (5, datetime64[ns]): [2011-01-01 09:00:00 < 2011-01-01 10:00:00 < 2011-01-01 11:00:00 <\n                                 2011-01-01 12:00:00 < 2011-01-01 13:00:00]\"\"\"  # noqa\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, 2011-01-01 13:00:00, 2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, 2011-01-01 13:00:00]\nCategories (5, datetime64[ns]): [2011-01-01 09:00:00 < 2011-01-01 10:00:00 < 2011-01-01 11:00:00 <\n                                 2011-01-01 12:00:00 < 2011-01-01 13:00:00]\"\"\"  # noqa\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00]\nCategories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00 < 2011-01-01 10:00:00-05:00 <\n                                             2011-01-01 11:00:00-05:00 < 2011-01-01 12:00:00-05:00 <\n                                             2011-01-01 13:00:00-05:00]\"\"\"  # noqa\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00, 2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00]\nCategories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00 < 2011-01-01 10:00:00-05:00 <\n                                             2011-01-01 11:00:00-05:00 < 2011-01-01 12:00:00-05:00 <\n                                             2011-01-01 13:00:00-05:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_period(self):\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        c = pd.Categorical(idx)\n        exp = \"\"\"[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00]\nCategories (5, period[H]): [2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00,\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = \"\"\"[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00, 2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00]\nCategories (5, period[H]): [2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00,\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        c = pd.Categorical(idx)\n        exp = \"\"\"[2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\nCategories (5, period[M]): [2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = \"\"\"[2011-01, 2011-02, 2011-03, 2011-04, 2011-05, 2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\nCategories (5, period[M]): [2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_period_ordered(self):\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00]\nCategories (5, period[H]): [2011-01-01 09:00 < 2011-01-01 10:00 < 2011-01-01 11:00 < 2011-01-01 12:00 <\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00, 2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00]\nCategories (5, period[H]): [2011-01-01 09:00 < 2011-01-01 10:00 < 2011-01-01 11:00 < 2011-01-01 12:00 <\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\nCategories (5, period[M]): [2011-01 < 2011-02 < 2011-03 < 2011-04 < 2011-05]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[2011-01, 2011-02, 2011-03, 2011-04, 2011-05, 2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\nCategories (5, period[M]): [2011-01 < 2011-02 < 2011-03 < 2011-04 < 2011-05]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_timedelta(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        c = pd.Categorical(idx)\n        exp = \"\"\"[1 days, 2 days, 3 days, 4 days, 5 days]\nCategories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = \"\"\"[1 days, 2 days, 3 days, 4 days, 5 days, 1 days, 2 days, 3 days, 4 days, 5 days]\nCategories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=20)\n        c = pd.Categorical(idx)\n        exp = \"\"\"[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, ..., 15 days 01:00:00, 16 days 01:00:00, 17 days 01:00:00, 18 days 01:00:00, 19 days 01:00:00]\nLength: 20\nCategories (20, timedelta64[ns]): [0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00,\n                                   3 days 01:00:00, ..., 16 days 01:00:00, 17 days 01:00:00,\n                                   18 days 01:00:00, 19 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx)\n        exp = \"\"\"[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, ..., 15 days 01:00:00, 16 days 01:00:00, 17 days 01:00:00, 18 days 01:00:00, 19 days 01:00:00]\nLength: 40\nCategories (20, timedelta64[ns]): [0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00,\n                                   3 days 01:00:00, ..., 16 days 01:00:00, 17 days 01:00:00,\n                                   18 days 01:00:00, 19 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_repr_timedelta_ordered(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[1 days, 2 days, 3 days, 4 days, 5 days]\nCategories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[1 days, 2 days, 3 days, 4 days, 5 days, 1 days, 2 days, 3 days, 4 days, 5 days]\nCategories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=20)\n        c = pd.Categorical(idx, ordered=True)\n        exp = \"\"\"[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, ..., 15 days 01:00:00, 16 days 01:00:00, 17 days 01:00:00, 18 days 01:00:00, 19 days 01:00:00]\nLength: 20\nCategories (20, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01:00:00 <\n                                   3 days 01:00:00 ... 16 days 01:00:00 < 17 days 01:00:00 <\n                                   18 days 01:00:00 < 19 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n        c = pd.Categorical(idx.append(idx), categories=idx, ordered=True)\n        exp = \"\"\"[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, ..., 15 days 01:00:00, 16 days 01:00:00, 17 days 01:00:00, 18 days 01:00:00, 19 days 01:00:00]\nLength: 40\nCategories (20, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01:00:00 <\n                                   3 days 01:00:00 ... 16 days 01:00:00 < 17 days 01:00:00 <\n                                   18 days 01:00:00 < 19 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(c), exp)\n\n    def test_categorical_series_repr(self):\n        s = pd.Series(pd.Categorical([1, 2, 3]))\n        exp = \"\"\"0    1\n1    2\n2    3\ndtype: category\nCategories (3, int64): [1, 2, 3]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        s = pd.Series(pd.Categorical(np.arange(10)))\n        exp = \"\"\"0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: category\nCategories (10, int64): [0, 1, 2, 3, ..., 6, 7, 8, 9]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_ordered(self):\n        s = pd.Series(pd.Categorical([1, 2, 3], ordered=True))\n        exp = \"\"\"0    1\n1    2\n2    3\ndtype: category\nCategories (3, int64): [1 < 2 < 3]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        s = pd.Series(pd.Categorical(np.arange(10), ordered=True))\n        exp = \"\"\"0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: category\nCategories (10, int64): [0 < 1 < 2 < 3 ... 6 < 7 < 8 < 9]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_datetime(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   2011-01-01 09:00:00\n1   2011-01-01 10:00:00\n2   2011-01-01 11:00:00\n3   2011-01-01 12:00:00\n4   2011-01-01 13:00:00\ndtype: category\nCategories (5, datetime64[ns]): [2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00,\n                                 2011-01-01 12:00:00, 2011-01-01 13:00:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   2011-01-01 09:00:00-05:00\n1   2011-01-01 10:00:00-05:00\n2   2011-01-01 11:00:00-05:00\n3   2011-01-01 12:00:00-05:00\n4   2011-01-01 13:00:00-05:00\ndtype: category\nCategories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00,\n                                             2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00,\n                                             2011-01-01 13:00:00-05:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_datetime_ordered(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   2011-01-01 09:00:00\n1   2011-01-01 10:00:00\n2   2011-01-01 11:00:00\n3   2011-01-01 12:00:00\n4   2011-01-01 13:00:00\ndtype: category\nCategories (5, datetime64[ns]): [2011-01-01 09:00:00 < 2011-01-01 10:00:00 < 2011-01-01 11:00:00 <\n                                 2011-01-01 12:00:00 < 2011-01-01 13:00:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   2011-01-01 09:00:00-05:00\n1   2011-01-01 10:00:00-05:00\n2   2011-01-01 11:00:00-05:00\n3   2011-01-01 12:00:00-05:00\n4   2011-01-01 13:00:00-05:00\ndtype: category\nCategories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00 < 2011-01-01 10:00:00-05:00 <\n                                             2011-01-01 11:00:00-05:00 < 2011-01-01 12:00:00-05:00 <\n                                             2011-01-01 13:00:00-05:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_period(self):\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   2011-01-01 09:00\n1   2011-01-01 10:00\n2   2011-01-01 11:00\n3   2011-01-01 12:00\n4   2011-01-01 13:00\ndtype: category\nCategories (5, period[H]): [2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00,\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   2011-01\n1   2011-02\n2   2011-03\n3   2011-04\n4   2011-05\ndtype: category\nCategories (5, period[M]): [2011-01, 2011-02, 2011-03, 2011-04, 2011-05]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_period_ordered(self):\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   2011-01-01 09:00\n1   2011-01-01 10:00\n2   2011-01-01 11:00\n3   2011-01-01 12:00\n4   2011-01-01 13:00\ndtype: category\nCategories (5, period[H]): [2011-01-01 09:00 < 2011-01-01 10:00 < 2011-01-01 11:00 < 2011-01-01 12:00 <\n                            2011-01-01 13:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   2011-01\n1   2011-02\n2   2011-03\n3   2011-04\n4   2011-05\ndtype: category\nCategories (5, period[M]): [2011-01 < 2011-02 < 2011-03 < 2011-04 < 2011-05]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_timedelta(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   1 days\n1   2 days\n2   3 days\n3   4 days\n4   5 days\ndtype: category\nCategories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=10)\n        s = pd.Series(pd.Categorical(idx))\n        exp = \"\"\"0   0 days 01:00:00\n1   1 days 01:00:00\n2   2 days 01:00:00\n3   3 days 01:00:00\n4   4 days 01:00:00\n5   5 days 01:00:00\n6   6 days 01:00:00\n7   7 days 01:00:00\n8   8 days 01:00:00\n9   9 days 01:00:00\ndtype: category\nCategories (10, timedelta64[ns]): [0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00,\n                                   3 days 01:00:00, ..., 6 days 01:00:00, 7 days 01:00:00,\n                                   8 days 01:00:00, 9 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_series_repr_timedelta_ordered(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   1 days\n1   2 days\n2   3 days\n3   4 days\n4   5 days\ndtype: category\nCategories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=10)\n        s = pd.Series(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"0   0 days 01:00:00\n1   1 days 01:00:00\n2   2 days 01:00:00\n3   3 days 01:00:00\n4   4 days 01:00:00\n5   5 days 01:00:00\n6   6 days 01:00:00\n7   7 days 01:00:00\n8   8 days 01:00:00\n9   9 days 01:00:00\ndtype: category\nCategories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01:00:00 <\n                                   3 days 01:00:00 ... 6 days 01:00:00 < 7 days 01:00:00 <\n                                   8 days 01:00:00 < 9 days 01:00:00]\"\"\"\n\n        self.assertEqual(repr(s), exp)\n\n    def test_categorical_index_repr(self):\n        idx = pd.CategoricalIndex(pd.Categorical([1, 2, 3]))\n        exp = \"\"\"CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(idx), exp)\n\n        i = pd.CategoricalIndex(pd.Categorical(np.arange(10)))\n        exp = \"\"\"CategoricalIndex([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], categories=[0, 1, 2, 3, 4, 5, 6, 7, ...], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_ordered(self):\n        i = pd.CategoricalIndex(pd.Categorical([1, 2, 3], ordered=True))\n        exp = \"\"\"CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        i = pd.CategoricalIndex(pd.Categorical(np.arange(10), ordered=True))\n        exp = \"\"\"CategoricalIndex([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], categories=[0, 1, 2, 3, 4, 5, 6, 7, ...], ordered=True, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_datetime(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00:00', '2011-01-01 10:00:00',\n                  '2011-01-01 11:00:00', '2011-01-01 12:00:00',\n                  '2011-01-01 13:00:00'],\n                 categories=[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, 2011-01-01 13:00:00], ordered=False, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00:00-05:00', '2011-01-01 10:00:00-05:00',\n                  '2011-01-01 11:00:00-05:00', '2011-01-01 12:00:00-05:00',\n                  '2011-01-01 13:00:00-05:00'],\n                 categories=[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00], ordered=False, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_datetime_ordered(self):\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00:00', '2011-01-01 10:00:00',\n                  '2011-01-01 11:00:00', '2011-01-01 12:00:00',\n                  '2011-01-01 13:00:00'],\n                 categories=[2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00, 2011-01-01 12:00:00, 2011-01-01 13:00:00], ordered=True, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                            tz='US/Eastern')\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00:00-05:00', '2011-01-01 10:00:00-05:00',\n                  '2011-01-01 11:00:00-05:00', '2011-01-01 12:00:00-05:00',\n                  '2011-01-01 13:00:00-05:00'],\n                 categories=[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00], ordered=True, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        i = pd.CategoricalIndex(pd.Categorical(idx.append(idx), ordered=True))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00:00-05:00', '2011-01-01 10:00:00-05:00',\n                  '2011-01-01 11:00:00-05:00', '2011-01-01 12:00:00-05:00',\n                  '2011-01-01 13:00:00-05:00', '2011-01-01 09:00:00-05:00',\n                  '2011-01-01 10:00:00-05:00', '2011-01-01 11:00:00-05:00',\n                  '2011-01-01 12:00:00-05:00', '2011-01-01 13:00:00-05:00'],\n                 categories=[2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00, 2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00, 2011-01-01 13:00:00-05:00], ordered=True, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_period(self):\n        # test all length\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=1)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00'], categories=[2011-01-01 09:00], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=2)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00', '2011-01-01 10:00'], categories=[2011-01-01 09:00, 2011-01-01 10:00], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=3)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00', '2011-01-01 10:00', '2011-01-01 11:00'], categories=[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00', '2011-01-01 10:00', '2011-01-01 11:00',\n                  '2011-01-01 12:00', '2011-01-01 13:00'],\n                 categories=[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00], ordered=False, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        i = pd.CategoricalIndex(pd.Categorical(idx.append(idx)))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00', '2011-01-01 10:00', '2011-01-01 11:00',\n                  '2011-01-01 12:00', '2011-01-01 13:00', '2011-01-01 09:00',\n                  '2011-01-01 10:00', '2011-01-01 11:00', '2011-01-01 12:00',\n                  '2011-01-01 13:00'],\n                 categories=[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00], ordered=False, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['2011-01', '2011-02', '2011-03', '2011-04', '2011-05'], categories=[2011-01, 2011-02, 2011-03, 2011-04, 2011-05], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_period_ordered(self):\n        idx = pd.period_range('2011-01-01 09:00', freq='H', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['2011-01-01 09:00', '2011-01-01 10:00', '2011-01-01 11:00',\n                  '2011-01-01 12:00', '2011-01-01 13:00'],\n                 categories=[2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00, 2011-01-01 13:00], ordered=True, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.period_range('2011-01', freq='M', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['2011-01', '2011-02', '2011-03', '2011-04', '2011-05'], categories=[2011-01, 2011-02, 2011-03, 2011-04, 2011-05], ordered=True, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_timedelta(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], categories=[1 days 00:00:00, 2 days 00:00:00, 3 days 00:00:00, 4 days 00:00:00, 5 days 00:00:00], ordered=False, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=10)\n        i = pd.CategoricalIndex(pd.Categorical(idx))\n        exp = \"\"\"CategoricalIndex(['0 days 01:00:00', '1 days 01:00:00', '2 days 01:00:00',\n                  '3 days 01:00:00', '4 days 01:00:00', '5 days 01:00:00',\n                  '6 days 01:00:00', '7 days 01:00:00', '8 days 01:00:00',\n                  '9 days 01:00:00'],\n                 categories=[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, 5 days 01:00:00, 6 days 01:00:00, 7 days 01:00:00, ...], ordered=False, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_index_repr_timedelta_ordered(self):\n        idx = pd.timedelta_range('1 days', periods=5)\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], categories=[1 days 00:00:00, 2 days 00:00:00, 3 days 00:00:00, 4 days 00:00:00, 5 days 00:00:00], ordered=True, dtype='category')\"\"\"\n        self.assertEqual(repr(i), exp)\n\n        idx = pd.timedelta_range('1 hours', periods=10)\n        i = pd.CategoricalIndex(pd.Categorical(idx, ordered=True))\n        exp = \"\"\"CategoricalIndex(['0 days 01:00:00', '1 days 01:00:00', '2 days 01:00:00',\n                  '3 days 01:00:00', '4 days 01:00:00', '5 days 01:00:00',\n                  '6 days 01:00:00', '7 days 01:00:00', '8 days 01:00:00',\n                  '9 days 01:00:00'],\n                 categories=[0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00, 3 days 01:00:00, 4 days 01:00:00, 5 days 01:00:00, 6 days 01:00:00, 7 days 01:00:00, ...], ordered=True, dtype='category')\"\"\"\n\n        self.assertEqual(repr(i), exp)\n\n    def test_categorical_frame(self):\n        # normal DataFrame\n        dt = pd.date_range('2011-01-01 09:00', freq='H', periods=5,\n                           tz='US/Eastern')\n        p = pd.period_range('2011-01', freq='M', periods=5)\n        df = pd.DataFrame({'dt': dt, 'p': p})\n        exp = \"\"\"                         dt       p\n0 2011-01-01 09:00:00-05:00 2011-01\n1 2011-01-01 10:00:00-05:00 2011-02\n2 2011-01-01 11:00:00-05:00 2011-03\n3 2011-01-01 12:00:00-05:00 2011-04\n4 2011-01-01 13:00:00-05:00 2011-05\"\"\"\n\n        df = pd.DataFrame({'dt': pd.Categorical(dt), 'p': pd.Categorical(p)})\n        self.assertEqual(repr(df), exp)\n\n    def test_info(self):\n\n        # make sure it works\n        n = 2500\n        df = DataFrame({'int64': np.random.randint(100, size=n)})\n        df['category'] = Series(np.array(list('abcdefghij')).take(\n            np.random.randint(0, 10, size=n))).astype('category')\n        df.isnull()\n        df.info()\n\n        df2 = df[df['category'] == 'd']\n        df2.info()\n\n    def test_groupby_sort(self):\n\n        # http://stackoverflow.com/questions/23814368/sorting-pandas-categorical-labels-after-groupby\n        # This should result in a properly sorted Series so that the plot\n        # has a sorted x axis\n        # self.cat.groupby(['value_group'])['value_group'].count().plot(kind='bar')\n\n        res = self.cat.groupby(['value_group'])['value_group'].count()\n        exp = res[sorted(res.index, key=lambda x: float(x.split()[0]))]\n        exp.index = pd.CategoricalIndex(exp.index, name=exp.index.name)\n        tm.assert_series_equal(res, exp)\n\n    def test_min_max(self):\n        # unordered cats have no min/max\n        cat = Series(Categorical([\"a\", \"b\", \"c\", \"d\"], ordered=False))\n        self.assertRaises(TypeError, lambda: cat.min())\n        self.assertRaises(TypeError, lambda: cat.max())\n\n        cat = Series(Categorical([\"a\", \"b\", \"c\", \"d\"], ordered=True))\n        _min = cat.min()\n        _max = cat.max()\n        self.assertEqual(_min, \"a\")\n        self.assertEqual(_max, \"d\")\n\n        cat = Series(Categorical([\"a\", \"b\", \"c\", \"d\"], categories=[\n                     'd', 'c', 'b', 'a'], ordered=True))\n        _min = cat.min()\n        _max = cat.max()\n        self.assertEqual(_min, \"d\")\n        self.assertEqual(_max, \"a\")\n\n        cat = Series(Categorical(\n            [np.nan, \"b\", \"c\", np.nan], categories=['d', 'c', 'b', 'a'\n                                                    ], ordered=True))\n        _min = cat.min()\n        _max = cat.max()\n        self.assertTrue(np.isnan(_min))\n        self.assertEqual(_max, \"b\")\n\n        cat = Series(Categorical(\n            [np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1], ordered=True))\n        _min = cat.min()\n        _max = cat.max()\n        self.assertTrue(np.isnan(_min))\n        self.assertEqual(_max, 1)\n\n    def test_mode(self):\n        s = Series(Categorical([1, 1, 2, 4, 5, 5, 5],\n                               categories=[5, 4, 3, 2, 1], ordered=True))\n        res = s.mode()\n        exp = Series(Categorical([5], categories=[\n                     5, 4, 3, 2, 1], ordered=True))\n        tm.assert_series_equal(res, exp)\n        s = Series(Categorical([1, 1, 1, 4, 5, 5, 5],\n                               categories=[5, 4, 3, 2, 1], ordered=True))\n        res = s.mode()\n        exp = Series(Categorical([5, 1], categories=[\n                     5, 4, 3, 2, 1], ordered=True))\n        tm.assert_series_equal(res, exp)\n        s = Series(Categorical([1, 2, 3, 4, 5], categories=[5, 4, 3, 2, 1],\n                               ordered=True))\n        res = s.mode()\n        exp = Series(Categorical([], categories=[5, 4, 3, 2, 1], ordered=True))\n        tm.assert_series_equal(res, exp)\n\n    def test_value_counts(self):\n        # GH 12835\n        cats = pd.Categorical([\"a\", \"b\", \"c\", \"c\", \"c\", \"b\"],\n                              categories=[\"c\", \"a\", \"b\", \"d\"])\n        s = pd.Series(cats, name='xxx')\n        res = s.value_counts(sort=False)\n\n        exp_index = pd.CategoricalIndex([\"c\", \"a\", \"b\", \"d\"],\n                                        categories=cats.categories)\n        exp = Series([3, 1, 2, 0], name='xxx', index=exp_index)\n        tm.assert_series_equal(res, exp)\n\n        res = s.value_counts(sort=True)\n\n        exp_index = pd.CategoricalIndex([\"c\", \"b\", \"a\", \"d\"],\n                                        categories=cats.categories)\n        exp = Series([3, 2, 1, 0], name='xxx', index=exp_index)\n        tm.assert_series_equal(res, exp)\n\n        # check object dtype handles the Series.name as the same\n        # (tested in test_base.py)\n        s = pd.Series([\"a\", \"b\", \"c\", \"c\", \"c\", \"b\"], name='xxx')\n        res = s.value_counts()\n        exp = Series([3, 2, 1], name='xxx', index=[\"c\", \"b\", \"a\"])\n        tm.assert_series_equal(res, exp)\n\n    def test_value_counts_with_nan(self):\n        # see gh-9443\n\n        # sanity check\n        s = pd.Series([\"a\", \"b\", \"a\"], dtype=\"category\")\n        exp = pd.Series([2, 1], index=pd.CategoricalIndex([\"a\", \"b\"]))\n\n        res = s.value_counts(dropna=True)\n        tm.assert_series_equal(res, exp)\n\n        res = s.value_counts(dropna=True)\n        tm.assert_series_equal(res, exp)\n\n        # same Series via two different constructions --> same behaviour\n        series = [\n            pd.Series([\"a\", \"b\", None, \"a\", None, None], dtype=\"category\"),\n            pd.Series(pd.Categorical([\"a\", \"b\", None, \"a\", None, None],\n                                     categories=[\"a\", \"b\"]))\n        ]\n\n        for s in series:\n            # None is a NaN value, so we exclude its count here\n            exp = pd.Series([2, 1], index=pd.CategoricalIndex([\"a\", \"b\"]))\n            res = s.value_counts(dropna=True)\n            tm.assert_series_equal(res, exp)\n\n            # we don't exclude the count of None and sort by counts\n            exp = pd.Series([3, 2, 1], index=pd.CategoricalIndex([np.nan, \"a\", \"b\"]))\n            res = s.value_counts(dropna=False)\n            tm.assert_series_equal(res, exp)\n\n            # When we aren't sorting by counts, and np.nan isn't a\n            # category, it should be last.\n            exp = pd.Series([2, 1, 3], index=pd.CategoricalIndex([\"a\", \"b\", np.nan]))\n            res = s.value_counts(dropna=False, sort=False)\n            tm.assert_series_equal(res, exp)\n\n    def test_groupby(self):\n\n        cats = Categorical([\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"],\n                           categories=[\"a\", \"b\", \"c\", \"d\"], ordered=True)\n        data = DataFrame({\"a\": [1, 1, 1, 2, 2, 2, 3, 4, 5], \"b\": cats})\n\n        exp_index = pd.CategoricalIndex(['a', 'b', 'c', 'd'], name='b',\n                                        ordered=True)\n        expected = DataFrame({'a': [1, 2, 4, np.nan]}, index=exp_index)\n        result = data.groupby(\"b\").mean()\n        tm.assert_frame_equal(result, expected)\n\n        raw_cat1 = Categorical([\"a\", \"a\", \"b\", \"b\"],\n                               categories=[\"a\", \"b\", \"z\"], ordered=True)\n        raw_cat2 = Categorical([\"c\", \"d\", \"c\", \"d\"],\n                               categories=[\"c\", \"d\", \"y\"], ordered=True)\n        df = DataFrame({\"A\": raw_cat1, \"B\": raw_cat2, \"values\": [1, 2, 3, 4]})\n\n        # single grouper\n        gb = df.groupby(\"A\")\n        exp_idx = pd.CategoricalIndex(['a', 'b', 'z'], name='A', ordered=True)\n        expected = DataFrame({'values': Series([3, 7, np.nan], index=exp_idx)})\n        result = gb.sum()\n        tm.assert_frame_equal(result, expected)\n\n        # multiple groupers\n        gb = df.groupby(['A', 'B'])\n        exp_index = pd.MultiIndex.from_product([['a', 'b', 'z'],\n                                                ['c', 'd', 'y']],\n                                               names=['A', 'B'])\n        expected = DataFrame({'values': [1, 2, np.nan, 3, 4, np.nan,\n                                         np.nan, np.nan, np.nan]},\n                             index=exp_index)\n        result = gb.sum()\n        tm.assert_frame_equal(result, expected)\n\n        # multiple groupers with a non-cat\n        df = df.copy()\n        df['C'] = ['foo', 'bar'] * 2\n        gb = df.groupby(['A', 'B', 'C'])\n        expected = DataFrame({'values': Series(\n            np.nan, index=pd.MultiIndex.from_product(\n                [['a', 'b', 'z'], ['c', 'd', 'y'], ['foo', 'bar']\n                 ], names=['A', 'B', 'C']))}).sortlevel()\n        expected.iloc[[1, 2, 7, 8], 0] = [1, 2, 3, 4]\n        result = gb.sum()\n        tm.assert_frame_equal(result, expected)\n\n        # GH 8623\n        x = pd.DataFrame([[1, 'John P. Doe'], [2, 'Jane Dove'],\n                          [1, 'John P. Doe']],\n                         columns=['person_id', 'person_name'])\n        x['person_name'] = pd.Categorical(x.person_name)\n\n        g = x.groupby(['person_id'])\n        result = g.transform(lambda x: x)\n        tm.assert_frame_equal(result, x[['person_name']])\n\n        result = x.drop_duplicates('person_name')\n        expected = x.iloc[[0, 1]]\n        tm.assert_frame_equal(result, expected)\n\n        def f(x):\n            return x.drop_duplicates('person_name').iloc[0]\n\n        result = g.apply(f)\n        expected = x.iloc[[0, 1]].copy()\n        expected.index = Index([1, 2], name='person_id')\n        expected['person_name'] = expected['person_name'].astype('object')\n        tm.assert_frame_equal(result, expected)\n\n        # GH 9921\n        # Monotonic\n        df = DataFrame({\"a\": [5, 15, 25]})\n        c = pd.cut(df.a, bins=[0, 10, 20, 30, 40])\n\n        result = df.a.groupby(c).transform(sum)\n        tm.assert_series_equal(result, df['a'])\n\n        tm.assert_series_equal(\n            df.a.groupby(c).transform(lambda xs: np.sum(xs)), df['a'])\n        tm.assert_frame_equal(df.groupby(c).transform(sum), df[['a']])\n        tm.assert_frame_equal(\n            df.groupby(c).transform(lambda xs: np.max(xs)), df[['a']])\n\n        # Filter\n        tm.assert_series_equal(df.a.groupby(c).filter(np.all), df['a'])\n        tm.assert_frame_equal(df.groupby(c).filter(np.all), df)\n\n        # Non-monotonic\n        df = DataFrame({\"a\": [5, 15, 25, -5]})\n        c = pd.cut(df.a, bins=[-10, 0, 10, 20, 30, 40])\n\n        result = df.a.groupby(c).transform(sum)\n        tm.assert_series_equal(result, df['a'])\n\n        tm.assert_series_equal(\n            df.a.groupby(c).transform(lambda xs: np.sum(xs)), df['a'])\n        tm.assert_frame_equal(df.groupby(c).transform(sum), df[['a']])\n        tm.assert_frame_equal(\n            df.groupby(c).transform(lambda xs: np.sum(xs)), df[['a']])\n\n        # GH 9603\n        df = pd.DataFrame({'a': [1, 0, 0, 0]})\n        c = pd.cut(df.a, [0, 1, 2, 3, 4])\n        result = df.groupby(c).apply(len)\n\n        exp_index = pd.CategoricalIndex(c.values.categories,\n                                        ordered=c.values.ordered)\n        expected = pd.Series([1, 0, 0, 0], index=exp_index)\n        expected.index.name = 'a'\n        tm.assert_series_equal(result, expected)\n\n    def test_pivot_table(self):\n\n        raw_cat1 = Categorical([\"a\", \"a\", \"b\", \"b\"],\n                               categories=[\"a\", \"b\", \"z\"], ordered=True)\n        raw_cat2 = Categorical([\"c\", \"d\", \"c\", \"d\"],\n                               categories=[\"c\", \"d\", \"y\"], ordered=True)\n        df = DataFrame({\"A\": raw_cat1, \"B\": raw_cat2, \"values\": [1, 2, 3, 4]})\n        result = pd.pivot_table(df, values='values', index=['A', 'B'])\n\n        expected = Series([1, 2, np.nan, 3, 4, np.nan, np.nan, np.nan, np.nan],\n                          index=pd.MultiIndex.from_product(\n                              [['a', 'b', 'z'], ['c', 'd', 'y']],\n                              names=['A', 'B']),\n                          name='values')\n        tm.assert_series_equal(result, expected)\n\n    def test_count(self):\n\n        s = Series(Categorical([np.nan, 1, 2, np.nan],\n                               categories=[5, 4, 3, 2, 1], ordered=True))\n        result = s.count()\n        self.assertEqual(result, 2)\n\n    def test_sort_values(self):\n\n        c = Categorical([\"a\", \"b\", \"b\", \"a\"], ordered=False)\n        cat = Series(c.copy())\n\n        # 'order' was deprecated in gh-10726\n        # 'sort' was deprecated in gh-12882\n        for func in ('order', 'sort'):\n            with tm.assert_produces_warning(FutureWarning):\n                getattr(c, func)()\n\n        # sort in the categories order\n        expected = Series(\n            Categorical([\"a\", \"a\", \"b\", \"b\"],\n                        ordered=False), index=[0, 3, 1, 2])\n        result = cat.sort_values()\n        tm.assert_series_equal(result, expected)\n\n        cat = Series(Categorical([\"a\", \"c\", \"b\", \"d\"], ordered=True))\n        res = cat.sort_values()\n        exp = np.array([\"a\", \"b\", \"c\", \"d\"], dtype=np.object_)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n\n        cat = Series(Categorical([\"a\", \"c\", \"b\", \"d\"], categories=[\n                     \"a\", \"b\", \"c\", \"d\"], ordered=True))\n        res = cat.sort_values()\n        exp = np.array([\"a\", \"b\", \"c\", \"d\"], dtype=np.object_)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n\n        res = cat.sort_values(ascending=False)\n        exp = np.array([\"d\", \"c\", \"b\", \"a\"], dtype=np.object_)\n        self.assert_numpy_array_equal(res.__array__(), exp)\n\n        raw_cat1 = Categorical([\"a\", \"b\", \"c\", \"d\"],\n                               categories=[\"a\", \"b\", \"c\", \"d\"], ordered=False)\n        raw_cat2 = Categorical([\"a\", \"b\", \"c\", \"d\"],\n                               categories=[\"d\", \"c\", \"b\", \"a\"], ordered=True)\n        s = [\"a\", \"b\", \"c\", \"d\"]\n        df = DataFrame({\"unsort\": raw_cat1,\n                        \"sort\": raw_cat2,\n                        \"string\": s,\n                        \"values\": [1, 2, 3, 4]})\n\n        # Cats must be sorted in a dataframe\n        res = df.sort_values(by=[\"string\"], ascending=False)\n        exp = np.array([\"d\", \"c\", \"b\", \"a\"], dtype=np.object_)\n        self.assert_numpy_array_equal(res[\"sort\"].values.__array__(), exp)\n        self.assertEqual(res[\"sort\"].dtype, \"category\")\n\n        res = df.sort_values(by=[\"sort\"], ascending=False)\n        exp = df.sort_values(by=[\"string\"], ascending=True)\n        self.assert_series_equal(res[\"values\"], exp[\"values\"])\n        self.assertEqual(res[\"sort\"].dtype, \"category\")\n        self.assertEqual(res[\"unsort\"].dtype, \"category\")\n\n        # unordered cat, but we allow this\n        df.sort_values(by=[\"unsort\"], ascending=False)\n\n        # multi-columns sort\n        # GH 7848\n        df = DataFrame({\"id\": [6, 5, 4, 3, 2, 1],\n                        \"raw_grade\": ['a', 'b', 'b', 'a', 'a', 'e']})\n        df[\"grade\"] = pd.Categorical(df[\"raw_grade\"], ordered=True)\n        df['grade'] = df['grade'].cat.set_categories(['b', 'e', 'a'])\n\n        # sorts 'grade' according to the order of the categories\n        result = df.sort_values(by=['grade'])\n        expected = df.iloc[[1, 2, 5, 0, 3, 4]]\n        tm.assert_frame_equal(result, expected)\n\n        # multi\n        result = df.sort_values(by=['grade', 'id'])\n        expected = df.iloc[[2, 1, 5, 4, 3, 0]]\n        tm.assert_frame_equal(result, expected)\n\n    def test_slicing(self):\n        cat = Series(Categorical([1, 2, 3, 4]))\n        reversed = cat[::-1]\n        exp = np.array([4, 3, 2, 1], dtype=np.int64)\n        self.assert_numpy_array_equal(reversed.__array__(), exp)\n\n        df = DataFrame({'value': (np.arange(100) + 1).astype('int64')})\n        df['D'] = pd.cut(df.value, bins=[0, 25, 50, 75, 100])\n\n        expected = Series([11, '(0, 25]'], index=['value', 'D'], name=10)\n        result = df.iloc[10]\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame({'value': np.arange(11, 21).astype('int64')},\n                             index=np.arange(10, 20).astype('int64'))\n        expected['D'] = pd.cut(expected.value, bins=[0, 25, 50, 75, 100])\n        result = df.iloc[10:20]\n        tm.assert_frame_equal(result, expected)\n\n        expected = Series([9, '(0, 25]'], index=['value', 'D'], name=8)\n        result = df.loc[8]\n        tm.assert_series_equal(result, expected)\n\n    def test_slicing_and_getting_ops(self):\n\n        # systematically test the slicing operations:\n        #  for all slicing ops:\n        #   - returning a dataframe\n        #   - returning a column\n        #   - returning a row\n        #   - returning a single value\n\n        cats = pd.Categorical(\n            [\"a\", \"c\", \"b\", \"c\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 3, 4, 5, 6, 7]\n        df = pd.DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        cats2 = pd.Categorical([\"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx2 = pd.Index([\"j\", \"k\"])\n        values2 = [3, 4]\n\n        # 2:4,: | \"j\":\"k\",:\n        exp_df = pd.DataFrame({\"cats\": cats2, \"values\": values2}, index=idx2)\n\n        # :,\"cats\" | :,0\n        exp_col = pd.Series(cats, index=idx, name='cats')\n\n        # \"j\",: | 2,:\n        exp_row = pd.Series([\"b\", 3], index=[\"cats\", \"values\"], dtype=\"object\",\n                            name=\"j\")\n\n        # \"j\",\"cats | 2,0\n        exp_val = \"b\"\n\n        # iloc\n        # frame\n        res_df = df.iloc[2:4, :]\n        tm.assert_frame_equal(res_df, exp_df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        # row\n        res_row = df.iloc[2, :]\n        tm.assert_series_equal(res_row, exp_row)\n        tm.assertIsInstance(res_row[\"cats\"], compat.string_types)\n\n        # col\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        self.assertTrue(is_categorical_dtype(res_col))\n\n        # single value\n        res_val = df.iloc[2, 0]\n        self.assertEqual(res_val, exp_val)\n\n        # loc\n        # frame\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        tm.assertIsInstance(res_row[\"cats\"], compat.string_types)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        self.assertTrue(is_categorical_dtype(res_col))\n\n        # single value\n        res_val = df.loc[\"j\", \"cats\"]\n        self.assertEqual(res_val, exp_val)\n\n        # ix\n        # frame\n        # res_df = df.ix[\"j\":\"k\",[0,1]] # doesn't work?\n        res_df = df.ix[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        # row\n        res_row = df.ix[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        tm.assertIsInstance(res_row[\"cats\"], compat.string_types)\n\n        # col\n        res_col = df.ix[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        self.assertTrue(is_categorical_dtype(res_col))\n\n        # single value\n        res_val = df.ix[\"j\", 0]\n        self.assertEqual(res_val, exp_val)\n\n        # iat\n        res_val = df.iat[2, 0]\n        self.assertEqual(res_val, exp_val)\n\n        # at\n        res_val = df.at[\"j\", \"cats\"]\n        self.assertEqual(res_val, exp_val)\n\n        # fancy indexing\n        exp_fancy = df.iloc[[2]]\n\n        res_fancy = df[df[\"cats\"] == \"b\"]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n        res_fancy = df[df[\"values\"] == 3]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n\n        # get_value\n        res_val = df.get_value(\"j\", \"cats\")\n        self.assertEqual(res_val, exp_val)\n\n        # i : int, slice, or sequence of integers\n        res_row = df.iloc[2]\n        tm.assert_series_equal(res_row, exp_row)\n        tm.assertIsInstance(res_row[\"cats\"], compat.string_types)\n\n        res_df = df.iloc[slice(2, 4)]\n        tm.assert_frame_equal(res_df, exp_df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        res_df = df.iloc[[2, 3]]\n        tm.assert_frame_equal(res_df, exp_df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        self.assertTrue(is_categorical_dtype(res_col))\n\n        res_df = df.iloc[:, slice(0, 2)]\n        tm.assert_frame_equal(res_df, df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n        res_df = df.iloc[:, [0, 1]]\n        tm.assert_frame_equal(res_df, df)\n        self.assertTrue(is_categorical_dtype(res_df[\"cats\"]))\n\n    def test_slicing_doc_examples(self):\n\n        # GH 7918\n        cats = Categorical(\n            [\"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", ])\n        values = [1, 2, 2, 2, 3, 4, 5]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        result = df.iloc[2:4, :]\n        expected = DataFrame(\n            {\"cats\": Categorical(\n                ['b', 'b'], categories=['a', 'b', 'c']),\n             \"values\": [2, 2]}, index=['j', 'k'])\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[2:4, :].dtypes\n        expected = Series(['category', 'int64'], ['cats', 'values'])\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", \"cats\"]\n        expected = Series(Categorical(['a', 'b', 'b'],\n                                      categories=['a', 'b', 'c']),\n                          index=['h', 'i', 'j'], name='cats')\n        tm.assert_series_equal(result, expected)\n\n        result = df.ix[\"h\":\"j\", 0:1]\n        expected = DataFrame({'cats': Series(\n            Categorical(\n                ['a', 'b', 'b'], categories=['a', 'b', 'c']), index=['h', 'i',\n                                                                     'j'])})\n        tm.assert_frame_equal(result, expected)\n\n    def test_assigning_ops(self):\n        # systematically test the assigning operations:\n        # for all slicing ops:\n        #  for value in categories and value not in categories:\n\n        #   - assign a single value -> exp_single_cats_value\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n\n        # assign multiple rows (mixed values) (-> array) -> exp_multi_row\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n\n        cats = pd.Categorical([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n                              categories=[\"a\", \"b\"])\n        idx = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 1, 1, 1, 1, 1, 1]\n        orig = pd.DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        # changed single row\n        cats1 = pd.Categorical([\"a\", \"a\", \"b\", \"a\", \"a\", \"a\", \"a\"],\n                               categories=[\"a\", \"b\"])\n        idx1 = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values1 = [1, 1, 2, 1, 1, 1, 1]\n        exp_single_row = pd.DataFrame({\"cats\": cats1,\n                                       \"values\": values1}, index=idx1)\n\n        # changed multiple rows\n        cats2 = pd.Categorical([\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"a\"],\n                               categories=[\"a\", \"b\"])\n        idx2 = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values2 = [1, 1, 2, 2, 1, 1, 1]\n        exp_multi_row = pd.DataFrame({\"cats\": cats2,\n                                      \"values\": values2}, index=idx2)\n\n        # changed part of the cats column\n        cats3 = pd.Categorical(\n            [\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx3 = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values3 = [1, 1, 1, 1, 1, 1, 1]\n        exp_parts_cats_col = pd.DataFrame(\n            {\"cats\": cats3,\n             \"values\": values3}, index=idx3)\n\n        # changed single value in cats col\n        cats4 = pd.Categorical(\n            [\"a\", \"a\", \"b\", \"a\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx4 = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values4 = [1, 1, 1, 1, 1, 1, 1]\n        exp_single_cats_value = pd.DataFrame(\n            {\"cats\": cats4,\n             \"values\": values4}, index=idx4)\n\n        #  iloc\n        # ###############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.iloc[2, 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.iloc[df.index == \"j\", 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        def f():\n            df = orig.copy()\n            df.iloc[2, 0] = \"c\"\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.iloc[2, :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        def f():\n            df = orig.copy()\n            df.iloc[2, :] = [\"c\", 2]\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.iloc[2:4, :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        def f():\n            df = orig.copy()\n            df.iloc[2:4, :] = [[\"c\", 2], [\"c\", 2]]\n\n        self.assertRaises(ValueError, f)\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.iloc[2:4, 0] = pd.Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.iloc[2:4, 0] = pd.Categorical(\n                [\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n\n        with tm.assertRaises(ValueError):\n            # different values\n            df = orig.copy()\n            df.iloc[2:4, 0] = pd.Categorical(\n                [\"c\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.iloc[2:4, 0] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            df.iloc[2:4, 0] = [\"c\", \"c\"]\n\n        #  loc\n        # ##############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.loc[\"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.loc[df.index == \"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        def f():\n            df = orig.copy()\n            df.loc[\"j\", \"cats\"] = \"c\"\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.loc[\"j\", :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        def f():\n            df = orig.copy()\n            df.loc[\"j\", :] = [\"c\", 2]\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.loc[\"j\":\"k\", :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        def f():\n            df = orig.copy()\n            df.loc[\"j\":\"k\", :] = [[\"c\", 2], [\"c\", 2]]\n\n        self.assertRaises(ValueError, f)\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", \"cats\"] = pd.Categorical(\n            [\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.loc[\"j\":\"k\", \"cats\"] = pd.Categorical(\n                [\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n\n        with tm.assertRaises(ValueError):\n            # different values\n            df = orig.copy()\n            df.loc[\"j\":\"k\", \"cats\"] = pd.Categorical(\n                [\"c\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", \"cats\"] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            df.loc[\"j\":\"k\", \"cats\"] = [\"c\", \"c\"]\n\n        #  ix\n        # ##############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.ix[\"j\", 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.ix[df.index == \"j\", 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        def f():\n            df = orig.copy()\n            df.ix[\"j\", 0] = \"c\"\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.ix[\"j\", :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        def f():\n            df = orig.copy()\n            df.ix[\"j\", :] = [\"c\", 2]\n\n        self.assertRaises(ValueError, f)\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.ix[\"j\":\"k\", :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        def f():\n            df = orig.copy()\n            df.ix[\"j\":\"k\", :] = [[\"c\", 2], [\"c\", 2]]\n\n        self.assertRaises(ValueError, f)\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.ix[\"j\":\"k\", 0] = pd.Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.ix[\"j\":\"k\", 0] = pd.Categorical(\n                [\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n\n        with tm.assertRaises(ValueError):\n            # different values\n            df = orig.copy()\n            df.ix[\"j\":\"k\", 0] = pd.Categorical(\n                [\"c\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.ix[\"j\":\"k\", 0] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with tm.assertRaises(ValueError):\n            df.ix[\"j\":\"k\", 0] = [\"c\", \"c\"]\n\n        # iat\n        df = orig.copy()\n        df.iat[2, 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        def f():\n            df = orig.copy()\n            df.iat[2, 0] = \"c\"\n\n        self.assertRaises(ValueError, f)\n\n        # at\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.at[\"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        def f():\n            df = orig.copy()\n            df.at[\"j\", \"cats\"] = \"c\"\n\n        self.assertRaises(ValueError, f)\n\n        # fancy indexing\n        catsf = pd.Categorical(\n            [\"a\", \"a\", \"c\", \"c\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\", \"c\"])\n        idxf = pd.Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        valuesf = [1, 1, 3, 3, 1, 1, 1]\n        df = pd.DataFrame({\"cats\": catsf, \"values\": valuesf}, index=idxf)\n\n        exp_fancy = exp_multi_row.copy()\n        exp_fancy[\"cats\"].cat.set_categories([\"a\", \"b\", \"c\"], inplace=True)\n\n        df[df[\"cats\"] == \"c\"] = [\"b\", 2]\n        # category c is kept in .categories\n        tm.assert_frame_equal(df, exp_fancy)\n\n        # set_value\n        df = orig.copy()\n        df.set_value(\"j\", \"cats\", \"b\")\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        def f():\n            df = orig.copy()\n            df.set_value(\"j\", \"cats\", \"c\")\n\n        self.assertRaises(ValueError, f)\n\n        # Assigning a Category to parts of a int/... column uses the values of\n        # the Catgorical\n        df = pd.DataFrame({\"a\": [1, 1, 1, 1, 1],\n                           \"b\": [\"a\", \"a\", \"a\", \"a\", \"a\"]})\n        exp = pd.DataFrame({\"a\": [1, \"b\", \"b\", 1, 1],\n                            \"b\": [\"a\", \"a\", \"b\", \"b\", \"a\"]})\n        df.loc[1:2, \"a\"] = pd.Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        df.loc[2:3, \"b\"] = pd.Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp)\n\n        # Series\n        orig = Series(pd.Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"]))\n        s = orig.copy()\n        s[:] = \"a\"\n        exp = Series(pd.Categorical([\"a\", \"a\"], categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(s, exp)\n\n        s = orig.copy()\n        s[1] = \"a\"\n        exp = Series(pd.Categorical([\"b\", \"a\"], categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(s, exp)\n\n        s = orig.copy()\n        s[s.index > 0] = \"a\"\n        exp = Series(pd.Categorical([\"b\", \"a\"], categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(s, exp)\n\n        s = orig.copy()\n        s[[False, True]] = \"a\"\n        exp = Series(pd.Categorical([\"b\", \"a\"], categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(s, exp)\n\n        s = orig.copy()\n        s.index = [\"x\", \"y\"]\n        s[\"y\"] = \"a\"\n        exp = Series(\n            pd.Categorical([\"b\", \"a\"],\n                           categories=[\"a\", \"b\"]), index=[\"x\", \"y\"])\n        tm.assert_series_equal(s, exp)\n\n        # ensure that one can set something to np.nan\n        s = Series(Categorical([1, 2, 3]))\n        exp = Series(Categorical([1, np.nan, 3], categories=[1, 2, 3]))\n        s[1] = np.nan\n        tm.assert_series_equal(s, exp)\n\n    def test_comparisons(self):\n        tests_data = [(list(\"abc\"), list(\"cba\"), list(\"bbb\")),\n                      ([1, 2, 3], [3, 2, 1], [2, 2, 2])]\n        for data, reverse, base in tests_data:\n            cat_rev = pd.Series(pd.Categorical(data, categories=reverse,\n                                               ordered=True))\n            cat_rev_base = pd.Series(pd.Categorical(base, categories=reverse,\n                                                    ordered=True))\n            cat = pd.Series(pd.Categorical(data, ordered=True))\n            cat_base = pd.Series(pd.Categorical(\n                base, categories=cat.cat.categories, ordered=True))\n            s = Series(base)\n            a = np.array(base)\n\n            # comparisons need to take categories ordering into account\n            res_rev = cat_rev > cat_rev_base\n            exp_rev = Series([True, False, False])\n            tm.assert_series_equal(res_rev, exp_rev)\n\n            res_rev = cat_rev < cat_rev_base\n            exp_rev = Series([False, False, True])\n            tm.assert_series_equal(res_rev, exp_rev)\n\n            res = cat > cat_base\n            exp = Series([False, False, True])\n            tm.assert_series_equal(res, exp)\n\n            scalar = base[1]\n            res = cat > scalar\n            exp = Series([False, False, True])\n            exp2 = cat.values > scalar\n            tm.assert_series_equal(res, exp)\n            tm.assert_numpy_array_equal(res.values, exp2)\n            res_rev = cat_rev > scalar\n            exp_rev = Series([True, False, False])\n            exp_rev2 = cat_rev.values > scalar\n            tm.assert_series_equal(res_rev, exp_rev)\n            tm.assert_numpy_array_equal(res_rev.values, exp_rev2)\n\n            # Only categories with same categories can be compared\n            def f():\n                cat > cat_rev\n\n            self.assertRaises(TypeError, f)\n\n            # categorical cannot be compared to Series or numpy array, and also\n            # not the other way around\n            self.assertRaises(TypeError, lambda: cat > s)\n            self.assertRaises(TypeError, lambda: cat_rev > s)\n            self.assertRaises(TypeError, lambda: cat > a)\n            self.assertRaises(TypeError, lambda: cat_rev > a)\n\n            self.assertRaises(TypeError, lambda: s < cat)\n            self.assertRaises(TypeError, lambda: s < cat_rev)\n\n            self.assertRaises(TypeError, lambda: a < cat)\n            self.assertRaises(TypeError, lambda: a < cat_rev)\n\n        # unequal comparison should raise for unordered cats\n        cat = Series(Categorical(list(\"abc\")))\n\n        def f():\n            cat > \"b\"\n\n        self.assertRaises(TypeError, f)\n        cat = Series(Categorical(list(\"abc\"), ordered=False))\n\n        def f():\n            cat > \"b\"\n\n        self.assertRaises(TypeError, f)\n\n        # https://github.com/pydata/pandas/issues/9836#issuecomment-92123057\n        # and following comparisons with scalars not in categories should raise\n        # for unequal comps, but not for equal/not equal\n        cat = Series(Categorical(list(\"abc\"), ordered=True))\n\n        self.assertRaises(TypeError, lambda: cat < \"d\")\n        self.assertRaises(TypeError, lambda: cat > \"d\")\n        self.assertRaises(TypeError, lambda: \"d\" < cat)\n        self.assertRaises(TypeError, lambda: \"d\" > cat)\n\n        self.assert_series_equal(cat == \"d\", Series([False, False, False]))\n        self.assert_series_equal(cat != \"d\", Series([True, True, True]))\n\n        # And test NaN handling...\n        cat = Series(Categorical([\"a\", \"b\", \"c\", np.nan]))\n        exp = Series([True, True, True, False])\n        res = (cat == cat)\n        tm.assert_series_equal(res, exp)\n\n    def test_cat_equality(self):\n\n        # GH 8938\n        # allow equality comparisons\n        a = Series(list('abc'), dtype=\"category\")\n        b = Series(list('abc'), dtype=\"object\")\n        c = Series(['a', 'b', 'cc'], dtype=\"object\")\n        d = Series(list('acb'), dtype=\"object\")\n        e = Categorical(list('abc'))\n        f = Categorical(list('acb'))\n\n        # vs scalar\n        self.assertFalse((a == 'a').all())\n        self.assertTrue(((a != 'a') == ~(a == 'a')).all())\n\n        self.assertFalse(('a' == a).all())\n        self.assertTrue((a == 'a')[0])\n        self.assertTrue(('a' == a)[0])\n        self.assertFalse(('a' != a)[0])\n\n        # vs list-like\n        self.assertTrue((a == a).all())\n        self.assertFalse((a != a).all())\n\n        self.assertTrue((a == list(a)).all())\n        self.assertTrue((a == b).all())\n        self.assertTrue((b == a).all())\n        self.assertTrue(((~(a == b)) == (a != b)).all())\n        self.assertTrue(((~(b == a)) == (b != a)).all())\n\n        self.assertFalse((a == c).all())\n        self.assertFalse((c == a).all())\n        self.assertFalse((a == d).all())\n        self.assertFalse((d == a).all())\n\n        # vs a cat-like\n        self.assertTrue((a == e).all())\n        self.assertTrue((e == a).all())\n        self.assertFalse((a == f).all())\n        self.assertFalse((f == a).all())\n\n        self.assertTrue(((~(a == e) == (a != e)).all()))\n        self.assertTrue(((~(e == a) == (e != a)).all()))\n        self.assertTrue(((~(a == f) == (a != f)).all()))\n        self.assertTrue(((~(f == a) == (f != a)).all()))\n\n        # non-equality is not comparable\n        self.assertRaises(TypeError, lambda: a < b)\n        self.assertRaises(TypeError, lambda: b < a)\n        self.assertRaises(TypeError, lambda: a > b)\n        self.assertRaises(TypeError, lambda: b > a)\n\n    def test_concat(self):\n        cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals = [1, 2]\n        df = pd.DataFrame({\"cats\": cat, \"vals\": vals})\n        cat2 = pd.Categorical([\"a\", \"b\", \"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals2 = [1, 2, 1, 2]\n        exp = pd.DataFrame({\"cats\": cat2,\n                            \"vals\": vals2}, index=pd.Index([0, 1, 0, 1]))\n\n        res = pd.concat([df, df])\n        tm.assert_frame_equal(exp, res)\n\n        # Concat should raise if the two categoricals do not have the same\n        # categories\n        cat3 = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n        vals3 = [1, 2]\n        df_wrong_categories = pd.DataFrame({\"cats\": cat3, \"vals\": vals3})\n\n        def f():\n            pd.concat([df, df_wrong_categories])\n\n        self.assertRaises(ValueError, f)\n\n        # GH 7864\n        # make sure ordering is preserverd\n        df = pd.DataFrame({\"id\": [1, 2, 3, 4, 5, 6],\n                           \"raw_grade\": ['a', 'b', 'b', 'a', 'a', 'e']})\n        df[\"grade\"] = pd.Categorical(df[\"raw_grade\"])\n        df['grade'].cat.set_categories(['e', 'a', 'b'])\n\n        df1 = df[0:3]\n        df2 = df[3:]\n\n        self.assert_index_equal(df['grade'].cat.categories,\n                                df1['grade'].cat.categories)\n        self.assert_index_equal(df['grade'].cat.categories,\n                                df2['grade'].cat.categories)\n\n        dfx = pd.concat([df1, df2])\n        dfx['grade'].cat.categories\n        self.assert_index_equal(df['grade'].cat.categories,\n                                dfx['grade'].cat.categories)\n\n    def test_concat_preserve(self):\n\n        # GH 8641\n        # series concat not preserving category dtype\n        s = Series(list('abc'), dtype='category')\n        s2 = Series(list('abd'), dtype='category')\n\n        def f():\n            pd.concat([s, s2])\n\n        self.assertRaises(ValueError, f)\n\n        result = pd.concat([s, s], ignore_index=True)\n        expected = Series(list('abcabc')).astype('category')\n        tm.assert_series_equal(result, expected)\n\n        result = pd.concat([s, s])\n        expected = Series(\n            list('abcabc'), index=[0, 1, 2, 0, 1, 2]).astype('category')\n        tm.assert_series_equal(result, expected)\n\n        a = Series(np.arange(6, dtype='int64'))\n        b = Series(list('aabbca'))\n\n        df2 = DataFrame({'A': a,\n                         'B': b.astype('category', categories=list('cab'))})\n        result = pd.concat([df2, df2])\n        expected = DataFrame({'A': pd.concat([a, a]),\n                              'B': pd.concat([b, b]).astype(\n                                  'category', categories=list('cab'))})\n        tm.assert_frame_equal(result, expected)\n\n    def test_categorical_index_preserver(self):\n\n        a = Series(np.arange(6, dtype='int64'))\n        b = Series(list('aabbca'))\n\n        df2 = DataFrame({'A': a,\n                         'B': b.astype('category', categories=list(\n                             'cab'))}).set_index('B')\n        result = pd.concat([df2, df2])\n        expected = DataFrame({'A': pd.concat([a, a]),\n                              'B': pd.concat([b, b]).astype(\n                                  'category', categories=list(\n                                      'cab'))}).set_index('B')\n        tm.assert_frame_equal(result, expected)\n\n        # wrong catgories\n        df3 = DataFrame({'A': a,\n                         'B': b.astype('category', categories=list(\n                             'abc'))}).set_index('B')\n        self.assertRaises(TypeError, lambda: pd.concat([df2, df3]))\n\n    def test_append(self):\n        cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals = [1, 2]\n        df = pd.DataFrame({\"cats\": cat, \"vals\": vals})\n        cat2 = pd.Categorical([\"a\", \"b\", \"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals2 = [1, 2, 1, 2]\n        exp = pd.DataFrame({\"cats\": cat2,\n                            \"vals\": vals2}, index=pd.Index([0, 1, 0, 1]))\n\n        res = df.append(df)\n        tm.assert_frame_equal(exp, res)\n\n        # Concat should raise if the two categoricals do not have the same\n        # categories\n        cat3 = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n        vals3 = [1, 2]\n        df_wrong_categories = pd.DataFrame({\"cats\": cat3, \"vals\": vals3})\n\n        def f():\n            df.append(df_wrong_categories)\n\n        self.assertRaises(ValueError, f)\n\n    def test_merge(self):\n        # GH 9426\n\n        right = DataFrame({'c': {0: 'a',\n                                 1: 'b',\n                                 2: 'c',\n                                 3: 'd',\n                                 4: 'e'},\n                           'd': {0: 'null',\n                                 1: 'null',\n                                 2: 'null',\n                                 3: 'null',\n                                 4: 'null'}})\n        left = DataFrame({'a': {0: 'f',\n                                1: 'f',\n                                2: 'f',\n                                3: 'f',\n                                4: 'f'},\n                          'b': {0: 'g',\n                                1: 'g',\n                                2: 'g',\n                                3: 'g',\n                                4: 'g'}})\n        df = pd.merge(left, right, how='left', left_on='b', right_on='c')\n\n        # object-object\n        expected = df.copy()\n\n        # object-cat\n        cright = right.copy()\n        cright['d'] = cright['d'].astype('category')\n        result = pd.merge(left, cright, how='left', left_on='b', right_on='c')\n        tm.assert_frame_equal(result, expected)\n\n        # cat-object\n        cleft = left.copy()\n        cleft['b'] = cleft['b'].astype('category')\n        result = pd.merge(cleft, cright, how='left', left_on='b', right_on='c')\n        tm.assert_frame_equal(result, expected)\n\n        # cat-cat\n        cright = right.copy()\n        cright['d'] = cright['d'].astype('category')\n        cleft = left.copy()\n        cleft['b'] = cleft['b'].astype('category')\n        result = pd.merge(cleft, cright, how='left', left_on='b', right_on='c')\n        tm.assert_frame_equal(result, expected)\n\n    def test_repeat(self):\n        # GH10183\n        cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n        exp = pd.Categorical([\"a\", \"a\", \"b\", \"b\"], categories=[\"a\", \"b\"])\n        res = cat.repeat(2)\n        self.assert_categorical_equal(res, exp)\n\n    def test_numpy_repeat(self):\n        cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n        exp = pd.Categorical([\"a\", \"a\", \"b\", \"b\"], categories=[\"a\", \"b\"])\n        self.assert_categorical_equal(np.repeat(cat, 2), exp)\n\n        msg = \"the 'axis' parameter is not supported\"\n        tm.assertRaisesRegexp(ValueError, msg, np.repeat, cat, 2, axis=1)\n\n    def test_reshape(self):\n        cat = pd.Categorical([], categories=[\"a\", \"b\"])\n        tm.assert_produces_warning(FutureWarning, cat.reshape, 0)\n\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([], categories=[\"a\", \"b\"])\n            self.assert_categorical_equal(cat.reshape(0), cat)\n\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([], categories=[\"a\", \"b\"])\n            self.assert_categorical_equal(cat.reshape((5, -1)), cat)\n\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n            self.assert_categorical_equal(cat.reshape(cat.shape), cat)\n\n        with tm.assert_produces_warning(FutureWarning):\n            cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n            self.assert_categorical_equal(cat.reshape(cat.size), cat)\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            msg = \"can only specify one unknown dimension\"\n            cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n            tm.assertRaisesRegexp(ValueError, msg, cat.reshape, (-2, -1))\n\n    def test_numpy_reshape(self):\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            cat = pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n            self.assert_categorical_equal(np.reshape(cat, cat.shape), cat)\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            msg = \"the 'order' parameter is not supported\"\n            tm.assertRaisesRegexp(ValueError, msg, np.reshape,\n                                  cat, cat.shape, order='F')\n\n    def test_na_actions(self):\n\n        cat = pd.Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])\n        vals = [\"a\", \"b\", np.nan, \"d\"]\n        df = pd.DataFrame({\"cats\": cat, \"vals\": vals})\n        cat2 = pd.Categorical([1, 2, 3, 3], categories=[1, 2, 3])\n        vals2 = [\"a\", \"b\", \"b\", \"d\"]\n        df_exp_fill = pd.DataFrame({\"cats\": cat2, \"vals\": vals2})\n        cat3 = pd.Categorical([1, 2, 3], categories=[1, 2, 3])\n        vals3 = [\"a\", \"b\", np.nan]\n        df_exp_drop_cats = pd.DataFrame({\"cats\": cat3, \"vals\": vals3})\n        cat4 = pd.Categorical([1, 2], categories=[1, 2, 3])\n        vals4 = [\"a\", \"b\"]\n        df_exp_drop_all = pd.DataFrame({\"cats\": cat4, \"vals\": vals4})\n\n        # fillna\n        res = df.fillna(value={\"cats\": 3, \"vals\": \"b\"})\n        tm.assert_frame_equal(res, df_exp_fill)\n\n        def f():\n            df.fillna(value={\"cats\": 4, \"vals\": \"c\"})\n\n        self.assertRaises(ValueError, f)\n\n        res = df.fillna(method='pad')\n        tm.assert_frame_equal(res, df_exp_fill)\n\n        res = df.dropna(subset=[\"cats\"])\n        tm.assert_frame_equal(res, df_exp_drop_cats)\n\n        res = df.dropna()\n        tm.assert_frame_equal(res, df_exp_drop_all)\n\n        # make sure that fillna takes missing values into account\n        c = Categorical([np.nan, \"b\", np.nan], categories=[\"a\", \"b\"])\n        df = pd.DataFrame({\"cats\": c, \"vals\": [1, 2, 3]})\n\n        cat_exp = Categorical([\"a\", \"b\", \"a\"], categories=[\"a\", \"b\"])\n        df_exp = pd.DataFrame({\"cats\": cat_exp, \"vals\": [1, 2, 3]})\n\n        res = df.fillna(\"a\")\n        tm.assert_frame_equal(res, df_exp)\n\n    def test_astype_to_other(self):\n\n        s = self.cat['value_group']\n        expected = s\n        tm.assert_series_equal(s.astype('category'), expected)\n        tm.assert_series_equal(s.astype(CategoricalDtype()), expected)\n        self.assertRaises(ValueError, lambda: s.astype('float64'))\n\n        cat = Series(Categorical(['a', 'b', 'b', 'a', 'a', 'c', 'c', 'c']))\n        exp = Series(['a', 'b', 'b', 'a', 'a', 'c', 'c', 'c'])\n        tm.assert_series_equal(cat.astype('str'), exp)\n        s2 = Series(Categorical.from_array(['1', '2', '3', '4']))\n        exp2 = Series([1, 2, 3, 4]).astype(int)\n        tm.assert_series_equal(s2.astype('int'), exp2)\n\n        # object don't sort correctly, so just compare that we have the same\n        # values\n        def cmp(a, b):\n            tm.assert_almost_equal(\n                np.sort(np.unique(a)), np.sort(np.unique(b)))\n\n        expected = Series(np.array(s.values), name='value_group')\n        cmp(s.astype('object'), expected)\n        cmp(s.astype(np.object_), expected)\n\n        # array conversion\n        tm.assert_almost_equal(np.array(s), np.array(s.values))\n\n        # valid conversion\n        for valid in [lambda x: x.astype('category'),\n                      lambda x: x.astype(CategoricalDtype()),\n                      lambda x: x.astype('object').astype('category'),\n                      lambda x: x.astype('object').astype(\n                          CategoricalDtype())\n                      ]:\n\n            result = valid(s)\n            # compare series values\n            # internal .categories can't be compared because it is sorted\n            tm.assert_series_equal(result, s, check_categorical=False)\n\n        # invalid conversion (these are NOT a dtype)\n        for invalid in [lambda x: x.astype(pd.Categorical),\n                        lambda x: x.astype('object').astype(pd.Categorical)]:\n            self.assertRaises(TypeError, lambda: invalid(s))\n\n    def test_astype_categorical(self):\n\n        cat = Categorical(['a', 'b', 'b', 'a', 'a', 'c', 'c', 'c'])\n        tm.assert_categorical_equal(cat, cat.astype('category'))\n        tm.assert_almost_equal(np.array(cat), cat.astype('object'))\n\n        self.assertRaises(ValueError, lambda: cat.astype(float))\n\n    def test_to_records(self):\n\n        # GH8626\n\n        # dict creation\n        df = DataFrame({'A': list('abc')}, dtype='category')\n        expected = Series(list('abc'), dtype='category', name='A')\n        tm.assert_series_equal(df['A'], expected)\n\n        # list-like creation\n        df = DataFrame(list('abc'), dtype='category')\n        expected = Series(list('abc'), dtype='category', name=0)\n        tm.assert_series_equal(df[0], expected)\n\n        # to record array\n        # this coerces\n        result = df.to_records()\n        expected = np.rec.array([(0, 'a'), (1, 'b'), (2, 'c')],\n                                dtype=[('index', '=i8'), ('0', 'O')])\n        tm.assert_almost_equal(result, expected)\n\n    def test_numeric_like_ops(self):\n\n        # numeric ops should not succeed\n        for op in ['__add__', '__sub__', '__mul__', '__truediv__']:\n            self.assertRaises(TypeError,\n                              lambda: getattr(self.cat, op)(self.cat))\n\n        # reduction ops should not succeed (unless specifically defined, e.g.\n        # min/max)\n        s = self.cat['value_group']\n        for op in ['kurt', 'skew', 'var', 'std', 'mean', 'sum', 'median']:\n            self.assertRaises(TypeError,\n                              lambda: getattr(s, op)(numeric_only=False))\n\n        # mad technically works because it takes always the numeric data\n\n        # numpy ops\n        s = pd.Series(pd.Categorical([1, 2, 3, 4]))\n        self.assertRaises(TypeError, lambda: np.sum(s))\n\n        # numeric ops on a Series\n        for op in ['__add__', '__sub__', '__mul__', '__truediv__']:\n            self.assertRaises(TypeError, lambda: getattr(s, op)(2))\n\n        # invalid ufunc\n        self.assertRaises(TypeError, lambda: np.log(s))\n\n    def test_cat_tab_completition(self):\n        # test the tab completion display\n        ok_for_cat = ['categories', 'codes', 'ordered', 'set_categories',\n                      'add_categories', 'remove_categories',\n                      'rename_categories', 'reorder_categories',\n                      'remove_unused_categories', 'as_ordered', 'as_unordered']\n\n        def get_dir(s):\n            results = [r for r in s.cat.__dir__() if not r.startswith('_')]\n            return list(sorted(set(results)))\n\n        s = Series(list('aabbcde')).astype('category')\n        results = get_dir(s)\n        tm.assert_almost_equal(results, list(sorted(set(ok_for_cat))))\n\n    def test_cat_accessor_api(self):\n        # GH 9322\n        from pandas.core.categorical import CategoricalAccessor\n        self.assertIs(Series.cat, CategoricalAccessor)\n        s = Series(list('aabbcde')).astype('category')\n        self.assertIsInstance(s.cat, CategoricalAccessor)\n\n        invalid = Series([1])\n        with tm.assertRaisesRegexp(AttributeError, \"only use .cat accessor\"):\n            invalid.cat\n        self.assertFalse(hasattr(invalid, 'cat'))\n\n    def test_cat_accessor_no_new_attributes(self):\n        # https://github.com/pydata/pandas/issues/10673\n        c = Series(list('aabbcde')).astype('category')\n        with tm.assertRaisesRegexp(AttributeError,\n                                   \"You cannot add any new attribute\"):\n            c.cat.xlabel = \"a\"\n\n    def test_str_accessor_api_for_categorical(self):\n        # https://github.com/pydata/pandas/issues/10661\n        from pandas.core.strings import StringMethods\n        s = Series(list('aabb'))\n        s = s + \" \" + s\n        c = s.astype('category')\n        self.assertIsInstance(c.str, StringMethods)\n\n        # str functions, which need special arguments\n        special_func_defs = [\n            ('cat', (list(\"zyxw\"),), {\"sep\": \",\"}),\n            ('center', (10,), {}),\n            ('contains', (\"a\",), {}),\n            ('count', (\"a\",), {}),\n            ('decode', (\"UTF-8\",), {}),\n            ('encode', (\"UTF-8\",), {}),\n            ('endswith', (\"a\",), {}),\n            ('extract', (\"([a-z]*) \",), {\"expand\":False}),\n            ('extract', (\"([a-z]*) \",), {\"expand\":True}),\n            ('extractall', (\"([a-z]*) \",), {}),\n            ('find', (\"a\",), {}),\n            ('findall', (\"a\",), {}),\n            ('index', (\" \",), {}),\n            ('ljust', (10,), {}),\n            ('match', (\"a\"), {}),  # deprecated...\n            ('normalize', (\"NFC\",), {}),\n            ('pad', (10,), {}),\n            ('partition', (\" \",), {\"expand\": False}),  # not default\n            ('partition', (\" \",), {\"expand\": True}),  # default\n            ('repeat', (3,), {}),\n            ('replace', (\"a\", \"z\"), {}),\n            ('rfind', (\"a\",), {}),\n            ('rindex', (\" \",), {}),\n            ('rjust', (10,), {}),\n            ('rpartition', (\" \",), {\"expand\": False}),  # not default\n            ('rpartition', (\" \",), {\"expand\": True}),  # default\n            ('slice', (0, 1), {}),\n            ('slice_replace', (0, 1, \"z\"), {}),\n            ('split', (\" \",), {\"expand\": False}),  # default\n            ('split', (\" \",), {\"expand\": True}),  # not default\n            ('startswith', (\"a\",), {}),\n            ('wrap', (2,), {}),\n            ('zfill', (10,), {})\n        ]\n        _special_func_names = [f[0] for f in special_func_defs]\n\n        # * get, join: they need a individual elements of type lists, but\n        #   we can't make a categorical with lists as individual categories.\n        #   -> `s.str.split(\" \").astype(\"category\")` will error!\n        # * `translate` has different interfaces for py2 vs. py3\n        _ignore_names = [\"get\", \"join\", \"translate\"]\n\n        str_func_names = [f\n                          for f in dir(s.str)\n                          if not (f.startswith(\"_\") or f in _special_func_names\n                                  or f in _ignore_names)]\n\n        func_defs = [(f, (), {}) for f in str_func_names]\n        func_defs.extend(special_func_defs)\n\n        for func, args, kwargs in func_defs:\n            res = getattr(c.str, func)(*args, **kwargs)\n            exp = getattr(s.str, func)(*args, **kwargs)\n\n            if isinstance(res, pd.DataFrame):\n                tm.assert_frame_equal(res, exp)\n            else:\n                tm.assert_series_equal(res, exp)\n\n        invalid = Series([1, 2, 3]).astype('category')\n        with tm.assertRaisesRegexp(AttributeError,\n                                   \"Can only use .str accessor with string\"):\n            invalid.str\n        self.assertFalse(hasattr(invalid, 'str'))\n\n    def test_dt_accessor_api_for_categorical(self):\n        # https://github.com/pydata/pandas/issues/10661\n        from pandas.tseries.common import Properties\n        from pandas.tseries.index import date_range, DatetimeIndex\n        from pandas.tseries.period import period_range, PeriodIndex\n        from pandas.tseries.tdi import timedelta_range, TimedeltaIndex\n\n        s_dr = Series(date_range('1/1/2015', periods=5, tz=\"MET\"))\n        c_dr = s_dr.astype(\"category\")\n\n        s_pr = Series(period_range('1/1/2015', freq='D', periods=5))\n        c_pr = s_pr.astype(\"category\")\n\n        s_tdr = Series(timedelta_range('1 days', '10 days'))\n        c_tdr = s_tdr.astype(\"category\")\n\n        test_data = [\n            (\"Datetime\", DatetimeIndex._datetimelike_ops, s_dr, c_dr),\n            (\"Period\", PeriodIndex._datetimelike_ops, s_pr, c_pr),\n            (\"Timedelta\", TimedeltaIndex._datetimelike_ops, s_tdr, c_tdr)]\n\n        self.assertIsInstance(c_dr.dt, Properties)\n\n        special_func_defs = [\n            ('strftime', (\"%Y-%m-%d\",), {}),\n            ('tz_convert', (\"EST\",), {}),\n            ('round', (\"D\",), {}),\n            ('floor', (\"D\",), {}),\n            ('ceil', (\"D\",), {}),\n            # ('tz_localize', (\"UTC\",), {}),\n        ]\n        _special_func_names = [f[0] for f in special_func_defs]\n\n        # the series is already localized\n        _ignore_names = ['tz_localize']\n\n        for name, attr_names, s, c in test_data:\n            func_names = [f\n                          for f in dir(s.dt)\n                          if not (f.startswith(\"_\") or f in attr_names or f in\n                                  _special_func_names or f in _ignore_names)]\n\n            func_defs = [(f, (), {}) for f in func_names]\n            for f_def in special_func_defs:\n                if f_def[0] in dir(s.dt):\n                    func_defs.append(f_def)\n\n            for func, args, kwargs in func_defs:\n                res = getattr(c.dt, func)(*args, **kwargs)\n                exp = getattr(s.dt, func)(*args, **kwargs)\n\n                if isinstance(res, pd.DataFrame):\n                    tm.assert_frame_equal(res, exp)\n                elif isinstance(res, pd.Series):\n                    tm.assert_series_equal(res, exp)\n                else:\n                    tm.assert_numpy_array_equal(res, exp)\n\n            for attr in attr_names:\n                try:\n                    res = getattr(c.dt, attr)\n                    exp = getattr(s.dt, attr)\n                except Exception as e:\n                    print(name, attr)\n                    raise e\n\n            if isinstance(res, pd.DataFrame):\n                tm.assert_frame_equal(res, exp)\n            elif isinstance(res, pd.Series):\n                tm.assert_series_equal(res, exp)\n            else:\n                tm.assert_numpy_array_equal(res, exp)\n\n        invalid = Series([1, 2, 3]).astype('category')\n        with tm.assertRaisesRegexp(\n                AttributeError, \"Can only use .dt accessor with datetimelike\"):\n            invalid.dt\n        self.assertFalse(hasattr(invalid, 'str'))\n\n    def test_concat_categorical(self):\n        # See GH 10177\n        df1 = pd.DataFrame(\n            np.arange(18, dtype='int64').reshape(6,\n                                                 3), columns=[\"a\", \"b\", \"c\"])\n\n        df2 = pd.DataFrame(\n            np.arange(14, dtype='int64').reshape(7, 2), columns=[\"a\", \"c\"])\n        df2['h'] = pd.Series(pd.Categorical([\"one\", \"one\", \"two\", \"one\", \"two\",\n                                             \"two\", \"one\"]))\n\n        df_concat = pd.concat((df1, df2), axis=0).reset_index(drop=True)\n\n        df_expected = pd.DataFrame(\n            {'a': [0, 3, 6, 9, 12, 15, 0, 2, 4, 6, 8, 10, 12],\n             'b': [1, 4, 7, 10, 13, 16, np.nan, np.nan, np.nan, np.nan, np.nan,\n                   np.nan, np.nan],\n             'c': [2, 5, 8, 11, 14, 17, 1, 3, 5, 7, 9, 11, 13]})\n        df_expected['h'] = pd.Series(pd.Categorical(\n            [None, None, None, None, None, None, \"one\", \"one\", \"two\", \"one\",\n             \"two\", \"two\", \"one\"]))\n\n        tm.assert_frame_equal(df_expected, df_concat)\n\n\nclass TestCategoricalSubclassing(tm.TestCase):\n\n    _multiprocess_can_split_ = True\n\n    def test_constructor(self):\n        sc = tm.SubclassedCategorical(['a', 'b', 'c'])\n        self.assertIsInstance(sc, tm.SubclassedCategorical)\n        tm.assert_categorical_equal(sc, Categorical(['a', 'b', 'c']))\n\n    def test_from_array(self):\n        sc = tm.SubclassedCategorical.from_codes([1, 0, 2], ['a', 'b', 'c'])\n        self.assertIsInstance(sc, tm.SubclassedCategorical)\n        exp = Categorical.from_codes([1, 0, 2], ['a', 'b', 'c'])\n        tm.assert_categorical_equal(sc, exp)\n\n    def test_map(self):\n        sc = tm.SubclassedCategorical(['a', 'b', 'c'])\n        res = sc.map(lambda x: x.upper())\n        self.assertIsInstance(res, tm.SubclassedCategorical)\n        exp = Categorical(['A', 'B', 'C'])\n        tm.assert_categorical_equal(res, exp)\n\n    def test_map(self):\n        sc = tm.SubclassedCategorical(['a', 'b', 'c'])\n        res = sc.map(lambda x: x.upper())\n        self.assertIsInstance(res, tm.SubclassedCategorical)\n        exp = Categorical(['A', 'B', 'C'])\n        tm.assert_categorical_equal(res, exp)\n\n\nif __name__ == '__main__':\n    import nose\n    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],\n                   # '--with-coverage', '--cover-package=pandas.core']\n                   exit=False)\n"
    }
  ],
  "questions": [
    "@jreback Can you clarify what you mean by saying _\"Categoricals should not allow non-strings when an object dtype is passed\"_\n\nMy PR above takes this literally, which breaks many tests, [particularly here](https://github.com/pydata/pandas/blob/master/pandas/indexes/multi.py#L867) . That list comprehension  passes in `arr` to `Categorical.from_array`, which is often of type `object`, but all the individual values are homogenous \n\nIn my PR, should I just check if all the values are of the same type?\n\nThanks"
  ],
  "golden_answers": [
    "Hello @wcwagner . Thank you for taking a look on this.\n\nI believe that it was more like the second option - individual values should be homogenous (in the terms of dtypes). So don't allow something like this: `1, '2', 3` (mixing int with string), while `'1', '2', '3'` (all str/objects) or `1, 2, 3` (all ints) are valid.\n\nIf I should implement it extremely naively, I would do something like: \n\n``` python\ncategories_types = [type(x) for x in categories]\nif len(categories_types) > 1: \n    raise ValueError('Categories must be all of the same type. They are %s', categories_types)\n```"
  ],
  "questions_generated": [
    "Why does the HDF Store with 'table' format not support categories with mixed types in pandas?",
    "What is the expected behavior when trying to store a DataFrame with mixed-type categories using `to_hdf` in pandas?",
    "How does the pandas library currently handle the creation of a Categorical with mixed types, and what is the proposed change?",
    "In the context of the pandas issue discussed, what does it mean for values to be homogenous, and why is this important?",
    "What are the potential implications of allowing mixed types in pandas Categorical data, particularly when interfacing with external storage formats like HDF5?"
  ],
  "golden_answers_generated": [
    "The HDF Store with 'table' format in pandas does not support categories with mixed types because it expects a consistent data type for serialization. When mixed types are present, such as integers and strings in a single category, it results in an object dtype, which the HDF format cannot serialize efficiently, leading to the TypeError encountered.",
    "The expected behavior when trying to store a DataFrame with mixed-type categories using `to_hdf` in pandas is that it should raise an error. Mixed types within a category result in an object dtype, which is not supported by the HDF5 format with 'table'. The operation requires all values to be of a single, consistent dtype for successful serialization.",
    "Currently, pandas allows the creation of Categoricals with mixed types, but this can lead to issues when performing operations such as saving to HDF5. The proposed change is to raise an error during the creation of a Categorical if it contains mixed types, ensuring that only uniform dtypes are allowed, thereby preventing downstream errors when using functions like `to_hdf`.",
    "In the context of the pandas issue, for values to be homogenous means that all the elements within a category should be of the same data type, such as all integers or all strings. This homogeneity is important because it ensures that operations like serialization and data manipulation can be performed without type-related errors, maintaining data integrity and compatibility with formats like HDF5.",
    "Allowing mixed types in pandas Categorical data can lead to significant issues when interfacing with external storage formats like HDF5, which require consistent data types for serialization. Mixed types result in object dtypes, which are not supported by the 'table' format of HDF5, causing serialization to fail. This can prevent data from being saved correctly and lead to data loss or corruption if not handled properly."
  ]
}