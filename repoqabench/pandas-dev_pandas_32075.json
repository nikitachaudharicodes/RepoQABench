{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "32075",
  "issue_description": "# Series.replace fails to replace value\n\n#### Code Sample, a copy-pastable example if possible\r\n\r\n```python\r\nIn [93]: ser.eq('nil').sum()\r\nOut[93]: 1\r\n\r\nIn [94]: ser.replace('nil', pd.NA).eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/missing.py:47: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\nOut[94]: 1\r\n\r\nIn [95]: ser.loc[(ser == 'nil').fillna(False)] = pd.NA\r\n\r\nIn [104]: ser.eq('nil').sum()\r\nOut[104]: 0\r\n\r\n\r\n```\r\n\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\n[paste the output of ``pd.show_versions()`` here below this line]\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : None\r\npython           : 3.7.5.final.0\r\npython-bits      : 64\r\nOS               : Linux\r\nOS-release       : 5.4.18-100.fc30.x86_64\r\nmachine          : x86_64\r\nprocessor        : x86_64\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : nb_NO.UTF-8\r\nLOCALE           : nb_NO.UTF-8\r\n\r\npandas           : 1.0.1\r\nnumpy            : 1.17.3\r\npytz             : 2019.3\r\ndateutil         : 2.8.0\r\npip              : 19.3.1\r\nsetuptools       : 41.6.0.post20191030\r\nCython           : 0.29.13\r\npytest           : 5.2.2\r\nhypothesis       : None\r\nsphinx           : 2.2.1\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : 1.2.2\r\nlxml.etree       : 4.4.1\r\nhtml5lib         : 1.0.1\r\npymysql          : None\r\npsycopg2         : 2.8.4 (dt dec pq3 ext lo64)\r\njinja2           : 2.10.3\r\nIPython          : 7.9.0\r\npandas_datareader: None\r\nbs4              : 4.8.1\r\nbottleneck       : 1.2.1\r\nfastparquet      : None\r\ngcsfs            : None\r\nlxml.etree       : 4.4.1\r\nmatplotlib       : 2.2.3\r\nnumexpr          : 2.7.0\r\nodfpy            : None\r\nopenpyxl         : 3.0.0\r\npandas_gbq       : None\r\npyarrow          : 0.15.1\r\npytables         : None\r\npytest           : 5.2.2\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.3.1\r\nsqlalchemy       : 1.3.10\r\ntables           : 3.5.2\r\ntabulate         : 0.8.5\r\nxarray           : None\r\nxlrd             : 1.2.0\r\nxlwt             : 1.3.0\r\nxlsxwriter       : 1.2.2\r\nnumba            : 0.46.0\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 587438220,
      "user": "MarcoGorelli",
      "body": "Thanks @tsoernes \r\n\r\nCould you include a [minimal reproducible example](https://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports)? I couldn't reproduce this\r\n```\r\nIn [1]: import pandas as pd                                                                                                                                                                                      \r\nIn [2]: ser = pd.DataFrame({'a': ['nil']})                                                                                                                                                                       \r\n\r\nIn [3]: ser                                                                                                                                                                                                      \r\nOut[3]: \r\n     a\r\n0  nil\r\n\r\nIn [4]: ser.replace('nil', pd.NA)                                                                                                                                                                                \r\nOut[4]: \r\n      a\r\n0  <NA>\r\n\r\nIn [5]: ser.replace('nil', pd.NA).eq('nil').sum()                                                                                                                                                                \r\nOut[5]: \r\na    0\r\ndtype: int64\r\n```"
    },
    {
      "id": 587447893,
      "user": "tsoernes",
      "body": "@MarcoGorelli \r\n\r\nIn the following example, I extract out two rows from the dataframe and recreate it via a dict.\r\nThe first row has a 'nil' in the 'amount' column; the second row has no 'nil'. \r\nIf I only recreate the dataframe with the first row, then the problem does not show itself.\r\nWhen going via JSON, the problem does not persist.\r\n\r\n```python\r\n\r\nIn [282]: di = df.loc[[26123, 26122]].to_dict()\r\n\r\nIn [283]: di\r\nOut[283]: \r\n<redacted since problem isolated later in thread>\r\n\r\nIn [284]: df = pd.DataFrame.from_dict(di)\r\n\r\nIn [285]: df.eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[285]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\nIn [286]: df.replace('nil', pd.NA).eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/missing.py:47: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[289]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\n```"
    },
    {
      "id": 587458865,
      "user": "MarcoGorelli",
      "body": "@tsoernes OK, got it - it fails when there is another row with `pd.NA`:\r\n\r\n```\r\n>>> ser = pd.DataFrame({'a': ['nil', pd.NA]}) \r\n>>> ser.replace('nil', 'anything else')                                                                                                                                                                  \r\n/home/SERILOCAL/m.gorelli/pandas/pandas/core/missing.py:48: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n      a\r\n0   nil\r\n1  <NA>\r\n```\r\n"
    },
    {
      "id": 587460741,
      "user": "MarcoGorelli",
      "body": "Problem's related to this:\r\n```\r\n>>> np.array([['nil', pd.NA]]) == 'nil'\r\nFalse\r\n>>> np.array([['nil', 'anything else']]) == 'nil'\r\narray([[ True, False]])\r\n```"
    },
    {
      "id": 591539006,
      "user": "AnnaDaglis",
      "body": "take"
    },
    {
      "id": 593964225,
      "user": "AnnaDaglis",
      "body": "@MarcoGorelli \r\nIs there any particular approach here you could suggest to fix the bug? There is no issue when using `np.nan`, not `pd.NA`.\r\n```\r\n>>> np.array([['nil', np.nan]]) == 'nil'\r\narray([[ True, False]])\r\n```"
    },
    {
      "id": 594208581,
      "user": "MarcoGorelli",
      "body": "Hi Anna - gonna be honest, I don't know :) I had a quick go at this one but\ncouldn't figure it out. If you have any specific questions I'd imagine you\ncould tag one of the core team members (e.g. Tom Augspurger) and ask.\n\nOn Tue, 3 Mar 2020 13:59 Anna Daglis, <notifications@github.com> wrote:\n\n> @MarcoGorelli <https://github.com/MarcoGorelli>\n>\n> Is there any particular approach here you could suggest to fix the bug?\n> There is no issue when using np.nan, not pd.NA.\n>\n> >>> np.array([['nil', np.nan]]) == 'nil'\n> array([[ True, False]])\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/32075?email_source=notifications&email_token=AH7QVMAQXWDFDIOEHDX3T7TRFUENRA5CNFSM4KXDNN42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENTSZQI#issuecomment-593964225>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AH7QVMHQJKUXY46CWPZW2NDRFUENRANCNFSM4KXDNN4Q>\n> .\n>\n"
    },
    {
      "id": 595141028,
      "user": "AnnaDaglis",
      "body": "The problem in this case lies in `pandas.core.missing`, `mask_missing(arr, values_to_mask)`  function, the following clause:\r\n\r\n```\r\nif is_numeric_v_string_like(arr, x):\r\n    # GH#29553 prevent numpy deprecation warnings\r\n    mask = False\r\nelse:\r\n    mask = arr == x\r\n```\r\n\r\nThe problem arises here `arr == x`, which fails when `arr` contains ``pd.NA``, as pointed out above. \r\n\r\n@TomAugspurger @jorisvandenbossche \r\nDo you have any suggestions how to tackle this bug? I noticed that handling ``pd.NA`` behaviour has been discussed in other issues, e.g. this one: https://github.com/pandas-dev/pandas/issues/32265"
    },
    {
      "id": 595206009,
      "user": "TomAugspurger",
      "body": "I'm not sure offhand, sorry. But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask? Some of the methods in `core.arrays.boolean` may be helpful to look through."
    },
    {
      "id": 596455690,
      "user": "tsoernes",
      "body": "Can we get this for 1.0.2 that would be awesome"
    },
    {
      "id": 596735782,
      "user": "jorisvandenbossche",
      "body": "Note that this is working fine with string dtype:\r\n\r\n```\r\nIn [4]: ser = pd.DataFrame({'a': ['nil', pd.NA]}, dtype=\"string\") \r\n\r\nIn [5]: ser.replace('nil', 'anything else')\r\nOut[5]: \r\n               a\r\n0  anything else\r\n1           <NA>\r\n```\r\n\r\nSo it is specifically for NA in object dtype (something we actually don't really test yet, I think).\r\n\r\n> The problem arises here arr == x, which fails when arr contains pd.NA, as pointed out above.\r\n\r\nThis *might* be related to the comparison deprecations in numpy (there are other cases where comparisons return a scalar True/False, instead of doing it element-wise), you also see the deprecation warning. \r\nNow in general, numpy might not be able to handle this: the comparison with pd.NA returns pd.NA, so it cannot be put in a boolean ndarray (which numpy expects to do for a comparison, I suppose). So the deprecation might be correct that it will fail in the future. \r\n\r\nIf we want to handle pd.NA in object dtype better, we will need to start using masks as well, and not rely on numpy behaviour. \r\n\r\nFor example, also this is wrong:\r\n\r\n```\r\nIn [9]: pd.Series([1, pd.NA], dtype=object) >= 1\r\nOut[9]: \r\n0     True\r\n1    False\r\ndtype: bool\r\n```\r\n\r\n(we should probably open a separate issue about \"pd.NA in object dtype\", and the best way forward here generally)\r\n"
    },
    {
      "id": 602671661,
      "user": "simonjayhawkins",
      "body": "> (we should probably open a separate issue about \"pd.NA in object dtype\", and the best way forward here generally)\r\n\r\n#32931"
    },
    {
      "id": 666730226,
      "user": "tsibley",
      "body": "@jorisvandenbossche \r\n\r\n> Note that this is working fine with string dtype:\r\n\r\nAs of 1.1.0 at least, it's not working fine:\r\n\r\n```\r\n>>> import pandas as pd\r\n>>> pd.__version__\r\n'1.1.0'\r\n\r\n>>> s = pd.Series([\"a\", \"\", \"b\", pd.NA], dtype=\"string\")\r\n>>> s\r\n0       a\r\n1        \r\n2       b\r\n3    <NA>\r\ndtype: string\r\n\r\n>>> s.replace(\"\", pd.NA)\r\n.../lib/python3.6/site-packages/pandas/core/missing.py:49: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n0       a\r\n1        \r\n2       b\r\n3    <NA>\r\ndtype: object\r\n```"
    },
    {
      "id": 666731486,
      "user": "tsibley",
      "body": "Note however, that the one-dict-arg form of `replace` _does_ appear to work (!):\r\n\r\n```\r\n>>> s.replace({\"\": pd.NA})\r\n0       a\r\n1    <NA>\r\n2       b\r\n3    <NA>\r\ndtype: object\r\n```\r\n\r\nbut as described in #35268, it changes the dtype of the Series from whatever it was to object.\r\n\r\nI'd (naively, perhaps) expect two-arg replace and one-dict-arg replace to both use the same codepath internally!"
    },
    {
      "id": 666769187,
      "user": "tsibley",
      "body": "> But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask?\r\n\r\nThis makes sense to me and matches my debugging. I'm testing this patch now:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..be1632315 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = (arr == x).fillna(False)\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= (arr == x).fillna(False)\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n\r\n```\r\n"
    },
    {
      "id": 667254337,
      "user": "tsibley",
      "body": "The patch above doesn't work (unsurprisingly) because sometimes `arr` is a Pandas array and sometimes it's a NumPy array, but only Pandas arrays have a `fillna` method.\r\n\r\nThe patch below _seems_ to work with some manual testing and the result of `./test_fast.sh` is the same before/after applying it:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..f8280c0a2 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n```\r\n\r\nThis replaces `pd.NA` values with NumPy `NaN` and `NaT` values, which do compare with `==` correctly and produce a boolean vector instead of a boolean scalar.\r\n\r\nI want to write an actual set of tests cases for this bug for various dtypes though before submitting a PR. I believe the patch above may still fail for `pd.Period` types."
    },
    {
      "id": 703128526,
      "user": "MarcusJellinghaus",
      "body": "Here is another example - at least I think it is the same bug:\r\n\r\n```import pandas as pd\r\nimport numpy as np\r\nseries1 = pd.Series([\"\"]).replace(\"\", np.nan) # works\r\nprint(series1.values)  # [nan]\r\nseries2 = pd.Series([\"\", pd.NA]).replace(\"\", np.nan) # fails\r\nprint(series2.values)  # ['' <NA>]\r\nseries3 = pd.Series([\"\", pd.NA]).replace(pd.NA, np.nan).replace(\"\", np.nan) # possible workaround\r\nprint(series3.values)  # [nan nan] \r\n```\r\n\r\nMaybe this would helps to fix the bug.\r\n\r\nIt would be great if you could fix the bug."
    },
    {
      "id": 1396165673,
      "user": "phofl",
      "body": "This works now, may need tests"
    }
  ],
  "text_context": "# Series.replace fails to replace value\n\n#### Code Sample, a copy-pastable example if possible\r\n\r\n```python\r\nIn [93]: ser.eq('nil').sum()\r\nOut[93]: 1\r\n\r\nIn [94]: ser.replace('nil', pd.NA).eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/missing.py:47: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\nOut[94]: 1\r\n\r\nIn [95]: ser.loc[(ser == 'nil').fillna(False)] = pd.NA\r\n\r\nIn [104]: ser.eq('nil').sum()\r\nOut[104]: 0\r\n\r\n\r\n```\r\n\r\n\r\n#### Output of ``pd.show_versions()``\r\n\r\n<details>\r\n\r\n[paste the output of ``pd.show_versions()`` here below this line]\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit           : None\r\npython           : 3.7.5.final.0\r\npython-bits      : 64\r\nOS               : Linux\r\nOS-release       : 5.4.18-100.fc30.x86_64\r\nmachine          : x86_64\r\nprocessor        : x86_64\r\nbyteorder        : little\r\nLC_ALL           : None\r\nLANG             : nb_NO.UTF-8\r\nLOCALE           : nb_NO.UTF-8\r\n\r\npandas           : 1.0.1\r\nnumpy            : 1.17.3\r\npytz             : 2019.3\r\ndateutil         : 2.8.0\r\npip              : 19.3.1\r\nsetuptools       : 41.6.0.post20191030\r\nCython           : 0.29.13\r\npytest           : 5.2.2\r\nhypothesis       : None\r\nsphinx           : 2.2.1\r\nblosc            : None\r\nfeather          : None\r\nxlsxwriter       : 1.2.2\r\nlxml.etree       : 4.4.1\r\nhtml5lib         : 1.0.1\r\npymysql          : None\r\npsycopg2         : 2.8.4 (dt dec pq3 ext lo64)\r\njinja2           : 2.10.3\r\nIPython          : 7.9.0\r\npandas_datareader: None\r\nbs4              : 4.8.1\r\nbottleneck       : 1.2.1\r\nfastparquet      : None\r\ngcsfs            : None\r\nlxml.etree       : 4.4.1\r\nmatplotlib       : 2.2.3\r\nnumexpr          : 2.7.0\r\nodfpy            : None\r\nopenpyxl         : 3.0.0\r\npandas_gbq       : None\r\npyarrow          : 0.15.1\r\npytables         : None\r\npytest           : 5.2.2\r\npyxlsb           : None\r\ns3fs             : None\r\nscipy            : 1.3.1\r\nsqlalchemy       : 1.3.10\r\ntables           : 3.5.2\r\ntabulate         : 0.8.5\r\nxarray           : None\r\nxlrd             : 1.2.0\r\nxlwt             : 1.3.0\r\nxlsxwriter       : 1.2.2\r\nnumba            : 0.46.0\r\n\r\n</details>\r\n\n\nThanks @tsoernes \r\n\r\nCould you include a [minimal reproducible example](https://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports)? I couldn't reproduce this\r\n```\r\nIn [1]: import pandas as pd                                                                                                                                                                                      \r\nIn [2]: ser = pd.DataFrame({'a': ['nil']})                                                                                                                                                                       \r\n\r\nIn [3]: ser                                                                                                                                                                                                      \r\nOut[3]: \r\n     a\r\n0  nil\r\n\r\nIn [4]: ser.replace('nil', pd.NA)                                                                                                                                                                                \r\nOut[4]: \r\n      a\r\n0  <NA>\r\n\r\nIn [5]: ser.replace('nil', pd.NA).eq('nil').sum()                                                                                                                                                                \r\nOut[5]: \r\na    0\r\ndtype: int64\r\n```\n\n@MarcoGorelli \r\n\r\nIn the following example, I extract out two rows from the dataframe and recreate it via a dict.\r\nThe first row has a 'nil' in the 'amount' column; the second row has no 'nil'. \r\nIf I only recreate the dataframe with the first row, then the problem does not show itself.\r\nWhen going via JSON, the problem does not persist.\r\n\r\n```python\r\n\r\nIn [282]: di = df.loc[[26123, 26122]].to_dict()\r\n\r\nIn [283]: di\r\nOut[283]: \r\n<redacted since problem isolated later in thread>\r\n\r\nIn [284]: df = pd.DataFrame.from_dict(di)\r\n\r\nIn [285]: df.eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[285]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\nIn [286]: df.replace('nil', pd.NA).eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/missing.py:47: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[289]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\n```\n\n@tsoernes OK, got it - it fails when there is another row with `pd.NA`:\r\n\r\n```\r\n>>> ser = pd.DataFrame({'a': ['nil', pd.NA]}) \r\n>>> ser.replace('nil', 'anything else')                                                                                                                                                                  \r\n/home/SERILOCAL/m.gorelli/pandas/pandas/core/missing.py:48: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n      a\r\n0   nil\r\n1  <NA>\r\n```\r\n\n\nProblem's related to this:\r\n```\r\n>>> np.array([['nil', pd.NA]]) == 'nil'\r\nFalse\r\n>>> np.array([['nil', 'anything else']]) == 'nil'\r\narray([[ True, False]])\r\n```\n\ntake\n\n@MarcoGorelli \r\nIs there any particular approach here you could suggest to fix the bug? There is no issue when using `np.nan`, not `pd.NA`.\r\n```\r\n>>> np.array([['nil', np.nan]]) == 'nil'\r\narray([[ True, False]])\r\n```\n\nHi Anna - gonna be honest, I don't know :) I had a quick go at this one but\ncouldn't figure it out. If you have any specific questions I'd imagine you\ncould tag one of the core team members (e.g. Tom Augspurger) and ask.\n\nOn Tue, 3 Mar 2020 13:59 Anna Daglis, <notifications@github.com> wrote:\n\n> @MarcoGorelli <https://github.com/MarcoGorelli>\n>\n> Is there any particular approach here you could suggest to fix the bug?\n> There is no issue when using np.nan, not pd.NA.\n>\n> >>> np.array([['nil', np.nan]]) == 'nil'\n> array([[ True, False]])\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/32075?email_source=notifications&email_token=AH7QVMAQXWDFDIOEHDX3T7TRFUENRA5CNFSM4KXDNN42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENTSZQI#issuecomment-593964225>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AH7QVMHQJKUXY46CWPZW2NDRFUENRANCNFSM4KXDNN4Q>\n> .\n>\n\n\nThe problem in this case lies in `pandas.core.missing`, `mask_missing(arr, values_to_mask)`  function, the following clause:\r\n\r\n```\r\nif is_numeric_v_string_like(arr, x):\r\n    # GH#29553 prevent numpy deprecation warnings\r\n    mask = False\r\nelse:\r\n    mask = arr == x\r\n```\r\n\r\nThe problem arises here `arr == x`, which fails when `arr` contains ``pd.NA``, as pointed out above. \r\n\r\n@TomAugspurger @jorisvandenbossche \r\nDo you have any suggestions how to tackle this bug? I noticed that handling ``pd.NA`` behaviour has been discussed in other issues, e.g. this one: https://github.com/pandas-dev/pandas/issues/32265\n\nI'm not sure offhand, sorry. But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask? Some of the methods in `core.arrays.boolean` may be helpful to look through.\n\nCan we get this for 1.0.2 that would be awesome\n\nNote that this is working fine with string dtype:\r\n\r\n```\r\nIn [4]: ser = pd.DataFrame({'a': ['nil', pd.NA]}, dtype=\"string\") \r\n\r\nIn [5]: ser.replace('nil', 'anything else')\r\nOut[5]: \r\n               a\r\n0  anything else\r\n1           <NA>\r\n```\r\n\r\nSo it is specifically for NA in object dtype (something we actually don't really test yet, I think).\r\n\r\n> The problem arises here arr == x, which fails when arr contains pd.NA, as pointed out above.\r\n\r\nThis *might* be related to the comparison deprecations in numpy (there are other cases where comparisons return a scalar True/False, instead of doing it element-wise), you also see the deprecation warning. \r\nNow in general, numpy might not be able to handle this: the comparison with pd.NA returns pd.NA, so it cannot be put in a boolean ndarray (which numpy expects to do for a comparison, I suppose). So the deprecation might be correct that it will fail in the future. \r\n\r\nIf we want to handle pd.NA in object dtype better, we will need to start using masks as well, and not rely on numpy behaviour. \r\n\r\nFor example, also this is wrong:\r\n\r\n```\r\nIn [9]: pd.Series([1, pd.NA], dtype=object) >= 1\r\nOut[9]: \r\n0     True\r\n1    False\r\ndtype: bool\r\n```\r\n\r\n(we should probably open a separate issue about \"pd.NA in object dtype\", and the best way forward here generally)\r\n\n\n> (we should probably open a separate issue about \"pd.NA in object dtype\", and the best way forward here generally)\r\n\r\n#32931\n\n@jorisvandenbossche \r\n\r\n> Note that this is working fine with string dtype:\r\n\r\nAs of 1.1.0 at least, it's not working fine:\r\n\r\n```\r\n>>> import pandas as pd\r\n>>> pd.__version__\r\n'1.1.0'\r\n\r\n>>> s = pd.Series([\"a\", \"\", \"b\", pd.NA], dtype=\"string\")\r\n>>> s\r\n0       a\r\n1        \r\n2       b\r\n3    <NA>\r\ndtype: string\r\n\r\n>>> s.replace(\"\", pd.NA)\r\n.../lib/python3.6/site-packages/pandas/core/missing.py:49: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n0       a\r\n1        \r\n2       b\r\n3    <NA>\r\ndtype: object\r\n```\n\nNote however, that the one-dict-arg form of `replace` _does_ appear to work (!):\r\n\r\n```\r\n>>> s.replace({\"\": pd.NA})\r\n0       a\r\n1    <NA>\r\n2       b\r\n3    <NA>\r\ndtype: object\r\n```\r\n\r\nbut as described in #35268, it changes the dtype of the Series from whatever it was to object.\r\n\r\nI'd (naively, perhaps) expect two-arg replace and one-dict-arg replace to both use the same codepath internally!\n\n> But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask?\r\n\r\nThis makes sense to me and matches my debugging. I'm testing this patch now:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..be1632315 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = (arr == x).fillna(False)\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= (arr == x).fillna(False)\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n\r\n```\r\n\n\nThe patch above doesn't work (unsurprisingly) because sometimes `arr` is a Pandas array and sometimes it's a NumPy array, but only Pandas arrays have a `fillna` method.\r\n\r\nThe patch below _seems_ to work with some manual testing and the result of `./test_fast.sh` is the same before/after applying it:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..f8280c0a2 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n```\r\n\r\nThis replaces `pd.NA` values with NumPy `NaN` and `NaT` values, which do compare with `==` correctly and produce a boolean vector instead of a boolean scalar.\r\n\r\nI want to write an actual set of tests cases for this bug for various dtypes though before submitting a PR. I believe the patch above may still fail for `pd.Period` types.\n\nHere is another example - at least I think it is the same bug:\r\n\r\n```import pandas as pd\r\nimport numpy as np\r\nseries1 = pd.Series([\"\"]).replace(\"\", np.nan) # works\r\nprint(series1.values)  # [nan]\r\nseries2 = pd.Series([\"\", pd.NA]).replace(\"\", np.nan) # fails\r\nprint(series2.values)  # ['' <NA>]\r\nseries3 = pd.Series([\"\", pd.NA]).replace(pd.NA, np.nan).replace(\"\", np.nan) # possible workaround\r\nprint(series3.values)  # [nan nan] \r\n```\r\n\r\nMaybe this would helps to fix the bug.\r\n\r\nIt would be great if you could fix the bug.\n\nThis works now, may need tests",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/51954",
  "code_context": [
    {
      "filename": "pandas/tests/frame/methods/test_replace.py",
      "content": "from __future__ import annotations\n\nfrom datetime import datetime\nimport re\n\nimport numpy as np\nimport pytest\n\nimport pandas as pd\nfrom pandas import (\n    DataFrame,\n    Index,\n    Series,\n    Timestamp,\n    date_range,\n)\nimport pandas._testing as tm\n\n\n@pytest.fixture\ndef mix_ab() -> dict[str, list[int | str]]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\")}\n\n\n@pytest.fixture\ndef mix_abc() -> dict[str, list[float | str]]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": [\"a\", \"b\", np.nan, \"d\"]}\n\n\nclass TestDataFrameReplace:\n    def test_replace_inplace(self, datetime_frame, float_string_frame):\n        datetime_frame.loc[datetime_frame.index[:5], \"A\"] = np.nan\n        datetime_frame.loc[datetime_frame.index[-5:], \"A\"] = np.nan\n\n        tsframe = datetime_frame.copy()\n        return_value = tsframe.replace(np.nan, 0, inplace=True)\n        assert return_value is None\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))\n\n        # mixed type\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, 0)\n        expected = float_string_frame.fillna(value=0)\n        tm.assert_frame_equal(result, expected)\n\n        tsframe = datetime_frame.copy()\n        return_value = tsframe.replace([np.nan], [0], inplace=True)\n        assert return_value is None\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))\n\n    @pytest.mark.parametrize(\n        \"to_replace,values,expected\",\n        [\n            # lists of regexes and values\n            # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n            (\n                [r\"\\s*\\.\\s*\", r\"e|f|g\"],\n                [np.nan, \"crap\"],\n                {\n                    \"a\": [\"a\", \"b\", np.nan, np.nan],\n                    \"b\": [\"crap\"] * 3 + [\"h\"],\n                    \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n                },\n            ),\n            # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n            (\n                [r\"\\s*(\\.)\\s*\", r\"(e|f|g)\"],\n                [r\"\\1\\1\", r\"\\1_crap\"],\n                {\n                    \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                    \"b\": [\"e_crap\", \"f_crap\", \"g_crap\", \"h\"],\n                    \"c\": [\"h\", \"e_crap\", \"l\", \"o\"],\n                },\n            ),\n            # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n            # or vN)]\n            (\n                [r\"\\s*(\\.)\\s*\", r\"e\"],\n                [r\"\\1\\1\", r\"crap\"],\n                {\n                    \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                    \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                    \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"inplace\", [True, False])\n    @pytest.mark.parametrize(\"use_value_regex_args\", [True, False])\n    def test_regex_replace_list_obj(\n        self, to_replace, values, expected, inplace, use_value_regex_args\n    ):\n        df = DataFrame({\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")})\n\n        if use_value_regex_args:\n            result = df.replace(value=values, regex=to_replace, inplace=inplace)\n        else:\n            result = df.replace(to_replace, values, regex=True, inplace=inplace)\n\n        if inplace:\n            assert result is None\n            result = df\n\n        expected = DataFrame(expected)\n        tm.assert_frame_equal(result, expected)\n\n    def test_regex_replace_list_mixed(self, mix_ab):\n        # mixed frame to make sure this doesn't break things\n        dfmix = DataFrame(mix_ab)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        mix2 = {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": list(\"halo\")}\n        dfmix2 = DataFrame(mix2)\n        res = dfmix2.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": mix2[\"a\"],\n                \"b\": [\"crap\", \"b\", np.nan, np.nan],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(regex=to_replace_res, value=values)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_list_mixed_inplace(self, mix_ab):\n        dfmix = DataFrame(mix_ab)\n        # the same inplace\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        res = dfmix.copy()\n        return_value = res.replace(to_replace_res, values, inplace=True, regex=True)\n        assert return_value is None\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b\", np.nan, np.nan]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        return_value = res.replace(to_replace_res, values, inplace=True, regex=True)\n        assert return_value is None\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        return_value = res.replace(to_replace_res, values, inplace=True, regex=True)\n        assert return_value is None\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        return_value = res.replace(regex=to_replace_res, value=values, inplace=True)\n        assert return_value is None\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n    def test_regex_replace_dict_mixed(self, mix_abc):\n        dfmix = DataFrame(mix_abc)\n\n        # dicts\n        # single dict {re1: v1}, search the whole frame\n        # need test for this...\n\n        # list of dicts {re1: v1, re2: v2, ..., re3: v3}, search the whole\n        # frame\n        res = dfmix.replace({\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        return_value = res2.replace(\n            {\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, inplace=True, regex=True\n        )\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # list of dicts {re1: re11, re2: re12, ..., reN: re1N}, search the\n        # whole frame\n        res = dfmix.replace({\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, regex=True)\n        res2 = dfmix.copy()\n        return_value = res2.replace(\n            {\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, inplace=True, regex=True\n        )\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"})\n        res2 = dfmix.copy()\n        return_value = res2.replace(\n            regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"}, inplace=True\n        )\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # scalar -> dict\n        # to_replace regex, {value: value}\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        return_value = res2.replace(\"a\", {\"b\": np.nan}, regex=True, inplace=True)\n        assert return_value is None\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        return_value = res2.replace(regex=\"a\", value={\"b\": np.nan}, inplace=True)\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n    def test_regex_replace_dict_nested(self, mix_abc):\n        # nested dicts will not work until this is implemented for Series\n        dfmix = DataFrame(mix_abc)\n        res = dfmix.replace({\"b\": {r\"\\s*\\.\\s*\": np.nan}}, regex=True)\n        res2 = dfmix.copy()\n        res4 = dfmix.copy()\n        return_value = res2.replace(\n            {\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True, regex=True\n        )\n        assert return_value is None\n        res3 = dfmix.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}})\n        return_value = res4.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True)\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n        tm.assert_frame_equal(res4, expec)\n\n    def test_regex_replace_dict_nested_non_first_character(self, any_string_dtype):\n        # GH 25259\n        dtype = any_string_dtype\n        df = DataFrame({\"first\": [\"abc\", \"bca\", \"cab\"]}, dtype=dtype)\n        expected = DataFrame({\"first\": [\".bc\", \"bc.\", \"c.b\"]}, dtype=dtype)\n        result = df.replace({\"a\": \".\"}, regex=True)\n        tm.assert_frame_equal(result, expected)\n\n    def test_regex_replace_dict_nested_gh4115(self):\n        df = DataFrame({\"Type\": [\"Q\", \"T\", \"Q\", \"Q\", \"T\"], \"tmp\": 2})\n        expected = DataFrame({\"Type\": [0, 1, 0, 0, 1], \"tmp\": 2})\n        result = df.replace({\"Type\": {\"Q\": 0, \"T\": 1}})\n        tm.assert_frame_equal(result, expected)\n\n    def test_regex_replace_list_to_scalar(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame(\n            {\n                \"a\": mix_abc[\"a\"],\n                \"b\": np.array([np.nan] * 4),\n                \"c\": [np.nan, np.nan, np.nan, \"d\"],\n            }\n        )\n        res = df.replace([r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True)\n        res2 = df.copy()\n        res3 = df.copy()\n        return_value = res2.replace(\n            [r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True, inplace=True\n        )\n        assert return_value is None\n        return_value = res3.replace(\n            regex=[r\"\\s*\\.\\s*\", \"a|b\"], value=np.nan, inplace=True\n        )\n        assert return_value is None\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_str_to_numeric(self, mix_abc):\n        # what happens when you try to replace a numeric value with a regex?\n        df = DataFrame(mix_abc)\n        res = df.replace(r\"\\s*\\.\\s*\", 0, regex=True)\n        res2 = df.copy()\n        return_value = res2.replace(r\"\\s*\\.\\s*\", 0, inplace=True, regex=True)\n        assert return_value is None\n        res3 = df.copy()\n        return_value = res3.replace(regex=r\"\\s*\\.\\s*\", value=0, inplace=True)\n        assert return_value is None\n        expec = DataFrame({\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", 0, 0], \"c\": mix_abc[\"c\"]})\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_regex_list_to_numeric(self, mix_abc):\n        df = DataFrame(mix_abc)\n        res = df.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True)\n        res2 = df.copy()\n        return_value = res2.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True, inplace=True)\n        assert return_value is None\n        res3 = df.copy()\n        return_value = res3.replace(regex=[r\"\\s*\\.\\s*\", \"b\"], value=0, inplace=True)\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", 0, 0, 0], \"c\": [\"a\", 0, np.nan, \"d\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_series_of_regexes(self, mix_abc):\n        df = DataFrame(mix_abc)\n        s1 = Series({\"b\": r\"\\s*\\.\\s*\"})\n        s2 = Series({\"b\": np.nan})\n        res = df.replace(s1, s2, regex=True)\n        res2 = df.copy()\n        return_value = res2.replace(s1, s2, inplace=True, regex=True)\n        assert return_value is None\n        res3 = df.copy()\n        return_value = res3.replace(regex=s1, value=s2, inplace=True)\n        assert return_value is None\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n\n    def test_regex_replace_numeric_to_object_conversion(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame({\"a\": [\"a\", 1, 2, 3], \"b\": mix_abc[\"b\"], \"c\": mix_abc[\"c\"]})\n        res = df.replace(0, \"a\")\n        tm.assert_frame_equal(res, expec)\n        assert res.a.dtype == np.object_\n\n    @pytest.mark.parametrize(\n        \"to_replace\", [{\"\": np.nan, \",\": \"\"}, {\",\": \"\", \"\": np.nan}]\n    )\n    def test_joint_simple_replace_and_regex_replace(self, to_replace):\n        # GH-39338\n        df = DataFrame(\n            {\n                \"col1\": [\"1,000\", \"a\", \"3\"],\n                \"col2\": [\"a\", \"\", \"b\"],\n                \"col3\": [\"a\", \"b\", \"c\"],\n            }\n        )\n        result = df.replace(regex=to_replace)\n        expected = DataFrame(\n            {\n                \"col1\": [\"1000\", \"a\", \"3\"],\n                \"col2\": [\"a\", np.nan, \"b\"],\n                \"col3\": [\"a\", \"b\", \"c\"],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\"metachar\", [\"[]\", \"()\", r\"\\d\", r\"\\w\", r\"\\s\"])\n    def test_replace_regex_metachar(self, metachar):\n        df = DataFrame({\"a\": [metachar, \"else\"]})\n        result = df.replace({\"a\": {metachar: \"paren\"}})\n        expected = DataFrame({\"a\": [\"paren\", \"else\"]})\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"data,to_replace,expected\",\n        [\n            ([\"xax\", \"xbx\"], {\"a\": \"c\", \"b\": \"d\"}, [\"xcx\", \"xdx\"]),\n            ([\"d\", \"\", \"\"], {r\"^\\s*$\": pd.NA}, [\"d\", pd.NA, pd.NA]),\n        ],\n    )\n    def test_regex_replace_string_types(\n        self, data, to_replace, expected, frame_or_series, any_string_dtype\n    ):\n        # GH-41333, GH-35977\n        dtype = any_string_dtype\n        obj = frame_or_series(data, dtype=dtype)\n        result = obj.replace(to_replace, regex=True)\n        expected = frame_or_series(expected, dtype=dtype)\n\n        tm.assert_equal(result, expected)\n\n    def test_replace(self, datetime_frame):\n        datetime_frame.loc[datetime_frame.index[:5], \"A\"] = np.nan\n        datetime_frame.loc[datetime_frame.index[-5:], \"A\"] = np.nan\n\n        zero_filled = datetime_frame.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, datetime_frame.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), datetime_frame)\n\n        datetime_frame.loc[datetime_frame.index[:5], \"A\"] = np.nan\n        datetime_frame.loc[datetime_frame.index[-5:], \"A\"] = np.nan\n        datetime_frame.loc[datetime_frame.index[:5], \"B\"] = -1e8\n\n        # empty\n        df = DataFrame(index=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, df.replace(5, 7))\n\n        # GH 11698\n        # test for mixed data types.\n        df = DataFrame(\n            [(\"-\", pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        df1 = df.replace(\"-\", np.nan)\n        expected_df = DataFrame(\n            [(np.nan, pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        tm.assert_frame_equal(df1, expected_df)\n\n    def test_replace_list(self):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [v1, v2, ..., vN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\".\", r\"e\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [v1, v2, ..., vN] -> [v1, v2, .., vN]\n        to_replace_res = [r\".\", r\"f\"]\n        values = [r\"..\", r\"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e\", \"crap\", \"g\", \"h\"],\n                \"c\": [\"h\", \"e\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n    def test_replace_with_empty_list(self, frame_or_series):\n        # GH 21977\n        ser = Series([[\"a\", \"b\"], [], np.nan, [1]])\n        obj = DataFrame({\"col\": ser})\n        obj = tm.get_obj(obj, frame_or_series)\n        expected = obj\n        result = obj.replace([], np.nan)\n        tm.assert_equal(result, expected)\n\n        # GH 19266\n        msg = (\n            \"NumPy boolean array indexing assignment cannot assign {size} \"\n            \"input values to the 1 output values where the mask is true\"\n        )\n        with pytest.raises(ValueError, match=msg.format(size=0)):\n            obj.replace({np.nan: []})\n        with pytest.raises(ValueError, match=msg.format(size=2)):\n            obj.replace({np.nan: [\"dummy\", \"alt\"]})\n\n    def test_replace_series_dict(self):\n        # from GH 3064\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        result = df.replace(0, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 1.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, df.mean())\n        tm.assert_frame_equal(result, expected)\n\n        # series to series/dict\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        s = Series({\"zero\": 0.0, \"one\": 2.0})\n        result = df.replace(s, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 1.0, \"b\": 0.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(s, df.mean())\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_convert(self):\n        # gh 3907\n        df = DataFrame([[\"foo\", \"bar\", \"bah\"], [\"bar\", \"foo\", \"bah\"]])\n        m = {\"foo\": 1, \"bar\": 2, \"bah\": 3}\n        rep = df.replace(m)\n        expec = Series([np.int64] * 3)\n        res = rep.dtypes\n        tm.assert_series_equal(expec, res)\n\n    def test_replace_mixed(self, float_string_frame):\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, -18)\n        expected = float_string_frame.fillna(value=-18)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-18, np.nan), float_string_frame)\n\n        result = float_string_frame.replace(np.nan, -1e8)\n        expected = float_string_frame.fillna(value=-1e8)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-1e8, np.nan), float_string_frame)\n\n    def test_replace_mixed_int_block_upcasting(self):\n        # int block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n        return_value = df.replace(0, 0.5, inplace=True)\n        assert return_value is None\n        tm.assert_frame_equal(df, expected)\n\n    def test_replace_mixed_int_block_splitting(self):\n        # int block splitting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_mixed2(self):\n        # to object block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1, \"foo\"], dtype=\"object\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(2, \"foo\")\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            {\n                \"A\": Series([\"foo\", \"bar\"], dtype=\"object\"),\n                \"B\": Series([0, \"foo\"], dtype=\"object\"),\n            }\n        )\n        result = df.replace([1, 2], [\"foo\", \"bar\"])\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_mixed3(self):\n        # test case from\n        df = DataFrame(\n            {\"A\": Series([3, 0], dtype=\"int64\"), \"B\": Series([0, 3], dtype=\"int64\")}\n        )\n        result = df.replace(3, df.mean().to_dict())\n        expected = df.copy().astype(\"float64\")\n        m = df.mean()\n        expected.iloc[0, 0] = m[0]\n        expected.iloc[1, 1] = m[1]\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_nullable_int_with_string_doesnt_cast(self):\n        # GH#25438 don't cast df['a'] to float64\n        df = DataFrame({\"a\": [1, 2, 3, np.nan], \"b\": [\"some\", \"strings\", \"here\", \"he\"]})\n        df[\"a\"] = df[\"a\"].astype(\"Int64\")\n\n        res = df.replace(\"\", np.nan)\n        tm.assert_series_equal(res[\"a\"], df[\"a\"])\n\n    @pytest.mark.parametrize(\"dtype\", [\"boolean\", \"Int64\", \"Float64\"])\n    def test_replace_with_nullable_column(self, dtype):\n        # GH-44499\n        nullable_ser = Series([1, 0, 1], dtype=dtype)\n        df = DataFrame({\"A\": [\"A\", \"B\", \"x\"], \"B\": nullable_ser})\n        result = df.replace(\"x\", \"X\")\n        expected = DataFrame({\"A\": [\"A\", \"B\", \"X\"], \"B\": nullable_ser})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_simple_nested_dict(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({\"col\": {1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)\n\n        # in this case, should be the same as the not nested version\n        result = df.replace({1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)\n\n    def test_replace_simple_nested_dict_with_nonexistent_value(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({-1: \"-\", 1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)\n\n        result = df.replace({\"col\": {-1: \"-\", 1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)\n\n    def test_replace_NA_with_None(self):\n        # gh-45601\n        df = DataFrame({\"value\": [42, None]}).astype({\"value\": \"Int64\"})\n        result = df.replace({pd.NA: None})\n        expected = DataFrame({\"value\": [42, None]}, dtype=object)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_NAT_with_None(self):\n        # gh-45836\n        df = DataFrame([pd.NaT, pd.NaT])\n        result = df.replace({pd.NaT: None, np.NaN: None})\n        expected = DataFrame([None, None])\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_None_keeps_categorical(self):\n        # gh-46634\n        cat_series = Series([\"b\", \"b\", \"b\", \"d\"], dtype=\"category\")\n        df = DataFrame(\n            {\n                \"id\": Series([5, 4, 3, 2], dtype=\"float64\"),\n                \"col\": cat_series,\n            }\n        )\n        result = df.replace({3: None})\n\n        expected = DataFrame(\n            {\n                \"id\": Series([5.0, 4.0, None, 2.0], dtype=\"object\"),\n                \"col\": cat_series,\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_value_is_none(self, datetime_frame):\n        orig_value = datetime_frame.iloc[0, 0]\n        orig2 = datetime_frame.iloc[1, 0]\n\n        datetime_frame.iloc[0, 0] = np.nan\n        datetime_frame.iloc[1, 0] = 1\n\n        result = datetime_frame.replace(to_replace={np.nan: 0})\n        expected = datetime_frame.T.replace(to_replace={np.nan: 0}).T\n        tm.assert_frame_equal(result, expected)\n\n        result = datetime_frame.replace(to_replace={np.nan: 0, 1: -1e8})\n        tsframe = datetime_frame.copy()\n        tsframe.iloc[0, 0] = 0\n        tsframe.iloc[1, 0] = -1e8\n        expected = tsframe\n        tm.assert_frame_equal(expected, result)\n        datetime_frame.iloc[0, 0] = orig_value\n        datetime_frame.iloc[1, 0] = orig2\n\n    def test_replace_for_new_dtypes(self, datetime_frame):\n        # dtypes\n        tsframe = datetime_frame.copy().astype(np.float32)\n        tsframe.loc[tsframe.index[:5], \"A\"] = np.nan\n        tsframe.loc[tsframe.index[-5:], \"A\"] = np.nan\n\n        zero_filled = tsframe.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, tsframe.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), tsframe)\n\n        tsframe.loc[tsframe.index[:5], \"A\"] = np.nan\n        tsframe.loc[tsframe.index[-5:], \"A\"] = np.nan\n        tsframe.loc[tsframe.index[:5], \"B\"] = -1e8\n\n        b = tsframe[\"B\"]\n        b[b == -1e8] = np.nan\n        tsframe[\"B\"] = b\n        result = tsframe.fillna(method=\"bfill\")\n        tm.assert_frame_equal(result, tsframe.fillna(method=\"bfill\"))\n\n    @pytest.mark.parametrize(\n        \"frame, to_replace, value, expected\",\n        [\n            (DataFrame({\"ints\": [1, 2, 3]}), 1, 0, DataFrame({\"ints\": [0, 2, 3]})),\n            (\n                DataFrame({\"ints\": [1, 2, 3]}, dtype=np.int32),\n                1,\n                0,\n                DataFrame({\"ints\": [0, 2, 3]}, dtype=np.int32),\n            ),\n            (\n                DataFrame({\"ints\": [1, 2, 3]}, dtype=np.int16),\n                1,\n                0,\n                DataFrame({\"ints\": [0, 2, 3]}, dtype=np.int16),\n            ),\n            (\n                DataFrame({\"bools\": [True, False, True]}),\n                False,\n                True,\n                DataFrame({\"bools\": [True, True, True]}),\n            ),\n            (\n                DataFrame({\"complex\": [1j, 2j, 3j]}),\n                1j,\n                0,\n                DataFrame({\"complex\": [0j, 2j, 3j]}),\n            ),\n            (\n                DataFrame(\n                    {\n                        \"datetime64\": Index(\n                            [\n                                datetime(2018, 5, 28),\n                                datetime(2018, 7, 28),\n                                datetime(2018, 5, 28),\n                            ]\n                        )\n                    }\n                ),\n                datetime(2018, 5, 28),\n                datetime(2018, 7, 28),\n                DataFrame({\"datetime64\": Index([datetime(2018, 7, 28)] * 3)}),\n            ),\n            # GH 20380\n            (\n                DataFrame({\"dt\": [datetime(3017, 12, 20)], \"str\": [\"foo\"]}),\n                \"foo\",\n                \"bar\",\n                DataFrame({\"dt\": [datetime(3017, 12, 20)], \"str\": [\"bar\"]}),\n            ),\n            # GH 36782\n            (\n                DataFrame({\"dt\": [datetime(2920, 10, 1)]}),\n                datetime(2920, 10, 1),\n                datetime(2020, 10, 1),\n                DataFrame({\"dt\": [datetime(2020, 10, 1)]}),\n            ),\n            (\n                DataFrame(\n                    {\n                        \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                        \"B\": [0, np.nan, 2],\n                    }\n                ),\n                Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                DataFrame(\n                    {\n                        \"A\": [\n                            Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                            Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                            Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                        ],\n                        \"B\": [0, np.nan, 2],\n                    }\n                ),\n            ),\n            # GH 35376\n            (\n                DataFrame([[1, 1.0], [2, 2.0]]),\n                1.0,\n                5,\n                DataFrame([[5, 5.0], [2, 2.0]]),\n            ),\n            (\n                DataFrame([[1, 1.0], [2, 2.0]]),\n                1,\n                5,\n                DataFrame([[5, 5.0], [2, 2.0]]),\n            ),\n            (\n                DataFrame([[1, 1.0], [2, 2.0]]),\n                1.0,\n                5.0,\n                DataFrame([[5, 5.0], [2, 2.0]]),\n            ),\n            (\n                DataFrame([[1, 1.0], [2, 2.0]]),\n                1,\n                5.0,\n                DataFrame([[5, 5.0], [2, 2.0]]),\n            ),\n        ],\n    )\n    def test_replace_dtypes(self, frame, to_replace, value, expected):\n        result = frame.replace(to_replace, value)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_input_formats_listlike(self):\n        # both dicts\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(to_rep, values)\n        expected = {k: v.replace(to_rep[k], values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        result = df.replace([0, 2, 5], [5, 2, 0])\n        expected = DataFrame(\n            {\"A\": [np.nan, 5, np.inf], \"B\": [5, 2, 0], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # scalar to dict\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.nan], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(np.nan, values)\n        expected = {k: v.replace(np.nan, values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        # list to list\n        to_rep = [np.nan, 0, \"\"]\n        values = [-2, -1, \"missing\"]\n        result = df.replace(to_rep, values)\n        expected = df.copy()\n        for rep, value in zip(to_rep, values):\n            return_value = expected.replace(rep, value, inplace=True)\n            assert return_value is None\n        tm.assert_frame_equal(result, expected)\n\n        msg = r\"Replacement lists must match in length\\. Expecting 3 got 2\"\n        with pytest.raises(ValueError, match=msg):\n            df.replace(to_rep, values[1:])\n\n    def test_replace_input_formats_scalar(self):\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n\n        # dict to scalar\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        filled = df.replace(to_rep, 0)\n        expected = {k: v.replace(to_rep[k], 0) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        msg = \"value argument must be scalar, dict, or Series\"\n        with pytest.raises(TypeError, match=msg):\n            df.replace(to_rep, [np.nan, 0, \"\"])\n\n        # list to scalar\n        to_rep = [np.nan, 0, \"\"]\n        result = df.replace(to_rep, -1)\n        expected = df.copy()\n        for rep in to_rep:\n            return_value = expected.replace(rep, -1, inplace=True)\n            assert return_value is None\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_limit(self):\n        # TODO\n        pass\n\n    def test_replace_dict_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = {\n            \"Agree\": 4,\n            \"Disagree\": 2,\n            \"Neutral\": 3,\n            \"Strongly Agree\": 5,\n            \"Strongly Disagree\": 1,\n        }\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)\n\n    def test_replace_series_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = Series(\n            {\n                \"Agree\": 4,\n                \"Disagree\": 2,\n                \"Neutral\": 3,\n                \"Strongly Agree\": 5,\n                \"Strongly Disagree\": 1,\n            }\n        )\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)\n\n    def test_replace_dict_tuple_list_ordering_remains_the_same(self):\n        df = DataFrame({\"A\": [np.nan, 1]})\n        res1 = df.replace(to_replace={np.nan: 0, 1: -1e8})\n        res2 = df.replace(to_replace=(1, np.nan), value=[-1e8, 0])\n        res3 = df.replace(to_replace=[1, np.nan], value=[-1e8, 0])\n\n        expected = DataFrame({\"A\": [0, -1e8]})\n        tm.assert_frame_equal(res1, res2)\n        tm.assert_frame_equal(res2, res3)\n        tm.assert_frame_equal(res3, expected)\n\n    def test_replace_doesnt_replace_without_regex(self):\n        df = DataFrame(\n            {\n                \"fol\": [1, 2, 2, 3],\n                \"T_opp\": [\"0\", \"vr\", \"0\", \"0\"],\n                \"T_Dir\": [\"0\", \"0\", \"0\", \"bt\"],\n                \"T_Enh\": [\"vo\", \"0\", \"0\", \"0\"],\n            }\n        )\n        res = df.replace({r\"\\D\": 1})\n        tm.assert_frame_equal(df, res)\n\n    def test_replace_bool_with_string(self):\n        df = DataFrame({\"a\": [True, False], \"b\": list(\"ab\")})\n        result = df.replace(True, \"a\")\n        expected = DataFrame({\"a\": [\"a\", False], \"b\": df.b})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_pure_bool_with_string_no_op(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(\"asdf\", \"fdsa\")\n        tm.assert_frame_equal(df, result)\n\n    def test_replace_bool_with_bool(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(False, True)\n        expected = DataFrame(np.ones((2, 2), dtype=bool))\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_dict_with_bool_keys(self):\n        df = DataFrame({0: [True, False], 1: [False, True]})\n        result = df.replace({\"asdf\": \"asdb\", True: \"yes\"})\n        expected = DataFrame({0: [\"yes\", False], 1: [False, \"yes\"]})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_dict_strings_vs_ints(self):\n        # GH#34789\n        df = DataFrame({\"Y0\": [1, 2], \"Y1\": [3, 4]})\n        result = df.replace({\"replace_string\": \"test\"})\n\n        tm.assert_frame_equal(result, df)\n\n        result = df[\"Y0\"].replace({\"replace_string\": \"test\"})\n        tm.assert_series_equal(result, df[\"Y0\"])\n\n    def test_replace_truthy(self):\n        df = DataFrame({\"a\": [True, True]})\n        r = df.replace([np.inf, -np.inf], np.nan)\n        e = df\n        tm.assert_frame_equal(r, e)\n\n    def test_nested_dict_overlapping_keys_replace_int(self):\n        # GH 27660 keep behaviour consistent for simple dictionary and\n        # nested dictionary replacement\n        df = DataFrame({\"a\": list(range(1, 5))})\n\n        result = df.replace({\"a\": dict(zip(range(1, 5), range(2, 6)))})\n        expected = df.replace(dict(zip(range(1, 5), range(2, 6))))\n        tm.assert_frame_equal(result, expected)\n\n    def test_nested_dict_overlapping_keys_replace_str(self):\n        # GH 27660\n        a = np.arange(1, 5)\n        astr = a.astype(str)\n        bstr = np.arange(2, 6).astype(str)\n        df = DataFrame({\"a\": astr})\n        result = df.replace(dict(zip(astr, bstr)))\n        expected = df.replace({\"a\": dict(zip(astr, bstr))})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_swapping_bug(self):\n        df = DataFrame({\"a\": [True, False, True]})\n        res = df.replace({\"a\": {True: \"Y\", False: \"N\"}})\n        expect = DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)\n\n        df = DataFrame({\"a\": [0, 1, 0]})\n        res = df.replace({\"a\": {0: \"Y\", 1: \"N\"}})\n        expect = DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)\n\n    def test_replace_period(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": pd.Period(year=2011, month=8, freq=\"M\"),\n                \"out_augmented_JAN_2011.json\": pd.Period(year=2011, month=1, freq=\"M\"),\n                \"out_augmented_MAY_2012.json\": pd.Period(year=2012, month=5, freq=\"M\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": pd.Period(\n                    year=2011, month=4, freq=\"M\"\n                ),\n                \"out_augmented_AUG_2012.json\": pd.Period(year=2012, month=8, freq=\"M\"),\n                \"out_augmented_MAY_2011.json\": pd.Period(year=2011, month=5, freq=\"M\"),\n                \"out_augmented_SEP_2013.json\": pd.Period(year=2013, month=9, freq=\"M\"),\n            }\n        }\n\n        df = DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n\n        expected = DataFrame({\"fname\": [d[\"fname\"][k] for k in df.fname.values]})\n        assert expected.dtypes[0] == \"Period[M]\"\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_datetime(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": Timestamp(\"2011-08\"),\n                \"out_augmented_JAN_2011.json\": Timestamp(\"2011-01\"),\n                \"out_augmented_MAY_2012.json\": Timestamp(\"2012-05\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": Timestamp(\"2011-04\"),\n                \"out_augmented_AUG_2012.json\": Timestamp(\"2012-08\"),\n                \"out_augmented_MAY_2011.json\": Timestamp(\"2011-05\"),\n                \"out_augmented_SEP_2013.json\": Timestamp(\"2013-09\"),\n            }\n        }\n\n        df = DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n        expected = DataFrame({\"fname\": [d[\"fname\"][k] for k in df.fname.values]})\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_datetimetz(self):\n        # GH 11326\n        # behaving poorly when presented with a datetime64[ns, tz]\n        df = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        result = df.replace(np.nan, 1)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": Series([0, 1, 2], dtype=\"float64\"),\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.fillna(1)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, np.nan)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [np.nan, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(\n            Timestamp(\"20130102\", tz=\"US/Eastern\"),\n            Timestamp(\"20130104\", tz=\"US/Eastern\"),\n        )\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Eastern\"))\n        tm.assert_frame_equal(result, expected)\n\n        # pre-2.0 this would coerce to object with mismatched tzs\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Pacific\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Pacific\").tz_convert(\"US/Eastern\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": np.nan}, Timestamp(\"20130104\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_empty_dictlike(self, mix_abc):\n        # GH 15289\n        df = DataFrame(mix_abc)\n        tm.assert_frame_equal(df, df.replace({}))\n        tm.assert_frame_equal(df, df.replace(Series([], dtype=object)))\n\n        tm.assert_frame_equal(df, df.replace({\"b\": {}}))\n        tm.assert_frame_equal(df, df.replace(Series({\"b\": {}})))\n\n    @pytest.mark.parametrize(\n        \"to_replace, method, expected\",\n        [\n            (0, \"bfill\", {\"A\": [1, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]}),\n            (\n                np.nan,\n                \"bfill\",\n                {\"A\": [0, 1, 2], \"B\": [5.0, 7.0, 7.0], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\"d\", \"ffill\", {\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]}),\n            (\n                [0, 2],\n                \"bfill\",\n                {\"A\": [1, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                [1, 2],\n                \"pad\",\n                {\"A\": [0, 0, 0], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                (1, 2),\n                \"bfill\",\n                {\"A\": [0, 2, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]},\n            ),\n            (\n                [\"b\", \"c\"],\n                \"ffill\",\n                {\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"a\", \"a\"]},\n            ),\n        ],\n    )\n    def test_replace_method(self, to_replace, method, expected):\n        # GH 19632\n        df = DataFrame({\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]})\n\n        result = df.replace(to_replace=to_replace, value=None, method=method)\n        expected = DataFrame(expected)\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n\n        final_data = np.array(final_data)\n\n        a = pd.Categorical(final_data[:, 0], categories=[3, 2])\n\n        ex_cat = [3, 2] if replace_dict[\"b\"] == 1 else [1, 3]\n        b = pd.Categorical(final_data[:, 1], categories=ex_cat)\n\n        expected = DataFrame({\"a\": a, \"b\": b})\n        result = df.replace(replace_dict, 3)\n        tm.assert_frame_equal(result, expected)\n        msg = (\n            r\"Attributes of DataFrame.iloc\\[:, 0\\] \\(column name=\\\"a\\\"\\) are \"\n            \"different\"\n        )\n        with pytest.raises(AssertionError, match=msg):\n            # ensure non-inplace call does not affect original\n            tm.assert_frame_equal(df, expected)\n        return_value = df.replace(replace_dict, 3, inplace=True)\n        assert return_value is None\n        tm.assert_frame_equal(df, expected)\n\n    @pytest.mark.parametrize(\n        \"df, to_replace, exp\",\n        [\n            (\n                {\"col1\": [1, 2, 3], \"col2\": [4, 5, 6]},\n                {4: 5, 5: 6, 6: 7},\n                {\"col1\": [1, 2, 3], \"col2\": [5, 6, 7]},\n            ),\n            (\n                {\"col1\": [1, 2, 3], \"col2\": [\"4\", \"5\", \"6\"]},\n                {\"4\": \"5\", \"5\": \"6\", \"6\": \"7\"},\n                {\"col1\": [1, 2, 3], \"col2\": [\"5\", \"6\", \"7\"]},\n            ),\n        ],\n    )\n    def test_replace_commutative(self, df, to_replace, exp):\n        # GH 16051\n        # DataFrame.replace() overwrites when values are non-numeric\n        # also added to data frame whilst issue was for series\n\n        df = DataFrame(df)\n\n        expected = DataFrame(exp)\n        result = df.replace(to_replace)\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\n        \"replacer\",\n        [\n            Timestamp(\"20170827\"),\n            np.int8(1),\n            np.int16(1),\n            np.float32(1),\n            np.float64(1),\n        ],\n    )\n    def test_replace_replacer_dtype(self, request, replacer):\n        # GH26632\n        df = DataFrame([\"a\"])\n        result = df.replace({\"a\": replacer, \"b\": replacer})\n        expected = DataFrame([replacer])\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_after_convert_dtypes(self):\n        # GH31517\n        df = DataFrame({\"grp\": [1, 2, 3, 4, 5]}, dtype=\"Int64\")\n        result = df.replace(1, 10)\n        expected = DataFrame({\"grp\": [10, 2, 3, 4, 5]}, dtype=\"Int64\")\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_invalid_to_replace(self):\n        # GH 18634\n        # API: replace() should raise an exception if invalid argument is given\n        df = DataFrame({\"one\": [\"a\", \"b \", \"c\"], \"two\": [\"d \", \"e \", \"f \"]})\n        msg = (\n            r\"Expecting 'to_replace' to be either a scalar, array-like, \"\n            r\"dict or None, got invalid type.*\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.replace(lambda x: x.strip())\n\n    @pytest.mark.parametrize(\"dtype\", [\"float\", \"float64\", \"int64\", \"Int64\", \"boolean\"])\n    @pytest.mark.parametrize(\"value\", [np.nan, pd.NA])\n    def test_replace_no_replacement_dtypes(self, dtype, value):\n        # https://github.com/pandas-dev/pandas/issues/32988\n        df = DataFrame(np.eye(2), dtype=dtype)\n        result = df.replace(to_replace=[None, -np.inf, np.inf], value=value)\n        tm.assert_frame_equal(result, df)\n\n    @pytest.mark.parametrize(\"replacement\", [np.nan, 5])\n    def test_replace_with_duplicate_columns(self, replacement):\n        # GH 24798\n        result = DataFrame({\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [7, 8, 9]})\n        result.columns = list(\"AAB\")\n\n        expected = DataFrame(\n            {\"A\": [1, 2, 3], \"A1\": [4, 5, 6], \"B\": [replacement, 8, 9]}\n        )\n        expected.columns = list(\"AAB\")\n\n        result[\"B\"] = result[\"B\"].replace(7, replacement)\n\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\"value\", [pd.Period(\"2020-01\"), pd.Interval(0, 5)])\n    def test_replace_ea_ignore_float(self, frame_or_series, value):\n        # GH#34871\n        obj = DataFrame({\"Per\": [value] * 3})\n        obj = tm.get_obj(obj, frame_or_series)\n\n        expected = obj.copy()\n        result = obj.replace(1.0, 0.0)\n        tm.assert_equal(expected, result)\n\n    def test_replace_value_category_type(self):\n        \"\"\"\n        Test for #23305: to ensure category dtypes are maintained\n        after replace with direct values\n        \"\"\"\n\n        # create input data\n        input_dict = {\n            \"col1\": [1, 2, 3, 4],\n            \"col2\": [\"a\", \"b\", \"c\", \"d\"],\n            \"col3\": [1.5, 2.5, 3.5, 4.5],\n            \"col4\": [\"cat1\", \"cat2\", \"cat3\", \"cat4\"],\n            \"col5\": [\"obj1\", \"obj2\", \"obj3\", \"obj4\"],\n        }\n        # explicitly cast columns as category and order them\n        input_df = DataFrame(data=input_dict).astype(\n            {\"col2\": \"category\", \"col4\": \"category\"}\n        )\n        input_df[\"col2\"] = input_df[\"col2\"].cat.reorder_categories(\n            [\"a\", \"b\", \"c\", \"d\"], ordered=True\n        )\n        input_df[\"col4\"] = input_df[\"col4\"].cat.reorder_categories(\n            [\"cat1\", \"cat2\", \"cat3\", \"cat4\"], ordered=True\n        )\n\n        # create expected dataframe\n        expected_dict = {\n            \"col1\": [1, 2, 3, 4],\n            \"col2\": [\"a\", \"b\", \"c\", \"z\"],\n            \"col3\": [1.5, 2.5, 3.5, 4.5],\n            \"col4\": [\"cat1\", \"catX\", \"cat3\", \"cat4\"],\n            \"col5\": [\"obj9\", \"obj2\", \"obj3\", \"obj4\"],\n        }\n        # explicitly cast columns as category and order them\n        expected = DataFrame(data=expected_dict).astype(\n            {\"col2\": \"category\", \"col4\": \"category\"}\n        )\n        expected[\"col2\"] = expected[\"col2\"].cat.reorder_categories(\n            [\"a\", \"b\", \"c\", \"z\"], ordered=True\n        )\n        expected[\"col4\"] = expected[\"col4\"].cat.reorder_categories(\n            [\"cat1\", \"catX\", \"cat3\", \"cat4\"], ordered=True\n        )\n\n        # replace values in input dataframe\n        input_df = input_df.replace(\"d\", \"z\")\n        input_df = input_df.replace(\"obj1\", \"obj9\")\n        result = input_df.replace(\"cat2\", \"catX\")\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_dict_category_type(self):\n        \"\"\"\n        Test to ensure category dtypes are maintained\n        after replace with dict values\n        \"\"\"\n        # GH#35268, GH#44940\n\n        # create input dataframe\n        input_dict = {\"col1\": [\"a\"], \"col2\": [\"obj1\"], \"col3\": [\"cat1\"]}\n        # explicitly cast columns as category\n        input_df = DataFrame(data=input_dict).astype(\n            {\"col1\": \"category\", \"col2\": \"category\", \"col3\": \"category\"}\n        )\n\n        # create expected dataframe\n        expected_dict = {\"col1\": [\"z\"], \"col2\": [\"obj9\"], \"col3\": [\"catX\"]}\n        # explicitly cast columns as category\n        expected = DataFrame(data=expected_dict).astype(\n            {\"col1\": \"category\", \"col2\": \"category\", \"col3\": \"category\"}\n        )\n\n        # replace values in input dataframe using a dict\n        result = input_df.replace({\"a\": \"z\", \"obj1\": \"obj9\", \"cat1\": \"catX\"})\n\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_compiled_regex(self):\n        # https://github.com/pandas-dev/pandas/issues/35680\n        df = DataFrame([\"a\", \"b\", \"c\"])\n        regex = re.compile(\"^a$\")\n        result = df.replace({regex: \"z\"}, regex=True)\n        expected = DataFrame([\"z\", \"b\", \"c\"])\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_intervals(self):\n        # https://github.com/pandas-dev/pandas/issues/35931\n        df = DataFrame({\"a\": [pd.Interval(0, 1), pd.Interval(0, 1)]})\n        result = df.replace({\"a\": {pd.Interval(0, 1): \"x\"}})\n        expected = DataFrame({\"a\": [\"x\", \"x\"]})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_unicode(self):\n        # GH: 16784\n        columns_values_map = {\"positive\": {\"正面\": 1, \"中立\": 1, \"负面\": 0}}\n        df1 = DataFrame({\"positive\": np.ones(3)})\n        result = df1.replace(columns_values_map)\n        expected = DataFrame({\"positive\": np.ones(3)})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_bytes(self, frame_or_series):\n        # GH#38900\n        obj = frame_or_series([\"o\"]).astype(\"|S\")\n        expected = obj.copy()\n        obj = obj.replace({None: np.nan})\n        tm.assert_equal(obj, expected)\n\n    @pytest.mark.parametrize(\n        \"data, to_replace, value, expected\",\n        [\n            ([1], [1.0], [0], [0]),\n            ([1], [1], [0], [0]),\n            ([1.0], [1.0], [0], [0.0]),\n            ([1.0], [1], [0], [0.0]),\n        ],\n    )\n    @pytest.mark.parametrize(\"box\", [list, tuple, np.array])\n    def test_replace_list_with_mixed_type(\n        self, data, to_replace, value, expected, box, frame_or_series\n    ):\n        # GH#40371\n        obj = frame_or_series(data)\n        expected = frame_or_series(expected)\n        result = obj.replace(box(to_replace), value)\n        tm.assert_equal(result, expected)\n\n    @pytest.mark.parametrize(\"val\", [2, np.nan, 2.0])\n    def test_replace_value_none_dtype_numeric(self, val):\n        # GH#48231\n        df = DataFrame({\"a\": [1, val]})\n        result = df.replace(val, None)\n        expected = DataFrame({\"a\": [1, None]}, dtype=object)\n        tm.assert_frame_equal(result, expected)\n\n        df = DataFrame({\"a\": [1, val]})\n        result = df.replace({val: None})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_with_nil_na(self):\n        # GH 32075\n        ser = DataFrame({\"a\": [\"nil\", pd.NA]})\n        expected = DataFrame({\"a\": [\"anything else\", pd.NA]}, index=[0, 1])\n        result = ser.replace(\"nil\", \"anything else\")\n        tm.assert_frame_equal(expected, result)\n\n\nclass TestDataFrameReplaceRegex:\n    @pytest.mark.parametrize(\n        \"data\",\n        [\n            {\"a\": list(\"ab..\"), \"b\": list(\"efgh\")},\n            {\"a\": list(\"ab..\"), \"b\": list(range(4))},\n        ],\n    )\n    @pytest.mark.parametrize(\n        \"to_replace,value\", [(r\"\\s*\\.\\s*\", np.nan), (r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\")]\n    )\n    @pytest.mark.parametrize(\"compile_regex\", [True, False])\n    @pytest.mark.parametrize(\"regex_kwarg\", [True, False])\n    @pytest.mark.parametrize(\"inplace\", [True, False])\n    def test_regex_replace_scalar(\n        self, data, to_replace, value, compile_regex, regex_kwarg, inplace\n    ):\n        df = DataFrame(data)\n        expected = df.copy()\n\n        if compile_regex:\n            to_replace = re.compile(to_replace)\n\n        if regex_kwarg:\n            regex = to_replace\n            to_replace = None\n        else:\n            regex = True\n\n        result = df.replace(to_replace, value, inplace=inplace, regex=regex)\n\n        if inplace:\n            assert result is None\n            result = df\n\n        if value is np.nan:\n            expected_replace_val = np.nan\n        else:\n            expected_replace_val = \"...\"\n\n        expected.loc[expected[\"a\"] == \".\", \"a\"] = expected_replace_val\n        tm.assert_frame_equal(result, expected)\n\n    @pytest.mark.parametrize(\"regex\", [False, True])\n    def test_replace_regex_dtype_frame(self, regex):\n        # GH-48644\n        df1 = DataFrame({\"A\": [\"0\"], \"B\": [\"0\"]})\n        expected_df1 = DataFrame({\"A\": [1], \"B\": [1]})\n        result_df1 = df1.replace(to_replace=\"0\", value=1, regex=regex)\n        tm.assert_frame_equal(result_df1, expected_df1)\n\n        df2 = DataFrame({\"A\": [\"0\"], \"B\": [\"1\"]})\n        expected_df2 = DataFrame({\"A\": [1], \"B\": [\"1\"]})\n        result_df2 = df2.replace(to_replace=\"0\", value=1, regex=regex)\n        tm.assert_frame_equal(result_df2, expected_df2)\n\n    def test_replace_with_value_also_being_replaced(self):\n        # GH46306\n        df = DataFrame({\"A\": [0, 1, 2], \"B\": [1, 0, 2]})\n        result = df.replace({0: 1, 1: np.nan})\n        expected = DataFrame({\"A\": [1, np.nan, 2], \"B\": [np.nan, 1, 2]})\n        tm.assert_frame_equal(result, expected)\n\n    def test_replace_categorical_no_replacement(self):\n        # GH#46672\n        df = DataFrame(\n            {\n                \"a\": [\"one\", \"two\", None, \"three\"],\n                \"b\": [\"one\", None, \"two\", \"three\"],\n            },\n            dtype=\"category\",\n        )\n        expected = df.copy()\n\n        result = df.replace(to_replace=[\".\", \"def\"], value=[\"_\", None])\n        tm.assert_frame_equal(result, expected)\n"
    }
  ],
  "questions": [
    "Thanks @tsoernes \r\n\r\nCould you include a [minimal reproducible example](https://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports)? I couldn't reproduce this\r\n```\r\nIn [1]: import pandas as pd                                                                                                                                                                                      \r\nIn [2]: ser = pd.DataFrame({'a': ['nil']})                                                                                                                                                                       \r\n\r\nIn [3]: ser                                                                                                                                                                                                      \r\nOut[3]: \r\n     a\r\n0  nil\r\n\r\nIn [4]: ser.replace('nil', pd.NA)                                                                                                                                                                                \r\nOut[4]: \r\n      a\r\n0  <NA>\r\n\r\nIn [5]: ser.replace('nil', pd.NA).eq('nil').sum()                                                                                                                                                                \r\nOut[5]: \r\na    0\r\ndtype: int64\r\n```",
    "@MarcoGorelli \r\nIs there any particular approach here you could suggest to fix the bug? There is no issue when using `np.nan`, not `pd.NA`.\r\n```\r\n>>> np.array([['nil', np.nan]]) == 'nil'\r\narray([[ True, False]])\r\n```",
    "Hi Anna - gonna be honest, I don't know :) I had a quick go at this one but\ncouldn't figure it out. If you have any specific questions I'd imagine you\ncould tag one of the core team members (e.g. Tom Augspurger) and ask.\n\nOn Tue, 3 Mar 2020 13:59 Anna Daglis, <notifications@github.com> wrote:\n\n> @MarcoGorelli <https://github.com/MarcoGorelli>\n>\n> Is there any particular approach here you could suggest to fix the bug?\n> There is no issue when using np.nan, not pd.NA.\n>\n> >>> np.array([['nil', np.nan]]) == 'nil'\n> array([[ True, False]])\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/32075?email_source=notifications&email_token=AH7QVMAQXWDFDIOEHDX3T7TRFUENRA5CNFSM4KXDNN42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENTSZQI#issuecomment-593964225>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AH7QVMHQJKUXY46CWPZW2NDRFUENRANCNFSM4KXDNN4Q>\n> .\n>",
    "The problem in this case lies in `pandas.core.missing`, `mask_missing(arr, values_to_mask)`  function, the following clause:\r\n\r\n```\r\nif is_numeric_v_string_like(arr, x):\r\n    # GH#29553 prevent numpy deprecation warnings\r\n    mask = False\r\nelse:\r\n    mask = arr == x\r\n```\r\n\r\nThe problem arises here `arr == x`, which fails when `arr` contains ``pd.NA``, as pointed out above. \r\n\r\n@TomAugspurger @jorisvandenbossche \r\nDo you have any suggestions how to tackle this bug? I noticed that handling ``pd.NA`` behaviour has been discussed in other issues, e.g. this one: https://github.com/pandas-dev/pandas/issues/32265",
    "I'm not sure offhand, sorry. But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask? Some of the methods in `core.arrays.boolean` may be helpful to look through.",
    "> But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask?\r\n\r\nThis makes sense to me and matches my debugging. I'm testing this patch now:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..be1632315 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = (arr == x).fillna(False)\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= (arr == x).fillna(False)\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n\r\n```"
  ],
  "golden_answers": [
    "@MarcoGorelli \r\n\r\nIn the following example, I extract out two rows from the dataframe and recreate it via a dict.\r\nThe first row has a 'nil' in the 'amount' column; the second row has no 'nil'. \r\nIf I only recreate the dataframe with the first row, then the problem does not show itself.\r\nWhen going via JSON, the problem does not persist.\r\n\r\n```python\r\n\r\nIn [282]: di = df.loc[[26123, 26122]].to_dict()\r\n\r\nIn [283]: di\r\nOut[283]: \r\n<redacted since problem isolated later in thread>\r\n\r\nIn [284]: df = pd.DataFrame.from_dict(di)\r\n\r\nIn [285]: df.eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[285]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\nIn [286]: df.replace('nil', pd.NA).eq('nil').sum()\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/missing.py:47: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  mask = arr == x\r\n/home/torstein/anaconda3/lib/python3.7/site-packages/pandas/core/ops/array_ops.py:253: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  res_values = method(rvalues)\r\nOut[289]: \r\nid                  0\r\nproperties          0\r\nurl                 0\r\nstarted_at          0\r\nended_at            0\r\ninvestee_id         0\r\nlead_investor_id    0\r\ncreated_at          0\r\nupdated_at          0\r\nround               0\r\namount              1\r\ncurrency            0\r\ndtype: int64\r\n\r\n```",
    "The problem in this case lies in `pandas.core.missing`, `mask_missing(arr, values_to_mask)`  function, the following clause:\r\n\r\n```\r\nif is_numeric_v_string_like(arr, x):\r\n    # GH#29553 prevent numpy deprecation warnings\r\n    mask = False\r\nelse:\r\n    mask = arr == x\r\n```\r\n\r\nThe problem arises here `arr == x`, which fails when `arr` contains ``pd.NA``, as pointed out above. \r\n\r\n@TomAugspurger @jorisvandenbossche \r\nDo you have any suggestions how to tackle this bug? I noticed that handling ``pd.NA`` behaviour has been discussed in other issues, e.g. this one: https://github.com/pandas-dev/pandas/issues/32265",
    "The problem in this case lies in `pandas.core.missing`, `mask_missing(arr, values_to_mask)`  function, the following clause:\r\n\r\n```\r\nif is_numeric_v_string_like(arr, x):\r\n    # GH#29553 prevent numpy deprecation warnings\r\n    mask = False\r\nelse:\r\n    mask = arr == x\r\n```\r\n\r\nThe problem arises here `arr == x`, which fails when `arr` contains ``pd.NA``, as pointed out above. \r\n\r\n@TomAugspurger @jorisvandenbossche \r\nDo you have any suggestions how to tackle this bug? I noticed that handling ``pd.NA`` behaviour has been discussed in other issues, e.g. this one: https://github.com/pandas-dev/pandas/issues/32265",
    "I'm not sure offhand, sorry. But it seems like NA values should be considered False there, so perhaps fill it with something other than the value to mask? Some of the methods in `core.arrays.boolean` may be helpful to look through.",
    "Note that this is working fine with string dtype:\r\n\r\n```\r\nIn [4]: ser = pd.DataFrame({'a': ['nil', pd.NA]}, dtype=\"string\") \r\n\r\nIn [5]: ser.replace('nil', 'anything else')\r\nOut[5]: \r\n               a\r\n0  anything else\r\n1           <NA>\r\n```\r\n\r\nSo it is specifically for NA in object dtype (something we actually don't really test yet, I think).\r\n\r\n> The problem arises here arr == x, which fails when arr contains pd.NA, as pointed out above.\r\n\r\nThis *might* be related to the comparison deprecations in numpy (there are other cases where comparisons return a scalar True/False, instead of doing it element-wise), you also see the deprecation warning. \r\nNow in general, numpy might not be able to handle this: the comparison with pd.NA returns pd.NA, so it cannot be put in a boolean ndarray (which numpy expects to do for a comparison, I suppose). So the deprecation might be correct that it will fail in the future. \r\n\r\nIf we want to handle pd.NA in object dtype better, we will need to start using masks as well, and not rely on numpy behaviour. \r\n\r\nFor example, also this is wrong:\r\n\r\n```\r\nIn [9]: pd.Series([1, pd.NA], dtype=object) >= 1\r\nOut[9]: \r\n0     True\r\n1    False\r\ndtype: bool\r\n```\r\n\r\n(we should probably open a separate issue about \"pd.NA in object dtype\", and the best way forward here generally)",
    "The patch above doesn't work (unsurprisingly) because sometimes `arr` is a Pandas array and sometimes it's a NumPy array, but only Pandas arrays have a `fillna` method.\r\n\r\nThe patch below _seems_ to work with some manual testing and the result of `./test_fast.sh` is the same before/after applying it:\r\n\r\n```diff\r\ndiff --git a/pandas/core/missing.py b/pandas/core/missing.py\r\nindex 7802c5cbd..f8280c0a2 100644\r\n--- a/pandas/core/missing.py\r\n+++ b/pandas/core/missing.py\r\n@@ -46,7 +46,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask = False\r\n             else:\r\n-                mask = arr == x\r\n+                mask = np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n             # if x is a string and arr is not, then we get False and we must\r\n             # expand the mask to size arr.shape\r\n@@ -57,7 +57,7 @@ def mask_missing(arr, values_to_mask):\r\n                 # GH#29553 prevent numpy deprecation warnings\r\n                 mask |= False\r\n             else:\r\n-                mask |= arr == x\r\n+                mask |= np.where(~isna(arr), arr, np.full_like(arr, np.nan)) == x\r\n \r\n     if na_mask.any():\r\n         if mask is None:\r\n```\r\n\r\nThis replaces `pd.NA` values with NumPy `NaN` and `NaT` values, which do compare with `==` correctly and produce a boolean vector instead of a boolean scalar.\r\n\r\nI want to write an actual set of tests cases for this bug for various dtypes though before submitting a PR. I believe the patch above may still fail for `pd.Period` types."
  ],
  "questions_generated": [
    "What could be the reason for the `Series.replace` method failing to replace the value 'nil' with `pd.NA` in the provided code sample?",
    "Why does the manual replacement using `ser.loc[(ser == 'nil').fillna(False)] = pd.NA` succeed where `Series.replace` fails?",
    "What is the significance of the FutureWarning message in the context of this issue and how should it be interpreted by developers?",
    "How does the pandas version 1.0.1, as shown in the `pd.show_versions()` output, influence the behavior observed in the issue?",
    "Why is it important to provide a minimal reproducible example when reporting issues in open-source repositories like pandas?"
  ],
  "golden_answers_generated": [
    "The issue may be related to the way `pandas` handles elementwise comparison for object dtype Series. The warning indicates that an elementwise comparison failed and a scalar was returned instead. This suggests that the `replace` method may not be properly identifying the 'nil' string for replacement due to underlying dtype or comparison mechanism limitations.",
    "The manual replacement works because it explicitly identifies and locates the positions in the Series where 'nil' exists using boolean indexing. This method avoids the pitfalls of the `replace` method's handling of object dtypes and elementwise operations, directly assigning `pd.NA` to the identified positions.",
    "The FutureWarning signifies that the current behavior of elementwise comparison returning a scalar is not the intended future behavior. Developers should interpret this warning as an indication to modify code that relies on this behavior, as future pandas versions will perform elementwise comparisons that may result in different outcomes.",
    "Pandas version 1.0.1 may have specific implementation details and bugs related to the `replace` method and handling of object dtypes that contribute to this issue. Updates in later versions might address these bugs by improving elementwise operations or dtype handling, thus altering the behavior observed in this older version.",
    "Providing a minimal reproducible example is crucial for efficient debugging and resolution of issues. It allows maintainers and contributors to quickly understand the problem context, test potential fixes, and verify solutions without extraneous information that could complicate diagnosis. A clear example ensures better communication and collaboration in open-source projects."
  ]
}