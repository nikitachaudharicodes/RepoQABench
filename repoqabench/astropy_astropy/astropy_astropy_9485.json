{
  "repo_name": "astropy_astropy",
  "issue_id": "9485",
  "issue_description": "# Make code snippets from docstrings run by  doctest \n\nhttps://github.com/astropy/astropy/pull/9468 highlighted that there are code snippets in docstrings that are not actually picked up during doctesting. I strongly feel that shouldn't be the case, we should skip any such testing in very rare occasions.\r\nI tag this as a coordinates issue, but they may be other sub packages affected by the same problem.",
  "issue_comments": [
    {
      "id": 547025551,
      "user": "pllim",
      "body": "What is the solution you have in mind? Prepend `>>>` in front of them to be picked up by `doctest`?"
    },
    {
      "id": 547026726,
      "user": "bsipocz",
      "body": "Basically yes. \r\nBut then they most probably needs to be extended to have all the required imports. So overall change them from many one liners to a few few liners."
    },
    {
      "id": 554473369,
      "user": "Harshil-C",
      "body": "hey ,iam a student and i want  to work on this issue as a step to familiarise the project "
    },
    {
      "id": 555190475,
      "user": "mhvk",
      "body": "@Harshil-C - that's great! (Sorry for the slow response, we're in the middle of a new release.) Please just go ahead and try to fix some. It will be by far easiest if you set up your own computer such that it can do the testing (see help for developpers in the main documentation page). But if you are unsure, do feel free to ask - perhaps easiest based on a PR that changes at least a few examples to doctests."
    },
    {
      "id": 562833458,
      "user": "Harshil-C",
      "body": "thanks for replying ,\r\nshould i run the doctest and find the missing code snippets just on the  sky_cooordinate.py   file"
    },
    {
      "id": 562860478,
      "user": "mhvk",
      "body": "Sure, start with `sky_coordinate.py`!"
    },
    {
      "id": 569514342,
      "user": "DShivansh",
      "body": "@mhvk can I work on this issue? if no one is working on it."
    },
    {
      "id": 569523992,
      "user": "mhvk",
      "body": "@DShivansh - it doesn't seem @Harshil-C actually did it, so, yes, go ahead (@Harshil-C, please give a shout if you have something ready)."
    },
    {
      "id": 570803139,
      "user": "DShivansh",
      "body": "@mhvk can you please show me the code or tell me the file in which I can find it as it seems I am not able to fully understand the problem correctly."
    },
    {
      "id": 570807224,
      "user": "mhvk",
      "body": "@DShivansh - the issue here is that #9468 found that some examples were not marked as doctests and thus not ran in tests, and that we want to be sure there are no others. A quick look at `sky_coordinate.py` actually suggests there no other problem cases (though I didn't look in detail), but in a way the work here is to look through the code and make sure that is true for the whole module. If it turns out we have been otherwise good and everything is a doctest (i.e., has `>>>` in front of every piece of example code), then that is very useful to know too!"
    },
    {
      "id": 571596239,
      "user": "Harshil-C",
      "body": "i coudnt find  any  statement in  the example to be prepended ,but idid find that while running  doctest to the module it showed up a value error that teminated the tests .I tried the test removing  a particular statement to check whether  it was the reason for this issue  and the doctest did pass all the test after removing the snippet.\r\nAs a novice i didnt understand the purpose of the comment statement # doctest: +FLOAT_CMP  \r\nThe value error showed up when the sign ':' came up,i think it kills the comment property  which inturn gives the value error.\r\ni think that is the reason ,and it really helps if i could know the meaning of # doctest: +FLOAT_CMP \r\n\r\n "
    },
    {
      "id": 571615626,
      "user": "ayshih",
      "body": "I suspect that you either don't have `pytest-doctestplus` installed or have an old version.  `FLOAT_CMP` is an optional directive provided by `pytest-doctestplus` that enables nice comparison of floats.  The syntax of `# doctest: +FLOAT_CMP` is correct (including the colon), and should work on a setup with a proper version of `pytest-doctestplus`."
    },
    {
      "id": 571652200,
      "user": "Harshil-C",
      "body": "oh so chances  are that i dont have pytest doctest  plus installed\r\n thanks man i didnt know about that doctest plugin\r\n\r\nand sorry for all the misleading blunder suggestions"
    },
    {
      "id": 621828810,
      "user": "nikita-0209",
      "body": "@mhvk Hi, I am a beginner.  If no one else is, I want to work on this issue. \r\nI went through [sky_coordinate.py](https://github.com/astropy/astropy/blob/master/astropy/coordinates/sky_coordinate.py)\r\nI found code snippets in docstrings only in `Position_Angle`. Is that all we are supposed to test?"
    },
    {
      "id": 621916838,
      "user": "mhvk",
      "body": "@nikita-0209 - I'm actually not sure there still are issues that need looking at. @bsipocz - do you know? Or should we close this issue? "
    },
    {
      "id": 622005801,
      "user": "bsipocz",
      "body": "I think most of these got indeed cleaned up, but there may some more instances around. E.g one could argue this list ideally should be sent through doctest with ignoring output. A few more files with more examples (most are borderline) are listed below based on a quick and dirty grep:\r\n\r\n```\r\nclass Angle(u.SpecificTypeQuantity):\r\n    \"\"\"\r\n    One or more angular value(s) with units equivalent to radians or degrees.\r\n\r\n    An angle can be specified either as an array, scalar, tuple (see\r\n    below), string, `~astropy.units.Quantity` or another\r\n    :class:`~astropy.coordinates.Angle`.\r\n\r\n    The input parser is flexible and supports a variety of formats::\r\n\r\n      Angle('10.2345d')\r\n      Angle(['10.2345d', '-20d'])\r\n      Angle('1:2:30.43 degrees')\r\n      Angle('1 2 0 hours')\r\n      Angle(np.arange(1, 8), unit=u.deg)\r\n      Angle('1°2′3″')\r\n      Angle('1°2′3″N')\r\n      Angle('1d2m3.4s')\r\n      Angle('1d2m3.4sS')\r\n      Angle('-1h2m3s')\r\n      Angle('-1h2m3sE')\r\n      Angle('-1h2.5m')\r\n      Angle('-1h2.5mW')\r\n      Angle('-1:2.5', unit=u.deg)\r\n      Angle((10, 11, 12), unit='hourangle')  # (h, m, s)\r\n      Angle((-1, 2, 3), unit=u.deg)  # (d, m, s)\r\n      Angle(10.2345 * u.deg)\r\n      Angle(Angle(10.2345 * u.deg))\r\n```\r\nsee also `astropy/io/ascii/latex.py`, `astropy/time/core.py`, `astropy/table/column.py `, `astropy/io/ascii/misc.py`"
    },
    {
      "id": 637183426,
      "user": "nikita-0209",
      "body": "I've created a Pull Request #10261 "
    },
    {
      "id": 703218221,
      "user": "astrojuanlu",
      "body": "Prospective contributors: see [end of @bsipocz comment above](https://github.com/astropy/astropy/issues/9485#issuecomment-622005801) for a list of modules that need to be checked."
    },
    {
      "id": 710783346,
      "user": "zupeiza",
      "body": "I'll work in the modules above:\r\n\r\n- astropy/io/ascii/latex.py\r\n- astropy/time/core.py\r\n- astropy/table/column.py\r\n- astropy/io/ascii/misc.py"
    },
    {
      "id": 752041567,
      "user": "astrojuanlu",
      "body": "With #10261 (merged) and #10886 (pending review) I _think_ we can close this issue."
    },
    {
      "id": 752135702,
      "user": "pllim",
      "body": "Sure. We can address any future cases that appear in a \"as needed\" basis. Thanks for following up on this!"
    }
  ],
  "text_context": "# Make code snippets from docstrings run by  doctest \n\nhttps://github.com/astropy/astropy/pull/9468 highlighted that there are code snippets in docstrings that are not actually picked up during doctesting. I strongly feel that shouldn't be the case, we should skip any such testing in very rare occasions.\r\nI tag this as a coordinates issue, but they may be other sub packages affected by the same problem.\n\nWhat is the solution you have in mind? Prepend `>>>` in front of them to be picked up by `doctest`?\n\nBasically yes. \r\nBut then they most probably needs to be extended to have all the required imports. So overall change them from many one liners to a few few liners.\n\nhey ,iam a student and i want  to work on this issue as a step to familiarise the project \n\n@Harshil-C - that's great! (Sorry for the slow response, we're in the middle of a new release.) Please just go ahead and try to fix some. It will be by far easiest if you set up your own computer such that it can do the testing (see help for developpers in the main documentation page). But if you are unsure, do feel free to ask - perhaps easiest based on a PR that changes at least a few examples to doctests.\n\nthanks for replying ,\r\nshould i run the doctest and find the missing code snippets just on the  sky_cooordinate.py   file\n\nSure, start with `sky_coordinate.py`!\n\n@mhvk can I work on this issue? if no one is working on it.\n\n@DShivansh - it doesn't seem @Harshil-C actually did it, so, yes, go ahead (@Harshil-C, please give a shout if you have something ready).\n\n@mhvk can you please show me the code or tell me the file in which I can find it as it seems I am not able to fully understand the problem correctly.\n\n@DShivansh - the issue here is that #9468 found that some examples were not marked as doctests and thus not ran in tests, and that we want to be sure there are no others. A quick look at `sky_coordinate.py` actually suggests there no other problem cases (though I didn't look in detail), but in a way the work here is to look through the code and make sure that is true for the whole module. If it turns out we have been otherwise good and everything is a doctest (i.e., has `>>>` in front of every piece of example code), then that is very useful to know too!\n\ni coudnt find  any  statement in  the example to be prepended ,but idid find that while running  doctest to the module it showed up a value error that teminated the tests .I tried the test removing  a particular statement to check whether  it was the reason for this issue  and the doctest did pass all the test after removing the snippet.\r\nAs a novice i didnt understand the purpose of the comment statement # doctest: +FLOAT_CMP  \r\nThe value error showed up when the sign ':' came up,i think it kills the comment property  which inturn gives the value error.\r\ni think that is the reason ,and it really helps if i could know the meaning of # doctest: +FLOAT_CMP \r\n\r\n \n\nI suspect that you either don't have `pytest-doctestplus` installed or have an old version.  `FLOAT_CMP` is an optional directive provided by `pytest-doctestplus` that enables nice comparison of floats.  The syntax of `# doctest: +FLOAT_CMP` is correct (including the colon), and should work on a setup with a proper version of `pytest-doctestplus`.\n\noh so chances  are that i dont have pytest doctest  plus installed\r\n thanks man i didnt know about that doctest plugin\r\n\r\nand sorry for all the misleading blunder suggestions\n\n@mhvk Hi, I am a beginner.  If no one else is, I want to work on this issue. \r\nI went through [sky_coordinate.py](https://github.com/astropy/astropy/blob/master/astropy/coordinates/sky_coordinate.py)\r\nI found code snippets in docstrings only in `Position_Angle`. Is that all we are supposed to test?\n\n@nikita-0209 - I'm actually not sure there still are issues that need looking at. @bsipocz - do you know? Or should we close this issue? \n\nI think most of these got indeed cleaned up, but there may some more instances around. E.g one could argue this list ideally should be sent through doctest with ignoring output. A few more files with more examples (most are borderline) are listed below based on a quick and dirty grep:\r\n\r\n```\r\nclass Angle(u.SpecificTypeQuantity):\r\n    \"\"\"\r\n    One or more angular value(s) with units equivalent to radians or degrees.\r\n\r\n    An angle can be specified either as an array, scalar, tuple (see\r\n    below), string, `~astropy.units.Quantity` or another\r\n    :class:`~astropy.coordinates.Angle`.\r\n\r\n    The input parser is flexible and supports a variety of formats::\r\n\r\n      Angle('10.2345d')\r\n      Angle(['10.2345d', '-20d'])\r\n      Angle('1:2:30.43 degrees')\r\n      Angle('1 2 0 hours')\r\n      Angle(np.arange(1, 8), unit=u.deg)\r\n      Angle('1°2′3″')\r\n      Angle('1°2′3″N')\r\n      Angle('1d2m3.4s')\r\n      Angle('1d2m3.4sS')\r\n      Angle('-1h2m3s')\r\n      Angle('-1h2m3sE')\r\n      Angle('-1h2.5m')\r\n      Angle('-1h2.5mW')\r\n      Angle('-1:2.5', unit=u.deg)\r\n      Angle((10, 11, 12), unit='hourangle')  # (h, m, s)\r\n      Angle((-1, 2, 3), unit=u.deg)  # (d, m, s)\r\n      Angle(10.2345 * u.deg)\r\n      Angle(Angle(10.2345 * u.deg))\r\n```\r\nsee also `astropy/io/ascii/latex.py`, `astropy/time/core.py`, `astropy/table/column.py `, `astropy/io/ascii/misc.py`\n\nI've created a Pull Request #10261 \n\nProspective contributors: see [end of @bsipocz comment above](https://github.com/astropy/astropy/issues/9485#issuecomment-622005801) for a list of modules that need to be checked.\n\nI'll work in the modules above:\r\n\r\n- astropy/io/ascii/latex.py\r\n- astropy/time/core.py\r\n- astropy/table/column.py\r\n- astropy/io/ascii/misc.py\n\nWith #10261 (merged) and #10886 (pending review) I _think_ we can close this issue.\n\nSure. We can address any future cases that appear in a \"as needed\" basis. Thanks for following up on this!",
  "pr_link": "https://github.com/astropy/astropy/pull/9468",
  "code_context": [
    {
      "filename": "astropy/coordinates/sky_coordinate.py",
      "content": "import re\nimport copy\n\nimport numpy as np\n\nfrom astropy import _erfa as erfa\nfrom astropy.utils.compat.misc import override__dir__\nfrom astropy import units as u\nfrom astropy.constants import c as speed_of_light\nfrom astropy.wcs.utils import skycoord_to_pixel, pixel_to_skycoord\nfrom astropy.utils.data_info import MixinInfo\nfrom astropy.utils import ShapedLikeNDArray\nfrom astropy.time import Time\n\nfrom .distances import Distance\nfrom .angles import Angle\nfrom .baseframe import (BaseCoordinateFrame, frame_transform_graph,\n                        GenericFrame)\nfrom .builtin_frames import ICRS, SkyOffsetFrame\nfrom .representation import (SphericalRepresentation,\n                             UnitSphericalRepresentation, SphericalDifferential)\nfrom .sky_coordinate_parsers import (_get_frame_class, _get_frame_without_data,\n                                     _parse_coordinate_data)\n\n__all__ = ['SkyCoord', 'SkyCoordInfo']\n\n\nclass SkyCoordInfo(MixinInfo):\n    \"\"\"\n    Container for meta information like name, description, format.  This is\n    required when the object is used as a mixin column within a table, but can\n    be used as a general way to store meta information.\n    \"\"\"\n    attrs_from_parent = set(['unit'])  # Unit is read-only\n    _supports_indexing = False\n\n    @staticmethod\n    def default_format(val):\n        repr_data = val.info._repr_data\n        formats = ['{0.' + compname + '.value:}' for compname\n                   in repr_data.components]\n        return ','.join(formats).format(repr_data)\n\n    @property\n    def unit(self):\n        repr_data = self._repr_data\n        unit = ','.join(str(getattr(repr_data, comp).unit) or 'None'\n                        for comp in repr_data.components)\n        return unit\n\n    @property\n    def _repr_data(self):\n        if self._parent is None:\n            return None\n\n        sc = self._parent\n        if (issubclass(sc.representation_type, SphericalRepresentation)\n                and isinstance(sc.data, UnitSphericalRepresentation)):\n            repr_data = sc.represent_as(sc.data.__class__, in_frame_units=True)\n        else:\n            repr_data = sc.represent_as(sc.representation_type,\n                                        in_frame_units=True)\n        return repr_data\n\n    def _represent_as_dict(self):\n        obj = self._parent\n        attrs = (list(obj.representation_component_names) +\n                 list(frame_transform_graph.frame_attributes.keys()))\n\n        # Don't output distance if it is all unitless 1.0\n        if 'distance' in attrs and np.all(obj.distance == 1.0):\n            attrs.remove('distance')\n\n        out = super()._represent_as_dict(attrs)\n\n        out['representation_type'] = obj.representation_type.get_name()\n        out['frame'] = obj.frame.name\n        # Note that obj.info.unit is a fake composite unit (e.g. 'deg,deg,None'\n        # or None,None,m) and is not stored.  The individual attributes have\n        # units.\n\n        return out\n\n\nclass SkyCoord(ShapedLikeNDArray):\n    \"\"\"High-level object providing a flexible interface for celestial coordinate\n    representation, manipulation, and transformation between systems.\n\n    The `SkyCoord` class accepts a wide variety of inputs for initialization. At\n    a minimum these must provide one or more celestial coordinate values with\n    unambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\n    scalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\n    Typically one also specifies the coordinate frame, though this is not\n    required. The general pattern for spherical representations is::\n\n      SkyCoord(COORD, [FRAME], keyword_args ...)\n      SkyCoord(LON, LAT, [FRAME], keyword_args ...)\n      SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\n      SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\n\n    It is also possible to input coordinate values in other representations\n    such as cartesian or cylindrical.  In this case one includes the keyword\n    argument ``representation_type='cartesian'`` (for example) along with data\n    in ``x``, ``y``, and ``z``.\n\n    See also: http://docs.astropy.org/en/stable/coordinates/\n\n    Examples\n    --------\n    The examples below illustrate common ways of initializing a `SkyCoord`\n    object.  For a complete description of the allowed syntax see the\n    full coordinates documentation.  First some imports::\n\n      >>> from astropy.coordinates import SkyCoord  # High-level coordinates\n      >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\n      >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\n      >>> import astropy.units as u\n\n    The coordinate values and frame specification can now be provided using\n    positional and keyword arguments::\n\n      >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\n      >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\n\n      >>> coords = [\"1:12:43.2 +1:12:43\", \"1 12 43.2 +1 12 43\"]\n      >>> c = SkyCoord(coords, frame=FK4, unit=(u.deg, u.hourangle), obstime=\"J1992.21\")\n\n      >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\n      >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\n\n      >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\n      >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\n      >>> c = SkyCoord(ra, dec, frame='icrs')\n      >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime='2001-01-02T12:34:56')\n\n      >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\n      >>> c = SkyCoord(c, obstime='J2010.11', equinox='B1965')  # Override defaults\n\n      >>> c = SkyCoord(w=0, u=1, v=2, unit='kpc', frame='galactic',\n      ...              representation_type='cartesian')\n\n      >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\n\n    Velocity components (proper motions or radial velocities) can also be\n    provided in a similar manner::\n\n      >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\n\n      >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\n\n    As shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\n    class or the corresponding string alias.  The frame classes that are built in\n    to astropy are `ICRS`, `FK5`, `FK4`, `FK4NoETerms`, and `Galactic`.\n    The string aliases are simply lower-case versions of the class name, and\n    allow for creating a `SkyCoord` object and transforming frames without\n    explicitly importing the frame classes.\n\n    Parameters\n    ----------\n    frame : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\n        Type of coordinate frame this `SkyCoord` should represent. Defaults to\n        to ICRS if not given or given as None.\n    unit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\n        Units for supplied ``LON`` and ``LAT`` values, respectively.  If\n        only one unit is supplied then it applies to both ``LON`` and\n        ``LAT``.\n    obstime : valid `~astropy.time.Time` initializer, optional\n        Time(s) of observation.\n    equinox : valid `~astropy.time.Time` initializer, optional\n        Coordinate frame equinox.\n    representation_type : str or Representation class\n        Specifies the representation, e.g. 'spherical', 'cartesian', or\n        'cylindrical'.  This affects the positional args and other keyword args\n        which must correspond to the given representation.\n    copy : bool, optional\n        If `True` (default), a copy of any coordinate data is made.  This\n        argument can only be passed in as a keyword argument.\n    **keyword_args\n        Other keyword arguments as applicable for user-defined coordinate frames.\n        Common options include:\n\n        ra, dec : valid `~astropy.coordinates.Angle` initializer, optional\n            RA and Dec for frames where ``ra`` and ``dec`` are keys in the\n            frame's ``representation_component_names``, including `ICRS`,\n            `FK5`, `FK4`, and `FK4NoETerms`.\n        pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity`, optional\n            Proper motion components, in angle per time units.\n        l, b : valid `~astropy.coordinates.Angle` initializer, optional\n            Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\n            keys in the frame's ``representation_component_names``, including\n            the `Galactic` frame.\n        pm_l_cosb, pm_b : `~astropy.units.Quantity`, optional\n            Proper motion components in the `Galactic` frame, in angle per time\n            units.\n        x, y, z : float or `~astropy.units.Quantity`, optional\n            Cartesian coordinates values\n        u, v, w : float or `~astropy.units.Quantity`, optional\n            Cartesian coordinates values for the Galactic frame.\n        radial_velocity : `~astropy.units.Quantity`, optional\n            The component of the velocity along the line-of-sight (i.e., the\n            radial direction), in velocity units.\n    \"\"\"\n\n    # Declare that SkyCoord can be used as a Table column by defining the\n    # info property.\n    info = SkyCoordInfo()\n\n    def __init__(self, *args, copy=True, **kwargs):\n\n        # these are frame attributes set on this SkyCoord but *not* a part of\n        # the frame object this SkyCoord contains\n        self._extra_frameattr_names = set()\n\n        # If all that is passed in is a frame instance that already has data,\n        # we should bypass all of the parsing and logic below. This is here\n        # to make this the fastest way to create a SkyCoord instance. Many of\n        # the classmethods implemented for performance enhancements will use\n        # this as the initialization path\n        if (len(args) == 1 and len(kwargs) == 0\n                and isinstance(args[0], (BaseCoordinateFrame, SkyCoord))):\n\n            coords = args[0]\n            if isinstance(coords, SkyCoord):\n                self._extra_frameattr_names = coords._extra_frameattr_names\n                self.info = coords.info\n\n                # Copy over any extra frame attributes\n                for attr_name in self._extra_frameattr_names:\n                    # Setting it will also validate it.\n                    setattr(self, attr_name, getattr(coords, attr_name))\n\n                coords = coords.frame\n\n            if not coords.has_data:\n                raise ValueError('Cannot initialize from a coordinate frame '\n                                 'instance without coordinate data')\n\n            if copy:\n                self._sky_coord_frame = coords.copy()\n            else:\n                self._sky_coord_frame = coords\n\n        else:\n            # Get the frame instance without coordinate data but with all frame\n            # attributes set - these could either have been passed in with the\n            # frame as an instance, or passed in as kwargs here\n            frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n\n            # Parse the args and kwargs to assemble a sanitized and validated\n            # kwargs dict for initializing attributes for this object and for\n            # creating the internal self._sky_coord_frame object\n            args = list(args)  # Make it mutable\n            skycoord_kwargs, components, info = _parse_coordinate_data(\n                frame_cls(**frame_kwargs), args, kwargs)\n\n            # In the above two parsing functions, these kwargs were identified\n            # as valid frame attributes for *some* frame, but not the frame that\n            # this SkyCoord will have. We keep these attributes as special\n            # skycoord frame attributes:\n            for attr in skycoord_kwargs:\n                # Setting it will also validate it.\n                setattr(self, attr, skycoord_kwargs[attr])\n\n            if info is not None:\n                self.info = info\n\n            # Finally make the internal coordinate object.\n            frame_kwargs.update(components)\n            self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n\n            if not self._sky_coord_frame.has_data:\n                raise ValueError('Cannot create a SkyCoord without data')\n\n    @property\n    def frame(self):\n        return self._sky_coord_frame\n\n    @property\n    def representation_type(self):\n        return self.frame.representation_type\n\n    @representation_type.setter\n    def representation_type(self, value):\n        self.frame.representation_type = value\n\n    # TODO: remove these in future\n    @property\n    def representation(self):\n        return self.frame.representation\n\n    @representation.setter\n    def representation(self, value):\n        self.frame.representation = value\n\n    @property\n    def shape(self):\n        return self.frame.shape\n\n    def _apply(self, method, *args, **kwargs):\n        \"\"\"Create a new instance, applying a method to the underlying data.\n\n        In typical usage, the method is any of the shape-changing methods for\n        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those\n        picking particular elements (``__getitem__``, ``take``, etc.), which\n        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be\n        applied to the underlying arrays in the representation (e.g., ``x``,\n        ``y``, and ``z`` for `~astropy.coordinates.CartesianRepresentation`),\n        as well as to any frame attributes that have a shape, with the results\n        used to create a new instance.\n\n        Internally, it is also used to apply functions to the above parts\n        (in particular, `~numpy.broadcast_to`).\n\n        Parameters\n        ----------\n        method : str or callable\n            If str, it is the name of a method that is applied to the internal\n            ``components``. If callable, the function is applied.\n        args : tuple\n            Any positional arguments for ``method``.\n        kwargs : dict\n            Any keyword arguments for ``method``.\n        \"\"\"\n        def apply_method(value):\n            if isinstance(value, ShapedLikeNDArray):\n                return value._apply(method, *args, **kwargs)\n            else:\n                if callable(method):\n                    return method(value, *args, **kwargs)\n                else:\n                    return getattr(value, method)(*args, **kwargs)\n\n        # create a new but empty instance, and copy over stuff\n        new = super().__new__(self.__class__)\n        new._sky_coord_frame = self._sky_coord_frame._apply(method,\n                                                            *args, **kwargs)\n        new._extra_frameattr_names = self._extra_frameattr_names.copy()\n        for attr in self._extra_frameattr_names:\n            value = getattr(self, attr)\n            if getattr(value, 'size', 1) > 1:\n                value = apply_method(value)\n            elif method == 'copy' or method == 'flatten':\n                # flatten should copy also for a single element array, but\n                # we cannot use it directly for array scalars, since it\n                # always returns a one-dimensional array. So, just copy.\n                value = copy.copy(value)\n            setattr(new, '_' + attr, value)\n\n        # Copy other 'info' attr only if it has actually been defined.\n        # See PR #3898 for further explanation and justification, along\n        # with Quantity.__array_finalize__\n        if 'info' in self.__dict__:\n            new.info = self.info\n\n        return new\n\n    def transform_to(self, frame, merge_attributes=True):\n        \"\"\"Transform this coordinate to a new frame.\n\n        The precise frame transformed to depends on ``merge_attributes``.\n        If `False`, the destination frame is used exactly as passed in.\n        But this is often not quite what one wants.  E.g., suppose one wants to\n        transform an ICRS coordinate that has an obstime attribute to FK4; in\n        this case, one likely would want to use this information. Thus, the\n        default for ``merge_attributes`` is `True`, in which the precedence is\n        as follows: (1) explicitly set (i.e., non-default) values in the\n        destination frame; (2) explicitly set values in the source; (3) default\n        value in the destination frame.\n\n        Note that in either case, any explicitly set attributes on the source\n        `SkyCoord` that are not part of the destination frame's definition are\n        kept (stored on the resulting `SkyCoord`), and thus one can round-trip\n        (e.g., from FK4 to ICRS to FK4 without loosing obstime).\n\n        Parameters\n        ----------\n        frame : str, `BaseCoordinateFrame` class or instance, or `SkyCoord` instance\n            The frame to transform this coordinate into.  If a `SkyCoord`, the\n            underlying frame is extracted, and all other information ignored.\n        merge_attributes : bool, optional\n            Whether the default attributes in the destination frame are allowed\n            to be overridden by explicitly set attributes in the source\n            (see note above; default: `True`).\n\n        Returns\n        -------\n        coord : `SkyCoord`\n            A new object with this coordinate represented in the `frame` frame.\n\n        Raises\n        ------\n        ValueError\n            If there is no possible transformation route.\n\n        \"\"\"\n        from astropy.coordinates.errors import ConvertError\n\n        frame_kwargs = {}\n\n        # Frame name (string) or frame class?  Coerce into an instance.\n        try:\n            frame = _get_frame_class(frame)()\n        except Exception:\n            pass\n\n        if isinstance(frame, SkyCoord):\n            frame = frame.frame  # Change to underlying coord frame instance\n\n        if isinstance(frame, BaseCoordinateFrame):\n            new_frame_cls = frame.__class__\n            # Get frame attributes, allowing defaults to be overridden by\n            # explicitly set attributes of the source if ``merge_attributes``.\n            for attr in frame_transform_graph.frame_attributes:\n                self_val = getattr(self, attr, None)\n                frame_val = getattr(frame, attr, None)\n                if (frame_val is not None\n                    and not (merge_attributes\n                             and frame.is_frame_attr_default(attr))):\n                    frame_kwargs[attr] = frame_val\n                elif (self_val is not None\n                      and not self.is_frame_attr_default(attr)):\n                    frame_kwargs[attr] = self_val\n                elif frame_val is not None:\n                    frame_kwargs[attr] = frame_val\n        else:\n            raise ValueError('Transform `frame` must be a frame name, class, or instance')\n\n        # Get the composite transform to the new frame\n        trans = frame_transform_graph.get_transform(self.frame.__class__, new_frame_cls)\n        if trans is None:\n            raise ConvertError('Cannot transform from {} to {}'\n                               .format(self.frame.__class__, new_frame_cls))\n\n        # Make a generic frame which will accept all the frame kwargs that\n        # are provided and allow for transforming through intermediate frames\n        # which may require one or more of those kwargs.\n        generic_frame = GenericFrame(frame_kwargs)\n\n        # Do the transformation, returning a coordinate frame of the desired\n        # final type (not generic).\n        new_coord = trans(self.frame, generic_frame)\n\n        # Finally make the new SkyCoord object from the `new_coord` and\n        # remaining frame_kwargs that are not frame_attributes in `new_coord`.\n        for attr in (set(new_coord.get_frame_attr_names()) &\n                     set(frame_kwargs.keys())):\n            frame_kwargs.pop(attr)\n\n        return self.__class__(new_coord, **frame_kwargs)\n\n    def apply_space_motion(self, new_obstime=None, dt=None):\n        \"\"\"\n        Compute the position of the source represented by this coordinate object\n        to a new time using the velocities stored in this object and assuming\n        linear space motion (including relativistic corrections). This is\n        sometimes referred to as an \"epoch transformation.\"\n\n        The initial time before the evolution is taken from the ``obstime``\n        attribute of this coordinate.  Note that this method currently does not\n        support evolving coordinates where the *frame* has an ``obstime`` frame\n        attribute, so the ``obstime`` is only used for storing the before and\n        after times, not actually as an attribute of the frame. Alternatively,\n        if ``dt`` is given, an ``obstime`` need not be provided at all.\n\n        Parameters\n        ----------\n        new_obstime : `~astropy.time.Time`, optional\n            The time at which to evolve the position to. Requires that the\n            ``obstime`` attribute be present on this frame.\n        dt : `~astropy.units.Quantity`, `~astropy.time.TimeDelta`, optional\n            An amount of time to evolve the position of the source. Cannot be\n            given at the same time as ``new_obstime``.\n\n        Returns\n        -------\n        new_coord : `SkyCoord`\n            A new coordinate object with the evolved location of this coordinate\n            at the new time.  ``obstime`` will be set on this object to the new\n            time only if ``self`` also has ``obstime``.\n        \"\"\"\n\n        if (new_obstime is None and dt is None or\n                new_obstime is not None and dt is not None):\n            raise ValueError(\"You must specify one of `new_obstime` or `dt`, \"\n                             \"but not both.\")\n\n        # Validate that we have velocity info\n        if 's' not in self.frame.data.differentials:\n            raise ValueError('SkyCoord requires velocity data to evolve the '\n                             'position.')\n\n        if 'obstime' in self.frame.frame_attributes:\n            raise NotImplementedError(\"Updating the coordinates in a frame \"\n                                      \"with explicit time dependence is \"\n                                      \"currently not supported. If you would \"\n                                      \"like this functionality, please open an \"\n                                      \"issue on github:\\n\"\n                                      \"https://github.com/astropy/astropy\")\n\n        if new_obstime is not None and self.obstime is None:\n            # If no obstime is already on this object, raise an error if a new\n            # obstime is passed: we need to know the time / epoch at which the\n            # the position / velocity were measured initially\n            raise ValueError('This object has no associated `obstime`. '\n                             'apply_space_motion() must receive a time '\n                             'difference, `dt`, and not a new obstime.')\n\n        # Compute t1 and t2, the times used in the starpm call, which *only*\n        # uses them to compute a delta-time\n        t1 = self.obstime\n        if dt is None:\n            # self.obstime is not None and new_obstime is not None b/c of above\n            # checks\n            t2 = new_obstime\n        else:\n            # new_obstime is definitely None b/c of the above checks\n            if t1 is None:\n                # MAGIC NUMBER: if the current SkyCoord object has no obstime,\n                # assume J2000 to do the dt offset. This is not actually used\n                # for anything except a delta-t in starpm, so it's OK that it's\n                # not necessarily the \"real\" obstime\n                t1 = Time('J2000')\n                new_obstime = None  # we don't actually know the inital obstime\n                t2 = t1 + dt\n            else:\n                t2 = t1 + dt\n                new_obstime = t2\n        # starpm wants tdb time\n        t1 = t1.tdb\n        t2 = t2.tdb\n\n        # proper motion in RA should not include the cos(dec) term, see the\n        # erfa function eraStarpv, comment (4).  So we convert to the regular\n        # spherical differentials.\n        icrsrep = self.icrs.represent_as(SphericalRepresentation, SphericalDifferential)\n        icrsvel = icrsrep.differentials['s']\n\n        try:\n            plx = icrsrep.distance.to_value(u.arcsecond, u.parallax())\n        except u.UnitConversionError:  # No distance: set to 0 by convention\n            plx = 0.\n\n        try:\n            rv = icrsvel.d_distance.to_value(u.km/u.s)\n        except u.UnitConversionError:  # No RV\n            rv = 0.\n\n        starpm = erfa.starpm(icrsrep.lon.radian, icrsrep.lat.radian,\n                             icrsvel.d_lon.to_value(u.radian/u.yr),\n                             icrsvel.d_lat.to_value(u.radian/u.yr),\n                             plx, rv, t1.jd1, t1.jd2, t2.jd1, t2.jd2)\n\n        icrs2 = ICRS(ra=u.Quantity(starpm[0], u.radian, copy=False),\n                     dec=u.Quantity(starpm[1], u.radian, copy=False),\n                     pm_ra=u.Quantity(starpm[2], u.radian/u.yr, copy=False),\n                     pm_dec=u.Quantity(starpm[3], u.radian/u.yr, copy=False),\n                     distance=Distance(parallax=starpm[4] * u.arcsec, copy=False),\n                     radial_velocity=u.Quantity(starpm[5], u.km/u.s, copy=False),\n                     differential_type=SphericalDifferential)\n\n        # Update the obstime of the returned SkyCoord, and need to carry along\n        # the frame attributes\n        frattrs = {attrnm: getattr(self, attrnm)\n                   for attrnm in self._extra_frameattr_names}\n        frattrs['obstime'] = new_obstime\n        return self.__class__(icrs2, **frattrs).transform_to(self.frame)\n\n    def _is_name(self, string):\n        \"\"\"\n        Returns whether a string is one of the aliases for the frame.\n        \"\"\"\n        return (self.frame.name == string or\n                (isinstance(self.frame.name, list) and string in self.frame.name))\n\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the master transform graph.\n        \"\"\"\n        if '_sky_coord_frame' in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.get_frame_attr_names():\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, '_' + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith('_') and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Fail\n        raise AttributeError(\"'{}' object has no attribute '{}'\"\n                             .format(self.__class__.__name__, attr))\n\n    def __setattr__(self, attr, val):\n        # This is to make anything available through __getattr__ immutable\n        if '_sky_coord_frame' in self.__dict__:\n            if self._is_name(attr):\n                raise AttributeError(f\"'{attr}' is immutable\")\n\n            if not attr.startswith('_') and hasattr(self._sky_coord_frame, attr):\n                setattr(self._sky_coord_frame, attr, val)\n                return\n\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                raise AttributeError(f\"'{attr}' is immutable\")\n\n        if attr in frame_transform_graph.frame_attributes:\n            # All possible frame attributes can be set, but only via a private\n            # variable.  See __getattr__ above.\n            super().__setattr__('_' + attr, val)\n            # Validate it\n            frame_transform_graph.frame_attributes[attr].__get__(self)\n            # And add to set of extra attributes\n            self._extra_frameattr_names |= {attr}\n\n        else:\n            # Otherwise, do the standard Python attribute setting\n            super().__setattr__(attr, val)\n\n    def __delattr__(self, attr):\n        # mirror __setattr__ above\n        if '_sky_coord_frame' in self.__dict__:\n            if self._is_name(attr):\n                raise AttributeError(f\"'{attr}' is immutable\")\n\n            if not attr.startswith('_') and hasattr(self._sky_coord_frame,\n                                                    attr):\n                delattr(self._sky_coord_frame, attr)\n                return\n\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                raise AttributeError(f\"'{attr}' is immutable\")\n\n        if attr in frame_transform_graph.frame_attributes:\n            # All possible frame attributes can be deleted, but need to remove\n            # the corresponding private variable.  See __getattr__ above.\n            super().__delattr__('_' + attr)\n            # Also remove it from the set of extra attributes\n            self._extra_frameattr_names -= {attr}\n\n        else:\n            # Otherwise, do the standard Python attribute setting\n            super().__delattr__(attr)\n\n    @override__dir__\n    def __dir__(self):\n        \"\"\"\n        Override the builtin `dir` behavior to include:\n        - Transforms available by aliases\n        - Attribute / methods of the underlying self.frame object\n        \"\"\"\n\n        # determine the aliases that this can be transformed to.\n        dir_values = set()\n        for name in frame_transform_graph.get_names():\n            frame_cls = frame_transform_graph.lookup_name(name)\n            if self.frame.is_transformable_to(frame_cls):\n                dir_values.add(name)\n\n        # Add public attributes of self.frame\n        dir_values.update(set(attr for attr in dir(self.frame) if not attr.startswith('_')))\n\n        # Add all possible frame attributes\n        dir_values.update(frame_transform_graph.frame_attributes.keys())\n\n        return dir_values\n\n    def __repr__(self):\n        clsnm = self.__class__.__name__\n        coonm = self.frame.__class__.__name__\n        frameattrs = self.frame._frame_attrs_repr()\n        if frameattrs:\n            frameattrs = ': ' + frameattrs\n\n        data = self.frame._data_repr()\n        if data:\n            data = ': ' + data\n\n        return '<{clsnm} ({coonm}{frameattrs}){data}>'.format(**locals())\n\n    def to_string(self, style='decimal', **kwargs):\n        \"\"\"\n        A string representation of the coordinates.\n\n        The default styles definitions are::\n\n          'decimal': 'lat': {'decimal': True, 'unit': \"deg\"}\n                     'lon': {'decimal': True, 'unit': \"deg\"}\n          'dms': 'lat': {'unit': \"deg\"}\n                 'lon': {'unit': \"deg\"}\n          'hmsdms': 'lat': {'alwayssign': True, 'pad': True, 'unit': \"deg\"}\n                    'lon': {'pad': True, 'unit': \"hour\"}\n\n        See :meth:`~astropy.coordinates.Angle.to_string` for details and\n        keyword arguments (the two angles forming the coordinates are are\n        both :class:`~astropy.coordinates.Angle` instances). Keyword\n        arguments have precedence over the style defaults and are passed\n        to :meth:`~astropy.coordinates.Angle.to_string`.\n\n        Parameters\n        ----------\n        style : {'hmsdms', 'dms', 'decimal'}\n            The formatting specification to use. These encode the three most\n            common ways to represent coordinates. The default is `decimal`.\n        kwargs\n            Keyword args passed to :meth:`~astropy.coordinates.Angle.to_string`.\n        \"\"\"\n\n        sph_coord = self.frame.represent_as(SphericalRepresentation)\n\n        styles = {'hmsdms': {'lonargs': {'unit': u.hour, 'pad': True},\n                             'latargs': {'unit': u.degree, 'pad': True, 'alwayssign': True}},\n                  'dms': {'lonargs': {'unit': u.degree},\n                          'latargs': {'unit': u.degree}},\n                  'decimal': {'lonargs': {'unit': u.degree, 'decimal': True},\n                              'latargs': {'unit': u.degree, 'decimal': True}}\n                  }\n\n        lonargs = {}\n        latargs = {}\n\n        if style in styles:\n            lonargs.update(styles[style]['lonargs'])\n            latargs.update(styles[style]['latargs'])\n        else:\n            raise ValueError('Invalid style.  Valid options are: {}'.format(\",\".join(styles)))\n\n        lonargs.update(kwargs)\n        latargs.update(kwargs)\n\n        if np.isscalar(sph_coord.lon.value):\n            coord_string = (sph_coord.lon.to_string(**lonargs) +\n                            \" \" + sph_coord.lat.to_string(**latargs))\n        else:\n            coord_string = []\n            for lonangle, latangle in zip(sph_coord.lon.ravel(), sph_coord.lat.ravel()):\n                coord_string += [(lonangle.to_string(**lonargs) +\n                                 \" \" + latangle.to_string(**latargs))]\n            if len(sph_coord.shape) > 1:\n                coord_string = np.array(coord_string).reshape(sph_coord.shape)\n\n        return coord_string\n\n    def is_equivalent_frame(self, other):\n        \"\"\"\n        Checks if this object's frame as the same as that of the ``other``\n        object.\n\n        To be the same frame, two objects must be the same frame class and have\n        the same frame attributes. For two `SkyCoord` objects, *all* of the\n        frame attributes have to match, not just those relevant for the object's\n        frame.\n\n        Parameters\n        ----------\n        other : SkyCoord or BaseCoordinateFrame\n            The other object to check.\n\n        Returns\n        -------\n        isequiv : bool\n            True if the frames are the same, False if not.\n\n        Raises\n        ------\n        TypeError\n            If ``other`` isn't a `SkyCoord` or a `BaseCoordinateFrame` or subclass.\n        \"\"\"\n        if isinstance(other, BaseCoordinateFrame):\n            return self.frame.is_equivalent_frame(other)\n        elif isinstance(other, SkyCoord):\n            if other.frame.name != self.frame.name:\n                return False\n\n            for fattrnm in frame_transform_graph.frame_attributes:\n                if np.any(getattr(self, fattrnm) != getattr(other, fattrnm)):\n                    return False\n            return True\n        else:\n            # not a BaseCoordinateFrame nor a SkyCoord object\n            raise TypeError(\"Tried to do is_equivalent_frame on something that \"\n                            \"isn't frame-like\")\n\n    # High-level convenience methods\n    def separation(self, other):\n        \"\"\"\n        Computes on-sky separation between this coordinate and another.\n\n        .. note::\n\n            If the ``other`` coordinate object is in a different frame, it is\n            first transformed to the frame of this object. This can lead to\n            unintuitive behavior if not accounted for. Particularly of note is\n            that ``self.separation(other)`` and ``other.separation(self)`` may\n            not give the same answer in this case.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        other : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The coordinate to get the separation to.\n\n        Returns\n        -------\n        sep : `~astropy.coordinates.Angle`\n            The on-sky separation between this and the ``other`` coordinate.\n\n        Notes\n        -----\n        The separation is calculated using the Vincenty formula, which\n        is stable at all locations, including poles and antipodes [1]_.\n\n        .. [1] https://en.wikipedia.org/wiki/Great-circle_distance\n\n        \"\"\"\n        from . import Angle\n        from .angle_utilities import angular_separation\n\n        if not self.is_equivalent_frame(other):\n            try:\n                other = other.transform_to(self, merge_attributes=False)\n            except TypeError:\n                raise TypeError('Can only get separation to another SkyCoord '\n                                'or a coordinate frame with data')\n\n        lon1 = self.spherical.lon\n        lat1 = self.spherical.lat\n        lon2 = other.spherical.lon\n        lat2 = other.spherical.lat\n\n        # Get the separation as a Quantity, convert to Angle in degrees\n        sep = angular_separation(lon1, lat1, lon2, lat2)\n        return Angle(sep, unit=u.degree)\n\n    def separation_3d(self, other):\n        \"\"\"\n        Computes three dimensional separation between this coordinate\n        and another.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        other : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The coordinate to get the separation to.\n\n        Returns\n        -------\n        sep : `~astropy.coordinates.Distance`\n            The real-space distance between these two coordinates.\n\n        Raises\n        ------\n        ValueError\n            If this or the other coordinate do not have distances.\n        \"\"\"\n        if not self.is_equivalent_frame(other):\n            try:\n                other = other.transform_to(self, merge_attributes=False)\n            except TypeError:\n                raise TypeError('Can only get separation to another SkyCoord '\n                                'or a coordinate frame with data')\n\n        if issubclass(self.data.__class__, UnitSphericalRepresentation):\n            raise ValueError('This object does not have a distance; cannot '\n                             'compute 3d separation.')\n        if issubclass(other.data.__class__, UnitSphericalRepresentation):\n            raise ValueError('The other object does not have a distance; '\n                             'cannot compute 3d separation.')\n\n        c1 = self.cartesian.without_differentials()\n        c2 = other.cartesian.without_differentials()\n        return Distance((c1 - c2).norm())\n\n    def spherical_offsets_to(self, tocoord):\n        r\"\"\"\n        Computes angular offsets to go *from* this coordinate *to* another.\n\n        Parameters\n        ----------\n        tocoord : `~astropy.coordinates.BaseCoordinateFrame`\n            The coordinate to find the offset to.\n\n        Returns\n        -------\n        lon_offset : `~astropy.coordinates.Angle`\n            The angular offset in the longitude direction (i.e., RA for\n            equatorial coordinates).\n        lat_offset : `~astropy.coordinates.Angle`\n            The angular offset in the latitude direction (i.e., Dec for\n            equatorial coordinates).\n\n        Raises\n        ------\n        ValueError\n            If the ``tocoord`` is not in the same frame as this one. This is\n            different from the behavior of the `separation`/`separation_3d`\n            methods because the offset components depend critically on the\n            specific choice of frame.\n\n        Notes\n        -----\n        This uses the sky offset frame machinery, and hence will produce a new\n        sky offset frame if one does not already exist for this object's frame\n        class.\n\n        See Also\n        --------\n        separation : for the *total* angular offset (not broken out into components).\n        position_angle : for the direction of the offset.\n\n        \"\"\"\n        if not self.is_equivalent_frame(tocoord):\n            raise ValueError('Tried to use spherical_offsets_to with two non-matching frames!')\n\n        aframe = self.skyoffset_frame()\n        acoord = tocoord.transform_to(aframe)\n\n        dlon = acoord.spherical.lon.view(Angle)\n        dlat = acoord.spherical.lat.view(Angle)\n        return dlon, dlat\n\n    def directional_offset_by(self, position_angle, separation):\n        \"\"\"\n        Computes coordinates at the given offset from this coordinate.\n\n        Parameters\n        ----------\n        position_angle : `~astropy.coordinates.Angle`\n            position_angle of offset\n        separation : `~astropy.coordinates.Angle`\n            offset angular separation\n\n        Returns\n        -------\n        newpoints : `~astropy.coordinates.SkyCoord`\n            The coordinates for the location that corresponds to offsetting by\n            the given `position_angle` and `separation`.\n\n        Notes\n        -----\n        Returned SkyCoord frame retains only the frame attributes that are for\n        the resulting frame type.  (e.g. if the input frame is\n        `~astropy.coordinates.ICRS`, an ``equinox`` value will be retained, but\n        an ``obstime`` will not.)\n\n        For a more complete set of transform offsets, use `~astropy.wcs.WCS`.\n        `~astropy.coordinates.SkyCoord.skyoffset_frame()` can also be used to\n        create a spherical frame with (lat=0, lon=0) at a reference point,\n        approximating an xy cartesian system for small offsets. This method\n        is distinct in that it is accurate on the sphere.\n\n        See Also\n        --------\n        position_angle : inverse operation for the ``position_angle`` component\n        separation : inverse operation for the ``separation`` component\n\n        \"\"\"\n        from . import angle_utilities\n\n        slat = self.represent_as(UnitSphericalRepresentation).lat\n        slon = self.represent_as(UnitSphericalRepresentation).lon\n\n        newlon, newlat = angle_utilities.offset_by(\n            lon=slon, lat=slat,\n            posang=position_angle, distance=separation)\n\n        return SkyCoord(newlon, newlat, frame=self.frame)\n\n    def match_to_catalog_sky(self, catalogcoord, nthneighbor=1):\n        \"\"\"\n        Finds the nearest on-sky matches of this coordinate in a set of\n        catalog coordinates.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        catalogcoord : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The base catalog in which to search for matches. Typically this\n            will be a coordinate object that is an array (i.e.,\n            ``catalogcoord.isscalar == False``)\n        nthneighbor : int, optional\n            Which closest neighbor to search for.  Typically ``1`` is\n            desired here, as that is correct for matching one set of\n            coordinates to another. The next likely use case is ``2``,\n            for matching a coordinate catalog against *itself* (``1``\n            is inappropriate because each point will find itself as the\n            closest match).\n\n        Returns\n        -------\n        idx : integer array\n            Indices into ``catalogcoord`` to get the matched points for\n            each of this object's coordinates. Shape matches this\n            object.\n        sep2d : `~astropy.coordinates.Angle`\n            The on-sky separation between the closest match for each\n            element in this object in ``catalogcoord``. Shape matches\n            this object.\n        dist3d : `~astropy.units.Quantity`\n            The 3D distance between the closest match for each element\n            in this object in ``catalogcoord``. Shape matches this\n            object. Unless both this and ``catalogcoord`` have associated\n            distances, this quantity assumes that all sources are at a\n            distance of 1 (dimensionless).\n\n        Notes\n        -----\n        This method requires `SciPy <https://www.scipy.org/>`_ to be\n        installed or it will fail.\n\n        See Also\n        --------\n        astropy.coordinates.match_coordinates_sky\n        SkyCoord.match_to_catalog_3d\n        \"\"\"\n        from .matching import match_coordinates_sky\n\n        if (isinstance(catalogcoord, (SkyCoord, BaseCoordinateFrame))\n                and catalogcoord.has_data):\n            self_in_catalog_frame = self.transform_to(catalogcoord)\n        else:\n            raise TypeError('Can only get separation to another SkyCoord or a '\n                            'coordinate frame with data')\n\n        res = match_coordinates_sky(self_in_catalog_frame, catalogcoord,\n                                    nthneighbor=nthneighbor,\n                                    storekdtree='_kdtree_sky')\n        return res\n\n    def match_to_catalog_3d(self, catalogcoord, nthneighbor=1):\n        \"\"\"\n        Finds the nearest 3-dimensional matches of this coordinate to a set\n        of catalog coordinates.\n\n        This finds the 3-dimensional closest neighbor, which is only different\n        from the on-sky distance if ``distance`` is set in this object or the\n        ``catalogcoord`` object.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        catalogcoord : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The base catalog in which to search for matches. Typically this\n            will be a coordinate object that is an array (i.e.,\n            ``catalogcoord.isscalar == False``)\n        nthneighbor : int, optional\n            Which closest neighbor to search for.  Typically ``1`` is\n            desired here, as that is correct for matching one set of\n            coordinates to another.  The next likely use case is\n            ``2``, for matching a coordinate catalog against *itself*\n            (``1`` is inappropriate because each point will find\n            itself as the closest match).\n\n        Returns\n        -------\n        idx : integer array\n            Indices into ``catalogcoord`` to get the matched points for\n            each of this object's coordinates. Shape matches this\n            object.\n        sep2d : `~astropy.coordinates.Angle`\n            The on-sky separation between the closest match for each\n            element in this object in ``catalogcoord``. Shape matches\n            this object.\n        dist3d : `~astropy.units.Quantity`\n            The 3D distance between the closest match for each element\n            in this object in ``catalogcoord``. Shape matches this\n            object.\n\n        Notes\n        -----\n        This method requires `SciPy <https://www.scipy.org/>`_ to be\n        installed or it will fail.\n\n        See Also\n        --------\n        astropy.coordinates.match_coordinates_3d\n        SkyCoord.match_to_catalog_sky\n        \"\"\"\n        from .matching import match_coordinates_3d\n\n        if (isinstance(catalogcoord, (SkyCoord, BaseCoordinateFrame))\n                and catalogcoord.has_data):\n            self_in_catalog_frame = self.transform_to(catalogcoord)\n        else:\n            raise TypeError('Can only get separation to another SkyCoord or a '\n                            'coordinate frame with data')\n\n        res = match_coordinates_3d(self_in_catalog_frame, catalogcoord,\n                                   nthneighbor=nthneighbor,\n                                   storekdtree='_kdtree_3d')\n\n        return res\n\n    def search_around_sky(self, searcharoundcoords, seplimit):\n        \"\"\"\n        Searches for all coordinates in this object around a supplied set of\n        points within a given on-sky separation.\n\n        This is intended for use on `~astropy.coordinates.SkyCoord` objects\n        with coordinate arrays, rather than a scalar coordinate.  For a scalar\n        coordinate, it is better to use\n        `~astropy.coordinates.SkyCoord.separation`.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        searcharoundcoords : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The coordinates to search around to try to find matching points in\n            this `SkyCoord`. This should be an object with array coordinates,\n            not a scalar coordinate object.\n        seplimit : `~astropy.units.Quantity` with angle units\n            The on-sky separation to search within.\n\n        Returns\n        -------\n        idxsearcharound : integer array\n            Indices into ``searcharoundcoords`` that match the\n            corresponding elements of ``idxself``. Shape matches\n            ``idxself``.\n        idxself : integer array\n            Indices into ``self`` that match the\n            corresponding elements of ``idxsearcharound``. Shape matches\n            ``idxsearcharound``.\n        sep2d : `~astropy.coordinates.Angle`\n            The on-sky separation between the coordinates. Shape matches\n            ``idxsearcharound`` and ``idxself``.\n        dist3d : `~astropy.units.Quantity`\n            The 3D distance between the coordinates. Shape matches\n            ``idxsearcharound`` and ``idxself``.\n\n        Notes\n        -----\n        This method requires `SciPy <https://www.scipy.org/>`_ (>=0.12.0) to be\n        installed or it will fail.\n\n        In the current implementation, the return values are always sorted in\n        the same order as the ``searcharoundcoords`` (so ``idxsearcharound`` is\n        in ascending order).  This is considered an implementation detail,\n        though, so it could change in a future release.\n\n        See Also\n        --------\n        astropy.coordinates.search_around_sky\n        SkyCoord.search_around_3d\n        \"\"\"\n        from .matching import search_around_sky\n\n        return search_around_sky(searcharoundcoords, self, seplimit,\n                                 storekdtree='_kdtree_sky')\n\n    def search_around_3d(self, searcharoundcoords, distlimit):\n        \"\"\"\n        Searches for all coordinates in this object around a supplied set of\n        points within a given 3D radius.\n\n        This is intended for use on `~astropy.coordinates.SkyCoord` objects\n        with coordinate arrays, rather than a scalar coordinate.  For a scalar\n        coordinate, it is better to use\n        `~astropy.coordinates.SkyCoord.separation_3d`.\n\n        For more on how to use this (and related) functionality, see the\n        examples in :doc:`/coordinates/matchsep`.\n\n        Parameters\n        ----------\n        searcharoundcoords : `~astropy.coordinates.SkyCoord` or `~astropy.coordinates.BaseCoordinateFrame`\n            The coordinates to search around to try to find matching points in\n            this `SkyCoord`. This should be an object with array coordinates,\n            not a scalar coordinate object.\n        distlimit : `~astropy.units.Quantity` with distance units\n            The physical radius to search within.\n\n        Returns\n        -------\n        idxsearcharound : integer array\n            Indices into ``searcharoundcoords`` that match the\n            corresponding elements of ``idxself``. Shape matches\n            ``idxself``.\n        idxself : integer array\n            Indices into ``self`` that match the\n            corresponding elements of ``idxsearcharound``. Shape matches\n            ``idxsearcharound``.\n        sep2d : `~astropy.coordinates.Angle`\n            The on-sky separation between the coordinates. Shape matches\n            ``idxsearcharound`` and ``idxself``.\n        dist3d : `~astropy.units.Quantity`\n            The 3D distance between the coordinates. Shape matches\n            ``idxsearcharound`` and ``idxself``.\n\n        Notes\n        -----\n        This method requires `SciPy <https://www.scipy.org/>`_ (>=0.12.0) to be\n        installed or it will fail.\n\n        In the current implementation, the return values are always sorted in\n        the same order as the ``searcharoundcoords`` (so ``idxsearcharound`` is\n        in ascending order).  This is considered an implementation detail,\n        though, so it could change in a future release.\n\n        See Also\n        --------\n        astropy.coordinates.search_around_3d\n        SkyCoord.search_around_sky\n        \"\"\"\n        from .matching import search_around_3d\n\n        return search_around_3d(searcharoundcoords, self, distlimit,\n                                storekdtree='_kdtree_3d')\n\n    def position_angle(self, other):\n        \"\"\"\n        Computes the on-sky position angle (East of North) between this\n        `SkyCoord` and another.\n\n        Parameters\n        ----------\n        other : `SkyCoord`\n            The other coordinate to compute the position angle to.  It is\n            treated as the \"head\" of the vector of the position angle.\n\n        Returns\n        -------\n        pa : `~astropy.coordinates.Angle`\n            The (positive) position angle of the vector pointing from ``self``\n            to ``other``.  If either ``self`` or ``other`` contain arrays, this\n            will be an array following the appropriate `numpy` broadcasting\n            rules.\n\n        Examples\n        --------\n\n        >>> c1 = SkyCoord(0*u.deg, 0*u.deg)\n        >>> c2 = SkyCoord(1*u.deg, 0*u.deg)\n        >>> c1.position_angle(c2).degree\n        90.0\n        >>> c3 = SkyCoord(1*u.deg, 1*u.deg)\n        >>> c1.position_angle(c3).degree  # doctest: +FLOAT_CMP\n        44.995636455344844\n        \"\"\"\n        from . import angle_utilities\n\n        if not self.is_equivalent_frame(other):\n            try:\n                other = other.transform_to(self, merge_attributes=False)\n            except TypeError:\n                raise TypeError('Can only get position_angle to another '\n                                'SkyCoord or a coordinate frame with data')\n\n        slat = self.represent_as(UnitSphericalRepresentation).lat\n        slon = self.represent_as(UnitSphericalRepresentation).lon\n        olat = other.represent_as(UnitSphericalRepresentation).lat\n        olon = other.represent_as(UnitSphericalRepresentation).lon\n\n        return angle_utilities.position_angle(slon, slat, olon, olat)\n\n    def skyoffset_frame(self, rotation=None):\n        \"\"\"\n        Returns the sky offset frame with this `SkyCoord` at the origin.\n\n        Returns\n        -------\n        astrframe : `~astropy.coordinates.SkyOffsetFrame`\n            A sky offset frame of the same type as this `SkyCoord` (e.g., if\n            this object has an ICRS coordinate, the resulting frame is\n            SkyOffsetICRS, with the origin set to this object)\n        rotation : `~astropy.coordinates.Angle` or `~astropy.units.Quantity` with angle units\n            The final rotation of the frame about the ``origin``. The sign of\n            the rotation is the left-hand rule. That is, an object at a\n            particular position angle in the un-rotated system will be sent to\n            the positive latitude (z) direction in the final frame.\n        \"\"\"\n        return SkyOffsetFrame(origin=self, rotation=rotation)\n\n    def get_constellation(self, short_name=False, constellation_list='iau'):\n        \"\"\"\n        Determines the constellation(s) of the coordinates this `SkyCoord`\n        contains.\n\n        Parameters\n        ----------\n        short_name : bool\n            If True, the returned names are the IAU-sanctioned abbreviated\n            names.  Otherwise, full names for the constellations are used.\n        constellation_list : str\n            The set of constellations to use.  Currently only ``'iau'`` is\n            supported, meaning the 88 \"modern\" constellations endorsed by the IAU.\n\n        Returns\n        -------\n        constellation : str or string array\n            If this is a scalar coordinate, returns the name of the\n            constellation.  If it is an array `SkyCoord`, it returns an array of\n            names.\n\n        Notes\n        -----\n        To determine which constellation a point on the sky is in, this first\n        precesses to B1875, and then uses the Delporte boundaries of the 88\n        modern constellations, as tabulated by\n        `Roman 1987 <http://cdsarc.u-strasbg.fr/viz-bin/Cat?VI/42>`_.\n\n        See Also\n        --------\n        astropy.coordinates.get_constellation\n        \"\"\"\n        from .funcs import get_constellation\n\n        # because of issue #7028, the conversion to a PrecessedGeocentric\n        # system fails in some cases.  Work around is to  drop the velocities.\n        # they are not needed here since only position infromation is used\n        extra_frameattrs = {nm: getattr(self, nm)\n                            for nm in self._extra_frameattr_names}\n        novel = SkyCoord(self.realize_frame(self.data.without_differentials()),\n                         **extra_frameattrs)\n        return get_constellation(novel, short_name, constellation_list)\n\n        # the simpler version below can be used when gh-issue #7028 is resolved\n        # return get_constellation(self, short_name, constellation_list)\n\n    # WCS pixel to/from sky conversions\n    def to_pixel(self, wcs, origin=0, mode='all'):\n        \"\"\"\n        Convert this coordinate to pixel coordinates using a `~astropy.wcs.WCS`\n        object.\n\n        Parameters\n        ----------\n        wcs : `~astropy.wcs.WCS`\n            The WCS to use for convert\n        origin : int\n            Whether to return 0 or 1-based pixel coordinates.\n        mode : 'all' or 'wcs'\n            Whether to do the transformation including distortions (``'all'``) or\n            only including only the core WCS transformation (``'wcs'``).\n\n        Returns\n        -------\n        xp, yp : `numpy.ndarray`\n            The pixel coordinates\n\n        See Also\n        --------\n        astropy.wcs.utils.skycoord_to_pixel : the implementation of this method\n        \"\"\"\n        return skycoord_to_pixel(self, wcs=wcs, origin=origin, mode=mode)\n\n    @classmethod\n    def from_pixel(cls, xp, yp, wcs, origin=0, mode='all'):\n        \"\"\"\n        Create a new `SkyCoord` from pixel coordinates using an\n        `~astropy.wcs.WCS` object.\n\n        Parameters\n        ----------\n        xp, yp : float or `numpy.ndarray`\n            The coordinates to convert.\n        wcs : `~astropy.wcs.WCS`\n            The WCS to use for convert\n        origin : int\n            Whether to return 0 or 1-based pixel coordinates.\n        mode : 'all' or 'wcs'\n            Whether to do the transformation including distortions (``'all'``) or\n            only including only the core WCS transformation (``'wcs'``).\n\n        Returns\n        -------\n        coord : an instance of this class\n            A new object with sky coordinates corresponding to the input ``xp``\n            and ``yp``.\n\n        See Also\n        --------\n        to_pixel : to do the inverse operation\n        astropy.wcs.utils.pixel_to_skycoord : the implementation of this method\n        \"\"\"\n        return pixel_to_skycoord(xp, yp, wcs=wcs, origin=origin, mode=mode, cls=cls)\n\n    def contained_by(self, wcs, image=None, **kwargs):\n        \"\"\"\n        Determines if the SkyCoord is contained in the given wcs footprint.\n\n        Parameters\n        ----------\n        wcs : `~astropy.wcs.WCS`\n            The coordinate to check if it is within the wcs coordinate.\n        image : array\n            Optional.  The image associated with the wcs object that the cooordinate\n            is being checked against. If not given the naxis keywords will be used\n            to determine if the coordinate falls within the wcs footprint.\n        **kwargs :\n           Additional arguments to pass to `~astropy.coordinates.SkyCoord.to_pixel`\n\n        Returns\n        -------\n        response : bool\n           True means the WCS footprint contains the coordinate, False means it does not.\n        \"\"\"\n\n        if image is not None:\n            ymax, xmax = image.shape\n        else:\n            xmax, ymax = wcs._naxis\n\n        import warnings\n        with warnings.catch_warnings():\n            #  Suppress warnings since they just mean we didn't find the coordinate\n            warnings.simplefilter(\"ignore\")\n            try:\n                x, y = self.to_pixel(wcs, **kwargs)\n            except Exception:\n                return False\n\n        return (x < xmax) & (x > 0) & (y < ymax) & (y > 0)\n\n    def radial_velocity_correction(self, kind='barycentric', obstime=None,\n                                   location=None):\n        \"\"\"\n        Compute the correction required to convert a radial velocity at a given\n        time and place on the Earth's Surface to a barycentric or heliocentric\n        velocity.\n\n        Parameters\n        ----------\n        kind : str\n            The kind of velocity correction.  Must be 'barycentric' or\n            'heliocentric'.\n        obstime : `~astropy.time.Time` or None, optional\n            The time at which to compute the correction.  If `None`, the\n            ``obstime`` frame attribute on the `SkyCoord` will be used.\n        location : `~astropy.coordinates.EarthLocation` or None, optional\n            The observer location at which to compute the correction.  If\n            `None`, the  ``location`` frame attribute on the passed-in\n            ``obstime`` will be used, and if that is None, the ``location``\n            frame attribute on the `SkyCoord` will be used.\n\n        Raises\n        ------\n        ValueError\n            If either ``obstime`` or ``location`` are passed in (not ``None``)\n            when the frame attribute is already set on this `SkyCoord`.\n        TypeError\n            If ``obstime`` or ``location`` aren't provided, either as arguments\n            or as frame attributes.\n\n        Returns\n        -------\n        vcorr : `~astropy.units.Quantity` with velocity units\n            The  correction with a positive sign.  I.e., *add* this\n            to an observed radial velocity to get the barycentric (or\n            heliocentric) velocity. If m/s precision or better is needed,\n            see the notes below.\n\n        Notes\n        -----\n        The barycentric correction is calculated to higher precision than the\n        heliocentric correction and includes additional physics (e.g time dilation).\n        Use barycentric corrections if m/s precision is required.\n\n        The algorithm here is sufficient to perform corrections at the mm/s level, but\n        care is needed in application. Strictly speaking, the barycentric correction is\n        multiplicative and should be applied as::\n\n          >>> from astropy.time import Time\n          >>> from astropy.coordinates import SkyCoord, EarthLocation\n          >>> from astropy.constants import c\n          >>> t = Time(56370.5, format='mjd', scale='utc')\n          >>> loc = EarthLocation('149d33m00.5s','-30d18m46.385s',236.87*u.m)\n          >>> sc = SkyCoord(1*u.deg, 2*u.deg)\n          >>> vcorr = sc.radial_velocity_correction(kind='barycentric', obstime=t, location=loc)  # doctest: +REMOTE_DATA\n          >>> rv = rv + vcorr + rv * vcorr / c  # doctest: +SKIP\n\n        If your target is nearby and/or has finite proper motion you may need to account\n        for terms arising from this. See Wright & Eastman (2014) for details.\n\n        Also note that this method returns the correction velocity in the so-called\n        *optical convention*::\n\n          >>> vcorr = zb * c  # doctest: +SKIP\n\n        where ``zb`` is the barycentric correction redshift as defined in section 3\n        of Wright & Eastman (2014). The application formula given above follows from their\n        equation (11) under assumption that the radial velocity ``rv`` has also been defined\n        using the same optical convention. Note, this can be regarded as a matter of\n        velocity definition and does not by itself imply any loss of accuracy, provided\n        sufficient care has been taken during interpretation of the results. If you need\n        the barycentric correction expressed as the full relativistic velocity (e.g., to provide\n        it as the input to another software which performs the application), the\n        following recipe can be used::\n\n          >>> zb = vcorr / c  # doctest: +REMOTE_DATA\n          >>> zb_plus_one_squared = (zb + 1) ** 2  # doctest: +REMOTE_DATA\n          >>> vcorr_rel = c * (zb_plus_one_squared - 1) / (zb_plus_one_squared + 1)  # doctest: +REMOTE_DATA\n\n        or alternatively using just equivalencies::\n\n          >>> vcorr_rel = vcorr.to(u.Hz, u.doppler_optical(1*u.Hz)).to(vcorr.unit, u.doppler_relativistic(1*u.Hz))  # doctest: +REMOTE_DATA\n\n        See also `~astropy.units.equivalencies.doppler_optical`,\n        `~astropy.units.equivalencies.doppler_radio`, and\n        `~astropy.units.equivalencies.doppler_relativistic` for more information on\n        the velocity conventions.\n\n        The default is for this method to use the builtin ephemeris for\n        computing the sun and earth location.  Other ephemerides can be chosen\n        by setting the `~astropy.coordinates.solar_system_ephemeris` variable,\n        either directly or via ``with`` statement.  For example, to use the JPL\n        ephemeris, do::\n\n          >>> from astropy.coordinates import solar_system_ephemeris\n          >>> sc = SkyCoord(1*u.deg, 2*u.deg)\n          >>> with solar_system_ephemeris.set('jpl'):  # doctest: +REMOTE_DATA\n          ...     rv += sc.radial_velocity_correction(obstime=t, location=loc)  # doctest: +SKIP\n\n        \"\"\"\n        # has to be here to prevent circular imports\n        from .solar_system import get_body_barycentric_posvel\n\n        # location validation\n        timeloc = getattr(obstime, 'location', None)\n        if location is None:\n            if self.location is not None:\n                location = self.location\n                if timeloc is not None:\n                    raise ValueError('`location` cannot be in both the '\n                                     'passed-in `obstime` and this `SkyCoord` '\n                                     'because it is ambiguous which is meant '\n                                     'for the radial_velocity_correction.')\n            elif timeloc is not None:\n                location = timeloc\n            else:\n                raise TypeError('Must provide a `location` to '\n                                'radial_velocity_correction, either as a '\n                                'SkyCoord frame attribute, as an attribute on '\n                                'the passed in `obstime`, or in the method '\n                                'call.')\n\n        elif self.location is not None or timeloc is not None:\n            raise ValueError('Cannot compute radial velocity correction if '\n                             '`location` argument is passed in and there is '\n                             'also a  `location` attribute on this SkyCoord or '\n                             'the passed-in `obstime`.')\n\n        # obstime validation\n        if obstime is None:\n            obstime = self.obstime\n            if obstime is None:\n                raise TypeError('Must provide an `obstime` to '\n                                'radial_velocity_correction, either as a '\n                                'SkyCoord frame attribute or in the method '\n                                'call.')\n        elif self.obstime is not None:\n            raise ValueError('Cannot compute radial velocity correction if '\n                             '`obstime` argument is passed in and it is '\n                             'inconsistent with the `obstime` frame '\n                             'attribute on the SkyCoord')\n\n        pos_earth, v_earth = get_body_barycentric_posvel('earth', obstime)\n        if kind == 'barycentric':\n            v_origin_to_earth = v_earth\n        elif kind == 'heliocentric':\n            v_sun = get_body_barycentric_posvel('sun', obstime)[1]\n            v_origin_to_earth = v_earth - v_sun\n        else:\n            raise ValueError(\"`kind` argument to radial_velocity_correction must \"\n                             \"be 'barycentric' or 'heliocentric', but got \"\n                             \"'{}'\".format(kind))\n\n        gcrs_p, gcrs_v = location.get_gcrs_posvel(obstime)\n        # transforming to GCRS is not the correct thing to do here, since we don't want to\n        # include aberration (or light deflection)? Instead, only apply parallax if necessary\n        if self.data.__class__ is UnitSphericalRepresentation:\n            targcart = self.icrs.cartesian\n        else:\n            # skycoord has distances so apply parallax\n            obs_icrs_cart = pos_earth + gcrs_p\n            icrs_cart = self.icrs.cartesian\n            targcart = icrs_cart - obs_icrs_cart\n            targcart /= targcart.norm()\n\n        if kind == 'barycentric':\n            beta_obs = (v_origin_to_earth + gcrs_v) / speed_of_light\n            gamma_obs = 1 / np.sqrt(1 - beta_obs.norm()**2)\n            gr = location.gravitational_redshift(obstime)\n            # barycentric redshift according to eq 28 in Wright & Eastmann (2014),\n            # neglecting Shapiro delay and effects of the star's own motion\n            zb = gamma_obs * (1 + targcart.dot(beta_obs)) / (1 + gr/speed_of_light) - 1\n            return zb * speed_of_light\n        else:\n            # do a simpler correction ignoring time dilation and gravitational redshift\n            # this is adequate since Heliocentric corrections shouldn't be used if\n            # cm/s precision is required.\n            return targcart.dot(v_origin_to_earth + gcrs_v)\n\n    # Table interactions\n    @classmethod\n    def guess_from_table(cls, table, **coord_kwargs):\n        r\"\"\"\n        A convenience method to create and return a new `SkyCoord` from the data\n        in an astropy Table.\n\n        This method matches table columns that start with the case-insensitive\n        names of the the components of the requested frames, if they are also\n        followed by a non-alphanumeric character. It will also match columns\n        that *end* with the component name if a non-alphanumeric character is\n        *before* it.\n\n        For example, the first rule means columns with names like\n        ``'RA[J2000]'`` or ``'ra'`` will be interpreted as ``ra`` attributes for\n        `~astropy.coordinates.ICRS` frames, but ``'RAJ2000'`` or ``'radius'``\n        are *not*. Similarly, the second rule applied to the\n        `~astropy.coordinates.Galactic` frame means that a column named\n        ``'gal_l'`` will be used as the the ``l`` component, but ``gall`` or\n        ``'fill'`` will not.\n\n        The definition of alphanumeric here is based on Unicode's definition\n        of alphanumeric, except without ``_`` (which is normally considered\n        alphanumeric).  So for ASCII, this means the non-alphanumeric characters\n        are ``<space>_!\"#$%&'()*+,-./\\:;<=>?@[]^`{|}~``).\n\n        Parameters\n        ----------\n        table : astropy.Table\n            The table to load data from.\n        coord_kwargs\n            Any additional keyword arguments are passed directly to this class's\n            constructor.\n\n        Returns\n        -------\n        newsc : same as this class\n            The new `SkyCoord` (or subclass) object.\n        \"\"\"\n        _frame_cls, _frame_kwargs = _get_frame_without_data([], coord_kwargs)\n        frame = _frame_cls(**_frame_kwargs)\n        coord_kwargs['frame'] = coord_kwargs.get('frame', frame)\n\n        comp_kwargs = {}\n        for comp_name in frame.representation_component_names:\n            # this matches things like 'ra[...]'' but *not* 'rad'.\n            # note that the \"_\" must be in there explicitly, because\n            # \"alphanumeric\" usually includes underscores.\n            starts_with_comp = comp_name + r'(\\W|\\b|_)'\n            # this part matches stuff like 'center_ra', but *not*\n            # 'aura'\n            ends_with_comp = r'.*(\\W|\\b|_)' + comp_name + r'\\b'\n            # the final regex ORs together the two patterns\n            rex = re.compile('(' + starts_with_comp + ')|(' + ends_with_comp + ')',\n                             re.IGNORECASE | re.UNICODE)\n\n            for col_name in table.colnames:\n                if rex.match(col_name):\n                    if comp_name in comp_kwargs:\n                        oldname = comp_kwargs[comp_name].name\n                        msg = ('Found at least two matches for  component \"{0}\"'\n                               ': \"{1}\" and \"{2}\". Cannot continue with this '\n                               'ambiguity.')\n                        raise ValueError(msg.format(comp_name, oldname, col_name))\n                    comp_kwargs[comp_name] = table[col_name]\n\n        for k, v in comp_kwargs.items():\n            if k in coord_kwargs:\n                raise ValueError('Found column \"{}\" in table, but it was '\n                                 'already provided as \"{}\" keyword to '\n                                 'guess_from_table function.'.format(v.name, k))\n            else:\n                coord_kwargs[k] = v\n\n        return cls(**coord_kwargs)\n\n    # Name resolve\n    @classmethod\n    def from_name(cls, name, frame='icrs', parse=False):\n        \"\"\"\n        Given a name, query the CDS name resolver to attempt to retrieve\n        coordinate information for that object. The search database, sesame\n        url, and  query timeout can be set through configuration items in\n        ``astropy.coordinates.name_resolve`` -- see docstring for\n        `~astropy.coordinates.get_icrs_coordinates` for more\n        information.\n\n        Parameters\n        ----------\n        name : str\n            The name of the object to get coordinates for, e.g. ``'M42'``.\n        frame : str or `BaseCoordinateFrame` class or instance\n            The frame to transform the object to.\n        parse: bool\n            Whether to attempt extracting the coordinates from the name by\n            parsing with a regex. For objects catalog names that have\n            J-coordinates embedded in their names eg:\n            'CRTS SSS100805 J194428-420209', this may be much faster than a\n            sesame query for the same object name. The coordinates extracted\n            in this way may differ from the database coordinates by a few\n            deci-arcseconds, so only use this option if you do not need\n            sub-arcsecond accuracy for coordinates.\n\n        Returns\n        -------\n        coord : SkyCoord\n            Instance of the SkyCoord class.\n        \"\"\"\n\n        from .name_resolve import get_icrs_coordinates\n\n        icrs_coord = get_icrs_coordinates(name, parse)\n        icrs_sky_coord = cls(icrs_coord)\n        if frame in ('icrs', icrs_coord.__class__):\n            return icrs_sky_coord\n        else:\n            return icrs_sky_coord.transform_to(frame)\n"
    }
  ]
}