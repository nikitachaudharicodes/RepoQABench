{
  "repo_name": "oppia_oppia",
  "issue_id": "3146",
  "issue_description": "# \"Restart From Beginning\" Button is not responding\n\n\r\nWhile previewing the created exploration, there is a \"Restart From Beginning\" Button at the bottom of the page, which is not working. \r\nSteps to reproduce:\r\n1. Login.\r\n2. Create a new exploration.\r\n3. Add some slides/interaction.\r\n4. Preview the exploration at any of those slides.\r\n5. Press \"Restart From Beginning\" Button ( at the bottom of the page)\r\nNOTHING HAPPENS! (expected to start the preview from the 1st slide of the exploration)\r\n\r\nmore simply just click [here](https://www.oppia.org/create/BvpDpLSmO2Iu#/preview/Syntax%20Counts) and go through step 5 (directly). \r\n![screenshot from 2017-03-02 11 22 49](https://cloud.githubusercontent.com/assets/16653571/23494880/6c868d02-ff3b-11e6-9cf1-c880525d1638.png)\r\n@jaredsilver Can you confirm if this is bug?\r\n[Chrome, Ubuntu(Linux)]",
  "issue_comments": [
    {
      "id": 283586783,
      "user": "seanlip",
      "body": "@DubeySandeep, can you please provide clear minimal repro instructions starting from a clean dev server? See e.g. the way this is explained: https://github.com/oppia/oppia/issues/3131\r\n\r\nThanks!"
    },
    {
      "id": 283589412,
      "user": "DubeySandeep",
      "body": "Done! \r\nThanks :)\r\n@seanlip "
    },
    {
      "id": 283590007,
      "user": "seanlip",
      "body": "/cc @tjiang11, @arun1595 -- just to check, this doesn't happen to be related to the bug that was fixed in #3125, does it? (I remember that was breaking some preview-related tests.)"
    },
    {
      "id": 283592129,
      "user": "brucelee0110",
      "body": "can I start to work on this?"
    },
    {
      "id": 283592288,
      "user": "seanlip",
      "body": "Sure! Please accept the invitation at github.com/oppia and then feel free to assign yourself to it."
    },
    {
      "id": 283610863,
      "user": "brucelee0110",
      "body": "When I try to fix this bug, I notice that if I press the \"Preview\" button in the navigator at the top, it is not working(after step 4 described above).  I am not sure wether it was designed to work like this, but personally I think adding this functionality will be more user-friendly.\r\n![6c868d02-ff3b-11e6-9cf1-c880525d1638](https://cloud.githubusercontent.com/assets/20383674/23502411/c4931fce-ff72-11e6-9484-d68019a29b06.png)\r\n\r\nI suppose pressing this button will reload the exploration the same way as the \"Restart From Beginning\" Button at the bottom."
    },
    {
      "id": 283847627,
      "user": "tjiang11",
      "body": "Hi @brucefeynman . Looks like this bug was introduced by my PR https://github.com/oppia/oppia/pull/2883 since in PreviewTab.js, resetPreview() calls loadPreviewState() but I changed the functionality of loadPreviewState() to only load settings from the editor rather than the state/exploration itself (so maybe this could actually be replaced with a better name). You'll want to make it so that resetPreview interacts with oppiaPlayerService in some way to reset the player to the beginning of the exploration."
    },
    {
      "id": 283848267,
      "user": "seanlip",
      "body": "Hi @brucefeynman -- with regards to the question you brought up in your comment, let's file a new bug for that and handle it separately. I am not sure what the correct behaviour should be here, but it should be possible to fix the existing bug while leaving that one for later. Thanks!"
    },
    {
      "id": 283860601,
      "user": "jaredsilver",
      "body": "Thanks @DubeySandeep! I was able to reproduce this successfully."
    },
    {
      "id": 283894670,
      "user": "seanlip",
      "body": "Hi @brucefeynman, I still can't seem to assign you to this issue. Could you accept the invitation at github.com/oppia?\r\n\r\nThanks!"
    },
    {
      "id": 284137753,
      "user": "brucelee0110",
      "body": "Sorry,@sean, I didn't get it either from my email or oppia home page on github. I don't know what went wrong. Maybe I open too many github pages? Please add me one more time. Thanks"
    },
    {
      "id": 284175610,
      "user": "seanlip",
      "body": "That's odd -- you do still seem to be in the \"invited\" list. Try https://github.com/oppia/oppia/invitations ?"
    },
    {
      "id": 284193395,
      "user": "DubeySandeep",
      "body": "that was just by mistake! I was searching for @brucefeynman and accidently I was assigned."
    },
    {
      "id": 285843484,
      "user": "anthkris",
      "body": "Hiya @brucefeynman ! I see that there was some confusion about getting you into the github org originally but it's been sorted out. Have you been able to make any progress on this?"
    },
    {
      "id": 290939341,
      "user": "FangYo",
      "body": "Given the change log of the [expected behaviour of this functionality](https://github.com/oppia/oppia/blob/a56644dcb24d73ad278a026e9b0580429f197f53/CHANGELOG#L523), this issue has recently become a concern of mine as well. I think the problem may be associated with [this function](https://github.com/oppia/oppia/blob/055fd4b2ce1620dda020ebe1afcf5336071dfeab/core/templates/dev/head/pages/exploration_editor/preview_tab/PreviewTab.js#L146) and the one above it. @brucefeynman Would be glad to learn about the progress you have made! "
    },
    {
      "id": 291421718,
      "user": "seanlip",
      "body": "Deassigning @brucefeynman due to lack of response."
    },
    {
      "id": 292078597,
      "user": "ghost",
      "body": "Invistigating why \"resetPreview()\" is not called after pressing \"Restart From Beginning\" "
    },
    {
      "id": 294105236,
      "user": "seanlip",
      "body": "Hi @pdalavi -- how is this going?"
    },
    {
      "id": 294148984,
      "user": "ghost",
      "body": "Actually i am not able to find the root cause and also review button disables,"
    },
    {
      "id": 294261597,
      "user": "seanlip",
      "body": "OK. Should we deassign you, then?"
    },
    {
      "id": 304204446,
      "user": "seanlip",
      "body": "Hi @lunrong! Mind taking a look at this? "
    },
    {
      "id": 304730388,
      "user": "tjiang11",
      "body": "@lunrong ping"
    },
    {
      "id": 304767939,
      "user": "lunrong",
      "body": "working on it ~ @tjiang11 "
    },
    {
      "id": 307660326,
      "user": "wxyxinyu",
      "body": "Hi @lunrong -- how is this going?"
    },
    {
      "id": 307867913,
      "user": "lunrong",
      "body": "sorry for the delay, i'm little busy in these weeks, didn't get much progress yet "
    },
    {
      "id": 316659404,
      "user": "seanlip",
      "body": "Hi @muxout -- would you like to take a crack at this?"
    },
    {
      "id": 319435173,
      "user": "anthkris",
      "body": "Howdy @muxout How is this going?"
    },
    {
      "id": 322363283,
      "user": "kevinlee12",
      "body": "Hi @muxout, how this is issue coming along? "
    },
    {
      "id": 325864556,
      "user": "pranavsid98",
      "body": "De assigning @muxout - feel free to assign yourself when you're free work on this! Thanks!"
    },
    {
      "id": 342170269,
      "user": "DubeySandeep",
      "body": "May I can work on this? @seanlip \r\nFew questions:\r\nLet us assume an exploration consists of 10 cards. We started previewing from 5th card and went upto 8th card on preview, So this \"Restart from beginning\" will take me to the 5th card Or 1st card?"
    }
  ],
  "text_context": "# \"Restart From Beginning\" Button is not responding\n\n\r\nWhile previewing the created exploration, there is a \"Restart From Beginning\" Button at the bottom of the page, which is not working. \r\nSteps to reproduce:\r\n1. Login.\r\n2. Create a new exploration.\r\n3. Add some slides/interaction.\r\n4. Preview the exploration at any of those slides.\r\n5. Press \"Restart From Beginning\" Button ( at the bottom of the page)\r\nNOTHING HAPPENS! (expected to start the preview from the 1st slide of the exploration)\r\n\r\nmore simply just click [here](https://www.oppia.org/create/BvpDpLSmO2Iu#/preview/Syntax%20Counts) and go through step 5 (directly). \r\n![screenshot from 2017-03-02 11 22 49](https://cloud.githubusercontent.com/assets/16653571/23494880/6c868d02-ff3b-11e6-9cf1-c880525d1638.png)\r\n@jaredsilver Can you confirm if this is bug?\r\n[Chrome, Ubuntu(Linux)]\n\n@DubeySandeep, can you please provide clear minimal repro instructions starting from a clean dev server? See e.g. the way this is explained: https://github.com/oppia/oppia/issues/3131\r\n\r\nThanks!\n\nDone! \r\nThanks :)\r\n@seanlip \n\n/cc @tjiang11, @arun1595 -- just to check, this doesn't happen to be related to the bug that was fixed in #3125, does it? (I remember that was breaking some preview-related tests.)\n\ncan I start to work on this?\n\nSure! Please accept the invitation at github.com/oppia and then feel free to assign yourself to it.\n\nWhen I try to fix this bug, I notice that if I press the \"Preview\" button in the navigator at the top, it is not working(after step 4 described above).  I am not sure wether it was designed to work like this, but personally I think adding this functionality will be more user-friendly.\r\n![6c868d02-ff3b-11e6-9cf1-c880525d1638](https://cloud.githubusercontent.com/assets/20383674/23502411/c4931fce-ff72-11e6-9484-d68019a29b06.png)\r\n\r\nI suppose pressing this button will reload the exploration the same way as the \"Restart From Beginning\" Button at the bottom.\n\nHi @brucefeynman . Looks like this bug was introduced by my PR https://github.com/oppia/oppia/pull/2883 since in PreviewTab.js, resetPreview() calls loadPreviewState() but I changed the functionality of loadPreviewState() to only load settings from the editor rather than the state/exploration itself (so maybe this could actually be replaced with a better name). You'll want to make it so that resetPreview interacts with oppiaPlayerService in some way to reset the player to the beginning of the exploration.\n\nHi @brucefeynman -- with regards to the question you brought up in your comment, let's file a new bug for that and handle it separately. I am not sure what the correct behaviour should be here, but it should be possible to fix the existing bug while leaving that one for later. Thanks!\n\nThanks @DubeySandeep! I was able to reproduce this successfully.\n\nHi @brucefeynman, I still can't seem to assign you to this issue. Could you accept the invitation at github.com/oppia?\r\n\r\nThanks!\n\nSorry,@sean, I didn't get it either from my email or oppia home page on github. I don't know what went wrong. Maybe I open too many github pages? Please add me one more time. Thanks\n\nThat's odd -- you do still seem to be in the \"invited\" list. Try https://github.com/oppia/oppia/invitations ?\n\nthat was just by mistake! I was searching for @brucefeynman and accidently I was assigned.\n\nHiya @brucefeynman ! I see that there was some confusion about getting you into the github org originally but it's been sorted out. Have you been able to make any progress on this?\n\nGiven the change log of the [expected behaviour of this functionality](https://github.com/oppia/oppia/blob/a56644dcb24d73ad278a026e9b0580429f197f53/CHANGELOG#L523), this issue has recently become a concern of mine as well. I think the problem may be associated with [this function](https://github.com/oppia/oppia/blob/055fd4b2ce1620dda020ebe1afcf5336071dfeab/core/templates/dev/head/pages/exploration_editor/preview_tab/PreviewTab.js#L146) and the one above it. @brucefeynman Would be glad to learn about the progress you have made! \n\nDeassigning @brucefeynman due to lack of response.\n\nInvistigating why \"resetPreview()\" is not called after pressing \"Restart From Beginning\" \n\nHi @pdalavi -- how is this going?\n\nActually i am not able to find the root cause and also review button disables,\n\nOK. Should we deassign you, then?\n\nHi @lunrong! Mind taking a look at this? \n\n@lunrong ping\n\nworking on it ~ @tjiang11 \n\nHi @lunrong -- how is this going?\n\nsorry for the delay, i'm little busy in these weeks, didn't get much progress yet \n\nHi @muxout -- would you like to take a crack at this?\n\nHowdy @muxout How is this going?\n\nHi @muxout, how this is issue coming along? \n\nDe assigning @muxout - feel free to assign yourself when you're free work on this! Thanks!\n\nMay I can work on this? @seanlip \r\nFew questions:\r\nLet us assume an exploration consists of 10 cards. We started previewing from 5th card and went upto 8th card on preview, So this \"Restart from beginning\" will take me to the 5th card Or 1st card?",
  "pr_link": "https://github.com/oppia/oppia/pull/2883",
  "code_context": [
    {
      "filename": "core/templates/dev/head/domain/exploration/AnswerGroupObjectFactory.js",
      "content": "// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\noppia.factory('AnswerGroupObjectFactory', [function() {\n  var AnswerGroup = function(ruleSpecs, outcome) {\n    this.ruleSpecs = ruleSpecs;\n    this.outcome = outcome;\n  };\n\n  AnswerGroup.prototype.toBackendDict = function() {\n    return {\n      rule_specs: this.ruleSpecs,\n      outcome: this.outcome\n    };\n  };\n\n  // Static class methods. Note that \"this\" is not available in\n  // static contexts.\n  AnswerGroup.create = function(ruleSpecs, outcome) {\n    return new AnswerGroup(ruleSpecs, outcome);\n  };\n\n  return AnswerGroup;\n}]);\n"
    },
    {
      "filename": "core/templates/dev/head/domain/exploration/ExplorationObjectFactory.js",
      "content": "// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating new frontend instances of Exploration\n * domain objects.\n */\n\noppia.factory('ExplorationObjectFactory', [\n  'INTERACTION_SPECS', 'INTERACTION_DISPLAY_MODE_INLINE',\n  'StateObjectFactory', 'UrlInterpolationService',\n  function(\n      INTERACTION_SPECS, INTERACTION_DISPLAY_MODE_INLINE, StateObjectFactory,\n      UrlInterpolationService) {\n    var Exploration = function(\n        initStateName, paramChanges, paramSpecs, skinCustomizations, states,\n        title, languageCode) {\n      this.initStateName = initStateName;\n      this.paramChanges = paramChanges;\n      this.paramSpecs = paramSpecs;\n      this.skinCustomizations = skinCustomizations;\n      this.title = title;\n      this.languageCode = languageCode;\n\n      this.states = {};\n      for (var stateName in states) {\n        this.states[stateName] = StateObjectFactory.create(\n          stateName, states[stateName]);\n      }\n    };\n\n    // Instance methods\n    Exploration.prototype.isStateTerminal = function(stateName) {\n      return (\n        stateName && this.getInteractionId(stateName) &&\n        INTERACTION_SPECS[this.getInteractionId(stateName)].is_terminal);\n    };\n\n    Exploration.prototype.getAuthorRecommendedExpIds = function(stateName) {\n      if (!this.isStateTerminal(stateName)) {\n        throw Error(\n          'Tried to get recommendations for a non-terminal state: ' +\n          stateName);\n      }\n\n      return this.getInteractionCustomizationArgs(\n        stateName).recommendedExplorationIds.value;\n    };\n\n    Exploration.prototype.getInteraction = function(stateName) {\n      return this.states[stateName].interaction;\n    };\n\n    Exploration.prototype.getInteractionId = function(stateName) {\n      return this.states[stateName].interaction.id;\n    };\n\n    Exploration.prototype.getInteractionCustomizationArgs =\n      function(stateName) {\n        return this.states[stateName].interaction.customization_args;\n      };\n\n    Exploration.prototype.getInteractionInstructions = function(stateName) {\n      var interactionId = this.getInteractionId(stateName);\n      return interactionId ? INTERACTION_SPECS[interactionId].instructions : '';\n    };\n\n    Exploration.prototype.getNarrowInstructions = function(stateName) {\n      var interactionId = this.getInteractionId(stateName);\n      return (\n        interactionId ?\n        INTERACTION_SPECS[interactionId].narrow_instructions :\n        '');\n    };\n\n    Exploration.prototype.getInteractionThumbnailSrc = function(stateName) {\n      // TODO(sll): unify this with the 'choose interaction' modal in\n      // state_editor_interaction.html.\n      var interactionId = this.getInteractionId(stateName);\n      return interactionId ? (\n        UrlInterpolationService.getInteractionThumbnailImageUrl(interactionId))\n        : '';\n    };\n\n    Exploration.prototype.isInteractionInline = function(stateName) {\n      var interactionId = this.getInteractionId(stateName);\n\n      // Note that we treat a null interaction as an inline one, so that the\n      // error message associated with it is displayed in the most compact way\n      // possible in the learner view.\n      return (\n        !interactionId ||\n        INTERACTION_SPECS[interactionId].display_mode ===\n          INTERACTION_DISPLAY_MODE_INLINE);\n    };\n\n    Exploration.prototype.getGadgetPanelsContents = function() {\n      return this.skinCustomizations.panels_contents;\n    };\n\n    Exploration.prototype.getState = function(stateName) {\n      return this.states[stateName];\n    };\n\n    Exploration.prototype.getInitialState = function() {\n      return this.getState(this.initStateName);\n    };\n\n    Exploration.prototype.setInitialStateName = function(stateName) {\n      this.initStateName = stateName;\n    };\n\n    Exploration.prototype.getUninterpolatedContentHtml = function(stateName) {\n      return this.getState(stateName).content[0].value;\n    };\n\n    // Static class methods. Note that \"this\" is not available in\n    // static contexts.\n    Exploration.create = function(explorationDict) {\n      return new Exploration(\n        explorationDict.init_state_name,\n        explorationDict.param_changes,\n        explorationDict.param_specs,\n        explorationDict.skin_customizations,\n        explorationDict.states,\n        explorationDict.title,\n        explorationDict.language_code);\n    };\n\n    return Exploration;\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/domain/exploration/StateObjectFactory.js",
      "content": "// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory for creating new frontend instances of State\n * domain objects.\n */\n\noppia.factory('StateObjectFactory', [\n  'AnswerGroupObjectFactory',\n  function(AnswerGroupObjectFactory) {\n  var State = function(name, content, interaction, paramChanges) {\n    this.name = name;\n    this.content = content;\n    this.interaction = {\n      answer_groups:\n        generateAnswerGroupsFromBackend(interaction.answer_groups),\n      confirmed_unclassified_answers:\n        interaction.confirmed_unclassified_answers,\n      customization_args: interaction.customization_args,\n      default_outcome: interaction.default_outcome,\n      fallbacks: interaction.fallbacks,\n      id: interaction.id\n    };\n    this.paramChanges = paramChanges;\n  };\n\n  var generateAnswerGroupsFromBackend = function(answerGroupBackendDicts) {\n    var answerGroups = answerGroupBackendDicts.map(function(answerGroupDict) {\n      return AnswerGroupObjectFactory.create(\n        answerGroupDict.rule_specs, answerGroupDict.outcome);\n    });\n\n    return answerGroups;\n  };\n\n  // Instance methods.\n  State.prototype.toBackendDict = function() {\n    return {\n      content: this.content,\n      interaction: this.interaction,\n      param_changes: this.paramChanges\n    };\n  };\n\n  // Static class methods. Note that \"this\" is not available in\n  // static contexts.\n  State.create = function(stateName, stateDict) {\n    return new State(\n      stateName,\n      stateDict.content,\n      stateDict.interaction,\n      stateDict.param_changes);\n  };\n\n  return State;\n}]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/EditorServices.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Standalone services for the exploration editor page.\n */\n\n// Service for handling all interactions with the exploration editor backend.\noppia.factory('explorationData', [\n  '$http', '$log', 'alertsService', '$q',\n  function($http, $log, alertsService, $q) {\n    // The pathname (without the hash) should be: .../create/{exploration_id}\n    var explorationId = '';\n    var pathnameArray = window.location.pathname.split('/');\n    for (var i = 0; i < pathnameArray.length; i++) {\n      if (pathnameArray[i] === 'create') {\n        var explorationId = pathnameArray[i + 1];\n        break;\n      }\n    }\n\n    if (!explorationId) {\n      $log.error(\n        'Unexpected call to explorationData for pathname ', pathnameArray[i]);\n      // Note: if we do not return anything, Karma unit tests fail.\n      return {};\n    }\n\n    var explorationDataUrl = '/createhandler/data/' + explorationId;\n    var resolvedAnswersUrlPrefix = (\n      '/createhandler/resolved_answers/' + explorationId);\n    var explorationDraftAutosaveUrl = (\n      '/createhandler/autosave_draft/' + explorationId);\n\n    // Put exploration variables here.\n    var explorationData = {\n      explorationId: explorationId,\n      autosaveChangeList: function(changeList, successCallback, errorCallback) {\n        $http.put(explorationDraftAutosaveUrl, {\n          change_list: changeList,\n          version: explorationData.data.version\n        }).then(function(response) {\n          if (successCallback) {\n            successCallback(response);\n          }\n        }, function() {\n          if (errorCallback) {\n            errorCallback();\n          }\n        });\n      },\n      discardDraft: function(successCallback, errorCallback) {\n        $http.post(explorationDraftAutosaveUrl, {}).then(function() {\n          if (successCallback) {\n            successCallback();\n          }\n        }, function() {\n          if (errorCallback) {\n            errorCallback();\n          }\n        });\n      },\n      // Returns a promise that supplies the data for the current exploration.\n      getData: function() {\n        if (explorationData.data) {\n          $log.info('Found exploration data in cache.');\n\n          var deferred = $q.defer();\n          deferred.resolve(explorationData.data);\n          return deferred.promise;\n        } else {\n          // Retrieve data from the server.\n          // WARNING: Note that this is a version of the exploration with draft\n          // changes applied. This makes a force-refresh necessary when changes\n          // are discarded, otherwise the exploration-with-draft-changes\n          // (which is cached here) will be reused.\n          return $http.get(explorationDataUrl, {\n            params: {\n              apply_draft: true\n            }\n          }).then(function(response) {\n            $log.info('Retrieved exploration data.');\n            $log.info(response.data);\n\n            explorationData.data = response.data;\n\n            return response.data;\n          });\n        }\n      },\n      // Returns a promise supplying the last saved version for the current\n      // exploration.\n      getLastSavedData: function() {\n        return $http.get(explorationDataUrl).then(function(response) {\n          $log.info('Retrieved saved exploration data.');\n          $log.info(response.data);\n\n          return response.data;\n        });\n      },\n      resolveAnswers: function(stateName, resolvedAnswersList) {\n        alertsService.clearWarnings();\n        $http.put(\n            resolvedAnswersUrlPrefix + '/' + encodeURIComponent(stateName), {\n          resolved_answers: resolvedAnswersList\n        });\n      },\n      /**\n       * Saves the exploration to the backend, and, on a success callback,\n       * updates the local copy of the exploration data.\n       * @param {object} changeList - Represents the change list for\n       *   this save. Each element of the list is a command representing an\n       *   editing action (such as add state, delete state, etc.). See the\n       *  _'Change' class in exp_services.py for full documentation.\n       * @param {string} commitMessage - The user-entered commit message for\n       *   this save operation.\n       */\n      save: function(\n          changeList, commitMessage, successCallback, errorCallback) {\n        $http.put(explorationDataUrl, {\n          change_list: changeList,\n          commit_message: commitMessage,\n          version: explorationData.data.version\n        }).then(function(response) {\n          alertsService.clearWarnings();\n          explorationData.data = response.data;\n          if (successCallback) {\n            successCallback(\n              response.data.is_version_of_draft_valid,\n              response.data.draft_changes);\n          }\n        }, function() {\n          if (errorCallback) {\n            errorCallback();\n          }\n        });\n      }\n    };\n\n    return explorationData;\n  }\n]);\n\n// A service that maintains a record of which state in the exploration is\n// currently active.\noppia.factory('editorContextService', ['$log', function($log) {\n  var activeStateName = null;\n\n  return {\n    getActiveStateName: function() {\n      return activeStateName;\n    },\n    setActiveStateName: function(newActiveStateName) {\n      if (newActiveStateName === '' || newActiveStateName === null) {\n        $log.error('Invalid active state name: ' + newActiveStateName);\n        return;\n      }\n      activeStateName = newActiveStateName;\n    }\n  };\n}]);\n\n// TODO(sll): Should this depend on a versioning service that keeps track of\n// the current active version? Previous versions should not be editable.\noppia.factory('editabilityService', [function() {\n  var isEditable = false;\n  var inTutorialMode = false;\n\n  return {\n    isEditable: function() {\n      return isEditable && !inTutorialMode;\n    },\n    isEditableOutsideTutorialMode: function() {\n      return isEditable;\n    },\n    markEditable: function() {\n      isEditable = true;\n    },\n    markNotEditable: function() {\n      isEditable = false;\n    },\n    onEndTutorial: function() {\n      inTutorialMode = false;\n    },\n    onStartTutorial: function() {\n      inTutorialMode = true;\n    }\n  };\n}]);\n\n// A service that maintains a provisional list of changes to be committed to\n// the server.\noppia.factory('changeListService', [\n  '$rootScope', '$log', 'alertsService', 'explorationData',\n  'autosaveInfoModalsService',\n  function(\n      $rootScope, $log, alertsService, explorationData,\n      autosaveInfoModalsService) {\n    // TODO(sll): Implement undo, redo functionality. Show a message on each\n    // step saying what the step is doing.\n    // TODO(sll): Allow the user to view the list of changes made so far, as\n    // well as the list of changes in the undo stack.\n\n    // Temporary buffer for changes made to the exploration.\n    var explorationChangeList = [];\n    // Stack for storing undone changes. The last element is the most recently\n    // undone change.\n    var undoneChangeStack = [];\n\n    // All these constants should correspond to those in exp_domain.py.\n    // TODO(sll): Enforce this in code.\n    var CMD_ADD_STATE = 'add_state';\n    var CMD_RENAME_STATE = 'rename_state';\n    var CMD_DELETE_STATE = 'delete_state';\n    var CMD_EDIT_STATE_PROPERTY = 'edit_state_property';\n    var CMD_EDIT_EXPLORATION_PROPERTY = 'edit_exploration_property';\n    // All gadget commands\n    var CMD_ADD_GADGET = 'add_gadget';\n    var CMD_RENAME_GADGET = 'rename_gadget';\n    var CMD_DELETE_GADGET = 'delete_gadget';\n    var CMD_EDIT_GADGET_PROPERTY = 'edit_gadget_property';\n\n    var ALLOWED_EXPLORATION_BACKEND_NAMES = {\n      category: true,\n      init_state_name: true,\n      language_code: true,\n      objective: true,\n      param_changes: true,\n      param_specs: true,\n      tags: true,\n      title: true\n    };\n\n    var ALLOWED_STATE_BACKEND_NAMES = {\n      answer_groups: true,\n      confirmed_unclassified_answers: true,\n      content: true,\n      default_outcome: true,\n      fallbacks: true,\n      param_changes: true,\n      state_name: true,\n      widget_customization_args: true,\n      widget_id: true\n    };\n\n    var ALLOWED_GADGET_BACKEND_NAMES = {\n      gadget_customization_args: true,\n      gadget_visibility: true\n    };\n\n    var autosaveChangeListOnChange = function(explorationChangeList) {\n      // Asynchronously send an autosave request, and check for errors in the\n      // response:\n      // If error is present -> Check for the type of error occurred\n      // (Display the corresponding modals in both cases, if not already\n      // opened):\n      // - Version Mismatch.\n      // - Non-strict Validation Fail.\n      explorationData.autosaveChangeList(\n        explorationChangeList,\n        function(response) {\n          if (!response.data.is_version_of_draft_valid) {\n            if (!autosaveInfoModalsService.isModalOpen()) {\n              autosaveInfoModalsService.showVersionMismatchModal(\n                explorationChangeList);\n            }\n          }\n        },\n        function() {\n          alertsService.clearWarnings();\n          $log.error(\n            'nonStrictValidationFailure: ' +\n            JSON.stringify(explorationChangeList));\n          if (!autosaveInfoModalsService.isModalOpen()) {\n            autosaveInfoModalsService.showNonStrictValidationFailModal();\n          }\n        }\n      );\n    };\n\n    var addChange = function(changeDict) {\n      if ($rootScope.loadingMessage) {\n        return;\n      }\n      explorationChangeList.push(changeDict);\n      undoneChangeStack = [];\n      autosaveChangeListOnChange(explorationChangeList);\n    };\n\n    return {\n      /**\n       * Saves a gadget dict that represents a new gadget.\n       *\n       * It is the responsbility of the caller to check that the gadget dict\n       * is correctly formed\n       *\n       * @param {object} gadgetData - The dict containing new gadget info.\n       */\n      addGadget: function(gadgetData) {\n        addChange({\n          cmd: CMD_ADD_GADGET,\n          gadget_dict: gadgetData,\n          panel: gadgetData.panel\n        });\n      },\n      /**\n       * Saves a change dict that represents adding a new state. It is the\n       * responsbility of the caller to check that the new state name is valid.\n       *\n       * @param {string} stateName - The name of the newly-added state\n       */\n      addState: function(stateName) {\n        addChange({\n          cmd: CMD_ADD_STATE,\n          state_name: stateName\n        });\n      },\n      /**\n       * Deletes the gadget with the specified name.\n       *\n       * @param {string} gadgetName - Unique name of the gadget to delete.\n       */\n      deleteGadget: function(gadgetName) {\n        addChange({\n          cmd: CMD_DELETE_GADGET,\n          gadget_name: gadgetName\n        });\n      },\n      /**\n       * Saves a change dict that represents deleting a new state. It is the\n       * responsbility of the caller to check that the deleted state name\n       * corresponds to an existing state.\n       *\n       * @param {string} stateName - The name of the deleted state.\n       */\n      deleteState: function(stateName) {\n        addChange({\n          cmd: CMD_DELETE_STATE,\n          state_name: stateName\n        });\n      },\n      discardAllChanges: function() {\n        explorationChangeList = [];\n        undoneChangeStack = [];\n        explorationData.discardDraft();\n      },\n      /**\n       * Saves a change dict that represents a change to an exploration\n       * property (such as its title, category, ...). It is the responsibility\n       * of the caller to check that the old and new values are not equal.\n       *\n       * @param {string} backendName - The backend name of the property\n       *   (e.g. title, category)\n       * @param {string} newValue - The new value of the property\n       * @param {string} oldValue - The previous value of the property\n       */\n      editExplorationProperty: function(backendName, newValue, oldValue) {\n        if (!ALLOWED_EXPLORATION_BACKEND_NAMES.hasOwnProperty(backendName)) {\n          alertsService.addWarning(\n            'Invalid exploration property: ' + backendName);\n          return;\n        }\n        addChange({\n          cmd: CMD_EDIT_EXPLORATION_PROPERTY,\n          new_value: angular.copy(newValue),\n          old_value: angular.copy(oldValue),\n          property_name: backendName\n        });\n      },\n      /**\n       * Saves a change dict that represents a change to a gadget property.\n       *\n       * It is the responsibility of the caller to check that the old and new\n       * values are not equal.\n       *\n       * @param {string} gadgetName - The name of the gadget being edited\n       * @param {string} backendName - The backend name of the edited property\n       * @param {string} newValue - The new value of the property\n       * @param {string} oldValue - The previous value of the property\n       */\n      editGadgetProperty: function(\n          gadgetName, backendName, newValue, oldValue) {\n        if (!ALLOWED_GADGET_BACKEND_NAMES.hasOwnProperty(backendName)) {\n          alertsService.addWarning('Invalid gadget property: ' + backendName);\n          return;\n        }\n        addChange({\n          cmd: CMD_EDIT_GADGET_PROPERTY,\n          gadget_name: gadgetName,\n          new_value: angular.copy(newValue),\n          old_value: angular.copy(oldValue),\n          property_name: backendName\n        });\n      },\n      /**\n       * Saves a change dict that represents a change to a state property. It\n       * is the responsibility of the caller to check that the old and new\n       * values are not equal.\n       *\n       * @param {string} stateName - The name of the state that is being edited\n       * @param {string} backendName - The backend name of the edited property\n       * @param {string} newValue - The new value of the property\n       * @param {string} oldValue - The previous value of the property\n       */\n      editStateProperty: function(stateName, backendName, newValue, oldValue) {\n        if (!ALLOWED_STATE_BACKEND_NAMES.hasOwnProperty(backendName)) {\n          alertsService.addWarning('Invalid state property: ' + backendName);\n          return;\n        }\n        addChange({\n          cmd: CMD_EDIT_STATE_PROPERTY,\n          new_value: angular.copy(newValue),\n          old_value: angular.copy(oldValue),\n          property_name: backendName,\n          state_name: stateName\n        });\n      },\n      getChangeList: function() {\n        return angular.copy(explorationChangeList);\n      },\n      isExplorationLockedForEditing: function() {\n        return explorationChangeList.length > 0;\n      },\n      /**\n       * Initializes the current changeList with the one received from backend.\n       * This behavior exists only in case of an autosave.\n       *\n       * @param {object} changeList - Autosaved changeList data\n       */\n      loadAutosavedChangeList: function(changeList) {\n        explorationChangeList = changeList;\n      },\n      /**\n       * Saves a change dict that represents the renaming of a gadget.\n       *\n       * It is the responsibility of the caller to check that the two names\n       * are not equal.\n       *\n       * @param {string} oldGadgetName - The previous name of the gadget\n       * @param {string} newGadgetName - The new name of the gadget\n       */\n      renameGadget: function(oldGadgetName, newGadgetName) {\n        addChange({\n          cmd: CMD_RENAME_GADGET,\n          new_gadget_name: newGadgetName,\n          old_gadget_name: oldGadgetName\n        });\n      },\n      /**\n       * Saves a change dict that represents the renaming of a state. This\n       * is also intended to change the initial state name if necessary\n       * (that is, the latter change is implied and does not have to be\n       * recorded separately in another change dict). It is the responsibility\n       * of the caller to check that the two names are not equal.\n       *\n       * @param {string} newStateName - The new name of the state\n       * @param {string} oldStateName - The previous name of the state\n       */\n      renameState: function(newStateName, oldStateName) {\n        addChange({\n          cmd: CMD_RENAME_STATE,\n          new_state_name: newStateName,\n          old_state_name: oldStateName\n        });\n      },\n      undoLastChange: function() {\n        if (explorationChangeList.length === 0) {\n          alertsService.addWarning('There are no changes to undo.');\n          return;\n        }\n        var lastChange = explorationChangeList.pop();\n        undoneChangeStack.push(lastChange);\n        autosaveChangeListOnChange(explorationChangeList);\n      }\n    };\n  }\n]);\n\n// A data service that stores data about the rights for this exploration.\noppia.factory('explorationRightsService', [\n    '$http', '$q', 'explorationData', 'alertsService',\n    function($http, $q, explorationData, alertsService) {\n  return {\n    init: function(\n        ownerNames, editorNames, viewerNames, status, clonedFrom,\n        isCommunityOwned, viewableIfPrivate) {\n      this.ownerNames = ownerNames;\n      this.editorNames = editorNames;\n      this.viewerNames = viewerNames;\n      this._status = status;\n      // This is null if the exploration was not cloned from anything,\n      // otherwise it is the exploration ID of the source exploration.\n      this._clonedFrom = clonedFrom;\n      this._isCommunityOwned = isCommunityOwned;\n      this._viewableIfPrivate = viewableIfPrivate;\n    },\n    clonedFrom: function() {\n      return this._clonedFrom;\n    },\n    isPrivate: function() {\n      return this._status === GLOBALS.ACTIVITY_STATUS_PRIVATE;\n    },\n    isPublic: function() {\n      return this._status === GLOBALS.ACTIVITY_STATUS_PUBLIC;\n    },\n    isPublicized: function() {\n      return this._status === GLOBALS.ACTIVITY_STATUS_PUBLICIZED;\n    },\n    isCloned: function() {\n      return Boolean(this._clonedFrom);\n    },\n    isCommunityOwned: function() {\n      return this._isCommunityOwned;\n    },\n    viewableIfPrivate: function() {\n      return this._viewableIfPrivate;\n    },\n    saveChangeToBackend: function(requestParams) {\n      var whenRightsSaved = $q.defer();\n      var that = this;\n\n      requestParams.version = explorationData.data.version;\n      var explorationRightsUrl = (\n        '/createhandler/rights/' + explorationData.explorationId);\n      $http.put(explorationRightsUrl, requestParams).then(function(response) {\n        var data = response.data;\n        alertsService.clearWarnings();\n        that.init(\n          data.rights.owner_names, data.rights.editor_names,\n          data.rights.viewer_names, data.rights.status,\n          data.rights.cloned_from, data.rights.community_owned,\n          data.rights.viewable_if_private);\n        whenRightsSaved.resolve();\n      });\n      return whenRightsSaved.promise;\n    },\n    saveModeratorChangeToBackend: function(action, emailBody) {\n      var that = this;\n\n      var explorationModeratorRightsUrl = (\n        '/createhandler/moderatorrights/' + explorationData.explorationId);\n      $http.put(explorationModeratorRightsUrl, {\n        action: action,\n        email_body: emailBody,\n        version: explorationData.data.version\n      }).then(function(response) {\n        var data = response.data;\n        alertsService.clearWarnings();\n        that.init(\n          data.rights.owner_names, data.rights.editor_names,\n          data.rights.viewer_names, data.rights.status,\n          data.rights.cloned_from, data.rights.community_owned,\n          data.rights.viewable_if_private);\n      });\n    }\n  };\n}]);\n\noppia.factory('explorationPropertyService', [\n    '$rootScope', '$log', 'changeListService', 'alertsService',\n    function($rootScope, $log, changeListService, alertsService) {\n  // Public base API for data services corresponding to exploration properties\n  // (title, category, etc.)\n  return {\n    init: function(value) {\n      if (this.propertyName === null) {\n        throw 'Exploration property name cannot be null.';\n      }\n\n      $log.info('Initializing exploration ' + this.propertyName + ':', value);\n\n      // The current value of the property (which may not have been saved to the\n      // frontend yet). In general, this will be bound directly to the UI.\n      this.displayed = angular.copy(value);\n      // The previous (saved-in-the-frontend) value of the property. Here,\n      // 'saved' means that this is the latest value of the property as\n      // determined by the frontend change list.\n      this.savedMemento = angular.copy(value);\n\n      $rootScope.$broadcast('explorationPropertyChanged');\n    },\n    // Returns whether the current value has changed from the memento.\n    hasChanged: function() {\n      return !angular.equals(this.savedMemento, this.displayed);\n    },\n    // The backend name for this property. THIS MUST BE SPECIFIED BY SUBCLASSES.\n    propertyName: null,\n    // Transforms the given value into a normalized form. THIS CAN BE\n    // OVERRIDDEN BY SUBCLASSES. The default behavior is to do nothing.\n    _normalize: function(value) {\n      return value;\n    },\n    // Validates the given value and returns a boolean stating whether it\n    // is valid or not. THIS CAN BE OVERRIDDEN BY SUBCLASSES. The default\n    // behavior is to always return true.\n    _isValid: function(value) { // jscs:ignore disallowUnusedParams\n      return true;\n    },\n    // Normalizes the displayed value. Then, if the memento and the displayed\n    // value are the same, does nothing. Otherwise, creates a new entry in the\n    // change list, and updates the memento to the displayed value.\n    saveDisplayedValue: function() {\n      if (this.propertyName === null) {\n        throw 'Exploration property name cannot be null.';\n      }\n\n      this.displayed = this._normalize(this.displayed);\n      if (!this._isValid(this.displayed) || !this.hasChanged()) {\n        this.restoreFromMemento();\n        return;\n      }\n\n      if (angular.equals(this.displayed, this.savedMemento)) {\n        return;\n      }\n\n      alertsService.clearWarnings();\n      changeListService.editExplorationProperty(\n        this.propertyName, this.displayed, this.savedMemento);\n      this.savedMemento = angular.copy(this.displayed);\n\n      $rootScope.$broadcast('explorationPropertyChanged');\n    },\n    // Reverts the displayed value to the saved memento.\n    restoreFromMemento: function() {\n      this.displayed = angular.copy(this.savedMemento);\n    }\n  };\n}]);\n\n// A data service that stores the current exploration title so that it can be\n// displayed and edited in multiple places in the UI.\noppia.factory('explorationTitleService', [\n  'explorationPropertyService', '$filter', 'validatorsService',\n  'explorationRightsService',\n  function(\n    explorationPropertyService, $filter, validatorsService,\n    explorationRightsService) {\n    var child = Object.create(explorationPropertyService);\n    child.propertyName = 'title';\n    child._normalize = $filter('normalizeWhitespace');\n    child._isValid = function(value) {\n      return validatorsService.isValidEntityName(\n        value, true, explorationRightsService.isPrivate());\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the current exploration category so that it can be\n// displayed and edited in multiple places in the UI.\noppia.factory('explorationCategoryService', [\n  'explorationPropertyService', '$filter', 'validatorsService',\n  'explorationRightsService',\n  function(\n    explorationPropertyService, $filter, validatorsService,\n    explorationRightsService) {\n    var child = Object.create(explorationPropertyService);\n    child.propertyName = 'category';\n    child._normalize = $filter('normalizeWhitespace');\n    child._isValid = function(value) {\n      return validatorsService.isValidEntityName(\n        value, true, explorationRightsService.isPrivate());\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the current exploration objective so that it can\n// be displayed and edited in multiple places in the UI.\noppia.factory('explorationObjectiveService', [\n  'explorationPropertyService', '$filter', 'validatorsService',\n  'explorationRightsService',\n  function(\n    explorationPropertyService, $filter, validatorsService,\n    explorationRightsService) {\n    var child = Object.create(explorationPropertyService);\n    child.propertyName = 'objective';\n    child._normalize = $filter('normalizeWhitespace');\n    child._isValid = function(value) {\n      return (\n        explorationRightsService.isPrivate() ||\n        validatorsService.isNonempty(value, false));\n    };\n    return child;\n  }\n]);\n\n// A data service that stores the exploration language code.\noppia.factory('explorationLanguageCodeService', [\n    'explorationPropertyService', function(explorationPropertyService) {\n  var child = Object.create(explorationPropertyService);\n  child.propertyName = 'language_code';\n  child.getAllLanguageCodes = function() {\n    return GLOBALS.ALL_LANGUAGE_CODES;\n  };\n  child.getCurrentLanguageDescription = function() {\n    for (var i = 0; i < GLOBALS.ALL_LANGUAGE_CODES.length; i++) {\n      if (GLOBALS.ALL_LANGUAGE_CODES[i].code === child.displayed) {\n        return GLOBALS.ALL_LANGUAGE_CODES[i].description;\n      }\n    }\n  };\n  child._isValid = function(value) {\n    return GLOBALS.ALL_LANGUAGE_CODES.some(function(elt) {\n      return elt.code === value;\n    });\n  };\n  return child;\n}]);\n\n// A data service that stores the name of the exploration's initial state.\n// NOTE: This service does not perform validation. Users of this service\n// should ensure that new initial state names passed to the service are\n// valid.\noppia.factory('explorationInitStateNameService', [\n    'explorationPropertyService', function(explorationPropertyService) {\n  var child = Object.create(explorationPropertyService);\n  child.propertyName = 'init_state_name';\n  return child;\n}]);\n\n// A data service that stores tags for the exploration.\noppia.factory('explorationTagsService', [\n    'explorationPropertyService',\n    function(explorationPropertyService) {\n  var child = Object.create(explorationPropertyService);\n  child.propertyName = 'tags';\n  child._normalize = function(value) {\n    for (var i = 0; i < value.length; i++) {\n      value[i] = value[i].trim().replace(/\\s+/g, ' ');\n    }\n    // TODO(sll): Prevent duplicate tags from being added.\n    return value;\n  };\n  child._isValid = function(value) {\n    // Every tag should match the TAG_REGEX.\n    for (var i = 0; i < value.length; i++) {\n      var tagRegex = new RegExp(GLOBALS.TAG_REGEX);\n      if (!value[i].match(tagRegex)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  return child;\n}]);\n\noppia.factory('explorationParamSpecsService', [\n    'explorationPropertyService', function(explorationPropertyService) {\n  var child = Object.create(explorationPropertyService);\n  child.propertyName = 'param_specs';\n  return child;\n}]);\n\noppia.factory('explorationParamChangesService', [\n    'explorationPropertyService', function(explorationPropertyService) {\n  var child = Object.create(explorationPropertyService);\n  child.propertyName = 'param_changes';\n  return child;\n}]);\n\n// Data service for keeping track of the exploration's states. Note that this\n// is unlike the other exploration property services, in that it keeps no\n// mementos.\noppia.factory('explorationStatesService', [\n  '$log', '$modal', '$filter', '$location', '$rootScope',\n  'explorationInitStateNameService', 'alertsService', 'changeListService',\n  'editorContextService', 'validatorsService', 'newStateTemplateService',\n  'explorationGadgetsService', 'StateObjectFactory',\n  function(\n      $log, $modal, $filter, $location, $rootScope,\n      explorationInitStateNameService, alertsService, changeListService,\n      editorContextService, validatorsService, newStateTemplateService,\n      explorationGadgetsService, StateObjectFactory) {\n    var _states = null;\n    // Properties that have a different backend representation from the\n    // frontend and must be converted.\n    var PROPERTIES_TO_CONVERT = [\n      'answer_groups'\n    ];\n\n    var BACKEND_CONVERSIONS = {\n      answer_groups: function(answerGroups) {\n        var answerGroupBackendDicts = [];\n        answerGroups.map(function(answerGroup) {\n          answerGroupBackendDicts.push(answerGroup.toBackendDict());\n        });\n        return answerGroupBackendDicts;\n      }\n    };\n\n    // Maps backend names to the corresponding frontend dict accessor lists.\n    var PROPERTY_REF_DATA = {\n      answer_groups: ['interaction', 'answer_groups'],\n      confirmed_unclassified_answers: [\n        'interaction', 'confirmed_unclassified_answers'],\n      content: ['content'],\n      default_outcome: ['interaction', 'default_outcome'],\n      param_changes: ['paramChanges'],\n      fallbacks: ['interaction', 'fallbacks'],\n      widget_id: ['interaction', 'id'],\n      widget_customization_args: ['interaction', 'customization_args']\n    };\n\n    var _setState = function(stateName, stateData, refreshGraph) {\n      _states[stateName] = angular.copy(stateData);\n      if (refreshGraph) {\n        $rootScope.$broadcast('refreshGraph');\n      }\n    };\n\n    var getStatePropertyMemento = function(stateName, backendName) {\n      var accessorList = PROPERTY_REF_DATA[backendName];\n\n      var propertyRef = _states[stateName];\n      accessorList.forEach(function(key) {\n        propertyRef = propertyRef[key];\n      });\n\n      return angular.copy(propertyRef);\n    };\n\n    var saveStateProperty = function(stateName, backendName, newValue) {\n      var oldValue = getStatePropertyMemento(stateName, backendName);\n      var newBackendValue = angular.copy(newValue);\n\n      if (BACKEND_CONVERSIONS.hasOwnProperty(backendName)) {\n        newBackendValue = convertToBackendRepresentation(newValue, backendName);\n      }\n\n      if (!angular.equals(oldValue, newValue)) {\n        changeListService.editStateProperty(\n          stateName, backendName, newBackendValue, oldValue);\n\n        var newStateData = angular.copy(_states[stateName]);\n        var accessorList = PROPERTY_REF_DATA[backendName];\n\n        var propertyRef = newStateData;\n        for (var i = 0; i < accessorList.length - 1; i++) {\n          propertyRef = propertyRef[accessorList[i]];\n        }\n\n        propertyRef[accessorList[accessorList.length - 1]] = angular.copy(\n          newValue);\n\n        // We do not refresh the state editor immediately after the interaction\n        // id alone is saved, because the customization args dict will be\n        // temporarily invalid. A change in interaction id will always entail\n        // a change in the customization args dict anyway, so the graph will\n        // get refreshed after both properties have been updated.\n        var refreshGraph = (backendName !== 'widget_id');\n        _setState(stateName, newStateData, refreshGraph);\n      }\n    };\n\n    var convertToBackendRepresentation = function(frontendValue, backendName) {\n      var conversionFunction = BACKEND_CONVERSIONS[backendName];\n      return conversionFunction(frontendValue);\n    };\n\n    // TODO(sll): Add unit tests for all get/save methods.\n    return {\n      init: function(states) {\n        _states = {};\n        for (var stateName in states) {\n          var stateData = angular.copy(states[stateName]);\n          _states[stateName] = StateObjectFactory.create(\n            stateName, stateData);\n        }\n      },\n      getStates: function() {\n        return angular.copy(_states);\n      },\n      hasState: function(stateName) {\n        return _states.hasOwnProperty(stateName);\n      },\n      getState: function(stateName) {\n        return angular.copy(_states[stateName]);\n      },\n      setState: function(stateName, stateData) {\n        _setState(stateName, stateData, true);\n      },\n      isNewStateNameValid: function(newStateName, showWarnings) {\n        if (_states.hasOwnProperty(newStateName)) {\n          if (showWarnings) {\n            alertsService.addWarning('A state with this name already exists.');\n          }\n          return false;\n        }\n        return (\n          validatorsService.isValidStateName(newStateName, showWarnings));\n      },\n      getStateContentMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'content');\n      },\n      saveStateContent: function(stateName, newContent) {\n        saveStateProperty(stateName, 'content', newContent);\n      },\n      getStateParamChangesMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'param_changes');\n      },\n      saveStateParamChanges: function(stateName, newParamChanges) {\n        saveStateProperty(stateName, 'param_changes', newParamChanges);\n      },\n      getInteractionIdMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'widget_id');\n      },\n      saveInteractionId: function(stateName, newInteractionId) {\n        saveStateProperty(stateName, 'widget_id', newInteractionId);\n      },\n      getInteractionCustomizationArgsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'widget_customization_args');\n      },\n      saveInteractionCustomizationArgs: function(\n          stateName, newCustomizationArgs) {\n        saveStateProperty(\n          stateName, 'widget_customization_args', newCustomizationArgs);\n      },\n      getInteractionAnswerGroupsMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'answer_groups');\n      },\n      saveInteractionAnswerGroups: function(stateName, newAnswerGroups) {\n        saveStateProperty(stateName, 'answer_groups', newAnswerGroups);\n      },\n      getConfirmedUnclassifiedAnswersMemento: function(stateName) {\n        return getStatePropertyMemento(\n          stateName, 'confirmed_unclassified_answers');\n      },\n      saveConfirmedUnclassifiedAnswers: function(stateName, newAnswers) {\n        saveStateProperty(\n          stateName, 'confirmed_unclassified_answers', newAnswers);\n      },\n      getInteractionDefaultOutcomeMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'default_outcome');\n      },\n      saveInteractionDefaultOutcome: function(stateName, newDefaultOutcome) {\n        saveStateProperty(stateName, 'default_outcome', newDefaultOutcome);\n      },\n      getFallbacksMemento: function(stateName) {\n        return getStatePropertyMemento(stateName, 'fallbacks');\n      },\n      saveFallbacks: function(stateName, newFallbacks) {\n        saveStateProperty(stateName, 'fallbacks', newFallbacks);\n      },\n      addState: function(newStateName, successCallback) {\n        newStateName = $filter('normalizeWhitespace')(newStateName);\n        if (!validatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (_states.hasOwnProperty(newStateName)) {\n          alertsService.addWarning('A state with this name already exists.');\n          return;\n        }\n        alertsService.clearWarnings();\n\n        _states[newStateName] = newStateTemplateService.getNewStateTemplate(\n          newStateName);\n        changeListService.addState(newStateName);\n        $rootScope.$broadcast('refreshGraph');\n        if (successCallback) {\n          successCallback(newStateName);\n        }\n      },\n      deleteState: function(deleteStateName) {\n        alertsService.clearWarnings();\n\n        var initStateName = explorationInitStateNameService.displayed;\n        if (deleteStateName === initStateName) {\n          return;\n        }\n        if (!_states[deleteStateName]) {\n          alertsService.addWarning(\n            'No state with name ' + deleteStateName + ' exists.');\n          return;\n        }\n\n        $modal.open({\n          templateUrl: 'modals/deleteState',\n          backdrop: true,\n          resolve: {\n            deleteStateName: function() {\n              return deleteStateName;\n            }\n          },\n          controller: [\n            '$scope', '$modalInstance', 'explorationGadgetsService',\n            'deleteStateName',\n            function(\n                $scope, $modalInstance, explorationGadgetsService,\n                deleteStateName) {\n              $scope.deleteStateWarningText = (\n                'Are you sure you want to delete the card \"' +\n                deleteStateName + '\"?');\n\n              // Get all the gadgets that are only visible in this state.\n              var gadgetNamesUniqueToThisState = (\n                explorationGadgetsService.getGadgetNamesUniqueToState(\n                  deleteStateName));\n              if (gadgetNamesUniqueToThisState.length) {\n                // Update message to show that the gadgets unique to this state\n                // will be deleted too.\n                $scope.deleteStateWarningText = $scope.deleteStateWarningText +\n                  ' This will also delete the following gadget' +\n                  (gadgetNamesUniqueToThisState.length > 1 ? 's: ' : ': ') +\n                  gadgetNamesUniqueToThisState.join(', ') + '.';\n              }\n\n              $scope.reallyDelete = function() {\n                $modalInstance.close(deleteStateName);\n                // Delete the gadgets without additional dialog when confirmed.\n                for (var i = 0; i < gadgetNamesUniqueToThisState.length; i++) {\n                  // Note that explorationGadgetsService will update the data\n                  // and add additional 'delete gadget' cmds to\n                  // changeListService.\n                  explorationGadgetsService.deleteGadget(\n                    gadgetNamesUniqueToThisState[i], false);\n                }\n              };\n\n              $scope.cancel = function() {\n                $modalInstance.dismiss('cancel');\n                alertsService.clearWarnings();\n              };\n            }\n          ]\n        }).result.then(function(deleteStateName) {\n          delete _states[deleteStateName];\n          for (var otherStateName in _states) {\n            var interaction = _states[otherStateName].interaction;\n            var groups = interaction.answer_groups;\n            for (var i = 0; i < groups.length; i++) {\n              if (groups[i].outcome.dest === deleteStateName) {\n                groups[i].outcome.dest = otherStateName;\n              }\n            }\n            if (interaction.default_outcome) {\n              if (interaction.default_outcome.dest === deleteStateName) {\n                interaction.default_outcome.dest = otherStateName;\n              }\n            }\n\n            var fallbacks = interaction.fallbacks;\n            for (var i = 0; i < fallbacks.length; i++) {\n              if (fallbacks[i].outcome.dest === deleteStateName) {\n                fallbacks[i].outcome.dest = otherStateName;\n              }\n            }\n          }\n          changeListService.deleteState(deleteStateName);\n\n          if (editorContextService.getActiveStateName() === deleteStateName) {\n            editorContextService.setActiveStateName(\n              explorationInitStateNameService.savedMemento);\n          }\n\n          $location.path('/gui/' + editorContextService.getActiveStateName());\n          $rootScope.$broadcast('refreshGraph');\n          // This ensures that if the deletion changes rules in the current\n          // state, they get updated in the view.\n          $rootScope.$broadcast('refreshStateEditor');\n          // This state name is removed from gadget's visibilty settings.\n          explorationGadgetsService.handleStateDeletion(deleteStateName);\n        });\n      },\n      renameState: function(oldStateName, newStateName) {\n        newStateName = $filter('normalizeWhitespace')(newStateName);\n        if (!validatorsService.isValidStateName(newStateName, true)) {\n          return;\n        }\n        if (!!_states[newStateName]) {\n          alertsService.addWarning('A state with this name already exists.');\n          return;\n        }\n        alertsService.clearWarnings();\n\n        _states[newStateName] = angular.copy(_states[oldStateName]);\n        delete _states[oldStateName];\n\n        for (var otherStateName in _states) {\n          var interaction = _states[otherStateName].interaction;\n          var groups = interaction.answer_groups;\n          for (var i = 0; i < groups.length; i++) {\n            if (groups[i].outcome.dest === oldStateName) {\n              groups[i].outcome.dest = newStateName;\n            }\n          }\n          if (interaction.default_outcome) {\n            if (interaction.default_outcome.dest === oldStateName) {\n              interaction.default_outcome.dest = newStateName;\n            }\n          }\n\n          var fallbacks = interaction.fallbacks;\n          for (var i = 0; i < fallbacks.length; i++) {\n            if (fallbacks[i].outcome.dest === oldStateName) {\n              fallbacks[i].outcome.dest = newStateName;\n            }\n          }\n        }\n\n        editorContextService.setActiveStateName(newStateName);\n        // The 'rename state' command must come before the 'change\n        // init_state_name' command in the change list, otherwise the backend\n        // will raise an error because the new initial state name does not\n        // exist.\n        changeListService.renameState(newStateName, oldStateName);\n        // Amend initStateName appropriately, if necessary. Note that this\n        // must come after the state renaming, otherwise saving will lead to\n        // a complaint that the new name is not a valid state name.\n        if (explorationInitStateNameService.displayed === oldStateName) {\n          explorationInitStateNameService.displayed = newStateName;\n          explorationInitStateNameService.saveDisplayedValue(newStateName);\n        }\n        $rootScope.$broadcast('refreshGraph');\n        // The state name is updated in gadget's visibilty settings to the new\n        // name.\n        explorationGadgetsService.handleStateRenaming(\n          oldStateName, newStateName);\n      }\n    };\n  }\n]);\n\noppia.factory('statePropertyService', [\n  '$log', 'changeListService', 'alertsService', 'explorationStatesService',\n  function($log, changeListService, alertsService, explorationStatesService) {\n    // Public base API for data services corresponding to state properties\n    // (interaction id, content, etc.)\n    // WARNING: This should be initialized only in the context of the state\n    // editor, and every time the state is loaded, so that proper behavior is\n    // maintained if e.g. the state is renamed.\n    // TODO(sll): Remove this service and its descendants, in favour of using\n    // explorationStatesService directly.\n    return {\n      init: function(stateName, value) {\n        if (this.setterMethodKey === null) {\n          throw 'State property setter method key cannot be null.';\n        }\n\n        // The name of the state.\n        this.stateName = stateName;\n        // The current value of the property (which may not have been saved to\n        // the frontend yet). In general, this will be bound directly to the UI.\n        this.displayed = angular.copy(value);\n        // The previous (saved-in-the-frontend) value of the property. Here,\n        // 'saved' means that this is the latest value of the property as\n        // determined by the frontend change list.\n        this.savedMemento = angular.copy(value);\n      },\n      // Returns whether the current value has changed from the memento.\n      hasChanged: function() {\n        return !angular.equals(this.savedMemento, this.displayed);\n      },\n      // The name of the setter method in explorationStatesService for this\n      // property. THIS MUST BE SPECIFIED BY SUBCLASSES.\n      setterMethodKey: null,\n      // Transforms the given value into a normalized form. THIS CAN BE\n      // OVERRIDDEN BY SUBCLASSES. The default behavior is to do nothing.\n      _normalize: function(value) {\n        return value;\n      },\n      // Validates the given value and returns a boolean stating whether it\n      // is valid or not. THIS CAN BE OVERRIDDEN BY SUBCLASSES. The default\n      // behavior is to always return true.\n      _isValid: function(value) { // jscs:ignore disallowUnusedParams\n        return true;\n      },\n      // Creates a new entry in the change list, and updates the memento to the\n      // displayed value.\n      saveDisplayedValue: function() {\n        if (this.setterMethodKey === null) {\n          throw 'State property setter method key cannot be null.';\n        }\n\n        this.displayed = this._normalize(this.displayed);\n        if (!this._isValid(this.displayed) || !this.hasChanged()) {\n          this.restoreFromMemento();\n          return;\n        }\n\n        if (angular.equals(this.displayed, this.savedMemento)) {\n          return;\n        }\n\n        alertsService.clearWarnings();\n\n        var setterFunc = explorationStatesService[this.setterMethodKey];\n        setterFunc(this.stateName, angular.copy(this.displayed));\n\n        this.savedMemento = angular.copy(this.displayed);\n      },\n      // Reverts the displayed value to the saved memento.\n      restoreFromMemento: function() {\n        this.displayed = angular.copy(this.savedMemento);\n      }\n    };\n  }\n]);\n\n// A data service that stores the current list of state parameter changes.\n// TODO(sll): Add validation.\noppia.factory('stateParamChangesService', [\n    'statePropertyService', function(statePropertyService) {\n  var child = Object.create(statePropertyService);\n  child.setterMethodKey = 'saveStateParamChanges';\n  return child;\n}]);\n\n// A data service that stores the current interaction id.\n// TODO(sll): Add validation.\noppia.factory('stateInteractionIdService', [\n    'statePropertyService', function(statePropertyService) {\n  var child = Object.create(statePropertyService);\n  child.setterMethodKey = 'saveInteractionId';\n  return child;\n}]);\n\n// A data service that stores the current state customization args for the\n// interaction. This is a dict mapping customization arg names to dicts of the\n// form {value: customization_arg_value}.\n// TODO(sll): Add validation.\noppia.factory('stateCustomizationArgsService', [\n    'statePropertyService', function(statePropertyService) {\n  var child = Object.create(statePropertyService);\n  child.setterMethodKey = 'saveInteractionCustomizationArgs';\n  return child;\n}]);\n\n// A data service that stores the current interaction fallbacks.\noppia.factory('stateFallbacksService', [\n    'statePropertyService', function(statePropertyService) {\n  var child = Object.create(statePropertyService);\n  child.setterMethodKey = 'saveFallbacks';\n  return child;\n}]);\n\n// Data service for keeping track of gadget data and location across panels.\noppia.factory('explorationGadgetsService', [\n  '$log', '$modal', '$filter', '$location', '$rootScope',\n  'changeListService', 'editorContextService', 'alertsService',\n  'gadgetValidationService', 'GADGET_SPECS',\n  function($log, $modal, $filter, $location, $rootScope,\n           changeListService, editorContextService, alertsService,\n           gadgetValidationService, GADGET_SPECS) {\n    // _gadgets is a JS object with gadget_instance.name strings as keys\n    // and each gadget_instance's data as values.\n    var _gadgets = null;\n    // _panels is a JS object with skin panel names as keys and lists of\n    // gadget_instance.name strings as values. Lists are sorted in order\n    // that gadgets are displayed in panels that contain multiple gadgets.\n    var _panels = null;\n\n    var _getPanelNameFromGadgetName = function(gadgetName) {\n      for (var panel in _panels) {\n        if (_panels[panel].indexOf(gadgetName) !== -1) {\n          return panel;\n        }\n      }\n      $log.info(gadgetName + ' gadget does not exist in any panel.');\n    };\n\n    var _generateUniqueGadgetName = function(gadgetType) {\n      var baseGadgetName = GADGET_SPECS[gadgetType].short_description;\n      if (!_gadgets.hasOwnProperty(baseGadgetName)) {\n        return baseGadgetName;\n      } else {\n        var uniqueInteger = 2;\n        var generatedGadgetName = baseGadgetName + uniqueInteger;\n        while (_gadgets.hasOwnProperty(generatedGadgetName)) {\n          uniqueInteger++;\n          generatedGadgetName = baseGadgetName + uniqueInteger;\n        }\n        return generatedGadgetName;\n      }\n    };\n\n    var _getAllGadgetsInstancesForPanel = function(panel) {\n      var panelGadgets = [];\n      var gadgetsInCurrentPanel = _panels[panel];\n      for (var i = 0; i < gadgetsInCurrentPanel.length; i++) {\n        panelGadgets.push(_gadgets[gadgetsInCurrentPanel[i]]);\n      }\n      return panelGadgets;\n    };\n\n    /**\n     * Returns a JS object whose keys are state names, and whose corresponding\n     * values are lists of gadget instances representing the gadgets visible in\n     * that state for the given panel.\n     */\n    var _getGadgetsVisibilityMap = function(panel) {\n      var gadgetInstanceList = _getAllGadgetsInstancesForPanel(panel);\n      var visibilityMap = {};\n      for (var i = 0; i < gadgetInstanceList.length; i++) {\n        var gadgetInstance = angular.copy(gadgetInstanceList[i]);\n        for (var j = 0; j < gadgetInstance.visible_in_states.length; j++) {\n          var stateName = gadgetInstance.visible_in_states[j];\n          if (visibilityMap[stateName]) {\n            visibilityMap[stateName].push(gadgetInstance);\n          } else {\n            visibilityMap[stateName] = [gadgetInstance];\n          }\n        }\n      }\n      return visibilityMap;\n    };\n\n    var _isNewGadgetNameValid = function(newGadgetName) {\n      if (_gadgets.hasOwnProperty(newGadgetName)) {\n        alertsService.addWarning('A gadget with this name already exists.');\n        return false;\n      }\n      return (\n        gadgetValidationService.isValidGadgetName(newGadgetName));\n    };\n\n    /**\n     * Convert the backend representation of the skin's panel contents to a\n     * panel and a gadget dict. The panel dict has keys that are panel names\n     * and the values are list of gadget names present in that panel. The\n     * gadget dict has keys that are gadget names and the values are dicts\n     * representing the data for the gadget.\n     */\n    var _initGadgetsAndPanelsData = function(panelsContents) {\n      _panels = {};\n      _gadgets = {};\n      for (var panel in panelsContents) {\n        _panels[panel] = [];\n        // Append the name of each gadget instance in the panel.\n        for (var i = 0; i < panelsContents[panel].length; i++) {\n          _panels[panel].push(\n            panelsContents[panel][i].gadget_name\n          );\n          var gadgetName = panelsContents[panel][i].gadget_name;\n          _gadgets[gadgetName] = angular.copy(panelsContents[panel][i]);\n        }\n      }\n    };\n\n    return {\n      init: function(skinCustomizationsData) {\n        // Data structure initialization.\n        if (!skinCustomizationsData.hasOwnProperty('panels_contents')) {\n          alertsService.addWarning(\n            'Gadget Initialization failed. Panel contents were not provided');\n          return;\n        }\n        _initGadgetsAndPanelsData(skinCustomizationsData.panels_contents);\n        var isValid = false;\n        for (var panel in _panels) {\n          var visibilityMap = _getGadgetsVisibilityMap(panel);\n          isValid = gadgetValidationService.validatePanel(\n            panel, visibilityMap);\n          // The validatePanel(...) method should have added the warning to\n          // alertsService.\n          if (!isValid) {\n            return;\n          }\n        }\n        $rootScope.$broadcast('gadgetsChangedOrInitialized');\n      },\n      /**\n       * Confirms if a panel can accept a new gadget considering its capacity\n       * and the gadget's size requirements given its customization arguments.\n       */\n      canAddGadgetToItsPanel: function(gadgetData) {\n        var visibilityMap = _getGadgetsVisibilityMap(gadgetData.panel);\n        return (\n          _isNewGadgetNameValid(gadgetData.gadget_name) &&\n          gadgetValidationService.canAddGadget(gadgetData, visibilityMap));\n      },\n      getNewUniqueGadgetName: function(gadgetType) {\n        return _generateUniqueGadgetName(gadgetType);\n      },\n      getGadgets: function() {\n        return angular.copy(_gadgets);\n      },\n      // Returns a JS object mapping panel names to lists of gadget names.\n      getPanels: function() {\n        return angular.copy(_panels);\n      },\n      getPanelsContents: function() {\n        var panelsContents = {};\n        for (var panel in _panels) {\n          panelsContents[panel] = _panels[panel].map(function(gadgetName) {\n            return angular.copy(_gadgets[gadgetName]);\n          });\n        }\n        return panelsContents;\n      },\n      /**\n       * Function that returns list of gadget names only visible in the state\n       * name provided. Gadgets visible in multiple states would not be\n       * included.\n       */\n      getGadgetNamesUniqueToState: function(stateName) {\n        var gadgetNameList = [];\n        for (var gadgetName in _gadgets) {\n          var gadgetStateVisibilityList = (\n            _gadgets[gadgetName].visible_in_states);\n          if (gadgetStateVisibilityList.length === 1 &&\n              gadgetStateVisibilityList[0] === stateName) {\n            gadgetNameList.push(gadgetName);\n          }\n        }\n        return gadgetNameList;\n      },\n      /**\n       * Function that updates the old state name to the new state name in\n       * gadget's visibility settings.\n       */\n      handleStateRenaming: function(oldStateName, newStateName) {\n        for (var gadgetName in _gadgets) {\n          var gadgetStateVisibilityList = angular.copy(\n            _gadgets[gadgetName].visible_in_states);\n          var stateNameIndex = gadgetStateVisibilityList.indexOf(oldStateName);\n          if (stateNameIndex > -1) {\n            gadgetStateVisibilityList[stateNameIndex] = newStateName;\n            changeListService.editGadgetProperty(\n              gadgetName,\n              'gadget_visibility',\n              gadgetStateVisibilityList,\n              _gadgets[gadgetName].visible_in_states\n            );\n            _gadgets[gadgetName].visible_in_states = gadgetStateVisibilityList;\n            $rootScope.$broadcast('gadgetsChangedOrInitialized');\n          }\n        }\n      },\n      /**\n       * Function that deletes the state name in gadget's visibility settings.\n       */\n      handleStateDeletion: function(stateName) {\n        for (var gadgetName in _gadgets) {\n          var gadgetStateVisibilityList = angular.copy(\n            _gadgets[gadgetName].visible_in_states);\n          var stateNameIndex = gadgetStateVisibilityList.indexOf(stateName);\n          if (stateNameIndex > -1) {\n            gadgetStateVisibilityList.splice(stateNameIndex, 1);\n            changeListService.editGadgetProperty(\n              gadgetName,\n              'gadget_visibility',\n              gadgetStateVisibilityList,\n              _gadgets[gadgetName].visible_in_states\n            );\n            _gadgets[gadgetName].visible_in_states = gadgetStateVisibilityList;\n            $rootScope.$broadcast('gadgetsChangedOrInitialized');\n          }\n        }\n      },\n      /**\n       * Updates a gadget's visibility and/or customization args using\n       * the new data provided.\n       *\n       * This method does not update a gadget's name or panel position.\n       * Use this method in conjunction with renameGadget and\n       * moveGadgetBetweenPanels if those aspects need to be changed as well.\n       *\n       * @param {string} gadgetName - The name of gadget being updated.\n       * @param {object} newCustomizationArgs - New customization data for the\n       *   gadget.\n       * @param {array} newVisibleInStates - New state visibility list for the\n       *   gadget.\n       */\n      updateGadget: function(\n          gadgetName, newCustomizationArgs, newVisibleInStates) {\n        if (!_gadgets.hasOwnProperty(gadgetName)) {\n          alertsService.addWarning(\n            'Attempted to update a non-existent gadget: ' + gadgetName);\n          return;\n        }\n\n        // Check if new gadget data is valid.\n        // Warning will be displayed by isGadgetDataValid(...)\n        if (!gadgetValidationService.isGadgetDataValid(\n          gadgetName, newCustomizationArgs, newVisibleInStates)) {\n          return;\n        }\n\n        var currentGadgetData = _gadgets[gadgetName];\n\n        if (!angular.equals(currentGadgetData.customization_args,\n            newCustomizationArgs)) {\n          $log.info('Updating customization args for gadget: ' + gadgetName);\n          changeListService.editGadgetProperty(\n            gadgetName,\n            'gadget_customization_args',\n            newCustomizationArgs,\n            currentGadgetData.customization_args\n          );\n        }\n        if (!angular.equals(currentGadgetData.visible_in_states,\n            newVisibleInStates)) {\n          $log.info('Updating visibility for gadget: ' + gadgetName);\n          changeListService.editGadgetProperty(\n            gadgetName,\n            'gadget_visibility',\n            newVisibleInStates,\n            currentGadgetData.visible_in_states\n          );\n        }\n\n        // Updating the _gadgets dict.\n        currentGadgetData.customization_args = angular.copy(\n          newCustomizationArgs);\n        currentGadgetData.visible_in_states = angular.copy(newVisibleInStates);\n        $rootScope.$broadcast('gadgetsChangedOrInitialized');\n      },\n      addGadget: function(gadgetData) {\n        // Defense-in-depth: This warning should never happen with panel names\n        // hard coded and validated on the backend.\n        if (!_panels.hasOwnProperty(gadgetData.panel)) {\n          alertsService.addWarning(\n            'Attempted add to a non-existent panel: ' + gadgetData.panel);\n          return;\n        }\n\n        if (_gadgets.hasOwnProperty(gadgetData.gadget_name)) {\n          alertsService.addWarning('A gadget with this name already exists.');\n          return;\n        }\n\n        _gadgets[gadgetData.gadget_name] = gadgetData;\n        _panels[gadgetData.panel].push(gadgetData.gadget_name);\n        $rootScope.$broadcast('gadgetsChangedOrInitialized');\n        changeListService.addGadget(gadgetData);\n      },\n      /**\n       * Function that opens a modal to confirm gadget delete.\n       * @param {string} deleteGadgetName - The name of the gadget to be\n       *   deleted.\n       * @param {bool} showConfirmationDialog - To disable the confirmation\n       *   dialog, pass false, true otherwise.\n       */\n      deleteGadget: function(deleteGadgetName, showConfirmationDialog) {\n        alertsService.clearWarnings();\n\n        if (showConfirmationDialog === null ||\n            showConfirmationDialog === undefined) {\n          alertsService.addWarning(\n            'Missing param: No info was passed to show or hide the dialog.');\n          return;\n        }\n\n        if (!_gadgets.hasOwnProperty(deleteGadgetName)) {\n          // This warning can't be triggered in current UI.\n          // Keeping as defense-in-depth for future UI changes.\n          alertsService.addWarning(\n            'No gadget with name ' + deleteGadgetName + ' exists.'\n          );\n          return;\n        }\n\n        var _actuallyDeleteGadget = function(deleteGadgetName) {\n          // Update _gadgets.\n          delete _gadgets[deleteGadgetName];\n          // Update _panels.\n          var hostPanel = _getPanelNameFromGadgetName(deleteGadgetName);\n          var gadgetIndex = _panels[hostPanel].indexOf(deleteGadgetName);\n          _panels[hostPanel].splice(gadgetIndex, 1);\n\n          $rootScope.$broadcast('gadgetsChangedOrInitialized');\n          // Update changeListService\n          changeListService.deleteGadget(deleteGadgetName);\n        };\n\n        if (!showConfirmationDialog) {\n          _actuallyDeleteGadget(deleteGadgetName);\n          return;\n        }\n\n        $modal.open({\n          templateUrl: 'modals/deleteGadget',\n          backdrop: true,\n          resolve: {\n            deleteGadgetName: function() {\n              return deleteGadgetName;\n            }\n          },\n          controller: [\n            '$scope', '$modalInstance', 'deleteGadgetName',\n            function($scope, $modalInstance, deleteGadgetName) {\n              $scope.deleteGadgetName = deleteGadgetName;\n\n              $scope.reallyDelete = function() {\n                $modalInstance.close(deleteGadgetName);\n              };\n\n              $scope.cancel = function() {\n                $modalInstance.dismiss('cancel');\n                alertsService.clearWarnings();\n              };\n            }\n          ]\n        }).result.then(function(deleteGadgetName) {\n          _actuallyDeleteGadget(deleteGadgetName);\n        });\n      },\n      renameGadget: function(oldGadgetName, newGadgetName) {\n        newGadgetName = $filter('normalizeWhitespace')(newGadgetName);\n        if (!_isNewGadgetNameValid(newGadgetName)) {\n          return;\n        }\n        if (_gadgets.hasOwnProperty(newGadgetName)) {\n          alertsService.addWarning('A gadget with this name already exists.');\n          return;\n        }\n        alertsService.clearWarnings();\n\n        // Update _gadgets\n        gadgetData = angular.copy(_gadgets[oldGadgetName]);\n        gadgetData.gadget_name = newGadgetName;\n        _gadgets[newGadgetName] = gadgetData;\n        delete _gadgets[oldGadgetName];\n\n        // Update _panels\n        var hostPanel = _getPanelNameFromGadgetName(oldGadgetName);\n        var gadgetIndex = _panels[hostPanel].indexOf(oldGadgetName);\n        _panels[hostPanel].splice(gadgetIndex, 1, newGadgetName);\n        $rootScope.$broadcast('gadgetsChangedOrInitialized');\n\n        changeListService.renameGadget(oldGadgetName, newGadgetName);\n      }\n    };\n  }\n]);\n\n// A service that returns the frontend representation of a newly-added state.\n// TODO: refactor into factory as StateObjectFactory.createNewState()\noppia.factory('newStateTemplateService',\n  ['StateObjectFactory', function(StateObjectFactory) {\n    return {\n      // Returns a template for the new state with the given state name,\n      // changing the default rule destination to the new state name in\n      // the process.\n      // NB: clients should ensure that the desired state name is valid.\n      getNewStateTemplate: function(newStateName) {\n        var newStateTemplate = angular.copy(GLOBALS.NEW_STATE_TEMPLATE);\n        var newState = StateObjectFactory.create(newStateName, {\n          content: newStateTemplate.content,\n          interaction: newStateTemplate.interaction,\n          param_changes: newStateTemplate.param_changes\n        });\n        newState.interaction.default_outcome.dest = newStateName;\n        return newState;\n      }\n    };\n  }\n]);\n\noppia.factory('computeGraphService', [\n  'INTERACTION_SPECS', function(INTERACTION_SPECS) {\n    var _computeGraphData = function(initStateId, states) {\n      var nodes = {};\n      var links = [];\n      var finalStateIds = [];\n      for (var stateName in states) {\n        var interaction = states[stateName].interaction;\n        if (interaction.id && INTERACTION_SPECS[interaction.id].is_terminal) {\n          finalStateIds.push(stateName);\n        }\n\n        nodes[stateName] = stateName;\n\n        if (interaction.id) {\n          var groups = interaction.answer_groups;\n          for (var h = 0; h < groups.length; h++) {\n            links.push({\n              source: stateName,\n              target: groups[h].outcome.dest,\n              isFallback: false\n            });\n          }\n\n          if (interaction.default_outcome) {\n            links.push({\n              source: stateName,\n              target: interaction.default_outcome.dest,\n              isFallback: false\n            });\n          }\n\n          var fallbacks = interaction.fallbacks;\n          for (var h = 0; h < fallbacks.length; h++) {\n            links.push({\n              source: stateName,\n              target: fallbacks[h].outcome.dest,\n              isFallback: true\n            });\n          }\n        }\n      }\n\n      return {\n        finalStateIds: finalStateIds,\n        initStateId: initStateId,\n        links: links,\n        nodes: nodes\n      };\n    };\n\n    return {\n      compute: function(initStateId, states) {\n        return _computeGraphData(initStateId, states);\n      }\n    };\n  }\n]);\n\n// Service for computing graph data.\noppia.factory('graphDataService', [\n  'explorationStatesService', 'explorationInitStateNameService',\n  'computeGraphService',\n  function(\n      explorationStatesService, explorationInitStateNameService,\n      computeGraphService) {\n    var _graphData = null;\n\n    // Returns an object which can be treated as the input to a visualization\n    // for a directed graph. The returned object has the following keys:\n    //   - nodes: an object whose keys are node ids (equal to node names) and\n    //       whose values are node names\n    //   - links: a list of objects. Each object represents a directed link\n    //       between two nodes, and has keys 'source' and 'target', the values\n    //       of which are the names of the corresponding nodes.\n    //   - initStateName: the name of the initial state.\n    //   - finalStateName: the name of the final state.\n    var _recomputeGraphData = function() {\n      if (!explorationInitStateNameService.savedMemento) {\n        return;\n      }\n\n      var states = explorationStatesService.getStates();\n      var initStateId = explorationInitStateNameService.savedMemento;\n      _graphData = computeGraphService.compute(initStateId, states);\n    };\n\n    return {\n      recompute: function() {\n        _recomputeGraphData();\n      },\n      getGraphData: function() {\n        return angular.copy(_graphData);\n      }\n    };\n  }\n]);\n\n// Service for the state editor tutorial.\noppia.factory('stateEditorTutorialFirstTimeService', [\n  '$http', '$rootScope', 'editorFirstTimeEventsService',\n  function($http, $rootScope, editorFirstTimeEventsService) {\n    // Whether this is the first time the tutorial has been seen by this user.\n    var _currentlyInFirstVisit = true;\n\n    var STARTED_TUTORIAL_EVENT_URL = '/createhandler/started_tutorial_event';\n\n    return {\n      // After the first call to it in a client session, this does nothing.\n      init: function(firstTime, expId) {\n        if (!firstTime || !_currentlyInFirstVisit) {\n          _currentlyInFirstVisit = false;\n        }\n\n        if (_currentlyInFirstVisit) {\n          $rootScope.$broadcast('enterEditorForTheFirstTime');\n          editorFirstTimeEventsService.initRegisterEvents(expId);\n          $http.post(STARTED_TUTORIAL_EVENT_URL).error(function() {\n            console.error('Warning: could not record tutorial start event.');\n          });\n        }\n      },\n      markTutorialFinished: function() {\n        if (_currentlyInFirstVisit) {\n          $rootScope.$broadcast('openPostTutorialHelpPopover');\n          editorFirstTimeEventsService.registerEditorFirstEntryEvent();\n        }\n\n        _currentlyInFirstVisit = false;\n      }\n    };\n  }\n]);\n\noppia.constant('WARNING_TYPES', {\n  // These must be fixed before the exploration can be saved.\n  CRITICAL: 'critical',\n  // These must be fixed before publishing an exploration to the public\n  // library.\n  ERROR: 'error'\n});\n\noppia.constant('STATE_ERROR_MESSAGES', {\n  ADD_INTERACTION: 'Please add an interaction to this card.',\n  STATE_UNREACHABLE: 'This card is unreachable.',\n  UNABLE_TO_END_EXPLORATION: (\n    'There\\'s no way to complete the exploration starting from this card.')\n});\n\n// Service for the list of exploration warnings.\noppia.factory('explorationWarningsService', [\n  '$filter', 'graphDataService', 'explorationStatesService',\n  'expressionInterpolationService', 'explorationParamChangesService',\n  'parameterMetadataService', 'INTERACTION_SPECS', 'WARNING_TYPES',\n  'STATE_ERROR_MESSAGES', 'CLASSIFIER_RULESPEC_STR',\n  function(\n      $filter, graphDataService, explorationStatesService,\n      expressionInterpolationService, explorationParamChangesService,\n      parameterMetadataService, INTERACTION_SPECS, WARNING_TYPES,\n      STATE_ERROR_MESSAGES, CLASSIFIER_RULESPEC_STR) {\n    var _warningsList = [];\n    var stateWarnings = {};\n    var hasCriticalStateWarning = false;\n\n    var _getStatesWithoutInteractionIds = function() {\n      var statesWithoutInteractionIds = [];\n\n      var states = explorationStatesService.getStates();\n      for (var stateName in states) {\n        if (!states[stateName].interaction.id) {\n          statesWithoutInteractionIds.push(stateName);\n        }\n      }\n\n      return statesWithoutInteractionIds;\n    };\n\n    // Returns a list of names of all nodes which are unreachable from the\n    // initial node.\n    //\n    // Args:\n    // - initNodeIds: a list of initial node ids\n    // - nodes: an object whose keys are node ids, and whose values are node\n    //     names\n    // - edges: a list of edges, each of which is an object with keys 'source',\n    //     'target', and 'isFallback'\n    // - allowFallbackEdges: a boolean specifying whether to treat fallback\n    //     edges as valid edges for the purposes of this computation.\n    var _getUnreachableNodeNames = function(\n        initNodeIds, nodes, edges, allowFallbackEdges) {\n      var queue = initNodeIds;\n      var seen = {};\n      for (var i = 0; i < initNodeIds.length; i++) {\n        seen[initNodeIds[i]] = true;\n      }\n      while (queue.length > 0) {\n        var currNodeId = queue.shift();\n        edges.forEach(function(edge) {\n          if (edge.source === currNodeId && !seen.hasOwnProperty(edge.target) &&\n              (allowFallbackEdges || !edge.isFallback)) {\n            seen[edge.target] = true;\n            queue.push(edge.target);\n          }\n        });\n      }\n\n      var unreachableNodeNames = [];\n      for (var nodeId in nodes) {\n        if (!(seen.hasOwnProperty(nodes[nodeId]))) {\n          unreachableNodeNames.push(nodes[nodeId]);\n        }\n      }\n\n      return unreachableNodeNames;\n    };\n\n    // Given an array of objects with two keys 'source' and 'target', returns\n    // an array with the same objects but with the values of 'source' and\n    // 'target' switched. (The objects represent edges in a graph, and this\n    // operation amounts to reversing all the edges.)\n    var _getReversedLinks = function(links) {\n      return links.map(function(link) {\n        return {\n          source: link.target,\n          target: link.source,\n          isFallback: link.isFallback\n        };\n      });\n    };\n\n    // Verify that all parameters referred to in a state are guaranteed to\n    // have been set beforehand.\n    var _verifyParameters = function(initNodeIds) {\n      var unsetParametersInfo = (\n        parameterMetadataService.getUnsetParametersInfo(initNodeIds));\n\n      var paramWarningsList = [];\n      unsetParametersInfo.forEach(function(unsetParameterData) {\n        if (!unsetParameterData.stateName) {\n          // The parameter value is required in the initial list of parameter\n          // changes.\n          paramWarningsList.push({\n            type: WARNING_TYPES.CRITICAL,\n            message: (\n              'Please ensure the value of parameter \"' +\n              unsetParameterData.paramName +\n              '\" is set before it is referred to in the initial list of ' +\n              'parameter changes.')\n          });\n        } else {\n          // The parameter value is required in a subsequent state.\n          paramWarningsList.push({\n            type: WARNING_TYPES.CRITICAL,\n            message: (\n              'Please ensure the value of parameter \"' +\n              unsetParameterData.paramName +\n              '\" is set before using it in \"' + unsetParameterData.stateName +\n              '\".')\n          });\n        }\n      });\n\n      return paramWarningsList;\n    };\n\n    var _getAnswerGroupIndexesWithEmptyClassifiers = function(state) {\n      var indexes = [];\n      var answerGroups = state.interaction.answer_groups;\n      for (var i = 0; i < answerGroups.length; i++) {\n        var group = answerGroups[i];\n        if (group.ruleSpecs.length === 1 &&\n            group.ruleSpecs[0].rule_type === CLASSIFIER_RULESPEC_STR &&\n            group.ruleSpecs[0].inputs.training_data.length === 0) {\n          indexes.push(i);\n        }\n      }\n      return indexes;\n    };\n\n    var _getStatesAndAnswerGroupsWithEmptyClassifiers = function() {\n      var results = [];\n\n      var states = explorationStatesService.getStates();\n      for (var stateName in states) {\n        var groupIndexes = _getAnswerGroupIndexesWithEmptyClassifiers(\n          states[stateName]);\n        if (groupIndexes.length > 0) {\n          results.push({\n            groupIndexes: groupIndexes,\n            stateName: stateName\n          });\n        }\n      }\n\n      return results;\n    };\n\n    var _updateWarningsList = function() {\n      _warningsList = [];\n      stateWarnings = {};\n      hasCriticalStateWarning = false;\n\n      graphDataService.recompute();\n      var _graphData = graphDataService.getGraphData();\n\n      var _states = explorationStatesService.getStates();\n      for (var stateName in _states) {\n        var interaction = _states[stateName].interaction;\n        if (interaction.id) {\n          var validatorName = (\n            'oppiaInteractive' + _states[stateName].interaction.id +\n            'Validator');\n          var interactionWarnings = $filter(validatorName)(\n            stateName, interaction.customization_args,\n            interaction.answer_groups, interaction.default_outcome);\n\n          for (var j = 0; j < interactionWarnings.length; j++) {\n            if (stateWarnings.hasOwnProperty(stateName)) {\n              stateWarnings[stateName].push(interactionWarnings[j].message);\n            } else {\n              stateWarnings[stateName] = [interactionWarnings[j].message];\n            }\n\n            if (interactionWarnings[j].type === WARNING_TYPES.CRITICAL) {\n              hasCriticalStateWarning = true;\n            }\n          }\n        }\n      }\n\n      var statesWithoutInteractionIds = _getStatesWithoutInteractionIds();\n      angular.forEach(statesWithoutInteractionIds, function(\n        stateWithoutInteractionIds) {\n        if (stateWarnings.hasOwnProperty(stateWithoutInteractionIds)) {\n          stateWarnings[stateWithoutInteractionIds].push(\n            STATE_ERROR_MESSAGES.ADD_INTERACTION);\n        } else {\n          stateWarnings[stateWithoutInteractionIds] = [\n            STATE_ERROR_MESSAGES.ADD_INTERACTION];\n        }\n      });\n\n      if (_graphData) {\n        // Note that it is fine for states to be reachable by means of fallback\n        // edges only.\n        var unreachableStateNames = _getUnreachableNodeNames(\n          [_graphData.initStateId], _graphData.nodes, _graphData.links, true);\n\n        if (unreachableStateNames.length) {\n          angular.forEach(unreachableStateNames, function(\n            unreachableStateName) {\n            if (stateWarnings.hasOwnProperty(unreachableStateName)) {\n              stateWarnings[unreachableStateName].push(\n                STATE_ERROR_MESSAGES.STATE_UNREACHABLE);\n            } else {\n              stateWarnings[unreachableStateName] =\n                [STATE_ERROR_MESSAGES.STATE_UNREACHABLE];\n            }\n          });\n        } else {\n          // Only perform this check if all states are reachable. There must be\n          // a non-fallback path from each state to the END state.\n          var deadEndStates = _getUnreachableNodeNames(\n            _graphData.finalStateIds, _graphData.nodes,\n            _getReversedLinks(_graphData.links), false);\n          if (deadEndStates.length) {\n            angular.forEach(deadEndStates, function(deadEndState) {\n              if (stateWarnings.hasOwnProperty(deadEndState)) {\n                stateWarnings[deadEndState].push(\n                  STATE_ERROR_MESSAGES.UNABLE_TO_END_EXPLORATION);\n              } else {\n                stateWarnings[deadEndState] = [\n                  STATE_ERROR_MESSAGES.UNABLE_TO_END_EXPLORATION];\n              }\n            });\n          }\n        }\n\n        _warningsList = _warningsList.concat(_verifyParameters([\n          _graphData.initStateId]));\n      }\n\n      if (Object.keys(stateWarnings).length) {\n        _warningsList.push({\n          type: WARNING_TYPES.ERROR,\n          message: (\n            'The following states have errors: ' +\n            Object.keys(stateWarnings).join(', ') + '.')\n        });\n      };\n\n      var statesWithAnswerGroupsWithEmptyClassifiers = (\n        _getStatesAndAnswerGroupsWithEmptyClassifiers());\n      statesWithAnswerGroupsWithEmptyClassifiers.forEach(function(result) {\n        var warningMessage = 'In \\'' + result.stateName + '\\'';\n        if (result.groupIndexes.length !== 1) {\n          warningMessage += ', the following answer groups have classifiers ';\n          warningMessage += 'with no training data: ';\n        } else {\n          warningMessage += ', the following answer group has a classifier ';\n          warningMessage += 'with no training data: ';\n        }\n        warningMessage += result.groupIndexes.join(', ');\n\n        _warningsList.push({\n          message: warningMessage,\n          type: WARNING_TYPES.ERROR\n        });\n      });\n    };\n\n    return {\n      countWarnings: function() {\n        return _warningsList.length;\n      },\n      getAllStateRelatedWarnings: function() {\n        return stateWarnings;\n      },\n      getWarnings: function() {\n        return _warningsList;\n      },\n      hasCriticalWarnings: function() {\n        return hasCriticalStateWarning || _warningsList.some(function(warning) {\n          return warning.type === WARNING_TYPES.CRITICAL;\n        });\n      },\n      updateWarnings: function() {\n        _updateWarningsList();\n      }\n    };\n  }\n]);\n\noppia.factory('lostChangesService', ['utilsService', function(utilsService) {\n  var CMD_ADD_STATE = 'add_state';\n  var CMD_RENAME_STATE = 'rename_state';\n  var CMD_DELETE_STATE = 'delete_state';\n  var CMD_EDIT_STATE_PROPERTY = 'edit_state_property';\n\n  var makeRulesListHumanReadable = function(answerGroupValue) {\n    var rulesList = [];\n    answerGroupValue.ruleSpecs.forEach(function(ruleSpec) {\n      var ruleElm = angular.element('<li></li>');\n      ruleElm.html('<p>Type: ' + ruleSpec.rule_type + '</p>');\n      ruleElm.append(\n        '<p>Value: ' + (\n          Object.keys(ruleSpec.inputs).map(function(input) {\n            return ruleSpec.inputs[input];\n          })\n        ).toString() + '</p>');\n      rulesList.push(ruleElm);\n    });\n\n    return rulesList;\n  };\n\n  // An edit is represented either as an object or an array. If it's an object,\n  // then simply return that object. In case of an array, return the last item.\n  var getStatePropertyValue = function(statePropertyValue) {\n    return angular.isArray(statePropertyValue) ?\n      statePropertyValue[statePropertyValue.length - 1] : statePropertyValue;\n  };\n\n  // Detects whether an object of the type 'answer_group' or 'default_outcome'\n  // has been added, edited or deleted. Returns - 'addded', 'edited' or\n  // 'deleted' accordingly.\n  var getRelativeChangeToGroups = function(changeObject) {\n    var newValue = changeObject.new_value;\n    var oldValue = changeObject.old_value;\n    var result = '';\n\n    if (angular.isArray(newValue) && angular.isArray(oldValue)) {\n      result = (newValue.length > oldValue.length) ?\n        'added' : (newValue.length === oldValue.length) ?\n        'edited' : 'deleted';\n    } else {\n      if (!utilsService.isEmpty(oldValue)) {\n        if (!utilsService.isEmpty(newValue)) {\n          result = 'edited';\n        } else {\n          result = 'deleted';\n        }\n      } else if (!utilsService.isEmpty(newValue)) {\n        result = 'added';\n      }\n    }\n    return result;\n  };\n\n  var makeHumanReadable = function(lostChanges) {\n    var outerHtml = angular.element('<ul></ul>');\n    var stateWiseEditsMapping = {};\n    // The variable stateWiseEditsMapping stores the edits grouped by state.\n    // For instance, you made the following edits:\n    // 1. Changed content to 'Welcome!' instead of '' in 'Introduction'.\n    // 2. Added an interaction in this state.\n    // 2. Added a new state 'End'.\n    // 3. Ended Exporation from state 'End'.\n    // stateWiseEditsMapping will look something like this:\n    // - 'Introduction': [\n    //   - 'Edited Content: Welcome!',:\n    //   - 'Added Interaction: Continue',\n    //   - 'Added interaction customizations']\n    // - 'End': ['Ended exploration']\n\n    lostChanges.forEach(function(lostChange) {\n      switch (lostChange.cmd) {\n        case CMD_ADD_STATE:\n          outerHtml.append(\n            angular.element('<li></li>').html(\n              'Added state: ' + lostChange.state_name));\n          break;\n        case CMD_RENAME_STATE:\n          outerHtml.append(\n            angular.element('<li></li>').html(\n              'Renamed state: ' + lostChange.old_state_name + ' to ' +\n                lostChange.new_state_name));\n          break;\n        case CMD_DELETE_STATE:\n          outerHtml.append(\n            angular.element('<li></li>').html(\n              'Deleted state: ' + lostChange.state_name));\n          break;\n        case CMD_EDIT_STATE_PROPERTY:\n          var newValue = getStatePropertyValue(lostChange.new_value);\n          var oldValue = getStatePropertyValue(lostChange.old_value);\n          var stateName = lostChange.state_name;\n          if (!stateWiseEditsMapping[stateName]) {\n            stateWiseEditsMapping[stateName] = [];\n          }\n\n          switch (lostChange.property_name) {\n            case 'content':\n              if (newValue !== null) {\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div></div>').html(\n                    '<strong>Edited content: </strong><div class=\"content\">' +\n                      newValue.value + '</div>')\n                    .addClass('state-edit-desc'));\n              }\n              break;\n\n            case 'widget_id':\n              var lostChangeValue = '';\n              if (oldValue === null) {\n                if (newValue !== 'EndExploration') {\n                  lostChangeValue = ('<strong>Added Interaction: </strong>' +\n                                     newValue);\n                } else {\n                  lostChangeValue = 'Ended Exploration';\n                }\n              } else {\n                lostChangeValue = ('<strong>Deleted Interaction: </strong>' +\n                                   oldValue);\n              }\n              stateWiseEditsMapping[stateName].push(\n                angular.element('<div></div>').html(lostChangeValue)\n                  .addClass('state-edit-desc'));\n              break;\n\n            case 'widget_customization_args':\n              var lostChangeValue = '';\n              if (utilsService.isEmpty(oldValue)) {\n                lostChangeValue = 'Added Interaction Customizations';\n              } else if (utilsService.isEmpty(newValue)) {\n                lostChangeValue = 'Removed Interaction Customizations';\n              } else {\n                lostChangeValue = 'Edited Interaction Customizations';\n              }\n              stateWiseEditsMapping[stateName].push(\n                angular.element('<div></div>').html(lostChangeValue)\n                  .addClass('state-edit-desc'));\n              break;\n\n            case 'answer_groups':\n              var answerGroupChanges = getRelativeChangeToGroups(lostChange);\n              var answerGroupHtml = '';\n              if (answerGroupChanges === 'added') {\n                answerGroupHtml += (\n                  '<p class=\"sub-edit\"><i>Destination: </i>' +\n                    newValue.outcome.dest + '</p>');\n                answerGroupHtml += (\n                  '<div class=\"sub-edit\"><i>Feedback: </i>' +\n                    '<div class=\"feedback\">' +\n                    newValue.outcome.feedback + '</div></div>');\n                var rulesList = makeRulesListHumanReadable(newValue);\n                if (rulesList.length > 0) {\n                  answerGroupHtml += '<p class=\"sub-edit\"><i>Rules: </i></p>';\n                  var rulesListHtml = (angular.element('<ol></ol>')\n                                       .addClass('rules-list'));\n                  for (var rule in rulesList) {\n                    rulesListHtml.html(rulesList[rule][0].outerHTML);\n                  }\n                  answerGroupHtml += rulesListHtml[0].outerHTML;\n                }\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div><strong>Added answer group: ' +\n                                  '</strong></div>')\n                    .append(answerGroupHtml)\n                    .addClass('state-edit-desc answer-group'));\n              } else if (answerGroupChanges === 'edited') {\n                if (newValue.outcome.dest !== oldValue.outcome.dest) {\n                  answerGroupHtml += (\n                    '<p class=\"sub-edit\"><i>Destination: </i>' +\n                      newValue.outcome.dest + '</p>');\n                }\n                if (!angular.equals(\n                    newValue.outcome.feedback, oldValue.outcome.feedback)) {\n                  answerGroupHtml += (\n                    '<div class=\"sub-edit\"><i>Feedback: </i>' +\n                      '<div class=\"feedback\">' + newValue.outcome.feedback +\n                      '</div></div>');\n                }\n                if (!angular.equals(newValue.ruleSpecs, oldValue.ruleSpecs)) {\n                  var rulesList = makeRulesListHumanReadable(newValue);\n                  if (rulesList.length > 0) {\n                    answerGroupHtml += '<p class=\"sub-edit\"><i>Rules: </i></p>';\n                    var rulesListHtml = (angular.element('<ol></ol>')\n                                         .addClass('rules-list'));\n                    for (var rule in rulesList) {\n                      rulesListHtml.html(rulesList[rule][0].outerHTML);\n                    }\n                    answerGroupChanges = rulesListHtml[0].outerHTML;\n                  }\n                }\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div><strong>Edited answer group: <strong>' +\n                                  '</div>')\n                    .append(answerGroupHtml)\n                    .addClass('state-edit-desc answer-group'));\n              } else if (answerGroupChanges === 'deleted') {\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div>Deleted answer group</div>')\n                    .addClass('state-edit-desc'));\n              }\n              break;\n\n            case 'default_outcome':\n              var defaultOutcomeChanges = getRelativeChangeToGroups(lostChange);\n              var defaultOutcomeHtml = '';\n              if (defaultOutcomeChanges === 'added') {\n                defaultOutcomeHtml += (\n                  '<p class=\"sub-edit\"><i>Destination: </i>' +\n                    newValue.dest + '</p>');\n                defaultOutcomeHtml += (\n                  '<div class=\"sub-edit\"><i>Feedback: </i>' +\n                    '<div class=\"feedback\">' + newValue.feedback +\n                    '</div></div>');\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div>Added default outcome: </div>')\n                    .append(defaultOutcomeHtml)\n                    .addClass('state-edit-desc default-outcome'));\n              } else if (defaultOutcomeChanges === 'edited') {\n                if (newValue.dest !== oldValue.dest) {\n                  defaultOutcomeHtml += (\n                    '<p class=\"sub-edit\"><i>Destination: </i>' + newValue.dest +\n                      '</p>');\n                }\n                if (!angular.equals(newValue.feedback, oldValue.feedback)) {\n                  defaultOutcomeHtml += (\n                    '<div class=\"sub-edit\"><i>Feedback: </i>' +\n                      '<div class=\"feedback\">' + newValue.feedback +\n                      '</div></div>');\n                }\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div>Edited default outcome: </div>')\n                    .append(defaultOutcomeHtml)\n                    .addClass('state-edit-desc default-outcome'));\n              } else if (defaultOutcomeChanges === 'deleted') {\n                stateWiseEditsMapping[stateName].push(\n                  angular.element('<div>Deleted default outcome</div>')\n                    .addClass('state-edit-desc'));\n              }\n          };\n      }\n    });\n\n    for (var stateName in stateWiseEditsMapping) {\n      var stateChangesEl = angular.element(\n        '<li>Edits to state: ' + stateName + '</li>');\n      for (var stateEdit in stateWiseEditsMapping[stateName]) {\n        stateChangesEl.append(stateWiseEditsMapping[stateName][stateEdit]);\n      }\n      outerHtml.append(stateChangesEl);\n    }\n\n    return outerHtml;\n  };\n\n  return {\n    makeHumanReadable: makeHumanReadable\n  };\n}]);\n\n// Service for displaying different types of modals depending on the type of\n// response received as a result of the autosaving request.\noppia.factory('autosaveInfoModalsService', [\n  '$log', '$modal', '$timeout', '$window', 'lostChangesService',\n  'explorationData',\n  function(\n      $log, $modal, $timeout, $window, lostChangesService,\n      explorationData) {\n    var _isModalOpen = false;\n    var _refreshPage = function(delay) {\n      $timeout(function() {\n        $window.location.reload();\n      }, delay);\n    };\n\n    return {\n      showNonStrictValidationFailModal: function() {\n        $modal.open({\n          templateUrl: 'modals/saveValidationFail',\n          // Prevent modal from closing when the user clicks outside it.\n          backdrop: 'static',\n          controller: [\n            '$scope', '$modalInstance', function($scope, $modalInstance) {\n              $scope.closeAndRefresh = function() {\n                $modalInstance.dismiss('cancel');\n                _refreshPage(20);\n              };\n            }\n          ]\n        }).result.then(function() {\n          _isModalOpen = false;\n        }, function() {\n          _isModalOpen = false;\n        });\n\n        _isModalOpen = true;\n      },\n      isModalOpen: function() {\n        return _isModalOpen;\n      },\n      showVersionMismatchModal: function(lostChanges) {\n        $modal.open({\n          templateUrl: 'modals/saveVersionMismatch',\n          // Prevent modal from closing when the user clicks outside it.\n          backdrop: 'static',\n          controller: ['$scope', function($scope) {\n            // When the user clicks on discard changes button, signal backend\n            // to discard the draft and reload the page thereafter.\n            $scope.discardChanges = function() {\n              explorationData.discardDraft(function() {\n                _refreshPage(20);\n              });\n            };\n\n            $scope.hasLostChanges = (lostChanges && lostChanges.length > 0);\n            if ($scope.hasLostChanges) {\n              // TODO(sll): This should also include changes to exploration\n              // properties (such as the exploration title, category, etc.).\n              $scope.lostChangesHtml = (\n                lostChangesService.makeHumanReadable(lostChanges).html());\n              $log.error('Lost changes: ' + JSON.stringify(lostChanges));\n            }\n          }],\n          windowClass: 'oppia-autosave-version-mismatch-modal'\n        }).result.then(function() {\n          _isModalOpen = false;\n        }, function() {\n          _isModalOpen = false;\n        });\n\n        _isModalOpen = true;\n      }\n    };\n  }\n]);\n\n// Service registering analytics events for the editor for events which are\n// only logged when they happen after the editor is opened for the first time\n// for an exploration.\noppia.factory('editorFirstTimeEventsService', ['siteAnalyticsService',\n  function(siteAnalyticsService) {\n    var explorationId = null;\n    var shouldRegisterEvents = false;\n    var alreadyRegisteredEvents = {};\n    return {\n      initRegisterEvents: function(expId) {\n        shouldRegisterEvents = true;\n        explorationId = expId;\n      },\n      registerEditorFirstEntryEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty('EditorFirstEntryEvent')) {\n          siteAnalyticsService.registerEditorFirstEntryEvent(explorationId);\n          alreadyRegisteredEvents.EditorFirstEntryEvent = true;\n        }\n      },\n      registerFirstOpenContentBoxEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty(\n              'FirstOpenContentBoxEvent')) {\n          siteAnalyticsService.registerFirstOpenContentBoxEvent(explorationId);\n          alreadyRegisteredEvents.FirstOpenContentBoxEvent = true;\n        }\n      },\n      registerFirstSaveContentEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty('FirstSaveContentEvent')) {\n          siteAnalyticsService.registerFirstSaveContentEvent(explorationId);\n          alreadyRegisteredEvents.FirstSaveContentEvent = true;\n        }\n      },\n      registerFirstClickAddInteractionEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty(\n              'FirstClickAddInteractionEvent')) {\n          siteAnalyticsService.registerFirstClickAddInteractionEvent(\n            explorationId);\n          alreadyRegisteredEvents.FirstClickAddInteractionEvent = true;\n        }\n      },\n      registerFirstSelectInteractionTypeEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty(\n              'FirstSelectInteractionTypeEvent')) {\n          siteAnalyticsService.registerFirstSelectInteractionTypeEvent(\n            explorationId);\n          alreadyRegisteredEvents.FirstSelectInteractionTypeEvent = true;\n        }\n      },\n      registerFirstSaveInteractionEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty(\n              'FirstSaveInteractionEvent')) {\n          siteAnalyticsService.registerFirstSaveInteractionEvent(explorationId);\n          alreadyRegisteredEvents.FirstSaveInteractionEvent = true;\n        }\n      },\n      registerFirstSaveRuleEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty('FirstSaveRuleEvent')) {\n          siteAnalyticsService.registerFirstSaveRuleEvent(explorationId);\n          alreadyRegisteredEvents.FirstSaveRuleEvent = true;\n        }\n      },\n      registerFirstCreateSecondStateEvent: function() {\n        if (shouldRegisterEvents &&\n            !alreadyRegisteredEvents.hasOwnProperty(\n              'FirstCreateSecondStateEvent')) {\n          siteAnalyticsService.registerFirstCreateSecondStateEvent(\n            explorationId);\n          alreadyRegisteredEvents.FirstCreateSecondStateEvent = true;\n        }\n      }\n    };\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/EditorServicesSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the services and controllers of the exploration\n *   editor page.\n */\n\ndescribe('Editor context service', function() {\n  beforeEach(module('oppia'));\n\n  describe('editor context service', function() {\n    var ecs = null;\n\n    beforeEach(inject(function($injector) {\n      ecs = $injector.get('editorContextService');\n    }));\n\n    it('should correctly set and get state names', function() {\n      ecs.setActiveStateName('A State');\n      expect(ecs.getActiveStateName()).toBe('A State');\n    });\n\n    it('should not allow invalid state names to be set', function() {\n      ecs.setActiveStateName('');\n      expect(ecs.getActiveStateName()).toBeNull();\n\n      ecs.setActiveStateName(null);\n      expect(ecs.getActiveStateName()).toBeNull();\n    });\n  });\n});\n\ndescribe('Change list service', function() {\n  beforeEach(module('oppia'));\n\n  describe('change list service', function() {\n    var cls = null;\n    var $httpBackend = null;\n    var mockWarningsData;\n    var mockExplorationData;\n\n    var autosaveDraftUrl = 'createhandler/autosave_draft/0';\n    var validAutosaveResponse = {\n      is_version_of_draft_valid: true\n    };\n\n    beforeEach(function() {\n      mockWarningsData = {\n        addWarning: function() {}\n      };\n      module(function($provide) {\n        $provide.value('alertsService', mockWarningsData);\n      });\n      spyOn(mockWarningsData, 'addWarning');\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {},\n        discardDraft: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($injector) {\n      cls = $injector.get('changeListService');\n      $httpBackend = $injector.get('$httpBackend');\n    }));\n\n    it('should correctly get and save changes', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.addState('newState');\n      expect(cls.getChangeList()).not.toBe([]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly add a new state', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.addState('newState');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'add_state',\n        state_name: 'newState'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly rename a state', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.renameState('newName', 'oldName');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'rename_state',\n        old_state_name: 'oldName',\n        new_state_name: 'newName'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly delete a state', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.deleteState('deletedState');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'delete_state',\n        state_name: 'deletedState'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly edit an exploration property', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.editExplorationProperty('title', 'newTitle', 'oldTitle');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'edit_exploration_property',\n        property_name: 'title',\n        new_value: 'newTitle',\n        old_value: 'oldTitle'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should detect invalid exploration properties', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.editExplorationProperty('fake_property', 'newThing', 'oldThing');\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'Invalid exploration property: fake_property');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n    });\n\n    it('should correctly edit a state property', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.editStateProperty('stateName', 'content', 'newC', 'oldC');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'edit_state_property',\n        state_name: 'stateName',\n        property_name: 'content',\n        new_value: 'newC',\n        old_value: 'oldC'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should detect invalid exploration properties', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.editStateProperty(\n        'stateName', 'fake_property', 'newThing', 'oldThing');\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'Invalid state property: fake_property');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n    });\n\n    it('should correctly discard all changes', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.addState('newState');\n      expect(cls.getChangeList()).not.toBe([]);\n      cls.discardAllChanges();\n      expect(cls.getChangeList()).toEqual([]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly handle multiple changes in succession', function() {\n      expect(cls.getChangeList()).toEqual([]);\n\n      cls.addState('newState1');\n      cls.addState('newState2');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'add_state',\n        state_name: 'newState1'\n      }, {\n        cmd: 'add_state',\n        state_name: 'newState2'\n      }]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly undo changes', function() {\n      expect(cls.getChangeList()).toEqual([]);\n\n      cls.addState('newState1');\n      cls.addState('newState2');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'add_state',\n        state_name: 'newState1'\n      }, {\n        cmd: 'add_state',\n        state_name: 'newState2'\n      }]);\n\n      cls.undoLastChange();\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'add_state',\n        state_name: 'newState1'\n      }]);\n\n      cls.undoLastChange();\n      expect(cls.getChangeList()).toEqual([]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly add a gadget', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.addState('newState1');\n      var gadgetDict = {\n        gadget_type: 'TestGadget',\n        gadget_name: 'TestGadget 1',\n        customization_args: {\n          adviceObjects: {\n            value: [{\n              adviceHtml: '<p>Tips</p>',\n              adviceTitle: 'R-Tip'\n            }]\n          },\n          title: {\n            value: 'Tips'\n          }\n        },\n        visible_in_states: ['newState1']\n      };\n      cls.addGadget(gadgetDict);\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'add_state',\n        state_name: 'newState1'\n      }, {\n        cmd: 'add_gadget',\n        gadget_dict: {\n          gadget_type: 'TestGadget',\n          gadget_name: 'TestGadget 1',\n          customization_args: {\n            adviceObjects: {\n              value: [{\n                adviceHtml: '<p>Tips</p>',\n                adviceTitle: 'R-Tip'\n              }]\n            },\n            title: {\n              value: 'Tips'\n            }\n          },\n          visible_in_states: ['newState1']\n        }\n      }]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly rename a gadget', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.renameGadget('oldName', 'newName');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'rename_gadget',\n        old_gadget_name: 'oldName',\n        new_gadget_name: 'newName'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly delete a gadget', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      cls.deleteGadget('gadgetName');\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'delete_gadget',\n        gadget_name: 'gadgetName'\n      }]);\n      expect(mockWarningsData.addWarning).not.toHaveBeenCalled();\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly edit gadget customization args', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      var oldCustomizationArgs = {\n        customization_args: {\n          adviceObjects: {\n            value: [{\n              adviceHtml: '<p>Html Data</p>',\n              adviceTitle: 'advice tip name'\n            }]\n          },\n          title: {\n            value: 'main Title'\n          }\n        }\n      };\n      var newCustomizationArgs = {\n        customization_args: {\n          adviceObjects: {\n            value: [{\n              adviceHtml: '<p>New Html Data</p>',\n              adviceTitle: 'New advice tip name'\n            }]\n          },\n          title: {\n            value: 'New main Title'\n          }\n        }\n      };\n      cls.editGadgetProperty(\n        'gadgetName',\n        'gadget_customization_args',\n        newCustomizationArgs,\n        oldCustomizationArgs\n      );\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'edit_gadget_property',\n        gadget_name: 'gadgetName',\n        property_name: 'gadget_customization_args',\n        new_value: {\n          customization_args: {\n            adviceObjects: {\n              value: [{\n                adviceHtml: '<p>New Html Data</p>',\n                adviceTitle: 'New advice tip name'\n              }]\n            },\n            title: {\n              value: 'New main Title'\n            }\n          }\n        },\n        old_value: {\n          customization_args: {\n            adviceObjects: {\n              value: [{\n                adviceHtml: '<p>Html Data</p>',\n                adviceTitle: 'advice tip name'\n              }]\n            },\n            title: {\n              value: 'main Title'\n            }\n          }\n        }\n      }]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should correctly edit a gadget visibility property', function() {\n      expect(cls.getChangeList()).toEqual([]);\n      var oldVisibilityProp = ['old_state_name'];\n      var newVisibilityProp = ['new state name'];\n      cls.editGadgetProperty(\n        'gadgetName',\n        'gadget_visibility',\n        newVisibilityProp,\n        oldVisibilityProp\n      );\n      expect(cls.getChangeList()).toEqual([{\n        cmd: 'edit_gadget_property',\n        gadget_name: 'gadgetName',\n        property_name: 'gadget_visibility',\n        new_value: ['new state name'],\n        old_value: ['old_state_name']\n      }]);\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n  });\n});\n\ndescribe('Exploration title service', function() {\n  beforeEach(module('oppia'));\n\n  describe('exploration title service', function() {\n    var ets = null;\n    var $httpBackend = null;\n    var mockExplorationData;\n\n    var autosaveDraftUrl = 'createhandler/autosave_draft/0';\n    var validAutosaveResponse = {\n      is_version_of_draft_valid: true\n    };\n\n    beforeEach(function() {\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($injector) {\n      ets = $injector.get('explorationTitleService');\n      $httpBackend = $injector.get('$httpBackend');\n    }));\n\n    it('correctly initializes the service', function() {\n      expect(ets.displayed).toBeUndefined();\n      expect(ets.savedMemento).toBeUndefined();\n      ets.init('A title');\n      expect(ets.displayed).toEqual('A title');\n      expect(ets.savedMemento).toEqual('A title');\n    });\n\n    it('updates only the title and not the memento', function() {\n      ets.init('A title');\n      ets.displayed = 'New title';\n      expect(ets.displayed).toEqual('New title');\n      expect(ets.savedMemento).toEqual('A title');\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n    });\n\n    it('restores correctly from the memento', function() {\n      ets.init('A title');\n      ets.displayed = 'New title';\n      ets.restoreFromMemento();\n      expect(ets.displayed).toEqual('A title');\n      expect(ets.savedMemento).toEqual('A title');\n    });\n\n    it('updates the memento with the displayed title', function() {\n      ets.init('A title');\n      ets.displayed = 'New title';\n      expect(ets.savedMemento).toEqual('A title');\n      ets.saveDisplayedValue();\n      expect(ets.savedMemento).toEqual('New title');\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('reports whether the title has changed since it was saved', function() {\n      ets.init('A title');\n      expect(ets.hasChanged()).toBe(false);\n      ets.displayed = 'A title';\n      expect(ets.hasChanged()).toBe(false);\n      ets.displayed = 'New title';\n      expect(ets.hasChanged()).toBe(true);\n      ets.displayed = 'A title';\n      expect(ets.hasChanged()).toBe(false);\n\n      ets.saveDisplayedValue();\n      expect(mockExplorationData.autosaveChangeList).not.toHaveBeenCalled();\n      expect(ets.hasChanged()).toBe(false);\n    });\n  });\n});\n\ndescribe('Exploration rights service', function() {\n  beforeEach(module('oppia'));\n\n  describe('exploration rights service', function() {\n    var ers = null;\n\n    beforeEach(inject(function($injector) {\n      ers = $injector.get('explorationRightsService');\n\n      GLOBALS.ACTIVITY_STATUS_PRIVATE = 'private';\n      GLOBALS.ACTIVITY_STATUS_PUBLIC = 'public';\n      GLOBALS.ACTIVITY_STATUS_PUBLICIZED = 'publicized';\n    }));\n\n    it('correctly initializes the service', function() {\n      expect(ers.ownerNames).toBeUndefined();\n      expect(ers.editorNames).toBeUndefined();\n      expect(ers.viewerNames).toBeUndefined();\n      expect(ers._status).toBeUndefined();\n      expect(ers._clonedFrom).toBeUndefined();\n      expect(ers._isCommunityOwned).toBeUndefined();\n      expect(ers._viewableIfPrivate).toBeUndefined();\n\n      ers.init(['abc'], [], [], 'private', 'e1234', true, true);\n\n      expect(ers.ownerNames).toEqual(['abc']);\n      expect(ers.editorNames).toEqual([]);\n      expect(ers.viewerNames).toEqual([]);\n      expect(ers._status).toEqual('private');\n      expect(ers._clonedFrom).toEqual('e1234');\n      expect(ers._isCommunityOwned).toBe(true);\n      expect(ers._viewableIfPrivate).toBe(true);\n    });\n\n    it('reports the correct derived statuses', function() {\n      ers.init(['abc'], [], [], 'private', 'e1234', true);\n      expect(ers.isPrivate()).toBe(true);\n      expect(ers.isPublic()).toBe(false);\n      expect(ers.isPublicized()).toBe(false);\n\n      ers.init(['abc'], [], [], 'public', 'e1234', true);\n      expect(ers.isPrivate()).toBe(false);\n      expect(ers.isPublic()).toBe(true);\n      expect(ers.isPublicized()).toBe(false);\n\n      ers.init(['abc'], [], [], 'publicized', 'e1234', true);\n      expect(ers.isPrivate()).toBe(false);\n      expect(ers.isPublic()).toBe(false);\n      expect(ers.isPublicized()).toBe(true);\n    });\n\n    it('reports the correct cloning status', function() {\n      ers.init(['abc'], [], [], 'publicized', '1234', true);\n      expect(ers.isCloned()).toBe(true);\n      expect(ers.clonedFrom()).toEqual('1234');\n\n      ers.init(['abc'], [], [], 'publicized', null, true);\n      expect(ers.isCloned()).toBe(false);\n      expect(ers.clonedFrom()).toBeNull();\n    });\n\n    it('reports the correct community-owned status', function() {\n      ers.init(['abc'], [], [], 'publicized', '1234', false);\n      expect(ers.isCommunityOwned()).toBe(false);\n\n      ers.init(['abc'], [], [], 'publicized', '1234', true);\n      expect(ers.isCommunityOwned()).toBe(true);\n    });\n  });\n});\n\ndescribe('Exploration gadgets service', function() {\n  beforeEach(module('oppia'));\n\n  describe('exploration gadgets service', function() {\n    var egs = null;\n    var $httpBackend = null;\n    var mockWarningsData;\n    var mockExplorationData;\n    var TEST_GADGET_NAME = 'TestGadget1';\n\n    var autosaveDraftUrl = 'createhandler/autosave_draft/0';\n    var validAutosaveResponse = {\n      is_version_of_draft_valid: true\n    };\n\n    var GADGET_SPECS = {\n      ScoreBar: {\n        type: 'ScoreBar',\n        width_px: 250,\n        panel: 'bottom',\n        customization_arg_specs: [{\n          name: 'title',\n          description: 'Optional title for the score bar (e.g. \\'Score\\')',\n          schema: {\n            type: 'unicode'\n          },\n          default_value: 'Score'\n        }, {\n          name: 'maxValue',\n          description: 'Maximum value (bar fills as a % of this value)',\n          schema: {\n            type: 'int'\n          },\n          default_value: 100\n        }, {\n          name: 'paramName',\n          description: 'The parameter name this score bar follows.',\n          schema: {\n            type: 'unicode'\n          },\n          default_value: ''\n        }],\n        height_px: 100,\n        description: 'A visual score bar.',\n        name: 'ScoreBar'\n      },\n      TestGadget: {\n        type: 'TestGadget',\n        width_px: 100,\n        panel: 'bottom',\n        customization_arg_specs: [{\n          name: 'title',\n          description: 'Optional title for the advice bar (e.g. \\'Tips\\')',\n          schema: {\n            type: 'unicode'\n          },\n          default_value: ''\n        }, {\n          name: 'adviceObjects',\n          description: 'Title and content for each tip.',\n          schema: {\n            type: 'list',\n            validators: [{\n              id: 'has_length_at_least',\n              min_value: 1\n            }, {\n              id: 'has_length_at_most',\n              max_value: 3\n            }],\n            items: {\n              properties: [{\n                name: 'adviceTitle',\n                description: 'Tip title (visible on advice bar)',\n                schema: {\n                  type: 'unicode',\n                  validators: [{\n                    id: 'is_nonempty'\n                  }]\n                }\n              }, {\n                name: 'adviceHtml',\n                description: 'Advice content (visible upon click)',\n                schema: {\n                  type: 'html'\n                }\n              }],\n              type: 'dict'\n            }\n          },\n          default_value: [{\n            adviceTitle: 'Tip title',\n            adviceHtml: ''\n          }]\n        }],\n        height_px: 300,\n        description: 'Allows learners to receive advice.',\n        name: 'TestGadget'\n      }\n    };\n    var skinCustomizationsData = {\n      panels_contents: {\n        bottom: [{\n          gadget_name: TEST_GADGET_NAME,\n          visible_in_states: [\n            'Example1',\n            'Example2'\n          ],\n          customization_args: {\n            title: {\n              value: 'TIP1'\n            },\n            adviceObjects: {\n              value: [{\n                adviceTitle: 'title1',\n                adviceHtml: 'content1'\n              }]\n            }\n          },\n          gadget_type: 'TestGadget'\n        }]\n      }\n    };\n    var gadgetData = {\n      gadget_type: 'TestGadget',\n      gadget_name: 'NewTestGadget',\n      panel: 'bottom',\n      customization_args: {\n        title: {\n          value: 'TIP3'\n        },\n        adviceObjects: {\n          value: [{\n            adviceTitle: 'title3',\n            adviceHtml: 'content3'\n          }]\n        }\n      },\n      visible_in_states: ['state1']\n    };\n\n    beforeEach(function() {\n      mockWarningsData = {\n        addWarning: function() {}\n      };\n      module(function($provide) {\n        $provide.value('alertsService', mockWarningsData);\n        $provide.constant('GADGET_SPECS', GADGET_SPECS);\n      });\n      spyOn(mockWarningsData, 'addWarning');\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($injector) {\n      egs = $injector.get('explorationGadgetsService');\n      $httpBackend = $injector.get('$httpBackend');\n      GLOBALS.PANEL_SPECS = {\n        bottom: {\n          stackable_axis: 'horizontal',\n          pixels_between_gadgets: 80,\n          max_gadgets: 1,\n          width: 350,\n          height: 100\n        }\n      };\n    }));\n\n    it('Update gadgets data when state is deleted', function() {\n      egs.init(skinCustomizationsData);\n      egs.handleStateDeletion('Example1');\n\n      expect(egs.getGadgets()[TEST_GADGET_NAME].visible_in_states).toEqual(\n        ['Example2']\n      );\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('Update gadgets data when state is renamed', function() {\n      egs.init(skinCustomizationsData);\n      egs.handleStateRenaming('Example2', 'newStateName');\n\n      expect(egs.getGadgets()[TEST_GADGET_NAME].visible_in_states).toEqual(\n        ['Example1', 'newStateName']\n      );\n      expect(mockExplorationData.autosaveChangeList).toHaveBeenCalled();\n      $httpBackend.expectPUT(autosaveDraftUrl).respond(validAutosaveResponse);\n    });\n\n    it('should detect invalid data passed for initialization', function() {\n      egs.init({\n        wrongObjectKey: 'value'\n      });\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'Gadget Initialization failed. Panel contents were not provided');\n    });\n\n    it('init on valid data', function() {\n      egs.init(skinCustomizationsData);\n      expect(egs.getPanels()).toEqual({\n        bottom: [TEST_GADGET_NAME]\n      });\n    });\n\n    it('add a new gadget with valid data', function() {\n      egs.init(skinCustomizationsData);\n      egs.addGadget(gadgetData, 'bottom');\n      expect(egs.getPanels()).toEqual({\n        bottom: [TEST_GADGET_NAME, 'NewTestGadget']\n      });\n    });\n\n    it('should detect non existent panel when adding gadget', function() {\n      egs.init(skinCustomizationsData);\n      gadgetData.panel = 'unknown_panel';\n      egs.addGadget(gadgetData);\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'Attempted add to a non-existent panel: unknown_panel');\n    });\n\n    it('should detect same gadget name before adding gadget', function() {\n      egs.init(skinCustomizationsData);\n      gadgetData.gadget_name = TEST_GADGET_NAME;\n      gadgetData.panel = 'bottom';\n      egs.addGadget(gadgetData);\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'A gadget with this name already exists.');\n    });\n\n    it('should detect unknown gadget name before updating gadget', function() {\n      egs.init(skinCustomizationsData);\n      egs.updateGadget('unknownGadgetName', {}, []);\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'Attempted to update a non-existent gadget: unknownGadgetName');\n    });\n\n    it('should detect if gadget is not visible in any state.', function() {\n      egs.init(skinCustomizationsData);\n      egs.updateGadget(TEST_GADGET_NAME, gadgetData[TEST_GADGET_NAME], []);\n      expect(mockWarningsData.addWarning).toHaveBeenCalledWith(\n        'This gadget is not visible in any states.');\n    });\n\n    // TODO(vjoisar/sll): Add the test case when we delete the only state that\n    // contains the gadget.\n    // Also ensure right confirmation boxes show up in various cases.\n  });\n});\n\ndescribe('New state template service', function() {\n  beforeEach(module('oppia'));\n\n  describe('new state template service', function() {\n    var nsts = null;\n    var NEW_STATE_NAME = 'new state name';\n\n    beforeEach(inject(function($injector) {\n      GLOBALS.NEW_STATE_TEMPLATE = {\n        content: [{\n          type: 'text',\n          value: ''\n        }],\n        interaction: {\n          answer_groups: [],\n          confirmed_unclassified_answers: [],\n          customization_args: {\n            rows: {\n              value: 1\n            },\n            placeholder: {\n              value: 'Type your answer here.'\n            }\n          },\n          default_outcome: {\n            dest: '(untitled state)',\n            feedback: [],\n            param_changes: []\n          },\n          fallbacks: [],\n          id: 'TextInput'\n        },\n        param_changes: []\n      };\n      nsts = $injector.get('newStateTemplateService');\n    }));\n\n    it('should make a new state template given a state name', function() {\n      expect(JSON.parse(JSON.stringify(\n          nsts.getNewStateTemplate(NEW_STATE_NAME)\n        ))).toEqual({\n          name: 'new state name',\n          content: [{\n            type: 'text',\n            value: ''\n          }],\n          interaction: {\n            answer_groups: [],\n            confirmed_unclassified_answers: [],\n            customization_args: {\n              rows: {\n                value: 1\n              },\n              placeholder: {\n                value: 'Type your answer here.'\n              }\n            },\n            default_outcome: {\n              dest: NEW_STATE_NAME,\n              feedback: [],\n              param_changes: []\n            },\n            fallbacks: [],\n            id: 'TextInput'\n          },\n          paramChanges: []\n        });\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/ParamChangesEditorDirective.js",
      "content": "// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Directive for the parameter changes editor (which is shown in\n * both the exploration settings tab and the state editor page).\n */\n\noppia.directive('paramChangesEditor', [function() {\n  return {\n    restrict: 'E',\n    scope: {\n      paramChangesService: '=',\n      postSaveHook: '='\n    },\n    templateUrl: 'editor/paramChanges',\n    controller: [\n      '$scope', '$rootScope', 'editabilityService',\n      'explorationParamSpecsService', 'alertsService',\n      'UrlInterpolationService',\n      function(\n          $scope, $rootScope, editabilityService,\n          explorationParamSpecsService, alertsService,\n          UrlInterpolationService) {\n        $scope.editabilityService = editabilityService;\n        $scope.isParamChangesEditorOpen = false;\n        $scope.warningText = '';\n        $scope.PREAMBLE_TEXT = {\n          Copier: 'to',\n          RandomSelector: 'to one of'\n        };\n\n        var INVALID_PARAMETER_NAMES = GLOBALS.INVALID_PARAMETER_NAMES;\n        var DEFAULT_PARAM_SPEC = {\n          obj_type: 'UnicodeString'\n        };\n        var DEFAULT_CUSTOMIZATION_ARGS = {\n          Copier: {\n            parse_with_jinja: true,\n            value: '5'\n          },\n          RandomSelector: {\n            list_of_values: ['sample value']\n          }\n        };\n\n        $scope.$on('externalSave', function() {\n          if ($scope.isParamChangesEditorOpen) {\n            $scope.saveParamChanges();\n          }\n        });\n\n        var getDefaultParameterChange = function(name) {\n          return angular.copy({\n            customization_args: angular.copy(DEFAULT_CUSTOMIZATION_ARGS.Copier),\n            generator_id: 'Copier',\n            name: name\n          });\n        };\n\n        var generateParamNameChoices = function() {\n          return Object.keys(\n            explorationParamSpecsService.displayed\n          ).sort().map(function(paramName) {\n            return {\n              id: paramName,\n              text: paramName\n            };\n          });\n        };\n\n        // This is a local variable that is used by the select2 dropdowns for\n        // choosing parameter names. It may not accurately reflect the content\n        // of explorationParamSpecsService, since it's possible that temporary\n        // parameter names may be added and then deleted within the course of a\n        // single \"parameter changes\" edit.\n        $scope.paramNameChoices = [];\n\n        $scope.addParamChange = function() {\n          var newParamName = (\n            $scope.paramNameChoices.length > 0 ?\n            $scope.paramNameChoices[0].id : 'x');\n          var newParamChange = getDefaultParameterChange(newParamName);\n          // Add the new param name to $scope.paramNameChoices, if necessary,\n          // so that it shows up in the dropdown.\n          if (!$scope.paramNameChoices.hasOwnProperty(newParamChange.name)) {\n            explorationParamSpecsService.displayed[newParamChange.name] = (\n              angular.copy(DEFAULT_PARAM_SPEC));\n            $scope.paramNameChoices = generateParamNameChoices();\n          };\n\n          $scope.paramChangesService.displayed.push(newParamChange);\n        };\n\n        $scope.openParamChangesEditor = function() {\n          if (!editabilityService.isEditable()) {\n            return;\n          }\n\n          $scope.isParamChangesEditorOpen = true;\n          $scope.paramNameChoices = generateParamNameChoices();\n\n          if ($scope.paramChangesService.displayed.length === 0) {\n            $scope.addParamChange();\n          }\n        };\n\n        $scope.onChangeGeneratorType = function(paramChange) {\n          paramChange.customization_args = angular.copy(\n            DEFAULT_CUSTOMIZATION_ARGS[paramChange.generator_id]);\n        };\n\n        $scope.HUMAN_READABLE_ARGS_RENDERERS = {\n          Copier: function(customizationArgs) {\n            return 'to ' + customizationArgs.value;\n          },\n          RandomSelector: function(customizationArgs) {\n            var result = 'to one of [';\n            for (var i = 0; i < customizationArgs.list_of_values.length; i++) {\n              if (i !== 0) {\n                result += ', ';\n              }\n              result += String(customizationArgs.list_of_values[i]);\n            }\n            result += '] at random';\n            return result;\n          }\n        };\n\n        $scope.areDisplayedParamChangesValid = function() {\n          paramChanges = $scope.paramChangesService.displayed;\n\n          for (var i = 0; i < paramChanges.length; i++) {\n            var paramName = paramChanges[i].name;\n            if (paramName === '') {\n              $scope.warningText = 'Please pick a non-empty parameter name.';\n              return false;\n            }\n\n            if (INVALID_PARAMETER_NAMES.indexOf(paramName) !== -1) {\n              $scope.warningText = (\n                'The parameter name \\'' + paramName + '\\' is reserved.');\n              return false;\n            }\n\n            var ALPHA_CHARS_REGEX = /^[A-Za-z]+$/;\n            if (!ALPHA_CHARS_REGEX.test(paramName)) {\n              $scope.warningText = (\n                'Parameter names should use only alphabetic characters.');\n              return false;\n            }\n\n            var generatorId = paramChanges[i].generator_id;\n            var customizationArgs = paramChanges[i].customization_args;\n\n            if (!$scope.PREAMBLE_TEXT.hasOwnProperty(generatorId)) {\n              $scope.warningText = 'Each parameter should have a generator id.';\n              return false;\n            }\n\n            if (generatorId === 'RandomSelector' &&\n                customizationArgs.list_of_values.length === 0) {\n              $scope.warningText = (\n                'Each parameter should have at least one possible value.');\n              return false;\n            }\n          }\n\n          $scope.warningText = '';\n          return true;\n        };\n\n        $scope.saveParamChanges = function() {\n          // Validate displayed value.\n          if (!$scope.areDisplayedParamChangesValid()) {\n            alertsService.addWarning('Invalid parameter changes.');\n            return;\n          }\n\n          $scope.isParamChangesEditorOpen = false;\n\n          // Update paramSpecs manually with newly-added param names.\n          explorationParamSpecsService.restoreFromMemento();\n          $scope.paramChangesService.displayed.forEach(function(paramChange) {\n            var paramName = paramChange.name;\n            if (!explorationParamSpecsService.displayed.hasOwnProperty(\n                  paramName)) {\n              explorationParamSpecsService.displayed[paramName] = angular.copy(\n                DEFAULT_PARAM_SPEC);\n            }\n          });\n\n          explorationParamSpecsService.saveDisplayedValue();\n          $scope.paramChangesService.saveDisplayedValue();\n          if ($scope.postSaveHook) {\n            $scope.postSaveHook();\n          }\n        };\n\n        $scope.deleteParamChange = function(index) {\n          if (index < 0 ||\n              index >= $scope.paramChangesService.displayed.length) {\n            alertsService.addWarning(\n              'Cannot delete parameter change at position ' + index +\n              ': index out of range');\n          }\n\n          // This ensures that any new parameter names that have been added\n          // before the deletion are added to the list of possible names in the\n          // select2 dropdowns. Otherwise, after the deletion, the dropdowns\n          // may turn blank.\n          $scope.paramChangesService.displayed.forEach(function(paramChange) {\n            if (!explorationParamSpecsService.displayed.hasOwnProperty(\n                paramChange.name)) {\n              explorationParamSpecsService.displayed[paramChange.name] = (\n                angular.copy(DEFAULT_PARAM_SPEC));\n            }\n          });\n          $scope.paramNameChoices = generateParamNameChoices();\n\n          $scope.paramChangesService.displayed.splice(index, 1);\n        };\n\n        $scope.PARAM_CHANGE_LIST_SORTABLE_OPTIONS = {\n          axis: 'y',\n          containment: '.oppia-param-change-draggable-area',\n          cursor: 'move',\n          handle: '.oppia-param-change-sort-handle',\n          items: '.oppia-param-editor-row',\n          tolerance: 'pointer',\n          start: function(e, ui) {\n            $scope.$apply();\n            ui.placeholder.height(ui.item.height());\n          },\n          stop: function() {\n            // This ensures that any new parameter names that have been added\n            // before the swap are added to the list of possible names in the\n            // select2 dropdowns. Otherwise, after the swap, the dropdowns may\n            // turn blank.\n            $scope.paramChangesService.displayed.forEach(function(paramChange) {\n              if (!explorationParamSpecsService.displayed.hasOwnProperty(\n                  paramChange.name)) {\n                explorationParamSpecsService.displayed[paramChange.name] = (\n                  angular.copy(DEFAULT_PARAM_SPEC));\n              }\n            });\n            $scope.paramNameChoices = generateParamNameChoices();\n            $scope.$apply();\n          }\n        };\n\n        $scope.cancelEdit = function() {\n          $scope.paramChangesService.restoreFromMemento();\n          $scope.isParamChangesEditorOpen = false;\n        };\n\n        $scope.dragDotsImgUrl = UrlInterpolationService.getStaticImageUrl(\n          '/general/drag_dots.png');\n      }\n    ]\n  };\n}]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/ParameterMetadataService.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for computing parameter metadata.\n */\n\noppia.factory('parameterMetadataService', [\n  'explorationStatesService', 'expressionInterpolationService',\n  'explorationParamChangesService', 'graphDataService',\n  function(\n      explorationStatesService, expressionInterpolationService,\n      explorationParamChangesService, graphDataService) {\n    var PARAM_ACTION_GET = 'get';\n    var PARAM_ACTION_SET = 'set';\n\n    var PARAM_SOURCE_ANSWER = 'answer';\n    var PARAM_SOURCE_CONTENT = 'content';\n    var PARAM_SOURCE_FEEDBACK = 'feedback';\n    var PARAM_SOURCE_PARAM_CHANGES = 'param_changes';\n\n    var getMetadataFromParamChanges = function(paramChanges) {\n      var result = [];\n      for (var i = 0; i < paramChanges.length; i++) {\n        var pc = paramChanges[i];\n\n        if (pc.generator_id === 'Copier') {\n          if (!pc.customization_args.parse_with_jinja) {\n            result.push({\n              action: PARAM_ACTION_SET,\n              paramName: pc.name,\n              source: PARAM_SOURCE_PARAM_CHANGES,\n              sourceInd: i\n            });\n          } else {\n            var paramsReferenced = (\n              expressionInterpolationService.getParamsFromString(\n                pc.customization_args.value));\n            for (var j = 0; j < paramsReferenced.length; j++) {\n              result.push({\n                action: PARAM_ACTION_GET,\n                paramName: paramsReferenced[j],\n                source: PARAM_SOURCE_PARAM_CHANGES,\n                sourceInd: i\n              });\n            }\n\n            result.push({\n              action: PARAM_ACTION_SET,\n              paramName: pc.name,\n              source: PARAM_SOURCE_PARAM_CHANGES,\n              sourceInd: i\n            });\n          }\n        } else {\n          // RandomSelector. Elements in the list of possibilities are treated\n          // as raw unicode strings, not expressions.\n          result.push({\n            action: PARAM_ACTION_SET,\n            paramName: pc.name,\n            source: PARAM_SOURCE_PARAM_CHANGES,\n            sourceInd: i\n          });\n        }\n      }\n\n      return result;\n    };\n\n    // Returns a list of set/get actions for parameters in the given state, in\n    // the order that they occur.\n    // TODO(sll): Add trace data (so that it's easy to figure out in which rule\n    // an issue occurred, say).\n    var getStateParamMetadata = function(state) {\n      // First, the state param changes are applied: we get their values\n      // and set the params.\n      var result = getMetadataFromParamChanges(state.paramChanges);\n\n      // Next, the content is evaluated.\n      expressionInterpolationService.getParamsFromString(\n          state.content[0].value).forEach(function(paramName) {\n        result.push({\n          action: PARAM_ACTION_GET,\n          paramName: paramName,\n          source: PARAM_SOURCE_CONTENT\n        });\n      });\n\n      // Next, the answer is received.\n      result.push({\n        action: PARAM_ACTION_SET,\n        paramName: 'answer',\n        source: PARAM_SOURCE_ANSWER\n      });\n\n      // Finally, the rule feedback strings are evaluated.\n      state.interaction.answer_groups.forEach(function(group) {\n        for (var k = 0; k < group.outcome.feedback.length; k++) {\n          expressionInterpolationService.getParamsFromString(\n              group.outcome.feedback[k]).forEach(function(paramName) {\n            result.push({\n              action: PARAM_ACTION_GET,\n              paramName: paramName,\n              source: PARAM_SOURCE_FEEDBACK,\n              sourceInd: k\n            });\n          });\n        }\n      });\n\n      return result;\n    };\n\n    // Returns one of null, PARAM_ACTION_SET, PARAM_ACTION_GET depending on\n    // whether this parameter is not used at all in this state, or\n    // whether its first occurrence is a 'set' or 'get'.\n    var getParamStatus = function(stateParamMetadata, paramName) {\n      for (var i = 0; i < stateParamMetadata.length; i++) {\n        if (stateParamMetadata[i].paramName === paramName) {\n          return stateParamMetadata[i].action;\n        }\n      }\n      return null;\n    };\n\n    return {\n      // Returns a list of objects, each indicating a parameter for which it is\n      // possible to arrive at a state with that parameter required but unset.\n      // Each object in this list has two keys:\n      // - paramName: the name of the parameter that may be unset\n      // - stateName: the name of one of the states it is possible to reach\n      //     with the parameter being unset, or null if the place where the\n      //     parameter is required is in the initial list of parameter changes\n      //     (e.g. one parameter may be set based on the value assigned to\n      //     another parameter).\n      getUnsetParametersInfo: function(initNodeIds) {\n        var graphData = graphDataService.getGraphData();\n\n        var states = explorationStatesService.getStates();\n\n        // Determine all parameter names that are used within this exploration.\n        var allParamNames = [];\n        var expParamMetadata = getMetadataFromParamChanges(\n          explorationParamChangesService.savedMemento);\n        var stateParamMetadatas = {};\n\n        expParamMetadata.forEach(function(expParamMetadataItem) {\n          if (allParamNames.indexOf(expParamMetadataItem.paramName) === -1) {\n            allParamNames.push(expParamMetadataItem.paramName);\n          }\n        });\n        for (var stateName in states) {\n          stateParamMetadatas[stateName] = getStateParamMetadata(\n            states[stateName]);\n          for (var i = 0; i < stateParamMetadatas[stateName].length; i++) {\n            var pName = stateParamMetadatas[stateName][i].paramName;\n            if (allParamNames.indexOf(pName) === -1) {\n              allParamNames.push(pName);\n            }\n          }\n        }\n\n        // For each parameter, do a BFS to see if it's possible to get from\n        // the start node to a node requiring this parameter, without passing\n        // through any nodes that set this parameter.\n        var unsetParametersInfo = [];\n\n        for (var paramInd = 0; paramInd < allParamNames.length; paramInd++) {\n          var paramName = allParamNames[paramInd];\n          var tmpUnsetParameter = null;\n\n          var paramStatusAtOutset = getParamStatus(expParamMetadata, paramName);\n          if (paramStatusAtOutset === PARAM_ACTION_GET) {\n            unsetParametersInfo.push({\n              paramName: paramName,\n              stateName: null\n            });\n            continue;\n          } else if (paramStatusAtOutset === PARAM_ACTION_SET) {\n            // This parameter will remain set for the entirety of the\n            // exploration.\n            continue;\n          }\n\n          var queue = [];\n          var seen = {};\n          for (var i = 0; i < initNodeIds.length; i++) {\n            seen[initNodeIds[i]] = true;\n            var paramStatus = getParamStatus(\n              stateParamMetadatas[initNodeIds[i]], paramName);\n            if (paramStatus === PARAM_ACTION_GET) {\n              tmpUnsetParameter = {\n                paramName: paramName,\n                stateName: initNodeIds[i]\n              };\n              break;\n            } else if (!paramStatus) {\n              queue.push(initNodeIds[i]);\n            }\n          }\n\n          if (tmpUnsetParameter) {\n            unsetParametersInfo.push(angular.copy(tmpUnsetParameter));\n            continue;\n          }\n\n          while (queue.length > 0) {\n            var currNodeId = queue.shift();\n            for (var edgeInd = 0; edgeInd < graphData.links.length; edgeInd++) {\n              var edge = graphData.links[edgeInd];\n              if (edge.source === currNodeId &&\n                  !seen.hasOwnProperty(edge.target)) {\n                seen[edge.target] = true;\n                paramStatus = getParamStatus(\n                  stateParamMetadatas[edge.target], paramName);\n                if (paramStatus === PARAM_ACTION_GET) {\n                  tmpUnsetParameter = {\n                    paramName: paramName,\n                    stateName: edge.target\n                  };\n                  break;\n                } else if (!paramStatus) {\n                  queue.push(edge.target);\n                }\n              }\n            }\n          }\n\n          if (tmpUnsetParameter) {\n            unsetParametersInfo.push(angular.copy(tmpUnsetParameter));\n            continue;\n          }\n        }\n\n        return unsetParametersInfo;\n      }\n    };\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/StateEditor.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controllers for the graphical state editor.\n */\n\noppia.controller('StateEditor', [\n  '$scope', '$rootScope', 'editorContextService', 'changeListService',\n  'editabilityService', 'explorationStatesService', 'INTERACTION_SPECS',\n  'explorationInitStateNameService', 'explorationAdvancedFeaturesService',\n  'UrlInterpolationService', 'editorFirstTimeEventsService',\n  function(\n      $scope, $rootScope, editorContextService, changeListService,\n      editabilityService, explorationStatesService, INTERACTION_SPECS,\n      explorationInitStateNameService, explorationAdvancedFeaturesService,\n      UrlInterpolationService, editorFirstTimeEventsService) {\n    $scope.STATE_CONTENT_SCHEMA = {\n      type: 'html'\n    };\n\n    $scope.areParametersEnabled = (\n      explorationAdvancedFeaturesService.areParametersEnabled);\n    $scope.areFallbacksEnabled = (\n      explorationAdvancedFeaturesService.areFallbacksEnabled);\n\n    $scope.isCurrentStateTerminal = false;\n    $scope.isInteractionIdSet = false;\n    $scope.isInteractionShown = false;\n\n    $scope.oppiaBlackImgUrl = UrlInterpolationService.getStaticImageUrl(\n      '/avatar/oppia_black_72px.png');\n\n    $scope.isCurrentStateInitialState = function() {\n      return (\n        editorContextService.getActiveStateName() ===\n        explorationInitStateNameService.savedMemento);\n    };\n\n    $scope.$on('refreshStateEditor', function() {\n      $scope.initStateEditor();\n    });\n\n    $scope.$on('refreshStateContent', function() {\n      $scope.content = explorationStatesService.getStateContentMemento(\n        editorContextService.getActiveStateName());\n    });\n\n    $scope.$on('onInteractionIdChanged', function(evt, newInteractionId) {\n      $scope.isInteractionIdSet = Boolean(newInteractionId);\n      $scope.isCurrentStateTerminal = (\n        $scope.isInteractionIdSet && INTERACTION_SPECS[\n          newInteractionId].is_terminal);\n    });\n\n    $scope.contentEditorIsOpen = false;\n\n    $scope.initStateEditor = function() {\n      var stateName = editorContextService.getActiveStateName();\n      var stateData = explorationStatesService.getState(stateName);\n      if (stateName && stateData) {\n        $scope.content = explorationStatesService.getStateContentMemento(\n          stateName);\n\n        $rootScope.$broadcast('stateEditorInitialized', stateData);\n        var interactionId = explorationStatesService.getInteractionIdMemento(\n          stateName);\n        $scope.isInteractionIdSet = Boolean(interactionId);\n        $scope.isCurrentStateTerminal = (\n          $scope.isInteractionIdSet &&\n          INTERACTION_SPECS[interactionId].is_terminal);\n\n        if ($scope.content[0].value || stateData.interaction.id) {\n          $scope.isInteractionShown = true;\n        }\n\n        $scope.$on('externalSave', function() {\n          if ($scope.contentEditorIsOpen) {\n            $scope.saveTextContent();\n          }\n        });\n\n        $rootScope.loadingMessage = '';\n      }\n    };\n\n    $scope.openStateContentEditor = function() {\n      if (editabilityService.isEditable()) {\n        editorFirstTimeEventsService.registerFirstOpenContentBoxEvent();\n        $scope.contentEditorIsOpen = true;\n      }\n    };\n\n    $scope.saveTextContent = function() {\n      explorationStatesService.saveStateContent(\n        editorContextService.getActiveStateName(), $scope.content);\n      $scope.contentEditorIsOpen = false;\n    };\n\n    $scope.onSaveContentButtonClicked = function() {\n      editorFirstTimeEventsService.registerFirstSaveContentEvent();\n      $scope.saveTextContent();\n      // Show the interaction when the text content is saved, even if no content\n      // is entered.\n      $scope.isInteractionShown = true;\n    };\n\n    $scope.cancelEdit = function() {\n      $scope.content = explorationStatesService.getStateContentMemento(\n        editorContextService.getActiveStateName());\n      $scope.contentEditorIsOpen = false;\n    };\n  }\n]);\n\n// A service which handles opening and closing the training modal used for both\n// unresolved answers and answers within the training data of a classifier.\noppia.factory('trainingModalService', ['$rootScope', '$modal', 'alertsService',\n    function($rootScope, $modal, alertsService) {\n  return {\n    openTrainUnresolvedAnswerModal: function(unhandledAnswer, externalSave) {\n      alertsService.clearWarnings();\n      if (externalSave) {\n        $rootScope.$broadcast('externalSave');\n      }\n\n      $modal.open({\n        templateUrl: 'modals/trainUnresolvedAnswer',\n        backdrop: true,\n        controller: ['$scope', '$modalInstance', 'explorationStatesService',\n          'editorContextService', 'AnswerClassificationService',\n          'explorationContextService',\n          function($scope, $modalInstance, explorationStatesService,\n              editorContextService, AnswerClassificationService,\n              explorationContextService) {\n            $scope.trainingDataAnswer = '';\n            $scope.trainingDataFeedback = '';\n            $scope.trainingDataOutcomeDest = '';\n\n            // See the training panel directive in StateEditor for an\n            // explanation on the structure of this object.\n            $scope.classification = {\n              answerGroupIndex: 0,\n              newOutcome: null\n            };\n\n            $scope.finishTraining = function() {\n              $modalInstance.close();\n            };\n\n            $scope.init = function() {\n              var explorationId = explorationContextService.getExplorationId();\n              var currentStateName = editorContextService.getActiveStateName();\n              var state = explorationStatesService.getState(currentStateName);\n\n              AnswerClassificationService.getMatchingClassificationResult(\n                explorationId, state, unhandledAnswer, true).then(\n                    function(classificationResult) {\n                  var feedback = 'Nothing';\n                  var dest = classificationResult.outcome.dest;\n                  if (classificationResult.outcome.feedback.length > 0) {\n                    feedback = classificationResult.outcome.feedback[0];\n                  }\n                  if (dest === currentStateName) {\n                    dest = '<em>(try again)</em>';\n                  }\n\n                  // $scope.trainingDataAnswer, $scope.trainingDataFeedback\n                  // $scope.trainingDataOutcomeDest are intended to be local to\n                  // this modal and should not be used to populate any\n                  // information in the active exploration (including the\n                  // feedback). The feedback here refers to a representation of\n                  // the outcome of an answer group, rather than the specific\n                  // feedback of the outcome (for instance, it includes the\n                  // destination state within the feedback).\n                  $scope.trainingDataAnswer = unhandledAnswer;\n                  $scope.trainingDataFeedback = feedback;\n                  $scope.trainingDataOutcomeDest = dest;\n                  $scope.classification.answerGroupIndex = (\n                    classificationResult.answerGroupIndex);\n                });\n            };\n\n            $scope.init();\n          }]\n      });\n    }\n  };\n}]);\n\n// A service that, given an exploration ID and state name, determines all of the\n// answers which do not have certain classification and are not currently used\n// as part of any classifier training models.\noppia.factory('trainingDataService', [\n  '$rootScope', '$http', 'responsesService', 'CLASSIFIER_RULESPEC_STR',\n  'DEFAULT_CLASSIFIER_RULE_SPEC',\n  function(\n      $rootScope, $http, responsesService, CLASSIFIER_RULESPEC_STR,\n      DEFAULT_CLASSIFIER_RULE_SPEC) {\n    var _trainingDataAnswers = [];\n    var _trainingDataCounts = [];\n\n    var _getIndexOfTrainingData = function(answer, trainingData) {\n      var index = -1;\n      for (var i = 0; i < trainingData.length; i++) {\n        if (angular.equals(trainingData[i], answer)) {\n          index = i;\n          break;\n        }\n      }\n      return index;\n    };\n\n    // Attempts to remove a given answer from a list of trained answers. This\n    // function returns the index of the answer that was removed if it was\n    // successfully removed from the training data, or -1 otherwise.\n    var _removeAnswerFromTrainingData = function(answer, trainingData) {\n      var index = _getIndexOfTrainingData(answer, trainingData);\n      if (index !== -1) {\n        trainingData.splice(index, 1);\n      }\n      return index;\n    };\n\n    // This removes any occurrences of the answer from any training data inputs\n    // or the confirmed unclassified answer list. It also removes the answer\n    // from the training data being presented to the user so that it does not\n    // show up again.\n    var _removeAnswer = function(answer) {\n      var answerGroups = responsesService.getAnswerGroups();\n      var confirmedUnclassifiedAnswers = (\n        responsesService.getConfirmedUnclassifiedAnswers());\n      var updatedAnswerGroups = false;\n      var updatedConfirmedUnclassifiedAnswers = false;\n\n      // Remove the answer from all answer groups.\n      for (var i = 0; i < answerGroups.length; i++) {\n        var answerGroup = answerGroups[i];\n        var ruleSpecs = answerGroup.ruleSpecs;\n        var trainingData = null;\n        var classifierIndex = -1;\n        for (var j = 0; j < ruleSpecs.length; j++) {\n          var ruleSpec = ruleSpecs[j];\n          if (ruleSpec.rule_type === CLASSIFIER_RULESPEC_STR) {\n            trainingData = ruleSpec.inputs.training_data;\n            classifierIndex = j;\n            break;\n          }\n        }\n        if (trainingData &&\n            _removeAnswerFromTrainingData(answer, trainingData) !== -1) {\n          if (trainingData.length === 0 && ruleSpecs.length > 1) {\n            // If the last of the training data for a classifier has been\n            // removed and the classifier is not the only rule in the group,\n            // remove the rule since it is no longer doing anything.\n            ruleSpecs.splice(classifierIndex, 1);\n          }\n          updatedAnswerGroups = true;\n        }\n      }\n\n      // Remove the answer from the confirmed unclassified answers.\n      updatedConfirmedUnclassifiedAnswers = (_removeAnswerFromTrainingData(\n        answer, confirmedUnclassifiedAnswers) !== -1);\n\n      if (updatedAnswerGroups) {\n        responsesService.save(\n          answerGroups, responsesService.getDefaultOutcome());\n      }\n\n      if (updatedConfirmedUnclassifiedAnswers) {\n        responsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n      }\n\n      var index = _removeAnswerFromTrainingData(answer, _trainingDataAnswers);\n      if (index !== -1) {\n        _trainingDataCounts.splice(index, 1);\n        $rootScope.$broadcast('updatedTrainingData');\n      }\n    };\n\n    return {\n      initializeTrainingData: function(explorationId, stateName) {\n        var trainingDataUrl = '/createhandler/training_data/' + explorationId +\n          '/' + encodeURIComponent(stateName);\n        $http.get(trainingDataUrl).then(function(response) {\n          var unhandledAnswers = response.data.unhandled_answers;\n          _trainingDataAnswers = [];\n          _trainingDataCounts = [];\n          for (var i = 0; i < unhandledAnswers.length; i++) {\n            var unhandledAnswer = unhandledAnswers[i];\n            _trainingDataAnswers.push(unhandledAnswer.value);\n            _trainingDataCounts.push(unhandledAnswer.count);\n          }\n          $rootScope.$broadcast('updatedTrainingData');\n        });\n      },\n\n      getTrainingDataAnswers: function() {\n        return _trainingDataAnswers;\n      },\n\n      getTrainingDataCounts: function() {\n        return _trainingDataCounts;\n      },\n\n      getAllPotentialOutcomes: function(state) {\n        var potentialOutcomes = [];\n        var interaction = state.interaction;\n\n        for (var i = 0; i < interaction.answer_groups.length; i++) {\n          potentialOutcomes.push(interaction.answer_groups[i].outcome);\n        }\n\n        if (interaction.default_outcome) {\n          var outcome = interaction.default_outcome;\n          potentialOutcomes.push(interaction.default_outcome);\n        }\n\n        return potentialOutcomes;\n      },\n\n      trainAnswerGroup: function(answerGroupIndex, answer) {\n        _removeAnswer(answer);\n\n        var answerGroup = responsesService.getAnswerGroup(answerGroupIndex);\n        var rules = answerGroup.ruleSpecs;\n\n        // Ensure the answer group has a classifier rule.\n        var classifierRule = null;\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i];\n          if (rule.rule_type === CLASSIFIER_RULESPEC_STR) {\n            classifierRule = rule;\n            break;\n          }\n        }\n        if (!classifierRule) {\n          // Create new classifier rule for classification. All classifiers\n          // should match this schema.\n          classifierRule = angular.copy(DEFAULT_CLASSIFIER_RULE_SPEC);\n          rules.push(classifierRule);\n        }\n\n        // Train the rule to include this answer, but only if it's not already\n        // in the training data.\n        if (_getIndexOfTrainingData(\n            answer, classifierRule.inputs.training_data) === -1) {\n          classifierRule.inputs.training_data.push(answer);\n        }\n\n        responsesService.updateAnswerGroup(answerGroupIndex, {\n          rules: rules\n        });\n      },\n\n      trainDefaultResponse: function(answer) {\n        _removeAnswer(answer);\n\n        var confirmedUnclassifiedAnswers = (\n          responsesService.getConfirmedUnclassifiedAnswers());\n\n        if (_getIndexOfTrainingData(\n              answer, confirmedUnclassifiedAnswers) === -1) {\n          confirmedUnclassifiedAnswers.push(answer);\n        }\n\n        responsesService.updateConfirmedUnclassifiedAnswers(\n          confirmedUnclassifiedAnswers);\n      }\n    };\n  }\n]);\n\noppia.directive('trainingPanel', [function() {\n  return {\n    restrict: 'E',\n    scope: {\n      answer: '=',\n      answerFeedback: '=',\n      answerOutcomeDest: '=',\n      // The classification input is an object with two keys:\n      //   -answerGroupIndex: This refers to which answer group the answer being\n      //      trained has been classified to (for displaying feedback to the\n      //      creator). If answerGroupIndex is equal to the number of answer\n      //      groups, then it represents the default outcome feedback. This\n      //      index is changed by the panel when the creator specifies which\n      //      feedback should be associated with the answer.\n      //   -newOutcome: This refers to an outcome structure (containing a list\n      //      of feedback and a destination state name) which is non-null if,\n      //      and only if, the creator has specified that a new response should\n      //      be created for the trained answer.\n      classification: '=',\n      onFinishTraining: '&'\n    },\n    templateUrl: 'teaching/trainingPanel',\n    controller: [\n      '$scope', 'oppiaExplorationHtmlFormatterService', 'editorContextService',\n      'explorationStatesService', 'trainingDataService', 'responsesService',\n      'stateInteractionIdService', 'stateCustomizationArgsService',\n      function($scope, oppiaExplorationHtmlFormatterService,\n          editorContextService, explorationStatesService, trainingDataService,\n          responsesService, stateInteractionIdService,\n          stateCustomizationArgsService) {\n        $scope.changingAnswerGroupIndex = false;\n        $scope.addingNewResponse = false;\n\n        var _stateName = editorContextService.getActiveStateName();\n        var _state = explorationStatesService.getState(_stateName);\n        $scope.allOutcomes = trainingDataService.getAllPotentialOutcomes(\n          _state);\n\n        var _updateAnswerTemplate = function() {\n          $scope.answerTemplate = (\n            oppiaExplorationHtmlFormatterService.getAnswerHtml(\n              $scope.answer, stateInteractionIdService.savedMemento,\n              stateCustomizationArgsService.savedMemento));\n        };\n\n        $scope.$watch('answer', _updateAnswerTemplate);\n        _updateAnswerTemplate();\n\n        $scope.getCurrentStateName = function() {\n          return editorContextService.getActiveStateName();\n        };\n\n        $scope.beginChangingAnswerGroupIndex = function() {\n          $scope.changingAnswerGroupIndex = true;\n        };\n\n        $scope.beginAddingNewResponse = function() {\n          $scope.classification.newOutcome = {\n            dest: editorContextService.getActiveStateName(),\n            feedback: [''],\n            param_changes: []\n          };\n          $scope.addingNewResponse = true;\n        };\n\n        $scope.confirmAnswerGroupIndex = function(index) {\n          $scope.classification.answerGroupIndex = index;\n\n          if (index === responsesService.getAnswerGroupCount()) {\n            trainingDataService.trainDefaultResponse($scope.answer);\n          } else {\n            trainingDataService.trainAnswerGroup(index, $scope.answer);\n          }\n\n          $scope.onFinishTraining();\n        };\n        $scope.confirmNewFeedback = function() {\n          if ($scope.classification.newOutcome) {\n            // Create a new answer group with the given feedback.\n            var answerGroups = responsesService.getAnswerGroups();\n            answerGroups.push(AnswerGroupObjectFactory.create(\n              [], angular.copy($scope.classification.newOutcome)));\n            responsesService.save(\n              answerGroups, responsesService.getDefaultOutcome());\n\n            // Train the group with the answer.\n            var index = responsesService.getAnswerGroupCount() - 1;\n            trainingDataService.trainAnswerGroup(index, $scope.answer);\n          }\n\n          $scope.onFinishTraining();\n        };\n      }\n    ]\n  };\n}]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/StateEditorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the controller of the 'State Editor'. This also\n * includes unit tests for the training data service.\n */\n\ndescribe('State Editor controller', function() {\n  describe('StateEditor', function() {\n    var scope, ctrl, ecs, cls, ess;\n    var $httpBackend;\n    var mockExplorationData;\n\n    beforeEach(function() {\n      module('oppia');\n      // Set a global value for INTERACTION_SPECS that will be used by all the\n      // descendant dependencies.\n      module(function($provide) {\n        $provide.constant('INTERACTION_SPECS', {\n          TextInput: {\n            display_mode: 'inline',\n            is_terminal: false\n          }\n        });\n      });\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($rootScope, $controller, $injector) {\n      scope = $rootScope.$new();\n      $httpBackend = $injector.get('$httpBackend');\n      ecs = $injector.get('editorContextService');\n      cls = $injector.get('changeListService');\n      ess = $injector.get('explorationStatesService');\n      IS = $injector.get('INTERACTION_SPECS');\n\n      GLOBALS.INVALID_NAME_CHARS = '#@&^%$';\n\n      ess.init({\n        'First State': {\n          content: [{\n            type: 'text',\n            value: 'First State Content'\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              ruleSpecs: [{\n                dest: 'Second State'\n              }]\n            }]\n          },\n          param_changes: []\n        },\n        'Second State': {\n          content: [{\n            type: 'text',\n            value: 'Second State Content'\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              ruleSpecs: [{\n                dest: 'Second State'\n              }]\n            }]\n          },\n          param_changes: []\n        },\n        'Third State': {\n          content: [{\n            type: 'text',\n            value: 'This is some content.'\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              ruleSpecs: [{\n                dest: 'Second State'\n              }]\n            }]\n          },\n          param_changes: [{\n            name: 'comparison',\n            generator_id: 'Copier',\n            customization_args: {\n              value: 'something clever',\n              parse_with_jinja: false\n            }\n          }]\n        }\n      });\n\n      scope.getContent = function(contentString) {\n        return [{\n          type: 'text',\n          value: contentString\n        }];\n      };\n\n      ctrl = $controller('StateEditor', {\n        $scope: scope,\n        editorContextService: ecs,\n        changeListService: cls,\n        explorationStatesService: ess,\n        editabilityService: {\n          isEditable: function() {\n            return true;\n          }\n        },\n        INTERACTION_SPECS: IS\n      });\n    }));\n\n    it('should initialize the state name and related properties', function() {\n      ecs.setActiveStateName('Third State');\n      scope.initStateEditor();\n      expect(scope.contentEditorIsOpen).toBe(false);\n      expect(scope.content[0].value).toEqual('This is some content.');\n    });\n\n    it('should correctly handle no-op edits', function() {\n      ecs.setActiveStateName('First State');\n      scope.initStateEditor();\n      expect(scope.contentEditorIsOpen).toBe(false);\n      expect(scope.content).toEqual(scope.getContent('First State Content'));\n      scope.openStateContentEditor();\n      expect(scope.contentEditorIsOpen).toBe(true);\n      scope.content = scope.getContent('First State Content');\n      scope.saveTextContent();\n\n      expect(scope.contentEditorIsOpen).toBe(false);\n      expect(cls.getChangeList()).toEqual([]);\n    });\n\n    it('should check that content edits are saved correctly',\n       function() {\n      ecs.setActiveStateName('Third State');\n      expect(cls.getChangeList()).toEqual([]);\n      scope.openStateContentEditor();\n      scope.content = scope.getContent('babababa');\n      scope.saveTextContent();\n      expect(cls.getChangeList().length).toBe(1);\n      expect(cls.getChangeList()[0].new_value[0].value).toEqual('babababa');\n      expect(cls.getChangeList()[0].old_value[0].value).toEqual(\n        'This is some content.');\n\n      scope.openStateContentEditor();\n      scope.content = scope.getContent(\n        'And now for something completely different.'\n      );\n      scope.saveTextContent();\n      expect(cls.getChangeList().length).toBe(2);\n      expect(cls.getChangeList()[1].new_value[0].value)\n        .toEqual('And now for something completely different.');\n      expect(cls.getChangeList()[1].old_value[0].value).toEqual('babababa');\n    });\n\n    it('should not save any changes to content when an edit is cancelled',\n       function() {\n      ecs.setActiveStateName('Third State');\n      scope.initStateEditor();\n      var contentBeforeEdit = angular.copy(scope.content);\n      scope.content = scope.getContent('Test Content');\n      scope.cancelEdit();\n      expect(scope.contentEditorIsOpen).toBe(false);\n      expect(scope.content).toEqual(contentBeforeEdit);\n    });\n  });\n\n  describe('TrainingDataService', function() {\n    var $httpBackend;\n    var scope, siis, ecs, cls, rs, tds, ess, IS, CLASSIFIER_RULESPEC_STR;\n    var mockExplorationData;\n\n    beforeEach(module('oppia', GLOBALS.TRANSLATOR_PROVIDER_FOR_TESTS));\n\n    beforeEach(function() {\n      module('oppia');\n      // Set a global value for INTERACTION_SPECS that will be used by all the\n      // descendant dependencies.\n      module(function($provide) {\n        $provide.constant('INTERACTION_SPECS', {\n          TextInput: {\n            display_mode: 'inline',\n            is_terminal: false\n          }\n        });\n      });\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($rootScope, $controller, $injector) {\n      scope = $rootScope.$new();\n      $httpBackend = $injector.get('$httpBackend');\n      siis = $injector.get('stateInteractionIdService');\n      ecs = $injector.get('editorContextService');\n      cls = $injector.get('changeListService');\n      ess = $injector.get('explorationStatesService');\n      rs = $injector.get('responsesService');\n      tds = $injector.get('trainingDataService');\n      IS = $injector.get('INTERACTION_SPECS');\n      CLASSIFIER_RULESPEC_STR = $injector.get('CLASSIFIER_RULESPEC_STR');\n\n      // Set the currently loaded interaction ID.\n      siis.savedMemento = 'TextInput';\n\n      ess.init({\n        State: {\n          content: [{\n            type: 'text',\n            value: 'State Content'\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              rule_specs: [{\n                rule_type: 'Contains',\n                inputs: {\n                  x: 'Test'\n                }\n              }],\n              outcome: {\n                feedback: 'Feedback',\n                dest: 'State'\n              }\n            }],\n            default_outcome: {\n              feedback: 'Default',\n              dest: 'State'\n            },\n            confirmed_unclassified_answers: []\n          },\n          param_changes: []\n        }\n      });\n\n      var state = ess.getState('State');\n\n      rs.init({\n        answerGroups: state.interaction.answer_groups,\n        defaultOutcome: state.interaction.default_outcome,\n        confirmedUnclassifiedAnswers: (\n          state.interaction.confirmed_unclassified_answers)\n      });\n\n      ecs.setActiveStateName('State');\n\n      $httpBackend.when('GET', '/createhandler/training_data/0/State').respond({\n        unhandled_answers: [{\n          value: 'answer1',\n          count: 2\n        }, {\n          value: 'answer2',\n          count: 1\n        }]\n      });\n    }));\n\n    afterEach(function() {\n      $httpBackend.verifyNoOutstandingExpectation();\n      $httpBackend.verifyNoOutstandingRequest();\n    });\n\n    it('should call a backend handler to initialize training data', function() {\n      // Answers should be in the order sent from the backend.\n      $httpBackend.expectGET('/createhandler/training_data/0/State');\n      tds.initializeTrainingData('0', 'State');\n      $httpBackend.flush();\n      expect(tds.getTrainingDataAnswers()).toEqual(['answer1', 'answer2']);\n      expect(tds.getTrainingDataCounts()).toEqual([2, 1]);\n\n      // Ensure it handles receiving no unhandled answers correctly.\n      $httpBackend.expect(\n        'GET', '/createhandler/training_data/0/State').respond({\n          unhandled_answers: []\n        });\n\n      tds.initializeTrainingData('0', 'State');\n      $httpBackend.flush();\n      expect(tds.getTrainingDataAnswers()).toEqual([]);\n      expect(tds.getTrainingDataCounts()).toEqual([]);\n    });\n\n    it('should be able to train answer groups and the default response',\n        function() {\n      // Training the first answer of a group should add a new classifier.\n      tds.trainAnswerGroup(0, 'text answer');\n      var state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n\n      // Training a second answer to the same group should append the answer to\n      // the training data.\n      tds.trainAnswerGroup(0, 'second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer', 'second answer']\n        }\n      });\n\n      // Training the default response should add information to the confirmed\n      // unclassified answers.\n      tds.trainDefaultResponse('third answer');\n      state = ess.getState('State');\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'third answer'\n      ]);\n    });\n\n    it('should be able to retrain answers between answer groups and the ' +\n        'default outcome', function() {\n      // Retraining an answer from the answer group to the default outcome\n      // should remove it from the first, then add it to the second.\n      tds.trainAnswerGroup(0, 'text answer');\n      tds.trainAnswerGroup(0, 'second answer');\n      tds.trainDefaultResponse('third answer');\n\n      // Verify initial state.\n      var state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer', 'second answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'third answer'\n      ]);\n\n      // Try to retrain the second answer (answer group -> default response).\n      tds.trainDefaultResponse('second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'third answer', 'second answer'\n      ]);\n\n      // Try to retrain the third answer (default response -> answer group).\n      tds.trainAnswerGroup(0, 'third answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer', 'third answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'second answer'\n      ]);\n    });\n\n    it('should properly clear the default answer and remove a classifier ' +\n        'when it is not the last rule left in a group', function() {\n      tds.trainAnswerGroup(0, 'text answer');\n      tds.trainDefaultResponse('second answer');\n\n      // Verify initial state.\n      var state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'second answer'\n      ]);\n\n      // Ensure emptying the default unclassified answers is handled properly.\n      tds.trainAnswerGroup(0, 'second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer', 'second answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([]);\n\n      // Ensure emptying the answer group's classifier properly deletes the rule\n      // since there is another rule in the group.\n      tds.trainDefaultResponse('second answer');\n      tds.trainDefaultResponse('text answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs).toEqual([{\n        rule_type: 'Contains',\n        inputs: {\n          x: 'Test'\n        }\n      }]);\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'second answer', 'text answer'\n      ]);\n\n      // Training the answer group should add the classifier back.\n      tds.trainAnswerGroup(0, 'second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs).toEqual([{\n          rule_type: 'Contains',\n          inputs: {\n            x: 'Test'\n          }\n        }, {\n          rule_type: CLASSIFIER_RULESPEC_STR,\n          inputs: {\n            training_data: ['second answer']\n          }\n        }\n      ]);\n\n      // Removing the the 'contains' rule from the group and then removing the\n      // training data should not remove the classifier.\n      state.interaction.answer_groups[0].ruleSpecs.splice(0, 1);\n      ess.setState('State', state);\n      rs.init({\n        answerGroups: state.interaction.answer_groups,\n        defaultOutcome: state.interaction.default_outcome,\n        confirmedUnclassifiedAnswers: (\n          state.interaction.confirmed_unclassified_answers)\n      });\n\n      tds.trainDefaultResponse('second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs).toEqual([{\n          rule_type: CLASSIFIER_RULESPEC_STR,\n          inputs: {\n            training_data: []\n          }\n        }\n      ]);\n    });\n\n    it('should not be able to train duplicated answers', function() {\n      tds.trainAnswerGroup(0, 'text answer');\n      tds.trainDefaultResponse('second answer');\n\n      // Verify initial state.\n      var state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n      expect(state.interaction.confirmed_unclassified_answers).toEqual([\n        'second answer'\n      ]);\n\n      // Training a duplicate answer for the answer group should change nothing.\n      tds.trainAnswerGroup(0, 'text answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n\n      // Training a duplicate answer for the default response should change\n      // nothing.\n      tds.trainDefaultResponse('second answer');\n      state = ess.getState('State');\n      expect(state.interaction.answer_groups[0].ruleSpecs[1]).toEqual({\n        rule_type: CLASSIFIER_RULESPEC_STR,\n        inputs: {\n          training_data: ['text answer']\n        }\n      });\n    });\n\n    it('should remove unresolved answers after training', function() {\n      tds.initializeTrainingData('0', 'State');\n      $httpBackend.flush();\n\n      // Training an answer group should remove an unresolved answer.\n      tds.trainAnswerGroup(0, 'answer1');\n      expect(tds.getTrainingDataAnswers()).toEqual(['answer2']);\n      expect(tds.getTrainingDataCounts()).toEqual([1]);\n\n      // Training the default response should also remove an answer.\n      tds.trainDefaultResponse('answer2');\n      expect(tds.getTrainingDataAnswers()).toEqual([]);\n      expect(tds.getTrainingDataCounts()).toEqual([]);\n    });\n\n    it('should get all potential outcomes of an interaction', function() {\n      // First the answer group's outcome is listed, then the default.\n      expect(tds.getAllPotentialOutcomes(ess.getState('State'))).toEqual([{\n          feedback: 'Feedback',\n          dest: 'State'\n        }, {\n          feedback: 'Default',\n          dest: 'State'\n        }]);\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/StateInteractionSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the controller of 'State Interactions'.\n */\n\ndescribe('State Interaction controller', function() {\n  describe('StateInteraction', function() {\n    beforeEach(function() {\n      module('oppia');\n      // Set a global value for INTERACTION_SPECS that will be used by all the\n      // descendant dependencies.\n      module(function($provide) {\n        $provide.constant('INTERACTION_SPECS', {\n          TextInput: {\n            display_mode: 'inline',\n            is_terminal: false\n          },\n          TerminalInteraction: {\n            display_mode: 'inline',\n            is_terminal: true\n          }\n        });\n      });\n    });\n\n    var scope, ecs, cls, ess, siis, scas, idc, IS;\n    var $httpBackend;\n    var mockExplorationData;\n\n    beforeEach(function() {\n      mockExplorationData = {\n        explorationId: 0,\n        autosaveChangeList: function() {}\n      };\n      module(function($provide) {\n        $provide.value('explorationData', mockExplorationData);\n      });\n      spyOn(mockExplorationData, 'autosaveChangeList');\n    });\n\n    beforeEach(inject(function($rootScope, $controller, $injector) {\n      scope = $rootScope.$new();\n      ecs = $injector.get('editorContextService');\n      cls = $injector.get('changeListService');\n      ess = $injector.get('explorationStatesService');\n      siis = $injector.get('stateInteractionIdService');\n      scas = $injector.get('stateCustomizationArgsService');\n      idc = $injector.get('interactionDetailsCache');\n      IS = $injector.get('INTERACTION_SPECS');\n      $httpBackend = $injector.get('$httpBackend');\n      scope.stateInteractionIdService = siis;\n      scope.stateCustomizationArgsService = scas;\n      scope.interactionDetailsCache = idc;\n\n      ess.init({\n        'First State': {\n          content: [{\n            type: 'text',\n            value: 'First State Content'\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              ruleSpecs: [{\n                dest: 'End State'\n              }]\n            }]\n          },\n          param_changes: []\n        },\n        'End State': {\n          content: [{\n            type: 'text',\n            value: ''\n          }],\n          interaction: {\n            id: 'TextInput',\n            answer_groups: [{\n              ruleSpecs: [{\n                dest: 'End State'\n              }]\n            }]\n          },\n          param_changes: []\n        }\n      });\n\n      var stateEditorCtrl = $controller('StateEditor', {\n        $scope: scope,\n        editorContextService: ecs,\n        changeListService: cls,\n        explorationStatesService: ess,\n        editabilityService: {\n          isEditable: function() {\n            return true;\n          }\n        },\n        INTERACTION_SPECS: IS\n      });\n\n      var interactionCtrl = $controller('StateInteraction', {\n        $scope: scope,\n        editorContextService: ecs,\n        changeListService: cls,\n        explorationStatesService: ess,\n        editabilityService: {\n          isEditable: function() {\n            return true;\n          }\n        },\n        stateInteractionIdService: siis,\n        stateCustomizationArgsService: scas,\n        interactionDetailsCache: idc,\n        INTERACTION_SPECS: IS\n      });\n    }));\n\n    it('should keep non-empty content when setting a terminal interaction',\n        function() {\n      ecs.setActiveStateName('First State');\n      scope.initStateEditor();\n\n      var state = ess.getState('First State');\n      siis.init(\n        'First State', state.interaction.id, state.interaction, 'widget_id');\n      scas.init(\n        'First State', state.interaction.customization_args,\n        state.interaction, 'widget_customization_args');\n\n      siis.displayed = 'TerminalInteraction';\n      scope.onCustomizationModalSavePostHook();\n\n      expect(ess.getState('First State').content[0].value).toEqual(\n        'First State Content');\n      expect(ess.getState('First State').interaction.id).toEqual(\n        'TerminalInteraction');\n    });\n\n    it('should change to default text when adding a terminal interaction',\n       function() {\n      ecs.setActiveStateName('End State');\n      scope.initStateEditor();\n\n      var state = ess.getState('End State');\n      siis.init(\n        'End State', state.interaction.id, state.interaction, 'widget_id');\n      scas.init(\n        'End State', state.interaction.customization_args,\n        state.interaction, 'widget_customization_args');\n\n      siis.displayed = 'TerminalInteraction';\n      scope.onCustomizationModalSavePostHook();\n\n      expect(state.content[0].value).toEqual('');\n      expect(ess.getState('End State').content[0].value).toEqual(\n        'Congratulations, you have finished!');\n      expect(ess.getState('End State').interaction.id).toEqual(\n        'TerminalInteraction');\n    });\n\n    it('should not default text when adding a non-terminal interaction',\n        function() {\n      ecs.setActiveStateName('End State');\n      scope.initStateEditor();\n\n      var state = ess.getState('End State');\n      siis.init(\n        'End State', state.interaction.id, state.interaction, 'widget_id');\n      scas.init(\n        'End State', state.interaction.customization_args,\n        state.interaction, 'widget_customization_args');\n\n      siis.displayed = 'TextInput';\n      scope.onCustomizationModalSavePostHook();\n\n      expect(state.content[0].value).toEqual('');\n      expect(ess.getState('End State').content[0].value).toEqual('');\n      expect(ess.getState('End State').interaction.id).toEqual('TextInput');\n    });\n  });\n});\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/StateParameterChanges.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controllers for the state parameter changes section\n * of the editor sidebar.\n */\n\noppia.controller('StateParamChangesEditor', [\n  '$scope', 'editorContextService', 'stateParamChangesService',\n  function($scope, editorContextService, stateParamChangesService) {\n    $scope.stateParamChangesService = stateParamChangesService;\n\n    $scope.$on('stateEditorInitialized', function(evt, stateData) {\n      stateParamChangesService.init(\n        editorContextService.getActiveStateName(), stateData.paramChanges);\n    });\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/StateResponses.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controllers, services and filters for responses corresponding\n * to a state's interaction and answer groups.\n */\n\n// A state-specific cache for interaction handlers. It stores handlers\n// corresponding to an interaction id so that they can be restored if the\n// interaction is changed back while the user is still in this state. This\n// cache should be reset each time the state editor is initialized.\noppia.factory('answerGroupsCache', [function() {\n  var _cache = {};\n  return {\n    reset: function() {\n      _cache = {};\n    },\n    contains: function(interactionId) {\n      return _cache.hasOwnProperty(interactionId);\n    },\n    set: function(interactionId, answerGroups) {\n      _cache[interactionId] = angular.copy(answerGroups);\n    },\n    get: function(interactionId) {\n      if (!_cache.hasOwnProperty(interactionId)) {\n        return null;\n      }\n      return angular.copy(_cache[interactionId]);\n    }\n  };\n}]);\n\noppia.factory('responsesService', [\n  '$rootScope', 'stateInteractionIdService', 'INTERACTION_SPECS',\n  'answerGroupsCache', 'editorContextService', 'changeListService',\n  'explorationStatesService', 'graphDataService',\n  function(\n      $rootScope, stateInteractionIdService, INTERACTION_SPECS,\n      answerGroupsCache, editorContextService, changeListService,\n      explorationStatesService, graphDataService) {\n    var _answerGroupsMemento = null;\n    var _defaultOutcomeMemento = null;\n    var _confirmedUnclassifiedAnswersMemento = null;\n    // Represents the current selected answer group, starting at index 0. If the\n    // index equal to the number of answer groups (answerGroups.length), then it\n    // is referring to the default outcome.\n    var _activeAnswerGroupIndex = null;\n    var _activeRuleIndex = -1;\n    var _answerGroups = null;\n    var _defaultOutcome = null;\n    var _confirmedUnclassifiedAnswers = null;\n    var _answerChoices = null;\n\n    var _saveAnswerGroups = function(newAnswerGroups) {\n      var oldAnswerGroups = _answerGroupsMemento;\n      if (newAnswerGroups && oldAnswerGroups &&\n          !angular.equals(newAnswerGroups, oldAnswerGroups)) {\n        _answerGroups = newAnswerGroups;\n        $rootScope.$broadcast('answerGroupChanged');\n\n        explorationStatesService.saveInteractionAnswerGroups(\n          editorContextService.getActiveStateName(),\n          angular.copy(newAnswerGroups));\n\n        graphDataService.recompute();\n        _answerGroupsMemento = angular.copy(newAnswerGroups);\n      }\n    };\n\n    var _updateAnswerGroup = function(index, updates) {\n      var answerGroup = _answerGroups[index];\n      if (updates.rules) {\n        answerGroup.ruleSpecs = updates.rules;\n      }\n      if (updates.feedback) {\n        answerGroup.outcome.feedback = updates.feedback;\n      }\n      if (updates.dest) {\n        answerGroup.outcome.dest = updates.dest;\n      }\n      _saveAnswerGroups(_answerGroups);\n    };\n\n    var _saveDefaultOutcome = function(newDefaultOutcome) {\n      var oldDefaultOutcome = _defaultOutcomeMemento;\n      if (!angular.equals(newDefaultOutcome, oldDefaultOutcome)) {\n        _defaultOutcome = newDefaultOutcome;\n\n        explorationStatesService.saveInteractionDefaultOutcome(\n          editorContextService.getActiveStateName(),\n          angular.copy(newDefaultOutcome));\n\n        graphDataService.recompute();\n        _defaultOutcomeMemento = angular.copy(newDefaultOutcome);\n      }\n    };\n\n    var _saveConfirmedUnclassifiedAnswers = function(\n        newConfirmedUnclassifiedAnswers) {\n      var oldConfirmedUnclassifiedAnswers = (\n        _confirmedUnclassifiedAnswersMemento);\n      if (!angular.equals(\n          newConfirmedUnclassifiedAnswers, oldConfirmedUnclassifiedAnswers)) {\n        _confirmedUnclassifiedAnswers = newConfirmedUnclassifiedAnswers;\n\n        explorationStatesService.saveConfirmedUnclassifiedAnswers(\n          editorContextService.getActiveStateName(),\n          angular.copy(newConfirmedUnclassifiedAnswers));\n\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          newConfirmedUnclassifiedAnswers);\n      }\n    };\n\n    return {\n      // The 'data' arg is a list of interaction handlers for the\n      // currently-active state.\n      init: function(data) {\n        answerGroupsCache.reset();\n\n        _answerGroups = angular.copy(data.answerGroups);\n        _defaultOutcome = angular.copy(data.defaultOutcome);\n        _confirmedUnclassifiedAnswers = angular.copy(\n          data.confirmedUnclassifiedAnswers);\n        answerGroupsCache.set(\n          stateInteractionIdService.savedMemento, _answerGroups);\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n      },\n      onInteractionIdChanged: function(newInteractionId, callback) {\n        if (answerGroupsCache.contains(newInteractionId)) {\n          _answerGroups = answerGroupsCache.get(newInteractionId);\n        } else {\n          // Preserve the default outcome unless the interaction is terminal.\n          // Recreate the default outcome if switching away from a terminal\n          // interaction.\n          _answerGroups = [];\n          _confirmedUnclassifiedAnswers = [];\n          if (newInteractionId) {\n            if (INTERACTION_SPECS[newInteractionId].is_terminal) {\n              _defaultOutcome = null;\n            } else if (!_defaultOutcome) {\n              // TODO(bhenning): There should be a service for creating new\n              // instances of all aspects of the states schema, such as a new\n              // state, new answer group, or new outcome. This avoids tightly\n              // coupling code scattered throughout the frontend with the states\n              // schema.\n              _defaultOutcome = {\n                feedback: [],\n                dest: editorContextService.getActiveStateName(),\n                param_changes: []\n              };\n            }\n          }\n        }\n\n        _saveAnswerGroups(_answerGroups);\n        _saveDefaultOutcome(_defaultOutcome);\n        _saveConfirmedUnclassifiedAnswers(_confirmedUnclassifiedAnswers);\n        answerGroupsCache.set(newInteractionId, _answerGroups);\n\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _defaultOutcomeMemento = angular.copy(_defaultOutcome);\n        _confirmedUnclassifiedAnswersMemento = angular.copy(\n          _confirmedUnclassifiedAnswers);\n        _activeAnswerGroupIndex = -1;\n        _activeRuleIndex = 0;\n\n        if (callback) {\n          callback();\n        }\n      },\n      getActiveAnswerGroupIndex: function() {\n        return _activeAnswerGroupIndex;\n      },\n      changeActiveAnswerGroupIndex: function(newIndex) {\n        // If the current group is being clicked on again, close it.\n        if (newIndex === _activeAnswerGroupIndex) {\n          _activeAnswerGroupIndex = -1;\n        } else {\n          _activeAnswerGroupIndex = newIndex;\n        }\n\n        _activeRuleIndex = -1;\n      },\n      getActiveRuleIndex: function() {\n        return _activeRuleIndex;\n      },\n      changeActiveRuleIndex: function(newIndex) {\n        _activeRuleIndex = newIndex;\n      },\n      getAnswerChoices: function() {\n        return angular.copy(_answerChoices);\n      },\n      updateAnswerGroup: function(index, updates) {\n        _updateAnswerGroup(index, updates);\n      },\n      deleteAnswerGroup: function(index) {\n        _answerGroupsMemento = angular.copy(_answerGroups);\n        _answerGroups.splice(index, 1);\n        _activeAnswerGroupIndex = -1;\n        _saveAnswerGroups(_answerGroups);\n      },\n      updateActiveAnswerGroup: function(updates) {\n        _updateAnswerGroup(_activeAnswerGroupIndex, updates);\n      },\n      updateDefaultOutcome: function(updates) {\n        var outcome = _defaultOutcome;\n        if (updates.feedback) {\n          outcome.feedback = updates.feedback;\n        }\n        if (updates.dest) {\n          outcome.dest = updates.dest;\n        }\n        _saveDefaultOutcome(outcome);\n      },\n      updateConfirmedUnclassifiedAnswers: function(\n          confirmedUnclassifiedAnswers) {\n        _saveConfirmedUnclassifiedAnswers(confirmedUnclassifiedAnswers);\n      },\n      // Updates answer choices when the interaction requires it -- for\n      // example, the rules for multiple choice need to refer to the multiple\n      // choice interaction's customization arguments.\n      updateAnswerChoices: function(newAnswerChoices) {\n        var oldAnswerChoices = angular.copy(_answerChoices);\n        _answerChoices = newAnswerChoices;\n\n        // If the interaction is ItemSelectionInput, update the answer groups\n        // to refer to the new answer options.\n        if (stateInteractionIdService.savedMemento === 'ItemSelectionInput' &&\n            oldAnswerChoices) {\n          // We use an approximate algorithm here. If the length of the answer\n          // choices array remains the same, and no choice is replicated at\n          // different indices in both arrays (which indicates that some\n          // moving-around happened), then replace any old choice with its\n          // corresponding new choice. Otherwise, we simply remove any answer\n          // that has not been changed. This is not foolproof, but it should\n          // cover most cases.\n          //\n          // TODO(sll): Find a way to make this fully deterministic. This can\n          // probably only occur after we support custom editors for\n          // interactions.\n          var onlyEditsHappened = false;\n          if (oldAnswerChoices.length === newAnswerChoices.length) {\n            onlyEditsHappened = true;\n\n            // Check that no answer choice appears to have been moved.\n            var numAnswerChoices = oldAnswerChoices.length;\n            for (var i = 0; i < numAnswerChoices; i++) {\n              for (var j = 0; j < numAnswerChoices; j++) {\n                if (i !== j &&\n                    oldAnswerChoices[i].val === newAnswerChoices[j].val) {\n                  onlyEditsHappened = false;\n                  break;\n                }\n              }\n            }\n          }\n\n          var oldChoiceStrings = oldAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n          var newChoiceStrings = newAnswerChoices.map(function(choice) {\n            return choice.val;\n          });\n\n          _answerGroups.forEach(function(answerGroup, answerGroupIndex) {\n            var newRules = angular.copy(answerGroup.ruleSpecs);\n            newRules.forEach(function(rule) {\n              for (var key in rule.inputs) {\n                var newInputValue = [];\n                rule.inputs[key].forEach(function(item) {\n                  var newIndex = newChoiceStrings.indexOf(item);\n                  if (newIndex !== -1) {\n                    newInputValue.push(item);\n                  } else if (onlyEditsHappened) {\n                    var oldIndex = oldChoiceStrings.indexOf(item);\n                    if (oldIndex !== -1) {\n                      newInputValue.push(newAnswerChoices[oldIndex].val);\n                    }\n                  }\n                });\n                rule.inputs[key] = newInputValue;\n              };\n            });\n\n            _updateAnswerGroup(answerGroupIndex, {\n              rules: newRules\n            });\n          });\n        }\n      },\n      getAnswerGroups: function() {\n        return angular.copy(_answerGroups);\n      },\n      getAnswerGroup: function(index) {\n        return angular.copy(_answerGroups[index]);\n      },\n      getAnswerGroupCount: function() {\n        return _answerGroups.length;\n      },\n      getDefaultOutcome: function() {\n        return angular.copy(_defaultOutcome);\n      },\n      getConfirmedUnclassifiedAnswers: function() {\n        return angular.copy(_confirmedUnclassifiedAnswers);\n      },\n      // This registers the change to the handlers in the list of changes, and\n      // also updates the states object in explorationStatesService.\n      save: function(newAnswerGroups, defaultOutcome) {\n        _saveAnswerGroups(newAnswerGroups);\n        _saveDefaultOutcome(defaultOutcome);\n      }\n    };\n  }\n]);\n\noppia.controller('StateResponses', [\n  '$scope', '$rootScope', '$modal', '$filter', 'stateInteractionIdService',\n  'editorContextService', 'alertsService', 'responsesService', 'routerService',\n  'explorationContextService', 'trainingDataService',\n  'stateCustomizationArgsService', 'PLACEHOLDER_OUTCOME_DEST',\n  'INTERACTION_SPECS', 'UrlInterpolationService', 'AnswerGroupObjectFactory',\n  function(\n      $scope, $rootScope, $modal, $filter, stateInteractionIdService,\n      editorContextService, alertsService, responsesService, routerService,\n      explorationContextService, trainingDataService,\n      stateCustomizationArgsService, PLACEHOLDER_OUTCOME_DEST,\n      INTERACTION_SPECS, UrlInterpolationService, AnswerGroupObjectFactory) {\n    $scope.editorContextService = editorContextService;\n\n    $scope.dragDotsImgUrl = UrlInterpolationService.getStaticImageUrl(\n      '/general/drag_dots.png');\n\n    var _initializeTrainingData = function() {\n      var explorationId = explorationContextService.getExplorationId();\n      var currentStateName = editorContextService.getActiveStateName();\n      trainingDataService.initializeTrainingData(\n        explorationId, currentStateName);\n    };\n\n    $scope.suppressDefaultAnswerGroupWarnings = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      var answerGroups = responsesService.getAnswerGroups();\n      // This array contains the text of each of the possible answers\n      // for the interaction.\n      var answerChoices = [];\n      var customizationArgs = stateCustomizationArgsService.savedMemento;\n      var handledAnswersArray = [];\n\n      if (interactionId === 'MultipleChoiceInput') {\n        var numChoices = $scope.getAnswerChoices().length;\n        var choiceIndices = [];\n        // Collect all answers which have been handled by at least one\n        // answer group.\n        for (var i = 0; i < answerGroups.length; i++) {\n          for (var j = 0; j < answerGroups[i].ruleSpecs.length; j++) {\n            handledAnswersArray.push(answerGroups[i].ruleSpecs[j].inputs.x);\n          }\n        }\n        for (var i = 0; i < numChoices; i++) {\n          choiceIndices.push(i);\n        }\n        // We only suppress the default warning if each choice index has\n        // been handled by at least one answer group.\n        return choiceIndices.every(function(choiceIndex) {\n          return handledAnswersArray.indexOf(choiceIndex) !== -1;\n        });\n      } else if (interactionId === 'ItemSelectionInput') {\n        var maxSelectionCount = (\n            customizationArgs.maxAllowableSelectionCount.value);\n        if (maxSelectionCount === 1) {\n          var numChoices = $scope.getAnswerChoices().length;\n          // This array contains a list of booleans, one for each answer choice.\n          // Each boolean is true if the corresponding answer has been\n          // covered by at least one rule, and false otherwise.\n          handledAnswersArray = [];\n          for (var i = 0; i < numChoices; i++) {\n            handledAnswersArray.push(false);\n            answerChoices.push($scope.getAnswerChoices()[i].val);\n          }\n\n          var answerChoiceToIndex = {};\n          answerChoices.forEach(function(answerChoice, choiceIndex) {\n            answerChoiceToIndex[answerChoice] = choiceIndex;\n          });\n\n          answerGroups.forEach(function(answerGroup) {\n            var ruleSpecs = answerGroup.ruleSpecs;\n            ruleSpecs.forEach(function(ruleSpec) {\n              var ruleInputs = ruleSpec.inputs.x;\n              ruleInputs.forEach(function(ruleInput) {\n                var choiceIndex = answerChoiceToIndex[ruleInput];\n                if (ruleSpec.rule_type === 'Equals' ||\n                    ruleSpec.rule_type === 'ContainsAtLeastOneOf') {\n                  handledAnswersArray[choiceIndex] = true;\n                } else if (ruleSpec.rule_type ===\n                  'DoesNotContainAtLeastOneOf') {\n                  for (var i = 0; i < handledAnswersArray.length; i++) {\n                    if (i !== choiceIndex) {\n                      handledAnswersArray[i] = true;\n                    }\n                  }\n                }\n              });\n            });\n          });\n\n          var areAllChoicesCovered = handledAnswersArray.every(\n            function(handledAnswer) {\n              return handledAnswer;\n            });\n          // We only suppress the default warning if each choice text has\n          // been handled by at least one answer group, based on rule type.\n          return areAllChoicesCovered;\n        }\n      }\n    };\n\n    $scope.isSelfLoopWithNoFeedback = function(outcome) {\n      var isSelfLoop = function(outcome) {\n        return (\n          outcome &&\n          outcome.dest === editorContextService.getActiveStateName());\n      };\n      if (!outcome) {\n        return false;\n      }\n      var hasFeedback = outcome.feedback.some(function(feedbackItem) {\n        return Boolean(feedbackItem);\n      });\n      return isSelfLoop(outcome) && !hasFeedback;\n    };\n\n    $scope.changeActiveAnswerGroupIndex = function(newIndex) {\n      $rootScope.$broadcast('externalSave');\n      responsesService.changeActiveAnswerGroupIndex(newIndex);\n      $scope.activeAnswerGroupIndex = (\n        responsesService.getActiveAnswerGroupIndex());\n    };\n\n    $scope.getCurrentInteractionId = function() {\n      return stateInteractionIdService.savedMemento;\n    };\n\n    $scope.isCurrentInteractionTrainable = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      return interactionId && INTERACTION_SPECS[interactionId].is_trainable;\n    };\n\n    $scope.isCreatingNewState = function(outcome) {\n      return outcome && outcome.dest === PLACEHOLDER_OUTCOME_DEST;\n    };\n\n    // This returns false if the current interaction ID is null.\n    $scope.isCurrentInteractionLinear = function() {\n      var interactionId = $scope.getCurrentInteractionId();\n      return interactionId && INTERACTION_SPECS[interactionId].is_linear;\n    };\n\n    $scope.isLinearWithNoFeedback = function(outcome) {\n      // Returns false if current interaction is linear and has no feedback\n      if (!outcome) {\n        return false;\n      }\n      var hasFeedback = outcome.feedback.some(function(feedbackItem) {\n        return Boolean(feedbackItem);\n      });\n      return $scope.isCurrentInteractionLinear() && !hasFeedback;\n    };\n\n    $scope.getOutcomeTooltip = function(outcome) {\n      // Outcome tooltip depends on whether feedback is displayed\n      if ($scope.isLinearWithNoFeedback(outcome)) {\n        return 'Please direct the learner to a different card.';\n      } else {\n        return 'Please give Oppia something useful to say,' +\n               ' or direct the learner to a different card.';\n      }\n    };\n\n    $scope.$on('initializeAnswerGroups', function(evt, data) {\n      responsesService.init(data);\n      $scope.answerGroups = responsesService.getAnswerGroups();\n      $scope.defaultOutcome = responsesService.getDefaultOutcome();\n\n      // If the creator selects an interaction which has only one possible\n      // answer, automatically expand the default response. Otherwise, default\n      // to having no responses initially selected.\n      if ($scope.isCurrentInteractionLinear()) {\n        responsesService.changeActiveAnswerGroupIndex(0);\n      }\n\n      // Initialize training data for these answer groups.\n      _initializeTrainingData();\n\n      $scope.activeAnswerGroupIndex = (\n        responsesService.getActiveAnswerGroupIndex());\n      $rootScope.$broadcast('externalSave');\n    });\n\n    $scope.$on('onInteractionIdChanged', function(evt, newInteractionId) {\n      $rootScope.$broadcast('externalSave');\n      responsesService.onInteractionIdChanged(newInteractionId, function() {\n        $scope.answerGroups = responsesService.getAnswerGroups();\n        $scope.defaultOutcome = responsesService.getDefaultOutcome();\n\n        // Reinitialize training data if the interaction ID is changed.\n        _initializeTrainingData();\n\n        $scope.activeAnswerGroupIndex = (\n          responsesService.getActiveAnswerGroupIndex());\n      });\n\n      // Prompt the user to create a new response if it is not a linear or\n      // non-terminal interaction and if an actual interaction is specified\n      // (versus one being deleted).\n      if (newInteractionId &&\n          !INTERACTION_SPECS[newInteractionId].is_linear &&\n          !INTERACTION_SPECS[newInteractionId].is_terminal) {\n        // Open the training interface if the interaction is trainable,\n        // otherwise open the answer group modal.\n        if (GLOBALS.SHOW_TRAINABLE_UNRESOLVED_ANSWERS &&\n            $scope.isCurrentInteractionTrainable()) {\n          $scope.openTeachOppiaModal();\n        } else {\n          $scope.openAddAnswerGroupModal();\n        }\n      }\n    });\n\n    $scope.$on('answerGroupChanged', function() {\n      $scope.answerGroups = responsesService.getAnswerGroups();\n      $scope.defaultOutcome = responsesService.getDefaultOutcome();\n      $scope.activeAnswerGroupIndex = (\n        responsesService.getActiveAnswerGroupIndex());\n    });\n\n    $scope.$on('updateAnswerChoices', function(evt, newAnswerChoices) {\n      responsesService.updateAnswerChoices(newAnswerChoices);\n    });\n\n    $scope.openTeachOppiaModal = function() {\n      alertsService.clearWarnings();\n      $rootScope.$broadcast('externalSave');\n\n      $modal.open({\n        templateUrl: 'modals/teachOppia',\n        backdrop: true,\n        controller: [\n          '$scope', '$modalInstance', 'oppiaExplorationHtmlFormatterService',\n          'stateInteractionIdService', 'stateCustomizationArgsService',\n          'explorationContextService', 'editorContextService',\n          'explorationStatesService', 'trainingDataService',\n          'AnswerClassificationService', 'focusService', 'DEFAULT_RULE_NAME',\n          'CLASSIFIER_RULESPEC_STR',\n          function(\n              $scope, $modalInstance, oppiaExplorationHtmlFormatterService,\n              stateInteractionIdService, stateCustomizationArgsService,\n              explorationContextService, editorContextService,\n              explorationStatesService, trainingDataService,\n              AnswerClassificationService, focusService, DEFAULT_RULE_NAME,\n              CLASSIFIER_RULESPEC_STR) {\n            var _explorationId = explorationContextService.getExplorationId();\n            var _stateName = editorContextService.getActiveStateName();\n            var _state = explorationStatesService.getState(_stateName);\n\n            $scope.stateContent = _state.content[0].value;\n            $scope.inputTemplate = (\n              oppiaExplorationHtmlFormatterService.getInteractionHtml(\n                stateInteractionIdService.savedMemento,\n                stateCustomizationArgsService.savedMemento,\n                'testInteractionInput'));\n            $scope.answerTemplate = '';\n\n            $scope.trainingData = [];\n            $scope.trainingDataAnswer = '';\n            $scope.trainingDataFeedback = '';\n            $scope.trainingDataOutcomeDest = '';\n\n            // See the training panel directive in StateEditor for an\n            // explanation on the structure of this object.\n            $scope.classification = {\n              answerGroupIndex: 0,\n              newOutcome: null\n            };\n\n            focusService.setFocus('testInteractionInput');\n\n            $scope.finishTeaching = function(reopen) {\n              $modalInstance.close({\n                reopen: reopen\n              });\n            };\n\n            $scope.submitAnswer = function(answer) {\n              $scope.answerTemplate = (\n                oppiaExplorationHtmlFormatterService.getAnswerHtml(\n                  answer, stateInteractionIdService.savedMemento,\n                  stateCustomizationArgsService.savedMemento));\n\n              AnswerClassificationService.getMatchingClassificationResult(\n                _explorationId, _state, answer, true).then(\n                    function(classificationResult) {\n                  var feedback = 'Nothing';\n                  var dest = classificationResult.outcome.dest;\n                  if (classificationResult.outcome.feedback.length > 0) {\n                    feedback = classificationResult.outcome.feedback[0];\n                  }\n                  if (dest === _stateName) {\n                    dest = '<em>(try again)</em>';\n                  }\n                  $scope.trainingDataAnswer = answer;\n                  $scope.trainingDataFeedback = feedback;\n                  $scope.trainingDataOutcomeDest = dest;\n\n                  var answerGroupIndex = classificationResult.answerGroupIndex;\n                  var ruleSpecIndex = classificationResult.ruleSpecIndex;\n                  if (answerGroupIndex !==\n                        _state.interaction.answer_groups.length &&\n                      _state.interaction.answer_groups[\n                        answerGroupIndex].ruleSpecs[\n                          ruleSpecIndex].rule_type !==\n                            CLASSIFIER_RULESPEC_STR) {\n                    $scope.classification.answerGroupIndex = -1;\n                  } else {\n                    $scope.classification.answerGroupIndex = (\n                      classificationResult.answerGroupIndex);\n                  }\n                });\n            };\n          }]\n      }).result.then(function(result) {\n        // Check if the modal should be reopened right away.\n        if (result.reopen) {\n          $scope.openTeachOppiaModal();\n        }\n      });\n    };\n\n    $scope.openAddAnswerGroupModal = function() {\n      alertsService.clearWarnings();\n      $rootScope.$broadcast('externalSave');\n\n      $modal.open({\n        templateUrl: 'modals/addAnswerGroup',\n        // Clicking outside this modal should not dismiss it.\n        backdrop: 'static',\n        controller: [\n          '$scope', '$modalInstance', 'responsesService',\n          'editorContextService', 'editorFirstTimeEventsService',\n          function(\n              $scope, $modalInstance, responsesService,\n              editorContextService, editorFirstTimeEventsService) {\n            $scope.feedbackEditorIsOpen = false;\n            $scope.openFeedbackEditor = function() {\n              $scope.feedbackEditorIsOpen = true;\n            };\n            $scope.tmpRule = {\n              rule_type: null,\n              inputs: {}\n            };\n            $scope.tmpOutcome = {\n              dest: editorContextService.getActiveStateName(),\n              feedback: [''],\n              param_changes: []\n            };\n\n            $scope.isSelfLoopWithNoFeedback = function(tmpOutcome) {\n              var hasFeedback = false;\n              for (var i = 0; i < tmpOutcome.feedback.length; i++) {\n                if (tmpOutcome.feedback[i]) {\n                  hasFeedback = true;\n                  break;\n                }\n              }\n\n              return (\n                tmpOutcome.dest === editorContextService.getActiveStateName() &&\n                !hasFeedback);\n            };\n\n            $scope.addAnswerGroupForm = {};\n\n            $scope.saveResponse = function(reopen) {\n              $scope.$broadcast('saveOutcomeFeedbackDetails');\n              $scope.$broadcast('saveOutcomeDestDetails');\n\n              // If the feedback editor is never opened, replace the feedback\n              // with an empty array.\n              if ($scope.tmpOutcome.feedback.length === 1 &&\n                  $scope.tmpOutcome.feedback[0] === '') {\n                $scope.tmpOutcome.feedback = [];\n              }\n\n              editorFirstTimeEventsService.registerFirstSaveRuleEvent();\n\n              // Close the modal and save it afterwards.\n              $modalInstance.close({\n                tmpRule: angular.copy($scope.tmpRule),\n                tmpOutcome: angular.copy($scope.tmpOutcome),\n                reopen: reopen\n              });\n            };\n\n            $scope.cancel = function() {\n              $modalInstance.dismiss('cancel');\n              alertsService.clearWarnings();\n            };\n          }\n        ]\n      }).result.then(function(result) {\n        // Create a new answer group.\n        $scope.answerGroups.push(AnswerGroupObjectFactory.create(\n          [result.tmpRule], result.tmpOutcome));\n        responsesService.save($scope.answerGroups, $scope.defaultOutcome);\n        $scope.changeActiveAnswerGroupIndex($scope.answerGroups.length - 1);\n\n        // After saving it, check if the modal should be reopened right away.\n        if (result.reopen) {\n          $scope.openAddAnswerGroupModal();\n        }\n      });\n    };\n\n    // When the page is scrolled so that the top of the page is above the\n    // browser viewport, there are some bugs in the positioning of the helper.\n    // This is a bug in jQueryUI that has not been fixed yet. For more details,\n    // see http://stackoverflow.com/q/5791886\n    $scope.ANSWER_GROUP_LIST_SORTABLE_OPTIONS = {\n      axis: 'y',\n      cursor: 'move',\n      handle: '.oppia-rule-sort-handle',\n      items: '.oppia-sortable-rule-block',\n      revert: 100,\n      tolerance: 'pointer',\n      start: function(e, ui) {\n        $rootScope.$broadcast('externalSave');\n        $scope.changeActiveAnswerGroupIndex(-1);\n        ui.placeholder.height(ui.item.height());\n      },\n      stop: function() {\n        responsesService.save($scope.answerGroups, $scope.defaultOutcome);\n      }\n    };\n\n    $scope.deleteAnswerGroup = function(index, evt) {\n      // Prevent clicking on the delete button from also toggling the display\n      // state of the answer group.\n      evt.stopPropagation();\n\n      alertsService.clearWarnings();\n      $modal.open({\n        templateUrl: 'modals/deleteAnswerGroup',\n        backdrop: true,\n        controller: [\n          '$scope', '$modalInstance', function($scope, $modalInstance) {\n            $scope.reallyDelete = function() {\n              $modalInstance.close();\n            };\n\n            $scope.cancel = function() {\n              $modalInstance.dismiss('cancel');\n              alertsService.clearWarnings();\n            };\n          }\n        ]\n      }).result.then(function() {\n        responsesService.deleteAnswerGroup(index);\n      });\n    };\n\n    $scope.saveActiveAnswerGroupFeedback = function(updatedOutcome) {\n      responsesService.updateActiveAnswerGroup({\n        feedback: updatedOutcome.feedback\n      });\n    };\n\n    $scope.saveActiveAnswerGroupDest = function(updatedOutcome) {\n      responsesService.updateActiveAnswerGroup({\n        dest: updatedOutcome.dest\n      });\n    };\n\n    $scope.saveActiveAnswerGroupRules = function(updatedRules) {\n      responsesService.updateActiveAnswerGroup({\n        rules: updatedRules\n      });\n    };\n\n    $scope.saveDefaultOutcomeFeedback = function(updatedOutcome) {\n      responsesService.updateDefaultOutcome({\n        feedback: updatedOutcome.feedback\n      });\n    };\n\n    $scope.saveDefaultOutcomeDest = function(updatedOutcome) {\n      responsesService.updateDefaultOutcome({\n        dest: updatedOutcome.dest\n      });\n    };\n\n    $scope.getAnswerChoices = function() {\n      return responsesService.getAnswerChoices();\n    };\n\n    $scope.isOutcomeLooping = function(outcome) {\n      var activeStateName = editorContextService.getActiveStateName();\n      return outcome && (outcome.dest === activeStateName);\n    };\n\n    $scope.navigateToState = function(stateName) {\n      routerService.navigateToMainTab(stateName);\n    };\n  }\n]);\n\noppia.filter('summarizeAnswerGroup', [\n    '$filter', 'RULE_SUMMARY_WRAP_CHARACTER_COUNT',\n    function($filter, RULE_SUMMARY_WRAP_CHARACTER_COUNT) {\n  return function(answerGroup, interactionId, answerChoices, shortenRule) {\n    var summary = '';\n    var outcome = answerGroup.outcome;\n    var hasFeedback = outcome.feedback.length > 0 && outcome.feedback[0];\n\n    if (answerGroup.ruleSpecs) {\n      var firstRule = $filter('convertToPlainText')(\n        $filter('parameterizeRuleDescription')(\n          answerGroup.ruleSpecs[0], interactionId, answerChoices));\n      summary = 'Answer ' + firstRule;\n\n      if (hasFeedback && shortenRule) {\n        summary = $filter('wrapTextWithEllipsis')(\n          summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n      }\n      summary = '[' + summary + '] ';\n    }\n\n    if (hasFeedback) {\n      summary += $filter('convertToPlainText')(outcome.feedback[0]);\n    }\n    return summary;\n  };\n}]);\n\noppia.filter('summarizeDefaultOutcome', [\n  '$filter', 'INTERACTION_SPECS', 'RULE_SUMMARY_WRAP_CHARACTER_COUNT',\n  function($filter, INTERACTION_SPECS, RULE_SUMMARY_WRAP_CHARACTER_COUNT) {\n    return function(\n        defaultOutcome, interactionId, answerGroupCount, shortenRule) {\n      if (!defaultOutcome) {\n        return '';\n      }\n\n      var summary = '';\n      var feedback = defaultOutcome.feedback;\n      var hasFeedback = feedback.length > 0 && feedback[0];\n\n      if (interactionId && INTERACTION_SPECS[interactionId].is_linear) {\n        summary = INTERACTION_SPECS[interactionId].default_outcome_heading;\n      } else if (answerGroupCount > 0) {\n        summary = 'All other answers';\n      } else {\n        summary = 'All answers';\n      }\n\n      if (hasFeedback && shortenRule) {\n        summary = $filter('wrapTextWithEllipsis')(\n          summary, RULE_SUMMARY_WRAP_CHARACTER_COUNT);\n      }\n      summary = '[' + summary + '] ';\n\n      if (hasFeedback) {\n        summary += $filter('convertToPlainText')(defaultOutcome.feedback[0]);\n      }\n      return summary;\n    };\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/editor_tab.html",
      "content": "<div class=\"row\">\n  <div class=\"col-lg-8 col-md-8 col-sm-8\">\n    {% include 'pages/exploration_editor/editor_tab/state_editor.html' %}\n  </div>\n  <div class=\"col-lg-4 col-md-4 col-sm-4\">\n    <div class=\"oppia-editor-sidebar hidden-xs hidden-sm\">\n      {% include 'pages/exploration_editor/editor_tab/exploration_graph.html' %}\n      <div ng-show=\"areGadgetsEnabled()\">\n        {% include 'pages/exploration_editor/editor_tab/gadget_editor.html' %}\n      </div>\n    </div>\n  </div>\n  <attribution-guide></attribution-guide>\n</div>\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/editor_tab/state_editor_responses.html",
      "content": "<div ng-controller=\"StateResponses\">\n  <div class=\"oppia-editor-header\">\n    <strong>Learner's Answers and Oppia's Responses</strong>\n  </div>\n\n  <md-card class=\"oppia-editor-card-with-avatar\">\n    <div class=\"oppia-editor-card-body\">\n      <div ng-if=\"answerGroups.length > 0\">\n        <ul class=\"nav nav-stacked nav-pills\" role=\"tablist\" ui-sortable=\"ANSWER_GROUP_LIST_SORTABLE_OPTIONS\" ng-model=\"answerGroups\">\n          <!-- An HTML element marked ui-sortable should contain only one element,\n          and this element should have an ng-repeat defined on it. See the\n          ui-sortable documentation for more details. -->\n          <!-- Note that adding \"track by $index\" here seems to mess up the final\n          index in the stop() event handler. -->\n          <li ng-repeat=\"answerGroup in answerGroups\" ng-class=\"{'active': activeAnswerGroupIndex === $index}\" class=\"oppia-rule-block oppia-sortable-rule-block oppia-prevent-selection\" style=\"margin-top: 0;\">\n            <span class=\"oppia-rule-sort-handle\" ng-if=\"answerGroups.length > 1\" ng-mousedown=\"changeActiveAnswerGroupIndex(-1)\">\n              <img ng-if=\"editabilityService.isEditable()\" ng-src=\"<[dragDotsImgUrl]>\" width=\"10\">\n            </span>\n            <div class=\"oppia-rule-header-warning-placement\" ng-if=\"isSelfLoopWithNoFeedback(answerGroup.outcome)\" ng-click=\"changeActiveAnswerGroupIndex($index)\"\n                 tooltip=\"<[getOutcomeTooltip(answerGroup.outcome)]>\" tooltip-placement=\"bottom\">\n              <div class=\"oppia-rule-header-warning-style\" >\n                \n              </div>\n            </div>\n            <a ng-click=\"changeActiveAnswerGroupIndex($index)\" class=\"oppia-rule-tab protractor-test-response-tab\" ng-class=\"{'oppia-rule-tab-active': activeAnswerGroupIndex === $index}\">\n              <response-header index=\"$index\"\n                               summary=\"answerGroup | summarizeAnswerGroup : getCurrentInteractionId():getAnswerChoices():false\"\n                               short-summary=\"answerGroup | summarizeAnswerGroup : getCurrentInteractionId():getAnswerChoices():true\"\n                               is-active=\"$index === activeAnswerGroupIndex\"\n                               on-delete-fn=\"deleteAnswerGroup\"\n                               outcome=\"answerGroup.outcome\"\n                               num-rules=\"answerGroup.ruleSpecs.length\">\n              </response-header>\n            </a>\n\n            <div ng-if=\"activeAnswerGroupIndex === $index\">\n              <div class=\"oppia-editor-card-section\">\n                <div class=\"oppia-rule-body-container protractor-test-response-body-<[$index]>\">\n                  <answer-group-editor rules=\"answerGroup.ruleSpecs\"\n                                       outcome=\"answerGroup.outcome\"\n                                       on-save-answer-group-feedback=\"saveActiveAnswerGroupFeedback\"\n                                       on-save-answer-group-dest=\"saveActiveAnswerGroupDest\"\n                                       on-save-answer-group-rules=\"saveActiveAnswerGroupRules\"\n                                       is-editable=\"editabilityService.isEditable()\"\n                                       display-feedback=\"!isLinearWithNoFeedback(answerGroup.outcome)\"\n                                       class=\"protractor-test-response-body\">\n                  </answer-group-editor>\n                </div>\n              </div>\n            </div>\n          </li>\n        </ul>\n      </div>\n\n      <div>\n        <ul class=\"nav nav-stacked nav-pills\" role=\"tablist\">\n          <li ng-class=\"{'active': activeAnswerGroupIndex === answerGroups.length}\" class=\"oppia-rule-block\">\n            <div class=\"oppia-rule-header-warning-placement\" ng-if=\"isSelfLoopWithNoFeedback(defaultOutcome) && !suppressDefaultAnswerGroupWarnings()\" ng-click=\"changeActiveAnswerGroupIndex(answerGroups.length)\"\n                 tooltip=\"<[getOutcomeTooltip(defaultOutcome)]>\" tooltip-placement=\"bottom\">\n              <div class=\"oppia-rule-header-warning-style\" >\n                \n              </div>\n            </div>\n            <a ng-click=\"changeActiveAnswerGroupIndex(answerGroups.length)\" class=\"oppia-rule-tab oppia-default-rule-tab protractor-test-default-response-tab\" ng-class=\"{'oppia-rule-tab-active': activeAnswerGroupIndex == answerGroups.length}\">\n              <response-header index=\"$index\"\n                               is-active=\"$index === activeAnswerGroupIndex\"\n                               summary=\"defaultOutcome|summarizeDefaultOutcome:getCurrentInteractionId():answerGroups.length:false\"\n                               short-summary=\"defaultOutcome|summarizeDefaultOutcome:getCurrentInteractionId():answerGroups.length:true\"\n                               outcome=\"defaultOutcome\">\n              </response-header>\n            </a>\n\n            <div ng-if=\"activeAnswerGroupIndex === answerGroups.length\">\n              <div class=\"oppia-editor-card-section\">\n                <div class=\"oppia-rule-body-container protractor-test-response-body-default\">\n                  <answer-group-editor rules=\"null\"\n                                       outcome=\"defaultOutcome\"\n                                       on-save-answer-group-feedback=\"saveDefaultOutcomeFeedback\"\n                                       on-save-answer-group-dest=\"saveDefaultOutcomeDest\"\n                                       is-editable=\"editabilityService.isEditable()\"\n                                       suppress-warnings=\"suppressDefaultAnswerGroupWarnings()\"\n                                       display-feedback=\"!isLinearWithNoFeedback(defaultOutcome)\"\n                                       class=\"protractor-test-response-body\">\n                  </answer-group-editor>\n                </div>\n              </div>\n            </div>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </md-card>\n\n{% if SHOW_TRAINABLE_UNRESOLVED_ANSWERS %}\n  <md-card style=\"margin: 20px 0px; padding: 0px;\" ng-if=\"isCurrentInteractionTrainable()\">\n    <div ng-if=\"editabilityService.isEditableOutsideTutorialMode() && !isCurrentInteractionLinear()\">\n      <button type=\"button\" class=\"btn btn-default btn-lg oppia-add-response-button protractor-test-open-teach-modal\" ng-click=\"openTeachOppiaModal()\">\n        + Teach Oppia\n      </button>\n    </div>\n  </md-card>\n  <md-card style=\"margin: 20px 0px; padding: 0px;\" ng-if=\"!isCurrentInteractionTrainable()\">\n{% else %}\n  <md-card style=\"margin: 0px; padding: 0px;\">\n{% endif %}\n    <div ng-if=\"editabilityService.isEditableOutsideTutorialMode() && !isCurrentInteractionLinear()\">\n      <button type=\"button\" class=\"btn btn-default btn-lg oppia-add-response-button protractor-test-open-add-response-modal\" ng-click=\"openAddAnswerGroupModal()\">\n        + Add New Oppia Response\n      </button>\n    </div>\n  </md-card>\n</div>\n\n{% if SHOW_TRAINABLE_UNRESOLVED_ANSWERS %}\n  <script type=\"text/ng-template\" id=\"modals/teachOppia\">\n    <div class=\"modal-header\">\n      <h3>Enter a Sample Answer</h3>\n    </div>\n\n    <div class=\"modal-body\">\n      <div class=\"oppia-rule-details-header\">\n        <test-interaction-panel state-content=\"stateContent\" input-template=\"inputTemplate\" on-submit-answer=\"submitAnswer(answer)\">\n        </test-interaction-panel>\n\n        <div ng-if=\"trainingDataAnswer\" style=\"padding-top: 10px; border-top: 1px solid #e5e5e5;\">\n          <form name=\"testOppiaForm\" class=\"form-inline\">\n            <training-panel ng-if=\"classification.answerGroupIndex >= 0\" answer=\"trainingDataAnswer\" answer-feedback=\"trainingDataFeedback\" answer-outcome-dest=\"trainingDataOutcomeDest\" classification=\"classification\" on-finish-training=\"finishTeaching(true)\">\n            </training-panel>\n          </form>\n          <div ng-if=\"classification.answerGroupIndex === -1\">\n            <div>\n              <span><strong>If Oppia encounters the answer:</strong></span>\n            </div>\n\n            <div>\n              <div angular-html-bind=\"answerTemplate\">\n              </div>\n            </div>\n\n            <br>\n\n            <div>\n              <span><strong>it will reply with:</strong></span>\n            </div>\n\n            <div>\n              <div angular-html-bind=\"trainingDataFeedback\">\n              </div>\n            </div>\n\n            <br>\n\n            <div>\n              <span><strong>and then direct the learner to: </strong></span>\n              <span angular-html-bind=\"trainingDataOutcomeDest\"></span>\n            </div>\n\n            <br>\n\n            <div>\n              <span><strong>This is due to a specific rule and therefore cannot be trained. If you do not think this is right, you should change the rule directly referring to this answer.</strong></span>\n            </div>\n          </div>\n        </div>\n      <div>\n    </div>\n\n    <div class=\"modal-footer\">\n      <button class=\"btn btn-default\" ng-click=\"finishTeaching(false)\">Exit</button>\n    </div>\n  </script>\n{% endif %}\n\n<script type=\"text/ng-template\" id=\"modals/addAnswerGroup\">\n  <div class=\"modal-header protractor-test-add-response-modal-header\">\n    <h3>Add Response</h3>\n  </div>\n\n  <div class=\"modal-body\">\n    <form name=\"addAnswerGroupForm.outcomeDetailsForm\" class=\"form-inline protractor-test-add-response-details\">\n      <div class=\"oppia-rule-details-header\">\n        <strong>If the learner's answer...</strong>\n      </div>\n\n      <rule-editor rule=\"tmpRule\" is-editable=\"editabilityService.isEditable()\" is-editing-rule-inline=\"false\">\n      </rule-editor>\n\n      <br>\n\n      <div ng-if=\"!feedbackEditorIsOpen && !isLinearWithNoFeedback(tmpOutcome)\"\n           title=\"Edit feedback\"\n           style=\"height: 100%; margin-right: 22px;\">\n        <div class=\"oppia-rule-details-header oppia-editable-section\">\n          <div class=\"oppia-rule-preview oppia-transition-200\">\n            <div class=\"oppia-click-to-start-editing protractor-test-open-feedback-editor\" ng-click=\"openFeedbackEditor()\">\n              <i class=\"material-icons oppia-editor-edit-icon pull-right\" title=\"Edit Feedback\">&#xE254;</i>\n            </div>\n            <strong>Oppia tells the learner...</strong>\n            <div style=\"position: relative;\">\n              <span style=\"color: #888\">\n                <em>Nothing</em>\n              </span>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div ng-if=\"feedbackEditorIsOpen\">\n        <outcome-feedback-editor outcome=\"tmpOutcome\">\n        </outcome-feedback-editor>\n      </div>\n      <br>\n\n      <outcome-destination-editor outcome=\"tmpOutcome\" outcome-has-feedback=\"!isLinearWithNoFeedback(tmpOutcome)\">\n      </outcome-destination-editor>\n    </form>\n  </div>\n\n  <div class=\"modal-footer\">\n    <button class=\"btn btn-default protractor-test-close-add-response-modal\" ng-click=\"cancel()\">Cancel</button>\n    <button class=\"btn btn-success protractor-test-add-new-response\" ng-click=\"saveResponse(false)\" ng-disabled=\"addAnswerGroupForm.outcomeDetailsForm.$invalid || isSelfLoopWithNoFeedback(tmpOutcome)\">Save Response</button>\n    <button class=\"btn btn-success\" ng-click=\"saveResponse(true)\" ng-disabled=\"addAnswerGroupForm.outcomeDetailsForm.$invalid || isSelfLoopWithNoFeedback(tmpOutcome)\">Save and Add Another</button>\n  </div>\n</script>\n\n<script type=\"text/ng-template\" id=\"modals/deleteAnswerGroup\">\n  <div class=\"modal-header\">\n    <h3>Delete Response</h3>\n  </div>\n\n  <div class=\"modal-body\">\n    <p>\n      Are you sure you want to delete this response?\n    </p>\n  </div>\n\n  <div class=\"modal-footer\">\n    <button class=\"btn btn-default\" ng-click=\"cancel()\">Cancel</button>\n    <button class=\"btn btn-danger protractor-test-confirm-delete-response\"\n            ng-click=\"reallyDelete()\">\n      Delete Response\n    </button>\n  </div>\n</script>\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/exploration_editor.html",
      "content": "{% extends 'pages/base.html' %}\n\n{% block maintitle %}\n  {% if title %}\n    {{ title }} - Oppia Editor\n  {% else %}\n    Untitled Exploration - Oppia Editor\n  {% endif %}\n{% endblock maintitle %}\n\n{% block header_js %}\n  {{ super() }}\n  <script type=\"text/javascript\">\n    GLOBALS.ALLOWED_GADGETS = JSON.parse('{{ALLOWED_GADGETS|js_string}}');\n    GLOBALS.ALLOWED_INTERACTION_CATEGORIES = JSON.parse(\n      '{{ALLOWED_INTERACTION_CATEGORIES|js_string}}');\n    GLOBALS.can_edit = JSON.parse('{{can_edit|js_string}}');\n    GLOBALS.DEFAULT_OBJECT_VALUES = JSON.parse(\n      '{{DEFAULT_OBJECT_VALUES|js_string}}');\n    GLOBALS.DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR = JSON.parse(\n      '{{DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR|js_string}}');\n    GLOBALS.GADGET_SPECS = JSON.parse('{{GADGET_SPECS|js_string}}');\n    GLOBALS.INTERACTION_SPECS = JSON.parse('{{INTERACTION_SPECS|js_string}}');\n    GLOBALS.INVALID_PARAMETER_NAMES = JSON.parse(\n      '{{INVALID_PARAMETER_NAMES|js_string}}');\n    GLOBALS.NEW_STATE_TEMPLATE = JSON.parse(\n      '{{NEW_STATE_TEMPLATE|js_string}}');\n    GLOBALS.PANEL_SPECS = JSON.parse('{{PANEL_SPECS|js_string}}');\n    GLOBALS.SHOW_TRAINABLE_UNRESOLVED_ANSWERS = JSON.parse(\n      '{{SHOW_TRAINABLE_UNRESOLVED_ANSWERS|js_string}}');\n    GLOBALS.TAG_REGEX = JSON.parse('{{TAG_REGEX|js_string}}');\n  </script>\n\n  <script type=\"text/javascript\" src=\"https://www.google.com/jsapi\"></script>\n  <script type=\"text/javascript\">\n    if (window.google && window.google.load) {\n      google.load('visualization', '1', {packages: ['corechart']});\n    } else {\n      throw 'error: Could not load google visualization library. Are you offline?';\n    }\n  </script>\n\n  <style>\n    html, body {\n      background-color: #eee;\n    }\n  </style>\n\n  {{dependencies_html}}\n{% endblock header_js %}\n\n{% block navbar_breadcrumb %}\n  <editor-navbar-breadcrumb></editor-navbar-breadcrumb>\n{% endblock navbar_breadcrumb %}\n\n{% block local_top_nav_options %}\n  <editor-navigation></editor-navigation>\n\n  <exploration-save-and-publish-buttons></exploration-save-and-publish-buttons>\n{% endblock local_top_nav_options %}\n\n{% block content %}\n  <div ng-controller=\"ExplorationEditor\" ng-cloak>\n    <div class=\"container-fluid oppia-editor-page-container\" ng-joy-ride=\"tutorialInProgress\" config=\"EDITOR_TUTORIAL_OPTIONS\" on-finish=\"onFinishTutorial()\" on-skip=\"onSkipTutorial()\">\n      <div class=\"row\" ng-if=\"explorationRightsService.isCloned()\">\n        <div class=\"col-lg-12 col-md-12 col-sm-12\">\n          <div class=\"oppia-align-center alert alert-warning\" style=\"padding: 2px; width: 90%;\">\n            <strong>Note:</strong> This is a private, unpublishable copy of a\n            <a ng-href=\"<[getExplorationUrl(explorationRightsService.clonedFrom())]>\" target=\"_blank\">public exploration</a>.\n          </div>\n        </div>\n      </div>\n\n      <div ng-show=\"getTabStatuses().active === 'main'\">\n        {% include 'pages/exploration_editor/editor_tab/editor_tab.html' %}\n      </div>\n\n      <!-- This is an ng-if, so that the preview loads the latest version of the exploration each time the tab is accessed. -->\n      <div ng-if=\"getTabStatuses().active === 'preview'\">\n        {% include 'pages/exploration_editor/preview_tab/preview_tab.html' %}\n        {% include 'pages/exploration_editor/preview_tab/preview_set_parameters_modal_directive.html' %}\n      </div>\n\n      <div ng-show=\"getTabStatuses().active === 'stats'\">\n        {% include 'pages/exploration_editor/statistics_tab/statistics_tab.html' %}\n      </div>\n\n      <div ng-show=\"getTabStatuses().active === 'settings'\">\n        {% include 'pages/exploration_editor/settings_tab/settings_tab.html' %}\n      </div>\n\n      <div ng-show=\"getTabStatuses().active === 'history'\">\n        {% include 'pages/exploration_editor/history_tab/history_tab.html' %}\n      </div>\n\n      <div ng-show=\"getTabStatuses().active === 'feedback'\">\n        {% include 'pages/exploration_editor/feedback_tab/feedback_tab.html' %}\n        {% include 'pages/exploration_editor/feedback_tab/thread_table_directive.html' %}\n      </div>\n    </div>\n  </div>\n\n  <!-- These definitions must be included exactly once on the page for the graph SVGs to work in Firefox. -->\n  <svg width=\"0\" height=\"0\">\n    <defs>\n      <marker id=\"arrowhead\" viewBox=\"0 0 18 18\" refX=\"10\" refY=\"3\"\n              markerWidth=\"10\" markerHeight=\"6\" orient=\"auto\">\n        <path d=\"M 0 0 L 10 4 L 0 8 z\" fill=\"grey\"></path>\n      </marker>\n      <marker id=\"arrowhead-green\" viewBox=\"0 0 18 18\" refX=\"10\" refY=\"3\"\n              markerWidth=\"10\" markerHeight=\"6\" orient=\"auto\">\n        <path d=\"M 0 0 L 10 4 L 0 8 z\" fill=\"#1F7D1F\"></path>\n      </marker>\n      <marker id=\"arrowhead-red\" viewBox=\"0 0 18 18\" refX=\"10\" refY=\"3\"\n              markerWidth=\"10\" markerHeight=\"6\" orient=\"auto\">\n        <path d=\"M 0 0 L 10 4 L 0 8 z\" fill=\"#B22222\"></path>\n      </marker>\n      <linearGradient id=\"nodegradient\" x1=\"0%\" x2=\"100%\" y1=\"0%\" y2=\"0%\">\n        <stop offset=\"0%\" style=\"stop-opacity: 1; stop-color: darkseagreen;\"></stop>\n        <stop offset=\"100%\" style=\"stop-opacity: 0.1; stop-color: darkseagreen;\"></stop>\n      </linearGradient>\n    </defs>\n  </svg>\n\n  {% include 'components/attribution_guide/attribution_guide_directive.html' %}\n  {% include 'components/embed_modal/embed_exploration_modal_directive.html' %}\n  {% include 'components/forms/html_select_directive.html' %}\n  {% include 'components/gadget/gadget_directive.html' %}\n  {% include 'components/gadget/gadget_panel_directive.html' %}\n  {% include 'components/profile_link/profile_link_text_directive.html' %}\n  {% include 'components/share/sharing_links_directive.html' %}\n\n  {% include 'components/answer_group_editor_directive.html' %}\n  {% include 'components/classifier_panel_directive.html' %}\n  {% include 'components/fallback_editor_directive.html' %}\n  {% include 'components/outcome_editor_directive.html' %}\n  {% include 'components/outcome_destination_editor_directive.html' %}\n  {% include 'components/outcome_feedback_editor_directive.html' %}\n  {% include 'components/response_header_directive.html' %}\n  {% include 'components/rule_editor_directive.html' %}\n  {% include 'components/version_diff_visualization_directive.html' %}\n\n  {% include 'pages/exploration_player/tutor_card_directive.html' %}\n  {% include 'pages/exploration_player/supplemental_card_directive.html' %}\n  {% include 'pages/exploration_editor/editor_navigation_directive.html' %}\n  {% include 'pages/exploration_editor/editor_navbar_breadcrumb_directive.html' %}\n  {% include 'pages/exploration_editor/editor_reloading_modal_directive.html' %}\n  {% include 'pages/exploration_editor/exploration_metadata_modal_directive.html' %}\n  {% include 'pages/exploration_editor/exploration_publish_modal_directive.html' %}\n  {% include 'pages/exploration_editor/exploration_save_and_publish_buttons_directive.html' %}\n  {% include 'pages/exploration_editor/exploration_save_modal_directive.html' %}\n  {% include 'pages/exploration_editor/help_modal_directive.html' %}\n  {% include 'pages/exploration_editor/param_changes_editor_directive.html' %}\n  {% include 'pages/exploration_editor/post_publish_modal_directive.html' %}\n  {% include 'pages/exploration_editor/save_validation_fail_modal.html' %}\n  {% include 'pages/exploration_editor/save_version_mismatch_modal.html' %}\n  {% include 'pages/exploration_editor/state_diff_modal_directive.html' %}\n  {% include 'pages/exploration_editor/welcome_modal_directive.html' %}\n\n  {% include 'pages/exploration_editor/editor_tab/state_graph_visualization_directive.html' %}\n\n  {% include 'pages/exploration_player/answer_feedback_pair_directive.html' %}\n  {% include 'pages/exploration_player/conversation_skin_directive.html' %}\n  {% include 'pages/exploration_player/progress_dots_directive.html' %}\n{% endblock content %}\n\n{% block footer_js %}\n  {{ super() }}\n  <script src=\"/third_party/static/d3js-3.4.11/d3.min.js\"></script>\n  <script>\n    {{ value_generators_js }}\n  </script>\n\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/BooleanEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/CodeStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/CoordTwoDimEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/FilepathEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/GraphEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/GraphPropertyEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/HtmlEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/ImageWithRegionsEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/IntEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/ListOfUnicodeStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/LogicErrorCategoryEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/LogicQuestionEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/MathLatexStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/MusicPhraseEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/NonnegativeIntEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/NormalizedStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/ParameterNameEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/RealEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/SanitizedUrlEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/SetOfHtmlStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/SetOfUnicodeStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/UnicodeStringEditor.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/attribution_guide/AttributionGuideDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/embed_modal/ExplorationEmbedButtonService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/forms/HtmlSelectDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/gadget/GadgetDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/gadget/GadgetPanelDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/profile_link/ProfileLinkTextDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/share/SharingLinksDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/AnswerGroupEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/CodemirrorMergeviewDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/FallbackEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/ClassifierRulePanelDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/OutcomeEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/OutcomeDestinationEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/OutcomeFeedbackEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/ResponseHeaderDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/RuleEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/RuleTypeSelectorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/StateGraphLayoutService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/VersionDiffVisualizationDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/services/explorationServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/services/messengerService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/services/utilsService.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/EditorNavbarBreadcrumbDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/EditorNavigationDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/EditorServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ExplorationDiffService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ExplorationEditor.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ExplorationEditorAdvancedFeaturesService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ExplorationSaveAndPublishButtonsDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ExplorationSaveService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/GadgetValidationService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ParamChangesEditorDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ParameterMetadataService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/RouterServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/ValueGeneratorEditorDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/ExplorationGraph.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/GadgetEditor.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/SidebarStateName.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateEditor.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateFallbacks.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateGraphVisualizationDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateInteraction.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateParameterChanges.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateResponses.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/editor_tab/StateStatistics.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/preview_tab/PreviewTab.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/statistics_tab/StatisticsTab.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/statistics_tab/BarChartDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/settings_tab/SettingsTab.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/history_tab/HistoryTab.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/history_tab/HistoryServices.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/feedback_tab/FeedbackTab.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/feedback_tab/ThreadDataService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/feedback_tab/ThreadStatusDisplayService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_editor/feedback_tab/ThreadTableDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/ExplorationObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/StateObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/AnswerGroupObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/utilities/StopwatchObjectFactory.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/TutorCardDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/SupplementalCardDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ExplorationPlayerStateService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerConstants.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/AnswerClassificationService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/AnswerFeedbackPairDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ConversationSkinDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ExplorationRecommendationsService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerParamsService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerViewRatingService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerPositionService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerTranscriptService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ProgressDotsDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/StatsReportingService.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/expressions/expressionInterpolationService.js\"></script>\n\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/interactions/baseValidator.js\"></script>\n\n  {{ interaction_templates }}\n  {{ gadget_templates }}\n{% endblock footer_js %}\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_editor/preview_tab/PreviewTab.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Controllers and services for the exploration preview in the\n * editor page.\n */\n\noppia.controller('PreviewTab', [\n  '$scope', '$modal', '$q', '$timeout', 'LearnerParamsService',\n  'explorationData', 'explorationAdvancedFeaturesService',\n  'explorationCategoryService', 'editorContextService',\n  'explorationGadgetsService', 'explorationInitStateNameService',\n  'explorationParamChangesService', 'explorationParamSpecsService',\n  'explorationStatesService', 'explorationTitleService',\n  'oppiaPlayerService', 'parameterMetadataService',\n  function(\n      $scope, $modal, $q, $timeout, LearnerParamsService,\n      explorationData, explorationAdvancedFeaturesService,\n      explorationCategoryService, editorContextService,\n      explorationGadgetsService, explorationInitStateNameService,\n      explorationParamChangesService, explorationParamSpecsService,\n      explorationStatesService, explorationTitleService,\n      oppiaPlayerService, parameterMetadataService) {\n    $scope.isExplorationPopulated = false;\n    explorationData.getData().then(function() {\n      var initStateNameForPreview = editorContextService.getActiveStateName();\n      var manualParamChanges = [];\n\n      // Show a warning message if preview doesn't start from the first state\n      if (initStateNameForPreview !==\n          explorationInitStateNameService.savedMemento) {\n        $scope.previewWarning =\n          'Preview started from \\\"' + initStateNameForPreview + '\\\"';\n      } else {\n        $scope.previewWarning = '';\n      }\n\n      // Prompt user to enter any unset parameters, then populate exploration\n      manualParamChanges = $scope.getManualParamChanges(\n        initStateNameForPreview).then(function(manualParamChanges) {\n        $scope.loadPreviewState(initStateNameForPreview, manualParamChanges);\n      });\n    });\n\n    $scope.getManualParamChanges = function(initStateNameForPreview) {\n      var deferred = $q.defer();\n\n      var unsetParametersInfo = parameterMetadataService.getUnsetParametersInfo(\n        [initStateNameForPreview]);\n\n      // Construct array to hold required parameter changes\n      var getDefaultParameterChange = function(name) {\n        return angular.copy({\n          customization_args: {\n            parse_with_jinja: true,\n            value: ''\n          },\n          generator_id: 'Copier',\n          name: name\n        });\n      };\n      var manualParamChanges = [];\n      for (var i = 0; i < unsetParametersInfo.length; i++) {\n        var newParamChange =\n          getDefaultParameterChange(unsetParametersInfo[i].paramName);\n        manualParamChanges.push(newParamChange);\n      };\n\n      // Use modal to populate parameter change values\n      if (manualParamChanges.length > 0) {\n        $scope.showSetParamsModal(manualParamChanges, function() {\n          deferred.resolve(manualParamChanges);\n        });\n      } else {\n        deferred.resolve([]);\n      };\n\n      return deferred.promise;\n    };\n\n    $scope.showParameterSummary = function() {\n      return (explorationAdvancedFeaturesService.areParametersEnabled() &&\n              !angular.equals({}, $scope.allParams));\n    };\n\n    $scope.showSetParamsModal = function(manualParamChanges, callback) {\n      var modalInstance = $modal.open({\n        templateUrl: 'modals/previewParams',\n        backdrop: 'static',\n        windowClass: 'oppia-preview-set-params-modal',\n        controller: [\n          '$scope', '$modalInstance', 'routerService',\n          function($scope, $modalInstance, routerService) {\n            $scope.manualParamChanges = manualParamChanges;\n            $scope.previewParamModalOk = $modalInstance.close;\n            $scope.previewParamModalCancel = function() {\n              $modalInstance.dismiss('cancel');\n              routerService.navigateToMainTab();\n            };\n          }\n        ]\n      }).result.then(function() {\n        if (callback) {\n          callback();\n        }\n      });\n    };\n\n    $scope.loadPreviewState = function(stateName, manualParamChanges) {\n      oppiaPlayerService.initSettingsFromEditor(stateName, manualParamChanges);\n      $scope.isExplorationPopulated = true;\n    };\n\n    $scope.resetPreview = function() {\n      $scope.previewWarning = '';\n      $scope.isExplorationPopulated = false;\n      $scope.loadPreviewState(explorationInitStateNameService.savedMemento, []);\n    };\n\n    // This allows the active state to be kept up-to-date whilst navigating in\n    // preview mode, ensuring that the state does not change when toggling\n    // between editor and preview.\n    $scope.$on('updateActiveStateIfInEditor', function(evt, stateName) {\n      editorContextService.setActiveStateName(stateName);\n    });\n\n    $scope.allParams = {};\n    $scope.$on('playerStateChange', function() {\n      $scope.allParams = LearnerParamsService.getAllParams();\n    });\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_player/AnswerClassificationService.js",
      "content": "// Copyright 2015 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Classification service for answer groups.\n */\n\noppia.factory('AnswerClassificationService', [\n  '$http', '$q', 'LearnerParamsService', 'alertsService', 'INTERACTION_SPECS',\n  'ENABLE_STRING_CLASSIFIER', 'CLASSIFIER_RULESPEC_STR',\n  function($http, $q, LearnerParamsService, alertsService, INTERACTION_SPECS,\n      ENABLE_STRING_CLASSIFIER, CLASSIFIER_RULESPEC_STR) {\n    /**\n     * Finds the first answer group with a rule that returns true.\n     *\n     * @param {*} answer - The answer that the user has submitted.\n     * @param {array} answerGroups - The answer groups of the interaction. Each\n     *     answer group contains rule_specs, which is a list of rules.\n     * @param {object} defaultOutcome - The default outcome of the interaction.\n     * @param {function} interactionRulesService The service which contains the\n     *     explicit rules of that interaction.\n     *\n     * @return {object} An object representing the answer group with the\n     *     following properties:\n     * <ul>\n     *   <li> **outcome**: the outcome of the answer group\n     *   <li> **answerGroupIndex**: the index of the matched answer group\n     *   <li> **ruleSpecIndex**: the index of the rule in the matched answer\n     *     group.\n     * </ul>\n     */\n    var classifyAnswer = function(\n        answer, answerGroups, defaultOutcome, interactionRulesService) {\n      // Find the first group that contains a rule which returns true\n      for (var i = 0; i < answerGroups.length; i++) {\n        for (var j = 0; j < answerGroups[i].ruleSpecs.length; j++) {\n          var ruleSpec = answerGroups[i].ruleSpecs[j];\n          if (ruleSpec.rule_type !== CLASSIFIER_RULESPEC_STR &&\n              interactionRulesService[ruleSpec.rule_type](\n                answer, ruleSpec.inputs)) {\n            return {\n              outcome: answerGroups[i].outcome,\n              answerGroupIndex: i,\n              ruleSpecIndex: j\n            };\n          }\n        }\n      }\n\n      // If no rule in any answer group returns true, the default 'group' is\n      // returned. Throws an error if the default outcome is not defined.\n      if (defaultOutcome) {\n        return {\n          outcome: defaultOutcome,\n          answerGroupIndex: answerGroups.length,\n          ruleSpecIndex: 0\n        };\n      } else {\n        alertsService.addWarning('Something went wrong with the exploration.');\n      }\n    };\n\n    return {\n      /**\n       * Gets a promise to the matching answer group.\n       *\n       * @param {string} explorationId - The exploration ID.\n       * @param {object} oldState - The state where the user submitted the\n       *   answer.\n       * @param {*} answer - The answer that the user has submitted.\n       * @param {boolean} isInEditorMode - Whether the function is being called\n       *   in editor mode.\n       * @param {function} interactionRulesService - The service which contains\n       *   the explicit rules of that interaction.\n       *\n       * @return {promise} A promise for an object representing the answer group\n       *     with the following properties:\n       * <ul>\n       *   <li> **outcome**: the outcome of the answer group\n       *   <li> **answerGroupIndex**: the index of the matched answer group\n       *   <li> **ruleSpecIndex**: the index of the rule in the matched answer\n       *            group\n       * </ul>\n       */\n      getMatchingClassificationResult: function(\n          explorationId, oldState, answer, isInEditorMode,\n          interactionRulesService) {\n        var deferred = $q.defer();\n        var result = null;\n        var answerGroups = oldState.interaction.answer_groups;\n        var defaultOutcome = oldState.interaction.default_outcome;\n        if (interactionRulesService) {\n          result = classifyAnswer(\n            answer, answerGroups, defaultOutcome, interactionRulesService);\n        } else {\n          alertsService.addWarning(\n            'Something went wrong with the exploration: no ' +\n            'interactionRulesService was available.');\n          deferred.reject();\n          return deferred.promise;\n        }\n\n        if (result.outcome === defaultOutcome &&\n            INTERACTION_SPECS[oldState.interaction.id]\n              .is_string_classifier_trainable &&\n            ENABLE_STRING_CLASSIFIER) {\n          // TODO(bhenning): Figure out a long-term solution for determining\n          // what params should be passed to the batch classifier.\n          var classifyUrl = '/explorehandler/classify/' + explorationId;\n          var params = (\n            isInEditorMode ? {} : LearnerParamsService.getAllParams());\n\n          $http.post(classifyUrl, {\n            old_state: oldState.toBackendDict(),\n            params: params,\n            answer: answer\n          }).then(function(response) {\n            var result = response.data;\n            deferred.resolve({\n              outcome: result.outcome,\n              ruleSpecIndex: result.rule_spec_index,\n              answerGroupIndex: result.answer_group_index\n            });\n          });\n        } else {\n          deferred.resolve(result);\n        }\n        return deferred.promise;\n      }\n    };\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_player/PlayerServices.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utility service for the learner's view of an exploration.\n */\n\noppia.constant('GADGET_SPECS', GLOBALS.GADGET_SPECS);\noppia.constant('INTERACTION_SPECS', GLOBALS.INTERACTION_SPECS);\n\n// A service that provides a number of utility functions for JS used by\n// the player skin.\n// Note that this service is used both in the learner and the editor views.\n// The URL determines which of these it is. Some methods may need to be\n// implemented differently depending on whether the skin is being played\n// in the learner view, or whether it is being previewed in the editor view.\n//\n// TODO(sll): Make this read from a local client-side copy of the exploration\n// and audit it to ensure it behaves differently for learner mode and editor\n// mode. Add tests to ensure this.\noppia.factory('oppiaPlayerService', [\n  '$http', '$rootScope', '$q', 'LearnerParamsService',\n  'alertsService', 'AnswerClassificationService', 'explorationContextService',\n  'PAGE_CONTEXT', 'oppiaExplorationHtmlFormatterService',\n  'playerTranscriptService', 'ExplorationObjectFactory',\n  'expressionInterpolationService', 'StatsReportingService',\n  'UrlInterpolationService',\n  function(\n      $http, $rootScope, $q, LearnerParamsService,\n      alertsService, AnswerClassificationService, explorationContextService,\n      PAGE_CONTEXT, oppiaExplorationHtmlFormatterService,\n      playerTranscriptService, ExplorationObjectFactory,\n      expressionInterpolationService, StatsReportingService,\n      UrlInterpolationService) {\n    var _explorationId = explorationContextService.getExplorationId();\n    var _editorPreviewMode = (\n      explorationContextService.getPageContext() === PAGE_CONTEXT.EDITOR);\n    var _isLoggedIn = GLOBALS.userIsLoggedIn;\n    var answerIsBeingProcessed = false;\n\n    var exploration = null;\n\n    // Param changes to be used ONLY in editor preview mode.\n    var manualParamChanges = null;\n    var initialStateName = null;\n    var version = GLOBALS.explorationVersion;\n\n    var randomFromArray = function(arr) {\n      return arr[Math.floor(Math.random() * arr.length)];\n    };\n\n    // Evaluate feedback.\n    var makeFeedback = function(feedbacks, envs) {\n      var feedbackHtml = feedbacks.length > 0 ? feedbacks[0] : '';\n      return expressionInterpolationService.processHtml(feedbackHtml, envs);\n    };\n\n    // Evaluate parameters. Returns null if any evaluation fails.\n    var makeParams = function(oldParams, paramChanges, envs) {\n      var newParams = angular.copy(oldParams);\n      if (paramChanges.every(function(pc) {\n        if (pc.generator_id === 'Copier') {\n          if (!pc.customization_args.parse_with_jinja) {\n            newParams[pc.name] = pc.customization_args.value;\n          } else {\n            var paramValue = expressionInterpolationService.processUnicode(\n              pc.customization_args.value, [newParams].concat(envs));\n            if (paramValue === null) {\n              return false;\n            }\n            newParams[pc.name] = paramValue;\n          }\n        } else {\n          // RandomSelector.\n          newParams[pc.name] = randomFromArray(\n            pc.customization_args.list_of_values);\n        }\n        return true;\n      })) {\n        // All parameters were evaluated successfully.\n        return newParams;\n      }\n      // Evaluation of some parameter failed.\n      return null;\n    };\n\n    // Evaluate question string.\n    var makeQuestion = function(newState, envs) {\n      return expressionInterpolationService.processHtml(\n        newState.content[0].value, envs);\n    };\n\n    // This should only be called when 'exploration' is non-null.\n    var _loadInitialState = function(successCallback) {\n      var initialState = exploration.getInitialState();\n      var oldParams = LearnerParamsService.getAllParams();\n      var newParams = makeParams(\n        oldParams, initialState.paramChanges, [oldParams]);\n      if (newParams === null) {\n        alertsService.addWarning('Expression parsing error.');\n        return;\n      }\n\n      var questionHtml = makeQuestion(initialState, [newParams]);\n      if (questionHtml === null) {\n        alertsService.addWarning('Expression parsing error.');\n        return;\n      }\n\n      if (!_editorPreviewMode) {\n        StatsReportingService.recordExplorationStarted(\n          exploration.initStateName, newParams);\n      }\n\n      $rootScope.$broadcast('playerStateChange', initialState.name);\n      successCallback(exploration, questionHtml, newParams);\n    };\n\n    // Initialize the parameters in the exploration as specified in the\n    // exploration-level initial parameter changes list, followed by any\n    // manual parameter changes (in editor preview mode).\n    var initParams = function(manualParamChanges) {\n      var baseParams = {};\n      for (var paramName in exploration.paramSpecs) {\n        // TODO(sll): This assumes all parameters are of type\n        // UnicodeString. We should generalize this to other default values\n        // for different types of parameters.\n        baseParams[paramName] = '';\n      }\n\n      var startingParams = makeParams(\n        baseParams,\n        exploration.paramChanges.concat(manualParamChanges),\n        [baseParams]);\n\n      LearnerParamsService.init(startingParams);\n    };\n\n    // Ensure the transition to a terminal state properly logs the end of the\n    // exploration.\n    $rootScope.$on('playerStateChange', function(evt, newStateName) {\n      if (!_editorPreviewMode && exploration.isStateTerminal(newStateName)) {\n        StatsReportingService.recordExplorationCompleted(\n          newStateName, LearnerParamsService.getAllParams());\n      }\n    });\n\n    return {\n      // This should only be used in editor preview mode. It sets the\n      // exploration data from what's currently specified in the editor, and\n      // also initializes the parameters to empty strings.\n      initSettingsFromEditor: function(activeStateNameFromPreviewTab,\n        manualParamChangesToInit) {\n        if (_editorPreviewMode) {\n          manualParamChanges = manualParamChangesToInit;\n          initStateName = activeStateNameFromPreviewTab;\n        } else {\n          throw 'Error: cannot populate exploration in learner mode.';\n        }\n      },\n      /**\n       * Initializes an exploration, passing the data for the first state to\n       * successCallback.\n       *\n       * In editor preview mode, populateExploration() must be called before\n       * calling init().\n       *\n       * @param {function} successCallback - The function to execute after the\n       *   initial exploration data is successfully loaded. This function will\n       *   be passed two arguments:\n       *   - stateName {string}, the name of the first state\n       *   - initHtml {string}, an HTML string representing the content of the\n       *       first state.\n       */\n      init: function(successCallback) {\n        answerIsBeingProcessed = false;\n        playerTranscriptService.init();\n\n        if (_editorPreviewMode) {\n          var explorationDataUrl = UrlInterpolationService.interpolateUrl(\n            '/createhandler/data/<exploration_id>', {\n              exploration_id: _explorationId\n            });\n          $http.get(explorationDataUrl, {\n            params: {\n              apply_draft: true\n            }\n          }).then(function(response) {\n            exploration = ExplorationObjectFactory.create(response.data);\n            exploration.setInitialStateName(initStateName);\n            initParams(manualParamChanges);\n            _loadInitialState(successCallback);\n          });\n        } else {\n          var explorationDataUrl = UrlInterpolationService.interpolateUrl(\n            '/explorehandler/init/<exploration_id>', {\n              exploration_id: _explorationId\n            }) + (version ? '?v=' + version : '');\n          $http.get(explorationDataUrl).then(function(response) {\n            var data = response.data;\n            exploration = ExplorationObjectFactory.create(data.exploration);\n            version = data.version;\n\n            initParams([]);\n\n            StatsReportingService.initSession(\n              _explorationId, data.version, data.session_id,\n              GLOBALS.collectionId);\n\n            _loadInitialState(successCallback);\n            $rootScope.$broadcast('playerServiceInitialized');\n          });\n        }\n      },\n      getExplorationId: function() {\n        return _explorationId;\n      },\n      getExplorationTitle: function() {\n        return exploration.title;\n      },\n      getExplorationVersion: function() {\n        return version;\n      },\n      getExplorationLanguageCode: function() {\n        return exploration.languageCode;\n      },\n      getStateContentHtml: function(stateName) {\n        return exploration.getUninterpolatedContentHtml(stateName);\n      },\n      getInteractionHtml: function(stateName, labelForFocusTarget) {\n        var interactionId = exploration.getInteractionId(stateName);\n        if (!interactionId) {\n          return null;\n        }\n\n        return oppiaExplorationHtmlFormatterService.getInteractionHtml(\n          interactionId,\n          exploration.getInteractionCustomizationArgs(stateName),\n          labelForFocusTarget);\n      },\n      getInteraction: function(stateName) {\n        return exploration.getInteraction(stateName);\n      },\n      getRandomSuffix: function() {\n        // This is a bit of a hack. When a refresh to a $scope variable happens,\n        // AngularJS compares the new value of the variable to its previous\n        // value. If they are the same, then the variable is not updated.\n        // Appending a random suffix makes the new value different from the\n        // previous one, and thus indirectly forces a refresh.\n        var randomSuffix = '';\n        var N = Math.round(Math.random() * 1000);\n        for (var i = 0; i < N; i++) {\n          randomSuffix += ' ';\n        }\n        return randomSuffix;\n      },\n      isLoggedIn: function() {\n        return _isLoggedIn;\n      },\n      isInPreviewMode: function() {\n        return !!_editorPreviewMode;\n      },\n      submitAnswer: function(answer, interactionRulesService, successCallback) {\n        if (answerIsBeingProcessed) {\n          return;\n        }\n\n        answerIsBeingProcessed = true;\n        var oldState = exploration.getState(\n          playerTranscriptService.getLastStateName());\n        AnswerClassificationService.getMatchingClassificationResult(\n          _explorationId, oldState, answer, false, interactionRulesService\n        ).then(function(classificationResult) {\n          if (!_editorPreviewMode) {\n            StatsReportingService.recordAnswerSubmitted(\n              playerTranscriptService.getLastStateName(),\n              LearnerParamsService.getAllParams(),\n              answer,\n              classificationResult.answerGroupIndex,\n              classificationResult.ruleSpecIndex);\n          }\n\n          // Use angular.copy() to clone the object\n          // since classificationResult.outcome points\n          // at oldState.interaction.default_outcome\n          var outcome = angular.copy(classificationResult.outcome);\n\n          // If this is a return to the same state, and the resubmission trigger\n          // kicks in, replace the dest, feedback and param changes with that\n          // of the trigger.\n          if (outcome.dest === playerTranscriptService.getLastStateName()) {\n            for (var i = 0; i < oldState.interaction.fallbacks.length; i++) {\n              var fallback = oldState.interaction.fallbacks[i];\n              if (fallback.trigger.trigger_type === 'NthResubmission' &&\n                  fallback.trigger.customization_args.num_submits.value ===\n                    playerTranscriptService.getNumSubmitsForLastCard()) {\n                outcome.dest = fallback.outcome.dest;\n                outcome.feedback = fallback.outcome.feedback;\n                outcome.param_changes = fallback.outcome.param_changes;\n                break;\n              }\n            }\n          }\n\n          var newStateName = outcome.dest;\n          var newState = exploration.getState(newStateName);\n\n          // Compute the data for the next state.\n          var oldParams = LearnerParamsService.getAllParams();\n          oldParams.answer = answer;\n          var feedbackHtml = makeFeedback(outcome.feedback, [oldParams]);\n          if (feedbackHtml === null) {\n            answerIsBeingProcessed = false;\n            alertsService.addWarning('Expression parsing error.');\n            return;\n          }\n\n          var newParams = (\n            newState ? makeParams(\n              oldParams, newState.paramChanges, [oldParams]) : oldParams);\n          if (newParams === null) {\n            answerIsBeingProcessed = false;\n            alertsService.addWarning('Expression parsing error.');\n            return;\n          }\n\n          var questionHtml = makeQuestion(newState, [newParams, {\n            answer: 'answer'\n          }]);\n          if (questionHtml === null) {\n            answerIsBeingProcessed = false;\n            alertsService.addWarning('Expression parsing error.');\n            return;\n          }\n\n          // TODO(sll): Remove the 'answer' key from newParams.\n          newParams.answer = answer;\n\n          answerIsBeingProcessed = false;\n\n          var oldStateName = playerTranscriptService.getLastStateName();\n          var refreshInteraction = (\n            oldStateName !== newStateName ||\n            exploration.isInteractionInline(oldStateName));\n\n          if (!_editorPreviewMode) {\n            StatsReportingService.recordStateTransition(\n              oldStateName, newStateName, answer,\n              LearnerParamsService.getAllParams());\n          }\n\n          $rootScope.$broadcast('updateActiveStateIfInEditor', newStateName);\n          $rootScope.$broadcast('playerStateChange', newStateName);\n          successCallback(\n            newStateName, refreshInteraction, feedbackHtml, questionHtml,\n            newParams);\n        });\n      },\n      isAnswerBeingProcessed: function() {\n        return answerIsBeingProcessed;\n      },\n      // Returns a promise for the user profile picture, or the default image if\n      // user is not logged in or has not uploaded a profile picture, or the\n      // player is in preview mode.\n      getUserProfileImage: function() {\n        var DEFAULT_PROFILE_IMAGE_PATH = (\n          UrlInterpolationService.getStaticImageUrl(\n            '/avatar/user_blue_72px.png'));\n\n        var deferred = $q.defer();\n        if (_isLoggedIn && !_editorPreviewMode) {\n          $http.get(\n            '/preferenceshandler/profile_picture'\n          ).then(function(response) {\n            var profilePictureDataUrl = response.data.profile_picture_data_url;\n            if (profilePictureDataUrl) {\n              deferred.resolve(profilePictureDataUrl);\n            } else {\n              deferred.resolve(DEFAULT_PROFILE_IMAGE_PATH);\n            }\n          });\n        } else {\n          deferred.resolve(DEFAULT_PROFILE_IMAGE_PATH);\n        }\n        return deferred.promise;\n      }\n    };\n  }\n]);\n"
    },
    {
      "filename": "core/templates/dev/head/pages/exploration_player/exploration_player.html",
      "content": "{% extends 'pages/base.html' %}\n\n{% block maintitle %}\n  {{ exploration_title }} - Oppia\n{% endblock maintitle %}\n\n{% block header_js %}\n  {{ super() }}\n  {% if exploration_version %}\n    <script type=\"text/javascript\">\n      GLOBALS.collectionId = JSON.parse('{{collection_id|js_string}}');\n      GLOBALS.collectionTitle = JSON.parse('{{collection_title|js_string}}');\n      GLOBALS.DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER = JSON.parse(\n        '{{DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER|js_string}}');\n      GLOBALS.explorationVersion = JSON.parse(\n        '{{exploration_version|js_string}}');\n      GLOBALS.GADGET_SPECS = JSON.parse('{{GADGET_SPECS|js_string}}');\n      GLOBALS.INTERACTION_SPECS = JSON.parse(\n        '{{INTERACTION_SPECS|js_string}}');\n    </script>\n\n  {% endif %}\n\n  {{dependencies_html}}\n  <style>\n    @media(max-width: 768px) {\n      /* This prevents the navbar from collapsing in the exploration page,\n      so that the exploration title can be shown. */\n      .oppia-exploration-header {\n        display: block;\n        float: right;\n        max-width: 240px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n      .oppia-navbar-collapse.collapse {\n        display: block;\n      }\n    }\n    @media(max-width: 600px) {\n      .oppia-logo {\n        height: 48px;\n        margin-left: 0;\n        margin-top: 8px;\n        max-width: none;\n      }\n      .oppia-exploration-header {\n        max-width: 180px;\n      }\n      .oppia-navbar-brand-name {\n        max-width: 35px;\n        overflow: hidden;\n      }\n      .oppia-navbar-breadcrumb-icon {\n        display: none;\n      }\n    }\n    @media(max-width: 400px) {\n      .oppia-exploration-header {\n        max-width: 130px;\n      }\n    }\n  </style>\n{% endblock header_js %}\n\n{% block navbar_breadcrumb %}\n  <ul class=\"nav navbar-nav oppia-navbar-breadcrumb\" ng-controller=\"LearnerViewBreadcrumb\">\n    <li>\n      <span class=\"oppia-navbar-breadcrumb-separator\"></span>\n      <span class=\"protractor-test-exploration-header oppia-exploration-header\" itemprop=\"description\">{{exploration_title}}</span>\n    </li>\n    <li ng-click=\"showInformationCard()\" tooltip=\"<['I18N_PLAYER_INFO_TOOLTIP' | translate]>\" tooltip-placement=\"bottom\" style=\"cursor: pointer;\" class=\"protractor-test-exploration-info-icon\">\n      <i class=\"material-icons oppia-navbar-breadcrumb-icon\" style=\"font-size: 20px;\">&#xE88E;</i>\n    </li>\n  </ul>\n{% endblock navbar_breadcrumb %}\n\n{% block local_top_nav_options %}\n  <script type=\"text/ng-template\" id=\"modals/learnerSuggestionSubmitted\">\n    <div class=\"modal-header\">\n      <h3>Thanks!</h3>\n    </div>\n\n    <div class=\"modal-body\">\n      <p>\n        Your suggestion has been forwarded to the exploration author for review.\n      </p>\n    </div>\n\n    <div class=\"modal-footer\">\n      <button class=\"btn btn-default\" ng-click=\"close()\">Close</button>\n    </div>\n  </script>\n  <script type=\"text/ng-template\" id=\"modals/learnerViewSuggestion\">\n    <div class=\"modal-header\">\n      <h3>Suggest a Change</h3>\n    </div>\n\n    <div class=\"modal-body\">\n      <text-angular-rte ng-show=\"showEditor\" html-content=\"suggestionContent\"></text-angular-rte>\n      <br>\n      Briefly describe your changes (required):\n      <input type=\"text\" ng-model=\"description\" style=\"width: 100%\">\n    </div>\n\n    <div class=\"modal-footer\">\n      <button class=\"btn btn-default\" ng-click=\"cancelSuggestion()\">Cancel</button>\n      <button class=\"btn btn-success\" ng-click=\"submitSuggestion()\" ng-disabled=\"(initContent == suggestionContent) || !description\">\n        Submit Suggestion\n      </button>\n    </div>\n  </script>\n  {% include 'pages/exploration_player/learner_local_nav.html' %}\n{% endblock local_top_nav_options %}\n\n{% block content %}\n  <div>\n    <background-banner></background-banner>\n    <conversation-skin></conversation-skin>\n    {% if not iframed %}\n      <attribution-guide></attribution-guide>\n    {% endif %}\n  </div>\n\n  {% include 'components/attribution_guide/attribution_guide_directive.html' %}\n  {% include 'components/embed_modal/embed_exploration_modal_directive.html' %}\n  {% include 'components/gadget/gadget_directive.html' %}\n  {% include 'components/gadget/gadget_panel_directive.html' %}\n  {% include 'components/profile_link/profile_link_image_directive.html' %}\n\n  {% if iframed %}\n    {% include 'pages/exploration_player/conversation_skin_embed_directive.html' %}\n  {% else %}\n    {% include 'pages/exploration_player/conversation_skin_directive.html' %}\n  {% endif %}\n\n  {% include 'pages/exploration_player/tutor_card_directive.html' %}\n  {% include 'pages/exploration_player/supplemental_card_directive.html' %}\n  {% include 'pages/exploration_player/answer_feedback_pair_directive.html' %}\n  {% include 'pages/exploration_player/exploration_successfully_flagged_modal.html' %}\n  {% include 'pages/exploration_player/feedback_popup_directive.html' %}\n  {% include 'pages/exploration_player/flag_exploration_modal.html' %}\n  {% include 'pages/exploration_player/information_card_modal.html' %}\n  {% include 'pages/exploration_player/progress_dots_directive.html' %}\n\n{% endblock %}\n\n{% block footer %}\n  {% if not iframed %}\n    {% include 'pages/exploration_player/exploration_footer_directive.html' %}\n    {% include 'components/share/sharing_links_directive.html' %}\n    <exploration-footer twitter-text=\"{{DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER}}\"></exploration-footer>\n  {% endif %}\n{% endblock %}\n\n{% block footer_js %}\n  {{ super() }}\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/MathLatexStringEditor.js\"></script>\n  <script src=\"{{ASSET_DIR_PREFIX}}/extensions/objects/templates/SanitizedUrlEditor.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/services/explorationServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/services/messengerService.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/attribution_guide/AttributionGuideDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/embed_modal/ExplorationEmbedButtonService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/gadget/GadgetDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/gadget/GadgetPanelDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/profile_link/ProfileLinkImageDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/components/share/SharingLinksDirective.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/ExplorationObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/StateObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/exploration/AnswerGroupObjectFactory.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/summary/ExplorationSummaryBackendApiService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/domain/utilities/StopwatchObjectFactory.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/TutorCardDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/SupplementalCardDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ExplorationPlayerStateService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerConstants.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/AnswerClassificationService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/AnswerFeedbackPairDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ConversationSkinDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ExplorationFooterDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ExplorationRecommendationsService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/FeedbackPopupDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerLocalNav.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerParamsService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerViewBreadcrumb.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/LearnerViewRatingService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerPositionService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerServices.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/PlayerTranscriptService.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/ProgressDotsDirective.js\"></script>\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/pages/exploration_player/StatsReportingService.js\"></script>\n\n  <script src=\"{{TEMPLATE_DIR_PREFIX}}/expressions/expressionInterpolationService.js\"></script>\n\n  {{ interaction_templates }}\n  {{ gadget_templates }}\n{% endblock footer_js %}\n"
    },
    {
      "filename": "core/tests/protractor/stateEditor.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview End-to-end tests of the interaction between the player and\n * editor.\n */\n\nvar general = require('../protractor_utils/general.js');\nvar interactions = require('../../../extensions/interactions/protractor.js');\nvar forms = require('../protractor_utils/forms.js');\nvar users = require('../protractor_utils/users.js');\nvar workflow = require('../protractor_utils/workflow.js');\nvar editor = require('../protractor_utils/editor.js');\nvar player = require('../protractor_utils/player.js');\n\ndescribe('State editor', function() {\n  it('should walk through the tutorial when user repeatedly clicks Next',\n      function() {\n    var NUM_TUTORIAL_STAGES = 7;\n    users.createUser(\n      'userTutorial@stateEditor.com', 'userTutorialStateEditor');\n    users.login('userTutorial@stateEditor.com');\n\n    workflow.createExplorationAndStartTutorial();\n    editor.startTutorial();\n    for (var i = 0; i < NUM_TUTORIAL_STAGES - 1; i++) {\n      editor.progressInTutorial();\n      general.waitForSystem();\n    }\n    editor.finishTutorial();\n    users.logout();\n  });\n\n  it('should display plain text content', function() {\n    users.createUser('user1@stateEditor.com', 'user1StateEditor');\n    users.login('user1@stateEditor.com');\n\n    workflow.createExploration();\n    editor.setContent(forms.toRichText('plain text'));\n    editor.setInteraction('Continue', 'click here');\n    editor.setDefaultOutcome(null, 'final card', true);\n\n    // Setup a terminating state\n    editor.moveToState('final card');\n    editor.setInteraction('EndExploration');\n    editor.saveChanges();\n\n    general.moveToPlayer();\n    player.expectContentToMatch(forms.toRichText('plain text'));\n    player.expectExplorationToNotBeOver();\n    player.expectInteractionToMatch('Continue', 'click here');\n    player.submitAnswer('Continue', null);\n    player.expectExplorationToBeOver();\n\n    users.logout();\n  });\n\n  it('should create content and multiple choice interactions', function() {\n    users.createUser('user2@stateEditor.com', 'user2StateEditor');\n    users.login('user2@stateEditor.com');\n    workflow.createExploration();\n    editor.setContent(function(richTextEditor) {\n      richTextEditor.appendBoldText('bold text');\n      richTextEditor.appendPlainText(' ');\n      richTextEditor.appendItalicText('italic text');\n      richTextEditor.appendPlainText(' ');\n      richTextEditor.appendPlainText(' ');\n      richTextEditor.appendOrderedList(['entry 1', 'entry 2']);\n      richTextEditor.appendUnorderedList(['an entry', 'another entry']);\n    });\n    editor.setInteraction(\n      'MultipleChoiceInput',\n      [forms.toRichText('option A'), forms.toRichText('option B')]);\n    editor.setDefaultOutcome(null, 'final card', true);\n\n    // Setup a terminating state\n    editor.moveToState('final card');\n    editor.setInteraction('EndExploration');\n    editor.saveChanges();\n\n    general.moveToPlayer();\n    player.expectExplorationToNotBeOver();\n    player.expectInteractionToMatch(\n      'MultipleChoiceInput',\n      [forms.toRichText('option A'), forms.toRichText('option B')]);\n    player.submitAnswer('MultipleChoiceInput', 'option B');\n    player.expectExplorationToBeOver();\n\n    users.logout();\n  });\n\n  it('should obey numeric interaction rules and display feedback', function() {\n    users.createUser('user3@stateEditor.com', 'user3StateEditor');\n    users.login('user3@stateEditor.com');\n\n    workflow.createExploration();\n    editor.setContent(forms.toRichText('some content'));\n    editor.setInteraction('NumericInput');\n    editor.addResponse('NumericInput', function(richTextEditor) {\n      richTextEditor.appendBoldText('correct');\n    }, 'final card', true, 'IsInclusivelyBetween', -1, 3);\n    editor.setDefaultOutcome(forms.toRichText('out of bounds'), null, false);\n\n    // Setup a terminating state\n    editor.moveToState('final card');\n    editor.setInteraction('EndExploration');\n    editor.saveChanges();\n\n    general.moveToPlayer();\n    player.submitAnswer('NumericInput', 5);\n    player.expectLatestFeedbackToMatch(forms.toRichText('out of bounds'));\n    player.expectExplorationToNotBeOver();\n    // It's important to test the value 0 in order to ensure that it would\n    // still get submitted even though it is a falsy value in JavaScript.\n    player.submitAnswer('NumericInput', 0);\n    player.expectLatestFeedbackToMatch(function(richTextChecker) {\n      richTextChecker.readBoldText('correct');\n    });\n    player.clickThroughToNextCard();\n    player.expectExplorationToBeOver();\n\n    users.logout();\n  });\n\n  it('should preserve input value when rule type changes in' +\n      ' add response modal', function() {\n    users.createUser('stateEditorUser1@example.com', 'stateEditorUser1');\n    users.login('stateEditorUser1@example.com');\n    workflow.createExploration();\n    editor.setContent(forms.toRichText('some content'));\n\n    editor.openInteraction('TextInput');\n    editor.customizeInteraction('TextInput', 'My PlaceHolder', 2);\n    editor.selectRuleInAddResponseModal('TextInput', 'Equals');\n    editor.setRuleParametersInAddResponseModal('TextInput',\n      'Equals', 'Some Text');\n    editor.expectRuleParametersToBe('TextInput', 'Equals', 'Some Text');\n    editor.selectRuleInAddResponseModal('TextInput', 'Contains');\n    editor.expectRuleParametersToBe('TextInput', 'Equals', 'Some Text');\n    editor.closeAddResponseModal();\n\n    editor.saveChanges();\n    users.logout();\n  });\n\n  afterEach(function() {\n    general.checkForConsoleErrors([]);\n  });\n});\n"
    },
    {
      "filename": "extensions/interactions/CodeRepl/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveCodeReplValidator', function() {\n  var WARNING_TYPES, validator;\n  var currentState, goodAnswerGroups, goodDefaultOutcome;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    validator = $injector.get('$filter')('oppiaInteractiveCodeReplValidator');\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n\n    currentState = 'First State';\n    goodDefaultOutcome = {\n      dest: 'Second State',\n      feedback: []\n    };\n    goodAnswerGroups = [{\n      ruleSpecs: [],\n      outcome: goodDefaultOutcome\n    }];\n  }));\n\n  it('should be able to perform basic validation', function() {\n    var warnings = validator(\n      currentState, {}, goodAnswerGroups, goodDefaultOutcome);\n    expect(warnings).toEqual([]);\n  });\n});\n"
    },
    {
      "filename": "extensions/interactions/Continue/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveContinueValidator', function() {\n  var validator, WARNING_TYPES;\n\n  var currentState;\n  var goodAnswerGroups, goodDefaultOutcome;\n  var customizationArguments;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    validator = $injector.get('$filter')('oppiaInteractiveContinueValidator');\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n\n    currentState = 'First State';\n    goodDefaultOutcome = {\n      dest: 'Second State',\n      feedback: []\n    };\n\n    goodAnswerGroups = [{\n      ruleSpecs: [],\n      outcome: goodDefaultOutcome\n    }];\n    customizationArguments = {\n      buttonText: {\n        value: 'Some Button Text'\n      }\n    };\n  }));\n\n  it('should expect a non-empty button text customization argument',\n    function() {\n      var warnings = validator(\n        currentState, customizationArguments, [], goodDefaultOutcome);\n      expect(warnings).toEqual([]);\n\n      customizationArguments.buttonText.value = '';\n      warnings = validator(\n        currentState, customizationArguments, [], goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The button text should not be empty.'\n      }]);\n\n      expect(function() {\n        validator(currentState, {}, [], goodDefaultOutcome);\n      }).toThrow(\n        'Expected customization arguments to have property: buttonText');\n    });\n\n  it('should expect no answer groups', function() {\n    var warnings = validator(\n      currentState, customizationArguments, goodAnswerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([{\n      type: WARNING_TYPES.CRITICAL,\n      message: (\n        'Only the default outcome is necessary for a continue interaction.')\n    }]);\n  });\n\n  it('should expect a non-confusing and non-null default outcome',\n    function() {\n      var warnings = validator(currentState, customizationArguments, [], null);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.ERROR,\n        message: (\n          'Please specify what Oppia should do after the button is clicked.')\n      }]);\n    });\n});\n"
    },
    {
      "filename": "extensions/interactions/EndExploration/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveEndExplorationValidator', function() {\n  var WARNING_TYPES;\n\n  var currentState;\n  var badOutcome, goodAnswerGroups;\n  var validator, customizationArguments;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    var filter = $injector.get('$filter');\n    validator = filter('oppiaInteractiveEndExplorationValidator');\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n\n    currentState = 'First State';\n\n    badOutcome = {\n      dest: currentState,\n      feedback: []\n    };\n\n    customizationArguments = {\n      recommendedExplorationIds: {\n        value: ['ExpID0', 'ExpID1', 'ExpID2']\n      }\n    };\n\n    goodAnswerGroups = [\n      {\n        ruleSpecs: [],\n        outcome: {\n          dest: 'Second State',\n          feedback: []\n        }\n      }\n    ];\n  }));\n\n  it('should not have warnings for no answer groups or no default outcome',\n    function() {\n      var warnings = validator(currentState, customizationArguments, [], null);\n      expect(warnings).toEqual([]);\n    });\n\n  it('should have warnings for any answer groups or default outcome',\n    function() {\n      var warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups, badOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.ERROR,\n        message: (\n          'Please make sure end exploration interactions do not ' +\n          'have any answer groups.')\n      }, {\n        type: WARNING_TYPES.ERROR,\n        message: (\n          'Please make sure end exploration interactions do not ' +\n          'have a default outcome.')\n      }]);\n    });\n\n  it('should throw for missing recommendations argument', function() {\n    expect(function() {\n      validator(currentState, {}, [], null);\n    }).toThrow(\n      'Expected customization arguments to have property: ' +\n      'recommendedExplorationIds');\n  });\n\n  it('should not have warnings for 0 or 8 recommendations', function() {\n    customizationArguments.recommendedExplorationIds.value = [];\n    var warnings = validator(currentState, customizationArguments, [], null);\n    expect(warnings).toEqual([]);\n\n    customizationArguments.recommendedExplorationIds.value = [\n      'ExpID0', 'ExpID1', 'ExpID2', 'ExpID3',\n      'ExpID4', 'ExpID5', 'ExpID6', 'ExpID7'\n    ];\n    warnings = validator(currentState, customizationArguments, [], null);\n    expect(warnings).toEqual([]);\n  });\n});\n"
    },
    {
      "filename": "extensions/interactions/GraphInput/validator.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Frontend validator for customization args and rules of\n * the interaction.\n */\n\noppia.filter('oppiaInteractiveGraphInputValidator', [\n    'WARNING_TYPES', 'baseInteractionValidationService',\n    function(WARNING_TYPES, baseInteractionValidationService) {\n  // Returns a list of warnings.\n  return function(stateName, customizationArgs, answerGroups, defaultOutcome) {\n    var VERTICES_LIMIT = 50;\n    var ISOMORPHISM_VERTICES_LIMIT = 10;\n\n    var warningsList = [];\n\n    baseInteractionValidationService.requireCustomizationArguments(\n      customizationArgs, ['graph', 'canEditEdgeWeight', 'canEditVertexLabel']);\n\n    if (customizationArgs.graph.value.vertices.length > VERTICES_LIMIT) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The graph used in customization exceeds supported ' +\n                 'maximum number of vertices of ' + VERTICES_LIMIT + '.'\n      });\n    }\n\n    if (!customizationArgs.graph.value.isWeighted &&\n        customizationArgs.canEditEdgeWeight.value) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The learner cannot edit edge weights for an unweighted graph.'\n      });\n    }\n\n    if (!customizationArgs.graph.value.isLabeled &&\n        customizationArgs.canEditVertexLabel.value) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The learner cannot edit vertex labels for an unlabeled graph.'\n      });\n    }\n\n    warningsList = warningsList.concat(\n      baseInteractionValidationService.getAllOutcomeWarnings(\n        answerGroups, defaultOutcome, stateName));\n    for (var i = 0; i < answerGroups.length; i++) {\n      var ruleSpecs = answerGroups[i].ruleSpecs;\n      for (var j = 0; j < ruleSpecs.length; j++) {\n        var ruleSpec = ruleSpecs[j];\n        try {\n          if (ruleSpec.rule_type === 'HasGraphProperty') {\n            continue;\n          } else if (ruleSpec.rule_type === 'IsIsomorphicTo' &&\n              ruleSpec.inputs.g.vertices.length > ISOMORPHISM_VERTICES_LIMIT) {\n            warningsList.push({\n              type: WARNING_TYPES.CRITICAL,\n              message: 'The graph used in the rule ' + (j + 1) +\n                       ' in group ' + (i + 1) +\n                       ' exceeds supported maximum number of vertices of ' +\n                        ISOMORPHISM_VERTICES_LIMIT + ' for isomorphism check.'\n            });\n          } else if (ruleSpec.inputs.g.vertices.length > VERTICES_LIMIT) {\n            warningsList.push({\n              type: WARNING_TYPES.CRITICAL,\n              message: 'The graph used in the rule ' + (j + 1) +\n                       ' in group ' + (i + 1) +\n                       ' exceeds supported maximum number of vertices of ' +\n                        VERTICES_LIMIT + '.'\n            });\n          }\n        }\n        catch (e) {\n          warningsList.push({\n            type: WARNING_TYPES.CRITICAL,\n            message: (\n              'The rule ' + (j + 1) +\n              ' in group ' + (i + 1) + ' is invalid.')\n          });\n        }\n      }\n    }\n    return warningsList;\n  };\n}]);\n"
    },
    {
      "filename": "extensions/interactions/GraphInput/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveGraphInputValidator', function() {\n  var WARNING_TYPES, validator;\n  var currentState, customizationArguments, answerGroups, goodDefaultOutcome;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n    validator = $injector.get('$filter')('oppiaInteractiveGraphInputValidator');\n\n    currentState = 'First State';\n    goodDefaultOutcome = {\n      dest: 'Second State',\n      feedback: []\n    };\n\n    customizationArguments = {\n      graph: {\n        value: {\n          vertices: new Array(10),\n          isWeighted: false,\n          isLabeled: false\n        }\n      },\n      canEditEdgeWeight: {\n        value: false\n      },\n      canEditVertexLabel: {\n        value: false\n      }\n    };\n\n    var answerGroup = {\n      outcome: goodDefaultOutcome,\n      ruleSpecs: [{\n        inputs: {\n          g: {\n            vertices: new Array(10)\n          }\n        },\n        rule_type: 'IsIsomorphicTo'\n      }, {\n        inputs: {\n          g: {\n            vertices: new Array(10)\n          }\n        },\n        rule_type: 'IsIsomorphicTo'\n      }]\n    };\n    answerGroups = [answerGroup, angular.copy(answerGroup)];\n  }));\n\n  it('should be able to perform basic validation', function() {\n    var warnings = validator(\n      currentState, customizationArguments, answerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([]);\n  });\n\n  it('should expect graph and edit customization arguments', function() {\n    expect(function() {\n      validator(currentState, {}, answerGroups, goodDefaultOutcome);\n    }).toThrow('Expected customization arguments to have properties: ' +\n      'graph, canEditEdgeWeight, canEditVertexLabel');\n  });\n\n  it('The graph used in customization exceeds supported maximum number of ' +\n    'vertices of 50.',\n    function() {\n      customizationArguments.graph.value.vertices = new Array(51);\n      var warnings = validator(\n        currentState, customizationArguments, answerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The graph used in customization exceeds supported maximum ' +\n          'number of vertices of 50.'\n      }]);\n    });\n\n  it('The graph used in the rule x in group y exceeds supported maximum ' +\n    'number of vertices of 10 for isomorphism check.',\n    function() {\n      answerGroups[0].ruleSpecs[0].inputs.g.vertices = new Array(11);\n      answerGroups[0].ruleSpecs[1].inputs.g.vertices = new Array(11);\n      answerGroups[1].ruleSpecs[0].inputs.g.vertices = new Array(11);\n      var warnings = validator(\n        currentState, customizationArguments, answerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The graph used in the rule 1 in group 1 exceeds supported ' +\n          'maximum number of vertices of 10 for isomorphism check.'\n      }, {\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The graph used in the rule 2 in group 1 exceeds supported ' +\n          'maximum number of vertices of 10 for isomorphism check.'\n      }, {\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The graph used in the rule 1 in group 2 exceeds supported ' +\n          'maximum number of vertices of 10 for isomorphism check.'\n      }]);\n    });\n\n  it('should verify edge weight edit permissions make sense', function() {\n    customizationArguments.graph.value.isWeighted = false;\n    customizationArguments.canEditEdgeWeight.value = true;\n    var warnings = validator(\n      currentState, customizationArguments, answerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([{\n      type: WARNING_TYPES.CRITICAL,\n      message: (\n        'The learner cannot edit edge weights for an unweighted graph.')\n    }]);\n  });\n\n  it('should verify vertex label edit permissions make sense', function() {\n    customizationArguments.graph.value.isLabeled = false;\n    customizationArguments.canEditVertexLabel.value = true;\n    var warnings = validator(\n      currentState, customizationArguments, answerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([{\n      type: WARNING_TYPES.CRITICAL,\n      message: (\n        'The learner cannot edit vertex labels for an unlabeled graph.')\n    }]);\n  });\n});\n"
    },
    {
      "filename": "extensions/interactions/ImageClickInput/validator.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Frontend validator for customization args and rules of\n * the interaction.\n */\n\noppia.filter('oppiaInteractiveImageClickInputValidator', [\n    '$filter', 'WARNING_TYPES', 'baseInteractionValidationService',\n    function($filter, WARNING_TYPES, baseInteractionValidationService) {\n  // Returns a list of warnings.\n  return function(stateName, customizationArgs, answerGroups, defaultOutcome) {\n    var warningsList = [];\n\n    baseInteractionValidationService.requireCustomizationArguments(\n      customizationArgs, ['imageAndRegions']);\n\n    if (!customizationArgs.imageAndRegions.value.imagePath) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please add an image for the learner to click on.'\n      });\n    }\n\n    var areAnyRegionStringsEmpty = false;\n    var areAnyRegionStringsDuplicated = false;\n    var seenRegionStrings = [];\n    if (customizationArgs.imageAndRegions.value.labeledRegions.length === 0) {\n      warningsList.push({\n        type: WARNING_TYPES.ERROR,\n        message: 'Please specify at least one image region to click on.'\n      });\n    }\n\n    for (var i = 0;\n         i < customizationArgs.imageAndRegions.value.labeledRegions.length;\n         i++) {\n      var regionLabel = (\n        customizationArgs.imageAndRegions.value.labeledRegions[i].label);\n\n      var ALPHANUMERIC_REGEX = /^[A-Za-z0-9]+$/;\n      if (regionLabel.trim().length === 0) {\n        areAnyRegionStringsEmpty = true;\n      } else if (!ALPHANUMERIC_REGEX.test(regionLabel)) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: (\n            'The image region strings should consist of characters from ' +\n            '[A-Za-z0-9].')\n        });\n      } else if (seenRegionStrings.indexOf(regionLabel) !== -1) {\n        areAnyRegionStringsDuplicated = true;\n      } else {\n        seenRegionStrings.push(regionLabel);\n      }\n    }\n\n    if (areAnyRegionStringsEmpty) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please ensure the image region strings are nonempty.'\n      });\n    }\n    if (areAnyRegionStringsDuplicated) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please ensure the image region strings are unique.'\n      });\n    }\n\n    warningsList = warningsList.concat(\n      baseInteractionValidationService.getAnswerGroupWarnings(\n        answerGroups, stateName));\n\n    // Check that each rule refers to a valid region string.\n    for (var i = 0; i < answerGroups.length; i++) {\n      var ruleSpecs = answerGroups[i].ruleSpecs;\n      for (var j = 0; j < ruleSpecs.length; j++) {\n        if (ruleSpecs[j].rule_type === 'IsInRegion') {\n          var label = ruleSpecs[j].inputs.x;\n          if (seenRegionStrings.indexOf(label) === -1) {\n            warningsList.push({\n              type: WARNING_TYPES.CRITICAL,\n              message: (\n                'The region label \\'' + label + '\\' in rule ' + String(j + 1) +\n                ' in group ' + String(i + 1) + ' is invalid.')\n            });\n          }\n        }\n      }\n    }\n\n    if (!defaultOutcome ||\n        $filter('isOutcomeConfusing')(defaultOutcome, stateName)) {\n      warningsList.push({\n        type: WARNING_TYPES.ERROR,\n        message: (\n          'Please add a rule to cover what should happen if none of the ' +\n          'given regions are clicked.')\n      });\n    }\n\n    return warningsList;\n  };\n}]);\n"
    },
    {
      "filename": "extensions/interactions/ImageClickInput/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveImageClickInputValidator', function() {\n  var WARNING_TYPES, validator;\n\n  var currentState;\n  var badOutcome, goodAnswerGroups, goodDefaultOutcome;\n  var customizationArguments;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    var filter = $injector.get('$filter');\n    validator = filter('oppiaInteractiveImageClickInputValidator');\n\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n\n    currentState = 'First State';\n    goodDefaultOutcome = {\n      dest: 'Second State',\n      feedback: []\n    };\n\n    badOutcome = {\n      dest: currentState,\n      feedback: []\n    };\n\n    customizationArguments = {\n      imageAndRegions: {\n        value: {\n          imagePath: '/path/to/image',\n          labeledRegions: [{\n            label: 'FirstLabel'\n          }, {\n            label: 'SecondLabel'\n          }]\n        }\n      }\n    };\n    goodAnswerGroups = [{\n      ruleSpecs: [{\n        rule_type: 'IsInRegion',\n        inputs: {\n          x: 'SecondLabel'\n        }\n      }],\n      outcome: goodDefaultOutcome\n    }];\n  }));\n\n  it('should expect a customization argument for image and regions',\n    function() {\n      goodAnswerGroups[0].ruleSpecs = [];\n      expect(function() {\n        validator(currentState, {}, goodAnswerGroups, goodDefaultOutcome);\n      }).toThrow(\n        'Expected customization arguments to have property: imageAndRegions');\n    });\n\n  it('should expect an image path customization argument', function() {\n    var warnings = validator(\n      currentState, customizationArguments, goodAnswerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([]);\n\n    customizationArguments.imageAndRegions.value.imagePath = '';\n    warnings = validator(\n      currentState, customizationArguments, goodAnswerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([{\n      type: WARNING_TYPES.CRITICAL,\n      message: 'Please add an image for the learner to click on.'\n    }]);\n  });\n\n  it('should expect labeled regions with non-empty, unique, and ' +\n    'alphanumeric labels',\n    function() {\n      var regions = customizationArguments.imageAndRegions.value.labeledRegions;\n      regions[0].label = '';\n      var warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please ensure the image region strings are nonempty.'\n      }]);\n\n      regions[0].label = 'SecondLabel';\n      warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please ensure the image region strings are unique.'\n      }]);\n\n      regions[0].label = '@';\n      warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'The image region strings should consist of characters ' +\n          'from [A-Za-z0-9].'\n      }]);\n\n      customizationArguments.imageAndRegions.value.labeledRegions = [];\n      goodAnswerGroups[0].ruleSpecs = [];\n      warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.ERROR,\n        message: 'Please specify at least one image region to click on.'\n      }]);\n    });\n\n  it('should expect rule types to reference valid region labels', function() {\n    goodAnswerGroups[0].ruleSpecs[0].inputs.x = 'FakeLabel';\n    var warnings = validator(\n      currentState, customizationArguments, goodAnswerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([{\n      type: WARNING_TYPES.CRITICAL,\n      message: 'The region label \\'FakeLabel\\' in rule 1 in group 1 is ' +\n        'invalid.'\n    }]);\n  });\n\n  it('should expect a non-confusing and non-null default outcome',\n    function() {\n      var warnings = validator(currentState, customizationArguments, [], null);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.ERROR,\n        message: 'Please add a rule to cover what should happen if none of ' +\n          'the given regions are clicked.'\n      }]);\n      warnings = validator(\n        currentState, customizationArguments, [], badOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.ERROR,\n        message: 'Please add a rule to cover what should happen if none of ' +\n          'the given regions are clicked.'\n      }]);\n    });\n});\n"
    },
    {
      "filename": "extensions/interactions/InteractiveMap/validator.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Frontend validator for customization args and rules of\n * the interaction.\n */\n\noppia.filter('oppiaInteractiveInteractiveMapValidator', [\n    'WARNING_TYPES', 'baseInteractionValidationService',\n    function(WARNING_TYPES, baseInteractionValidationService) {\n  // Returns a list of warnings.\n  return function(stateName, customizationArgs, answerGroups, defaultOutcome) {\n    var warningsList = [];\n\n    baseInteractionValidationService.requireCustomizationArguments(\n      customizationArgs, ['latitude', 'longitude']);\n\n    if (customizationArgs.latitude.value < -90 ||\n        customizationArgs.latitude.value > 90) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting latitude between -90 and 90.'\n      });\n    }\n\n    if (customizationArgs.longitude.value < -180 ||\n        customizationArgs.longitude.value > 180) {\n      warningsList.push({\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting longitude between -180 and 180.'\n      });\n    }\n\n    for (var i = 0; i < answerGroups.length; i++) {\n      var ruleSpecs = answerGroups[i].ruleSpecs;\n      for (var j = 0; j < ruleSpecs.length; j++) {\n        if (ruleSpecs[j].rule_type === 'Within' ||\n            ruleSpecs[j].rule_type === 'NotWithin') {\n          if (ruleSpecs[j].inputs.d < 0) {\n            warningsList.push({\n              type: WARNING_TYPES.CRITICAL,\n              message: 'Please ensure that rule ' + String(j + 1) +\n                ' in group ' + String(i + 1) + ' refers to a valid distance.'\n            });\n          }\n        }\n      }\n    }\n\n    warningsList = warningsList.concat(\n      baseInteractionValidationService.getAllOutcomeWarnings(\n        answerGroups, defaultOutcome, stateName));\n\n    return warningsList;\n  };\n}]);\n"
    },
    {
      "filename": "extensions/interactions/InteractiveMap/validatorSpec.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ndescribe('oppiaInteractiveInteractiveMapValidator', function() {\n  var validator, WARNING_TYPES;\n\n  var currentState;\n  var goodAnswerGroups, goodDefaultOutcome;\n  var customizationArguments;\n\n  beforeEach(function() {\n    module('oppia');\n  });\n\n  beforeEach(inject(function($rootScope, $controller, $injector) {\n    var filter = $injector.get('$filter');\n    validator = filter('oppiaInteractiveInteractiveMapValidator');\n    WARNING_TYPES = $injector.get('WARNING_TYPES');\n\n    currentState = 'First State';\n    goodDefaultOutcome = {\n      dest: 'Second State',\n      feedback: []\n    };\n\n    customizationArguments = {\n      latitude: {\n        value: 0\n      },\n      longitude: {\n        value: 0\n      }\n    };\n    goodAnswerGroups = [{\n      ruleSpecs: [{\n        rule_type: 'Within',\n        inputs: {\n          d: 100\n        }\n      }, {\n        rule_type: 'NotWithin',\n        inputs: {\n          d: 50\n        }\n      }],\n      outcome: goodDefaultOutcome\n    }];\n  }));\n\n  it('should be able to perform basic validation', function() {\n    var warnings = validator(\n      currentState, customizationArguments, goodAnswerGroups,\n      goodDefaultOutcome);\n    expect(warnings).toEqual([]);\n  });\n\n  it('should expect latitude and longitude customization arguments',\n    function() {\n      expect(function() {\n        validator(currentState, {}, goodAnswerGroups, goodDefaultOutcome);\n      }).toThrow('Expected customization arguments to have properties: ' +\n        'latitude, longitude');\n    }\n  );\n\n  it('should expect latitudes and longitudes within [-90, 90] and ' +\n    '[-180, 180], respectively',\n    function() {\n      customizationArguments.latitude.value = -120;\n      customizationArguments.longitude.value = 200;\n      var warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting latitude between -90 and 90.'\n      }, {\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting longitude between -180 and 180.'\n      }]);\n\n      customizationArguments.latitude.value = 120;\n      customizationArguments.longitude.value = -200;\n      warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting latitude between -90 and 90.'\n      }, {\n        type: WARNING_TYPES.CRITICAL,\n        message: 'Please pick a starting longitude between -180 and 180.'\n      }]);\n    }\n  );\n\n  it('should expect all rule types to refer to positive distances',\n    function() {\n      goodAnswerGroups[0].ruleSpecs[0].inputs.d = -90;\n      goodAnswerGroups[0].ruleSpecs[1].inputs.d = -180;\n      var warnings = validator(\n        currentState, customizationArguments, goodAnswerGroups,\n        goodDefaultOutcome);\n      expect(warnings).toEqual([{\n        type: WARNING_TYPES.CRITICAL,\n        message: (\n          'Please ensure that rule 1 in group 1 refers to a valid distance.')\n      }, {\n        type: WARNING_TYPES.CRITICAL,\n        message: (\n          'Please ensure that rule 2 in group 1 refers to a valid distance.')\n      }]);\n    }\n  );\n});\n"
    },
    {
      "filename": "extensions/interactions/ItemSelectionInput/validator.js",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Frontend validator for customization args and rules of\n * the interaction.\n */\n\noppia.filter('oppiaInteractiveItemSelectionInputValidator', [\n  '$filter', 'WARNING_TYPES', 'baseInteractionValidationService',\n  function($filter, WARNING_TYPES, baseInteractionValidationService) {\n    // Returns a list of warnings.\n    return function(\n        stateName, customizationArgs, answerGroups, defaultOutcome) {\n      var warningsList = [];\n\n      baseInteractionValidationService.requireCustomizationArguments(\n        customizationArgs, ['choices']);\n\n      var areAnyChoicesEmpty = false;\n      var areAnyChoicesDuplicated = false;\n      var seenChoices = [];\n      var handledAnswers = [];\n      var numChoices = customizationArgs.choices.value.length;\n      var areAllChoicesCovered = false;\n\n      for (var i = 0; i < numChoices; i++) {\n        var choice = customizationArgs.choices.value[i];\n        if (choice.trim().length === 0) {\n          areAnyChoicesEmpty = true;\n        }\n        if (seenChoices.indexOf(choice) !== -1) {\n          areAnyChoicesDuplicated = true;\n        }\n        seenChoices.push(choice);\n        handledAnswers.push(false);\n      }\n\n      if (areAnyChoicesEmpty) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: 'Please ensure the choices are nonempty.'\n        });\n      }\n\n      if (areAnyChoicesDuplicated) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: 'Please ensure the choices are unique.'\n        });\n      }\n\n      var minAllowedCount = customizationArgs.minAllowableSelectionCount.value;\n      var maxAllowedCount = customizationArgs.maxAllowableSelectionCount.value;\n\n      if (minAllowedCount > maxAllowedCount) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: (\n            'Please ensure that the max allowed count is not less than the ' +\n            'min count.')\n        });\n      }\n\n      if (numChoices < minAllowedCount) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: (\n            'Please ensure that you have enough choices to reach the min ' +\n            'count.')\n        });\n      } else if (numChoices < maxAllowedCount) {\n        warningsList.push({\n          type: WARNING_TYPES.CRITICAL,\n          message: (\n            'Please ensure that you have enough choices to reach the max ' +\n            'count.')\n        });\n      }\n\n      warningsList = warningsList.concat(\n        baseInteractionValidationService.getAnswerGroupWarnings(\n          answerGroups, stateName));\n\n      var selectedChoices = [];\n      if (maxAllowedCount === 1) {\n        var answerChoiceToIndex = {};\n        seenChoices.forEach(function(seenChoice, choiceIndex) {\n          answerChoiceToIndex[seenChoice] = choiceIndex;\n        });\n\n        answerGroups.forEach(function(answerGroup, answerIndex) {\n          var ruleSpecs = answerGroup.ruleSpecs;\n          ruleSpecs.forEach(function(ruleSpec, ruleIndex) {\n            var ruleInputs = ruleSpec.inputs.x;\n            ruleInputs.forEach(function(ruleInput) {\n              var choiceIndex = answerChoiceToIndex[ruleInput];\n              if (ruleSpec.rule_type === 'Equals') {\n                handledAnswers[choiceIndex] = true;\n                if (ruleInputs.length > 1) {\n                  warningsList.push({\n                    type: WARNING_TYPES.ERROR,\n                    message: (\n                      'In answer group ' + (answerIndex + 1) + ', ' +\n                      'rule ' + (ruleIndex + 1) + ', ' +\n                      'please select only one answer choice.')\n                  });\n                }\n              } else if (ruleSpec.rule_type === 'ContainsAtLeastOneOf') {\n                handledAnswers[choiceIndex] = true;\n              } else if (ruleSpec.rule_type ===\n                'DoesNotContainAtLeastOneOf') {\n                for (var i = 0; i < handledAnswers.length; i++) {\n                  if (i !== choiceIndex) {\n                    handledAnswers[i] = true;\n                  }\n                }\n              }\n            });\n          });\n        });\n        areAllChoicesCovered = handledAnswers.every(function(handledAnswer) {\n          return handledAnswer;\n        });\n      }\n\n      if (!areAllChoicesCovered) {\n        if (!defaultOutcome ||\n            $filter('isOutcomeConfusing')(defaultOutcome, stateName)) {\n          warningsList.push({\n            type: WARNING_TYPES.ERROR,\n            message: (\n              'Please clarify the default outcome so it is less confusing to ' +\n              'the user.')\n          });\n        }\n      }\n\n      return warningsList;\n    };\n  }\n]);\n"
    }
  ]
}