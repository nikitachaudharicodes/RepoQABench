{
  "repo_name": "oppia_oppia",
  "issue_id": "21301",
  "issue_description": "# [BUG]: Unable to add subject interests from profile preferences \n\n### Describe the bug\r\n\r\nUnable to add subject of interest from profile preferences, after typing in the \"subject interests\" field, save changes field is still disabled. When you change something else, click save changes, the subject of interest input is not saved.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/preferences\r\n\r\n### Steps To Reproduce\r\n\r\n1. Navigate to Preferences\r\n2. Type in the \"subject interests\" field\r\n\r\n### Expected Behavior\r\n\r\n\"save changes\" button becomes enabled\r\n\r\nWe should add a frontend or acceptance test for this flow to ensure it doesn't break again.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/user-attachments/assets/570a4c0f-ce0c-4b01-bce1-6aa6f439f605\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\nChrome 130.0.6723.91\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n",
  "issue_comments": [
    {
      "id": 2499612608,
      "user": "mdodab",
      "body": "I checked out the latest commit and found that the issue still exists. The ‘Save Changes’ button is disabled when Subject Interests is entered.  I found that feature request #19216 was implemented to change the preference page from auto-save to a fixed-save bar at the bottom of the page in March 15, 2024.  Later a commit was made 3 months ago under [#20374](https://github.com/oppia/oppia/commit/1fb7160f178c54bb8407ffd9c74a9b79f3c6079c). This made changes to \"core/templates/pages/preferences-page/preferences-page.component.html\" and \"core/templates/pages/preferences-page/preferences-page.component.ts\" which I believe caused the issue. I am suspecting that the save button stays disabled because preferencesForm.dirty is not set to true when subject-interests changes. I would like to work on this issue and am trying to fix it in my local dev server, but please let me know if I am headed in the right direction to solve this."
    },
    {
      "id": 2499615481,
      "user": "seanlip",
      "body": "Thanks @mdodab. I think you're looking at the right places, but please do try this out locally and demonstrate that you've managed to root-cause and fix the issue (ideally with a video and a clear statement of what lines in the code are causing the breakage), and we can give you more feedback on whether the implementation is along the right lines. \r\n\r\nAlso, one note -- let's make sure to add a frontend or acceptance test for this flow to ensure it doesn't break again. I have added a note in the original issue about this.\r\n\r\nThanks!"
    },
    {
      "id": 2502348068,
      "user": "mdodab",
      "body": "Thanks @seanlip ! I would like to run acceptance test for this flow -- especially core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts where it is testing the update of user's subject interest by deliberately pressing 'enter'. How do I go about running this acceptance test? I am running make run_tests.acceptance PYTHON_ARGS=\"--skip-build\" but is there a way to just run one acceptance test for the preference page?"
    },
    {
      "id": 2502381101,
      "user": "samirkh1",
      "body": "I'm wondering if this is even a bug at all? It seems like when enter is pressed after entering each subject of interest, the save changes appears."
    },
    {
      "id": 2502454136,
      "user": "mdodab",
      "body": "hi samirkh1, If enter is pressed  after typing subject interest there is no issue. Only when the subject interest is typed and moved off the field by hitting tab then the other fields will be saved but not the subject interest."
    },
    {
      "id": 2503242632,
      "user": "seanlip",
      "body": "> Thanks @seanlip ! I would like to run acceptance test for this flow -- especially core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts where it is testing the update of user's subject interest by deliberately pressing 'enter'. How do I go about running this acceptance test? I am running make run_tests.acceptance PYTHON_ARGS=\"--skip-build\" but is there a way to just run one acceptance test for the preference page?\r\n\r\nDo these instructions work for you? https://github.com/oppia/oppia/wiki/Acceptance-Tests#how-to-run-the-acceptance-tests\r\n\r\n(Note that, in general, you can find a lot of info on our wiki.)"
    },
    {
      "id": 2509542556,
      "user": "Vineet1101",
      "body": "@seanlip i would like to work on the issue is it still there???"
    },
    {
      "id": 2509578025,
      "user": "seanlip",
      "body": "@Vineet1101 It is still open. But, per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 2509974280,
      "user": "mdodab",
      "body": "I have a fix for this issue implemented and working on my local! Will provide necessary details of what I changed as outlined by the guidance document shortly. "
    },
    {
      "id": 2510048808,
      "user": "mdodab",
      "body": "@seanlip \r\nMy PR modifies the two following files:  /core/templates/pages/preferences-page/subject-interests.component.ts and /core/templates/pages/preferences-page/subject-interests.html\r\n\r\nAfter typing the entry in the subject interest field, when the user moves to another field or directly hits enter, the value entered by the user will be captured. This is done by introducing an addOnBlur() function. To enable the Save button when subject interest is entered, onChange() is called from the add() method.\r\n\r\nDiff  in /core/templates/pages/preferences-page/form-fields/subject-interests.component.ts\r\n99d98\r\n<       this.onChange(this.subjectInterests);\r\n128,136d126\r\n<   addOnBlur(inputElement: HTMLInputElement): void {\r\n<     const inputValue = inputElement.value.trim();\r\n<     if (inputValue) {\r\n<       this.subjectInterests.push(inputValue);\r\n<       inputElement.value = ''; // Clear the input field\r\n<       this.formCtrl.setValue(''); // Reset form control\r\n<     }\r\n<   }\r\n\r\nDiff in /core/templates/pages/preferences-page/form-fields/subject-interests.component.html\r\n24d23\r\n<            (blur)=\"addOnBlur(subjectInterestInput)\"\r\n\r\nScreen recording of working solution on my local is shown below:\r\n\r\n\r\nhttps://github.com/user-attachments/assets/d421a343-b02f-499a-8a15-e6220b62e95d\r\n\r\n\r\nCan you please assign this issue to me?\r\n"
    },
    {
      "id": 2510845445,
      "user": "JayanthK007",
      "body": "@seanlip I have changed the code the code in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` as below\r\n`onBlur(): void {\r\n  const value = this.subjectInterestInput.nativeElement.value.trim();\r\n  if (value && this.validInput(value)) {\r\n    // Add the current value to the list of subject interests.\r\n    this.subjectInterests.push(value);\r\n    this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n  }\r\n  this.onChange(this.subjectInterests);\r\n  \r\n}` and `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` as `(blur)=\"onBlur()\" `\r\n\r\nbelow is the screen recording.\r\n\r\nhttps://github.com/user-attachments/assets/42e1d841-4306-4aa7-a0a8-b80830eaf161\r\n\r\n"
    },
    {
      "id": 2511130017,
      "user": "seanlip",
      "body": "@mdodab @JayanthK007 Thanks for your notes. I have a question for both of you. What exactly is the root cause of the original issue? Please explain with references to the existing codebase -- we should not attempt a fix without properly understanding that.\r\n\r\nAlso @mdodab I can't see your video.\r\n\r\nFinally, @mdodab @JayanthK007 when creating a video, please follow exactly the same steps as what the original issue author did. Otherwise it's hard to determine whether you have actually solved the problem. Thanks."
    },
    {
      "id": 2511648717,
      "user": "mdodab",
      "body": "The root is that the existing codebase only handles conditions where the user presses enter key after inputting their subject interests. Line 53 of /oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts sets the SeparatorKeyCodes: number[] = Enter , meaning that enter is the only condition in which an add event is triggered. Clicking enter appends to the array, which saves to memory once the save button is clicked. \r\n\r\nThe existing codebase has no corresponding code to handle conditions in which the user enters their subject interest and then loses focus,  which happens when the user types the subject interest and moves away from the field (without pressing enter key). Because the existing code is only set to detect a change when the enter button is clicked, the save button stays disabled when the subject simply loses focus by clicking or tabbing away. \r\n\r\nAdditionally, the /core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts only has a test for the subject interest field that tests if subject interests are saved after hitting the enter key. This is likely why this issue was not caught earlier. I have pasted it below for your convenience.\r\n\r\n  /**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n  async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      await this.page.keyboard.press('Enter');\r\n    }\r\n  }\r\n\r\nMy fix enables the save button when the user loses focus (clicking on other fields, saving right away, hitting the tab key) after entering their new subject interests. It also saves it. I will look into the video and emulate the same steps as what the original author did. Could I be assigned this issue?\r\n"
    },
    {
      "id": 2511713605,
      "user": "mdodab",
      "body": "\r\nhttps://github.com/user-attachments/assets/b18145ba-33c9-444f-9313-27226204490f\r\n\r\n"
    },
    {
      "id": 2514477057,
      "user": "Atharva7115",
      "body": "Hii @seanlip  , I have tried to resolve the issue  and i want to check whether the issue in resolved or not .\r\nCan you please help me  with how can I run and check the webpage is which issue is there,"
    },
    {
      "id": 2515864755,
      "user": "JayanthK007",
      "body": "Hi @seanlip when doing migration #13219 the enter key logic was added. How it behaves is when anything is entered in subject interest field and pressed enter then the Performcontrol.dirty becomes true and save button would be enabled. This was the previous logic.\r\n\r\nWhat I have made changes is when we start typing in the subject interest field. The button becomes enabled. Even if we don't press enter in the subject interest field , the value is saved for this OnBlur event listener I have added .\r\n\r\nin `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` I have added ```(blur)=\"onBlur()\"\r\n           (input)=\"onInput($event)\">\r\n``` and in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` I have added below functions.\r\n\r\n```typescript\r\nonBlur(): void {\r\n    const value = this.subjectInterestInput.nativeElement.value.trim();\r\n    if (value && this.validInput(value)) {\r\n        // Add the current value to the list of subject interests.\r\n        this.subjectInterests.push(value);\r\n        this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n    }\r\n    this.onChange(this.subjectInterests);\r\n}\r\n\r\nonInput(event: Event): void {\r\n    const inputElement = event.target as HTMLInputElement;\r\n    const inputValue = inputElement.value.trim();\r\n    // Check if input is empty or valid\r\n    if (!inputValue) {\r\n        this.formCtrl.markAsPristine(); // Mark control as not dirty\r\n    } else if (this.validInput(inputValue)) {\r\n        this.formCtrl.markAsDirty(); // Mark control as dirty\r\n    }\r\n    // Update the parent form (if applicable)\r\n    this.onChange(this.subjectInterests);\r\n}\r\n```\r\n\r\nBelow is the video recording of what changes I have made.\r\n\r\n\r\nhttps://github.com/user-attachments/assets/c56bd190-866b-43f0-b2f0-c0f4d44c2473\r\n\r\nCan you please assign this to me? @seanlip \r\n"
    },
    {
      "id": 2518129460,
      "user": "seanlip",
      "body": "Hi @mdodab @JayanthK007, firstly, thanks for outlining your solutions to the issue. Both seem like reasonable approaches and I appreciate that you've taken the time to look at the issue and find a good fix that works on your machine. \r\n\r\nThere is one more thing I need to check. We need to add a frontend/acceptance test to ensure this doesn't happen again. What is your proposal for where to add that test -- what code will you modify and can you show it working locally on your machine?\r\n\r\nAlso, unfortunately, I can only assign this issue to one of you, so this means that there's a chance one of your efforts will not result in being assigned -- sorry about that in advance. My intention is to assign this to the first person who gives a valid answer to the testing question (which was stated in the issue description but not really addressed AFAICT)."
    },
    {
      "id": 2518800802,
      "user": "JayanthK007",
      "body": "Hi @seanlip. My testing approach is in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` when the user enters the subject interests before it was checking until ENTER key is pressed, what I have changed is to move to other focus for example save button. Below are the changes I have made.\r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n```\r\n\r\nwhen subject interest is added it is saved and again focus is made on the subject interest field. Then, another interest is added if there is any, and then it is saved again. \r\n\r\nI think this approach works. Does this answer your previous question? @seanlip "
    },
    {
      "id": 2519771180,
      "user": "seanlip",
      "body": "Thanks @JayanthK007, I think that seems reasonable. One suggestion: maybe you could have two functions, updateSubjectInterestsWithEnterKey and updateSubjectInterestsByBlurringField. Then call both from the top-level, one after the other. Does that sound good?\r\n\r\nAlso, I am assigning this issue to you. Thank you for the clear explanations!"
    },
    {
      "id": 2521784617,
      "user": "JayanthK007",
      "body": "Hi @seanlip According to your guidelines i have added two functions in `oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts` page .\r\n\r\n```Typescript\r\n      await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n      await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n\r\n      await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n```\r\nand in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` page \r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.\r\n   */\r\n  async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      await this.page.keyboard.press('Enter');\r\n    }\r\n  }\r\n\r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.\r\n   */\r\n  async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n  \r\n```\r\n\r\nIs this fine? @seanlip \r\n"
    },
    {
      "id": 2521916655,
      "user": "seanlip",
      "body": "Not totally sure about using the page's save button in particular to take\r\nfocus away if the idea is to add another tag after that, since presumably a\r\nuser won't do that. Let's try to keep the acceptance tests to what users\r\nwould generally do.\r\n\r\nBut otherwise looks generally fine I think, feel free to make a PR and we\r\ncan have more specific discussion during the review phase. Thanks!\r\n\r\nOn Fri, Dec 6, 2024, 08:09 JayanthKumar Karthik ***@***.***>\r\nwrote:\r\n\r\n> Hi @seanlip <https://github.com/seanlip> According to your guidelines i\r\n> have added two functions in\r\n> oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts\r\n> page .\r\n>\r\n>       await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n>       await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n>\r\n>       await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n>\r\n> and in\r\n> oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts\r\n> page\r\n>\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.   */\r\n>   async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       await this.page.keyboard.press('Enter');\r\n>     }\r\n>   }\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.   */\r\n>   async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       // Focus and type in the subject interest input field\r\n>       await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       // Click on the save button to trigger onBlur\r\n>       await this.page.click('.e2e-test-save-changes-button');\r\n>     }\r\n>   }\r\n>\r\n> Is this fine? @seanlip <https://github.com/seanlip>\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oppia/oppia/issues/21301#issuecomment-2521784617>, or\r\n> unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ACQV5SQJHTHUQZVHFT2OR7T2EDTNBAVCNFSM6AAAAABSDPHJ4WVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDKMRRG44DINRRG4>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n"
    },
    {
      "id": 2614008518,
      "user": "HardikGoyal2003",
      "body": "Unassigning @JayanthK007 Due to inactivity."
    },
    {
      "id": 2647073283,
      "user": "HardikGoyal2003",
      "body": "Closing this issue as fixed by https://github.com/oppia/oppia/pull/21820"
    }
  ],
  "text_context": "# [BUG]: Unable to add subject interests from profile preferences \n\n### Describe the bug\r\n\r\nUnable to add subject of interest from profile preferences, after typing in the \"subject interests\" field, save changes field is still disabled. When you change something else, click save changes, the subject of interest input is not saved.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/preferences\r\n\r\n### Steps To Reproduce\r\n\r\n1. Navigate to Preferences\r\n2. Type in the \"subject interests\" field\r\n\r\n### Expected Behavior\r\n\r\n\"save changes\" button becomes enabled\r\n\r\nWe should add a frontend or acceptance test for this flow to ensure it doesn't break again.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/user-attachments/assets/570a4c0f-ce0c-4b01-bce1-6aa6f439f605\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\nChrome 130.0.6723.91\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!\r\n\n\nI checked out the latest commit and found that the issue still exists. The ‘Save Changes’ button is disabled when Subject Interests is entered.  I found that feature request #19216 was implemented to change the preference page from auto-save to a fixed-save bar at the bottom of the page in March 15, 2024.  Later a commit was made 3 months ago under [#20374](https://github.com/oppia/oppia/commit/1fb7160f178c54bb8407ffd9c74a9b79f3c6079c). This made changes to \"core/templates/pages/preferences-page/preferences-page.component.html\" and \"core/templates/pages/preferences-page/preferences-page.component.ts\" which I believe caused the issue. I am suspecting that the save button stays disabled because preferencesForm.dirty is not set to true when subject-interests changes. I would like to work on this issue and am trying to fix it in my local dev server, but please let me know if I am headed in the right direction to solve this.\n\nThanks @mdodab. I think you're looking at the right places, but please do try this out locally and demonstrate that you've managed to root-cause and fix the issue (ideally with a video and a clear statement of what lines in the code are causing the breakage), and we can give you more feedback on whether the implementation is along the right lines. \r\n\r\nAlso, one note -- let's make sure to add a frontend or acceptance test for this flow to ensure it doesn't break again. I have added a note in the original issue about this.\r\n\r\nThanks!\n\nThanks @seanlip ! I would like to run acceptance test for this flow -- especially core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts where it is testing the update of user's subject interest by deliberately pressing 'enter'. How do I go about running this acceptance test? I am running make run_tests.acceptance PYTHON_ARGS=\"--skip-build\" but is there a way to just run one acceptance test for the preference page?\n\nI'm wondering if this is even a bug at all? It seems like when enter is pressed after entering each subject of interest, the save changes appears.\n\nhi samirkh1, If enter is pressed  after typing subject interest there is no issue. Only when the subject interest is typed and moved off the field by hitting tab then the other fields will be saved but not the subject interest.\n\n> Thanks @seanlip ! I would like to run acceptance test for this flow -- especially core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts where it is testing the update of user's subject interest by deliberately pressing 'enter'. How do I go about running this acceptance test? I am running make run_tests.acceptance PYTHON_ARGS=\"--skip-build\" but is there a way to just run one acceptance test for the preference page?\r\n\r\nDo these instructions work for you? https://github.com/oppia/oppia/wiki/Acceptance-Tests#how-to-run-the-acceptance-tests\r\n\r\n(Note that, in general, you can find a lot of info on our wiki.)\n\n@seanlip i would like to work on the issue is it still there???\n\n@Vineet1101 It is still open. But, per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nI have a fix for this issue implemented and working on my local! Will provide necessary details of what I changed as outlined by the guidance document shortly. \n\n@seanlip \r\nMy PR modifies the two following files:  /core/templates/pages/preferences-page/subject-interests.component.ts and /core/templates/pages/preferences-page/subject-interests.html\r\n\r\nAfter typing the entry in the subject interest field, when the user moves to another field or directly hits enter, the value entered by the user will be captured. This is done by introducing an addOnBlur() function. To enable the Save button when subject interest is entered, onChange() is called from the add() method.\r\n\r\nDiff  in /core/templates/pages/preferences-page/form-fields/subject-interests.component.ts\r\n99d98\r\n<       this.onChange(this.subjectInterests);\r\n128,136d126\r\n<   addOnBlur(inputElement: HTMLInputElement): void {\r\n<     const inputValue = inputElement.value.trim();\r\n<     if (inputValue) {\r\n<       this.subjectInterests.push(inputValue);\r\n<       inputElement.value = ''; // Clear the input field\r\n<       this.formCtrl.setValue(''); // Reset form control\r\n<     }\r\n<   }\r\n\r\nDiff in /core/templates/pages/preferences-page/form-fields/subject-interests.component.html\r\n24d23\r\n<            (blur)=\"addOnBlur(subjectInterestInput)\"\r\n\r\nScreen recording of working solution on my local is shown below:\r\n\r\n\r\nhttps://github.com/user-attachments/assets/d421a343-b02f-499a-8a15-e6220b62e95d\r\n\r\n\r\nCan you please assign this issue to me?\r\n\n\n@seanlip I have changed the code the code in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` as below\r\n`onBlur(): void {\r\n  const value = this.subjectInterestInput.nativeElement.value.trim();\r\n  if (value && this.validInput(value)) {\r\n    // Add the current value to the list of subject interests.\r\n    this.subjectInterests.push(value);\r\n    this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n  }\r\n  this.onChange(this.subjectInterests);\r\n  \r\n}` and `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` as `(blur)=\"onBlur()\" `\r\n\r\nbelow is the screen recording.\r\n\r\nhttps://github.com/user-attachments/assets/42e1d841-4306-4aa7-a0a8-b80830eaf161\r\n\r\n\n\n@mdodab @JayanthK007 Thanks for your notes. I have a question for both of you. What exactly is the root cause of the original issue? Please explain with references to the existing codebase -- we should not attempt a fix without properly understanding that.\r\n\r\nAlso @mdodab I can't see your video.\r\n\r\nFinally, @mdodab @JayanthK007 when creating a video, please follow exactly the same steps as what the original issue author did. Otherwise it's hard to determine whether you have actually solved the problem. Thanks.\n\nThe root is that the existing codebase only handles conditions where the user presses enter key after inputting their subject interests. Line 53 of /oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts sets the SeparatorKeyCodes: number[] = Enter , meaning that enter is the only condition in which an add event is triggered. Clicking enter appends to the array, which saves to memory once the save button is clicked. \r\n\r\nThe existing codebase has no corresponding code to handle conditions in which the user enters their subject interest and then loses focus,  which happens when the user types the subject interest and moves away from the field (without pressing enter key). Because the existing code is only set to detect a change when the enter button is clicked, the save button stays disabled when the subject simply loses focus by clicking or tabbing away. \r\n\r\nAdditionally, the /core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts only has a test for the subject interest field that tests if subject interests are saved after hitting the enter key. This is likely why this issue was not caught earlier. I have pasted it below for your convenience.\r\n\r\n  /**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n  async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      await this.page.keyboard.press('Enter');\r\n    }\r\n  }\r\n\r\nMy fix enables the save button when the user loses focus (clicking on other fields, saving right away, hitting the tab key) after entering their new subject interests. It also saves it. I will look into the video and emulate the same steps as what the original author did. Could I be assigned this issue?\r\n\n\n\r\nhttps://github.com/user-attachments/assets/b18145ba-33c9-444f-9313-27226204490f\r\n\r\n\n\nHii @seanlip  , I have tried to resolve the issue  and i want to check whether the issue in resolved or not .\r\nCan you please help me  with how can I run and check the webpage is which issue is there,\n\nHi @seanlip when doing migration #13219 the enter key logic was added. How it behaves is when anything is entered in subject interest field and pressed enter then the Performcontrol.dirty becomes true and save button would be enabled. This was the previous logic.\r\n\r\nWhat I have made changes is when we start typing in the subject interest field. The button becomes enabled. Even if we don't press enter in the subject interest field , the value is saved for this OnBlur event listener I have added .\r\n\r\nin `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` I have added ```(blur)=\"onBlur()\"\r\n           (input)=\"onInput($event)\">\r\n``` and in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` I have added below functions.\r\n\r\n```typescript\r\nonBlur(): void {\r\n    const value = this.subjectInterestInput.nativeElement.value.trim();\r\n    if (value && this.validInput(value)) {\r\n        // Add the current value to the list of subject interests.\r\n        this.subjectInterests.push(value);\r\n        this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n    }\r\n    this.onChange(this.subjectInterests);\r\n}\r\n\r\nonInput(event: Event): void {\r\n    const inputElement = event.target as HTMLInputElement;\r\n    const inputValue = inputElement.value.trim();\r\n    // Check if input is empty or valid\r\n    if (!inputValue) {\r\n        this.formCtrl.markAsPristine(); // Mark control as not dirty\r\n    } else if (this.validInput(inputValue)) {\r\n        this.formCtrl.markAsDirty(); // Mark control as dirty\r\n    }\r\n    // Update the parent form (if applicable)\r\n    this.onChange(this.subjectInterests);\r\n}\r\n```\r\n\r\nBelow is the video recording of what changes I have made.\r\n\r\n\r\nhttps://github.com/user-attachments/assets/c56bd190-866b-43f0-b2f0-c0f4d44c2473\r\n\r\nCan you please assign this to me? @seanlip \r\n\n\nHi @mdodab @JayanthK007, firstly, thanks for outlining your solutions to the issue. Both seem like reasonable approaches and I appreciate that you've taken the time to look at the issue and find a good fix that works on your machine. \r\n\r\nThere is one more thing I need to check. We need to add a frontend/acceptance test to ensure this doesn't happen again. What is your proposal for where to add that test -- what code will you modify and can you show it working locally on your machine?\r\n\r\nAlso, unfortunately, I can only assign this issue to one of you, so this means that there's a chance one of your efforts will not result in being assigned -- sorry about that in advance. My intention is to assign this to the first person who gives a valid answer to the testing question (which was stated in the issue description but not really addressed AFAICT).\n\nHi @seanlip. My testing approach is in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` when the user enters the subject interests before it was checking until ENTER key is pressed, what I have changed is to move to other focus for example save button. Below are the changes I have made.\r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n```\r\n\r\nwhen subject interest is added it is saved and again focus is made on the subject interest field. Then, another interest is added if there is any, and then it is saved again. \r\n\r\nI think this approach works. Does this answer your previous question? @seanlip \n\nThanks @JayanthK007, I think that seems reasonable. One suggestion: maybe you could have two functions, updateSubjectInterestsWithEnterKey and updateSubjectInterestsByBlurringField. Then call both from the top-level, one after the other. Does that sound good?\r\n\r\nAlso, I am assigning this issue to you. Thank you for the clear explanations!\n\nHi @seanlip According to your guidelines i have added two functions in `oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts` page .\r\n\r\n```Typescript\r\n      await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n      await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n\r\n      await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n```\r\nand in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` page \r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.\r\n   */\r\n  async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      await this.page.keyboard.press('Enter');\r\n    }\r\n  }\r\n\r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.\r\n   */\r\n  async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n  \r\n```\r\n\r\nIs this fine? @seanlip \r\n\n\nNot totally sure about using the page's save button in particular to take\r\nfocus away if the idea is to add another tag after that, since presumably a\r\nuser won't do that. Let's try to keep the acceptance tests to what users\r\nwould generally do.\r\n\r\nBut otherwise looks generally fine I think, feel free to make a PR and we\r\ncan have more specific discussion during the review phase. Thanks!\r\n\r\nOn Fri, Dec 6, 2024, 08:09 JayanthKumar Karthik ***@***.***>\r\nwrote:\r\n\r\n> Hi @seanlip <https://github.com/seanlip> According to your guidelines i\r\n> have added two functions in\r\n> oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts\r\n> page .\r\n>\r\n>       await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n>       await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n>\r\n>       await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n>\r\n> and in\r\n> oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts\r\n> page\r\n>\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.   */\r\n>   async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       await this.page.keyboard.press('Enter');\r\n>     }\r\n>   }\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.   */\r\n>   async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       // Focus and type in the subject interest input field\r\n>       await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       // Click on the save button to trigger onBlur\r\n>       await this.page.click('.e2e-test-save-changes-button');\r\n>     }\r\n>   }\r\n>\r\n> Is this fine? @seanlip <https://github.com/seanlip>\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oppia/oppia/issues/21301#issuecomment-2521784617>, or\r\n> unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ACQV5SQJHTHUQZVHFT2OR7T2EDTNBAVCNFSM6AAAAABSDPHJ4WVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDKMRRG44DINRRG4>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n\n\nUnassigning @JayanthK007 Due to inactivity.\n\nClosing this issue as fixed by https://github.com/oppia/oppia/pull/21820",
  "pr_link": "https://github.com/oppia/oppia/pull/21820",
  "code_context": [
    {
      "filename": "core/templates/pages/preferences-page/form-fields/subject-interests.component.html",
      "content": "<mat-form-field class=\"subject-interests-chip-list\" appearance=\"fill\">\n  <mat-label class=\"text-capitalize\">\n    {{ 'I18N_PREFERENCES_SUBJECT_INTERESTS' | translate }}\n  </mat-label>\n  <mat-chip-list #chipList role=\"textbox\">\n    <mat-chip *ngFor=\"let subjectInterest of subjectInterests\"\n              [selectable]=\"selectable\"\n              [removable]=\"removable\"\n              tabindex=\"-1\"\n              (removed)=\"remove(subjectInterest)\">\n      <span tabindex=\"0\" [attr.aria-label]=\" subjectInterest+ '. selected'\">{{ subjectInterest }}</span>\n      <button class=\"oppia-cancel-button\" tabindex=\"0\" matChipRemove aria-label=\". Remove\" *ngIf=\"removable\">\n        <mat-icon class=\"oppia-cancel-button-text\">cancel</mat-icon>\n      </button>\n    </mat-chip>\n    <input placeholder=\"{{ 'I18N_PREFERENCES_SUBJECT_INTERESTS_LABEL' | translate }}\"\n           class=\"e2e-test-subject-interests-input\"\n           aria-label=\"New subject interests\"\n           #subjectInterestInput\n           [formControl]=\"formCtrl\"\n           [matAutocomplete]=\"auto\"\n           [matChipInputFor]=\"chipList\"\n           [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\"\n           (matChipInputTokenEnd)=\"add($event)\"\n           (blur)=\"onBlur()\"\n           (input)=\"onInput($event)\">\n  </mat-chip-list>\n  <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"selected($event)\">\n    <mat-option *ngFor=\"let subjectInterest of filteredSubjectInterests | async\" [value]=\"subjectInterest\">\n      {{ subjectInterest }}\n    </mat-option>\n  </mat-autocomplete>\n  <mat-error>\n    {{ 'I18N_PREFERENCES_SUBJECT_INTERESTS_ERROR_TEXT' | translate }}\n  </mat-error>\n</mat-form-field>\n\n<style>\n  .subject-interests-chip-list {\n    width: 100%;\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/preferences-page/form-fields/subject-interests.component.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the subject interests component.\n */\n\nimport {ElementRef} from '@angular/core';\nimport {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\nimport {MaterialModule} from 'modules/material.module';\nimport {MockTranslatePipe} from 'tests/unit-test-utils';\nimport {SubjectInterestsComponent} from './subject-interests.component';\n\ndescribe('Subject interests form field Component', () => {\n  let componentInstance: SubjectInterestsComponent;\n  let fixture: ComponentFixture<SubjectInterestsComponent>;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        BrowserAnimationsModule,\n        MaterialModule,\n        FormsModule,\n        ReactiveFormsModule,\n      ],\n      declarations: [MockTranslatePipe, SubjectInterestsComponent],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(SubjectInterestsComponent);\n    componentInstance = fixture.componentInstance;\n  });\n\n  it('should be defined', () => {\n    expect(componentInstance).toBeDefined();\n  });\n\n  it('should initialize', () => {\n    fixture.detectChanges();\n    let input = '';\n    componentInstance.subjectInterests = ['math'];\n    componentInstance.formCtrl = {\n      valueChanges: {\n        subscribe: (callb: (value: string) => void) => {\n          callb(input);\n        },\n      },\n    } as FormControl;\n    componentInstance.ngOnInit();\n    input = 'math';\n    componentInstance.formCtrl = {\n      valueChanges: {\n        subscribe(callb: (val: string) => void) {\n          callb(input);\n        },\n      },\n    } as FormControl;\n    componentInstance.ngOnInit();\n    expect(componentInstance.allSubjectInterests).toEqual(\n      componentInstance.subjectInterests\n    );\n  });\n\n  it('should validate input', () => {\n    componentInstance.subjectInterests = [];\n    expect(componentInstance.isValidInput('math')).toBeTrue();\n  });\n\n  it('should add subject interest', () => {\n    spyOn(componentInstance, 'onChange');\n    spyOn(componentInstance, 'isValidInput').and.returnValue(true);\n    componentInstance.subjectInterests = [];\n    componentInstance.allSubjectInterests = [];\n    componentInstance.subjectInterestInput = {\n      nativeElement: {\n        value: '',\n      },\n    } as ElementRef;\n    componentInstance.add({value: 'math'});\n    componentInstance.add({value: ''});\n    expect(componentInstance.onChange).toHaveBeenCalled();\n    expect(componentInstance.subjectInterests).toEqual(['math']);\n    expect(componentInstance.allSubjectInterests).toEqual(['math']);\n  });\n\n  it('should remove subject interest', () => {\n    componentInstance.subjectInterests = ['math'];\n    componentInstance.allSubjectInterests = ['math'];\n    componentInstance.remove('math');\n    expect(componentInstance.subjectInterests).toEqual([]);\n  });\n\n  it('should handle when user selects a subject interest', () => {\n    spyOn(componentInstance, 'add');\n    spyOn(componentInstance, 'remove');\n    componentInstance.subjectInterests = ['math'];\n    componentInstance.selected({option: {value: 'math'}});\n    expect(componentInstance.remove).toHaveBeenCalled();\n    expect(componentInstance.add).not.toHaveBeenCalled();\n    componentInstance.subjectInterests = [];\n    componentInstance.selected({option: {value: 'math'}});\n    expect(componentInstance.add).toHaveBeenCalled();\n  });\n\n  it('should filter interests', () => {\n    componentInstance.allSubjectInterests = ['math'];\n    expect(componentInstance.filter('math')).toEqual(['math']);\n    expect(componentInstance.filter('art')).toEqual([]);\n  });\n\n  it('should write value', () => {\n    const interests = ['math', 'art'];\n    componentInstance.writeValue(interests);\n    expect(componentInstance.subjectInterests).toEqual(interests);\n  });\n\n  it('should register onChange function', () => {\n    const fn = (value: string[]) => {};\n    componentInstance.registerOnChange(fn);\n    expect(componentInstance.onChange).toBe(fn);\n  });\n\n  it('should register onTouched function', () => {\n    const fn = () => {};\n    componentInstance.registerOnTouched(fn);\n    expect(componentInstance.onTouched).toBe(fn);\n  });\n\n  it('should handle blur event correctly', () => {\n    spyOn(componentInstance, 'onChange');\n    spyOn(componentInstance, 'isValidInput').and.returnValue(true);\n    componentInstance.subjectInterests = [];\n    componentInstance.subjectInterestInput = {\n      nativeElement: {\n        value: 'math',\n      },\n    } as ElementRef;\n    componentInstance.onBlur();\n    expect(componentInstance.isValidInput).toHaveBeenCalledWith('math');\n    expect(componentInstance.subjectInterests).toEqual(['math']);\n    expect(componentInstance.subjectInterestInput.nativeElement.value).toBe('');\n    expect(componentInstance.onChange).toHaveBeenCalledWith(['math']);\n  });\n\n  it('should handle input event correctly', () => {\n    spyOn(componentInstance, 'onChange');\n    spyOn(componentInstance, 'isValidInput').and.returnValue(true);\n    componentInstance.formCtrl = new FormControl();\n    const inputEvent = {\n      target: {\n        value: 'math',\n      },\n    } as unknown as Event;\n    componentInstance.onInput(inputEvent);\n    expect(componentInstance.isValidInput).toHaveBeenCalledWith('math');\n    expect(componentInstance.formCtrl.dirty).toBeTrue();\n    expect(componentInstance.onChange).toHaveBeenCalledWith([]);\n  });\n\n  it('should mark input as pristine when input is empty', () => {\n    spyOn(componentInstance, 'onChange');\n    componentInstance.formCtrl = new FormControl();\n    const inputEvent = {\n      target: {\n        value: '',\n      },\n    } as unknown as Event;\n    componentInstance.onInput(inputEvent);\n    expect(componentInstance.formCtrl.pristine).toBeTrue();\n    expect(componentInstance.onChange).not.toHaveBeenCalled();\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/preferences-page/form-fields/subject-interests.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for subject interests form field.\n */\n\nimport {ENTER} from '@angular/cdk/keycodes';\nimport {\n  Component,\n  ElementRef,\n  forwardRef,\n  Input,\n  ViewChild,\n} from '@angular/core';\nimport {\n  ControlValueAccessor,\n  FormControl,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\nimport {MatChipList} from '@angular/material/chips';\nimport cloneDeep from 'lodash/cloneDeep';\nimport {Observable} from 'rxjs';\nimport {map, startWith} from 'rxjs/operators';\n\n@Component({\n  selector: 'oppia-subject-interests',\n  templateUrl: './subject-interests.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SubjectInterestsComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SubjectInterestsComponent implements ControlValueAccessor {\n  @Input() subjectInterests: string[] = [];\n\n  selectable = true;\n  removable = true;\n  separatorKeysCodes: number[] = [ENTER];\n  formCtrl = new FormControl();\n  filteredSubjectInterests: Observable<string[]>;\n  allSubjectInterests: string[] = [];\n  // These properties are initialized using Angular lifecycle hooks\n  // and we need to do non-null assertion. For more information, see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  @ViewChild('chipList') chipList!: MatChipList;\n  @ViewChild('subjectInterestInput')\n  subjectInterestInput!: ElementRef<HTMLInputElement>;\n\n  constructor() {\n    this.filteredSubjectInterests = this.formCtrl.valueChanges.pipe(\n      startWith(null),\n      map((interest: string | null) =>\n        interest ? this.filter(interest) : this.allSubjectInterests.slice()\n      )\n    );\n  }\n\n  // Implementing the ControlValueAccessor interface through the following\n  // 5 methods to make the component work as a form field.\n  onChange: (value: string[]) => void = () => {};\n  onTouched: () => void = () => {};\n\n  writeValue(value: string[]): void {\n    if (value !== undefined) {\n      this.subjectInterests = value;\n    }\n  }\n\n  registerOnChange(fn: (value: string[]) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  ngOnInit(): void {\n    this.formCtrl.valueChanges.subscribe((value: string) => {\n      if (!this.isValidInput(value)) {\n        this.chipList.errorState = true;\n      } else {\n        this.chipList.errorState = false;\n      }\n    });\n    this.allSubjectInterests = cloneDeep(this.subjectInterests);\n  }\n\n  isValidInput(value: string): boolean {\n    // The following regex matches only lowercase\n    // alphabetic characters and spaces.\n    let validRegex = new RegExp('^[a-z\\\\s]*$');\n\n    return validRegex.test(value) && !this.subjectInterests.includes(value);\n  }\n\n  add(event: {value: string}): void {\n    const value = (event.value || '').trim();\n    if (!value) {\n      return;\n    }\n\n    if (this.isValidInput(value)) {\n      this.subjectInterests.push(value);\n      if (this.allSubjectInterests.indexOf(value) < 0) {\n        this.allSubjectInterests.push(value);\n      }\n      this.onChange(this.subjectInterests);\n      this.subjectInterestInput.nativeElement.value = '';\n    }\n  }\n\n  remove(interest: string): void {\n    const index = this.subjectInterests.indexOf(interest);\n\n    if (index >= 0) {\n      this.subjectInterests.splice(index, 1);\n      this.onChange(this.subjectInterests);\n    }\n  }\n\n  selected(event: {option: {value: string}}): void {\n    if (this.subjectInterests.indexOf(event.option.value) > -1) {\n      this.remove(event.option.value);\n    } else {\n      this.add(event.option);\n    }\n  }\n\n  filter(value: string): string[] {\n    const filterValue = value.toLowerCase();\n\n    return this.allSubjectInterests.filter(interest =>\n      interest.toLowerCase().includes(filterValue)\n    );\n  }\n  onBlur(): void {\n    // `nativeElement.value` represents the current value of the input field in the DOM.\n    const value = this.subjectInterestInput.nativeElement.value.trim();\n\n    if (value && this.isValidInput(value)) {\n      this.subjectInterests.push(value);\n      this.subjectInterestInput.nativeElement.value = '';\n      this.onChange(this.subjectInterests);\n    }\n  }\n\n  onInput(event: Event): void {\n    const inputElement = event.target as HTMLInputElement;\n    const inputValue = inputElement.value.trim();\n\n    if (!inputValue) {\n      this.formCtrl.markAsPristine();\n      return;\n    }\n\n    if (this.isValidInput(inputValue)) {\n      this.formCtrl.markAsDirty();\n      this.onChange(this.subjectInterests);\n    }\n  }\n}\n"
    },
    {
      "filename": "core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts",
      "content": "// Copyright 2024 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Acceptance Test for the user journey of account creation, profile preference editing, and account export.\n * The test includes:\n * - Navigation to preferences page, editing profile preferences,\n *   verifying changes on profile page, exporting account, and account deletion by a logged-out user.\n */\n\nimport {UserFactory} from '../../utilities/common/user-factory';\nimport testConstants from '../../utilities/common/test-constants';\nimport {LoggedInUser} from '../../utilities/user/logged-in-user';\nimport {LoggedOutUser} from '../../utilities/user/logged-out-user';\n\nconst DEFAULT_SPEC_TIMEOUT_MSECS = testConstants.DEFAULT_SPEC_TIMEOUT_MSECS;\nconst PROFILE_PICTURE = testConstants.data.profilePicture;\n\ndescribe('Logged-in User', function () {\n  let loggedInUser1: LoggedInUser & LoggedOutUser;\n\n  beforeAll(async function () {\n    loggedInUser1 = await UserFactory.createNewUser(\n      'loggedInUser1',\n      'logged_in_user1@example.com'\n    );\n  }, DEFAULT_SPEC_TIMEOUT_MSECS);\n\n  it(\n    'should be able to create an account, update profile preferences, view changes on profile page, export account, and delete account',\n    async function () {\n      await loggedInUser1.navigateToPreferencesPage();\n\n      // Update profile preferences.\n      await loggedInUser1.updateProfilePicture(PROFILE_PICTURE);\n      await loggedInUser1.updateBio('This is my new bio.');\n      await loggedInUser1.updatePreferredDashboard('Creator Dashboard');\n      await loggedInUser1.updateSubjectInterestsWithEnterKey([\n        'math',\n        'science',\n      ]);\n      await loggedInUser1.updateSubjectInterestsWhenBlurringField([\n        'art',\n        'history',\n      ]);\n      await loggedInUser1.updatePreferredExplorationLanguage('Hinglish');\n      await loggedInUser1.updatePreferredSiteLanguage('English');\n      await loggedInUser1.updatePreferredAudioLanguage('English');\n      await loggedInUser1.updateEmailPreferences([\n        'Receive news and updates about the site',\n      ]);\n\n      await loggedInUser1.saveChanges();\n\n      // Navigate to Profile page and verify changes.\n      await loggedInUser1.navigateToProfilePageFromPreferencePage();\n      await loggedInUser1.verifyProfilePicUpdate();\n      await loggedInUser1.expectBioToBe('This is my new bio.');\n      await loggedInUser1.expectSubjectInterestsToBe([\n        'math',\n        'science',\n        'art',\n        'history',\n      ]);\n      // Export account from Preferences page.\n      await loggedInUser1.navigateToPreferencesPage();\n      await loggedInUser1.exportAccount();\n    },\n    DEFAULT_SPEC_TIMEOUT_MSECS\n  );\n\n  afterAll(async function () {\n    await UserFactory.closeAllBrowsers();\n  });\n});\n"
    },
    {
      "filename": "core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts",
      "content": "// Copyright 2024 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Logged-in users utility file.\n */\n\nimport {BaseUser} from '../common/puppeteer-utils';\nimport testConstants from '../common/test-constants';\nimport {showMessage} from '../common/show-message';\nimport puppeteer from 'puppeteer';\n\nconst profilePageUrlPrefix = testConstants.URLs.ProfilePagePrefix;\nconst WikiPrivilegesToFirebaseAccount =\n  testConstants.URLs.WikiPrivilegesToFirebaseAccount;\nconst baseUrl = testConstants.URLs.BaseURL;\nconst homePageUrl = testConstants.URLs.Home;\nconst signUpEmailField = testConstants.SignInDetails.inputField;\nconst learnerDashboardUrl = testConstants.URLs.LearnerDashboard;\nconst feedbackUpdatesUrl = testConstants.URLs.FeedbackUpdates;\n\nconst subscribeButton = 'button.oppia-subscription-button';\nconst unsubscribeLabel = '.e2e-test-unsubscribe-label';\nconst explorationCard = '.e2e-test-exploration-dashboard-card';\nconst ratingsHeaderSelector = '.conversation-skin-final-ratings-header';\nconst ratingStarSelector = '.e2e-test-rating-star';\nconst feedbackTextareaSelector = '.e2e-test-exploration-feedback-textarea';\nconst anonymousCheckboxSelector = '.e2e-test-stay-anonymous-checkbox';\nconst submitButtonSelector = '.e2e-test-exploration-feedback-submit-btn';\nconst submittedMessageSelector = '.e2e-test-rating-submitted-message';\nconst PreferencesPageUrl = testConstants.URLs.Preferences;\nconst deleteAccountButton = '.e2e-test-delete-account-button';\nconst accountDeletionButtonInDeleteAccountPage =\n  '.e2e-test-delete-my-account-button';\nconst signUpUsernameField = 'input.e2e-test-username-input';\nconst invalidEmailErrorContainer = '#mat-error-1';\nconst invalidUsernameErrorContainer = '.oppia-warning-text';\nconst optionText = '.mat-option-text';\nconst profileDropdown = '.e2e-test-profile-dropdown';\nconst learnerDashboardMenuLink = '.e2e-test-learner-dashboard-menu-link';\nconst confirmUsernameField = '.e2e-test-confirm-username-field';\nconst confirmAccountDeletionButton = '.e2e-test-confirm-deletion-button';\nconst agreeToTermsCheckbox = 'input.e2e-test-agree-to-terms-checkbox';\nconst registerNewUserButton = 'button.e2e-test-register-user:not([disabled])';\nconst desktopLessonCardTitleSelector = '.e2e-test-exploration-tile-title';\nconst lessonCardTitleSelector = '.e2e-test-exploration-tile-title';\nconst desktopAddToPlayLaterButton = '.e2e-test-add-to-playlist-btn';\nconst mobileAddToPlayLaterButton = '.e2e-test-mobile-add-to-playlist-btn';\nconst toastMessageSelector = '.e2e-test-toast-message';\nconst mobileLessonCardTitleSelector = '.e2e-test-exp-summary-tile-title';\nconst mobileCommunityLessonSectionButton = '.e2e-test-mobile-lessons-section';\nconst communityLessonsSectionButton = '.e2e-test-community-lessons-section';\nconst removeFromPlayLaterButtonSelector = '.e2e-test-remove-from-playlist-btn';\nconst confirmRemovalFromPlayLaterButton =\n  '.e2e-test-confirm-delete-interaction';\nconst playLaterSectionSelector = '.e2e-test-play-later-section';\nconst lessonCardTitleInPlayLaterSelector = `${playLaterSectionSelector} .e2e-test-exploration-tile-title`;\nconst mobileLessonCardOptionsDropdownButton =\n  '.e2e-test-mobile-lesson-card-dropdown';\nconst mobileProgressSectionButton = '.e2e-test-mobile-progress-section';\nconst addProfilePictureButton = '.e2e-test-photo-upload-submit';\nconst editProfilePictureButton = '.e2e-test-photo-clickable';\nconst bioTextareaSelector = '.e2e-test-user-bio';\nconst saveChangesButtonSelector = '.e2e-test-save-changes-button';\nconst subjectInterestsInputSelector = '.e2e-test-subject-interests-input';\nconst explorationLanguageInputSelector =\n  '.e2e-test-preferred-exploration-language-input';\nconst siteLanguageInputSelector = '.e2e-test-site-language-selector';\nconst audioLanguageInputSelector = '.e2e-test-audio-language-selector';\nconst goToProfilePageButton = '.e2e-test-go-to-profile-page';\nconst profilePictureSelector = '.e2e-test-profile-user-photo';\nconst bioSelector = '.oppia-user-bio-text';\nconst subjectInterestSelector = '.e2e-test-profile-interest';\nconst exportButtonSelector = '.e2e-test-export-account-button';\nconst angularRootElementSelector = 'oppia-angular-root';\nconst checkboxesSelector = '.checkbox';\nconst defaultProfilePicture =\n  '/assets/images/avatar/user_blue_150px.png?2983.800000011921';\n\nconst ACCOUNT_EXPORT_CONFIRMATION_MESSAGE =\n  'Your data is currently being loaded and will be downloaded as a JSON formatted text file upon completion.';\nconst reportExplorationButtonSelector = '.e2e-test-report-exploration-button';\nconst reportExplorationTextAreaSelector =\n  '.e2e-test-report-exploration-text-area';\nconst submitReportButtonSelector = '.e2e-test-submit-report-button';\nconst feedbackThreadSelector = '.e2e-test-feedback-thread';\nconst feedbackMessageSelector = '.e2e-test-feedback-message';\nconst desktopCompletedLessonsSectionSelector =\n  '.e2e-test-completed-community-lessons-section';\nconst lessonTileTitleSelector =\n  '.e2e-test-topic-name-in-learner-story-summary-tile';\nconst progressSectionSelector = '.e2e-test-progress-section';\nconst mobileGoalsSectionSelector = '.e2e-test-mobile-goals-section';\nconst goalsSectionSelector = '.e2e-test-goals-section';\nconst homeSectionSelector = '.e2e-test-home-section';\nconst mobileHomeSectionSelector = '.e2e-test-mobile-home-section';\nconst topicNameInEditGoalsSelector = '.e2e-test-topic-name-in-edit-goals';\nconst completedGoalsSectionSelector = '.e2e-test-completed-goals-section';\nconst completedGoalsTopicNameSelector = '.e2e-test-completed-goals-topic-name';\nconst completedStoriesSectionSelector = '.completed-stories';\nconst storyNameSelector = '.e2e-test-story-name-in-learner-story-summary-tile';\nconst continueFromWhereLeftOffSectionSelector =\n  '.continue-where-you-left-off-section';\nconst issueTypeSelector = '.e2e-test-report-exploration-radio-button';\nconst addTopicToCurrentGoalsButton =\n  '.e2e-test-add-topic-to-current-goals-button';\nconst mobileCompletedLessonSection = '.community-lessons-section';\nconst currentGoalsSectionSelector = '.e2e-test-current-goals-section';\nconst homeSectionGreetingElement = '.greeting';\nconst LABEL_FOR_SUBMIT_BUTTON = 'Submit and start contributing';\nconst matFormTextSelector = '.oppia-form-text';\n\nexport class LoggedInUser extends BaseUser {\n  /**\n   * Function for navigating to the profile page for a given username.\n   */\n  async navigateToProfilePage(username: string): Promise<void> {\n    const profilePageUrl = `${profilePageUrlPrefix}/${username}`;\n    if (this.page.url() === profilePageUrl) {\n      return;\n    }\n    await this.goto(profilePageUrl);\n  }\n\n  /**\n   * Navigates to the community library tab of the learner dashboard.\n   */\n  async navigateToCommunityLessonsSection(): Promise<void> {\n    await this.waitForPageToFullyLoad();\n    if (this.isViewportAtMobileWidth()) {\n      await this.page.waitForSelector(mobileProgressSectionButton);\n      await this.clickOn(mobileProgressSectionButton);\n\n      try {\n        await this.page.waitForSelector(mobileCommunityLessonSectionButton, {\n          timeout: 5000,\n        });\n      } catch (error) {\n        if (error instanceof puppeteer.errors.TimeoutError) {\n          // Try clicking again if does not opens the expected page.\n          await this.clickOn(mobileProgressSectionButton);\n        } else {\n          throw error;\n        }\n      }\n      await this.clickOn(mobileCommunityLessonSectionButton);\n    } else {\n      await this.page.click(communityLessonsSectionButton);\n    }\n  }\n\n  /**\n   * Function to subscribe to a creator with the given username.\n   */\n  async subscribeToCreator(username: string): Promise<void> {\n    const profilePageUrl = `${profilePageUrlPrefix}/${username}`;\n\n    if (this.page.url() !== profilePageUrl) {\n      await this.navigateToProfilePage(username);\n    }\n\n    await this.clickOn(subscribeButton);\n    await this.page.waitForSelector(unsubscribeLabel);\n    showMessage(`Subscribed to the creator with username ${username}.`);\n  }\n\n  /**\n   * Navigates to the learner dashboard.\n   */\n  async navigateToLearnerDashboard(): Promise<void> {\n    await this.goto(learnerDashboardUrl);\n  }\n\n  /**\n   * Navigates to the learner dashboard using profile dropdown in the navbar.\n   */\n  async navigateToLearnerDashboardUsingProfileDropdown(): Promise<void> {\n    await this.clickOn(profileDropdown);\n    await this.clickOn(learnerDashboardMenuLink);\n  }\n\n  /**\n   * Navigates to the progress section of the learner dashboard.\n   */\n  async navigateToProgressSection(): Promise<void> {\n    if (this.isViewportAtMobileWidth()) {\n      await this.page.waitForSelector(mobileProgressSectionButton);\n      await this.clickOn(mobileProgressSectionButton);\n\n      try {\n        await this.page.waitForSelector(mobileCommunityLessonSectionButton, {\n          timeout: 5000,\n        });\n      } catch (error) {\n        if (error instanceof puppeteer.errors.TimeoutError) {\n          // Try clicking again if does not opens the expected page.\n          await this.clickOn(mobileProgressSectionButton);\n        } else {\n          throw error;\n        }\n      }\n      await this.clickOn('Stories');\n    } else {\n      await this.page.waitForSelector(progressSectionSelector);\n      const progressSection = await this.page.$(progressSectionSelector);\n      if (!progressSection) {\n        throw new Error('Progress section not found.');\n      }\n      await progressSection.click();\n    }\n\n    await this.waitForPageToFullyLoad();\n  }\n\n  /**\n   * Navigates to the home section of the learner dashboard.\n   */\n  async navigateToHomeSection(): Promise<void> {\n    if (await this.isViewportAtMobileWidth()) {\n      await this.page.waitForSelector(mobileHomeSectionSelector);\n      await this.clickOn(mobileHomeSectionSelector);\n\n      try {\n        await this.page.waitForSelector(homeSectionGreetingElement, {\n          timeout: 5000,\n        });\n      } catch (error) {\n        if (error instanceof puppeteer.errors.TimeoutError) {\n          // Try clicking again if does not opens the expected page.\n          await this.clickOn(mobileHomeSectionSelector);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      await this.page.waitForSelector(homeSectionSelector);\n      const homeSectionElement = await this.page.$(homeSectionSelector);\n      if (!homeSectionElement) {\n        throw new Error('Home section not found.');\n      }\n      await this.waitForElementToBeClickable(homeSectionElement);\n      await homeSectionElement.click();\n    }\n\n    await this.waitForPageToFullyLoad();\n  }\n\n  /**\n   * Navigates to the goals section of the learner dashboard.\n   */\n  async navigateToGoalsSection(): Promise<void> {\n    if (this.isViewportAtMobileWidth()) {\n      await this.page.waitForSelector(mobileGoalsSectionSelector);\n      await this.clickOn(mobileGoalsSectionSelector);\n\n      try {\n        await this.page.waitForSelector(currentGoalsSectionSelector, {\n          timeout: 5000,\n        });\n      } catch (error) {\n        if (error instanceof puppeteer.errors.TimeoutError) {\n          // Try clicking again if does not opens the expected page.\n          await this.clickOn(mobileGoalsSectionSelector);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      await this.page.waitForSelector(goalsSectionSelector);\n      const goalSectionElement = await this.page.$(goalsSectionSelector);\n      if (!goalSectionElement) {\n        throw new Error('Progress section not found.');\n      }\n      await goalSectionElement.click();\n    }\n\n    await this.waitForPageToFullyLoad();\n  }\n\n  /**\n   * Navigates to the feedback updates page.\n   */\n  async navigateToFeedbackUpdatesPage(): Promise<void> {\n    await this.goto(feedbackUpdatesUrl);\n  }\n\n  /**\n   * Checks whether the exploration with the given title is authored by the creator.\n   */\n  async expectExplorationToBePresentInProfilePageWithTitle(\n    title: string\n  ): Promise<void> {\n    await this.page.waitForSelector(explorationCard);\n    const explorations = await this.page.$$(explorationCard);\n\n    if (explorations.length === 0) {\n      throw new Error('There are no explorations authored by the creator.');\n    }\n\n    const explorationTitle = await explorations[0].$eval(\n      '.e2e-test-exp-summary-tile-title span span',\n      element => (element as HTMLElement).textContent\n    );\n\n    if (explorationTitle?.trim() === title) {\n      showMessage(`Exploration with title ${title} is present.`);\n    } else {\n      throw new Error(`Exploration with title ${title} is not present.`);\n    }\n  }\n\n  /**\n   * Navigates to preference page.\n   */\n  async navigateToPreferencesPage(): Promise<void> {\n    await this.goto(PreferencesPageUrl);\n  }\n\n  /**\n   * This function navigates to the given topic URL and checks if the page displays\n   * an 'Error 404' message.\n   * @param {string} topicUrlFragment - The URL fragment of the topic to check.\n   */\n  async expectTopicLinkReturns404(topicUrlFragment: string): Promise<void> {\n    // Reloading the page to ensure the latest state is reflected,\n    // particularly useful if a topic was recently unpublished.\n    await this.page.reload();\n    await this.goto(`http://localhost:8181/learn/staging/${topicUrlFragment}`);\n    const isError404Present = await this.isTextPresentOnPage('Error 404');\n    if (!isError404Present) {\n      throw new Error(\n        'Expected \"Error 404\" to be present on the page, but it was not.'\n      );\n    } else {\n      showMessage('The link returns 404 as expected.');\n    }\n  }\n\n  /**\n   * Navigates to the exploration page and starts playing the exploration.\n   * @param {string} explorationId - The ID of the exploration to play.\n   */\n  async playExploration(explorationId: string | null): Promise<void> {\n    await this.goto(`${baseUrl}/explore/${explorationId as string}`);\n  }\n\n  /**\n   * Rates an exploration by clicking on the rating stars, providing feedback, and optionally staying anonymous.\n   *\n   * @param {number} rating - The rating to give to the exploration.\n   * @param {string} feedback - The feedback to provide for the exploration.\n   * @param {boolean} stayAnonymous - Whether to stay anonymous or not.\n   */\n  async rateExploration(\n    rating: number,\n    feedback: string,\n    stayAnonymous: boolean\n  ): Promise<void> {\n    try {\n      await this.page.waitForSelector(ratingsHeaderSelector);\n      const ratingStars = await this.page.$$(ratingStarSelector);\n      await this.waitForElementToBeClickable(ratingStars[rating - 1]);\n      await ratingStars[rating - 1].click();\n\n      await this.type(feedbackTextareaSelector, feedback);\n      if (stayAnonymous) {\n        await this.clickOn(anonymousCheckboxSelector);\n      }\n\n      await this.clickOn(submitButtonSelector);\n\n      // Wait for the submitted message to appear and check its text.\n      await this.page.waitForSelector(submittedMessageSelector);\n      const submittedMessageElement = await this.page.$(\n        submittedMessageSelector\n      );\n      const submittedMessageText = await this.page.evaluate(\n        el => el.innerText,\n        submittedMessageElement\n      );\n      if (submittedMessageText !== 'Thank you for the feedback!') {\n        throw new Error(\n          `Unexpected submitted message text: ${submittedMessageText}`\n        );\n      }\n    } catch (error) {\n      const newError = new Error(`Failed to rate exploration: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Clicks the delete account button and waits for navigation.\n   */\n  async deleteAccount(): Promise<void> {\n    await this.clickAndWaitForNavigation(deleteAccountButton);\n  }\n\n  /**\n   * Clicks on the delete button in the page /delete-account to confirm account deletion, also, for confirmation username needs to be entered.\n   * @param {string} username - The username of the account.\n   */\n  async confirmAccountDeletion(username: string): Promise<void> {\n    await this.clickOn(accountDeletionButtonInDeleteAccountPage);\n    await this.type(confirmUsernameField, username);\n    await this.clickAndWaitForNavigation(confirmAccountDeletionButton);\n  }\n\n  /**\n   * Navigates to the sign up page. If the user hasn't accepted cookies, it clicks 'OK' to accept them.\n   * Then, it clicks on the 'Sign in' button.\n   */\n  async navigateToSignUpPage(): Promise<void> {\n    await this.goto(homePageUrl);\n    if (!this.userHasAcceptedCookies) {\n      await this.clickOn('OK');\n      this.userHasAcceptedCookies = true;\n    }\n    await this.clickOn('Sign in');\n  }\n\n  /**\n   * Clicks on the link to the Oppia Wiki, which opens in a new tab.\n   */\n  async clickAdminAccessInfoLink(): Promise<void> {\n    await this.clickLinkAnchorToNewTab(\n      'Oppia Wiki',\n      WikiPrivilegesToFirebaseAccount\n    );\n  }\n\n  /**\n   * Enters the provided username into the sign up username field and sign in if the username is correct.\n   * @param {string} username - The username to enter.\n   */\n  async signInWithUsername(username: string): Promise<void> {\n    await this.clearAllTextFrom(signUpUsernameField);\n    await this.type(signUpUsernameField, username);\n    // Using blur() to remove focus from signUpUsernameField.\n    await this.page.evaluate(selector => {\n      document.querySelector(selector).blur();\n    }, signUpUsernameField);\n\n    await this.waitForPageToFullyLoad();\n    const invalidUsernameErrorContainerElement = await this.page.$(\n      invalidUsernameErrorContainer\n    );\n    if (!invalidUsernameErrorContainerElement) {\n      await this.clickOn(agreeToTermsCheckbox);\n      await this.page.waitForSelector(registerNewUserButton);\n      await this.clickOn(LABEL_FOR_SUBMIT_BUTTON);\n      await this.page.waitForNavigation({waitUntil: 'networkidle0'});\n    }\n  }\n\n  /**\n   * Function to sign in the user with the given email to the Oppia website only when the email is valid.\n   */\n  async enterEmail(email: string): Promise<void> {\n    await this.clearAllTextFrom(signUpEmailField);\n    await this.type(signUpEmailField, email);\n\n    await this.waitForPageToFullyLoad();\n    const invalidEmailErrorContainerElement = await this.page.$(\n      invalidEmailErrorContainer\n    );\n    if (!invalidEmailErrorContainerElement) {\n      await this.clickOn('Sign In');\n      await this.page.waitForNavigation({waitUntil: 'networkidle0'});\n    }\n  }\n\n  /**\n   * Waits for the invalid email error container to appear, then checks if the error message matches the expected error.\n   * @param {string} expectedError - The expected error message.\n   */\n  async expectValidationError(expectedError: string): Promise<void> {\n    await this.page.waitForSelector(invalidEmailErrorContainer);\n    const errorMessage = await this.page.$eval(\n      invalidEmailErrorContainer,\n      el => el.textContent\n    );\n    const trimmedErrorMessage = errorMessage?.trim();\n\n    if (trimmedErrorMessage !== expectedError) {\n      throw new Error(\n        `Validation error does not match. Expected: ${expectedError}, but got: ${trimmedErrorMessage}`\n      );\n    }\n  }\n\n  /**\n   * Waits for the duplicate username error container to appear, then checks if the error message matches the expected error.\n   * @param {string} expectedError - The expected error message.\n   */\n  async expectUsernameError(expectedError: string): Promise<void> {\n    await this.page.waitForSelector(invalidUsernameErrorContainer);\n    const errorMessage = await this.page.$eval(\n      invalidUsernameErrorContainer,\n      el => el.textContent\n    );\n    if (errorMessage?.trim() !== expectedError) {\n      throw new Error(\n        `D error does not match. Expected: ${expectedError}, but got: ${errorMessage}`\n      );\n    }\n  }\n\n  /**\n   * Clicks on the sign up email field, waits for the suggestion to appear, then checks if the\n   * suggestion matches the expected suggestion.\n   * @param {string} expectedSuggestion - The expected suggestion.\n   */\n  async expectAdminEmailSuggestion(expectedSuggestion: string): Promise<void> {\n    await this.clickOn(signUpEmailField);\n    await this.page.waitForSelector(optionText);\n    const suggestion = await this.page.$eval(optionText, el => el.textContent);\n\n    if (suggestion?.trim() !== expectedSuggestion) {\n      throw new Error(\n        `Suggestion does not match. Expected: ${expectedSuggestion}, but got: ${suggestion}`\n      );\n    }\n\n    // Click anywhere on the page to remove focus from the email field.\n    await this.page.click('body');\n  }\n\n  /**\n   * Verifies that the current page URL includes the expected page pathname.\n   */\n  async expectToBeOnPage(expectedPage: string): Promise<void> {\n    await this.waitForStaticAssetsToLoad();\n    const url = await this.page.url();\n\n    // Replace spaces in the expectedPage with hyphens.\n    const expectedPageInUrl = expectedPage.replace(/\\s+/g, '-');\n\n    if (!url.includes(expectedPageInUrl.toLowerCase())) {\n      throw new Error(\n        `Expected to be on page ${expectedPage}, but found ${url}`\n      );\n    }\n  }\n\n  /**\n  /**\n   * Adds a lesson to the 'Play Later' list from community library page.\n   * @param {string} lessonTitle - The title of the lesson to add to the 'Play Later' list.\n   */\n  async addLessonToPlayLater(lessonTitle: string): Promise<void> {\n    try {\n      await this.waitForPageToFullyLoad();\n      const isMobileViewport = await this.isViewportAtMobileWidth();\n      const lessonCardTitleSelector = isMobileViewport\n        ? mobileLessonCardTitleSelector\n        : desktopLessonCardTitleSelector;\n\n      await this.page.waitForSelector(lessonCardTitleSelector);\n      const lessonTitles = await this.page.$$eval(\n        lessonCardTitleSelector,\n        elements => elements.map(el => el.textContent?.trim())\n      );\n\n      const lessonIndex = lessonTitles.indexOf(lessonTitle);\n\n      if (lessonIndex === -1) {\n        throw new Error(`Lesson \"${lessonTitle}\" not found in search results.`);\n      }\n\n      if (isMobileViewport) {\n        await this.page.waitForSelector(mobileLessonCardOptionsDropdownButton);\n        const optionsDropdownButtons = await this.page.$$(\n          mobileLessonCardOptionsDropdownButton\n        );\n        await optionsDropdownButtons[lessonIndex].click();\n        await this.page.waitForSelector(mobileAddToPlayLaterButton);\n        const mobileAddToPlayLaterButtons = await this.page.$$(\n          mobileAddToPlayLaterButton\n        );\n        await mobileAddToPlayLaterButtons[lessonIndex].click();\n      } else {\n        await this.page.waitForSelector(desktopAddToPlayLaterButton);\n        const addToPlayLaterButtons = await this.page.$$(\n          desktopAddToPlayLaterButton\n        );\n        await addToPlayLaterButtons[lessonIndex].click();\n      }\n\n      showMessage(`Lesson \"${lessonTitle}\" added to 'Play Later' list.`);\n    } catch (error) {\n      const newError = new Error(\n        `Failed to add lesson to 'Play Later' list: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Expects the text content of the toast message to match the given expected message.\n   * @param {string} expectedMessage - The expected message to match the toast message against.\n   */\n  async expectToolTipMessage(expectedMessage: string): Promise<void> {\n    try {\n      await this.page.waitForSelector(toastMessageSelector, {visible: true});\n      const toastMessageElement = await this.page.$(toastMessageSelector);\n      const toastMessage = await this.page.evaluate(\n        el => el.textContent.trim(),\n        toastMessageElement\n      );\n\n      if (toastMessage !== expectedMessage) {\n        throw new Error(\n          `Expected toast message to be \"${expectedMessage}\", but it was \"${toastMessage}\".`\n        );\n      }\n      await this.page.waitForSelector(toastMessageSelector, {hidden: true});\n    } catch (error) {\n      const newError = new Error(`Failed to match toast message: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Function to play a specific lesson from the community library tab in learner dashboard.\n   * @param {string} lessonName - The name of the lesson to be played.\n   */\n  async playLessonFromDashboard(lessonName: string): Promise<void> {\n    try {\n      await this.page.waitForSelector(lessonCardTitleSelector);\n      const searchResultsElements = await this.page.$$(lessonCardTitleSelector);\n      const searchResults = await Promise.all(\n        searchResultsElements.map(result =>\n          this.page.evaluate(el => el.textContent.trim(), result)\n        )\n      );\n\n      const lessonIndex = searchResults.indexOf(lessonName);\n      if (lessonIndex === -1) {\n        throw new Error(`Lesson \"${lessonName}\" not found in search results.`);\n      }\n\n      await this.waitForElementToBeClickable(\n        searchResultsElements[lessonIndex]\n      );\n      await searchResultsElements[lessonIndex].click();\n    } catch (error) {\n      const newError = new Error(\n        `Failed to play lesson from dashboard: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Removes a lesson from the 'Play Later' list in the learner dashboard.\n   * @param {string} lessonName - The name of the lesson to remove from the 'Play Later' list.\n   */\n  async removeLessonFromPlayLater(lessonName: string): Promise<void> {\n    try {\n      await this.page.waitForSelector(lessonCardTitleInPlayLaterSelector);\n      const lessonCards = await this.page.$$(\n        lessonCardTitleInPlayLaterSelector\n      );\n      const lessonNames = await Promise.all(\n        lessonCards.map(card =>\n          this.page.evaluate(el => el.textContent.trim(), card)\n        )\n      );\n\n      const lessonIndex = lessonNames.indexOf(lessonName);\n      if (lessonIndex === -1) {\n        throw new Error(\n          `Lesson \"${lessonName}\" not found in 'Play Later' list.`\n        );\n      }\n\n      // Scroll to the element before hovering so the remove button could be visible.\n      await this.page.evaluate(\n        el => el.scrollIntoView(),\n        lessonCards[lessonIndex]\n      );\n      await this.page.hover(lessonCardTitleInPlayLaterSelector);\n\n      await this.page.waitForSelector(removeFromPlayLaterButtonSelector);\n      const removeFromPlayLaterButton = await this.page.$(\n        removeFromPlayLaterButtonSelector\n      );\n      await removeFromPlayLaterButton?.click();\n\n      // Confirm removal.\n      await this.clickOn(confirmRemovalFromPlayLaterButton);\n\n      showMessage(`Lesson \"${lessonName}\" removed from 'Play Later' list.`);\n    } catch (error) {\n      const newError = new Error(\n        `Failed to remove lesson from 'Play Later' list: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Verifies whether a lesson is in the 'Play Later' list.\n   * @param {string} lessonName - The name of the lesson to check.\n   * @param {boolean} shouldBePresent - Whether the lesson should be present in the 'Play Later' list.\n   */\n  async verifyLessonPresenceInPlayLater(\n    lessonName: string,\n    shouldBePresent: boolean\n  ): Promise<void> {\n    try {\n      await this.waitForStaticAssetsToLoad();\n      await this.page.waitForSelector(playLaterSectionSelector);\n      const lessonCards = await this.page.$$(\n        lessonCardTitleInPlayLaterSelector\n      );\n      const lessonNames = await Promise.all(\n        lessonCards.map(card =>\n          this.page.evaluate(el => el.textContent.trim(), card)\n        )\n      );\n\n      const lessonIndex = lessonNames.indexOf(lessonName);\n      if (lessonIndex !== -1 && !shouldBePresent) {\n        throw new Error(\n          `Lesson \"${lessonName}\" was found in 'Play Later' list, but it should not be.`\n        );\n      }\n\n      if (lessonIndex === -1 && shouldBePresent) {\n        throw new Error(\n          `Lesson \"${lessonName}\" was not found in 'Play Later' list, but it should be.`\n        );\n      }\n    } catch (error) {\n      const newError = new Error(\n        `Failed to verify presence of lesson in 'Play Later' list: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Updates the profile picture in preference page.\n   * @param {string} picturePath - The path of the picture to upload.\n   */\n  async updateProfilePicture(picturePath: string): Promise<void> {\n    await this.clickOn(editProfilePictureButton);\n    await this.uploadFile(picturePath);\n    await this.clickOn(addProfilePictureButton);\n  }\n\n  /**\n   * Updates the user's bio in preference page.\n   * @param {string} bio - The new bio to set for the user.\n   */\n  async updateBio(bio: string): Promise<void> {\n    await this.clickOn(bioTextareaSelector);\n    await this.type(bioTextareaSelector, bio);\n  }\n\n  /**\n   * Updates the user's preferred dashboard in preference page.\n   * @param {string} dashboard - The new dashboard to set for the user. Can be one of 'Learner Dashboard', 'Creator Dashboard', or 'Contributor Dashboard'.\n   */\n  async updatePreferredDashboard(dashboard: string): Promise<void> {\n    const allowedDashboards = [\n      'Learner Dashboard',\n      'Creator Dashboard',\n      'Contributor Dashboard',\n    ];\n\n    if (!allowedDashboards.includes(dashboard)) {\n      throw new Error(\n        `Invalid dashboard: ${dashboard}. Must be one of ${allowedDashboards.join(', ')}.`\n      );\n    }\n\n    // Converting the dashboard to lowercase and replace spaces with hyphens to match the selector.\n    const dashboardInSelector = dashboard.toLowerCase().replace(/\\s+/g, '-');\n    const dashboardSelector = `.e2e-test-${dashboardInSelector}-radio`;\n\n    await this.clickOn(dashboardSelector);\n  }\n\n  /**\n   * Updates the user's subject interests in preference page.\n   * @param {string[]} interests - The new interests to set for the user after each interest is entered in the input field, followed by pressing the Enter key.\n   */\n  async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\n    for (const interest of interests) {\n      await this.type(subjectInterestsInputSelector, interest);\n      await this.page.keyboard.press('Enter');\n    }\n  }\n  /**\n   * Updates the user's subject interests in the preferences page\n   * when the input field loses focus.\n   *\n   * @param {string[]} interests - The new interests to set for the user when the input field is blurred (i.e., focus is moved away).\n   */\n  async updateSubjectInterestsWhenBlurringField(\n    interests: string[]\n  ): Promise<void> {\n    for (const interest of interests) {\n      await this.type(subjectInterestsInputSelector, interest);\n      await this.page.click(matFormTextSelector);\n    }\n  }\n\n  /**\n   * Updates the user's preferred exploration language in preference page.\n   * @param {string} language - The new language to set for the user.\n   */\n  async updatePreferredExplorationLanguage(language: string): Promise<void> {\n    await this.waitForPageToFullyLoad();\n\n    await this.clickOn(explorationLanguageInputSelector);\n\n    await this.page.waitForSelector(optionText);\n    const options = await this.page.$$(optionText);\n    for (const option of options) {\n      const optionText = await this.page.evaluate(\n        el => el.textContent.trim(),\n        option\n      );\n      if (optionText === language) {\n        await option.click();\n        break;\n      }\n    }\n  }\n\n  /**\n   * Updates the user's preferred site language in preference page.\n   * @param {string} language - The new language to set for the user.\n   */\n  async updatePreferredSiteLanguage(language: string): Promise<void> {\n    await this.type(siteLanguageInputSelector, language);\n    await this.page.keyboard.press('Enter');\n  }\n\n  /**\n   * Updates the user's preferred audio language in preference page.\n   * @param {string} language - The new language to set for the user.\n   */\n  async updatePreferredAudioLanguage(language: string): Promise<void> {\n    await this.type(audioLanguageInputSelector, language);\n    await this.page.keyboard.press('Enter');\n  }\n\n  /**\n   * Updates the user's email preferences from the preferences page.\n   * @param {string[]} preferences - The new email preferences to set for the user.\n   */\n  async updateEmailPreferences(preferences: string[]): Promise<void> {\n    await this.waitForPageToFullyLoad();\n\n    try {\n      await this.page.waitForSelector(checkboxesSelector);\n      const checkboxes = await this.page.$$(checkboxesSelector);\n\n      for (const preference of preferences) {\n        let found = false;\n\n        for (const checkbox of checkboxes) {\n          const label = await checkbox.evaluate(el => el.textContent?.trim());\n          if (label === preference) {\n            await this.waitForElementToBeClickable(checkbox);\n            await checkbox.click();\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          throw new Error(`Preference not found: ${preference}`);\n        }\n      }\n    } catch (error) {\n      const newError = new Error(\n        `Failed to update email preferences: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Navigates to the Profile tab from the Preferences page.\n   */\n  async navigateToProfilePageFromPreferencePage(): Promise<void> {\n    try {\n      await this.page.waitForSelector(goToProfilePageButton);\n      const profileTab = await this.page.$(goToProfilePageButton);\n\n      if (!profileTab) {\n        throw new Error('Profile tab not found');\n      }\n\n      await this.clickAndWaitForNavigation(goToProfilePageButton);\n      await this.waitForPageToFullyLoad();\n    } catch (error) {\n      const newError = new Error(\n        `Failed to navigate to Profile tab from Preferences page: ${error}`\n      );\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Saves the changes made in the preferences page.\n   */\n  async saveChanges(): Promise<void> {\n    await this.waitForNetworkIdle({idleTime: 1000});\n    await this.waitForPageToFullyLoad();\n    await this.clickAndWaitForNavigation(saveChangesButtonSelector);\n  }\n\n  /**\n   * Expects the profile picture to not match a certain image.\n   */\n  async verifyProfilePicUpdate(): Promise<void> {\n    try {\n      await this.page.waitForSelector(profilePictureSelector);\n      const profilePicture = await this.page.$(profilePictureSelector);\n\n      if (!profilePicture) {\n        throw new Error('Profile picture not found');\n      }\n      const actualImageUrl = await this.page.evaluate(\n        img => img.src,\n        profilePicture\n      );\n\n      if (actualImageUrl === defaultProfilePicture) {\n        throw new Error(\n          `Profile picture does not match. Expected image source to be different from: ${defaultProfilePicture}`\n        );\n      }\n      showMessage('Profile picture is different from the default one.');\n    } catch (error) {\n      const newError = new Error(`Failed to check profile picture: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Expects the user's bio to match a certain text.\n   * @param {string} expectedBio - The expected bio text.\n   */\n  async expectBioToBe(expectedBio: string): Promise<void> {\n    try {\n      await this.page.waitForSelector(bioSelector);\n      const bioElement = await this.page.$(bioSelector);\n\n      if (!bioElement) {\n        throw new Error('Bio not found');\n      }\n\n      const actualBio = await this.page.evaluate(\n        el => el.textContent,\n        bioElement\n      );\n      if (actualBio.trim() !== expectedBio) {\n        throw new Error(\n          `Bio does not match. Expected: ${expectedBio}, but got: ${actualBio}`\n        );\n      }\n    } catch (error) {\n      const newError = new Error(`Failed to check bio: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Expects the user's subject interests to match a certain list.\n   * @param {string[]} expectedInterests - The expected list of interests.\n   */\n  async expectSubjectInterestsToBe(expectedInterests: string[]): Promise<void> {\n    try {\n      await this.page.waitForSelector(subjectInterestSelector);\n      const interestElements = await this.page.$$(subjectInterestSelector);\n      const actualInterests = await Promise.all(\n        interestElements.map(el =>\n          this.page.evaluate(el => el.textContent.trim(), el)\n        )\n      );\n\n      // Check if the actual interests match the expected interests.\n      for (const interest of expectedInterests) {\n        if (!actualInterests.includes(interest)) {\n          throw new Error(`Interest not found: ${interest}`);\n        }\n      }\n    } catch (error) {\n      const newError = new Error(`Failed to check interests: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Exports the user's account data.\n   */\n  async exportAccount(): Promise<void> {\n    try {\n      await this.page.waitForSelector(exportButtonSelector);\n      const exportButton = await this.page.$(exportButtonSelector);\n\n      if (!exportButton) {\n        throw new Error('Export button not found');\n      }\n\n      await this.waitForPageToFullyLoad();\n      await exportButton.click();\n\n      const isTextPresent = await this.isTextPresentOnPage(\n        ACCOUNT_EXPORT_CONFIRMATION_MESSAGE\n      );\n\n      if (!isTextPresent) {\n        throw new Error(\n          `Expected text not found on page: ${ACCOUNT_EXPORT_CONFIRMATION_MESSAGE}`\n        );\n      }\n    } catch (error) {\n      const newError = new Error(`Failed to export account: ${error}`);\n      newError.stack = error.stack;\n      throw newError;\n    }\n  }\n\n  /**\n   * Verifies if the page is displayed in Right-to-Left (RTL) mode.\n   */\n  async verifyPageIsRTL(): Promise<void> {\n    await this.page.waitForSelector(angularRootElementSelector);\n    const pageDirection = await this.page.evaluate(selector => {\n      const oppiaRoot = document.querySelector(selector);\n      if (!oppiaRoot) {\n        throw new Error(`${selector} not found`);\n      }\n\n      const childDiv = oppiaRoot.querySelector('div');\n      if (!childDiv) {\n        throw new Error('Child div not found');\n      }\n\n      return childDiv.getAttribute('dir');\n    }, angularRootElementSelector);\n\n    if (pageDirection !== 'rtl') {\n      throw new Error('Page is not in RTL mode');\n    }\n\n    showMessage('Page is displayed in RTL mode.');\n  }\n\n  /**\n   * This function is used to report an exploration. It clicks on the report button,\n   * opens the report modal, selects an issue, types a description, and submits the report.\n   * @param {string} issueName - The name of the issue to report.\n   * @param {string} issueDescription - The description of the issue.\n   */\n  async reportExploration(issueDescription: string): Promise<void> {\n    await this.clickOn(reportExplorationButtonSelector);\n    await this.page.waitForSelector(issueTypeSelector);\n    const issueTypeElement = await this.page.$(issueTypeSelector);\n    await issueTypeElement?.click();\n    await this.clickOn(reportExplorationTextAreaSelector);\n    await this.type(reportExplorationTextAreaSelector, issueDescription);\n\n    await this.clickOn(submitReportButtonSelector);\n\n    await this.clickOn('Close');\n  }\n\n  /**\n   * Views a feedback update thread.\n   * @param {number} threadNumber - The 0-indexed position of the thread.\n   */\n  async viewFeedbackUpdateThread(threadNumber: number): Promise<void> {\n    await this.page.waitForSelector(feedbackThreadSelector);\n    const feedbackThreads = await this.page.$$(feedbackThreadSelector);\n\n    if (threadNumber >= 0 && threadNumber < feedbackThreads.length) {\n      await feedbackThreads[threadNumber - 1].click();\n    } else {\n      throw new Error(`Thread not found: ${threadNumber}`);\n    }\n  }\n\n  /**\n   * Checks if the feedback and response match the expected values.\n   * @param {string} expectedFeedback - The expected feedback.\n   * @param {string} expectedResponse - The expected response.\n   */\n\n  async expectFeedbackAndResponseToMatch(\n    expectedFeedback: string,\n    expectedResponse: string\n  ): Promise<void> {\n    await this.page.waitForSelector(feedbackMessageSelector);\n    const feedbackMessages = await this.page.$$(feedbackMessageSelector);\n\n    if (feedbackMessages.length < 2) {\n      throw new Error('Not enough feedback messages found.');\n    }\n\n    const actualFeedback = await this.page.$eval(feedbackMessageSelector, el =>\n      el.textContent?.trim()\n    );\n\n    // Fetch the text content of the second feedbackMessageSelector.\n    const actualResponse = await this.page.$$eval(\n      feedbackMessageSelector,\n      elements => elements[1]?.textContent?.trim()\n    );\n\n    if (actualFeedback !== expectedFeedback) {\n      throw new Error(\n        `Feedback does not match the expected value. Expected: ${expectedFeedback}, Found: ${actualFeedback}`\n      );\n    }\n    if (actualResponse !== expectedResponse) {\n      throw new Error(\n        `Response does not match the expected value. Expected: ${expectedResponse}, Found: ${actualResponse}`\n      );\n    }\n  }\n\n  /**\n   * Adds goals from the goals section in the learner dashboard.\n   * @param {string[]} goals - The goals to add.\n   */\n  async addGoals(goals: string[]): Promise<void> {\n    await this.page.waitForSelector(topicNameInEditGoalsSelector, {\n      visible: true,\n    });\n    await this.page.waitForSelector(addTopicToCurrentGoalsButton, {\n      visible: true,\n    });\n\n    const topicNames = await this.page.$$(topicNameInEditGoalsSelector);\n    const addGoalButtons = await this.page.$$(addTopicToCurrentGoalsButton);\n\n    const actualTopicNames = await Promise.all(\n      topicNames.map(topicName =>\n        this.page.evaluate(el => el.textContent.trim(), topicName)\n      )\n    );\n\n    for (const goal of goals) {\n      const matchingTopicIndex = actualTopicNames.findIndex(\n        topicName => topicName === goal\n      );\n\n      if (matchingTopicIndex !== -1) {\n        await this.waitForElementToBeClickable(\n          addGoalButtons[matchingTopicIndex]\n        );\n        await addGoalButtons[matchingTopicIndex]?.click();\n        showMessage(`Goal \"${goal}\" added.`);\n      } else {\n        throw new Error(`Goal not found: ${goal}`);\n      }\n    }\n  }\n\n  /**\n   * Checks if the completed goals include the expected goals.\n   * @param {string[]} expectedGoals - The expected goals.\n   */\n  async expectCompletedGoalsToInclude(expectedGoals: string[]): Promise<void> {\n    await this.waitForPageToFullyLoad();\n\n    await this.page.waitForSelector(completedGoalsSectionSelector, {\n      visible: true,\n    });\n    await this.page\n      .waitForSelector(completedGoalsTopicNameSelector)\n      .catch(() => {\n        throw new Error('Completed goals section is empty');\n      });\n\n    const completedGoals = await this.page.$$eval(\n      `${completedGoalsSectionSelector} ${completedGoalsTopicNameSelector}`,\n      (elements: Element[]) =>\n        elements.map(el =>\n          el.textContent ? el.textContent.trim().replace('Learnt ', '') : ''\n        )\n    );\n\n    for (const expectedGoal of expectedGoals) {\n      if (!completedGoals.includes(expectedGoal)) {\n        throw new Error(\n          `Goal not found in completed lesson section: ${expectedGoal}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Checks if the completed stories include the expected stories.\n   * @param {string[]} expectedStories - The expected stories.\n   */\n  async expectStoriesCompletedToInclude(\n    expectedStories: string[]\n  ): Promise<void> {\n    await this.waitForPageToFullyLoad();\n\n    await this.page.waitForSelector(completedStoriesSectionSelector);\n    const storyNames = await this.page.$$(\n      completedStoriesSectionSelector + ' ' + storyNameSelector\n    );\n    const actualStories = await Promise.all(\n      storyNames.map(async storyName => {\n        return await this.page.evaluate(el => el.textContent.trim(), storyName);\n      })\n    );\n\n    for (const expectedStory of expectedStories) {\n      if (!actualStories.includes(expectedStory)) {\n        throw new Error(`Story not found: ${expectedStory}`);\n      }\n    }\n  }\n\n  /**\n   * Checks if the completed lessons include the expected lessons in the community lessons section of learner dashboard.\n   * @param {string[]} expectedLessons - The expected lessons.\n   */\n  async expectCompletedLessonsToInclude(\n    expectedLessons: string[]\n  ): Promise<void> {\n    const isMobileViewport = this.isViewportAtMobileWidth();\n    const completedLessonsSection = isMobileViewport\n      ? mobileCompletedLessonSection\n      : desktopCompletedLessonsSectionSelector;\n\n    await this.page.waitForSelector(completedLessonsSection);\n    await this.page.waitForSelector(lessonCardTitleSelector);\n    const lessonObjectives = await this.page.$$(\n      completedLessonsSection + ' ' + lessonCardTitleSelector\n    );\n\n    const actualLessons = await Promise.all(\n      lessonObjectives.map(async lessonObjective => {\n        return await this.page.evaluate(\n          el => el.textContent.trim(),\n          lessonObjective\n        );\n      })\n    );\n\n    for (const expectedLesson of expectedLessons) {\n      if (!actualLessons.includes(expectedLesson)) {\n        throw new Error(`Lesson not found: ${expectedLesson}`);\n      }\n    }\n  }\n\n  /**\n   * Plays a lesson from the \"Continue Where you Left off section\" section in learner dashboard.\n   * @param {string} lessonName - The name of the lesson.\n   */\n  async playLessonFromContinueWhereLeftOff(lessonName: string): Promise<void> {\n    await this.page.waitForSelector(continueFromWhereLeftOffSectionSelector);\n    await this.page.waitForSelector(lessonTileTitleSelector);\n\n    const lessonTileTitles = await this.page.$$(\n      continueFromWhereLeftOffSectionSelector + ' ' + lessonTileTitleSelector\n    );\n\n    for (const lessonTileTitle of lessonTileTitles) {\n      const actualLessonName = await this.page.evaluate(\n        el => el.textContent.trim(),\n        lessonTileTitle\n      );\n\n      if (actualLessonName === lessonName) {\n        await Promise.all([\n          this.page.waitForNavigation({waitUntil: 'networkidle0'}),\n          await this.waitForElementToBeClickable(lessonTileTitle),\n          lessonTileTitle.click(),\n        ]);\n        return;\n      }\n    }\n    throw new Error(`Lesson not found: ${lessonName}`);\n  }\n}\n\nexport let LoggedInUserFactory = (): LoggedInUser => new LoggedInUser();\n"
    }
  ],
  "questions": [
    "@seanlip \r\nMy PR modifies the two following files:  /core/templates/pages/preferences-page/subject-interests.component.ts and /core/templates/pages/preferences-page/subject-interests.html\r\n\r\nAfter typing the entry in the subject interest field, when the user moves to another field or directly hits enter, the value entered by the user will be captured. This is done by introducing an addOnBlur() function. To enable the Save button when subject interest is entered, onChange() is called from the add() method.\r\n\r\nDiff  in /core/templates/pages/preferences-page/form-fields/subject-interests.component.ts\r\n99d98\r\n<       this.onChange(this.subjectInterests);\r\n128,136d126\r\n<   addOnBlur(inputElement: HTMLInputElement): void {\r\n<     const inputValue = inputElement.value.trim();\r\n<     if (inputValue) {\r\n<       this.subjectInterests.push(inputValue);\r\n<       inputElement.value = ''; // Clear the input field\r\n<       this.formCtrl.setValue(''); // Reset form control\r\n<     }\r\n<   }\r\n\r\nDiff in /core/templates/pages/preferences-page/form-fields/subject-interests.component.html\r\n24d23\r\n<            (blur)=\"addOnBlur(subjectInterestInput)\"\r\n\r\nScreen recording of working solution on my local is shown below:\r\n\r\n\r\nhttps://github.com/user-attachments/assets/d421a343-b02f-499a-8a15-e6220b62e95d\r\n\r\n\r\nCan you please assign this issue to me?",
    "Hi @seanlip when doing migration #13219 the enter key logic was added. How it behaves is when anything is entered in subject interest field and pressed enter then the Performcontrol.dirty becomes true and save button would be enabled. This was the previous logic.\r\n\r\nWhat I have made changes is when we start typing in the subject interest field. The button becomes enabled. Even if we don't press enter in the subject interest field , the value is saved for this OnBlur event listener I have added .\r\n\r\nin `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` I have added ```(blur)=\"onBlur()\"\r\n           (input)=\"onInput($event)\">\r\n``` and in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` I have added below functions.\r\n\r\n```typescript\r\nonBlur(): void {\r\n    const value = this.subjectInterestInput.nativeElement.value.trim();\r\n    if (value && this.validInput(value)) {\r\n        // Add the current value to the list of subject interests.\r\n        this.subjectInterests.push(value);\r\n        this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n    }\r\n    this.onChange(this.subjectInterests);\r\n}\r\n\r\nonInput(event: Event): void {\r\n    const inputElement = event.target as HTMLInputElement;\r\n    const inputValue = inputElement.value.trim();\r\n    // Check if input is empty or valid\r\n    if (!inputValue) {\r\n        this.formCtrl.markAsPristine(); // Mark control as not dirty\r\n    } else if (this.validInput(inputValue)) {\r\n        this.formCtrl.markAsDirty(); // Mark control as dirty\r\n    }\r\n    // Update the parent form (if applicable)\r\n    this.onChange(this.subjectInterests);\r\n}\r\n```\r\n\r\nBelow is the video recording of what changes I have made.\r\n\r\n\r\nhttps://github.com/user-attachments/assets/c56bd190-866b-43f0-b2f0-c0f4d44c2473\r\n\r\nCan you please assign this to me? @seanlip",
    "Hi @mdodab @JayanthK007, firstly, thanks for outlining your solutions to the issue. Both seem like reasonable approaches and I appreciate that you've taken the time to look at the issue and find a good fix that works on your machine. \r\n\r\nThere is one more thing I need to check. We need to add a frontend/acceptance test to ensure this doesn't happen again. What is your proposal for where to add that test -- what code will you modify and can you show it working locally on your machine?\r\n\r\nAlso, unfortunately, I can only assign this issue to one of you, so this means that there's a chance one of your efforts will not result in being assigned -- sorry about that in advance. My intention is to assign this to the first person who gives a valid answer to the testing question (which was stated in the issue description but not really addressed AFAICT).",
    "Hi @seanlip. My testing approach is in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` when the user enters the subject interests before it was checking until ENTER key is pressed, what I have changed is to move to other focus for example save button. Below are the changes I have made.\r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n```\r\n\r\nwhen subject interest is added it is saved and again focus is made on the subject interest field. Then, another interest is added if there is any, and then it is saved again. \r\n\r\nI think this approach works. Does this answer your previous question? @seanlip",
    "Hi @seanlip According to your guidelines i have added two functions in `oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts` page .\r\n\r\n```Typescript\r\n      await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n      await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n\r\n      await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n```\r\nand in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` page \r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.\r\n   */\r\n  async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      await this.page.keyboard.press('Enter');\r\n    }\r\n  }\r\n\r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.\r\n   */\r\n  async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n  \r\n```\r\n\r\nIs this fine? @seanlip",
    "### Describe the bug\r\n\r\nUnable to add subject of interest from profile preferences, after typing in the \"subject interests\" field, save changes field is still disabled. When you change something else, click save changes, the subject of interest input is not saved.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\nhttps://www.oppiatestserver.org/preferences\r\n\r\n### Steps To Reproduce\r\n\r\n1. Navigate to Preferences\r\n2. Type in the \"subject interests\" field\r\n\r\n### Expected Behavior\r\n\r\n\"save changes\" button becomes enabled\r\n\r\nWe should add a frontend or acceptance test for this flow to ensure it doesn't break again.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/user-attachments/assets/570a4c0f-ce0c-4b01-bce1-6aa6f439f605\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\nChrome 130.0.6723.91\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore addressing the bug, please identify which PR caused the issue (you can follow the steps [here](https://github.com/oppia/oppia/wiki/How-to-find-the-commit-which-introduced-a-bug)). If you identify the PR, comment on the issue with a link to it. If not, mention the commit hash of the oldest commit you saw the bug on (and the month and year it was made in).\r\n\r\nThen, please leave a comment with details of the approach that you plan to take to fix the issue (see [example](https://github.com/oppia/oppia/issues/19157#issuecomment-1858788463)).\r\n\r\n**Note:** If this is your first Oppia issue, please make sure to follow our guidelines for [choosing an issue](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue) and [setting things up](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up). You will also need to show a demo of the fix working correctly on your local machine. Thanks!"
  ],
  "golden_answers": [
    "@seanlip I have changed the code the code in `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.ts` as below\r\n`onBlur(): void {\r\n  const value = this.subjectInterestInput.nativeElement.value.trim();\r\n  if (value && this.validInput(value)) {\r\n    // Add the current value to the list of subject interests.\r\n    this.subjectInterests.push(value);\r\n    this.subjectInterestInput.nativeElement.value = ''; // Clear the input field.\r\n  }\r\n  this.onChange(this.subjectInterests);\r\n  \r\n}` and `/oppia/core/templates/pages/preferences-page/form-fields/subject-interests.component.html` as `(blur)=\"onBlur()\" `\r\n\r\nbelow is the screen recording.\r\n\r\nhttps://github.com/user-attachments/assets/42e1d841-4306-4aa7-a0a8-b80830eaf161",
    "Hi @seanlip. My testing approach is in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` when the user enters the subject interests before it was checking until ENTER key is pressed, what I have changed is to move to other focus for example save button. Below are the changes I have made.\r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n```\r\n\r\nwhen subject interest is added it is saved and again focus is made on the subject interest field. Then, another interest is added if there is any, and then it is saved again. \r\n\r\nI think this approach works. Does this answer your previous question? @seanlip",
    "Hi @seanlip. My testing approach is in `oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts` when the user enters the subject interests before it was checking until ENTER key is pressed, what I have changed is to move to other focus for example save button. Below are the changes I have made.\r\n\r\n```Typescript \r\n/**\r\n   * Updates the user's subject interests in preference page.\r\n   * @param {string[]} interests - The new interests to set for the user.\r\n   */\r\n async updateSubjectInterests(interests: string[]): Promise<void> {\r\n    for (const interest of interests) {\r\n      // Focus and type in the subject interest input field\r\n      await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n      await this.type(subjectInterestsInputSelector, interest);\r\n      // Click on the save button to trigger onBlur\r\n      await this.page.click('.e2e-test-save-changes-button');\r\n    }\r\n  }\r\n```\r\n\r\nwhen subject interest is added it is saved and again focus is made on the subject interest field. Then, another interest is added if there is any, and then it is saved again. \r\n\r\nI think this approach works. Does this answer your previous question? @seanlip",
    "Thanks @JayanthK007, I think that seems reasonable. One suggestion: maybe you could have two functions, updateSubjectInterestsWithEnterKey and updateSubjectInterestsByBlurringField. Then call both from the top-level, one after the other. Does that sound good?\r\n\r\nAlso, I am assigning this issue to you. Thank you for the clear explanations!",
    "Not totally sure about using the page's save button in particular to take\r\nfocus away if the idea is to add another tag after that, since presumably a\r\nuser won't do that. Let's try to keep the acceptance tests to what users\r\nwould generally do.\r\n\r\nBut otherwise looks generally fine I think, feel free to make a PR and we\r\ncan have more specific discussion during the review phase. Thanks!\r\n\r\nOn Fri, Dec 6, 2024, 08:09 JayanthKumar Karthik ***@***.***>\r\nwrote:\r\n\r\n> Hi @seanlip <https://github.com/seanlip> According to your guidelines i\r\n> have added two functions in\r\n> oppia/core/tests/puppeteer-acceptance-tests/specs/logged-in-user/edit-profile-preferences-and-export-their-account.spec.ts\r\n> page .\r\n>\r\n>       await loggedInUser1.updateSubjectInterestsWithEnterKey(['math', 'science']);\r\n>       await loggedInUser1.updateSubjectInterestsByBlurringField(['art', 'history']);\r\n>\r\n>       await loggedInUser1.expectSubjectInterestsToBe(['math', 'science','art', 'history']);\r\n>\r\n> and in\r\n> oppia/core/tests/puppeteer-acceptance-tests/utilities/user/logged-in-user.ts\r\n> page\r\n>\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when enter key is pressed.   */\r\n>   async updateSubjectInterestsWithEnterKey(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       await this.page.keyboard.press('Enter');\r\n>     }\r\n>   }\r\n> /**   * Updates the user's subject interests in preference page.   * @param {string[]} interests - The new interests to set for the user when focus is moved to the next input or anywhere in the page.   */\r\n>   async updateSubjectInterestsByBlurringField(interests: string[]): Promise<void> {\r\n>     for (const interest of interests) {\r\n>       // Focus and type in the subject interest input field\r\n>       await this.page.click(subjectInterestsInputSelector); // Refocus the input field\r\n>       await this.type(subjectInterestsInputSelector, interest);\r\n>       // Click on the save button to trigger onBlur\r\n>       await this.page.click('.e2e-test-save-changes-button');\r\n>     }\r\n>   }\r\n>\r\n> Is this fine? @seanlip <https://github.com/seanlip>\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oppia/oppia/issues/21301#issuecomment-2521784617>, or\r\n> unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ACQV5SQJHTHUQZVHFT2OR7T2EDTNBAVCNFSM6AAAAABSDPHJ4WVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDKMRRG44DINRRG4>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>",
    "I checked out the latest commit and found that the issue still exists. The ‘Save Changes’ button is disabled when Subject Interests is entered.  I found that feature request #19216 was implemented to change the preference page from auto-save to a fixed-save bar at the bottom of the page in March 15, 2024.  Later a commit was made 3 months ago under [#20374](https://github.com/oppia/oppia/commit/1fb7160f178c54bb8407ffd9c74a9b79f3c6079c). This made changes to \"core/templates/pages/preferences-page/preferences-page.component.html\" and \"core/templates/pages/preferences-page/preferences-page.component.ts\" which I believe caused the issue. I am suspecting that the save button stays disabled because preferencesForm.dirty is not set to true when subject-interests changes. I would like to work on this issue and am trying to fix it in my local dev server, but please let me know if I am headed in the right direction to solve this."
  ],
  "questions_generated": [
    "What is the main issue reported in the oppia_oppia repository regarding the profile preferences?",
    "Which files are suspected to have caused the issue with the subject interests field according to the issue report?",
    "What is the suspected cause of the 'Save Changes' button remaining disabled when subject interests are entered?",
    "What steps are recommended for developers before addressing the bug in the oppia_oppia repository?",
    "How is the subject interests input field implemented in the HTML template of the preferences page?",
    "What specific change in the preferences page was implemented in March 2024, which might have contributed to the issue?",
    "What type of test is recommended to ensure that the subject interests functionality does not break again in the future?"
  ],
  "golden_answers_generated": [
    "The main issue is that users are unable to add subject interests from their profile preferences. After typing in the 'subject interests' field, the 'save changes' button remains disabled, and any input in the subject interests field is not saved when other changes are made and saved.",
    "The files 'core/templates/pages/preferences-page/preferences-page.component.html' and 'core/templates/pages/preferences-page/preferences-page.component.ts' are suspected to have caused the issue as changes were made to these files in a commit that is believed to have introduced the problem.",
    "The suspected cause is that the 'preferencesForm.dirty' property is not set to true when changes are made to the subject-interests field. This prevents the form from recognizing that a change has occurred, thus keeping the 'Save Changes' button disabled.",
    "Developers are advised to identify which PR caused the issue, either by finding the commit that introduced the bug or by mentioning the commit hash of the oldest commit where the bug was observed. They should then comment on the issue with their findings and propose an approach to fix the issue.",
    "The subject interests input field is implemented using a 'mat-form-field' with a 'mat-chip-list' where users can enter subject interests. It uses Angular Material components such as 'mat-autocomplete' and 'mat-chip' to allow users to add and remove subjects. The input is controlled by a form control and reacts to input events.",
    "In March 2024, a feature request (#19216) was implemented to change the preferences page from auto-save to a fixed-save bar at the bottom of the page. This change in the save mechanism could have contributed to the issue with saving subject interests.",
    "It is recommended to add a frontend or acceptance test for the flow of adding subject interests. This test should validate that the 'save changes' button becomes enabled when a subject is entered and that the entered subjects are correctly saved."
  ]
}