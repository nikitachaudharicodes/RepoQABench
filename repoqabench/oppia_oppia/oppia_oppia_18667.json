{
  "repo_name": "oppia_oppia",
  "issue_id": "18667",
  "issue_description": "# [BUG]: Not able to click topic tile in the math classroom page\n\n### Describe the bug\r\n\r\nIn the math classroom page (develop branch), the topic tile is not working i.e., on clicking the topic for navigating into the topic viewer page an error message is presented in the console.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\n`/learn/math`\r\n\r\n### Steps To Reproduce\r\n\r\nSteps to repro:\r\n1. Create profile and add admin rights\r\n2. Load dummy topic from the admin page\r\n3. Add the topic ID into classroom config in the Config tab under /admin\r\n4. Navigate to the math classroom page at /learn/math\r\n5. Click on the topic\r\n\r\n### Expected Behavior\r\n\r\n\r\n1. The console error should not be presented\r\n2. Should be able to click on the topic tile in the classroom and navigate to the topic viewer page.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/oppia/oppia/assets/57531197/d52e3fc3-a1a9-4b4e-91e5-e36a27d5c447\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore tackling the bug, please use `git bisect` (see https://git-scm.com/docs/git-bisect) to investigate which PR caused it (you only need to go back as far as commit https://github.com/oppia/oppia/commits/9a334e9). If you find the PR, leave a comment on this issue pointing to it, or just say that it happened before commit 9a334e9 if you could reproduce it there. This will help us fix the issue by reverting the faulty PR.\r\n\r\nAlso, if this is your first issue, please make sure to follow https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue and https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up before claiming it. Thanks!\r\n",
  "issue_comments": [
    {
      "id": 1646657023,
      "user": "Nik-09",
      "body": "Adding @prafulbbandre & @SanjaySajuJacob for ref."
    },
    {
      "id": 1741201473,
      "user": "seanlip",
      "body": "This issue arises because the dummy topics created when clicking on \"Activities > Load dummy new structures data\" in the Admin page are malformed. They don't have the necessary data (e.g. thumbnail, meta tag content, etc.)\n\nTo fix this, investigate the method _load_dummy_new_structures_data() in core/controllers/admin.py. Go to /admin and generate a topic according to the instructions in the issue description, Then visit the topic that was generated (which you can find from the /topics-and-skills-dashboard page). Your fix is correct once the generated topic does not contain any warnings.\n\nIn order to claim this issue, please show a screenshot of the generated topic that shows that it doesn't have any warnings, and explain the changes that you made in order to remove each warning. Thanks!"
    },
    {
      "id": 1742458119,
      "user": "SiddharthaKR",
      "body": "Hello there! would like to fix this issue, an you assign it to me"
    },
    {
      "id": 1742623133,
      "user": "prafulbbandre",
      "body": "Hi @SiddharthaKR ,\r\nThankyou for showing interest in this issue.\r\nAs Per the guidance at [Contributing-code-to-Oppia](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia), please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue."
    },
    {
      "id": 1743087067,
      "user": "SiddharthaKR",
      "body": "@prafulbbandre \r\nBased on the provided information in the issue tag and having a glance of the codebase.\r\n\r\n**Problem Description**:\r\nThe problem occurs when creating a new topic, and certain fields such as meta tag content are not properly validated.\r\nNULL values are being passed to the HTML templates, which is causing issues.\r\n\r\n**Files to be looked into**:\r\n_generate_dummy_classroom method in an admin.py.\r\n\r\ncreate_default_topic method in topic_domain.py  --> return cls(\r\n                                                                                    topic_id, name, name, url_fragment, None, None, None,...)\r\nsave_new_topic method in  topic_domain.py..\r\npublish_topic method in  topic_domain.py.\r\n\r\n_create_topic method in  topic_services.py.\r\n\r\nvalidate method in topic_domain.py.\r\n\r\nrequire_valid_meta_tag_content method in utils.py.\r\n\r\nAlso if necessary values are obtained at Fronted so the corresponding frontend files\r\n\r\n**Solution Steps**:-\r\n-Ensuring Default Topic Data in generate_dummy_classroom\r\n-Improving Validation In the create_default_topic - Validating the fields such as name, url_fragment, description, \r\n meta_tag_content, etc., to ensure they are not NULL and meet the required criteria.\r\n-Handling NULL Values in HTML Templates to resolve warnings\r\n"
    },
    {
      "id": 1747969823,
      "user": "prafulbbandre",
      "body": "> @prafulbbandre Based on the provided information in the issue tag and having a glance of the codebase.\r\n> \r\n> **Problem Description**: The problem occurs when creating a new topic, and certain fields such as meta tag content are not properly validated. NULL values are being passed to the HTML templates, which is causing issues.\r\n> \r\n> **Files to be looked into**: _generate_dummy_classroom method in an admin.py.\r\n> \r\n> create_default_topic method in topic_domain.py --> return cls( topic_id, name, name, url_fragment, None, None, None,...) save_new_topic method in topic_domain.py.. publish_topic method in topic_domain.py.\r\n> \r\n> _create_topic method in topic_services.py.\r\n> \r\n> validate method in topic_domain.py.\r\n> \r\n> require_valid_meta_tag_content method in utils.py.\r\n> \r\n> Also if necessary values are obtained at Fronted so the corresponding frontend files\r\n> \r\n> **Solution Steps**:- -Ensuring Default Topic Data in generate_dummy_classroom -Improving Validation In the create_default_topic - Validating the fields such as name, url_fragment, description, meta_tag_content, etc., to ensure they are not NULL and meet the required criteria. -Handling NULL Values in HTML Templates to resolve warnings\r\n\r\nAssigning @SiddharthaKR,\r\nPlease ensure you provide image and video proofs from the test server with the URL section in the PR.\r\nPlease provide PR opening date.\r\nThank you!"
    },
    {
      "id": 1748670129,
      "user": "SiddharthaKR",
      "body": "Thanks @prafulbbandre, considering  proper testing I will try to open the PR till 9th of October "
    },
    {
      "id": 1784216076,
      "user": "Nik-09",
      "body": "Hi @SiddharthaKR, any update?"
    },
    {
      "id": 1784217481,
      "user": "pritam2317",
      "body": "Hello @Nik-09  @prafulbbandre  will you please assign me to this issue ?"
    },
    {
      "id": 1785022656,
      "user": "seanlip",
      "body": "I've deassigned @SiddharthaKR due to inactivity. \r\n\r\n@pritam2317 Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue. Try to also explain clearly why this bug is occurring, pointing to specific lines of code as needed to support your argument.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 1807084641,
      "user": "jeanninedar",
      "body": "Hello, we are two students who would like to fix this bug. For our university course we are supposed to find an open source project that seems relevant to us and liked the idea of your project. We would use the next 4 weeks to fix this bug if that's okay :) "
    },
    {
      "id": 1807566199,
      "user": "prafulbbandre",
      "body": "Hi @jeanninedar Please follow this [comment](https://github.com/oppia/oppia/issues/18667#issuecomment-1785022656) to get started."
    },
    {
      "id": 1813965479,
      "user": "pritam2317",
      "body": "I have already added the following tasks in _load_dummy_new_structures_data() of core/controllers/admin.py. -\r\ni)thumbnail_filename \r\nii)thumbnail_bg_color \r\nnow the slicing problem is solved. \r\n![Screenshot from 2023-11-16 13-32-34](https://github.com/oppia/oppia/assets/72196402/cd6f50f9-05de-41cb-acf5-cf868c4b1036)\r\n\r\nI'm little bit confused whether we should publish the dummy topic or not? and Please assign me to this issue."
    },
    {
      "id": 1813975992,
      "user": "Nik-09",
      "body": "Thank you @pritam2317 for solving the issue of slicing. I am assigning this issue to you. I think publishing the Dummy Topic will be beneficial since this will save time for development/testing for others.\r\n\r\n@prafulbbandre @seanlip WDYT regarding the publication of the dummy topic?\r\nThanks\r\n"
    },
    {
      "id": 1813998877,
      "user": "seanlip",
      "body": "Yup, ok to publish the dummy topic. Thanks!"
    },
    {
      "id": 1814478069,
      "user": "jeanninedar",
      "body": "Hello,\r\nas this issue has now been assigned, we will keep looking for other open issues.\r\n\r\nKind regards and best of luck!  "
    },
    {
      "id": 1814499758,
      "user": "prafulbbandre",
      "body": "> Hello, as this issue has now been assigned, we will keep looking for other open issues.\r\n> \r\n> Kind regards and best of luck!\r\n\r\nHi @jeanninedar ,\r\nPlease take a look at this starter [Good first issues](https://github.com/orgs/oppia/projects/3/views/10) to get started and rather than asking to get assign try to explain your solution to any open issue this will help you to get assigned to it. If the solution looks good we can assign you the issue.\r\nHope this helps.\r\nThanks!"
    },
    {
      "id": 1816844609,
      "user": "jeanninedar",
      "body": "\r\n\r\n\r\n\r\n> > Hello, as this issue has now been assigned, we will keep looking for other open issues.\r\n> > Kind regards and best of luck!\r\n> \r\n> Hi @jeanninedar , Please take a look at this starter [Good first issues](https://github.com/orgs/oppia/projects/3/views/10) to get started and rather than asking to get assign try to explain your solution to any open issue this will help you to get assigned to it. If the solution looks good we can assign you the issue. Hope this helps. Thanks!\r\n\r\nHey @prafulbbandre,\r\nthank you very much for the advice! We'll have a look at it :)"
    },
    {
      "id": 1826397413,
      "user": "prafulbbandre",
      "body": "Hi @pritam2317 Please let me know the PR opening date.\r\nThanks!"
    },
    {
      "id": 1826398920,
      "user": "pritam2317",
      "body": "Within 2-3 day's I'll create the PR because currently i'm out of station. @prafulbbandre "
    },
    {
      "id": 1835702991,
      "user": "seanlip",
      "body": "It's been 2-3 days and there's been no update, so I'm deassigning. If anyone else would like to take up this issue, please post a screenshot/video showing that it's working on your local machine and explain what code changes you made. Thanks!"
    },
    {
      "id": 1835707758,
      "user": "pritam2317",
      "body": "within today i will do it forsure..."
    },
    {
      "id": 1836567241,
      "user": "pritam2317",
      "body": "I have created the PR https://github.com/oppia/oppia/pull/19241. Its under review @Nik-09  or @prafulbbandre PTAL."
    },
    {
      "id": 1847121384,
      "user": "mahmoodshariff123",
      "body": "Is this issue solved or not?.if not solved can you please assign it to me.i will do my best if i can possible to do"
    },
    {
      "id": 1847204157,
      "user": "pritam2317",
      "body": "Hi @mahmoodshariff123 I have created the PR. You can take another good-first-issue from [here](https://github.com/oppia/oppia/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)\r\n\r\nThanks "
    },
    {
      "id": 1849978572,
      "user": "shrutibhardwaj22",
      "body": "I want to work on this issue. please assign me this issue."
    },
    {
      "id": 1850096288,
      "user": "seanlip",
      "body": "@shrutibhardwaj22 Please follow the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, and don't pick issues that are already assigned. When claiming an issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.).\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 1881521242,
      "user": "prafulbbandre",
      "body": "fixed https://github.com/oppia/oppia/commit/6171792008266ad07826564316712b4b7b10eb61"
    }
  ],
  "text_context": "# [BUG]: Not able to click topic tile in the math classroom page\n\n### Describe the bug\r\n\r\nIn the math classroom page (develop branch), the topic tile is not working i.e., on clicking the topic for navigating into the topic viewer page an error message is presented in the console.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\n`/learn/math`\r\n\r\n### Steps To Reproduce\r\n\r\nSteps to repro:\r\n1. Create profile and add admin rights\r\n2. Load dummy topic from the admin page\r\n3. Add the topic ID into classroom config in the Config tab under /admin\r\n4. Navigate to the math classroom page at /learn/math\r\n5. Click on the topic\r\n\r\n### Expected Behavior\r\n\r\n\r\n1. The console error should not be presented\r\n2. Should be able to click on the topic tile in the classroom and navigate to the topic viewer page.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/oppia/oppia/assets/57531197/d52e3fc3-a1a9-4b4e-91e5-e36a27d5c447\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore tackling the bug, please use `git bisect` (see https://git-scm.com/docs/git-bisect) to investigate which PR caused it (you only need to go back as far as commit https://github.com/oppia/oppia/commits/9a334e9). If you find the PR, leave a comment on this issue pointing to it, or just say that it happened before commit 9a334e9 if you could reproduce it there. This will help us fix the issue by reverting the faulty PR.\r\n\r\nAlso, if this is your first issue, please make sure to follow https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue and https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up before claiming it. Thanks!\r\n\n\nAdding @prafulbbandre & @SanjaySajuJacob for ref.\n\nThis issue arises because the dummy topics created when clicking on \"Activities > Load dummy new structures data\" in the Admin page are malformed. They don't have the necessary data (e.g. thumbnail, meta tag content, etc.)\n\nTo fix this, investigate the method _load_dummy_new_structures_data() in core/controllers/admin.py. Go to /admin and generate a topic according to the instructions in the issue description, Then visit the topic that was generated (which you can find from the /topics-and-skills-dashboard page). Your fix is correct once the generated topic does not contain any warnings.\n\nIn order to claim this issue, please show a screenshot of the generated topic that shows that it doesn't have any warnings, and explain the changes that you made in order to remove each warning. Thanks!\n\nHello there! would like to fix this issue, an you assign it to me\n\nHi @SiddharthaKR ,\r\nThankyou for showing interest in this issue.\r\nAs Per the guidance at [Contributing-code-to-Oppia](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia), please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\n\n@prafulbbandre \r\nBased on the provided information in the issue tag and having a glance of the codebase.\r\n\r\n**Problem Description**:\r\nThe problem occurs when creating a new topic, and certain fields such as meta tag content are not properly validated.\r\nNULL values are being passed to the HTML templates, which is causing issues.\r\n\r\n**Files to be looked into**:\r\n_generate_dummy_classroom method in an admin.py.\r\n\r\ncreate_default_topic method in topic_domain.py  --> return cls(\r\n                                                                                    topic_id, name, name, url_fragment, None, None, None,...)\r\nsave_new_topic method in  topic_domain.py..\r\npublish_topic method in  topic_domain.py.\r\n\r\n_create_topic method in  topic_services.py.\r\n\r\nvalidate method in topic_domain.py.\r\n\r\nrequire_valid_meta_tag_content method in utils.py.\r\n\r\nAlso if necessary values are obtained at Fronted so the corresponding frontend files\r\n\r\n**Solution Steps**:-\r\n-Ensuring Default Topic Data in generate_dummy_classroom\r\n-Improving Validation In the create_default_topic - Validating the fields such as name, url_fragment, description, \r\n meta_tag_content, etc., to ensure they are not NULL and meet the required criteria.\r\n-Handling NULL Values in HTML Templates to resolve warnings\r\n\n\n> @prafulbbandre Based on the provided information in the issue tag and having a glance of the codebase.\r\n> \r\n> **Problem Description**: The problem occurs when creating a new topic, and certain fields such as meta tag content are not properly validated. NULL values are being passed to the HTML templates, which is causing issues.\r\n> \r\n> **Files to be looked into**: _generate_dummy_classroom method in an admin.py.\r\n> \r\n> create_default_topic method in topic_domain.py --> return cls( topic_id, name, name, url_fragment, None, None, None,...) save_new_topic method in topic_domain.py.. publish_topic method in topic_domain.py.\r\n> \r\n> _create_topic method in topic_services.py.\r\n> \r\n> validate method in topic_domain.py.\r\n> \r\n> require_valid_meta_tag_content method in utils.py.\r\n> \r\n> Also if necessary values are obtained at Fronted so the corresponding frontend files\r\n> \r\n> **Solution Steps**:- -Ensuring Default Topic Data in generate_dummy_classroom -Improving Validation In the create_default_topic - Validating the fields such as name, url_fragment, description, meta_tag_content, etc., to ensure they are not NULL and meet the required criteria. -Handling NULL Values in HTML Templates to resolve warnings\r\n\r\nAssigning @SiddharthaKR,\r\nPlease ensure you provide image and video proofs from the test server with the URL section in the PR.\r\nPlease provide PR opening date.\r\nThank you!\n\nThanks @prafulbbandre, considering  proper testing I will try to open the PR till 9th of October \n\nHi @SiddharthaKR, any update?\n\nHello @Nik-09  @prafulbbandre  will you please assign me to this issue ?\n\nI've deassigned @SiddharthaKR due to inactivity. \r\n\r\n@pritam2317 Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue. Try to also explain clearly why this bug is occurring, pointing to specific lines of code as needed to support your argument.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nHello, we are two students who would like to fix this bug. For our university course we are supposed to find an open source project that seems relevant to us and liked the idea of your project. We would use the next 4 weeks to fix this bug if that's okay :) \n\nHi @jeanninedar Please follow this [comment](https://github.com/oppia/oppia/issues/18667#issuecomment-1785022656) to get started.\n\nI have already added the following tasks in _load_dummy_new_structures_data() of core/controllers/admin.py. -\r\ni)thumbnail_filename \r\nii)thumbnail_bg_color \r\nnow the slicing problem is solved. \r\n![Screenshot from 2023-11-16 13-32-34](https://github.com/oppia/oppia/assets/72196402/cd6f50f9-05de-41cb-acf5-cf868c4b1036)\r\n\r\nI'm little bit confused whether we should publish the dummy topic or not? and Please assign me to this issue.\n\nThank you @pritam2317 for solving the issue of slicing. I am assigning this issue to you. I think publishing the Dummy Topic will be beneficial since this will save time for development/testing for others.\r\n\r\n@prafulbbandre @seanlip WDYT regarding the publication of the dummy topic?\r\nThanks\r\n\n\nYup, ok to publish the dummy topic. Thanks!\n\nHello,\r\nas this issue has now been assigned, we will keep looking for other open issues.\r\n\r\nKind regards and best of luck!  \n\n> Hello, as this issue has now been assigned, we will keep looking for other open issues.\r\n> \r\n> Kind regards and best of luck!\r\n\r\nHi @jeanninedar ,\r\nPlease take a look at this starter [Good first issues](https://github.com/orgs/oppia/projects/3/views/10) to get started and rather than asking to get assign try to explain your solution to any open issue this will help you to get assigned to it. If the solution looks good we can assign you the issue.\r\nHope this helps.\r\nThanks!\n\n\r\n\r\n\r\n\r\n> > Hello, as this issue has now been assigned, we will keep looking for other open issues.\r\n> > Kind regards and best of luck!\r\n> \r\n> Hi @jeanninedar , Please take a look at this starter [Good first issues](https://github.com/orgs/oppia/projects/3/views/10) to get started and rather than asking to get assign try to explain your solution to any open issue this will help you to get assigned to it. If the solution looks good we can assign you the issue. Hope this helps. Thanks!\r\n\r\nHey @prafulbbandre,\r\nthank you very much for the advice! We'll have a look at it :)\n\nHi @pritam2317 Please let me know the PR opening date.\r\nThanks!\n\nWithin 2-3 day's I'll create the PR because currently i'm out of station. @prafulbbandre \n\nIt's been 2-3 days and there's been no update, so I'm deassigning. If anyone else would like to take up this issue, please post a screenshot/video showing that it's working on your local machine and explain what code changes you made. Thanks!\n\nwithin today i will do it forsure...\n\nI have created the PR https://github.com/oppia/oppia/pull/19241. Its under review @Nik-09  or @prafulbbandre PTAL.\n\nIs this issue solved or not?.if not solved can you please assign it to me.i will do my best if i can possible to do\n\nHi @mahmoodshariff123 I have created the PR. You can take another good-first-issue from [here](https://github.com/oppia/oppia/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)\r\n\r\nThanks \n\nI want to work on this issue. please assign me this issue.\n\n@shrutibhardwaj22 Please follow the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, and don't pick issues that are already assigned. When claiming an issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.).\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nfixed https://github.com/oppia/oppia/commit/6171792008266ad07826564316712b4b7b10eb61",
  "pr_link": "https://github.com/oppia/oppia/pull/19241",
  "code_context": [
    {
      "filename": "core/controllers/admin.py",
      "content": "# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Controllers for the admin view.\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport logging\nimport random\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.controllers import domain_objects_validator as validation_method\nfrom core.domain import auth_services\nfrom core.domain import blog_services\nfrom core.domain import classroom_config_domain\nfrom core.domain import classroom_config_services\nfrom core.domain import collection_services\nfrom core.domain import config_domain\nfrom core.domain import config_services\nfrom core.domain import email_manager\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import fs_services\nfrom core.domain import opportunity_services\nfrom core.domain import platform_feature_services as feature_services\nfrom core.domain import platform_parameter_domain as parameter_domain\nfrom core.domain import platform_parameter_list\nfrom core.domain import platform_parameter_registry as registry\nfrom core.domain import question_domain\nfrom core.domain import question_services\nfrom core.domain import recommendations_services\nfrom core.domain import rights_manager\nfrom core.domain import role_services\nfrom core.domain import search_services\nfrom core.domain import skill_domain\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import stats_services\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_fetchers\nfrom core.domain import topic_services\nfrom core.domain import translation_domain\nfrom core.domain import user_services\nfrom core.domain import wipeout_service\n\nfrom typing import Dict, List, Optional, TypedDict, Union, cast\n\n# Platform paramters that we plan to show on the the release-coordinator page.\nPLATFORM_PARAMS_TO_SHOW_IN_RC_PAGE = set([\n    platform_parameter_list.ParamNames.PROMO_BAR_ENABLED.value,\n    platform_parameter_list.ParamNames.PROMO_BAR_MESSAGE.value\n])\n\n# Platform parameters that we plan to show on the blog admin page.\nPLATFORM_PARAMS_TO_SHOW_IN_BLOG_ADMIN_PAGE = set([\n    (\n        platform_parameter_list.ParamNames.\n        MAX_NUMBER_OF_TAGS_ASSIGNED_TO_BLOG_POST.value\n    )\n])\n\nsupported_languages: List[str] = [\n    lang['id'] for lang in constants.SUPPORTED_AUDIO_LANGUAGES]\n\n\nclass ClassroomPageDataDict(TypedDict):\n    \"\"\"Dict representation of classroom page's data dictionary.\"\"\"\n\n    course_details: str\n    name: str\n    topic_ids: List[str]\n    topic_list_intro: str\n    url_fragment: str\n\n\nAllowedAdminConfigPropertyValueTypes = Union[\n    str, bool, float, Dict[str, str], List[str], ClassroomPageDataDict\n]\n\n\nclass AdminHandlerNormalizePayloadDict(TypedDict):\n    \"\"\"Dict representation of AdminHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    action: Optional[str]\n    exploration_id: Optional[str]\n    collection_id: Optional[str]\n    num_dummy_exps_to_generate: Optional[int]\n    num_dummy_exps_to_publish: Optional[int]\n    new_config_property_values: Optional[\n        Dict[str, AllowedAdminConfigPropertyValueTypes]\n    ]\n    config_property_id: Optional[str]\n    data: Optional[str]\n    topic_id: Optional[str]\n    platform_param_name: Optional[str]\n    commit_message: Optional[str]\n    new_rules: Optional[List[parameter_domain.PlatformParameterRule]]\n    exp_id: Optional[str]\n    default_value: Dict[str, parameter_domain.PlatformDataTypes]\n\n\nclass AdminHandler(\n    base.BaseHandler[AdminHandlerNormalizePayloadDict, Dict[str, str]]\n):\n    \"\"\"Handler for the admin page.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {},\n        'POST': {\n            'action': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': [\n                        'reload_exploration', 'reload_collection',\n                        'generate_dummy_explorations', 'clear_search_index',\n                        'generate_dummy_new_structures_data',\n                        'generate_dummy_new_skill_data',\n                        'generate_dummy_classroom',\n                        'save_config_properties', 'revert_config_property',\n                        'upload_topic_similarities',\n                        'regenerate_topic_related_opportunities',\n                        'update_platform_parameter_rules',\n                        'rollback_exploration_to_safe_state'\n                    ]\n                },\n                # TODO(#13331): Remove default_value when it is confirmed that,\n                # for clearing the search indices of exploration & collection\n                # 'action' field must be provided in the payload.\n                'default_value': None\n            },\n            'exploration_id': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'collection_id': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'num_dummy_exps_to_generate': {\n                'schema': {\n                    'type': 'int'\n                },\n                'default_value': None\n            },\n            'num_dummy_exps_to_publish': {\n                'schema': {\n                    'type': 'int'\n                },\n                'default_value': None\n            },\n            'new_config_property_values': {\n                'schema': {\n                    'type': 'object_dict',\n                    'validation_method': (\n                        validation_method.validate_new_config_property_values)\n                },\n                'default_value': None\n            },\n            'config_property_id': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'data': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'topic_id': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'platform_param_name': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'commit_message': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'new_rules': {\n                'schema': {\n                    'type': 'list',\n                    'items': {\n                        'type': 'object_dict',\n                        'object_class': parameter_domain.PlatformParameterRule\n                    }\n                },\n                'default_value': None\n            },\n            'exp_id': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'default_value': {\n                'schema': {\n                    'type': 'object_dict',\n                    'validation_method': (\n                        validation_method.\n                        validate_new_default_value_of_platform_parameter)\n                },\n                'default_value': None\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def get(self) -> None:\n        \"\"\"Populates the data on the admin page.\"\"\"\n        demo_exploration_ids = list(feconf.DEMO_EXPLORATIONS.keys())\n\n        topic_summaries = topic_fetchers.get_all_topic_summaries()\n        topic_summary_dicts = [\n            summary.to_dict() for summary in topic_summaries]\n\n        platform_params_dicts = (\n            feature_services.\n            get_all_platform_parameters_except_feature_flag_dicts()\n        )\n        # Removes promo-bar related and blog related platform params as\n        # they are handled in release-coordinator page and blog admin page\n        # respectively.\n        platform_params_dicts = [\n            param for param in platform_params_dicts\n            if (\n                param['name'] not in PLATFORM_PARAMS_TO_SHOW_IN_RC_PAGE and\n                param['name'] not in PLATFORM_PARAMS_TO_SHOW_IN_BLOG_ADMIN_PAGE\n            )\n        ]\n\n        config_properties = config_domain.Registry.get_config_property_schemas()\n\n        self.render_json({\n            'config_properties': config_properties,\n            'demo_collections': sorted(feconf.DEMO_COLLECTIONS.items()),\n            'demo_explorations': sorted(feconf.DEMO_EXPLORATIONS.items()),\n            'demo_exploration_ids': demo_exploration_ids,\n            'updatable_roles': role_services.UPDATABLE_ROLES,\n            'viewable_roles': role_services.VIEWABLE_ROLES,\n            'human_readable_roles': role_services.HUMAN_READABLE_ROLES,\n            'role_to_actions': role_services.get_role_actions(),\n            'topic_summaries': topic_summary_dicts,\n            'platform_params_dicts': platform_params_dicts,\n        })\n\n    @acl_decorators.can_access_admin_page\n    def post(self) -> None:\n        \"\"\"Performs a series of actions based on the action parameter on the\n        admin page.\n\n        Raises:\n            Exception. The exploration_id must be provided when the action\n                is reload_exploration.\n            Exception. The collection_id must be provided when the action\n                is reload_collection.\n            Exception. The num_dummy_exps_to_generate must be provided when\n                the action is generate_dummy_explorations.\n            Exception. The num_dummy_exps_to_publish must be provided when\n                the action is generate_dummy_explorations.\n            InvalidInputException. Generate count cannot be less than publish\n                count.\n            Exception. The new_config_property_values must be provided\n                when the action is save_config_properties.\n            Exception. The config_property_id must be provided when the\n                action is revert_config_property.\n            Exception. The data must be provided when the action is\n                upload_topic_similarities.\n            Exception. The topic_id must be provided when the action is\n                regenerate_topic_related_opportunities.\n            Exception. The exp_id' must be provided when the action is\n                rollback_exploration_to_safe_state.\n            Exception. The platform_param_name must be provided when the action\n                is update_platform_parameter_rules.\n            Exception. The new_rules must be provided when the action is\n                update_platform_parameter_rules.\n            Exception. The commit_message must be provided when the action\n                is update_platform_parameter_rules.\n            InvalidInputException. The input provided is not valid.\n        \"\"\"\n        assert self.user_id is not None\n        assert self.normalized_payload is not None\n        action = self.normalized_payload.get('action')\n        try:\n            result = {}\n            if action == 'reload_exploration':\n                exploration_id = self.normalized_payload.get('exploration_id')\n                if exploration_id is None:\n                    raise Exception(\n                        'The \\'exploration_id\\' must be provided when the'\n                        ' action is reload_exploration.'\n                    )\n                self._reload_exploration(exploration_id)\n            elif action == 'reload_collection':\n                collection_id = self.normalized_payload.get('collection_id')\n                if collection_id is None:\n                    raise Exception(\n                        'The \\'collection_id\\' must be provided when the'\n                        ' action is reload_collection.'\n                    )\n                self._reload_collection(collection_id)\n            elif action == 'generate_dummy_explorations':\n                num_dummy_exps_to_generate = self.normalized_payload.get(\n                    'num_dummy_exps_to_generate')\n                if num_dummy_exps_to_generate is None:\n                    raise Exception(\n                        'The \\'num_dummy_exps_to_generate\\' must be provided'\n                        ' when the action is generate_dummy_explorations.'\n                    )\n                num_dummy_exps_to_publish = self.normalized_payload.get(\n                    'num_dummy_exps_to_publish')\n                if num_dummy_exps_to_publish is None:\n                    raise Exception(\n                        'The \\'num_dummy_exps_to_publish\\' must be provided'\n                        ' when the action is generate_dummy_explorations.'\n                    )\n\n                if num_dummy_exps_to_generate < num_dummy_exps_to_publish:\n                    raise self.InvalidInputException(\n                        'Generate count cannot be less than publish count')\n\n                self._generate_dummy_explorations(\n                    num_dummy_exps_to_generate, num_dummy_exps_to_publish)\n            elif action == 'clear_search_index':\n                search_services.clear_collection_search_index()\n                search_services.clear_exploration_search_index()\n                search_services.clear_blog_post_summaries_search_index()\n            elif action == 'generate_dummy_new_structures_data':\n                self._load_dummy_new_structures_data()\n            elif action == 'generate_dummy_new_skill_data':\n                self._generate_dummy_skill_and_questions()\n            elif action == 'generate_dummy_classroom':\n                self._generate_dummy_classroom()\n            elif action == 'save_config_properties':\n                new_config_property_values = self.normalized_payload.get(\n                    'new_config_property_values')\n                if new_config_property_values is None:\n                    raise Exception(\n                        'The \\'new_config_property_values\\' must be provided'\n                        ' when the action is save_config_properties.'\n                    )\n                logging.info(\n                    '[ADMIN] %s saved config property values: %s' %\n                    (self.user_id, new_config_property_values))\n                for (name, value) in new_config_property_values.items():\n                    config_services.set_property(self.user_id, name, value)\n            elif action == 'revert_config_property':\n                config_property_id = self.normalized_payload.get(\n                    'config_property_id')\n                if config_property_id is None:\n                    raise Exception(\n                        'The \\'config_property_id\\' must be provided'\n                        ' when the action is revert_config_property.'\n                    )\n                logging.info(\n                    '[ADMIN] %s reverted config property: %s' %\n                    (self.user_id, config_property_id))\n                config_services.revert_property(\n                    self.user_id, config_property_id)\n            elif action == 'upload_topic_similarities':\n                data = self.normalized_payload.get('data')\n                if data is None:\n                    raise Exception(\n                        'The \\'data\\' must be provided when the action'\n                        ' is upload_topic_similarities.'\n                    )\n                recommendations_services.update_topic_similarities(data)\n            elif action == 'regenerate_topic_related_opportunities':\n                topic_id = self.normalized_payload.get('topic_id')\n                if topic_id is None:\n                    raise Exception(\n                        'The \\'topic_id\\' must be provided when the action'\n                        ' is regenerate_topic_related_opportunities.'\n                    )\n                opportunities_count = (\n                    opportunity_services\n                    .regenerate_opportunities_related_to_topic(\n                        topic_id, delete_existing_opportunities=True))\n                result = {\n                    'opportunities_count': opportunities_count\n                }\n            elif action == 'rollback_exploration_to_safe_state':\n                exp_id = self.normalized_payload.get('exp_id')\n                if exp_id is None:\n                    raise Exception(\n                        'The \\'exp_id\\' must be provided when the action'\n                        ' is rollback_exploration_to_safe_state.'\n                    )\n                version = (\n                    exp_services.rollback_exploration_to_safe_state(exp_id))\n                result = {\n                    'version': version\n                }\n            else:\n                # The handler schema defines the possible values of 'action'.\n                # If 'action' has a value other than those defined in the\n                # schema, a Bad Request error will be thrown. Hence, 'action'\n                # must be 'update_platform_parameter_rules' if this branch is\n                # executed.\n                assert action == 'update_platform_parameter_rules'\n                platform_param_name = self.normalized_payload.get(\n                    'platform_param_name'\n                )\n                if platform_param_name is None:\n                    raise Exception(\n                        'The \\'platform_param_name\\' must be provided when '\n                        'the action is update_platform_parameter_rules.'\n                    )\n                new_rules = self.normalized_payload.get('new_rules')\n                if new_rules is None:\n                    raise Exception(\n                        'The \\'new_rules\\' must be provided when the action'\n                        ' is update_platform_parameter_rules.'\n                    )\n                commit_message = self.normalized_payload.get('commit_message')\n                if commit_message is None:\n                    raise Exception(\n                        'The \\'commit_message\\' must be provided when the '\n                        'action is update_platform_parameter_rules.'\n                    )\n                default_value = self.normalized_payload.get('default_value')\n                assert default_value is not None\n\n                try:\n                    registry.Registry.update_platform_parameter(\n                        platform_param_name, self.user_id, commit_message,\n                        new_rules,\n                        default_value['value']\n                    )\n                except (\n                    utils.ValidationError,\n                    feature_services.PlatformParameterNotFoundException\n                ) as e:\n                    raise self.InvalidInputException(e)\n\n                new_rule_dicts = [rule.to_dict() for rule in new_rules]\n                logging.info(\n                    '[ADMIN] %s updated feature %s with new rules: '\n                    '%s.' % (self.user_id, platform_param_name, new_rule_dicts))\n            self.render_json(result)\n        except Exception as e:\n            logging.exception('[ADMIN] %s', e)\n            self.render_json({'error': str(e)})\n            raise e\n\n    def _reload_exploration(self, exploration_id: str) -> None:\n        \"\"\"Reloads the exploration in dev_mode corresponding to the given\n        exploration id.\n\n        Args:\n            exploration_id: str. The exploration id.\n\n        Raises:\n            Exception. Cannot reload an exploration in production.\n        \"\"\"\n        if constants.DEV_MODE:\n            logging.info(\n                '[ADMIN] %s reloaded exploration %s' %\n                (self.user_id, exploration_id))\n            exp_services.load_demo(exploration_id)\n            rights_manager.release_ownership_of_exploration(\n                user_services.get_system_user(), exploration_id)\n        else:\n            raise Exception('Cannot reload an exploration in production.')\n\n    def _create_dummy_question(\n        self,\n        question_id: str,\n        question_content: str,\n        linked_skill_ids: List[str]\n    ) -> question_domain.Question:\n        \"\"\"Creates a dummy question object with the given question ID.\n\n        Args:\n            question_id: str. The ID of the question to be created.\n            question_content: str. The question content.\n            linked_skill_ids: list(str). The IDs of the skills to which the\n                question is linked to.\n\n        Returns:\n            Question. The dummy question with given values.\n        \"\"\"\n        content_id_generator = translation_domain.ContentIdGenerator()\n\n        state = state_domain.State.create_default_state(\n            'ABC',\n            content_id_generator.generate(\n                translation_domain.ContentType.CONTENT),\n            content_id_generator.generate(\n                translation_domain.ContentType.DEFAULT_OUTCOME),\n            is_initial_state=True)\n\n        state.update_interaction_id('TextInput')\n        state.update_interaction_customization_args({\n            'placeholder': {\n                'value': {\n                    'content_id': content_id_generator.generate(\n                        translation_domain.ContentType.CUSTOMIZATION_ARG\n                    ),\n                    'unicode_str': ''\n                }\n            },\n            'rows': {'value': 1},\n            'catchMisspellings': {\n                'value': False\n            }\n        })\n\n        state.update_linked_skill_id(None)\n        state.update_content(state_domain.SubtitledHtml(\n            'content_0', question_content))\n\n        solution = state_domain.Solution(\n            'TextInput', False, 'Solution', state_domain.SubtitledHtml(\n                content_id_generator.generate(\n                    translation_domain.ContentType.SOLUTION),\n                '<p>This is a solution.</p>'))\n        hints_list = [\n            state_domain.Hint(\n                state_domain.SubtitledHtml(\n                    content_id_generator.generate(\n                        translation_domain.ContentType.HINT),\n                    '<p>This is a hint.</p>')\n            )\n        ]\n\n        state.update_interaction_solution(solution)\n        state.update_interaction_hints(hints_list)\n        state.update_interaction_default_outcome(\n            state_domain.Outcome(\n                None, None,\n                state_domain.SubtitledHtml(\n                    content_id_generator.generate(\n                        translation_domain.ContentType.DEFAULT_OUTCOME),\n                    '<p>Dummy Feedback</p>'),\n                True, [], None, None\n            )\n        )\n        question = question_domain.Question(\n            question_id, state,\n            feconf.CURRENT_STATE_SCHEMA_VERSION,\n            constants.DEFAULT_LANGUAGE_CODE, 0, linked_skill_ids, [],\n            content_id_generator.next_content_id_index)\n        return question\n\n    def _create_dummy_skill(\n        self, skill_id: str, skill_description: str, explanation: str\n    ) -> skill_domain.Skill:\n        \"\"\"Creates a dummy skill object with the given values.\n\n        Args:\n            skill_id: str. The ID of the skill to be created.\n            skill_description: str. The description of the skill.\n            explanation: str. The review material for the skill.\n\n        Returns:\n            Skill. The dummy skill with given values.\n        \"\"\"\n        rubrics = [\n            skill_domain.Rubric(\n                constants.SKILL_DIFFICULTIES[0], ['Explanation 1']),\n            skill_domain.Rubric(\n                constants.SKILL_DIFFICULTIES[1], ['Explanation 2']),\n            skill_domain.Rubric(\n                constants.SKILL_DIFFICULTIES[2], ['Explanation 3'])]\n        skill = skill_domain.Skill.create_default_skill(\n            skill_id, skill_description, rubrics)\n        skill.update_explanation(state_domain.SubtitledHtml('1', explanation))\n        return skill\n\n    def _load_dummy_new_structures_data(self) -> None:\n        \"\"\"Loads the database with two topics (one of which is empty), a story\n        and three skills in the topic (two of them in a subtopic) and a question\n        attached to each skill.\n\n        Raises:\n            Exception. Cannot load new structures data in production mode.\n            Exception. User does not have enough rights to generate data.\n        \"\"\"\n        assert self.user_id is not None\n        if constants.DEV_MODE:\n            if feconf.ROLE_ID_CURRICULUM_ADMIN not in self.user.roles:\n                raise Exception(\n                    'User does not have enough rights to generate data.')\n            topic_id_1 = topic_fetchers.get_new_topic_id()\n            topic_id_2 = topic_fetchers.get_new_topic_id()\n\n            story_id = story_services.get_new_story_id()\n\n            skill_id_1 = skill_services.get_new_skill_id()\n            skill_id_2 = skill_services.get_new_skill_id()\n            skill_id_3 = skill_services.get_new_skill_id()\n\n            question_id_1 = question_services.get_new_question_id()\n            question_id_2 = question_services.get_new_question_id()\n            question_id_3 = question_services.get_new_question_id()\n            question_id_4 = question_services.get_new_question_id()\n            question_id_5 = question_services.get_new_question_id()\n\n            skill_1 = self._create_dummy_skill(\n                skill_id_1, 'Dummy Skill 1', '<p>Dummy Explanation 1</p>')\n            skill_2 = self._create_dummy_skill(\n                skill_id_2, 'Dummy Skill 2', '<p>Dummy Explanation 2</p>')\n            skill_3 = self._create_dummy_skill(\n                skill_id_3, 'Dummy Skill 3', '<p>Dummy Explanation 3</p>')\n\n            question_1 = self._create_dummy_question(\n                question_id_1, 'Question 1', [skill_id_1])\n            question_2 = self._create_dummy_question(\n                question_id_2, 'Question 2', [skill_id_2])\n            question_3 = self._create_dummy_question(\n                question_id_3, 'Question 3', [skill_id_3])\n            question_4 = self._create_dummy_question(\n                question_id_4, 'Question 4', [skill_id_1])\n            question_5 = self._create_dummy_question(\n                question_id_5, 'Question 5', [skill_id_1])\n\n            question_services.add_question(self.user_id, question_1)\n            question_services.add_question(self.user_id, question_4)\n            question_services.add_question(self.user_id, question_5)\n            question_services.add_question(self.user_id, question_2)\n            question_services.add_question(self.user_id, question_3)\n\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_1, skill_id_1, 0.3)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_4, skill_id_1, 0.3)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_5, skill_id_1, 0.3)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_2, skill_id_2, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_3, skill_id_3, 0.7)\n\n            topic_1 = topic_domain.Topic.create_default_topic(\n                topic_id_1, 'Dummy Topic 1', 'dummy-topic-one', 'description',\n                'fragm')\n            topic_1.skill_ids_for_diagnostic_test = [skill_id_1]\n            topic_1.thumbnail_filename = 'thumbnail.svg'\n            topic_1.thumbnail_bg_color = '#C6DCDA'\n            topic_1.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_1], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_1.next_subtopic_id = 2\n            topic_1.add_canonical_story(story_id)\n\n            topic_2 = topic_domain.Topic.create_default_topic(\n                topic_id_2, 'Empty Topic', 'empty-topic', 'description',\n                'fragm')\n\n            # These explorations were chosen since they pass the validations\n            # for published stories.\n            self._reload_exploration('6')\n            self._reload_exploration('25')\n            self._reload_exploration('13')\n            exp_services.update_exploration(\n                self.user_id, '6', [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY,\n                    'property_name': 'correctness_feedback_enabled',\n                    'new_value': True\n                })], 'Changed correctness_feedback_enabled.')\n            exp_services.update_exploration(\n                self.user_id, '25', [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY,\n                    'property_name': 'correctness_feedback_enabled',\n                    'new_value': True\n                })], 'Changed correctness_feedback_enabled.')\n            exp_services.update_exploration(\n                self.user_id, '13', [exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY,\n                    'property_name': 'correctness_feedback_enabled',\n                    'new_value': True\n                })], 'Changed correctness_feedback_enabled.')\n\n            story = story_domain.Story.create_default_story(\n                story_id, 'Help Jaime win the Arcade', 'Description',\n                topic_id_1, 'help-jamie-win-arcade')\n\n            story_node_dicts = [{\n                'exp_id': '6',\n                'title': 'What are the place values?',\n                'description': 'Jaime learns the place value of each digit ' +\n                               'in a big number.'\n            }, {\n                'exp_id': '25',\n                'title': 'Finding the value of a number',\n                'description': 'Jaime understands the value of his ' +\n                               'arcade score.'\n            }, {\n                'exp_id': '13',\n                'title': 'Comparing Numbers',\n                'description': 'Jaime learns if a number is smaller or ' +\n                               'greater than another number.'\n            }]\n\n            def generate_dummy_story_nodes(\n                node_id: int, exp_id: str, title: str, description: str\n            ) -> None:\n                \"\"\"Generates and connects sequential story nodes.\n\n                Args:\n                    node_id: int. The node id.\n                    exp_id: str. The exploration id.\n                    title: str. The title of the story node.\n                    description: str. The description of the story node.\n                \"\"\"\n                assert self.user_id is not None\n                story.add_node(\n                    '%s%d' % (story_domain.NODE_ID_PREFIX, node_id),\n                    title)\n                story.update_node_description(\n                    '%s%d' % (story_domain.NODE_ID_PREFIX, node_id),\n                    description)\n                story.update_node_exploration_id(\n                    '%s%d' % (story_domain.NODE_ID_PREFIX, node_id), exp_id)\n\n                if node_id != len(story_node_dicts):\n                    story.update_node_destination_node_ids(\n                        '%s%d' % (story_domain.NODE_ID_PREFIX, node_id),\n                        ['%s%d' % (story_domain.NODE_ID_PREFIX, node_id + 1)])\n\n                exp_services.update_exploration(\n                    self.user_id, exp_id, [exp_domain.ExplorationChange({\n                        'cmd': exp_domain.CMD_EDIT_EXPLORATION_PROPERTY,\n                        'property_name': 'category',\n                        'new_value': 'Astronomy'\n                    })], 'Change category')\n\n            for i, story_node_dict in enumerate(story_node_dicts):\n                generate_dummy_story_nodes(i + 1, **story_node_dict)\n\n            skill_services.save_new_skill(self.user_id, skill_1)\n            skill_services.save_new_skill(self.user_id, skill_2)\n            skill_services.save_new_skill(self.user_id, skill_3)\n            story_services.save_new_story(self.user_id, story)\n            topic_services.save_new_topic(self.user_id, topic_1)\n            topic_services.publish_topic(topic_id_1, self.user_id)\n            topic_services.save_new_topic(self.user_id, topic_2)\n\n            # Generates translation opportunities for the Contributor Dashboard.\n            exp_ids_in_story = story.story_contents.get_all_linked_exp_ids()\n            opportunity_services.add_new_exploration_opportunities(\n                story_id, exp_ids_in_story)\n\n            topic_services.publish_story(topic_id_1, story_id, self.user_id)\n        else:\n            raise Exception('Cannot load new structures data in production.')\n\n    def _generate_dummy_skill_and_questions(self) -> None:\n        \"\"\"Generate and loads the database with a skill and 15 questions\n        linked to the skill.\n\n        Raises:\n            Exception. Cannot load new structures data in production mode.\n            Exception. User does not have enough rights to generate data.\n        \"\"\"\n        assert self.user_id is not None\n        if constants.DEV_MODE:\n            if feconf.ROLE_ID_CURRICULUM_ADMIN not in self.user.roles:\n                raise Exception(\n                    'User does not have enough rights to generate data.')\n            skill_id = skill_services.get_new_skill_id()\n            skill_name = 'Dummy Skill %s' % str(random.getrandbits(32))\n            skill = self._create_dummy_skill(\n                skill_id, skill_name, '<p>Dummy Explanation 1</p>')\n            skill_services.save_new_skill(self.user_id, skill)\n            for i in range(15):\n                question_id = question_services.get_new_question_id()\n                question_name = 'Question number %s %s' % (str(i), skill_name)\n                question = self._create_dummy_question(\n                    question_id, question_name, [skill_id])\n                question_services.add_question(self.user_id, question)\n                question_difficulty = list(\n                    constants.SKILL_DIFFICULTY_LABEL_TO_FLOAT.values())\n                random_difficulty = random.choice(question_difficulty)\n                question_services.create_new_question_skill_link(\n                    self.user_id, question_id, skill_id, random_difficulty)\n        else:\n            raise Exception('Cannot generate dummy skills in production.')\n\n    def _reload_collection(self, collection_id: str) -> None:\n        \"\"\"Reloads the collection in dev_mode corresponding to the given\n        collection id.\n\n        Args:\n            collection_id: str. The collection id.\n\n        Raises:\n            Exception. Cannot reload a collection in production.\n        \"\"\"\n        assert self.user_id is not None\n        if constants.DEV_MODE:\n            logging.info(\n                '[ADMIN] %s reloaded collection %s' %\n                (self.user_id, collection_id))\n            collection_services.load_demo(collection_id)\n            rights_manager.release_ownership_of_collection(\n                user_services.get_system_user(), collection_id)\n        else:\n            raise Exception('Cannot reload a collection in production.')\n\n    def _generate_dummy_explorations(\n        self, num_dummy_exps_to_generate: int, num_dummy_exps_to_publish: int\n    ) -> None:\n        \"\"\"Generates and publishes the given number of dummy explorations.\n\n        Args:\n            num_dummy_exps_to_generate: int. Count of dummy explorations to\n                be generated.\n            num_dummy_exps_to_publish: int. Count of explorations to\n                be published.\n\n        Raises:\n            Exception. Environment is not DEVMODE.\n        \"\"\"\n        assert self.user_id is not None\n        if constants.DEV_MODE:\n            logging.info(\n                '[ADMIN] %s generated %s number of dummy explorations' %\n                (self.user_id, num_dummy_exps_to_generate))\n            possible_titles = ['Hulk Neuroscience', 'Quantum Starks',\n                               'Wonder Anatomy',\n                               'Elvish, language of \"Lord of the Rings',\n                               'The Science of Superheroes']\n            exploration_ids_to_publish = []\n            for i in range(num_dummy_exps_to_generate):\n                title = random.choice(possible_titles)\n                category = random.choice(constants.SEARCH_DROPDOWN_CATEGORIES)\n                new_exploration_id = exp_fetchers.get_new_exploration_id()\n                exploration = exp_domain.Exploration.create_default_exploration(\n                    new_exploration_id, title=title, category=category,\n                    objective='Dummy Objective')\n                exp_services.save_new_exploration(self.user_id, exploration)\n                if i <= num_dummy_exps_to_publish - 1:\n                    exploration_ids_to_publish.append(new_exploration_id)\n                    rights_manager.publish_exploration(\n                        self.user, new_exploration_id)\n            exp_services.index_explorations_given_ids(\n                exploration_ids_to_publish)\n        else:\n            raise Exception('Cannot generate dummy explorations in production.')\n\n    def _generate_dummy_classroom(self) -> None:\n        \"\"\"Generate and loads the database with a classroom.\n\n        Raises:\n            Exception. Cannot generate dummy classroom in production.\n            Exception. User does not have enough rights to generate data.\n        \"\"\"\n        assert self.user_id is not None\n        if constants.DEV_MODE:\n            if feconf.ROLE_ID_CURRICULUM_ADMIN not in self.user.roles:\n                raise Exception(\n                    'User does not have enough rights to generate data.')\n            logging.info(\n                '[ADMIN] %s generated dummy classroom.' % self.user_id)\n\n            topic_id_1 = topic_fetchers.get_new_topic_id()\n            topic_id_2 = topic_fetchers.get_new_topic_id()\n            topic_id_3 = topic_fetchers.get_new_topic_id()\n            topic_id_4 = topic_fetchers.get_new_topic_id()\n            topic_id_5 = topic_fetchers.get_new_topic_id()\n\n            skill_id_1 = skill_services.get_new_skill_id()\n            skill_id_2 = skill_services.get_new_skill_id()\n            skill_id_3 = skill_services.get_new_skill_id()\n            skill_id_4 = skill_services.get_new_skill_id()\n            skill_id_5 = skill_services.get_new_skill_id()\n\n            question_id_1 = question_services.get_new_question_id()\n            question_id_2 = question_services.get_new_question_id()\n            question_id_3 = question_services.get_new_question_id()\n            question_id_4 = question_services.get_new_question_id()\n            question_id_5 = question_services.get_new_question_id()\n            question_id_6 = question_services.get_new_question_id()\n            question_id_7 = question_services.get_new_question_id()\n            question_id_8 = question_services.get_new_question_id()\n            question_id_9 = question_services.get_new_question_id()\n            question_id_10 = question_services.get_new_question_id()\n            question_id_11 = question_services.get_new_question_id()\n            question_id_12 = question_services.get_new_question_id()\n            question_id_13 = question_services.get_new_question_id()\n            question_id_14 = question_services.get_new_question_id()\n            question_id_15 = question_services.get_new_question_id()\n\n            question_1 = self._create_dummy_question(\n                question_id_1, 'Question 1', [skill_id_1])\n            question_2 = self._create_dummy_question(\n                question_id_2, 'Question 2', [skill_id_1])\n            question_3 = self._create_dummy_question(\n                question_id_3, 'Question 3', [skill_id_1])\n            question_4 = self._create_dummy_question(\n                question_id_4, 'Question 4', [skill_id_2])\n            question_5 = self._create_dummy_question(\n                question_id_5, 'Question 5', [skill_id_2])\n            question_6 = self._create_dummy_question(\n                question_id_6, 'Question 6', [skill_id_2])\n            question_7 = self._create_dummy_question(\n                question_id_7, 'Question 7', [skill_id_3])\n            question_8 = self._create_dummy_question(\n                question_id_8, 'Question 8', [skill_id_3])\n            question_9 = self._create_dummy_question(\n                question_id_9, 'Question 9', [skill_id_3])\n            question_10 = self._create_dummy_question(\n                question_id_10, 'Question 10', [skill_id_4])\n            question_11 = self._create_dummy_question(\n                question_id_11, 'Question 11', [skill_id_4])\n            question_12 = self._create_dummy_question(\n                question_id_12, 'Question 12', [skill_id_4])\n            question_13 = self._create_dummy_question(\n                question_id_13, 'Question 13', [skill_id_5])\n            question_14 = self._create_dummy_question(\n                question_id_14, 'Question 14', [skill_id_5])\n            question_15 = self._create_dummy_question(\n                question_id_15, 'Question 15', [skill_id_5])\n\n            topic_1 = topic_domain.Topic.create_default_topic(\n                topic_id_1, 'Addition', 'add', 'description', 'fragm')\n            topic_1.skill_ids_for_diagnostic_test = [skill_id_1]\n            topic_1.thumbnail_filename = 'thumbnail.svg'\n            topic_1.thumbnail_bg_color = '#C6DCDA'\n            topic_1.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_1], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_1.next_subtopic_id = 2\n\n            topic_2 = topic_domain.Topic.create_default_topic(\n                topic_id_2, 'Subtraction', 'subtraction',\n                'description', 'fragm'\n            )\n            topic_2.skill_ids_for_diagnostic_test = [skill_id_2]\n            topic_2.thumbnail_filename = 'thumbnail.svg'\n            topic_2.thumbnail_bg_color = '#C6DCDA'\n            topic_2.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_2], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_2.next_subtopic_id = 2\n\n            topic_3 = topic_domain.Topic.create_default_topic(\n                topic_id_3, 'Multiplication', 'multiplication',\n                'description', 'fragm'\n            )\n            topic_3.skill_ids_for_diagnostic_test = [skill_id_3]\n            topic_3.thumbnail_filename = 'thumbnail.svg'\n            topic_3.thumbnail_bg_color = '#C6DCDA'\n            topic_3.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_3], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_3.next_subtopic_id = 2\n\n            topic_4 = topic_domain.Topic.create_default_topic(\n                topic_id_4, 'Division', 'division', 'description', 'fragm')\n            topic_4.skill_ids_for_diagnostic_test = [skill_id_4]\n            topic_4.thumbnail_filename = 'thumbnail.svg'\n            topic_4.thumbnail_bg_color = '#C6DCDA'\n            topic_4.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_4], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_4.next_subtopic_id = 2\n\n            topic_5 = topic_domain.Topic.create_default_topic(\n                topic_id_5, 'Fraction', 'fraction', 'description', 'fragm')\n            topic_5.skill_ids_for_diagnostic_test = [skill_id_5]\n            topic_5.thumbnail_filename = 'thumbnail.svg'\n            topic_5.thumbnail_bg_color = '#C6DCDA'\n            topic_5.subtopics = [\n                topic_domain.Subtopic(\n                    1, 'Title', [skill_id_5], 'image.svg',\n                    constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                    'dummy-subtopic-three')]\n            topic_5.next_subtopic_id = 2\n\n            skill_1 = self._create_dummy_skill(\n                skill_id_1, 'Skill1', '<p>Dummy Explanation 1</p>')\n            skill_2 = self._create_dummy_skill(\n                skill_id_2, 'Skill2', '<p>Dummy Explanation 2</p>')\n            skill_3 = self._create_dummy_skill(\n                skill_id_3, 'Skill3', '<p>Dummy Explanation 3</p>')\n            skill_4 = self._create_dummy_skill(\n                skill_id_4, 'Skill4', '<p>Dummy Explanation 4</p>')\n            skill_5 = self._create_dummy_skill(\n                skill_id_5, 'Skill5', '<p>Dummy Explanation 5</p>')\n\n            question_services.add_question(self.user_id, question_1)\n            question_services.add_question(self.user_id, question_2)\n            question_services.add_question(self.user_id, question_3)\n            question_services.add_question(self.user_id, question_4)\n            question_services.add_question(self.user_id, question_5)\n            question_services.add_question(self.user_id, question_6)\n            question_services.add_question(self.user_id, question_7)\n            question_services.add_question(self.user_id, question_8)\n            question_services.add_question(self.user_id, question_9)\n            question_services.add_question(self.user_id, question_10)\n            question_services.add_question(self.user_id, question_11)\n            question_services.add_question(self.user_id, question_12)\n            question_services.add_question(self.user_id, question_13)\n            question_services.add_question(self.user_id, question_14)\n            question_services.add_question(self.user_id, question_15)\n\n            skill_services.save_new_skill(self.user_id, skill_1)\n            skill_services.save_new_skill(self.user_id, skill_2)\n            skill_services.save_new_skill(self.user_id, skill_3)\n            skill_services.save_new_skill(self.user_id, skill_4)\n            skill_services.save_new_skill(self.user_id, skill_5)\n\n            topic_services.save_new_topic(self.user_id, topic_1)\n            topic_services.publish_topic(topic_id_1, self.user_id)\n\n            topic_services.save_new_topic(self.user_id, topic_2)\n            topic_services.publish_topic(topic_id_2, self.user_id)\n\n            topic_services.save_new_topic(self.user_id, topic_3)\n            topic_services.publish_topic(topic_id_3, self.user_id)\n\n            topic_services.save_new_topic(self.user_id, topic_4)\n            topic_services.publish_topic(topic_id_4, self.user_id)\n\n            topic_services.save_new_topic(self.user_id, topic_5)\n            topic_services.publish_topic(topic_id_5, self.user_id)\n\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_1, skill_id_1, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_2, skill_id_1, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_3, skill_id_1, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_4, skill_id_2, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_5, skill_id_2, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_6, skill_id_2, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_7, skill_id_3, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_8, skill_id_3, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_9, skill_id_3, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_10, skill_id_4, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_11, skill_id_4, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_12, skill_id_4, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_13, skill_id_5, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_14, skill_id_5, 0.5)\n            question_services.create_new_question_skill_link(\n                self.user_id, question_id_15, skill_id_5, 0.5)\n\n            classroom_id_1 = classroom_config_services.get_new_classroom_id()\n\n            classroom_name_1 = 'Math'\n\n            classroom_url_fragment_1 = 'math'\n\n            topic_dependency_for_classroom_1: Dict[str, list[str]] = {\n                topic_id_1: [],\n                topic_id_2: [topic_id_1],\n                topic_id_3: [topic_id_1],\n                topic_id_4: [topic_id_2],\n                topic_id_5: [topic_id_2, topic_id_3]\n            }\n\n            classroom_dict_1: classroom_config_domain.ClassroomDict = {\n                'classroom_id': classroom_id_1,\n                'name': classroom_name_1,\n                'url_fragment': classroom_url_fragment_1,\n                'course_details': '',\n                'topic_list_intro': '',\n                'topic_id_to_prerequisite_topic_ids': (\n                    topic_dependency_for_classroom_1)\n            }\n\n            classroom_1 = classroom_config_domain.Classroom.from_dict(\n                classroom_dict_1)\n\n            classroom_config_services.update_or_create_classroom_model(\n                classroom_1)\n\n            classroom_pages_data = [{\n                'name': 'math',\n                'url_fragment': 'math',\n                'course_details': '',\n                'topic_list_intro': '',\n                'topic_ids': [\n                    topic_id_1,\n                    topic_id_2,\n                    topic_id_3,\n                    topic_id_4,\n                    topic_id_5\n                ],\n            }]\n            config_services.set_property(\n                self.user_id, 'classroom_pages_data', classroom_pages_data)\n        else:\n            raise Exception('Cannot generate dummy classroom in production.')\n\n\nclass AdminRoleHandlerNormalizedGetRequestDict(TypedDict):\n    \"\"\"Dict representation of AdminRoleHandler's GET normalized_request\n    dictionary.\n    \"\"\"\n\n    filter_criterion: str\n    role: Optional[str]\n    username: Optional[str]\n\n\nclass AdminRoleHandlerNormalizedDeleteRequestDict(TypedDict):\n    \"\"\"Dict representation of AdminRoleHandler's DELETE normalized_request\n    dictionary.\n    \"\"\"\n\n    role: str\n    username: str\n\n\nclass AdminRoleHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of AdminRoleHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    role: str\n    username: str\n\n\nclass AdminRoleHandler(\n    base.BaseHandler[\n        AdminRoleHandlerNormalizedPayloadDict,\n        Union[\n            AdminRoleHandlerNormalizedGetRequestDict,\n            AdminRoleHandlerNormalizedDeleteRequestDict\n        ]\n    ]\n):\n    \"\"\"Handler for roles tab of admin page. Used to view and update roles.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'filter_criterion': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': [\n                        feconf.USER_FILTER_CRITERION_ROLE,\n                        feconf.USER_FILTER_CRITERION_USERNAME\n                    ]\n                }\n            },\n            'role': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': role_services.VIEWABLE_ROLES\n                },\n                'default_value': None\n            },\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            }\n        },\n        'PUT': {\n            'role': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': feconf.ALLOWED_USER_ROLES\n                }\n            },\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        },\n        'DELETE': {\n            'role': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': feconf.ALLOWED_USER_ROLES\n                }\n            },\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Retrieves information about users based on different filter\n        criteria to populate the roles tab.\n\n        Raises:\n            Exception. The role must be provided when the filter criterion\n                is 'role'.\n            Exception. The username must be provided when the filter\n                criterion is 'username'.\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        assert self.user_id is not None\n        # Here we use cast because we are narrowing down the type of\n        # 'normalized_request' from Union of request TypedDicts to a\n        # particular TypedDict that was defined according to the schemas.\n        # So that the type of fetched values is not considered as Any type.\n        request_data = cast(\n            AdminRoleHandlerNormalizedGetRequestDict,\n            self.normalized_request\n        )\n        filter_criterion = request_data['filter_criterion']\n        if filter_criterion == feconf.USER_FILTER_CRITERION_ROLE:\n            role = request_data.get(feconf.USER_FILTER_CRITERION_ROLE)\n            if role is None:\n                raise Exception(\n                    'The role must be provided when the filter criterion '\n                    'is \\'role\\'.'\n                )\n            role_services.log_role_query(\n                self.user_id, feconf.ROLE_ACTION_VIEW_BY_ROLE,\n                role=role)\n            self.render_json({\n                'usernames': (\n                    user_services.get_usernames_by_role(role) if role else []\n                )\n            })\n        else:\n            # The handler schema defines the possible values of\n            # 'filter_criterion'. If 'filter_criterion' has a value other than\n            # those defined in the schema, a Bad Request error will be thrown.\n            # Hence, 'filter_criterion' must be\n            # 'feconf.USER_FILTER_CRITERION_USERNAME' if this branch is\n            # executed.\n            assert filter_criterion == (\n                feconf.USER_FILTER_CRITERION_USERNAME)\n            username = request_data.get(feconf.USER_FILTER_CRITERION_USERNAME)\n            if username is None:\n                raise Exception(\n                    'The username must be provided when the filter criterion '\n                    'is \\'username\\'.'\n                )\n            user_id = (\n                user_services.get_user_id_from_username(username)\n            )\n            role_services.log_role_query(\n                self.user_id, feconf.ROLE_ACTION_VIEW_BY_USERNAME,\n                username=username)\n            if user_id is None:\n                raise self.InvalidInputException(\n                    'User with given username does not exist.')\n\n            user_settings = user_services.get_user_settings(user_id)\n            user_roles = user_settings.roles\n            managed_topic_ids = []\n            coordinated_language_ids = []\n            if feconf.ROLE_ID_TOPIC_MANAGER in user_roles:\n                managed_topic_ids = [\n                    rights.id for rights in\n                    topic_fetchers.get_topic_rights_with_user(user_id)]\n            if feconf.ROLE_ID_TRANSLATION_COORDINATOR in user_roles:\n                coordinated_language_ids = [\n                    rights.language_id for rights in\n                    user_services.get_translation_rights_with_user(\n                        user_id)]\n            user_roles_dict = {\n                'roles': user_roles,\n                'managed_topic_ids': managed_topic_ids,\n                'coordinated_language_ids': coordinated_language_ids,\n                'banned': user_settings.banned\n            }\n            self.render_json(user_roles_dict)\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Adds a role to a user.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n            InvalidInputException. Unsupported role for this handler.\n        \"\"\"\n        assert self.normalized_payload is not None\n        username = self.normalized_payload['username']\n        role = self.normalized_payload['role']\n        user_settings = user_services.get_user_settings_from_username(username)\n\n        if user_settings is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n\n        if role == feconf.ROLE_ID_TOPIC_MANAGER:\n            # The Topic manager role assignment is handled via\n            # TopicManagerRoleHandler.\n            raise self.InvalidInputException(\n                'Unsupported role for this handler.')\n\n        user_services.add_user_role(user_settings.user_id, role)\n\n        self.render_json({})\n\n    @acl_decorators.can_access_admin_page\n    def delete(self) -> None:\n        \"\"\"Removes a role from a user.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        # Here we use cast because we are narrowing down the type of\n        # 'normalized_request' from Union of request TypedDicts to a\n        # particular TypedDict that was defined according to the schemas.\n        # So that the type of fetched values is not considered as Any type.\n        request_data = cast(\n            AdminRoleHandlerNormalizedDeleteRequestDict,\n            self.normalized_request\n        )\n        username = request_data['username']\n        role = request_data['role']\n\n        user_id = user_services.get_user_id_from_username(username)\n        if user_id is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n\n        if role == feconf.ROLE_ID_TOPIC_MANAGER:\n            topic_services.deassign_user_from_all_topics(self.user, user_id)\n\n        if role == feconf.ROLE_ID_TRANSLATION_COORDINATOR:\n            user_services.deassign_user_from_all_languages(\n                self.user, user_id)\n\n        user_services.remove_user_role(user_id, role)\n\n        self.render_json({})\n\n\nclass TopicManagerRoleHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of TopicManagerRoleHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    username: str\n    action: str\n    topic_id: str\n\n\nclass TopicManagerRoleHandler(\n    base.BaseHandler[\n        TopicManagerRoleHandlerNormalizedPayloadDict, Dict[str, str]\n    ]\n):\n    \"\"\"Handler to assign or deassigning manager to a topic.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'action': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': ['assign', 'deassign']\n                }\n            },\n            'topic_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Adds or removes the topic-manager role for a user in the context\n        of a specific topic.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        assert self.normalized_payload is not None\n        username = self.normalized_payload['username']\n        action = self.normalized_payload['action']\n        topic_id = self.normalized_payload['topic_id']\n\n        user_settings = user_services.get_user_settings_from_username(username)\n\n        if user_settings is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n\n        user_id = user_settings.user_id\n        if action == 'assign':\n            if not feconf.ROLE_ID_TOPIC_MANAGER in user_settings.roles:\n                user_services.add_user_role(\n                    user_id, feconf.ROLE_ID_TOPIC_MANAGER)\n\n            topic_manager = user_services.get_user_actions_info(user_id)\n            topic_services.assign_role(\n                user_services.get_system_user(),\n                topic_manager, topic_domain.ROLE_MANAGER, topic_id)\n        else:\n            # The handler schema defines the possible values of 'action'.\n            # If 'action' has a value other than those defined in the schema,\n            # a Bad Request error will be thrown. Hence, 'action' must be\n            # 'deassign' if this branch is executed.\n            assert action == 'deassign'\n            topic_services.deassign_manager_role_from_topic(\n                user_services.get_system_user(), user_id, topic_id)\n\n            # The case where user does not have manager rights it will be\n            # caught before in topic_services.deassign_manager_role_from_topic\n            # method.\n            assert not topic_fetchers.get_topic_rights_with_user(user_id)\n            user_services.remove_user_role(\n                user_id, feconf.ROLE_ID_TOPIC_MANAGER)\n\n        self.render_json({})\n\n\nclass BannedUsersHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of BannedUsersHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    username: str\n\n\nclass BannedUsersHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of BannedUsersHandler's normalized_request\n    dictionary.\n    \"\"\"\n\n    username: str\n\n\nclass BannedUsersHandler(\n    base.BaseHandler[\n        BannedUsersHandlerNormalizedPayloadDict,\n        BannedUsersHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Handler to ban and unban users.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        },\n        'DELETE': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Marks a user as banned.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        assert self.normalized_payload is not None\n        username = self.normalized_payload['username']\n        user_id = user_services.get_user_id_from_username(username)\n\n        if user_id is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n        topic_services.deassign_user_from_all_topics(self.user, user_id)\n        user_services.mark_user_banned(user_id)\n\n        self.render_json({})\n\n    @acl_decorators.can_access_admin_page\n    def delete(self) -> None:\n        \"\"\"Removes the banned status of the user.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        assert self.normalized_request is not None\n        username = self.normalized_request['username']\n        user_id = user_services.get_user_id_from_username(username)\n\n        if user_id is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n        user_services.unmark_user_banned(user_id)\n\n        self.render_json({})\n\n\nclass AdminSuperAdminPrivilegesHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of AdminSuperAdminPrivilegesHandler's\n    normalized_payload dictionary.\n    \"\"\"\n\n    username: str\n\n\nclass AdminSuperAdminPrivilegesHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of AdminSuperAdminPrivilegesHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    username: str\n\n\nclass AdminSuperAdminPrivilegesHandler(\n    base.BaseHandler[\n        AdminSuperAdminPrivilegesHandlerNormalizedPayloadDict,\n        AdminSuperAdminPrivilegesHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Handler for granting a user super admin privileges.\"\"\"\n\n    PUT_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    DELETE_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        },\n        'DELETE': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Grants super admin privileges to a user.\n\n        Raises:\n            UnauthorizedUserException. Only the default system admin can\n                manage super admins.\n            InvalidInputException. No such user exists.\n        \"\"\"\n        assert self.normalized_payload is not None\n        if self.email != feconf.ADMIN_EMAIL_ADDRESS:\n            raise self.UnauthorizedUserException(\n                'Only the default system admin can manage super admins')\n        username = self.normalized_payload['username']\n\n        user_id = user_services.get_user_id_from_username(username)\n        if user_id is None:\n            raise self.InvalidInputException('No such user exists')\n\n        auth_services.grant_super_admin_privileges(user_id)\n        self.render_json(self.values)\n\n    @acl_decorators.can_access_admin_page\n    def delete(self) -> None:\n        \"\"\"Revokes super admin privileges from a user.\n\n        Raises:\n            UnauthorizedUserException. Only the default system admin can\n                manage super admins.\n            InvalidInputException. No such user exists.\n            InvalidInputException. Cannot revoke privileges from the default\n                super admin account.\n        \"\"\"\n        assert self.normalized_request is not None\n        if self.email != feconf.ADMIN_EMAIL_ADDRESS:\n            raise self.UnauthorizedUserException(\n                'Only the default system admin can manage super admins')\n        username = self.normalized_request['username']\n\n        user_settings = user_services.get_user_settings_from_username(username)\n        if user_settings is None:\n            raise self.InvalidInputException('No such user exists')\n\n        if user_settings.email == feconf.ADMIN_EMAIL_ADDRESS:\n            raise self.InvalidInputException(\n                'Cannot revoke privileges from the default super admin account')\n\n        auth_services.revoke_super_admin_privileges(user_settings.user_id)\n        self.render_json(self.values)\n\n\nclass AdminTopicsCsvFileDownloader(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Retrieves topic similarity data for download.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_DOWNLOADABLE\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.can_access_admin_page\n    def get(self) -> None:\n        \"\"\"Generates a CSV file containing topic similarities.\"\"\"\n        topic_similarities = (\n            recommendations_services.get_topic_similarities_as_csv()\n        )\n        # Downloadable file accepts only bytes, so we need to encode\n        # topic_similarities to bytes.\n        self.render_downloadable_file(\n            io.BytesIO(topic_similarities.encode('utf-8')),\n            'topic_similarities.csv',\n            'text/csv'\n        )\n\n\nclass DataExtractionQueryHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of DataExtractionQueryHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    exp_id: str\n    exp_version: int\n    state_name: str\n    num_answers: int\n\n\nclass DataExtractionQueryHandler(\n    base.BaseHandler[\n        Dict[str, str], DataExtractionQueryHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Handler for data extraction query.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'exp_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'exp_version': {\n                'schema': {\n                    'type': 'int'\n                }\n            },\n            'state_name': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'num_answers': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def get(self) -> None:\n        \"\"\"Retrieves a specified number of submitted answers for a particular\n        state within an exploration.\n\n        Raises:\n            InvalidInputException. Entity not found.\n            InvalidInputException. Exploration does not have such state.\n            Exception. No state answer exists.\n        \"\"\"\n        assert self.normalized_request is not None\n        exp_id = self.normalized_request['exp_id']\n        exp_version = self.normalized_request['exp_version']\n\n        exploration = exp_fetchers.get_exploration_by_id(\n            exp_id, strict=False, version=exp_version)\n        if exploration is None:\n            raise self.InvalidInputException(\n                'Entity for exploration with id %s and version %s not found.'\n                % (exp_id, exp_version))\n\n        state_name = self.normalized_request['state_name']\n        num_answers = self.normalized_request['num_answers']\n\n        if state_name not in exploration.states:\n            raise self.InvalidInputException(\n                'Exploration \\'%s\\' does not have \\'%s\\' state.'\n                % (exp_id, state_name))\n\n        state_answers = stats_services.get_state_answers(\n            exp_id, exp_version, state_name)\n        if state_answers is None:\n            raise Exception(\n                'No state answer exists for the given exp_id: %s,'\n                ' exp_version: %s and state_name: %s' %\n                (exp_id, exp_version, state_name)\n\n            )\n        extracted_answers = state_answers.get_submitted_answer_dict_list()\n\n        if num_answers > 0:\n            extracted_answers = extracted_answers[:num_answers]\n\n        response = {\n            'data': extracted_answers\n        }\n        self.render_json(response)\n\n\nclass SendDummyMailToAdminHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"This function handles sending test emails.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'POST': {}}\n\n    @acl_decorators.can_access_admin_page\n    def post(self) -> None:\n        \"\"\"Sends a dummy email to the admin if the application is\n        configured to send emails.\n\n        Raises:\n            InvalidInputException. This app cannot send emails.\n        \"\"\"\n        username = self.username\n        assert username is not None\n        if feconf.CAN_SEND_EMAILS:\n            email_manager.send_dummy_mail_to_admin(username)\n            self.render_json({})\n        else:\n            raise self.InvalidInputException('This app cannot send emails.')\n\n\nclass UpdateUsernameHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of UpdateUsernameHandler's\n    normalized_payload dictionary.\n    \"\"\"\n\n    old_username: str\n    new_username: str\n\n\nclass UpdateUsernameHandler(\n    base.BaseHandler[\n        UpdateUsernameHandlerNormalizedPayloadDict, Dict[str, str]\n    ]\n):\n    \"\"\"Handler for renaming usernames.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'old_username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'new_username': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'has_length_at_most',\n                        'max_value': constants.MAX_USERNAME_LENGTH\n                    }]\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Updates the username for a user.\n\n        Raises:\n            InvalidInputException. Invalid username.\n            InvalidInputException. The user does not have a profile picture\n                with png extension.\n            InvalidInputException. The user does not have a profile picture\n                with webp extension.\n        \"\"\"\n        assert self.user_id is not None\n        assert self.normalized_payload is not None\n        old_username = self.normalized_payload['old_username']\n        new_username = self.normalized_payload['new_username']\n\n        user_id = user_services.get_user_id_from_username(old_username)\n        if user_id is None:\n            raise self.InvalidInputException(\n                'Invalid username: %s' % old_username)\n\n        if user_services.is_username_taken(new_username):\n            raise self.InvalidInputException('Username already taken.')\n\n        # Update profile picture.\n        old_fs = fs_services.GcsFileSystem(\n            feconf.ENTITY_TYPE_USER, old_username)\n        new_fs = fs_services.GcsFileSystem(\n            feconf.ENTITY_TYPE_USER, new_username)\n\n        if not old_fs.isfile('profile_picture.png'):\n            raise self.InvalidInputException(\n                'The user with username %s does not have a '\n                'profile picture with png extension.' % old_username\n            )\n\n        if not old_fs.isfile('profile_picture.webp'):\n            raise self.InvalidInputException(\n                'The user with username %s does not have a '\n                'profile picture with webp extension.' % old_username\n            )\n\n        image_png = old_fs.get('profile_picture.png')\n        old_fs.delete('profile_picture.png')\n        new_fs.commit(\n            'profile_picture.png', image_png, mimetype='image/png')\n\n        image_webp = old_fs.get('profile_picture.webp')\n        old_fs.delete('profile_picture.webp')\n        new_fs.commit(\n            'profile_picture.webp', image_webp, mimetype='image/webp')\n\n        user_services.set_username(user_id, new_username)\n        user_services.log_username_change(\n            self.user_id, old_username, new_username)\n\n        self.render_json({})\n\n\nclass NumberOfDeletionRequestsHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Handler for getting the number of pending deletion requests via admin\n    page.\n    \"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.can_access_admin_page\n    def get(self) -> None:\n        \"\"\"Retrieves the number of pending deletion requests for models.\"\"\"\n        self.render_json({\n            'number_of_pending_deletion_models': (\n                wipeout_service.get_number_of_pending_deletion_requests())\n        })\n\n\nclass VerifyUserModelsDeletedHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of VerifyUserModelsDeletedHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    user_id: str\n\n\nclass VerifyUserModelsDeletedHandler(\n    base.BaseHandler[\n        Dict[str, str], VerifyUserModelsDeletedHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Handler for getting whether any models exist for specific user ID.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'user_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def get(self) -> None:\n        \"\"\"Checks if a user with a specific user_id has been deleted and\n        if there are related models or not.\n        \"\"\"\n        assert self.normalized_request is not None\n        user_id = self.normalized_request['user_id']\n\n        user_is_deleted = wipeout_service.verify_user_deleted(\n            user_id, include_delete_at_end_models=True)\n        self.render_json({'related_models_exist': not user_is_deleted})\n\n\nclass DeleteUserHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of DeleteUserHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    user_id: str\n    username: str\n\n\nclass DeleteUserHandler(\n    base.BaseHandler[\n        Dict[str, str], DeleteUserHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Handler for deleting a user with specific ID.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'DELETE': {\n            'user_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_delete_any_user\n    def delete(self) -> None:\n        \"\"\"Initiates the pre-deletion process for a user.\n\n        Raises:\n            InvalidInputException. The username doesn't belong to any user.\n            InvalidInputException. The user ID retrieved from the username\n                and the user ID provided by admin differ.\n        \"\"\"\n        assert self.normalized_request is not None\n        user_id = self.normalized_request['user_id']\n        username = self.normalized_request['username']\n\n        user_id_from_username = (\n            user_services.get_user_id_from_username(username))\n        if user_id_from_username is None:\n            raise self.InvalidInputException(\n                'The username doesn\\'t belong to any user'\n            )\n        if user_id_from_username != user_id:\n            raise self.InvalidInputException(\n                'The user ID retrieved from the username and '\n                'the user ID provided by admin differ.'\n            )\n        wipeout_service.pre_delete_user(user_id)\n        self.render_json({'success': True})\n\n\nclass UpdateBlogPostHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of UpdateBlogPostHandler's\n    normalized_payload dictionary.\n    \"\"\"\n\n    blog_post_id: str\n    author_username: str\n    published_on: str\n\n\nclass UpdateBlogPostHandler(\n    base.BaseHandler[\n        UpdateBlogPostHandlerNormalizedPayloadDict, Dict[str, str]\n    ]\n):\n    \"\"\"Handler for changing author ids and published on date in\n    blog posts.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'blog_post_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'author_username': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'has_length_at_most',\n                        'max_value': constants.MAX_USERNAME_LENGTH\n                    }]\n                }\n            },\n            'published_on': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Updates the author and published date of a blog post.\n\n        Raises:\n            InvalidInputException. Invalid username.\n            InvalidInputException. User does not have enough rights to be\n                blog post author.\n            PageNotFoundException. The blog post with the given id or url\n                doesn't exist.\n        \"\"\"\n        assert self.normalized_payload is not None\n        blog_post_id = self.normalized_payload['blog_post_id']\n        author_username = self.normalized_payload['author_username']\n        published_on = self.normalized_payload['published_on']\n\n        author_id = user_services.get_user_id_from_username(author_username)\n        if author_id is None:\n            raise self.InvalidInputException(\n                'Invalid username: %s' % author_username)\n\n        user_actions = user_services.get_user_actions_info(author_id).actions\n        if role_services.ACTION_ACCESS_BLOG_DASHBOARD not in user_actions:\n            raise self.InvalidInputException(\n                'User does not have enough rights to be blog post author.')\n\n        blog_post = (\n            blog_services.get_blog_post_by_id(blog_post_id, strict=False))\n        if blog_post is None:\n            raise self.PageNotFoundException(\n                Exception(\n                    'The blog post with the given id or url doesn\\'t exist.'))\n\n        blog_services.update_blog_models_author_and_published_on_date(\n            blog_post_id, author_id, published_on)\n        self.render_json({})\n\n\nclass TranslationCoordinatorRoleHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Dict representation of TranslationCoordinatorRoleHandler's\n    normalized_payload dictionary.\n    \"\"\"\n\n    username: str\n    action: str\n    language_id: str\n\n\nclass TranslationCoordinatorRoleHandler(\n    base.BaseHandler[\n        TranslationCoordinatorRoleHandlerNormalizedPayloadDict, Dict[str, str]\n    ]\n):\n    \"\"\"Handler to assign or deassigning coordinator to a language.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'PUT': {\n            'username': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'action': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': ['assign', 'deassign']\n                }\n            },\n            'language_id': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': supported_languages\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_access_admin_page\n    def put(self) -> None:\n        \"\"\"Adds or removes the translation-coordinator role for a user in the\n        context of a specific language.\n\n        Raises:\n            InvalidInputException. User with given username does not exist.\n        \"\"\"\n        assert self.normalized_payload is not None\n        username = self.normalized_payload['username']\n        action = self.normalized_payload['action']\n        language_id = self.normalized_payload['language_id']\n\n        user_settings = user_services.get_user_settings_from_username(username)\n\n        if user_settings is None:\n            raise self.InvalidInputException(\n                'User with given username does not exist.')\n\n        user_id = user_settings.user_id\n        if action == 'assign':\n            if not feconf.ROLE_ID_TRANSLATION_COORDINATOR in (\n                user_settings.roles):\n                user_services.add_user_role(\n                    user_id, feconf.ROLE_ID_TRANSLATION_COORDINATOR)\n\n            language_coordinator = user_services.get_user_actions_info(user_id)\n\n            user_services.assign_coordinator(\n                user_services.get_system_user(),\n                language_coordinator, language_id)\n        else:\n            # The handler schema defines the possible values of 'action'.\n            # If 'action' has a value other than those defined in the schema,\n            # a Bad Request error will be thrown. Hence, 'action' must be\n            # 'deassign' if this branch is executed.\n            assert action == 'deassign'\n            language_coordinator = user_services.get_user_actions_info(user_id)\n            user_services.deassign_coordinator(\n                user_services.get_system_user(),\n                language_coordinator, language_id)\n\n        self.render_json({})\n"
    },
    {
      "filename": "core/controllers/admin_test.py",
      "content": "# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the admin page.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport enum\nimport logging\n\nfrom core import feconf\nfrom core import platform_feature_list\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import blog_services\nfrom core.domain import classroom_config_services\nfrom core.domain import collection_services\nfrom core.domain import config_domain\nfrom core.domain import config_services\nfrom core.domain import exp_domain\nfrom core.domain import exp_services\nfrom core.domain import fs_services\nfrom core.domain import opportunity_services\nfrom core.domain import platform_parameter_domain\nfrom core.domain import platform_parameter_registry\nfrom core.domain import question_fetchers\nfrom core.domain import recommendations_services\nfrom core.domain import rights_manager\nfrom core.domain import search_services\nfrom core.domain import skill_services\nfrom core.domain import stats_domain\nfrom core.domain import stats_services\nfrom core.domain import story_domain\nfrom core.domain import story_fetchers\nfrom core.domain import story_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_fetchers\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.domain import wipeout_service\nfrom core.platform import models\nfrom core.platform.auth import firebase_auth_services\nfrom core.tests import test_utils\n\nMYPY = False\nif MYPY: # pragma: no cover\n    from mypy_imports import audit_models\n    from mypy_imports import blog_models\n    from mypy_imports import exp_models\n    from mypy_imports import opportunity_models\n    from mypy_imports import user_models\n\n(\n    audit_models, blog_models, exp_models, opportunity_models,\n    user_models\n) = models.Registry.import_models([\n    models.Names.AUDIT, models.Names.BLOG, models.Names.EXPLORATION,\n    models.Names.OPPORTUNITY, models.Names.USER\n])\n\nBOTH_MODERATOR_AND_ADMIN_EMAIL = 'moderator.and.admin@example.com'\nBOTH_MODERATOR_AND_ADMIN_USERNAME = 'moderatorandadm1n'\n\n\nclass ParamNames(enum.Enum):\n    \"\"\"Enum for parameter names.\"\"\"\n\n    TEST_PARAMETER_1 = 'test_param_1'\n\n\nclass AdminIntegrationTest(test_utils.GenericTestBase):\n    \"\"\"Server integration tests for operations on the admin page.\"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"Complete the signup process for self.CURRICULUM_ADMIN_EMAIL.\"\"\"\n        super().setUp()\n        self.signup(feconf.ADMIN_EMAIL_ADDRESS, 'testsuper')\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.prod_mode_swap = self.swap(constants, 'DEV_MODE', False)\n\n    def test_admin_get(self) -> None:\n        \"\"\"Test `/admin` returns a 200 response.\"\"\"\n        self.get_html_response('/admin', expected_status_int=200)\n\n    def test_change_configuration_property(self) -> None:\n        \"\"\"Test that configuration properties can be changed.\"\"\"\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        new_config_value = [{\n            'name': 'math',\n            'url_fragment': 'math',\n            'topic_ids': [],\n            'course_details': 'Detailed math classroom.',\n            'topic_list_intro': ''\n        }]\n\n        response_dict = self.get_json('/adminhandler')\n        response_config_properties = response_dict['config_properties']\n        self.assertDictContainsSubset({\n            'value': [{\n                'name': 'math',\n                'url_fragment': 'math',\n                'topic_ids': [],\n                'course_details': '',\n                'topic_list_intro': ''\n            }],\n        }, response_config_properties[\n            config_domain.CLASSROOM_PAGES_DATA.name])\n\n        payload = {\n            'action': 'save_config_properties',\n            'new_config_property_values': {\n                config_domain.CLASSROOM_PAGES_DATA.name: new_config_value,\n            }\n        }\n        self.post_json('/adminhandler', payload, csrf_token=csrf_token)\n\n        response_dict = self.get_json('/adminhandler')\n        response_config_properties = response_dict['config_properties']\n        self.assertDictContainsSubset({\n            'value': new_config_value,\n        }, response_config_properties[\n            config_domain.CLASSROOM_PAGES_DATA.name])\n\n        self.logout()\n\n    def test_cannot_reload_exploration_in_production_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot reload an exploration in production.')\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'reload_exploration',\n                    'exploration_id': '3'\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_exp_id_reload_exp_action_is_not_performed(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'exploration_id\\' must be provided when the action '\n            'is reload_exploration.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'reload_exploration',\n                    'exploration_id': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_collection_id_reload_collection_action_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'collection_id\\' must be provided when the action '\n            'is reload_collection.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'reload_collection',\n                    'collection_id': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_num_dummy_exps_generate_dummy_exp_action_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'num_dummy_exps_to_generate\\' must be provided when the '\n            'action is generate_dummy_explorations.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_explorations',\n                    'num_dummy_exps_to_generate': None,\n                    'num_dummy_exps_to_publish': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_num_dummy_exps_to_publish_action_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'num_dummy_exps_to_publish\\' must be provided when the '\n            'action is generate_dummy_explorations.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_explorations',\n                    'num_dummy_exps_to_generate': 5,\n                    'num_dummy_exps_to_publish': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_new_config_property_values_action_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'new_config_property_values\\' must be provided when the '\n            'action is save_config_properties.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'save_config_properties',\n                    'new_config_property_values': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_config_property_id_action_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'config_property_id\\' must be provided when the action '\n            'is revert_config_property.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'revert_config_property',\n                    'config_property_id': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_data_action_upload_topic_similarities_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'data\\' must be provided when the action is '\n            'upload_topic_similarities.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'upload_topic_similarities',\n                    'data': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_topic_id_action_regenerate_topic_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'topic_id\\' must be provided when the action is '\n            'regenerate_topic_related_opportunities.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'regenerate_topic_related_opportunities',\n                    'topic_id': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_exp_id_action_rollback_exploration_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'exp_id\\' must be provided when the action is '\n            'rollback_exploration_to_safe_state.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'rollback_exploration_to_safe_state',\n                    'exp_id': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_param_name_action_update_platform_param_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'platform_param_name\\' must be provided when the action is '\n            'update_platform_parameter_rules.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_new_rules_action_update_param_is_not_performed(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'new_rules\\' must be provided when the action is '\n            'update_platform_parameter_rules.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': 'new_feature',\n                    'new_rules': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_without_commit_message_action_update_param_is_not_performed(\n        self\n    ) -> None:\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': True\n            }\n        ]\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception,\n            'The \\'commit_message\\' must be provided when the action is '\n            'update_platform_parameter_rules.'\n        )\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': 'new_feature',\n                    'new_rules': new_rule_dicts,\n                    'commit_message': None\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_cannot_load_new_structures_data_in_production_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot load new structures data in production.')\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_new_structures_data'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_non_admins_cannot_load_new_structures_data(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        assert_raises_regexp = self.assertRaisesRegex(\n            Exception, 'User does not have enough rights to generate data.')\n        with assert_raises_regexp:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_new_structures_data'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_cannot_generate_dummy_skill_data_in_production_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot generate dummy skills in production.')\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_new_skill_data'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_cannot_generate_classroom_data_in_production_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot generate dummy classroom in production.')\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_classroom'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_non_admins_cannot_generate_dummy_skill_data(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        assert_raises_regexp = self.assertRaisesRegex(\n            Exception, 'User does not have enough rights to generate data.')\n        with assert_raises_regexp:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_new_skill_data'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_non_admins_cannot_generate_dummy_classroom_data(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        assert_raises_regexp = self.assertRaisesRegex(\n            Exception, 'User does not have enough rights to generate data.')\n        with assert_raises_regexp:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_classroom'\n                }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_cannot_reload_collection_in_production_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot reload a collection in production.')\n        with assert_raises_regexp_context_manager, self.prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'reload_collection',\n                    'collection_id': '2'\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_reload_collection(self) -> None:\n        observed_log_messages = []\n\n        def _mock_logging_function(msg: str, *args: str) -> None:\n            \"\"\"Mocks logging.info().\"\"\"\n            observed_log_messages.append(msg % args)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        collection_services.load_demo('0')\n        collection_rights = rights_manager.get_collection_rights('0')\n\n        self.assertFalse(collection_rights.community_owned)\n\n        with self.swap(logging, 'info', _mock_logging_function):\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'reload_collection',\n                    'collection_id': '0'\n                }, csrf_token=csrf_token)\n\n        collection_rights = rights_manager.get_collection_rights('0')\n\n        self.assertTrue(collection_rights.community_owned)\n        self.assertEqual(\n            observed_log_messages,\n            [\n                '[ADMIN] %s reloaded collection 0' % self.admin_id,\n                'Collection with id 0 was loaded.'\n            ]\n        )\n\n        self.logout()\n\n    def test_load_new_structures_data(self) -> None:\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_new_structures_data'\n            }, csrf_token=csrf_token)\n        topic_summaries = topic_fetchers.get_all_topic_summaries()\n        self.assertEqual(len(topic_summaries), 2)\n        for summary in topic_summaries:\n            if summary.name == 'Dummy Topic 1':\n                topic_id = summary.id\n        story_id = (\n            topic_fetchers.get_topic_by_id(\n                topic_id).canonical_story_references[0].story_id)\n        self.assertIsNotNone(\n            story_fetchers.get_story_by_id(story_id, strict=False))\n        skill_summaries = skill_services.get_all_skill_summaries()\n        self.assertEqual(len(skill_summaries), 3)\n        questions, _ = (\n            question_fetchers.get_questions_and_skill_descriptions_by_skill_ids(\n                10, [\n                    skill_summaries[0].id, skill_summaries[1].id,\n                    skill_summaries[2].id], 0)\n        )\n        self.assertEqual(len(questions), 5)\n        # Testing that there are 3 hindi translation opportunities\n        # available on the Contributor Dashboard. Hindi was picked arbitrarily,\n        # any language code other than english (what the dummy explorations\n        # were written in) can be tested here.\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities('hi', '', None))\n        self.assertEqual(len(translation_opportunities), 3)\n        self.logout()\n\n    def test_generate_dummy_skill_and_questions_data(self) -> None:\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_new_skill_data'\n            }, csrf_token=csrf_token)\n        skill_summaries = skill_services.get_all_skill_summaries()\n        self.assertEqual(len(skill_summaries), 1)\n        questions, _ = (\n            question_fetchers.get_questions_and_skill_descriptions_by_skill_ids(\n                20, [skill_summaries[0].id], 0)\n        )\n        self.assertEqual(len(questions), 15)\n        self.logout()\n\n    def test_generate_dummy_classroom_data(self) -> None:\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_classroom'\n            }, csrf_token=csrf_token)\n        classrooms = classroom_config_services.get_all_classrooms()\n        self.assertEqual(len(classrooms), 1)\n        self.logout()\n\n    def test_regenerate_topic_related_opportunities_action(self) -> None:\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        topic_id = 'topic'\n        story_id = 'story'\n        self.save_new_valid_exploration(\n            '0', owner_id, title='title', end_state_name='End State',\n            correctness_feedback_enabled=True)\n        self.publish_exploration(owner_id, '0')\n\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic', 'abbrev', 'description', 'fragm')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_1'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = ['skill_id_1']\n        topic_services.save_new_topic(owner_id, topic)\n        topic_services.publish_topic(topic_id, self.admin_id)\n\n        story = story_domain.Story.create_default_story(\n            story_id, 'A story', 'Description', topic_id, 'story')\n        story_services.save_new_story(owner_id, story)\n        topic_services.add_canonical_story(\n            owner_id, topic_id, story_id)\n        topic_services.publish_story(topic_id, story_id, self.admin_id)\n        story_services.update_story(\n            owner_id, story_id, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': '0'\n            })], 'Changes.')\n\n        all_opportunity_models = list(\n            opportunity_models.ExplorationOpportunitySummaryModel.get_all())\n\n        self.assertEqual(len(all_opportunity_models), 1)\n\n        old_creation_time = all_opportunity_models[0].created_on\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        result = self.post_json(\n            '/adminhandler', {\n                'action': 'regenerate_topic_related_opportunities',\n                'topic_id': 'topic'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(\n            result, {\n                'opportunities_count': 1\n            })\n\n        all_opportunity_models = list(\n            opportunity_models.ExplorationOpportunitySummaryModel.get_all())\n\n        self.assertEqual(len(all_opportunity_models), 1)\n\n        new_creation_time = all_opportunity_models[0].created_on\n\n        self.assertLess(old_creation_time, new_creation_time)\n\n    def test_rollback_exploration_to_safe_state_action(self) -> None:\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        self.save_new_valid_exploration(\n            '0', owner_id, title='title', end_state_name='End State',\n            correctness_feedback_enabled=True)\n        exp_services.update_exploration(\n            owner_id, '0', [exp_domain.ExplorationChange({\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'content 1'\n            },\n            'state_name': 'Introduction',\n            'old_value': {\n                'content_id': 'content_0',\n                'html': ''\n            },\n            'cmd': 'edit_state_property',\n            'property_name': 'content'\n            })], 'Update 1')\n        exp_services.update_exploration(\n            owner_id, '0', [exp_domain.ExplorationChange({\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'content 1'\n            },\n            'state_name': 'Introduction',\n            'old_value': {\n                'content_id': 'content_0',\n                'html': ''\n            },\n            'cmd': 'edit_state_property',\n            'property_name': 'content'\n            })], 'Update 2')\n        exp_services.update_exploration(\n            owner_id, '0', [exp_domain.ExplorationChange({\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'content 1'\n            },\n            'state_name': 'Introduction',\n            'old_value': {\n                'content_id': 'content_0',\n                'html': ''\n            },\n            'cmd': 'edit_state_property',\n            'property_name': 'content'\n            })], 'Update 3')\n        exp_services.update_exploration(\n            owner_id, '0', [exp_domain.ExplorationChange({\n            'new_value': {\n                'content_id': 'content_0',\n                'html': 'content 1'\n            },\n            'state_name': 'Introduction',\n            'old_value': {\n                'content_id': 'content_0',\n                'html': ''\n            },\n            'cmd': 'edit_state_property',\n            'property_name': 'content'\n            })], 'Update 4')\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        result = self.post_json(\n            '/adminhandler', {\n                'action': 'rollback_exploration_to_safe_state',\n                'exp_id': '0'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(\n            result, {\n                'version': 5\n            })\n\n        snapshot_content_model = (\n            exp_models.ExplorationSnapshotContentModel.get(\n                '0-5', strict=True))\n        snapshot_content_model.delete()\n        snapshot_metadata_model = (\n            exp_models.ExplorationSnapshotMetadataModel.get(\n                '0-4', strict=True))\n        snapshot_metadata_model.delete()\n\n        result = self.post_json(\n            '/adminhandler', {\n                'action': 'rollback_exploration_to_safe_state',\n                'exp_id': '0'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(\n            result, {\n                'version': 3\n            })\n\n    def test_admin_topics_csv_download_handler(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        response = self.get_custom_response(\n            '/admintopicscsvdownloadhandler', 'text/csv')\n\n        self.assertEqual(\n            response.headers['Content-Disposition'],\n            'attachment; filename=topic_similarities.csv')\n\n        self.assertIn(\n            b'Architecture,Art,Biology,Business,Chemistry,Computing,Economics,'\n            b'Education,Engineering,Environment,Geography,Government,Hobbies,'\n            b'Languages,Law,Life Skills,Mathematics,Medicine,Music,Philosophy,'\n            b'Physics,Programming,Psychology,Puzzles,Reading,Religion,Sport,'\n            b'Statistics,Welcome',\n            response.body)\n\n        self.logout()\n\n    def test_revert_config_property(self) -> None:\n        observed_log_messages = []\n\n        def _mock_logging_function(msg: str, *args: str) -> None:\n            \"\"\"Mocks logging.info().\"\"\"\n            observed_log_messages.append(msg % args)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        config_services.set_property(\n            self.admin_id, 'classroom_pages_data', [{\n                'name': 'math',\n                'url_fragment': 'math',\n                'topic_ids': [],\n                'course_details': 'Detailed math classroom.',\n                'topic_list_intro': ''\n            }]\n        )\n        self.assertEqual(\n            config_domain.CLASSROOM_PAGES_DATA.value, [{\n                'name': 'math',\n                'url_fragment': 'math',\n                'topic_ids': [],\n                'course_details': 'Detailed math classroom.',\n                'topic_list_intro': ''\n            }]\n        )\n\n        with self.swap(logging, 'info', _mock_logging_function):\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'revert_config_property',\n                    'config_property_id': 'classroom_pages_data'\n                }, csrf_token=csrf_token)\n\n        self.assertEqual(\n            config_domain.CLASSROOM_PAGES_DATA.value, [{\n                'name': 'math',\n                'url_fragment': 'math',\n                'topic_ids': [],\n                'course_details': '',\n                'topic_list_intro': ''\n            }]\n        )\n        self.assertEqual(\n            observed_log_messages,\n            ['[ADMIN] %s reverted config property: '\n             'classroom_pages_data' % self.admin_id])\n\n        self.logout()\n\n    def test_upload_topic_similarities(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        self.assertEqual(recommendations_services.get_topic_similarity(\n            'Art', 'Biology'), 0.1)\n        self.assertEqual(recommendations_services.get_topic_similarity(\n            'Art', 'Art'), feconf.SAME_TOPIC_SIMILARITY)\n        self.assertEqual(recommendations_services.get_topic_similarity(\n            'Topic 1', 'Topic 2'), feconf.DEFAULT_TOPIC_SIMILARITY)\n        self.assertEqual(recommendations_services.get_topic_similarity(\n            'Topic', 'Topic'), feconf.SAME_TOPIC_SIMILARITY)\n\n        topic_similarities_data = (\n            'Art,Biology,Chemistry\\n'\n            '1.0,0.2,0.1\\n'\n            '0.2,1.0,0.8\\n'\n            '0.1,0.8,1.0'\n        )\n\n        self.post_json(\n            '/adminhandler', {\n                'action': 'upload_topic_similarities',\n                'data': topic_similarities_data\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(recommendations_services.get_topic_similarity(\n            'Art', 'Biology'), 0.2)\n\n        self.logout()\n\n    def test_get_handler_includes_all_platform_params(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        param = (\n            platform_parameter_registry.Registry.create_platform_parameter(\n                ParamNames.TEST_PARAMETER_1,\n                'Param for test.',\n                platform_parameter_domain.DataTypes.BOOL)\n        )\n        with self.swap(\n            platform_feature_list,\n            'ALL_PLATFORM_PARAMS_EXCEPT_FEATURE_FLAGS',\n            [ParamNames.TEST_PARAMETER_1]\n        ):\n            response_dict = self.get_json('/adminhandler')\n        self.assertEqual(\n            response_dict['platform_params_dicts'], [param.to_dict()])\n\n        platform_parameter_registry.Registry.parameter_registry.pop(\n            param.name)\n        self.logout()\n\n    def test_post_with_rules_changes_updates_platform_params(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        param = (\n            platform_parameter_registry.Registry.create_platform_parameter(\n                ParamNames.TEST_PARAMETER_1,\n                'Param for test.',\n                platform_parameter_domain.DataTypes.BOOL)\n        )\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': True\n            }\n        ]\n\n        with self.swap(\n            platform_feature_list,\n            'ALL_PLATFORM_PARAMS_EXCEPT_FEATURE_FLAGS',\n            [ParamNames.TEST_PARAMETER_1]\n        ):\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': param.name,\n                    'new_rules': new_rule_dicts,\n                    'commit_message': 'test update param',\n                    'default_value': {'value': False}\n                }, csrf_token=csrf_token)\n\n        rule_dicts = [\n            rule.to_dict() for rule\n            in platform_parameter_registry.Registry.get_platform_parameter(\n                param.name).rules\n        ]\n        self.assertEqual(rule_dicts, new_rule_dicts)\n\n        platform_parameter_registry.Registry.parameter_registry.pop(\n            param.name)\n        self.logout()\n\n    def test_post_rules_changes_correctly_updates_params_returned_by_getter(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        platform_parameter_registry.Registry.parameter_registry.clear()\n        param = platform_parameter_registry.Registry.create_platform_parameter(\n            ParamNames.TEST_PARAMETER_1,\n            'Param for test.',\n            platform_parameter_domain.DataTypes.BOOL)\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': True\n            }\n        ]\n\n        with self.swap(\n            platform_feature_list,\n            'ALL_PLATFORM_PARAMS_EXCEPT_FEATURE_FLAGS',\n            [ParamNames.TEST_PARAMETER_1]\n        ):\n            response_dict = self.get_json('/adminhandler')\n            self.assertEqual(\n                response_dict['platform_params_dicts'], [param.to_dict()])\n\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': param.name,\n                    'new_rules': new_rule_dicts,\n                    'commit_message': 'test update param',\n                    'default_value': {'value': False}\n                }, csrf_token=csrf_token)\n\n            response_dict = self.get_json('/adminhandler')\n            rules = response_dict['platform_params_dicts'][0]['rules']\n            self.assertEqual(rules, new_rule_dicts)\n\n        platform_parameter_registry.Registry.parameter_registry.pop(\n            param.name)\n        self.logout()\n\n    def test_update_parameter_rules_with_unknown_param_name_raises_error(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': True\n            }\n        ]\n\n        with self.swap(\n            platform_feature_list,\n            'ALL_PLATFORM_PARAMS_EXCEPT_FEATURE_FLAGS',\n            [ParamNames.TEST_PARAMETER_1]\n        ):\n            response = self.post_json(\n                '/adminhandler', {\n                    'action': 'update_platform_parameter_rules',\n                    'platform_param_name': 'unknown_param',\n                    'new_rules': new_rule_dicts,\n                    'commit_message': 'test update param',\n                    'default_value': {'value': False}\n                },\n                csrf_token=csrf_token,\n                expected_status_int=500\n            )\n        self.assertEqual(\n            response['error'],\n            'Platform parameter not found: unknown_param.')\n\n        self.logout()\n\n    def test_update_parameter_rules_with_unknown_data_type_returns_400(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        platform_parameter_registry.Registry.parameter_registry.clear()\n        param = platform_parameter_registry.Registry.create_platform_parameter(\n            ParamNames.TEST_PARAMETER_1,\n            'Param for test.',\n            platform_parameter_domain.DataTypes.BOOL)\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': 'unknown'\n            }\n        ]\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': param.name,\n                'new_rules': new_rule_dicts,\n                'commit_message': 'test update param',\n                'default_value': {'value': False}\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        self.assertEqual(\n            response['error'],\n            'Expected bool, received \\'unknown\\' in value_when_matched.')\n\n        self.logout()\n\n    def test_update_param_rules_with_param_name_of_non_string_type_returns_400(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': 123,\n                'new_rules': [],\n                'commit_message': 'test update param',\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        error_msg = (\n            'Schema validation for \\'platform_param_name\\' failed: Expected '\n            'string, received 123')\n        self.assertEqual(response['error'], error_msg)\n\n        self.logout()\n\n    def test_update_param_rules_with_message_of_non_string_type_returns_400(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': 'param_name',\n                'new_rules': [],\n                'commit_message': 123,\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        error_msg = (\n            'Schema validation for \\'commit_message\\' failed: Expected '\n            'string, received 123')\n        self.assertEqual(response['error'], error_msg)\n\n        self.logout()\n\n    def test_update_param_rules_with_rules_of_non_list_type_returns_400(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': 'param_name',\n                'new_rules': {},\n                'commit_message': 'test update param',\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        error_msg = (\n            'Schema validation for \\'new_rules\\' failed: Expected list, '\n            'received {}')\n        self.assertEqual(response['error'], error_msg)\n\n        self.logout()\n\n    def test_update_param_rules_with_rules_of_non_list_of_dict_type_returns_400(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        error_msg = (\n            'Schema validation for \\'new_rules\\' failed: \\'int\\' '\n            'object is not subscriptable')\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': 'param_name',\n                'new_rules': [1, 2],\n                'commit_message': 'test update param',\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        self.assertEqual(response['error'], error_msg)\n\n        self.logout()\n\n    def test_update_param_rules_with_unexpected_exception_returns_500(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        param = platform_parameter_registry.Registry.create_platform_parameter(\n            ParamNames.TEST_PARAMETER_1,\n            'Param for test.',\n            platform_parameter_domain.DataTypes.BOOL)\n        new_rule_dicts = [\n            {\n                'filters': [\n                    {\n                        'type': 'platform_type',\n                        'conditions': [['=', 'Web']]\n                    }\n                ],\n                'value_when_matched': True\n            }\n        ]\n\n        # Here we use MyPy ignore because we are assigning a None value\n        # where instance of 'PlatformParameter' is expected, and this is\n        # done to Replace the stored instance with None in order to\n        # trigger the unexpected exception during update.\n        platform_parameter_registry.Registry.parameter_registry[\n            param.name] = None  # type: ignore[assignment]\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'update_platform_parameter_rules',\n                'platform_param_name': param.name,\n                'new_rules': new_rule_dicts,\n                'commit_message': 'test update param',\n                'default_value': {'value': False}\n            },\n            csrf_token=csrf_token,\n            expected_status_int=500\n        )\n        self.assertEqual(\n            response['error'],\n            '\\'NoneType\\' object has no attribute \\'serialize\\'')\n\n        platform_parameter_registry.Registry.parameter_registry.pop(\n            param.name)\n        self.logout()\n\n    def test_grant_super_admin_privileges(self) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        grant_super_admin_privileges_stub = self.swap_with_call_counter(\n            firebase_auth_services, 'grant_super_admin_privileges')\n\n        with grant_super_admin_privileges_stub as call_counter:\n            response = self.put_json(\n                '/adminsuperadminhandler',\n                {'username': self.CURRICULUM_ADMIN_USERNAME},\n                csrf_token=self.get_new_csrf_token(),\n                expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertNotIn('error', response)\n\n    def test_grant_super_admin_privileges_requires_system_default_admin(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        grant_super_admin_privileges_stub = self.swap_with_call_counter(\n            firebase_auth_services, 'grant_super_admin_privileges')\n\n        with grant_super_admin_privileges_stub as call_counter:\n            response = self.put_json(\n                '/adminsuperadminhandler',\n                {'username': self.CURRICULUM_ADMIN_USERNAME},\n                csrf_token=self.get_new_csrf_token(),\n                expected_status_int=401)\n\n        self.assertEqual(call_counter.times_called, 0)\n        self.assertEqual(\n            response['error'],\n            'Only the default system admin can manage super admins')\n\n    def test_grant_super_admin_privileges_fails_without_username(self) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.put_json(\n            '/adminsuperadminhandler', {}, csrf_token=self.get_new_csrf_token(),\n            expected_status_int=400)\n\n        error_msg = 'Missing key in handler args: username.'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_grant_super_admin_privileges_fails_with_invalid_username(\n        self\n    ) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.put_json(\n            '/adminsuperadminhandler', {'username': 'fakeusername'},\n            csrf_token=self.get_new_csrf_token(), expected_status_int=400)\n\n        self.assertEqual(response['error'], 'No such user exists')\n\n    def test_revoke_super_admin_privileges(self) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        revoke_super_admin_privileges_stub = self.swap_with_call_counter(\n            firebase_auth_services, 'revoke_super_admin_privileges')\n\n        with revoke_super_admin_privileges_stub as call_counter:\n            response = self.delete_json(\n                '/adminsuperadminhandler',\n                params={'username': self.CURRICULUM_ADMIN_USERNAME},\n                expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertNotIn('error', response)\n\n    def test_revoke_super_admin_privileges_requires_system_default_admin(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        revoke_super_admin_privileges_stub = self.swap_with_call_counter(\n            firebase_auth_services, 'revoke_super_admin_privileges')\n\n        with revoke_super_admin_privileges_stub as call_counter:\n            response = self.delete_json(\n                '/adminsuperadminhandler',\n                params={'username': self.CURRICULUM_ADMIN_USERNAME},\n                expected_status_int=401)\n\n        self.assertEqual(call_counter.times_called, 0)\n        self.assertEqual(\n            response['error'],\n            'Only the default system admin can manage super admins')\n\n    def test_revoke_super_admin_privileges_fails_without_username(self) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.delete_json(\n            '/adminsuperadminhandler', params={}, expected_status_int=400)\n\n        error_msg = 'Missing key in handler args: username.'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_revoke_super_admin_privileges_fails_with_invalid_username(\n        self\n    ) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.delete_json(\n            '/adminsuperadminhandler',\n            params={'username': 'fakeusername'}, expected_status_int=400)\n\n        self.assertEqual(response['error'], 'No such user exists')\n\n    def test_revoke_super_admin_privileges_fails_for_default_admin(\n        self\n    ) -> None:\n        self.login(feconf.ADMIN_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.delete_json(\n            '/adminsuperadminhandler', params={'username': 'testsuper'},\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Cannot revoke privileges from the default super admin account')\n\n\nclass GenerateDummyExplorationsTest(test_utils.GenericTestBase):\n    \"\"\"Test the conditions for generation of dummy explorations.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n    def test_generate_count_greater_than_publish_count(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_explorations',\n                'num_dummy_exps_to_generate': 10,\n                'num_dummy_exps_to_publish': 3\n            }, csrf_token=csrf_token)\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(len(generated_exps), 10)\n        self.assertEqual(len(published_exps), 3)\n\n    def test_generate_count_equal_to_publish_count(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_explorations',\n                'num_dummy_exps_to_generate': 2,\n                'num_dummy_exps_to_publish': 2\n            }, csrf_token=csrf_token)\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(len(generated_exps), 2)\n        self.assertEqual(len(published_exps), 2)\n\n    def test_generate_count_less_than_publish_count(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        generated_exps_response = self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_explorations',\n                'num_dummy_exps_to_generate': 2,\n                'num_dummy_exps_to_publish': 5\n            },\n            csrf_token=csrf_token, expected_status_int=400)\n        self.assertEqual(generated_exps_response['status_code'], 400)\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(len(generated_exps), 0)\n        self.assertEqual(len(published_exps), 0)\n\n    def test_handler_raises_error_with_non_int_num_dummy_exps_to_generate(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_explorations',\n                'num_dummy_exps_to_publish': 1,\n                'num_dummy_exps_to_generate': 'invalid_type'\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        error_msg = (\n            'Schema validation for \\'num_dummy_exps_to_generate\\' failed: '\n            'Could not convert str to int: invalid_type')\n        self.assertEqual(response['error'], error_msg)\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(generated_exps, {})\n        self.assertEqual(published_exps, {})\n\n        self.logout()\n\n    def test_handler_raises_error_with_non_int_num_dummy_exps_to_publish(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '/adminhandler', {\n                'action': 'generate_dummy_explorations',\n                'num_dummy_exps_to_publish': 'invalid_type',\n                'num_dummy_exps_to_generate': 1\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        error_msg = (\n            'Schema validation for \\'num_dummy_exps_to_publish\\' failed: '\n            'Could not convert str to int: invalid_type')\n        self.assertEqual(response['error'], error_msg)\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(generated_exps, {})\n        self.assertEqual(published_exps, {})\n\n        self.logout()\n\n    def test_cannot_generate_dummy_explorations_in_prod_mode(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        prod_mode_swap = self.swap(constants, 'DEV_MODE', False)\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'Cannot generate dummy explorations in production.')\n\n        with assert_raises_regexp_context_manager, prod_mode_swap:\n            self.post_json(\n                '/adminhandler', {\n                    'action': 'generate_dummy_explorations',\n                    'num_dummy_exps_to_generate': 10,\n                    'num_dummy_exps_to_publish': 3\n                }, csrf_token=csrf_token)\n\n        generated_exps = exp_services.get_all_exploration_summaries()\n        published_exps = exp_services.get_recently_published_exp_summaries(5)\n        self.assertEqual(generated_exps, {})\n        self.assertEqual(published_exps, {})\n\n        self.logout()\n\n\nclass AdminRoleHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Checks the user role handling on the admin page.\"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"Complete the signup process for self.CURRICULUM_ADMIN_EMAIL.\"\"\"\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n\n    def test_view_and_update_role(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n\n        self.signup(user_email, username)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        # Check normal user has expected roles. Viewing by username.\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': 'user1'})\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            {'role': feconf.ROLE_ID_MODERATOR, 'username': username},\n            csrf_token=csrf_token,\n            expected_status_int=200)\n        self.assertEqual(response_dict, {})\n\n        # Viewing by role.\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={\n                'filter_criterion': 'role',\n                'role': feconf.ROLE_ID_MODERATOR\n            })\n        self.assertEqual(response_dict, {\n            'usernames': ['user1']\n        })\n        self.logout()\n\n    def test_if_filter_criterion_is_username_and_username_is_not_provided(\n        self\n    ) -> None:\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        with self.assertRaisesRegex(\n            Exception,\n            'The username must be provided when the filter criterion '\n            'is \\'username\\'.'\n        ):\n            self.get_json(\n                feconf.ADMIN_ROLE_HANDLER_URL,\n                params={'filter_criterion': 'username'}\n            )\n\n    def test_if_filter_criterion_is_role_and_role_is_not_provided(\n        self\n    ) -> None:\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        with self.assertRaisesRegex(\n            Exception,\n            'The role must be provided when the filter criterion is \\'role\\'.'\n        ):\n            self.get_json(\n                feconf.ADMIN_ROLE_HANDLER_URL,\n                params={'filter_criterion': 'role'}\n            )\n\n    def test_invalid_username_in_filter_criterion_and_update_role(self) -> None:\n        username = 'myinvaliduser'\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Trying to view role of non-existent user.\n        self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username},\n            expected_status_int=400)\n\n        # Trying to update role of non-existent user.\n        csrf_token = self.get_new_csrf_token()\n        self.put_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            {'role': feconf.ROLE_ID_MODERATOR, 'username': username},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n    def test_removing_role_with_invalid_username(self) -> None:\n        username = 'invaliduser'\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        response = self.delete_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'role': feconf.ROLE_ID_TOPIC_MANAGER, 'username': username},\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'User with given username does not exist.')\n\n    def test_cannot_view_role_with_invalid_view_filter_criterion(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        response = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'invalid', 'username': 'user1'},\n            expected_status_int=400)\n        error_msg = (\n            'Schema validation for \\'filter_criterion\\' failed: Received '\n            'invalid which is not in the allowed range of choices: '\n            '[\\'role\\', \\'username\\']')\n        self.assertEqual(response['error'], error_msg)\n\n    def test_replacing_user_role_from_topic_manager_to_moderator(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n\n        self.signup(user_email, username)\n\n        topic_id = topic_fetchers.get_new_topic_id()\n        subtopic_1 = topic_domain.Subtopic.create_default_subtopic(\n            1, 'Subtopic Title 1', 'url-frag-one')\n        subtopic_1.skill_ids = ['skill_id_1']\n        subtopic_1.url_fragment = 'sub-one-frag'\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[subtopic_1], next_subtopic_id=2)\n        self.set_topic_managers([username], topic_id)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER],\n                'banned': False,\n                'managed_topic_ids': [topic_id],\n                'coordinated_language_ids': []\n            })\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'deassign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token)\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            {'role': feconf.ROLE_ID_MODERATOR, 'username': username},\n            csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(response_dict, {\n            'roles': [feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_MODERATOR],\n            'banned': False,\n            'managed_topic_ids': [],\n            'coordinated_language_ids': []\n        })\n\n        self.logout()\n\n    def test_removing_moderator_role_from_user_roles(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n\n        self.signup(user_email, username)\n        self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            {'role': feconf.ROLE_ID_MODERATOR, 'username': username},\n            csrf_token=csrf_token)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_MODERATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        self.delete_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'role': feconf.ROLE_ID_MODERATOR, 'username': username},\n            expected_status_int=200)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n        self.logout()\n\n    def test_general_role_handler_does_not_support_assigning_topic_manager(\n        self\n    ) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json(\n            feconf.ADMIN_ROLE_HANDLER_URL, {\n                'role': feconf.ROLE_ID_TOPIC_MANAGER,\n                'username': username\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'Unsupported role for this handler.')\n\n    def test_general_role_handler_supports_unassigning_topic_manager(\n        self\n    ) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n\n        self.signup(user_email, username)\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            abbreviated_name='abbrev', url_fragment='url-fragment',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER],\n                'banned': False,\n                'managed_topic_ids': [topic_id],\n                'coordinated_language_ids': []\n            })\n\n        self.delete_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'username': username, 'role': feconf.ROLE_ID_TOPIC_MANAGER})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n\nclass TopicManagerRoleHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests for TopicManagerRoleHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.admin_id = self.get_user_id_from_email(self.SUPER_ADMIN_EMAIL)\n\n    def test_handler_with_invalid_username(self) -> None:\n        username = 'invaliduser'\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            abbreviated_name='abbrev', url_fragment='url-fragment',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'User with given username does not exist.')\n\n    def test_adding_topic_manager_role_to_user(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n\n        self.signup(user_email, username)\n\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            abbreviated_name='abbrev', url_fragment='url-fragment',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER],\n                'banned': False,\n                'managed_topic_ids': [topic_id],\n                'coordinated_language_ids': []\n            })\n        self.logout()\n\n    def test_adding_new_topic_manager_to_a_topic(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            abbreviated_name='abbrev', url_fragment='url-fragment',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER],\n                'banned': False,\n                'managed_topic_ids': [topic_id],\n                'coordinated_language_ids': []\n            })\n\n        new_topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            new_topic_id, self.admin_id, name='New topic',\n            abbreviated_name='new-abbrev', url_fragment='new-url-fragment',\n            description='New description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': new_topic_id\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertFalse(response_dict['banned'])\n        self.assertItemsEqual(\n            response_dict['roles'],\n            [feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER])\n        self.assertItemsEqual(\n            response_dict['managed_topic_ids'], [new_topic_id, topic_id])\n\n        self.logout()\n\n\nclass TranslationCoordinatorRoleHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests for TranslationCoordinatorRoleHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.admin_id = self.get_user_id_from_email(self.SUPER_ADMIN_EMAIL)\n\n    def test_handler_with_invalid_username(self) -> None:\n        username = 'invaliduser'\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'User with given username does not exist.')\n\n    def test_adding_translation_coordinator_role_to_language(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER,\n                    feconf.ROLE_ID_TRANSLATION_COORDINATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': ['en']\n            })\n        self.logout()\n\n    def test_assigning_two_languages_to_translation_coordinator(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER,\n                    feconf.ROLE_ID_TRANSLATION_COORDINATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': ['en']\n            })\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'hi'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER,\n                    feconf.ROLE_ID_TRANSLATION_COORDINATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': ['en', 'hi']\n            })\n        self.logout()\n\n    def test_deassigning_language_from_coordinator(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER,\n                    feconf.ROLE_ID_TRANSLATION_COORDINATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': ['en']\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'deassign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        self.delete_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={\n                'role': feconf.ROLE_ID_TRANSLATION_COORDINATOR,\n                'username': username},\n            expected_status_int=200)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n        self.logout()\n\n    def test_removing_translation_coordinator_role(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        # Check role correctly gets updated.\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/translationcoordinatorrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'language_id': 'en'\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER,\n                    feconf.ROLE_ID_TRANSLATION_COORDINATOR],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': ['en']\n            })\n\n        self.delete_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={\n                'username': username,\n                'role': feconf.ROLE_ID_TRANSLATION_COORDINATOR})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n        self.logout()\n\n\nclass BannedUsersHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests for BannedUsersHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.admin_id = self.get_user_id_from_email(self.SUPER_ADMIN_EMAIL)\n\n    def test_mark_a_user_ban(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/bannedusershandler', {\n                'username': username\n            }, csrf_token=csrf_token)\n\n        self.assertEqual(response_dict, {})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [],\n                'banned': True,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n    def test_banning_topic_manager_should_remove_user_from_topics(\n        self\n    ) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, self.admin_id, name='Name',\n            abbreviated_name='abbrev', url_fragment='url-fragment',\n            description='Description', canonical_story_ids=[],\n            additional_story_ids=[], uncategorized_skill_ids=[],\n            subtopics=[], next_subtopic_id=1)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/topicmanagerrolehandler', {\n                'action': 'assign',\n                'username': username,\n                'topic_id': topic_id\n            }, csrf_token=csrf_token)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [\n                    feconf.ROLE_ID_FULL_USER, feconf.ROLE_ID_TOPIC_MANAGER],\n                'banned': False,\n                'managed_topic_ids': [topic_id],\n                'coordinated_language_ids': []\n            })\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json(\n            '/bannedusershandler', {\n                'username': username\n            }, csrf_token=csrf_token)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [],\n                'banned': True,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n    def test_ban_user_with_invalid_username(self) -> None:\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.put_json(\n            '/bannedusershandler', {\n                'username': 'invalidUsername'\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response_dict['error'], 'User with given username does not exist.')\n\n    def test_unmark_a_banned_user(self) -> None:\n        user_email = 'user1@example.com'\n        username = 'user1'\n        self.signup(user_email, username)\n\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n        self.put_json(\n            '/bannedusershandler', {\n                'username': username\n            }, csrf_token=csrf_token)\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [],\n                'banned': True,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n        self.delete_json('/bannedusershandler', params={'username': username})\n\n        response_dict = self.get_json(\n            feconf.ADMIN_ROLE_HANDLER_URL,\n            params={'filter_criterion': 'username', 'username': username})\n\n        self.assertEqual(\n            response_dict, {\n                'roles': [feconf.ROLE_ID_FULL_USER],\n                'banned': False,\n                'managed_topic_ids': [],\n                'coordinated_language_ids': []\n            })\n\n    def test_unban_user_with_invalid_username(self) -> None:\n        self.login(self.SUPER_ADMIN_EMAIL, is_super_admin=True)\n        response_dict = self.delete_json(\n            '/bannedusershandler',\n            params={'username': 'invalidUsername'},\n            expected_status_int=400)\n\n        self.assertEqual(\n            response_dict['error'], 'User with given username does not exist.')\n\n\nclass DataExtractionQueryHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for data extraction handler.\"\"\"\n\n    EXP_ID = 'exp'\n\n    def setUp(self) -> None:\n        \"\"\"Complete the signup process for self.CURRICULUM_ADMIN_EMAIL.\"\"\"\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.exploration = self.save_new_valid_exploration(\n            self.EXP_ID, self.editor_id, end_state_name='End')\n\n        stats_services.record_answer(\n            self.EXP_ID, self.exploration.version,\n            self.exploration.init_state_name, 'TextInput',\n            stats_domain.SubmittedAnswer(\n                'first answer', 'TextInput', 0,\n                0, exp_domain.EXPLICIT_CLASSIFICATION, {},\n                'a_session_id_val', 1.0))\n\n        stats_services.record_answer(\n            self.EXP_ID, self.exploration.version,\n            self.exploration.init_state_name, 'TextInput',\n            stats_domain.SubmittedAnswer(\n                'second answer', 'TextInput', 0,\n                0, exp_domain.EXPLICIT_CLASSIFICATION, {},\n                'a_session_id_val', 1.0))\n\n    def test_data_extraction_handler(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Test that it returns all answers when 'num_answers' is 0.\n        payload = {\n            'exp_id': self.EXP_ID,\n            'exp_version': self.exploration.version,\n            'state_name': self.exploration.init_state_name,\n            'num_answers': 0\n        }\n\n        response = self.get_json(\n            '/explorationdataextractionhandler', params=payload)\n        extracted_answers = response['data']\n        self.assertEqual(len(extracted_answers), 2)\n        self.assertEqual(extracted_answers[0]['answer'], 'first answer')\n        self.assertEqual(extracted_answers[1]['answer'], 'second answer')\n\n        # Make sure that it returns only 'num_answers' number of answers.\n        payload = {\n            'exp_id': self.EXP_ID,\n            'exp_version': self.exploration.version,\n            'state_name': self.exploration.init_state_name,\n            'num_answers': 1\n        }\n\n        response = self.get_json(\n            '/explorationdataextractionhandler', params=payload)\n        extracted_answers = response['data']\n        self.assertEqual(len(extracted_answers), 1)\n        self.assertEqual(extracted_answers[0]['answer'], 'first answer')\n\n    def test_raises_error_if_no_state_answer_exists_while_data_extraction(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        payload = {\n            'exp_id': self.EXP_ID,\n            'exp_version': self.exploration.version,\n            'state_name': self.exploration.init_state_name,\n            'num_answers': 0\n        }\n\n        swap_state_answers = self.swap_to_always_return(\n            stats_services, 'get_state_answers', None\n        )\n        with swap_state_answers:\n            response = self.get_json(\n                '/explorationdataextractionhandler',\n                params=payload,\n                expected_status_int=500\n            )\n        self.assertEqual(\n            response['error'],\n            'No state answer exists for the given exp_id: exp, '\n            'exp_version: 1 and state_name: Introduction'\n        )\n\n    def test_handler_when_exp_version_is_not_int_throws_exception(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Test that it returns all answers when 'num_answers' is 0.\n        payload = {\n            'exp_id': self.EXP_ID,\n            'exp_version': 'a',\n            'state_name': self.exploration.init_state_name,\n            'num_answers': 0\n        }\n\n        error_msg = (\n            'Schema validation for \\'exp_version\\' failed: '\n            'Could not convert str to int: a')\n        response = self.get_json(\n            '/explorationdataextractionhandler',\n            params=payload,\n            expected_status_int=400)\n        self.assertEqual(response['error'], error_msg)\n\n    def test_that_handler_raises_exception(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        payload = {\n            'exp_id': self.EXP_ID,\n            'exp_version': self.exploration.version,\n            'state_name': 'state name',\n            'num_answers': 0\n        }\n\n        response = self.get_json(\n            '/explorationdataextractionhandler', params=payload,\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Exploration \\'exp\\' does not have \\'state name\\' state.')\n\n    def test_handler_raises_error_with_invalid_exploration_id(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        payload = {\n            'exp_id': 'invalid_exp_id',\n            'state_name': 'state name',\n            'exp_version': 1,\n            'num_answers': 0\n        }\n\n        response = self.get_json(\n            '/explorationdataextractionhandler', params=payload,\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Entity for exploration with id invalid_exp_id and version 1 not '\n            'found.')\n\n    def test_handler_raises_error_with_invalid_exploration_version(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        payload = {\n            'exp_id': self.EXP_ID,\n            'state_name': 'state name',\n            'exp_version': 10,\n            'num_answers': 0\n        }\n\n        response = self.get_json(\n            '/explorationdataextractionhandler', params=payload,\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Entity for exploration with id %s and version 10 not found.'\n            % self.EXP_ID)\n\n\nclass ClearSearchIndexTest(test_utils.GenericTestBase):\n    \"\"\"Tests that search index gets cleared.\"\"\"\n\n    def test_clear_search_index(self) -> None:\n        exp_services.load_demo('0')\n        result_explorations = search_services.search_explorations(\n            'Welcome', [], [], 2)[0]\n        self.assertEqual(result_explorations, ['0'])\n        collection_services.load_demo('0')\n        result_collections = search_services.search_collections(\n            'Welcome', [], [], 2)[0]\n        self.assertEqual(result_collections, ['0'])\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        user_id_a = self.get_user_id_from_email(\n            self.CURRICULUM_ADMIN_EMAIL\n        )\n        blog_post = blog_services.create_new_blog_post(user_id_a)\n        change_dict: blog_services.BlogPostChangeDict = {\n            'title': 'Welcome to Oppia',\n            'thumbnail_filename': 'thumbnail.svg',\n            'content': 'Hello Blog Authors',\n            'tags': ['Math', 'Science']\n        }\n        blog_services.update_blog_post(blog_post.id, change_dict)\n        blog_services.publish_blog_post(blog_post.id)\n\n        csrf_token = self.get_new_csrf_token()\n        generated_exps_response = self.post_json(\n            '/adminhandler', {\n                'action': 'clear_search_index'\n            },\n            csrf_token=csrf_token)\n        self.assertEqual(generated_exps_response, {})\n        result_explorations = search_services.search_explorations(\n            'Welcome', [], [], 2)[0]\n        self.assertEqual(result_explorations, [])\n        result_collections = search_services.search_collections(\n            'Welcome', [], [], 2)[0]\n        self.assertEqual(result_collections, [])\n        result_blog_posts = (\n            search_services.search_blog_post_summaries('Welcome', [], 2)[0]\n        )\n        self.assertEqual(result_blog_posts, [])\n\n\nclass SendDummyMailTest(test_utils.GenericTestBase):\n    \"\"\"\"Tests for sending test mails to admin.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n    def test_send_dummy_mail(self) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        csrf_token = self.get_new_csrf_token()\n\n        with self.swap(feconf, 'CAN_SEND_EMAILS', True):\n            generated_response = self.post_json(\n                '/senddummymailtoadminhandler', {},\n                csrf_token=csrf_token, expected_status_int=200)\n            self.assertEqual(generated_response, {})\n\n        with self.swap(feconf, 'CAN_SEND_EMAILS', False):\n            generated_response = self.post_json(\n                '/senddummymailtoadminhandler', {},\n                csrf_token=csrf_token, expected_status_int=400)\n            self.assertEqual(\n                generated_response['error'], 'This app cannot send emails.')\n\n\nclass UpdateUsernameHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests for updating usernames.\"\"\"\n\n    OLD_USERNAME = 'oldUsername'\n    NEW_USERNAME = 'newUsername'\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.OLD_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n    def test_update_username_with_none_new_username(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.OLD_USERNAME,\n                'new_username': None},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        error_msg = 'Missing key in handler args: new_username.'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_username_with_none_old_username(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': None,\n                'new_username': self.NEW_USERNAME},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        error_msg = 'Missing key in handler args: old_username.'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_username_with_non_string_new_username(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.OLD_USERNAME,\n                'new_username': 123},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(\n            response['error'], 'Schema validation for \\'new_username\\' failed:'\n            ' Expected string, received 123')\n\n    def test_update_username_with_non_string_old_username(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': 123,\n                'new_username': self.NEW_USERNAME},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        error_msg = (\n            'Schema validation for \\'old_username\\' failed: Expected'\n            ' string, received 123')\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_username_with_long_new_username(self) -> None:\n        long_username = 'a' * (constants.MAX_USERNAME_LENGTH + 1)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.OLD_USERNAME,\n                'new_username': long_username},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        error_msg = (\n            'Schema validation for \\'new_username\\' failed: Validation failed'\n            ': has_length_at_most ({\\'max_value\\': %s}) for object %s'\n            % (constants.MAX_USERNAME_LENGTH, long_username))\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_username_with_nonexistent_old_username(self) -> None:\n        non_existent_username = 'invalid'\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': non_existent_username,\n                'new_username': self.NEW_USERNAME},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(response['error'], 'Invalid username: invalid')\n\n    def test_update_username_with_new_username_already_taken(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.OLD_USERNAME,\n                'new_username': self.OLD_USERNAME},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(response['error'], 'Username already taken.')\n\n    def test_update_username(self) -> None:\n        user_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        old_fs = fs_services.GcsFileSystem(\n            feconf.ENTITY_TYPE_USER, self.OLD_USERNAME)\n        image_with_old_username = old_fs.get('profile_picture.png')\n\n        self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.OLD_USERNAME,\n                'new_username': self.NEW_USERNAME},\n            csrf_token=csrf_token)\n        self.assertEqual(user_services.get_username(user_id), self.NEW_USERNAME)\n\n        new_fs = fs_services.GcsFileSystem(\n            feconf.ENTITY_TYPE_USER, self.NEW_USERNAME)\n        image_with_new_username = new_fs.get('profile_picture.png')\n\n        self.assertEqual(image_with_old_username, image_with_new_username)\n\n    def test_update_username_creates_audit_model(self) -> None:\n        user_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        creation_time_in_millisecs = utils.get_current_time_in_millisecs()\n        mock_get_current_time_in_millisecs = lambda: creation_time_in_millisecs\n        # Since the UsernameChangeAuditModel's ID is formed from the user ID and\n        # a millisecond timestamp we need to make sure that\n        # get_current_time_in_millisecs returns the same value as we have saved\n        # into current_time_in_millisecs. If we don't force the same value via\n        # swap flakes can occur, since as the time flows the saved milliseconds\n        # can differ from the milliseconds saved into the\n        # UsernameChangeAuditModel's ID.\n        with self.swap(\n            utils, 'get_current_time_in_millisecs',\n            mock_get_current_time_in_millisecs):\n            self.put_json(\n                '/updateusernamehandler',\n                {\n                    'old_username': self.OLD_USERNAME,\n                    'new_username': self.NEW_USERNAME},\n                csrf_token=csrf_token)\n\n        self.assertTrue(\n            audit_models.UsernameChangeAuditModel.has_reference_to_user_id(\n                user_id))\n\n        model_id = '%s.%d' % (user_id, creation_time_in_millisecs)\n        username_change_audit_model = (\n            audit_models.UsernameChangeAuditModel.get(model_id))\n\n        self.assertEqual(username_change_audit_model.committer_id, user_id)\n        self.assertEqual(\n            username_change_audit_model.old_username, self.OLD_USERNAME)\n        self.assertEqual(\n            username_change_audit_model.new_username, self.NEW_USERNAME)\n\n    def test_profile_picture_is_missing_raises_error(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n        old_fs = fs_services.GcsFileSystem(\n            feconf.ENTITY_TYPE_USER, self.EDITOR_USERNAME)\n        image_png = old_fs.get('profile_picture.png')\n        old_fs.delete('profile_picture.png')\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.EDITOR_USERNAME,\n                'new_username': self.NEW_USERNAME},\n                csrf_token=csrf_token,\n                expected_status_int=400)\n\n        self.assertEqual(response['error'], (\n            'The user with username %s does not have a profile '\n            'picture with png extension.' % self.EDITOR_USERNAME))\n        old_fs.commit(\n            'profile_picture.png', image_png, mimetype='image/png')\n\n        old_fs.delete('profile_picture.webp')\n        response = self.put_json(\n            '/updateusernamehandler',\n            {\n                'old_username': self.EDITOR_USERNAME,\n                'new_username': self.NEW_USERNAME},\n                csrf_token=csrf_token,\n                expected_status_int=400)\n\n        self.assertEqual(response['error'], (\n            'The user with username %s does not have a profile '\n            'picture with webp extension.' % self.EDITOR_USERNAME))\n\n\nclass NumberOfDeletionRequestsHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests NumberOfDeletionRequestsHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n    def test_get_with_no_deletion_request_returns_zero(self) -> None:\n        response = self.get_json('/numberofdeletionrequestshandler')\n        self.assertEqual(response['number_of_pending_deletion_models'], 0)\n\n    def test_get_with_two_deletion_request_returns_two(self) -> None:\n        user_models.PendingDeletionRequestModel(\n            id='id1', email='id1@email.com').put()\n        user_models.PendingDeletionRequestModel(\n            id='id2', email='id2@email.com').put()\n\n        response = self.get_json('/numberofdeletionrequestshandler')\n        self.assertEqual(response['number_of_pending_deletion_models'], 2)\n\n\nclass VerifyUserModelsDeletedHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests VerifyUserModelsDeletedHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        self.admin_user_id = (\n            self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL))\n\n    def test_get_without_user_id_raises_error(self) -> None:\n        self.get_json(\n            '/verifyusermodelsdeletedhandler', expected_status_int=400)\n\n    def test_get_with_nonexistent_user_id_returns_true(self) -> None:\n        response = self.get_json(\n            '/verifyusermodelsdeletedhandler', params={'user_id': 'aaa'})\n        self.assertFalse(response['related_models_exist'])\n\n    def test_get_with_existing_user_id_returns_true(self) -> None:\n        response = self.get_json(\n            '/verifyusermodelsdeletedhandler',\n            params={'user_id': self.admin_user_id}\n        )\n        self.assertTrue(response['related_models_exist'])\n\n\nclass DeleteUserHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests DeleteUserHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.NEW_USER_EMAIL, self.NEW_USER_USERNAME)\n        self.new_user_id = self.get_user_id_from_email(self.NEW_USER_EMAIL)\n        self.signup(feconf.SYSTEM_EMAIL_ADDRESS, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(feconf.SYSTEM_EMAIL_ADDRESS, is_super_admin=True)\n        self.admin_user_id = self.get_user_id_from_email(\n            feconf.SYSTEM_EMAIL_ADDRESS)\n\n    def test_delete_without_user_id_raises_error(self) -> None:\n        self.delete_json(\n            '/deleteuserhandler',\n            params={'username': 'someusername'},\n            expected_status_int=400)\n\n    def test_delete_without_username_raises_error(self) -> None:\n        self.delete_json(\n            '/deleteuserhandler',\n            params={'user_id': 'aa'},\n            expected_status_int=400)\n\n    def test_delete_with_wrong_username_raises_error(self) -> None:\n        self.delete_json(\n            '/deleteuserhandler',\n            params={\n                'username': 'someusername',\n                'user_id': 'aa'\n            },\n            expected_status_int=400)\n\n    def test_delete_with_differing_user_id_and_username_raises_error(\n        self\n    ) -> None:\n        self.delete_json(\n            '/deleteuserhandler',\n            params={\n                'username': self.NEW_USER_USERNAME,\n                'user_id': self.admin_user_id\n            },\n            expected_status_int=400)\n\n    def test_delete_with_correct_user_id_andusername_returns_true(\n        self\n    ) -> None:\n        response = self.delete_json(\n            '/deleteuserhandler',\n            params={\n                'username': self.NEW_USER_USERNAME,\n                'user_id': self.new_user_id\n            })\n        self.assertTrue(response['success'])\n        self.assertIsNotNone(\n            wipeout_service.get_pending_deletion_request(self.new_user_id))\n\n\nclass UpdateBlogPostHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Tests UpdateBlogPostHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.NEW_USER_EMAIL, self.NEW_USER_USERNAME)\n        self.new_user_id = self.get_user_id_from_email(self.NEW_USER_EMAIL)\n        self.signup(feconf.SYSTEM_EMAIL_ADDRESS, self.CURRICULUM_ADMIN_USERNAME)\n        self.admin_user_id = self.get_user_id_from_email(\n            feconf.SYSTEM_EMAIL_ADDRESS)\n        self.signup(\n            self.BLOG_ADMIN_EMAIL, self.BLOG_ADMIN_USERNAME)\n        self.add_user_role(\n            self.BLOG_ADMIN_USERNAME, feconf.ROLE_ID_BLOG_ADMIN)\n        self.blog_admin_id = (\n            self.get_user_id_from_email(self.BLOG_ADMIN_EMAIL))\n\n        self.blog_post = blog_services.create_new_blog_post(self.blog_admin_id)\n        model = (\n            blog_models.BlogPostModel.get_by_id(self.blog_post.id))\n        model.title = 'sample title'\n        model.tags = ['news']\n        model.thumbnail_filename = 'image.png'\n        model.content = 'hello bloggers'\n        model.url_fragment = 'sample'\n        model.published_on = datetime.datetime.utcnow()\n        model.update_timestamps()\n        model.put()\n\n        self.login(feconf.SYSTEM_EMAIL_ADDRESS, is_super_admin=True)\n\n    def test_update_blog_post_without_blog_post_id_raises_error(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'author_username': 'someusername',\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n    def test_update_blog_post_without_author_username_raises_error(\n        self\n    ) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': 'sampleid',\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n    def test_update_blog_post_without_published_on_raises_error(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': 'sampleid',\n                'author_username': 'someusername'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n    def test_update_blog_post_with_wrong_username_raises_error(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': self.blog_post.id,\n                'author_username': 'someusername',\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n        error_msg = 'Invalid username: someusername'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_blog_post_with_wrong_blog_post_id_raises_error(\n        self\n    ) -> None:\n        csrf_token = self.get_new_csrf_token()\n        self.signup(self.BLOG_EDITOR_EMAIL, self.BLOG_EDITOR_USERNAME)\n        self.add_user_role(\n            self.BLOG_EDITOR_USERNAME, feconf.ROLE_ID_BLOG_POST_EDITOR)\n        self.login(feconf.SYSTEM_EMAIL_ADDRESS, is_super_admin=True)\n\n        self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': 'sampleid1234',\n                'author_username': self.BLOG_EDITOR_USERNAME,\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=404)\n\n    def test_update_blog_post_with_user_without_enough_rights(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': self.blog_post.id,\n                'author_username': self.NEW_USER_USERNAME,\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n\n        error_msg = 'User does not have enough rights to be blog post author.'\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_blog_post_with_invalid_date_format(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n        self.signup(self.BLOG_EDITOR_EMAIL, self.BLOG_EDITOR_USERNAME)\n        self.add_user_role(\n            self.BLOG_EDITOR_USERNAME, feconf.ROLE_ID_BLOG_POST_EDITOR)\n        self.login(feconf.SYSTEM_EMAIL_ADDRESS, is_super_admin=True)\n\n        response = self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': self.blog_post.id,\n                'author_username': self.BLOG_EDITOR_USERNAME,\n                'published_on': '05/09/20000'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=500)\n\n        error_msg = (\n            'time data \\'05/09/20000, 00:00:00:00\\' does not match' +\n            ' format \\'%m/%d/%Y, %H:%M:%S:%f\\'')\n        self.assertEqual(response['error'], error_msg)\n\n    def test_update_blog_post_with_correct_params(self) -> None:\n        csrf_token = self.get_new_csrf_token()\n        self.signup(self.BLOG_EDITOR_EMAIL, self.BLOG_EDITOR_USERNAME)\n        self.add_user_role(\n            self.BLOG_EDITOR_USERNAME, feconf.ROLE_ID_BLOG_POST_EDITOR)\n        self.login(feconf.SYSTEM_EMAIL_ADDRESS, is_super_admin=True)\n\n        self.put_json(\n            '/updateblogpostdatahandler',\n            {\n                'blog_post_id': self.blog_post.id,\n                'author_username': self.BLOG_EDITOR_USERNAME,\n                'published_on': '05/09/2000'\n            },\n            csrf_token=csrf_token)\n"
    },
    {
      "filename": "core/templates/pages/admin-page/activities-tab/admin-dev-mode-activities-tab.component.html",
      "content": "<div class=\"admin-dev-mode-activities-tab\">\n  <mat-card class=\"oppia-admin-page-card oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container ml-0\">\n      <h3>Reload a single exploration</h3>\n      <div *ngFor=\"let exploration of DEMO_EXPLORATIONS\"\n           class=\"row oppia-reload-exploration-row e2e-test-reload-exploration-row\">\n        <span class=\"col-lg-4 col-md-4 col-sm-4 e2e-test-reload-exploration-title\">\n          {{ exploration[1] }}\n        </span>\n        <span class=\"col-lg-2 col-md-2 col-sm-2 ml-auto\">\n          <button type=\"button\"\n                  class=\"btn btn-secondary e2e-test-reload-exploration-button float-right\"\n                  (click)=\"reloadExploration(exploration[0])\">\n          Reload\n          </button>\n        </span>\n      </div>\n      <button type=\"button\"\n              class=\"btn btn-secondary e2e-test-reload-all-explorations-button\"\n              (click)=\"reloadAllExplorations()\"\n              [disabled]=\"!reloadingAllExplorationPossible\">\n        Reload All Explorations\n      </button>\n    </div>\n  </mat-card>\n\n  <mat-card class=\"oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container\">\n      <h3>Generate dummy explorations</h3>\n      <p>\n        Use this form to generate dummy explorations with random titles.\n      </p>\n      <span class=\"row\">\n        <label for=\"label-target-explorations-to-generate\">Number of explorations to generate</label>\n        <input class=\"form-control form-inline oppia-form-inline\"\n               [(ngModel)]=\"numDummyExpsToGenerate\"\n               placeholder=\"Explorations to generate\" type=\"number\" min=\"0\"\n               id=\"label-target-explorations-to-generate\">\n        <label for=\"label-target-explorations-to-publish\">Number of explorations to publish</label>\n        <em *ngIf=\"numDummyExpsToGenerate\"\n            class=\"oppia-publish-exploration-text\">\n          (Publish {{ numDummyExpsToPublish }} out of {{ numDummyExpsToGenerate }} explorations)\n        </em>\n        <input class=\"form-control form-inline\"\n               [(ngModel)]=\"numDummyExpsToPublish\"\n               placeholder=\"Explorations to Publish\"\n               [disabled]=\"!numDummyExpsToGenerate\" type=\"number\" min=\"0\"\n               id=\"label-target-explorations-to-publish\">\n        <button type=\"button\"\n                class=\"btn btn-primary oppia-generate-exploration-text\"\n                (click)=\"generateDummyExplorations()\"\n                [disabled]=\"!numDummyExpsToGenerate\">\n          Generate Explorations\n        </button>\n      </span>\n    </div>\n  </mat-card>\n\n  <mat-card class=\"oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container ml-0\">\n      <h3>Reload a single collection</h3>\n      <div *ngFor=\"let collection of DEMO_COLLECTIONS\"\n           class=\"row oppia-reload-collection-row e2e-test-reload-collection-row\">\n        <span class=\"col-lg-4 col-md-4 col-sm-4 e2e-test-reload-collection-title\">\n          {{ collection[1] }}\n        </span>\n        <span class=\"col-lg-2 col-md-2 col-sm-2 ml-auto\">\n          <button type=\"button\"\n                  class=\"btn btn-secondary e2e-test-reload-collection-button float-right\"\n                  (click)=\"reloadCollection(collection[0])\">\n            Reload\n          </button>\n        </span>\n      </div>\n    </div>\n  </mat-card>\n\n  <mat-card class=\"oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container ml-0\">\n      <h3>Load dummy new structures data (only admins)</h3>\n      <div class=\"row\">\n        <span class=\"col-lg-8 col-md-8 col-sm-8\">\n          Loads 2 topics (one of which is empty), a story and three skills (two in a subtopic)\n          attached to the first topic and 3 questions in the first skill and 1 question in the second and third skills, respectively. 3 explorations\n          are loaded and associated with the story. Translation and skill question opportunties\n          are populated on the Contributor Dashboard.\n        </span>\n        <span class=\"col-lg-2 col-md-2 col-sm-2 ml-auto\">\n          <button type=\"button\"\n                  class=\"btn btn-secondary float-right load-dummy-new-structures-data-button\"\n                  (click)=\"loadNewStructuresData()\">\n            Load Data\n          </button>\n        </span>\n      </div>\n    </div>\n  </mat-card>\n\n  <mat-card class=\"oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container ml-0\">\n      <h3>Generate dummy skill with questions (only admins)</h3>\n      <div class=\"row\">\n        <span class=\"col-lg-4 col-md-4 col-sm-4\">\n          Generate a skill with 15 questions linked to it.\n        </span>\n        <span class=\"col-lg-2 col-md-2 col-sm-2 ml-auto\">\n          <button type=\"button\"\n                  class=\"btn btn-secondary float-right\"\n                  (click)=\"generateNewSkillData()\">\n            Generate Data\n          </button>\n        </span>\n      </div>\n    </div>\n  </mat-card>\n\n  <mat-card class=\"oppia-page-card oppia-long-text oppia-long-text-card\">\n    <div class=\"container ml-0\">\n      <h3>Generate a dummy math classroom</h3>\n      <div class=\"row\">\n        <span class=\"col-lg-8 col-md-8 col-sm-4\">\n          Generate a dummy math classroom with 5 published topics containing 1\n          skill per topic and 3 questions linked per skill.\n        </span>\n        <span class=\"col-lg-2 col-md-2 col-sm-2 ml-auto\">\n          <button type=\"button\"\n                  class=\"btn btn-secondary float-right load-dummy-math-classroom\"\n                  (click)=\"generateNewClassroom()\">\n            Generate Data\n          </button>\n        </span>\n      </div>\n    </div>\n  </mat-card>\n</div>\n\n<style>\n  .admin-dev-mode-activities-tab .oppia-admin-page-card .row {\n    margin-left: 0;\n  }\n  .admin-dev-mode-activities-tab .oppia-reload-collection-row, .oppia-reload-exploration-row {\n    margin-bottom: 5px;\n  }\n  .admin-dev-mode-activities-tab .oppia-long-text-card {\n    max-width: 700px;\n  }\n  .admin-dev-mode-activities-tab .oppia-form-inline {\n    margin-bottom: 5px;\n  }\n  .admin-dev-mode-activities-tab .oppia-publish-exploration-text {\n    font-size: smaller;\n  }\n  .admin-dev-mode-activities-tab .oppia-generate-exploration-text {\n    margin-top: 20px;\n  }\n</style>\n"
    },
    {
      "filename": "scripts/populate_sample_contributor_data_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2022 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Unit tests for scripts/populate_sample_data.py.\"\"\"\n\nfrom __future__ import annotations\n\nfrom core import feconf\nfrom core.controllers import base\nfrom core.domain import opportunity_services\nfrom core.domain import question_fetchers\nfrom core.domain import skill_services\nfrom core.domain import story_fetchers\nfrom core.domain import topic_fetchers\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.platform.auth import firebase_auth_services_test\nfrom core.tests import test_utils\nfrom scripts import populate_sample_contributor_data\n\nimport requests\nfrom typing import Dict, List, Optional\nimport webtest\n\nauth_services = models.Registry.import_auth_services()\n\n\nclass MockResponse:\n\n    def __init__(\n        self,\n        ok: bool = True,\n        json: Dict[str, str] | None = None,\n        status_code: int = 200,\n        reason: str = 'foo'\n    ) -> None:\n        if json is None:\n            json = {}\n        self.ok = ok\n        self.json_dict = json\n        self.status_code = status_code\n        self.reason = reason\n\n    def json(self) -> Dict[str, str]:\n        \"\"\"Get json dict or raise ValueError if json_dict not a dict.\"\"\"\n        if not isinstance(self.json_dict, dict):\n            raise ValueError('Payload not JSON.')\n        return self.json_dict\n\n\nclass SampleDataInitializerTests(test_utils.GenericTestBase):\n\n    def setUp(self) -> None:\n        self.AUTO_CREATE_DEFAULT_SUPERADMIN_USER = False\n        super().setUp()\n        self.firebase_sdk_stub = (\n            firebase_auth_services_test.FirebaseAdminSdkStub())\n        self.firebase_sdk_stub.install(self)\n        self.token_by_email: Dict[str, str] = {}\n        self.token_of_current_user: Optional[str] = None\n        self.initializer = (\n            populate_sample_contributor_data.SampleDataInitializer(\n                base_url=''))\n\n        self.initializer.csrf_token = self.get_new_csrf_token()\n\n        self.request_swap = self.swap(\n            self.initializer.session,\n            'request',\n            self._mock_request)\n\n        self.post_to_firebase_swap = self.swap_with_checks(\n            requests, 'post',\n            self._mock_post_to_firebase,\n            expected_args=[\n                (populate_sample_contributor_data.FIREBASE_SIGN_UP_URL,),\n                (populate_sample_contributor_data.FIREBASE_SIGN_UP_URL,),\n                (populate_sample_contributor_data.FIREBASE_SIGN_IN_URL,)\n            ]\n        )\n\n    def tearDown(self) -> None:\n        self.firebase_sdk_stub.uninstall()\n        self.logout()\n        super().tearDown()\n\n    def _mock_request(\n        self,\n        method: str,\n        url: str,\n        params: Dict[str, str] | None = None,\n        headers: Dict[str, str] | None = None\n    ) -> webtest.TestResponse:\n        \"\"\"Returns a mock response for the given request.\"\"\"\n        if method == 'GET':\n            if url == '/session_begin':\n                assert headers is not None\n                cur_token = headers.get('Authorization', '').strip('Bearer ')\n                for email, token in self.token_by_email.items():\n                    if token == cur_token:\n                        self._mock_login_as_admin(email)\n                        break\n            with self.swap(\n                base, 'load_template', test_utils.mock_load_template\n            ):\n                return self.testapp.get(url, params=params, headers=headers)\n        if method == 'POST':\n            return self.testapp.post(url, params=params, headers=headers)\n        if method == 'PUT':\n            return self.testapp.put(url, params=params, headers=headers)\n\n    def _mock_post_to_firebase(\n        self,\n        url: str,\n        **kwargs: Dict[str, str]\n    ) -> MockResponse | None:\n        \"\"\"Mock for the post request to Firebase. The request is for signing\n        up or signing in a user on Firebase.\n        \"\"\"\n        email = kwargs['json']['email']\n\n        if url == populate_sample_contributor_data.FIREBASE_SIGN_UP_URL:\n            auth_id = self.get_auth_id_from_email(email)\n            self.token_by_email[email] = (\n                self.firebase_sdk_stub.create_user(auth_id, email))\n\n        self.token_of_current_user = self.token_by_email[email]\n        return MockResponse(json={'idToken': self.token_of_current_user})\n\n    def _mock_login_as_admin(self, email: str) -> None:\n        \"\"\"Sets the environment variables to simulate a login of admin.\"\"\"\n        self.login(email, is_super_admin=True)\n\n    def test_populate_data_is_called(self) -> None:\n        populate_data_swap = self.swap_with_call_counter(\n            populate_sample_contributor_data.SampleDataInitializer,\n            'populate_data')\n        with populate_data_swap as call_counter:\n            populate_sample_contributor_data.main()\n\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_populate_data(self) -> None:\n        with self.request_swap, self.post_to_firebase_swap:\n            self.initializer.populate_data()\n\n        self._assert_sign_up_new_user(\n            populate_sample_contributor_data.SUPER_ADMIN_EMAIL,\n            populate_sample_contributor_data.SUPER_ADMIN_USERNAME)\n        self._assert_sign_up_new_user(\n            populate_sample_contributor_data.CONTRIBUTOR_EMAIL,\n            populate_sample_contributor_data.CONTRIBUTOR_USERNAME)\n        self._assert_user_roles(\n            populate_sample_contributor_data.SUPER_ADMIN_USERNAME,\n            populate_sample_contributor_data.SUPER_ADMIN_ROLES)\n        self._assert_can_submit_question_suggestions(\n            populate_sample_contributor_data.CONTRIBUTOR_USERNAME)\n        self._assert_generate_sample_new_structures_data()\n        self._assert_topics_in_classroom(\n            populate_sample_contributor_data.CLASSROOM_NAME)\n\n    def _assert_user_roles(self, username: str, roles: List[str]) -> None:\n        \"\"\"Asserts that the user has the given roles.\"\"\"\n        user_settings = user_services.get_user_settings_from_username(username)\n        assert user_settings is not None\n        self.assertEqual(\n            user_settings.roles, [feconf.ROLE_ID_FULL_USER] + roles)\n\n    def _assert_can_submit_question_suggestions(self, username: str) -> None:\n        \"\"\"Asserts that the user can submit question suggestions.\"\"\"\n        user_id = user_services.get_user_id_from_username(username)\n        assert user_id is not None\n        self.assertTrue(user_services.can_submit_question_suggestions(user_id))\n\n    def _assert_generate_sample_new_structures_data(self) -> None:\n        \"\"\"Asserts that the sample new structures data is generated.\"\"\"\n        topic_summaries = topic_fetchers.get_all_topic_summaries()\n        self.assertEqual(len(topic_summaries), 2)\n\n        topic = topic_fetchers.get_topic_by_name('Dummy Topic 1')\n        assert topic is not None\n        story_id = topic.canonical_story_references[0].story_id\n        self.assertIsNotNone(\n            story_fetchers.get_story_by_id(story_id, strict=False))\n\n        skill_summaries = skill_services.get_all_skill_summaries()\n        self.assertEqual(len(skill_summaries), 3)\n\n        questions, _ = (\n            question_fetchers.get_questions_and_skill_descriptions_by_skill_ids(\n                10,\n                [\n                    skill_summaries[0].id,\n                    skill_summaries[1].id,\n                    skill_summaries[2].id\n                ],\n                0)\n        )\n        self.assertEqual(len(questions), 5)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities('hi', '', None))\n        self.assertEqual(len(translation_opportunities), 3)\n\n    def _assert_topics_in_classroom(self, classroom_name: str) -> None:\n        \"\"\"Asserts that test topics are in the classroom.\"\"\"\n        classroom_dict = self.get_json(\n            '%s/%s' % (feconf.CLASSROOM_DATA_HANDLER, classroom_name))\n        topic_summaries = topic_fetchers.get_all_topic_summaries()\n        topic_summary_dicts_from_classroom = classroom_dict[\n            'topic_summary_dicts']\n        for index, topic_summary in enumerate(topic_summaries):\n            topic_summary_dict = dict(topic_summary.to_dict())\n            topic_summary_dict_from_classroom = (\n                topic_summary_dicts_from_classroom[index])\n            topic_summary_dict['is_published'] = (\n                topic_summary_dict_from_classroom['is_published'])\n            self.assertEqual(\n                topic_summary_dict, topic_summary_dict_from_classroom)\n\n    def _assert_sign_up_new_user(self, email: str, username: str) -> None:\n        \"\"\"Asserts that the function _mock_firebase_auth_create_user() is called\n        and a user with the given email and username is created.\n        \"\"\"\n        self.assertIsNotNone(self.firebase_sdk_stub.get_user_by_email(email))\n        user_settings = user_services.get_user_settings_from_email(email)\n        assert user_settings is not None\n        self.assertEqual(user_settings.username, username)\n"
    }
  ],
  "questions": [
    "Is this issue solved or not?.if not solved can you please assign it to me.i will do my best if i can possible to do",
    "### Describe the bug\r\n\r\nIn the math classroom page (develop branch), the topic tile is not working i.e., on clicking the topic for navigating into the topic viewer page an error message is presented in the console.\r\n\r\n### URL of the page where the issue is observed.\r\n\r\n`/learn/math`\r\n\r\n### Steps To Reproduce\r\n\r\nSteps to repro:\r\n1. Create profile and add admin rights\r\n2. Load dummy topic from the admin page\r\n3. Add the topic ID into classroom config in the Config tab under /admin\r\n4. Navigate to the math classroom page at /learn/math\r\n5. Click on the topic\r\n\r\n### Expected Behavior\r\n\r\n\r\n1. The console error should not be presented\r\n2. Should be able to click on the topic tile in the classroom and navigate to the topic viewer page.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://github.com/oppia/oppia/assets/57531197/d52e3fc3-a1a9-4b4e-91e5-e36a27d5c447\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Tips for developers\r\n\r\nBefore tackling the bug, please use `git bisect` (see https://git-scm.com/docs/git-bisect) to investigate which PR caused it (you only need to go back as far as commit https://github.com/oppia/oppia/commits/9a334e9). If you find the PR, leave a comment on this issue pointing to it, or just say that it happened before commit 9a334e9 if you could reproduce it there. This will help us fix the issue by reverting the faulty PR.\r\n\r\nAlso, if this is your first issue, please make sure to follow https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue and https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up before claiming it. Thanks!"
  ],
  "golden_answers": [
    "Hi @mahmoodshariff123 I have created the PR. You can take another good-first-issue from [here](https://github.com/oppia/oppia/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)\r\n\r\nThanks",
    "This issue arises because the dummy topics created when clicking on \"Activities > Load dummy new structures data\" in the Admin page are malformed. They don't have the necessary data (e.g. thumbnail, meta tag content, etc.)\n\nTo fix this, investigate the method _load_dummy_new_structures_data() in core/controllers/admin.py. Go to /admin and generate a topic according to the instructions in the issue description, Then visit the topic that was generated (which you can find from the /topics-and-skills-dashboard page). Your fix is correct once the generated topic does not contain any warnings.\n\nIn order to claim this issue, please show a screenshot of the generated topic that shows that it doesn't have any warnings, and explain the changes that you made in order to remove each warning. Thanks!"
  ],
  "questions_generated": [
    "What is the main issue described in the oppia_oppia repository related to the topic tile on the math classroom page?",
    "Which URL is affected by the bug described in the issue?",
    "What are the steps to reproduce the bug in the math classroom page?",
    "What is the expected behavior when clicking on a topic tile in the math classroom page?",
    "What is the root cause of the issue with the topic tile clickability?",
    "Which function in the codebase is suggested for investigation to fix the issue with the dummy topics?",
    "What tool is recommended for developers to use before tackling the bug, and what is its purpose?",
    "What should developers do to claim the issue according to the guidelines?"
  ],
  "golden_answers_generated": [
    "The main issue is that the topic tile on the math classroom page is not clickable, and clicking on it results in a console error instead of navigating to the topic viewer page.",
    "The bug is observed on the '/learn/math' URL.",
    "The steps to reproduce the bug include: 1) Creating a profile and adding admin rights, 2) Loading a dummy topic from the admin page, 3) Adding the topic ID into classroom config in the Config tab under /admin, 4) Navigating to the math classroom page at /learn/math, and 5) Clicking on the topic.",
    "The expected behavior is that no console error should be presented, and the user should be able to click on the topic tile to navigate to the topic viewer page.",
    "The issue arises because the dummy topics created via the admin page are malformed, lacking necessary data such as thumbnail and meta tag content, which prevents proper navigation.",
    "The function suggested for investigation is '_load_dummy_new_structures_data()' in 'core/controllers/admin.py'.",
    "Developers are recommended to use 'git bisect', which helps in identifying which pull request (PR) caused the issue by checking out different commits and finding the introduction point of the bug.",
    "Developers should provide a screenshot of the generated topic that shows it doesn't have any warnings and explain the changes made to remove each warning in order to claim the issue."
  ]
}