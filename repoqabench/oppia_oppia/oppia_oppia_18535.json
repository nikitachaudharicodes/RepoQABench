{
  "repo_name": "oppia_oppia",
  "issue_id": "18535",
  "issue_description": "# [Feature Request]: Drop flags for checkpoint_celebration and end_chapter_celebration\n\n### Is your feature request related to a problem? Please describe.\r\n\r\nCertain features have been completed and we aren't going to turn them off, so we should get rid of their feature flags per the last step in the [guidance for launching a feature](https://github.com/oppia/oppia/wiki/Launching-new-features). \r\n\r\n### Describe the solution you'd like\r\n\r\nRemove the flags for the following features, and update the code to assume that they are permanently turned on:\r\n\r\n- checkpoint_celebration\r\n- end_chapter_celebration\r\n\r\n### Describe alternatives you've considered\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_",
  "issue_comments": [
    {
      "id": 2212455134,
      "user": "Code-eat-sleep-include",
      "body": "Hi @seanlip, could you please assign me this issue?"
    },
    {
      "id": 2246996544,
      "user": "seanlip",
      "body": "Hi @Code-eat-sleep-include, sorry for the late reply, I was out the past few weeks. \r\n\r\nPer the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 2390581510,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003  \r\nI hope you're doing well. I wanted to bring up the removal of the feature flags for checkpoint_celebration and end_chapter_celebration. Since both features are now fully implemented and will remain permanently enabled, I propose that we address the issue by commenting out the associated functions. This will help clean up the codebase and make it clear that these features are now active by default.\r\n\r\nPlease let me know if this solution works for you or if there are any other considerations to keep in mind.\r\n\r\nI would appreciate it if I could be assigned this issue to implement the changes.\r\n\r\nThank you for your time and consideration.\r\n<img width=\"986\" alt=\"Screenshot 2024-10-03 at 11 21 22 AM\" src=\"https://github.com/user-attachments/assets/55bb0134-c3f9-4a9c-9be0-adb84124c581\">\r\n"
    },
    {
      "id": 2390798926,
      "user": "HardikGoyal2003",
      "body": "Hey @KartikSuryavanshi Can you please list the name of the files that you will be changing and refer to this [docs](https://github.com/oppia/oppia/wiki/Launching-new-features) for more information. Thanks!"
    },
    {
      "id": 2390840091,
      "user": "seanlip",
      "body": "@KartikSuryavanshi Also please note that you shouldn't be commenting out code. We don't do that because the code becomes \"dead code\" and is hard to maintain -- it's fine to delete it entirely.\r\n\r\nPlease also:\r\n\r\n(a) delete all instances of the flags and the code that relies on them, not just the small piece you demonstrated,\r\n(b) show a video that demonstrates that the functionality gated by the flags works, even after your local changes to remove the flags themselves.\r\n\r\nThanks!"
    },
    {
      "id": 2391356367,
      "user": "KartikSuryavanshi",
      "body": "Thank you for the clarification! I’ll proceed with fully deleting the checkpoint_celebration and end_chapter_celebration flags and all related code instead of commenting them out.\r\n\r\nI’ll also share a video demonstrating that the functionality works after the changes and provide a list of the affected files.\r\n\r\nThanks again for your guidance!"
    },
    {
      "id": 2394951227,
      "user": "KartikSuryavanshi",
      "body": "Hey @seanlip @HardikGoyal2003,\r\nI hope this message finds you well! I wanted to inform you of my plan to remove all instances related to the checkpoint_celebration and end_chapter_celebration features. Specifically, I will be updating the following files:-\r\n\r\n1)feature-status-summary-model.ts\r\n2)feature_flags_list.py\r\n3)ReleaseCoordinatorPage.js\r\n\r\nI will completely remove all entries and any associated logic that relies on these feature flags. Please let me know if you have any suggestions or concerns regarding this approach.\r\n\r\nThank you!\r\n\r\n"
    },
    {
      "id": 2395310520,
      "user": "seanlip",
      "body": "Thanks @KartikSuryavanshi. We'll wait for your video demonstrating the changes. "
    },
    {
      "id": 2401834534,
      "user": "KartikSuryavanshi",
      "body": "Hey @seanlip, I’ve resolved the issue by removing the checkpoint_celebration and end_chapter_celebration feature flags, but I’ve only made changes to the ReleaseCoordinator page. When I tried updating the feature-status-summary-model.ts and feature_flag_list.py files, the exploration stopped working. It seems that the code might still depend on these flags for some critical functionalities. For instance, removing these flags without ensuring the logic has proper alternatives may affect navigation or state transitions within the exploration. Could you take a look and suggest improvements?\r\n\r\nhttps://github.com/user-attachments/assets/7de5dd3b-38e4-4f18-9d0d-9427b6ead788\r\n\r\n"
    },
    {
      "id": 2402953359,
      "user": "seanlip",
      "body": "@KartikSuryavanshi You will need to update all places in the codebase where these flags occur, not just the release coordinator page. I suggest that you trace through the frontend and backend code to get a better understanding of how these flags are used. The behaviour post-deletion should exactly match the behaviour when the flags are turned on.\r\n\r\n"
    },
    {
      "id": 2402983306,
      "user": "KartikSuryavanshi",
      "body": "Thanks for the heads-up! I’ll make sure to update all instances where these flags occur,and I’ll also check how the flags actually work both in the frontend and backend."
    },
    {
      "id": 2405492143,
      "user": "KartikSuryavanshi",
      "body": "Hey @seanlip,\r\n\r\nI dug deeper into the connection between the frontend and backend, and after my analysis, it seems we can safely delete the flags from both ReleaseCoordinatorPage.js and feature_flag_list.py—except for one specific part of the backend. However, when I tried removing the flags from feature-status-summary.model.ts, it completely broke the frontend, throwing the error seen in the attached screenshot.\r\n<img width=\"1344\" alt=\"Screenshot 2024-10-10 at 9 13 49 PM\" src=\"https://github.com/user-attachments/assets/44a4ceb5-f6a1-4f92-92cc-b202f1c2bd14\">\r\nIt appears that feature-status-summary.model.ts is tightly coupled to the frontend, and removing the end_chapter_celebration and checkpoint_celebration flags from this file causes a cascading failure in the frontend. The model references these flags in multiple places, and they may be required for frontend validation or feature toggles.\r\n I recommend following a gradual deletion approach: mark these feature flags as deprecated, log warnings when they are accessed, and gradually update the codebase to handle the removal over time. This should prevent sudden errors and ensure all instances are properly removed.\r\n\r\nWhat do you think of this phased approach?\"\r\n"
    },
    {
      "id": 2408835510,
      "user": "HardikGoyal2003",
      "body": "Hey @KartikSuryavanshi Sorry for the delayed response, gradual; deletion won't be a good approach because deleting some part of the feature flag will break both the functionality's old one as well as the new one, and I don't think so only these two files you mentioned will have the flag references, there will be more files from which you need to remove the flag, can you check again for all references.\r\n\r\n**Note:** From next time onwards please try to paste the stacktrace if you are referring to some error, this can provide a more detailed analysis."
    },
    {
      "id": 2408871941,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003 Thanks for your response and insights. I understand that gradual deletion isn't advisable since it may disrupt both the old and new functionalities tied to the feature flag.\r\n\r\nIn the image below, you can see where the flags are used, specifically in three files:\r\n\r\n1)ReleaseCoordinator page\r\n2)feature-status-summary-model.ts\r\n3)feature_flags_list.py\r\n\r\n<img width=\"525\" alt=\"Screenshot 2024-10-13 at 1 16 34 PM\" src=\"https://github.com/user-attachments/assets/7b742db1-dc6b-4a6e-8521-cccf8f3cb49b\">\r\n\r\nI'm currently facing issues when I attempt to delete the part of the code mentioned below in the feature_flags_list.py and feature-status-summary-model.ts. Could you please guide me on what might be causing the problem?\r\n<img width=\"782\" alt=\"Screenshot 2024-10-13 at 1 28 14 PM\" src=\"https://github.com/user-attachments/assets/3b02f3a8-7cc5-496f-b1dc-d569de5fcf16\">\r\n<img width=\"616\" alt=\"Screenshot 2024-10-13 at 1 29 05 PM\" src=\"https://github.com/user-attachments/assets/681ee2de-908c-49d1-b94e-d25f9123deeb\">\r\n"
    },
    {
      "id": 2408878307,
      "user": "HardikGoyal2003",
      "body": "@KartikSuryavanshi Check for ``EndChapterCelebration`` and references you will find more files."
    },
    {
      "id": 2408885394,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003 Got it!! Thanx I will check on them..."
    },
    {
      "id": 2410198576,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003, I have come across many files that seem to be associated with the removal of these feature flags. Could you provide guidance on which specific files should be modified or deleted? Should I remove all related files for a complete resolution, or just focus on certain areas?\r\n<img width=\"1428\" alt=\"Screenshot 2024-10-14 at 12 28 57 PM\" src=\"https://github.com/user-attachments/assets/efc7341d-014e-4e72-80e1-e0d6fa467b78\">\r\n"
    },
    {
      "id": 2410633227,
      "user": "HardikGoyal2003",
      "body": "Hey @KartikSuryavanshi this requires analyzing the code and properly understanding the feature flag workflow from backend to frontend so that you can remove the code safely. Figuring out what to change is a major part of this issue. If this is too difficult, it's fine to pick a different issue."
    },
    {
      "id": 2410760671,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003,\r\n\r\nThanks for the heads-up! I understand that this will require some careful analysis. I’ll give it a try and see what I can figure out. If I run into any issues, I’ll reach out for help.\r\n\r\n"
    },
    {
      "id": 2411469415,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003 \r\nI have successfully made the necessary changes to remove the feature flags for CheckpointCelebration and EndChapterCelebration. The code has been updated, and I have tested it to ensure it works flawlessly without errors.\r\nCould you please assign this issue to me?Additionally, I have implemented the video part of the feature, which is included below .\r\n\r\nhttps://github.com/user-attachments/assets/be5f5889-3476-4976-ad46-9f213b265751\r\n\r\n"
    },
    {
      "id": 2411502861,
      "user": "HardikGoyal2003",
      "body": "@KartikSuryavanshi Hmmm why it didn't show the end_chapter_celebration feature?"
    },
    {
      "id": 2411718099,
      "user": "KartikSuryavanshi",
      "body": "Hey @HardikGoyal2003     \r\nIt do show the end_chapter_celebration feature ,Please take a look at the screenshot below for reference.\r\n<img width=\"948\" alt=\"Screenshot 2024-10-14 at 9 50 53 PM\" src=\"https://github.com/user-attachments/assets/d986a2ef-33a5-41ca-97d5-86a424dac566\">\r\n"
    },
    {
      "id": 2411726871,
      "user": "HardikGoyal2003",
      "body": "Hey @seanlip, can you verify this or do we have the Figma files that demonstrate this functionality?"
    },
    {
      "id": 2412950000,
      "user": "seanlip",
      "body": "@HardikGoyal2003 @KartikSuryavanshi This isn't the end chapter celebration popup. You can verify this in 5 minutes by reading the code. If you search for the given message (in the blue box) in the codebase, you will see that it corresponds to I18N_EXPLORATION_STARTING_FROM_BEGINNING, which does not relate to the flag that was removed. \r\n\r\nDoing a similar search for EndChapterCelebration will show you which part of the code is gated by it and what is expected to happen (e.g. it will lead you to triggerCelebratoryAnimation()).\r\n\r\nIn the future, please try to do some simple analysis like this and present what you have tried, before asking for verification (or, worse, claiming that the code \"works flawlessly\")."
    },
    {
      "id": 2412968918,
      "user": "KartikSuryavanshi",
      "body": "Hi @seanlip ,\r\n\r\nI apologize for the confusion and any inconvenience caused by my earlier message. I now realize I should have done a more thorough analysis before claiming the code was flawless. I’ll review the I18N_EXPLORATION_STARTING_FROM_BEGINNING message and follow your guidance regarding the EndChapterCelebration feature and triggerCelebratoryAnimation().\r\n\r\nI appreciate your patience and will ensure to be more careful in the future. Thank you for your support and feedback."
    },
    {
      "id": 2744012291,
      "user": "HardikGoyal2003",
      "body": "Closing this as completed by https://github.com/oppia/oppia/pull/22182"
    }
  ],
  "text_context": "# [Feature Request]: Drop flags for checkpoint_celebration and end_chapter_celebration\n\n### Is your feature request related to a problem? Please describe.\r\n\r\nCertain features have been completed and we aren't going to turn them off, so we should get rid of their feature flags per the last step in the [guidance for launching a feature](https://github.com/oppia/oppia/wiki/Launching-new-features). \r\n\r\n### Describe the solution you'd like\r\n\r\nRemove the flags for the following features, and update the code to assume that they are permanently turned on:\r\n\r\n- checkpoint_celebration\r\n- end_chapter_celebration\r\n\r\n### Describe alternatives you've considered\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_\n\nHi @seanlip, could you please assign me this issue?\n\nHi @Code-eat-sleep-include, sorry for the late reply, I was out the past few weeks. \r\n\r\nPer the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\nHey @HardikGoyal2003  \r\nI hope you're doing well. I wanted to bring up the removal of the feature flags for checkpoint_celebration and end_chapter_celebration. Since both features are now fully implemented and will remain permanently enabled, I propose that we address the issue by commenting out the associated functions. This will help clean up the codebase and make it clear that these features are now active by default.\r\n\r\nPlease let me know if this solution works for you or if there are any other considerations to keep in mind.\r\n\r\nI would appreciate it if I could be assigned this issue to implement the changes.\r\n\r\nThank you for your time and consideration.\r\n<img width=\"986\" alt=\"Screenshot 2024-10-03 at 11 21 22 AM\" src=\"https://github.com/user-attachments/assets/55bb0134-c3f9-4a9c-9be0-adb84124c581\">\r\n\n\nHey @KartikSuryavanshi Can you please list the name of the files that you will be changing and refer to this [docs](https://github.com/oppia/oppia/wiki/Launching-new-features) for more information. Thanks!\n\n@KartikSuryavanshi Also please note that you shouldn't be commenting out code. We don't do that because the code becomes \"dead code\" and is hard to maintain -- it's fine to delete it entirely.\r\n\r\nPlease also:\r\n\r\n(a) delete all instances of the flags and the code that relies on them, not just the small piece you demonstrated,\r\n(b) show a video that demonstrates that the functionality gated by the flags works, even after your local changes to remove the flags themselves.\r\n\r\nThanks!\n\nThank you for the clarification! I’ll proceed with fully deleting the checkpoint_celebration and end_chapter_celebration flags and all related code instead of commenting them out.\r\n\r\nI’ll also share a video demonstrating that the functionality works after the changes and provide a list of the affected files.\r\n\r\nThanks again for your guidance!\n\nHey @seanlip @HardikGoyal2003,\r\nI hope this message finds you well! I wanted to inform you of my plan to remove all instances related to the checkpoint_celebration and end_chapter_celebration features. Specifically, I will be updating the following files:-\r\n\r\n1)feature-status-summary-model.ts\r\n2)feature_flags_list.py\r\n3)ReleaseCoordinatorPage.js\r\n\r\nI will completely remove all entries and any associated logic that relies on these feature flags. Please let me know if you have any suggestions or concerns regarding this approach.\r\n\r\nThank you!\r\n\r\n\n\nThanks @KartikSuryavanshi. We'll wait for your video demonstrating the changes. \n\nHey @seanlip, I’ve resolved the issue by removing the checkpoint_celebration and end_chapter_celebration feature flags, but I’ve only made changes to the ReleaseCoordinator page. When I tried updating the feature-status-summary-model.ts and feature_flag_list.py files, the exploration stopped working. It seems that the code might still depend on these flags for some critical functionalities. For instance, removing these flags without ensuring the logic has proper alternatives may affect navigation or state transitions within the exploration. Could you take a look and suggest improvements?\r\n\r\nhttps://github.com/user-attachments/assets/7de5dd3b-38e4-4f18-9d0d-9427b6ead788\r\n\r\n\n\n@KartikSuryavanshi You will need to update all places in the codebase where these flags occur, not just the release coordinator page. I suggest that you trace through the frontend and backend code to get a better understanding of how these flags are used. The behaviour post-deletion should exactly match the behaviour when the flags are turned on.\r\n\r\n\n\nThanks for the heads-up! I’ll make sure to update all instances where these flags occur,and I’ll also check how the flags actually work both in the frontend and backend.\n\nHey @seanlip,\r\n\r\nI dug deeper into the connection between the frontend and backend, and after my analysis, it seems we can safely delete the flags from both ReleaseCoordinatorPage.js and feature_flag_list.py—except for one specific part of the backend. However, when I tried removing the flags from feature-status-summary.model.ts, it completely broke the frontend, throwing the error seen in the attached screenshot.\r\n<img width=\"1344\" alt=\"Screenshot 2024-10-10 at 9 13 49 PM\" src=\"https://github.com/user-attachments/assets/44a4ceb5-f6a1-4f92-92cc-b202f1c2bd14\">\r\nIt appears that feature-status-summary.model.ts is tightly coupled to the frontend, and removing the end_chapter_celebration and checkpoint_celebration flags from this file causes a cascading failure in the frontend. The model references these flags in multiple places, and they may be required for frontend validation or feature toggles.\r\n I recommend following a gradual deletion approach: mark these feature flags as deprecated, log warnings when they are accessed, and gradually update the codebase to handle the removal over time. This should prevent sudden errors and ensure all instances are properly removed.\r\n\r\nWhat do you think of this phased approach?\"\r\n\n\nHey @KartikSuryavanshi Sorry for the delayed response, gradual; deletion won't be a good approach because deleting some part of the feature flag will break both the functionality's old one as well as the new one, and I don't think so only these two files you mentioned will have the flag references, there will be more files from which you need to remove the flag, can you check again for all references.\r\n\r\n**Note:** From next time onwards please try to paste the stacktrace if you are referring to some error, this can provide a more detailed analysis.\n\nHey @HardikGoyal2003 Thanks for your response and insights. I understand that gradual deletion isn't advisable since it may disrupt both the old and new functionalities tied to the feature flag.\r\n\r\nIn the image below, you can see where the flags are used, specifically in three files:\r\n\r\n1)ReleaseCoordinator page\r\n2)feature-status-summary-model.ts\r\n3)feature_flags_list.py\r\n\r\n<img width=\"525\" alt=\"Screenshot 2024-10-13 at 1 16 34 PM\" src=\"https://github.com/user-attachments/assets/7b742db1-dc6b-4a6e-8521-cccf8f3cb49b\">\r\n\r\nI'm currently facing issues when I attempt to delete the part of the code mentioned below in the feature_flags_list.py and feature-status-summary-model.ts. Could you please guide me on what might be causing the problem?\r\n<img width=\"782\" alt=\"Screenshot 2024-10-13 at 1 28 14 PM\" src=\"https://github.com/user-attachments/assets/3b02f3a8-7cc5-496f-b1dc-d569de5fcf16\">\r\n<img width=\"616\" alt=\"Screenshot 2024-10-13 at 1 29 05 PM\" src=\"https://github.com/user-attachments/assets/681ee2de-908c-49d1-b94e-d25f9123deeb\">\r\n\n\n@KartikSuryavanshi Check for ``EndChapterCelebration`` and references you will find more files.\n\nHey @HardikGoyal2003 Got it!! Thanx I will check on them...\n\nHey @HardikGoyal2003, I have come across many files that seem to be associated with the removal of these feature flags. Could you provide guidance on which specific files should be modified or deleted? Should I remove all related files for a complete resolution, or just focus on certain areas?\r\n<img width=\"1428\" alt=\"Screenshot 2024-10-14 at 12 28 57 PM\" src=\"https://github.com/user-attachments/assets/efc7341d-014e-4e72-80e1-e0d6fa467b78\">\r\n\n\nHey @KartikSuryavanshi this requires analyzing the code and properly understanding the feature flag workflow from backend to frontend so that you can remove the code safely. Figuring out what to change is a major part of this issue. If this is too difficult, it's fine to pick a different issue.\n\nHey @HardikGoyal2003,\r\n\r\nThanks for the heads-up! I understand that this will require some careful analysis. I’ll give it a try and see what I can figure out. If I run into any issues, I’ll reach out for help.\r\n\r\n\n\nHey @HardikGoyal2003 \r\nI have successfully made the necessary changes to remove the feature flags for CheckpointCelebration and EndChapterCelebration. The code has been updated, and I have tested it to ensure it works flawlessly without errors.\r\nCould you please assign this issue to me?Additionally, I have implemented the video part of the feature, which is included below .\r\n\r\nhttps://github.com/user-attachments/assets/be5f5889-3476-4976-ad46-9f213b265751\r\n\r\n\n\n@KartikSuryavanshi Hmmm why it didn't show the end_chapter_celebration feature?\n\nHey @HardikGoyal2003     \r\nIt do show the end_chapter_celebration feature ,Please take a look at the screenshot below for reference.\r\n<img width=\"948\" alt=\"Screenshot 2024-10-14 at 9 50 53 PM\" src=\"https://github.com/user-attachments/assets/d986a2ef-33a5-41ca-97d5-86a424dac566\">\r\n\n\nHey @seanlip, can you verify this or do we have the Figma files that demonstrate this functionality?\n\n@HardikGoyal2003 @KartikSuryavanshi This isn't the end chapter celebration popup. You can verify this in 5 minutes by reading the code. If you search for the given message (in the blue box) in the codebase, you will see that it corresponds to I18N_EXPLORATION_STARTING_FROM_BEGINNING, which does not relate to the flag that was removed. \r\n\r\nDoing a similar search for EndChapterCelebration will show you which part of the code is gated by it and what is expected to happen (e.g. it will lead you to triggerCelebratoryAnimation()).\r\n\r\nIn the future, please try to do some simple analysis like this and present what you have tried, before asking for verification (or, worse, claiming that the code \"works flawlessly\").\n\nHi @seanlip ,\r\n\r\nI apologize for the confusion and any inconvenience caused by my earlier message. I now realize I should have done a more thorough analysis before claiming the code was flawless. I’ll review the I18N_EXPLORATION_STARTING_FROM_BEGINNING message and follow your guidance regarding the EndChapterCelebration feature and triggerCelebratoryAnimation().\r\n\r\nI appreciate your patience and will ensure to be more careful in the future. Thank you for your support and feedback.\n\nClosing this as completed by https://github.com/oppia/oppia/pull/22182",
  "pr_link": "https://github.com/oppia/oppia/pull/22182",
  "code_context": [
    {
      "filename": "core/feature_flag_list.py",
      "content": "# coding: utf-8\n#\n# Copyright 2020 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Platform feature list.\"\"\"\n\nfrom __future__ import annotations\n\nimport enum\n\nfrom core.domain import feature_flag_domain\n\nfrom typing import List\n\n\nclass FeatureNames(enum.Enum):\n    \"\"\"Enum for Feature names.\"\"\"\n\n    DUMMY_FEATURE_FLAG_FOR_E2E_TESTS = 'dummy_feature_flag_for_e2e_tests'\n    END_CHAPTER_CELEBRATION = 'end_chapter_celebration'\n    CHECKPOINT_CELEBRATION = 'checkpoint_celebration'\n    CONTRIBUTOR_DASHBOARD_ACCOMPLISHMENTS = (\n        'contributor_dashboard_accomplishments')\n    ANDROID_BETA_LANDING_PAGE = 'android_beta_landing_page'\n    BLOG_PAGES = 'blog_pages'\n    DIAGNOSTIC_TEST = 'diagnostic_test'\n    SERIAL_CHAPTER_LAUNCH_CURRICULUM_ADMIN_VIEW = (\n        'serial_chapter_launch_curriculum_admin_view')\n    SERIAL_CHAPTER_LAUNCH_LEARNER_VIEW = (\n        'serial_chapter_launch_learner_view')\n    SHOW_REDESIGNED_LEARNER_DASHBOARD = (\n        'show_redesigned_learner_dashboard')\n    SHOW_TRANSLATION_SIZE = 'show_translation_size'\n    SHOW_FEEDBACK_UPDATES_IN_PROFILE_PIC_DROPDOWN = (\n        'show_feedback_updates_in_profile_pic_dropdown')\n    CD_ADMIN_DASHBOARD_NEW_UI = 'cd_admin_dashboard_new_ui'\n    IS_IMPROVEMENTS_TAB_ENABLED = 'is_improvements_tab_enabled'\n    LEARNER_GROUPS_ARE_ENABLED = 'learner_groups_are_enabled'\n    NEW_LESSON_PLAYER = 'new_lesson_player'\n    ADD_VOICEOVER_WITH_ACCENT = 'add_voiceover_with_accent'\n    CD_ALLOW_UNDOING_TRANSLATION_REVIEW = 'cd_allow_undoing_translation_review'\n    ENABLE_VOICEOVER_CONTRIBUTION = 'enable_voiceover_contribution'\n    AUTO_UPDATE_EXP_VOICE_ARTIST_LINK = 'auto_update_exp_voice_artist_link'\n    EXPLORATION_EDITOR_CAN_MODIFY_TRANSLATIONS = (\n        'exploration_editor_can_modify_translations')\n    EXPLORATION_EDITOR_CAN_TAG_MISCONCEPTIONS = (\n        'exploration_editor_can_tag_misconceptions')\n    ENABLE_MULTIPLE_CLASSROOMS = 'enable_multiple_classrooms'\n    REDESIGNED_TOPIC_VIEWER_PAGE = 'redesigned_topic_viewer_page'\n    AUTOMATIC_VOICEOVER_REGENERATION_FROM_EXP = (\n        'automatic_voiceover_regeneration_from_exp')\n    LABEL_ACCENT_TO_VOICE_ARTIST = 'label_accent_to_voice_artist'\n\n\n# Names of feature objects defined in FeatureNames should be added\n# to one of the following lists:\n#   - DEV_FEATURES_LIST\n#   - TEST_FEATURES_LIST\n#   - PROD_FEATURES_LIST\n# based on the their stages. Features not added in the lists above won't be\n# available to be enabled via the admin page.\n#\n# The stage of features indicates the maturity of\n# features being developed. Features are in one of the three stages: 'dev',\n# 'test' or 'prod'. In general, 'dev' features are in develop and can only be\n# enabled in dev environment. 'test' features are completed in development but\n# still requires further testing or approvals, which can be enabled for QA\n# testers. 'prod' feature has been fully tested so that it can be enabled in the\n# production environment.\n\n# Names of features in dev stage, the corresponding feature flag instances must\n# be in dev stage otherwise it will cause a test error in the backend test.\nDEV_FEATURES_LIST = [\n    FeatureNames.SHOW_FEEDBACK_UPDATES_IN_PROFILE_PIC_DROPDOWN,\n    FeatureNames.SHOW_TRANSLATION_SIZE,\n    FeatureNames.NEW_LESSON_PLAYER,\n    FeatureNames.REDESIGNED_TOPIC_VIEWER_PAGE,\n    FeatureNames.AUTOMATIC_VOICEOVER_REGENERATION_FROM_EXP\n]\n\n# Names of features in test stage, the corresponding feature flag instances must\n# be in test stage otherwise it will cause a test error in the backend test.\nTEST_FEATURES_LIST: List[FeatureNames] = [\n    FeatureNames.CD_ADMIN_DASHBOARD_NEW_UI,\n    FeatureNames.SERIAL_CHAPTER_LAUNCH_CURRICULUM_ADMIN_VIEW,\n    FeatureNames.SERIAL_CHAPTER_LAUNCH_LEARNER_VIEW,\n    FeatureNames.CD_ALLOW_UNDOING_TRANSLATION_REVIEW,\n    FeatureNames.ENABLE_MULTIPLE_CLASSROOMS,\n    FeatureNames.SHOW_REDESIGNED_LEARNER_DASHBOARD\n]\n\n# Names of features in prod stage, the corresponding feature flag instances must\n# be in prod stage otherwise it will cause a test error in the backend test.\nPROD_FEATURES_LIST: List[FeatureNames] = [\n    FeatureNames.DUMMY_FEATURE_FLAG_FOR_E2E_TESTS,\n    FeatureNames.IS_IMPROVEMENTS_TAB_ENABLED,\n    FeatureNames.LEARNER_GROUPS_ARE_ENABLED,\n    FeatureNames.ENABLE_VOICEOVER_CONTRIBUTION,\n    FeatureNames.AUTO_UPDATE_EXP_VOICE_ARTIST_LINK,\n    FeatureNames.ADD_VOICEOVER_WITH_ACCENT,\n    FeatureNames.DIAGNOSTIC_TEST,\n    FeatureNames.EXPLORATION_EDITOR_CAN_MODIFY_TRANSLATIONS,\n    FeatureNames.EXPLORATION_EDITOR_CAN_TAG_MISCONCEPTIONS,\n    FeatureNames.LABEL_ACCENT_TO_VOICE_ARTIST\n]\n\n# Names of features that should not be used anymore, e.g. features that are\n# completed and no longer gated because their functionality is permanently\n# built into the codebase.\nDEPRECATED_FEATURE_NAMES: List[FeatureNames] = [\n    FeatureNames.ANDROID_BETA_LANDING_PAGE,\n    FeatureNames.BLOG_PAGES,\n    FeatureNames.CONTRIBUTOR_DASHBOARD_ACCOMPLISHMENTS,\n    FeatureNames.END_CHAPTER_CELEBRATION,\n    FeatureNames.CHECKPOINT_CELEBRATION,\n]\n\nFEATURE_FLAG_NAME_TO_DESCRIPTION_AND_FEATURE_STAGE = {\n    FeatureNames.DUMMY_FEATURE_FLAG_FOR_E2E_TESTS.value: (\n        (\n            'This is a dummy feature flag for the e2e tests.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.DIAGNOSTIC_TEST.value: (\n        (\n            'This flag is for the diagnostic test functionality.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.SERIAL_CHAPTER_LAUNCH_CURRICULUM_ADMIN_VIEW.value: (\n        (\n            'This flag is for serial chapter launch feature and making changes '\n            'only in the curriculum admin view.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.SERIAL_CHAPTER_LAUNCH_LEARNER_VIEW.value: (\n        (\n            'This flag is for serial chapter launch feature and making changes '\n            'only in the learner view.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.SHOW_REDESIGNED_LEARNER_DASHBOARD.value: (\n        (\n            'This flag is to show redesigned learner dashboard.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.SHOW_TRANSLATION_SIZE.value: (\n        (\n            'This flag is to show translation size on translation cards in '\n            'contributor dashboard.',\n            feature_flag_domain.ServerMode.DEV\n        )\n    ),\n    FeatureNames.SHOW_FEEDBACK_UPDATES_IN_PROFILE_PIC_DROPDOWN.value: (\n        (\n            'This flag is to show feedback updates in the '\n            'profile pic drop-down menu.',\n            feature_flag_domain.ServerMode.DEV\n        )\n    ),\n    FeatureNames.CD_ADMIN_DASHBOARD_NEW_UI.value: (\n        (\n            'This flag is to show new contributor admin dashboard.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.IS_IMPROVEMENTS_TAB_ENABLED.value: (\n        (\n            'Exposes the Improvements Tab for creators in the exploration '\n            'editor.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.LEARNER_GROUPS_ARE_ENABLED.value: (\n        (\n            'Enable learner groups feature',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.NEW_LESSON_PLAYER.value: (\n        (\n            'This flag is to enable the exploration player redesign.',\n            feature_flag_domain.ServerMode.DEV\n        )\n    ),\n    FeatureNames.ADD_VOICEOVER_WITH_ACCENT.value: (\n        (\n            'The flag allows voice artists to add voiceovers in a specific '\n            'accent for the given language.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.CD_ALLOW_UNDOING_TRANSLATION_REVIEW.value: (\n        (\n            'This flag allows translation reviewers to undo translation '\n            'suggestion review on the contributor dashboard.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.ENABLE_VOICEOVER_CONTRIBUTION.value: (\n        (\n            'The flag controls whether voiceover contributions from the '\n            'voiceover tab of the exploration editor page is enabled or '\n            'disabled during voiceover migration.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.AUTO_UPDATE_EXP_VOICE_ARTIST_LINK.value: (\n        (\n            'The flag allows auto-updating of the exploration voice artists '\n            'link model after an exploration update.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.EXPLORATION_EDITOR_CAN_MODIFY_TRANSLATIONS.value: (\n        (\n            'This flag allows exploration editors to promptly update '\n            'translations of content they are editing in the exploration '\n            'editor page.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.EXPLORATION_EDITOR_CAN_TAG_MISCONCEPTIONS.value: (\n        (\n            'This flag allows exploration editors to view a list of '\n            'misconceptions and tag answer groups with misconceptions '\n            'for a curated exploration.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    ),\n    FeatureNames.ENABLE_MULTIPLE_CLASSROOMS.value: (\n        (\n            'The flag enables flow for multiple classrooms '\n            'and makes the classrooms page available to learners.',\n            feature_flag_domain.ServerMode.TEST\n        )\n    ),\n    FeatureNames.REDESIGNED_TOPIC_VIEWER_PAGE.value: (\n        (\n            'This flag activates the redesigned topic viewer page'\n            'and makes it accessible to learners.',\n            feature_flag_domain.ServerMode.DEV\n        )\n    ),\n    FeatureNames.AUTOMATIC_VOICEOVER_REGENERATION_FROM_EXP.value: (\n        (\n            'The flag enables the automatic regeneration of voiceovers '\n            'directly from the exploration editor page.',\n            feature_flag_domain.ServerMode.DEV\n        )\n    ),\n    FeatureNames.LABEL_ACCENT_TO_VOICE_ARTIST.value: (\n        (\n            'The flag enables the voice artist accent labeling feature '\n            'on the voiceover admin page.',\n            feature_flag_domain.ServerMode.PROD\n        )\n    )\n}\n"
    },
    {
      "filename": "core/templates/components/checkpoint-celebration-modal/checkpoint-celebration-modal.component.spec.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the checkpoint celebration modal component.\n */\n\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\nimport {\n  ComponentFixture,\n  waitForAsync,\n  TestBed,\n  fakeAsync,\n  tick,\n} from '@angular/core/testing';\nimport {EventEmitter} from '@angular/core';\nimport {TranslateService} from '@ngx-translate/core';\nimport {MockTranslateService} from 'components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';\nimport {CheckpointCelebrationModalComponent} from './checkpoint-celebration-modal.component';\nimport {CheckpointCelebrationUtilityService} from 'pages/exploration-player-page/services/checkpoint-celebration-utility.service';\nimport {ReadOnlyExplorationBackendApiService} from 'domain/exploration/read-only-exploration-backend-api.service';\nimport {ContextService} from 'services/context.service';\nimport {I18nLanguageCodeService} from 'services/i18n-language-code.service';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {PlayerPositionService} from 'pages/exploration-player-page/services/player-position.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {RecordedVoiceovers} from 'domain/exploration/recorded-voiceovers.model';\nimport {InteractionObjectFactory} from 'domain/exploration/InteractionObjectFactory';\nimport {AudioTranslationLanguageService} from 'pages/exploration-player-page/services/audio-translation-language.service';\nimport {StateObjectsBackendDict} from 'domain/exploration/StatesObjectFactory';\nimport {ExplorationPlayerStateService} from 'pages/exploration-player-page/services/exploration-player-state.service';\n\nclass MockCheckpointCelebrationUtilityService {\n  isOnCheckpointedState = false;\n  openLessonInformationModalEmitter = new EventEmitter<void>();\n\n  getStateListForCheckpointMessages(\n    statesbackendDict: StateObjectsBackendDict,\n    initStateName: string\n  ): string[] {\n    return [];\n  }\n\n  getCheckpointMessage(\n    completedCheckpointCount: number,\n    totalCheckpointCount: number\n  ): string {\n    return '';\n  }\n\n  getCheckpointTitle(): string {\n    return '';\n  }\n\n  setIsOnCheckpointedState(isOnCheckpointedState: boolean) {\n    this.isOnCheckpointedState = isOnCheckpointedState;\n  }\n\n  getIsOnCheckpointedState(): boolean {\n    return this.isOnCheckpointedState;\n  }\n\n  openLessonInformationModal() {\n    this.openLessonInformationModalEmitter.emit();\n  }\n}\n\nconst dummyExplorationBackendDict = {\n  init_state_name: 'Introduction',\n  param_changes: [],\n  param_specs: {},\n  states: {\n    Introduction: {\n      classifier_model_id: null,\n      content: {\n        content_id: 'content',\n        html: '',\n      },\n      recorded_voiceovers: {\n        voiceovers_mapping: {\n          content: {},\n          default_outcome: {},\n        },\n      },\n      interaction: {\n        answer_groups: [],\n        confirmed_unclassified_answers: [],\n        customization_args: {\n          buttonText: {\n            value: 'Continue',\n          },\n        },\n        default_outcome: {\n          dest: 'End State',\n          dest_if_really_stuck: null,\n          feedback: {\n            content_id: 'default_outcome',\n            html: '',\n          },\n          param_changes: [],\n          labelled_as_correct: true,\n          refresher_exploration_id: null,\n          missing_prerequisite_skill_id: null,\n        },\n        hints: [],\n        solution: null,\n        id: 'Continue',\n      },\n      linked_skill_id: null,\n      param_changes: [],\n      solicit_answer_details: false,\n      card_is_checkpoint: true,\n    },\n    'End State': {\n      classifier_model_id: null,\n      content: {\n        content_id: 'content',\n        html: '',\n      },\n      recorded_voiceovers: {\n        voiceovers_mapping: {\n          content: {},\n          default_outcome: {},\n        },\n      },\n      interaction: {\n        answer_groups: [],\n        confirmed_unclassified_answers: [],\n        customization_args: {\n          recommendedExplorationIds: {\n            value: [],\n          },\n        },\n        default_outcome: null,\n        hints: [],\n        solution: null,\n        id: 'EndExploration',\n      },\n      linked_skill_id: null,\n      param_changes: [],\n      solicit_answer_details: false,\n      card_is_checkpoint: false,\n    },\n  },\n  title: 'Dummy Title',\n  language_code: 'en',\n  objective: 'Dummy Objective',\n  next_content_id_index: 4,\n};\n\nconst dummyExplorationMetadata = {\n  title: 'Dummy Title',\n  category: 'Dummy Category',\n  objective: 'Dummy Objective',\n  language_code: 'en',\n  tags: [],\n  blurb: 'Dummy Blurb',\n  author_notes: 'Dummy Author Notes',\n  states_schema_version: 50,\n  init_state_name: 'Introduction',\n  param_specs: {},\n  param_changes: [],\n  auto_tts_enabled: false,\n  edits_allowed: true,\n};\n\nconst dummyExplorationBackendResponse = {\n  can_edit: true,\n  exploration: dummyExplorationBackendDict,\n  exploration_metadata: dummyExplorationMetadata,\n  exploration_id: '0',\n  is_logged_in: true,\n  session_id: 'dummy_session_id',\n  version: 1,\n  preferred_audio_language_code: 'en',\n  preferred_language_codes: ['en'],\n  auto_tts_enabled: false,\n  record_playthrough_probability: 1.0,\n  draft_change_list_id: 1,\n  has_viewed_lesson_info_modal_once: false,\n  furthest_reached_checkpoint_exp_version: 0,\n  furthest_reached_checkpoint_state_name: '',\n  most_recently_reached_checkpoint_state_name: 'Introduction',\n  most_recently_reached_checkpoint_exp_version: 0,\n  displayable_language_codes: [],\n};\n\ndescribe('Checkpoint celebration modal component', function () {\n  let component: CheckpointCelebrationModalComponent;\n  let fixture: ComponentFixture<CheckpointCelebrationModalComponent>;\n  let checkpointCelebrationUtilityService: CheckpointCelebrationUtilityService;\n  let readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService;\n  let contextService: ContextService;\n  let i18nLanguageCodeService: I18nLanguageCodeService;\n  let playerPositionService: PlayerPositionService;\n  let windowDimensionsService: WindowDimensionsService;\n  let urlInterpolationService: UrlInterpolationService;\n  let interactionObjectFactory: InteractionObjectFactory;\n  let audioTranslationLanguageService: AudioTranslationLanguageService;\n  let explorationPlayerStateService: ExplorationPlayerStateService;\n  let dummyStateCard: StateCard;\n  let mockResizeEmitter: EventEmitter<void>;\n\n  beforeEach(waitForAsync(() => {\n    mockResizeEmitter = new EventEmitter();\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [CheckpointCelebrationModalComponent],\n      providers: [\n        ReadOnlyExplorationBackendApiService,\n        ContextService,\n        I18nLanguageCodeService,\n        PlayerPositionService,\n        UrlInterpolationService,\n        InteractionObjectFactory,\n        AudioTranslationLanguageService,\n        ExplorationPlayerStateService,\n        {\n          provide: WindowDimensionsService,\n          useValue: {\n            getWidth: () => 1369,\n            getResizeEvent: () => mockResizeEmitter,\n          },\n        },\n        {\n          provide: CheckpointCelebrationUtilityService,\n          useClass: MockCheckpointCelebrationUtilityService,\n        },\n        {\n          provide: TranslateService,\n          useClass: MockTranslateService,\n        },\n      ],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    checkpointCelebrationUtilityService = TestBed.inject(\n      CheckpointCelebrationUtilityService\n    );\n    readOnlyExplorationBackendApiService = TestBed.inject(\n      ReadOnlyExplorationBackendApiService\n    );\n    contextService = TestBed.inject(ContextService);\n    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);\n    playerPositionService = TestBed.inject(PlayerPositionService);\n    windowDimensionsService = TestBed.inject(WindowDimensionsService);\n    urlInterpolationService = TestBed.inject(UrlInterpolationService);\n    interactionObjectFactory = TestBed.inject(InteractionObjectFactory);\n    audioTranslationLanguageService = TestBed.inject(\n      AudioTranslationLanguageService\n    );\n    explorationPlayerStateService = TestBed.inject(\n      ExplorationPlayerStateService\n    );\n    fixture = TestBed.createComponent(CheckpointCelebrationModalComponent);\n    component = fixture.componentInstance;\n\n    dummyStateCard = StateCard.createNewCard(\n      'State 2',\n      '<p>Content</p>',\n      '<interaction></interaction>',\n      interactionObjectFactory.createFromBackendDict({\n        id: 'TextInput',\n        answer_groups: [\n          {\n            outcome: {\n              dest: 'State',\n              dest_if_really_stuck: null,\n              feedback: {\n                html: '',\n                content_id: 'This is a new feedback text',\n              },\n              refresher_exploration_id: 'test',\n              missing_prerequisite_skill_id: 'test_skill_id',\n              labelled_as_correct: true,\n              param_changes: [],\n            },\n            rule_specs: [],\n            training_data: [],\n            tagged_skill_misconception_id: '',\n          },\n        ],\n        default_outcome: {\n          dest: 'Hola',\n          dest_if_really_stuck: null,\n          feedback: {\n            content_id: '',\n            html: '',\n          },\n          labelled_as_correct: true,\n          param_changes: [],\n          refresher_exploration_id: 'test',\n          missing_prerequisite_skill_id: 'test_skill_id',\n        },\n        confirmed_unclassified_answers: [],\n        customization_args: {\n          rows: {\n            value: true,\n          },\n          placeholder: {\n            value: 1,\n          },\n          catchMisspellings: {\n            value: false,\n          },\n        },\n        hints: [],\n        solution: {\n          answer_is_exclusive: true,\n          correct_answer: 'test_answer',\n          explanation: {\n            content_id: '2',\n            html: 'test_explanation1',\n          },\n        },\n      }),\n      RecordedVoiceovers.createEmpty(),\n      'content',\n      audioTranslationLanguageService\n    );\n  });\n\n  it('should initialize the component', fakeAsync(() => {\n    spyOn(contextService, 'getExplorationId').and.returnValue('expId');\n    spyOn(\n      urlInterpolationService,\n      'getStaticCopyrightedImageUrl'\n    ).and.returnValue('dummyStaticImageUrl');\n    spyOn(\n      readOnlyExplorationBackendApiService,\n      'fetchExplorationAsync'\n    ).and.returnValue(Promise.resolve(dummyExplorationBackendResponse));\n    spyOn(\n      checkpointCelebrationUtilityService,\n      'getStateListForCheckpointMessages'\n    ).and.returnValue(['Introduction', 'End State']);\n    spyOn(component, 'subscribeToCardChangeEmitter');\n    spyOn(component, 'subscribeToWindowResizeEmitter');\n    spyOn(component, 'setFadeInDelaysForCheckpointNodes');\n    spyOn(windowDimensionsService, 'getWidth').and.callThrough();\n\n    expect(component.shouldDisplayFullScaleMessage).toBe(true);\n\n    component.ngOnInit();\n    tick();\n\n    expect(component.explorationId).toEqual('expId');\n    expect(component.oppiaAvatarImageUrl).toEqual('dummyStaticImageUrl');\n    expect(\n      readOnlyExplorationBackendApiService.fetchExplorationAsync\n    ).toHaveBeenCalledWith('expId', null);\n    expect(component.hasViewedLessonInfoOnce).toEqual(false);\n    expect(component.mostRecentlyReachedCheckpointStateName).toEqual(\n      'Introduction'\n    );\n    expect(component.orderedCheckpointList).toEqual([\n      'Introduction',\n      'End State',\n    ]);\n    expect(\n      checkpointCelebrationUtilityService.getStateListForCheckpointMessages\n    ).toHaveBeenCalled();\n    expect(component.totalNumberOfCheckpoints).toEqual(2);\n    expect(component.checkpointStatusArray.length).toEqual(2);\n    expect(component.setFadeInDelaysForCheckpointNodes).toHaveBeenCalled();\n    expect(component.currentStateName).toEqual('Introduction');\n    expect(component.subscribeToCardChangeEmitter).toHaveBeenCalled();\n    expect(windowDimensionsService.getWidth).toHaveBeenCalled();\n    expect(component.shouldDisplayFullScaleMessage).toEqual(false);\n    expect(component.subscribeToWindowResizeEmitter).toHaveBeenCalled();\n  }));\n\n  it('should unsubscribe upon component destruction', () => {\n    spyOn(component.directiveSubscriptions, 'unsubscribe');\n\n    component.ngOnDestroy();\n\n    expect(component.directiveSubscriptions.unsubscribe).toHaveBeenCalled();\n  });\n\n  it('should execute callback when newCard emitter emits', fakeAsync(() => {\n    spyOn(playerPositionService.onNewCardOpened, 'subscribe').and.callThrough();\n    spyOn(checkpointCelebrationUtilityService, 'setIsOnCheckpointedState');\n    spyOn(component, 'dismissMessage');\n    spyOn(component, 'dismissMiniMessage');\n    spyOn(component, 'checkIfCheckpointMessageIsToBeTriggered');\n    component.miniMessageTooltipIsShown = true;\n    component.messageModalIsShown = false;\n    component.subscribeToCardChangeEmitter();\n\n    playerPositionService.onNewCardOpened.emit(dummyStateCard);\n    tick();\n\n    expect(\n      checkpointCelebrationUtilityService.setIsOnCheckpointedState\n    ).toHaveBeenCalledWith(false);\n    expect(component.dismissMiniMessage).toHaveBeenCalled();\n    tick(2300);\n    expect(\n      component.checkIfCheckpointMessageIsToBeTriggered\n    ).toHaveBeenCalled();\n\n    component.miniMessageTooltipIsShown = false;\n    component.messageModalIsShown = true;\n\n    playerPositionService.onNewCardOpened.emit(dummyStateCard);\n    tick();\n\n    expect(component.dismissMessage).toHaveBeenCalled();\n    tick(2300);\n    expect(\n      component.checkIfCheckpointMessageIsToBeTriggered\n    ).toHaveBeenCalledTimes(2);\n\n    component.miniMessageTooltipIsShown = false;\n    component.messageModalIsShown = false;\n\n    playerPositionService.onNewCardOpened.emit(dummyStateCard);\n    tick();\n\n    expect(\n      component.checkIfCheckpointMessageIsToBeTriggered\n    ).toHaveBeenCalledTimes(3);\n  }));\n\n  it('should execute callback when window resize emitter emits', () => {\n    expect(component.shouldDisplayFullScaleMessage).toEqual(true);\n\n    component.subscribeToWindowResizeEmitter();\n    mockResizeEmitter.emit();\n\n    expect(component.shouldDisplayFullScaleMessage).toEqual(false);\n  });\n\n  it('should check if checkpoint message is to be triggered', () => {\n    component.orderedCheckpointList = [\n      'Introduction',\n      'MostRecentlyReachedCheckpointStateName',\n      'NewStateName',\n      'EndState',\n    ];\n    spyOn(\n      checkpointCelebrationUtilityService,\n      'getCheckpointMessage'\n    ).and.returnValue('test_checkpoint_message');\n    spyOn(\n      checkpointCelebrationUtilityService,\n      'getCheckpointTitle'\n    ).and.returnValue('test_checkpoint_title');\n    spyOn(component, 'generateCheckpointStatusArray');\n    spyOn(checkpointCelebrationUtilityService, 'setIsOnCheckpointedState');\n    spyOn(component, 'triggerStandardMessage');\n    spyOn(component, 'triggerMiniMessage');\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(true);\n    component.currentStateName = 'Introduction';\n    component.mostRecentlyReachedCheckpointStateName =\n      'MostRecentlyReachedCheckpointStateName';\n\n    component.checkIfCheckpointMessageIsToBeTriggered('Introduction');\n    component.checkIfCheckpointMessageIsToBeTriggered(\n      'MostRecentlyReachedCheckpointStateName'\n    );\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).not.toHaveBeenCalled();\n\n    component.checkIfCheckpointMessageIsToBeTriggered('NonCheckpointStateName');\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).not.toHaveBeenCalled();\n\n    component.currentStateName = 'Introduction';\n    component.hasViewedLessonInfoOnce = false;\n\n    component.checkIfCheckpointMessageIsToBeTriggered('NewStateName');\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).not.toHaveBeenCalled();\n    expect(component.hasViewedLessonInfoOnce).toEqual(true);\n\n    component.currentStateName = 'Introduction';\n    component.hasViewedLessonInfoOnce = true;\n    component.shouldDisplayFullScaleMessage = true;\n\n    component.checkIfCheckpointMessageIsToBeTriggered('NewStateName');\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).toHaveBeenCalled();\n    expect(component.translatedCurrentCheckpointMessage).toEqual(\n      'test_checkpoint_message'\n    );\n    expect(component.translatedCurrentCheckpointMessageTitle).toEqual(\n      'test_checkpoint_title'\n    );\n    expect(component.generateCheckpointStatusArray).toHaveBeenCalled();\n    expect(component.triggerStandardMessage).toHaveBeenCalled();\n\n    component.currentStateName = 'Introduction';\n    component.hasViewedLessonInfoOnce = true;\n    component.shouldDisplayFullScaleMessage = false;\n    component.translatedCurrentCheckpointMessage = null;\n    component.translatedCurrentCheckpointMessageTitle = null;\n\n    component.checkIfCheckpointMessageIsToBeTriggered('NewStateName');\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).toHaveBeenCalledTimes(2);\n    expect(component.translatedCurrentCheckpointMessage).toEqual(\n      'test_checkpoint_message'\n    );\n    expect(component.translatedCurrentCheckpointMessageTitle).toEqual(\n      'test_checkpoint_title'\n    );\n    expect(component.generateCheckpointStatusArray).toHaveBeenCalledTimes(2);\n    expect(component.triggerMiniMessage).toHaveBeenCalled();\n  });\n\n  it('should not trigger checkpoint message if not in story mode', () => {\n    component.orderedCheckpointList = [\n      'Introduction',\n      'MostRecentlyReachedCheckpointStateName',\n      'NewStateName',\n      'EndState',\n    ];\n    component.currentStateName = 'Introduction';\n    component.mostRecentlyReachedCheckpointStateName =\n      'MostRecentlyReachedCheckpointStateName';\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(false);\n    spyOn(checkpointCelebrationUtilityService, 'getCheckpointMessage');\n\n    component.checkIfCheckpointMessageIsToBeTriggered('NewStateName');\n\n    expect(\n      checkpointCelebrationUtilityService.getCheckpointMessage\n    ).not.toHaveBeenCalled();\n  });\n\n  it('should generate checkpoint status array', () => {\n    component.checkpointNodesAreVisible = false;\n    component.checkpointStatusArray = new Array(8);\n    component.currentCheckpointPosition = 4;\n    component.totalNumberOfCheckpoints = 8;\n\n    component.generateCheckpointStatusArray();\n\n    expect(component.checkpointStatusArray).toEqual([\n      'completed',\n      'completed',\n      'completed',\n      'completed',\n      'in-progress',\n      'incomplete',\n      'incomplete',\n      'incomplete',\n    ]);\n    expect(component.checkpointNodesAreVisible).toEqual(true);\n  });\n\n  it('should get completed progress bar width', () => {\n    component.messageModalIsShown = false;\n\n    expect(component.getCompletedProgressBarWidth()).toEqual(0);\n\n    component.currentCheckpointPosition = 0;\n    component.totalNumberOfCheckpoints = 5;\n    component.messageModalIsShown = true;\n\n    expect(component.getCompletedProgressBarWidth()).toEqual(0);\n\n    component.currentCheckpointPosition = 2;\n\n    expect(component.getCompletedProgressBarWidth()).toEqual(37.5);\n  });\n\n  it('should set fade-in delays for checkpoint nodes', () => {\n    component.totalNumberOfCheckpoints = 5;\n    component.checkpointNodeFadeInDelays = new Array(5);\n\n    component.setFadeInDelaysForCheckpointNodes();\n\n    const expectedDelays = [2.2, 2.5, 2.8, 3.1, 3.4];\n\n    component.checkpointNodeFadeInDelays.forEach((delay, index) => {\n      expect(delay)\n        .withContext(`fade-in delay for checkpoint ${index}`)\n        .toBeCloseTo(expectedDelays[index]);\n    });\n  });\n\n  it('should trigger standard message', fakeAsync(() => {\n    component.messageModalIsShown = false;\n    component.checkpointNodesAreVisible = true;\n    spyOn(component, 'resetTimer');\n\n    component.triggerStandardMessage();\n\n    expect(component.messageModalIsShown).toEqual(true);\n    expect(component.resetTimer).toHaveBeenCalled();\n\n    tick(15100);\n\n    expect(component.messageModalIsShown).toEqual(false);\n    expect(component.checkpointNodesAreVisible).toEqual(false);\n  }));\n\n  it('should trigger mini message', fakeAsync(() => {\n    component.miniMessageTooltipIsShown = false;\n\n    component.triggerMiniMessage();\n\n    expect(component.miniMessageTooltipIsShown).toEqual(true);\n\n    tick(6500);\n\n    expect(component.miniMessageTooltipIsShown).toEqual(false);\n  }));\n\n  it('should dismiss message', fakeAsync(() => {\n    let mockSetTimeout = setTimeout(() => {});\n    component.autoMessageDismissalTimeout = mockSetTimeout;\n    component.messageModalIsShown = true;\n    component.messageModalIsDismissed = false;\n    component.checkpointNodesAreVisible = true;\n\n    component.dismissMessage();\n\n    expect(component.messageModalIsShown).toEqual(false);\n    expect(component.messageModalIsDismissed).toEqual(true);\n    expect(component.checkpointNodesAreVisible).toEqual(false);\n\n    tick(2500);\n\n    expect(component.messageModalIsDismissed).toEqual(false);\n  }));\n\n  it('should dismiss mini message', fakeAsync(() => {\n    component.miniMessageTooltipIsShown = true;\n    component.miniMessageTooltipIsDismissed = false;\n\n    component.dismissMiniMessage();\n\n    expect(component.miniMessageTooltipIsShown).toEqual(false);\n    expect(component.miniMessageTooltipIsDismissed).toEqual(true);\n\n    tick(2500);\n\n    expect(component.miniMessageTooltipIsDismissed).toEqual(false);\n  }));\n\n  it('should reset timer', () => {\n    component.checkpointTimerTemplateRef = {\n      nativeElement: {\n        // This throws \"Type\n        // '{ strokeDasharray: string; strokeDashoffset: string; }' is missing\n        // the following properties from type 'CSSStyleDeclaration':\n        // accentColor, alignContent, alignItems, alignSelf, and 457 more.\".\n        // We need to suppress this error because only these values are\n        // needed for testing and providing a value for every single property is\n        // unnecessary.\n        // @ts-expect-error\n        style: {\n          strokeDashoffset: '',\n          transitionDuration: '',\n        },\n      },\n    };\n    const rtlSpy = spyOn(\n      i18nLanguageCodeService,\n      'isLanguageRTL'\n    ).and.returnValue(false);\n    component.shouldDisplayFullScaleMessage = false;\n\n    component.resetTimer();\n\n    expect(component.checkpointTimer).toBeNull();\n\n    component.shouldDisplayFullScaleMessage = true;\n\n    component.resetTimer();\n\n    expect(rtlSpy).toHaveBeenCalled();\n    expect(component.checkpointTimer).toEqual({\n      style: {\n        strokeDashoffset: '10',\n        transitionDuration: '12.14s',\n      },\n    });\n\n    rtlSpy.and.returnValue(true);\n\n    component.resetTimer();\n\n    expect(rtlSpy).toHaveBeenCalledTimes(2);\n    expect(component.checkpointTimer).toEqual({\n      style: {\n        strokeDashoffset: '-10',\n        transitionDuration: '12.14s',\n      },\n    });\n  });\n\n  it('should open lesson info modal', () => {\n    spyOn(checkpointCelebrationUtilityService, 'openLessonInformationModal');\n\n    component.openLessonInfoModal();\n\n    expect(\n      checkpointCelebrationUtilityService.openLessonInformationModal\n    ).toHaveBeenCalled();\n  });\n\n  it('should determine if current language is RTL', () => {\n    const isLanguageRTLSpy = spyOn(\n      i18nLanguageCodeService,\n      'isCurrentLanguageRTL'\n    ).and.returnValue(true);\n\n    expect(component.isLanguageRTL()).toBe(true);\n\n    isLanguageRTLSpy.and.returnValue(false);\n\n    expect(component.isLanguageRTL()).toBe(false);\n  });\n});\n"
    },
    {
      "filename": "core/templates/components/checkpoint-celebration-modal/checkpoint-celebration-modal.component.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the checkpoint celebration modal.\n */\n\nimport {\n  Component,\n  OnInit,\n  OnDestroy,\n  ViewChild,\n  ElementRef,\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport {ContextService} from 'services/context.service';\nimport {I18nLanguageCodeService} from 'services/i18n-language-code.service';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {\n  ReadOnlyExplorationBackendApiService,\n  ReadOnlyExplorationBackendDict,\n} from 'domain/exploration/read-only-exploration-backend-api.service';\nimport {CheckpointCelebrationUtilityService} from 'pages/exploration-player-page/services/checkpoint-celebration-utility.service';\nimport {PlayerPositionService} from 'pages/exploration-player-page/services/player-position.service';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {ExplorationPlayerStateService} from 'pages/exploration-player-page/services/exploration-player-state.service';\n\nimport './checkpoint-celebration-modal.component.css';\n\nconst CHECKPOINT_STATUS_INCOMPLETE = 'incomplete';\nconst CHECKPOINT_STATUS_COMPLETED = 'completed';\nconst CHECKPOINT_STATUS_IN_PROGRESS = 'in-progress';\n\nconst MESSAGE_MODAL_APPROX_TRIGGER_AND_DISMISSAL_DURATION_MS = 2200;\nconst MESSAGE_MODAL_APPROX_COMPLETE_ANIMATION_DURATION_MS = 15000;\nconst MINI_MESSAGE_MODAL_APPROX_COMPLETE_ANIMATION_DURATION_MS = 6500;\nconst SCREEN_WIDTH_FOR_STANDARD_SIZED_MESSAGE_MODAL_CUTOFF_PX = 1370;\n\n@Component({\n  selector: 'oppia-checkpoint-celebration-modal',\n  templateUrl: './checkpoint-celebration-modal.component.html',\n  styleUrls: ['./checkpoint-celebration-modal.component.css'],\n})\nexport class CheckpointCelebrationModalComponent implements OnInit, OnDestroy {\n  @ViewChild('checkpointCelebrationModalTimer')\n  checkpointTimerTemplateRef!: ElementRef<SVGPolylineElement>;\n\n  // These properties below are initialized using Angular lifecycle hooks\n  // where we need to do non-null assertion. For more information see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  explorationId!: string;\n  checkpointStatusArray!: string[];\n  oppiaAvatarImageUrl!: string;\n  checkpointNodeFadeInDelays!: number[];\n  orderedCheckpointList!: string[];\n  checkpointStatusArrayPlaceholder!: string[];\n  checkpointTimer: SVGPolylineElement | null = null;\n  directiveSubscriptions = new Subscription();\n  exploration: ReadOnlyExplorationBackendDict | undefined;\n  hasViewedLessonInfoOnce: boolean | undefined;\n  currentStateName: string | undefined;\n  mostRecentlyReachedCheckpointStateName: string | null = null;\n  translatedCurrentCheckpointMessage: string | null = null;\n  translatedCurrentCheckpointMessageTitle: string | null = null;\n  currentCheckpointPosition: number = 0;\n  totalNumberOfCheckpoints: number = 0;\n  checkpointNodesAreVisible: boolean = false;\n  messageModalIsShown: boolean = false;\n  messageModalIsDismissed: boolean = false;\n  miniMessageTooltipIsShown: boolean = false;\n  miniMessageTooltipIsDismissed: boolean = false;\n  shouldDisplayFullScaleMessage: boolean = true;\n  autoMessageDismissalTimeout: NodeJS.Timeout | undefined;\n\n  constructor(\n    private contextService: ContextService,\n    private readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService,\n    private checkpointCelebrationUtilityService: CheckpointCelebrationUtilityService,\n    private playerPositionService: PlayerPositionService,\n    private i18nLanguageCodeService: I18nLanguageCodeService,\n    private urlInterpolationService: UrlInterpolationService,\n    private windowDimensionsService: WindowDimensionsService,\n    private explorationPlayerStateService: ExplorationPlayerStateService\n  ) {}\n\n  ngOnInit(): void {\n    this.explorationId = this.contextService.getExplorationId();\n    this.oppiaAvatarImageUrl =\n      this.urlInterpolationService.getStaticCopyrightedImageUrl(\n        '/avatar/oppia_avatar_100px.svg'\n      );\n    this.readOnlyExplorationBackendApiService\n      .fetchExplorationAsync(this.explorationId, null)\n      .then(response => {\n        this.exploration = response.exploration;\n        this.hasViewedLessonInfoOnce =\n          response.has_viewed_lesson_info_modal_once;\n        this.mostRecentlyReachedCheckpointStateName =\n          response.most_recently_reached_checkpoint_state_name;\n\n        this.orderedCheckpointList =\n          this.checkpointCelebrationUtilityService.getStateListForCheckpointMessages(\n            this.exploration.states,\n            this.exploration.init_state_name\n          );\n        this.totalNumberOfCheckpoints = this.orderedCheckpointList.length;\n        this.checkpointStatusArrayPlaceholder = new Array(\n          this.totalNumberOfCheckpoints\n        );\n        this.checkpointStatusArray = new Array(this.totalNumberOfCheckpoints);\n        this.checkpointNodeFadeInDelays = new Array(\n          this.totalNumberOfCheckpoints\n        );\n        this.setFadeInDelaysForCheckpointNodes();\n        this.currentStateName = this.exploration.init_state_name;\n        this.subscribeToCardChangeEmitter();\n      });\n    this.shouldDisplayFullScaleMessage =\n      this.windowDimensionsService.getWidth() >\n      SCREEN_WIDTH_FOR_STANDARD_SIZED_MESSAGE_MODAL_CUTOFF_PX;\n    this.subscribeToWindowResizeEmitter();\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n\n  subscribeToCardChangeEmitter(): void {\n    this.directiveSubscriptions.add(\n      this.playerPositionService.onNewCardOpened.subscribe(\n        (nextStateCard: StateCard) => {\n          this.checkpointCelebrationUtilityService.setIsOnCheckpointedState(\n            false\n          );\n          if (this.miniMessageTooltipIsShown) {\n            this.dismissMiniMessage();\n            setTimeout(() => {\n              this.checkIfCheckpointMessageIsToBeTriggered(\n                nextStateCard.getStateName()\n              );\n            }, MESSAGE_MODAL_APPROX_TRIGGER_AND_DISMISSAL_DURATION_MS);\n          } else if (this.messageModalIsShown) {\n            this.dismissMessage();\n            setTimeout(() => {\n              this.checkIfCheckpointMessageIsToBeTriggered(\n                nextStateCard.getStateName()\n              );\n            }, MESSAGE_MODAL_APPROX_TRIGGER_AND_DISMISSAL_DURATION_MS);\n          } else {\n            this.checkIfCheckpointMessageIsToBeTriggered(\n              nextStateCard.getStateName()\n            );\n          }\n        }\n      )\n    );\n  }\n\n  subscribeToWindowResizeEmitter(): void {\n    this.directiveSubscriptions.add(\n      this.windowDimensionsService.getResizeEvent().subscribe(() => {\n        this.shouldDisplayFullScaleMessage =\n          this.windowDimensionsService.getWidth() >\n          SCREEN_WIDTH_FOR_STANDARD_SIZED_MESSAGE_MODAL_CUTOFF_PX;\n      })\n    );\n  }\n\n  checkIfCheckpointMessageIsToBeTriggered(newStateName: string): void {\n    if (\n      newStateName === this.currentStateName ||\n      newStateName === this.mostRecentlyReachedCheckpointStateName ||\n      !this.explorationPlayerStateService.isInStoryChapterMode()\n    ) {\n      return;\n    }\n    this.currentStateName = newStateName;\n    let checkpointPos = this.orderedCheckpointList.indexOf(\n      this.currentStateName\n    );\n    if (checkpointPos === -1 || checkpointPos === 0) {\n      return;\n    }\n    if (!this.hasViewedLessonInfoOnce) {\n      this.hasViewedLessonInfoOnce = true;\n      return;\n    }\n\n    this.translatedCurrentCheckpointMessage =\n      this.checkpointCelebrationUtilityService.getCheckpointMessage(\n        checkpointPos,\n        this.orderedCheckpointList.length\n      );\n    this.translatedCurrentCheckpointMessageTitle =\n      this.checkpointCelebrationUtilityService.getCheckpointTitle();\n    this.currentCheckpointPosition = checkpointPos;\n    this.generateCheckpointStatusArray();\n\n    this.checkpointCelebrationUtilityService.setIsOnCheckpointedState(true);\n    if (this.shouldDisplayFullScaleMessage) {\n      this.triggerStandardMessage();\n    } else {\n      this.triggerMiniMessage();\n    }\n  }\n\n  generateCheckpointStatusArray(): void {\n    for (let i = 0; i < this.currentCheckpointPosition; i++) {\n      this.checkpointStatusArray[i] = CHECKPOINT_STATUS_COMPLETED;\n    }\n    if (this.totalNumberOfCheckpoints > this.currentCheckpointPosition) {\n      this.checkpointStatusArray[this.currentCheckpointPosition] =\n        CHECKPOINT_STATUS_IN_PROGRESS;\n    }\n    for (\n      let i = this.currentCheckpointPosition + 1;\n      i < this.totalNumberOfCheckpoints;\n      i++\n    ) {\n      this.checkpointStatusArray[i] = CHECKPOINT_STATUS_INCOMPLETE;\n    }\n    this.checkpointNodesAreVisible = true;\n  }\n\n  getCompletedProgressBarWidth(): number {\n    if (!this.messageModalIsShown || this.messageModalIsDismissed) {\n      return 0;\n    }\n    if (this.currentCheckpointPosition === 0) {\n      return 0;\n    }\n    const spaceBetweenEachNode = 100 / (this.totalNumberOfCheckpoints - 1);\n    return (\n      (this.currentCheckpointPosition - 1) * spaceBetweenEachNode +\n      spaceBetweenEachNode / 2\n    );\n  }\n\n  setFadeInDelaysForCheckpointNodes(): void {\n    for (let i = 0; i < this.totalNumberOfCheckpoints; i++) {\n      this.checkpointNodeFadeInDelays[i] =\n        i * (1.5 / this.totalNumberOfCheckpoints) + 2.2;\n    }\n  }\n\n  triggerStandardMessage(): void {\n    this.resetTimer();\n    this.messageModalIsShown = true;\n    this.autoMessageDismissalTimeout = setTimeout(() => {\n      this.messageModalIsShown = false;\n      this.checkpointNodesAreVisible = false;\n    }, MESSAGE_MODAL_APPROX_COMPLETE_ANIMATION_DURATION_MS);\n  }\n\n  triggerMiniMessage(): void {\n    this.miniMessageTooltipIsShown = true;\n    setTimeout(() => {\n      this.miniMessageTooltipIsShown = false;\n    }, MINI_MESSAGE_MODAL_APPROX_COMPLETE_ANIMATION_DURATION_MS);\n  }\n\n  dismissMessage(): void {\n    if (this.autoMessageDismissalTimeout) {\n      clearTimeout(this.autoMessageDismissalTimeout);\n    }\n    this.messageModalIsShown = false;\n    this.messageModalIsDismissed = true;\n    this.checkpointNodesAreVisible = false;\n    setTimeout(() => {\n      this.messageModalIsDismissed = false;\n    }, MESSAGE_MODAL_APPROX_TRIGGER_AND_DISMISSAL_DURATION_MS);\n  }\n\n  dismissMiniMessage(): void {\n    this.miniMessageTooltipIsShown = false;\n    this.miniMessageTooltipIsDismissed = true;\n    setTimeout(() => {\n      this.miniMessageTooltipIsDismissed = false;\n    }, MESSAGE_MODAL_APPROX_TRIGGER_AND_DISMISSAL_DURATION_MS);\n  }\n\n  resetTimer(): void {\n    if (!this.shouldDisplayFullScaleMessage) {\n      return;\n    }\n    this.checkpointTimer = this.checkpointTimerTemplateRef.nativeElement;\n    // This function is meant to reset the timer SVG to its initial position,\n    // i.e. completely filled. This needs to happen instantly, as opposed to the\n    // depleting of the timer which happens over a 12 second (approx.) period.\n    // Hence we set the transition duration to 0s, reset the stroke-dashoffset\n    // to 0, and then set the transition duration back to 12s before changing\n    // the stroke-dashoffset to 10, which begins the normal depleting of the\n    // timer.\n    // However, changing the transition duration to 0s isn't immediately\n    // picked up by the browser and so the timer can still be seen animating up\n    // to its initial position.\n    // To force the browser to pick up this change, we need to trigger a reflow.\n    // The clientHeight property is one of the properties that causes a\n    // reflow.\n    if (this.checkpointTimer) {\n      this.checkpointTimer.style.transitionDuration = '0s';\n      this.checkpointTimer.style.strokeDashoffset = '0';\n      this.checkpointTimer.clientHeight;\n      this.checkpointTimer.style.transitionDuration = '12.14s';\n      this.checkpointTimer.clientHeight;\n      if (this.isLanguageRTL()) {\n        this.checkpointTimer.style.strokeDashoffset = '-10';\n      } else {\n        this.checkpointTimer.style.strokeDashoffset = '10';\n      }\n    }\n  }\n\n  openLessonInfoModal(): void {\n    this.checkpointCelebrationUtilityService.openLessonInformationModal();\n  }\n\n  isLanguageRTL(): boolean {\n    return this.i18nLanguageCodeService.isCurrentLanguageRTL();\n  }\n}\n"
    },
    {
      "filename": "core/templates/domain/feature-flag/feature-status-summary.model.ts",
      "content": "// Copyright 2020 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Factory model for FeatureStatusSummary.\n */\n\n/**\n * Names of all feature flags should be defined here, with format:\n * FeatureName = 'feature_name', where the LHS is the feature name in\n * PascalCase, and the RHS is in snake_case, which is the naming convention\n * of features in the backend.\n */\nexport enum FeatureNames {\n  DummyFeatureFlagForE2ETests = 'dummy_feature_flag_for_e2e_tests',\n  DiagnosticTest = 'diagnostic_test',\n  SerialChapterLaunchCurriculumAdminView = 'serial_chapter_launch_curriculum_admin_view',\n  SerialChapterLaunchLearnerView = 'serial_chapter_launch_learner_view',\n  ShowTranslationSize = 'show_translation_size',\n  ShowFeedbackUpdatesInProfilePicDropdownMenu = 'show_feedback_updates_in_profile_pic_dropdown',\n  ShowRedesignedLearnerDashboard = 'show_redesigned_learner_dashboard',\n  IsImprovementsTabEnabled = 'is_improvements_tab_enabled',\n  LearnerGroupsAreEnabled = 'learner_groups_are_enabled',\n  CdAdminDashboardNewUi = 'cd_admin_dashboard_new_ui',\n  NewLessonPlayer = 'new_lesson_player',\n  AddVoiceoverWithAccent = 'add_voiceover_with_accent',\n  CdAllowUndoingTranslationReview = 'cd_allow_undoing_translation_review',\n  EnableVoiceoverContribution = 'enable_voiceover_contribution',\n  AutoUpdateExpVoiceArtistLink = 'auto_update_exp_voice_artist_link',\n  ExplorationEditorCanModifyTranslations = 'exploration_editor_can_modify_translations',\n  ExplorationEditorCanTagMisconceptions = 'exploration_editor_can_tag_misconceptions',\n  EnableMultipleClassrooms = 'enable_multiple_classrooms',\n  RedesignedTopicViewerPage = 'redesigned_topic_viewer_page',\n  AutomaticVoiceoverRegenerationFromExp = 'automatic_voiceover_regeneration_from_exp',\n  LabelAccentToVoiceArtist = 'label_accent_to_voice_artist',\n}\n\nexport interface FeatureStatusSummaryBackendDict {\n  [featureName: string]: boolean;\n}\n\n/**\n * Status checker of feature flags, which are keyed on their names defined in\n * FeatureNames. This provides interface for developer to access feature flag\n * values with feature name hint:\n *   featureStatusChecker.DummyFeatureFlagForE2ETests.isEnabled === true\n */\nexport type FeatureStatusChecker = {\n  [name in keyof typeof FeatureNames]: {\n    isEnabled: boolean;\n  };\n};\n\nexport type FeatureNamesKeys = (keyof typeof FeatureNames)[];\n\n/**\n * Item of the status checker of feature flags, which represents the status of\n * one feature flag, providing the '.isEnabled' interface to check the status\n * of that feature flag.\n */\nclass FeatureStatusCheckerItem {\n  /**\n   * Constructor of the FeatureStatusCheckerDictItem class.\n   *\n   * @param {() => boolean} getterFn - Function that returns the status of\n   *     the feature.\n   */\n  constructor(private getterFn: () => boolean) {}\n\n  /**\n   * Checks if the feature is enabled.\n   *\n   * @returns {boolean} - True if the feature is enabled.\n   */\n  get isEnabled(): boolean {\n    return this.getterFn();\n  }\n}\n\n/**\n * Represents the evaluation result summary of all feature flags received from\n * the server. This is used only in the frontend feature value retrieval.\n */\nexport class FeatureStatusSummary {\n  featureNameToFlag: Map<string, boolean>;\n\n  constructor(backendDict: FeatureStatusSummaryBackendDict) {\n    this.featureNameToFlag = new Map(Object.entries(backendDict));\n  }\n\n  static createFromBackendDict(\n    backendDict: FeatureStatusSummaryBackendDict\n  ): FeatureStatusSummary {\n    return new FeatureStatusSummary(backendDict);\n  }\n\n  /**\n   * Creates a default FeatureStatusSummary object such that all features are\n   * disabled.\n   *\n   * @returns {FeatureStatusSummary} - The FeatureStatusSummary object instance\n   *     with all feature disabled.\n   */\n  static createDefault(): FeatureStatusSummary {\n    const defaultDict: FeatureStatusSummaryBackendDict = {};\n    const featureNamesKeys = Object.keys(FeatureNames) as FeatureNamesKeys;\n    featureNamesKeys.forEach(name => (defaultDict[FeatureNames[name]] = false));\n    return this.createFromBackendDict(defaultDict);\n  }\n\n  /**\n   * Creates a dict representation of the instance.\n   *\n   * @returns {FeatureStatusSummaryBackendDict} - The dict representation\n   * of the instance.\n   */\n  toBackendDict(): FeatureStatusSummaryBackendDict {\n    const backendDict: Record<string, boolean> = {};\n    for (const [key, value] of this.featureNameToFlag.entries()) {\n      backendDict[key] = value;\n    }\n    return backendDict;\n  }\n\n  /**\n   * Construct and returns the feature status checker.\n   *\n   * @returns {FeatureStatusChecker} - The feature status checker.\n   */\n  toStatusChecker(): FeatureStatusChecker {\n    const checker = {} as FeatureStatusChecker;\n    const featureNamesKeys = Object.keys(FeatureNames) as FeatureNamesKeys;\n    featureNamesKeys.forEach(name => {\n      Object.defineProperty(checker, name, {\n        value: new FeatureStatusCheckerItem(() =>\n          this.isFeatureEnabled(FeatureNames[name])\n        ),\n      });\n    });\n    return checker;\n  }\n\n  /**\n   * Gets the value of a feature flag in the result.\n   *\n   * @param {string} featureName - The name of the feature.\n   *\n   * @returns {boolean} - The value of the feature flag, true if enabled.\n   * @throws {Error} - If the feature with the specified name doesn't exist.\n   */\n  private isFeatureEnabled(featureName: string): boolean {\n    const isEnabled = this.featureNameToFlag.get(featureName);\n    if (isEnabled === undefined) {\n      throw new Error(`Feature '${featureName}' does not exist.`);\n    }\n    return isEnabled;\n  }\n}\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/conversation-skin.component.html",
      "content": "<div role=\"main\" class=\"oppia-conversation-skin-animate-cards-container position-relative\" *ngIf=\"hasFullyLoaded\">\n  <div class=\"conversation-skin-cards-container conversation-skin-animate-cards e2e-test-conversation-skin-cards-container\"\n       [ngClass]=\"{'animate-to-two-cards': isAnimatingToTwoCards,'animate-to-one-card': isAnimatingToOneCard,'conversation-skin-cards-container-embedded': isIframed}\">\n\n    <div class=\"conversation-skin-tutor-card-container\"\n         [ngClass]=\"{'conversation-skin-animate-tutor-card-on-narrow':\n                      !canWindowShowTwoCards() && isCurrentSupplementalCardNonempty(),\n                    'conversation-skin-tutor-card-alone':\n                      !canWindowShowTwoCards() && !isCurrentSupplementalCardNonempty()}\">\n      <oppia-tutor-card [displayedCard]=\"displayedCard\"\n                        [displayedCardWasCompletedInPrevSession]=\"isDisplayedCardCompletedInPrevSession()\"\n                        [avatarImageIsShown]=\"true\"\n                        [shouldHideInteraction]=\"continueToReviseStateButtonIsVisible || !showInteraction\"\n                        [startCardChangeAnimation]=\"startCardChangeAnimation\"\n                        [userIsLoggedIn]=\"isLoggedIn\"\n                        [collectionSummary]=\"collectionSummary\"\n                        [questionPlayerConfig]=\"questionPlayerConfig\"\n                        [explorationIsInPreviewMode]=\"isInPreviewMode\"\n                        [isRefresherExploration]=\"isRefresherExploration\"\n                        [recommendedExplorationSummaries]=\"recommendedExplorationSummaries\"\n                        [parentExplorationIds]=\"parentExplorationIds\"\n                        [inStoryMode]=\"inStoryMode\"\n                        [nextLessonLink]=\"getExplorationLink()\"\n                        [completedChaptersCount]=\"completedChaptersCount\"\n                        [milestoneMessageIsToBeDisplayed]=\"chapterIsCompletedForTheFirstTime\"\n                        [feedbackIsEnabled]=\"feedbackIsEnabled\"\n                        [learnerCanOnlyAttemptQuestionOnce]=\"learnerCanOnlyAttemptQuestionOnce\"\n                        [inputOutputHistoryIsShown]=\"inputOutputHistoryIsShown\"\n                        [checkpointCelebrationModalIsEnabled]=\"checkpointCelebrationModalIsEnabled\">\n      </oppia-tutor-card>\n      <div *ngIf=\"isCurrentSupplementalCardNonempty() && !canWindowShowTwoCards()\">\n        <oppia-supplemental-card (clickContinueButton)=\"showUpcomingCard()\"\n                                 [displayedCard]=\"displayedCard\"\n                                 [isLearnAgainButton]=\"isLearnAgainButton()\">\n        </oppia-supplemental-card>\n      </div>\n      <div *ngIf=\"getCanAskLearnerForAnswerInfo()\">\n        <oppia-learner-answer-info-card (submitAnswer)=\"submitAnswer($event.currentAnswer, $event.rulesService)\">\n        </oppia-learner-answer-info-card>\n      </div>\n      <div *ngIf=\"!getCanAskLearnerForAnswerInfo()\">\n        <oppia-progress-nav (submit)=\"submitAnswerFromProgressNav()\"\n                            [isLearnAgainButton]=\"isLearnAgainButton()\"\n                            [displayedCard]=\"displayedCard\"\n                            [submitButtonIsShown]=\"!answerIsBeingProcessed && !continueToReviseStateButtonIsVisible\"\n                            [showContinueToReviseButton]=\"continueToReviseStateButtonIsVisible\"\n                            (clickContinueButton)=\"showUpcomingCard()\"\n                            (clickContinueToReviseButton)=\"triggerRedirectionToStuckState()\"\n                            (changeCard)=\"changeCard($event)\"\n                            [navigationThroughCardHistoryIsEnabled]=\"navigationThroughCardHistoryIsEnabled\"\n                            [skipButtonIsShown]=\"skipButtonIsShown\"\n                            (skipQuestion)=\"skipCurrentQuestion()\">\n        </oppia-progress-nav>\n      </div>\n      <div *ngIf=\"isOnTerminalCard() && recommendedExplorationSummaries && recommendedExplorationSummaries.length > 0 && (inStoryMode || (collectionSummary && isOnTerminalCard() && isCurrentCardAtEndOfTranscript()))\"\n           class=\"conversation-skin-next-lesson-wrapper\">\n        <div class=\"oppia-conversation-skin-next-lesson-text-container\">\n          <span class=\"conversation-skin-next-lesson-text\" translate=\"I18N_NEXT_LESSON\"></span>\n          <span *ngIf=\"!isHackyExpTitleTranslationDisplayed(recommendedExplorationSummaries[0].id)\">\n            {{ recommendedExplorationSummaries[0].title }}\n          </span>\n          <span *ngIf=\"isHackyExpTitleTranslationDisplayed(recommendedExplorationSummaries[0].id)\">\n            {{ getRecommendedExpTitleTranslationKey(recommendedExplorationSummaries[0].id) | translate }}\n          </span>\n        </div>\n        <div>\n          <a [href]=\"getExplorationLink()\" target=\"{{ openInNewWindow ? '_blank' : '_self' }}\">\n            <button mat-button class=\"md-raised oppia-button-raised e2e-test-next-lesson-button\">\n              <i class=\"material-icons oppia-vcenter oppia-button-icon\" aria-hidden=\"true\">&#xE5C8;</i>\n            </button>\n          </a>\n        </div>\n      </div>\n    </div>\n\n    <div *ngIf=\"isCurrentSupplementalCardNonempty() && canWindowShowTwoCards()\"\n         class=\"conversation-skin-supplemental-card-container\">\n      <div class=\"supplemental-card-parent-container\">\n        <oppia-supplemental-card (clickContinueButton)=\"showUpcomingCard()\"\n                                 [displayedCard]=\"displayedCard\"\n                                 [isLearnAgainButton]=\"isLearnAgainButton()\">\n        </oppia-supplemental-card>\n        <div class=\"conversation-skin-supplemental-nav\" *ngIf=\"isSupplementalNavShown() && !getCanAskLearnerForAnswerInfo()\">\n          <button mat-button\n                  type=\"submit\"\n                  class=\"oppia-learner-confirm-button oppia-learner-submit-answer-button e2e-test-submit-answer-button conversation-skin-supplemental-nav-submit-button\"\n                  (click)=\"submitAnswerFromProgressNav()\"\n                  [disabled]=\"isSubmitButtonDisabled()\">\n            {{ 'I18N_INTERACTIONS_SUBMIT' | translate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"conversation-skin-correctness-footer-container\" *ngIf=\"isCorrectnessFooterEnabled()\">\n    <oppia-correctness-footer></oppia-correctness-footer>\n  </div>\n</div>\n\n<div *ngIf=\"isProgressClearanceMessageShown()\" class=\"oppia-exploration-checkpoints-message\">\n  <div id=\"toast-container\" class=\"toast-top-center toast-container\">\n    <div class=\"toast-info checkpoints-toast-info ngx-toastr ng-trigger ng-trigger-flyInOut\">\n      <div aria-live=\"polite\" role=\"alertdialog\" class=\"toast-message e2e-test-lesson-completion-message\" attr.aria-label=\"{{'I18N_EXPLORATION_STARTING_FROM_BEGINNING' | translate}}\">\n        {{ 'I18N_EXPLORATION_STARTING_FROM_BEGINNING' | translate }}\n      </div>\n    </div>\n  </div>\n</div>\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/conversation-skin.component.spec.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for Conversation skin component.\n */\n\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\nimport {EventEmitter, NO_ERRORS_SCHEMA} from '@angular/core';\nimport {\n  ComponentFixture,\n  fakeAsync,\n  TestBed,\n  tick,\n  waitForAsync,\n  flush,\n} from '@angular/core/testing';\nimport {TranslateService} from '@ngx-translate/core';\nimport {MockTranslateService} from 'components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';\nimport {QuestionPlayerStateService} from 'components/question-directives/question-player/services/question-player-state.service';\nimport {Collection} from 'domain/collection/collection.model';\nimport {GuestCollectionProgressService} from 'domain/collection/guest-collection-progress.service';\nimport {ReadOnlyCollectionBackendApiService} from 'domain/collection/read-only-collection-backend-api.service';\nimport {\n  Interaction,\n  InteractionObjectFactory,\n} from 'domain/exploration/InteractionObjectFactory';\nimport {\n  FetchExplorationBackendResponse,\n  ReadOnlyExplorationBackendApiService,\n} from 'domain/exploration/read-only-exploration-backend-api.service';\nimport {BindableVoiceovers} from 'domain/exploration/recorded-voiceovers.model';\nimport {SubtitledHtml} from 'domain/exploration/subtitled-html.model';\nimport {ConceptCardBackendApiService} from 'domain/skill/concept-card-backend-api.service';\nimport {ConceptCard} from 'domain/skill/concept-card.model';\nimport {StateObjectFactory} from 'domain/state/StateObjectFactory';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {ReadOnlyStoryNode} from 'domain/story_viewer/read-only-story-node.model';\nimport {StoryPlaythrough} from 'domain/story_viewer/story-playthrough.model';\nimport {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';\nimport {\n  ExplorationSummaryBackendApiService,\n  ExplorationSummaryDict,\n} from 'domain/summary/exploration-summary-backend-api.service';\nimport {UserInfo} from 'domain/user/user-info.model';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {CollectionPlayerBackendApiService} from 'pages/collection-player-page/services/collection-player-backend-api.service';\nimport {AlertsService} from 'services/alerts.service';\nimport {AudioPlayerService} from 'services/audio-player.service';\nimport {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';\nimport {ContextService} from 'services/context.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {I18nLanguageCodeService} from 'services/i18n-language-code.service';\nimport {LoaderService} from 'services/loader.service';\nimport {LocalStorageService} from 'services/local-storage.service';\nimport {MessengerService} from 'services/messenger.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {FocusManagerService} from 'services/stateful/focus-manager.service';\nimport {UserService} from 'services/user.service';\nimport {MockTranslatePipe} from 'tests/unit-test-utils';\nimport {ExplorationPlayerConstants} from '../exploration-player-page.constants';\nimport {\n  AnswerClassificationService,\n  InteractionRulesService,\n} from '../services/answer-classification.service';\nimport {ContentTranslationManagerService} from '../services/content-translation-manager.service';\nimport {CurrentInteractionService} from '../services/current-interaction.service';\nimport {ExplorationEngineService} from '../services/exploration-engine.service';\nimport {ExplorationPlayerStateService} from '../services/exploration-player-state.service';\nimport {ExplorationRecommendationsService} from '../services/exploration-recommendations.service';\nimport {FatigueDetectionService} from '../services/fatigue-detection.service';\nimport {HintsAndSolutionManagerService} from '../services/hints-and-solution-manager.service';\nimport {ImagePreloaderService} from '../services/image-preloader.service';\nimport {LearnerAnswerInfoService} from '../services/learner-answer-info.service';\nimport {LearnerParamsService} from '../services/learner-params.service';\nimport {NumberAttemptsService} from '../services/number-attempts.service';\nimport {PlayerPositionService} from '../services/player-position.service';\nimport {PlayerTranscriptService} from '../services/player-transcript.service';\nimport {QuestionPlayerEngineService} from '../services/question-player-engine.service';\nimport {RefresherExplorationConfirmationModalService} from '../services/refresher-exploration-confirmation-modal.service';\nimport {StatsReportingService} from '../services/stats-reporting.service';\nimport {ConversationSkinComponent} from './conversation-skin.component';\nimport {LearnerDashboardBackendApiService} from 'domain/learner_dashboard/learner-dashboard-backend-api.service';\nimport {EditableExplorationBackendApiService} from 'domain/exploration/editable-exploration-backend-api.service';\nimport {DiagnosticTestTopicTrackerModel} from 'pages/diagnostic-test-player-page/diagnostic-test-topic-tracker.model';\nimport {AudioTranslationLanguageService} from '../services/audio-translation-language.service';\nimport {ConceptCardManagerService} from '../services/concept-card-manager.service';\nimport {SolutionObjectFactory} from 'domain/exploration/SolutionObjectFactory';\nimport {ConversationFlowService} from '../services/conversation-flow.service';\nimport {VoiceoverPlayerService} from '../services/voiceover-player.service';\n\nclass MockWindowRef {\n  nativeWindow = {\n    location: {\n      pathname: '/path/name',\n      reload: () => {},\n    },\n    onresize: () => {},\n    addEventListener(event: string, callback) {\n      callback({returnValue: null});\n    },\n    scrollTo: (x, y) => {},\n  };\n}\n\ndescribe('Conversation skin component', () => {\n  let fixture: ComponentFixture<ConversationSkinComponent>;\n  let componentInstance: ConversationSkinComponent;\n  let alertsService: AlertsService;\n  let audioPlayerService: AudioPlayerService;\n  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;\n  let collectionPlayerBackendApiService: CollectionPlayerBackendApiService;\n  let conceptCardBackendApiService: ConceptCardBackendApiService;\n  let contentTranslationManagerService: ContentTranslationManagerService;\n  let contextService: ContextService;\n  let conversationFlowService: ConversationFlowService;\n  let currentInteractionService: CurrentInteractionService;\n  let editableExplorationBackendApiService: EditableExplorationBackendApiService;\n  let explorationEngineService: ExplorationEngineService;\n  let explorationPlayerStateService: ExplorationPlayerStateService;\n  let explorationRecommendationsService: ExplorationRecommendationsService;\n  let explorationSummaryBackendApiService: ExplorationSummaryBackendApiService;\n  let fatigueDetectionService: FatigueDetectionService;\n  let focusManagerService: FocusManagerService;\n  let guestCollectionProgressService: GuestCollectionProgressService;\n  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;\n  let i18nLanguageCodeService: I18nLanguageCodeService;\n  let imagePreloaderService: ImagePreloaderService;\n  let learnerAnswerInfoService: LearnerAnswerInfoService;\n  let learnerParamsService: LearnerParamsService;\n  let loaderService: LoaderService;\n  let localStorageService: LocalStorageService;\n  let messengerService: MessengerService;\n  let numberAttemptsService: NumberAttemptsService;\n  let interactionObjectFactory: InteractionObjectFactory;\n  let playerPositionService: PlayerPositionService;\n  let playerTranscriptService: PlayerTranscriptService;\n  let questionPlayerEngineService: QuestionPlayerEngineService;\n  let questionPlayerStateService: QuestionPlayerStateService;\n  let answerClassificationService: AnswerClassificationService;\n  let readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService;\n  let refresherExplorationConfirmationModalService: RefresherExplorationConfirmationModalService;\n  let siteAnalyticsService: SiteAnalyticsService;\n  let statsReportingService: StatsReportingService;\n  let storyViewerBackendApiService: StoryViewerBackendApiService;\n  let urlInterpolationService: UrlInterpolationService;\n  let urlService: UrlService;\n  let userService: UserService;\n  let windowDimensionsService: WindowDimensionsService;\n  let windowRef: WindowRef;\n  let readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService;\n  let stateObjectFactory: StateObjectFactory;\n  let translateService: TranslateService;\n  let learnerDashboardBackendApiService: LearnerDashboardBackendApiService;\n  let audioTranslationLanguageService: AudioTranslationLanguageService;\n  let conceptCardManagerService: ConceptCardManagerService;\n  let solutionObjectFactory: SolutionObjectFactory;\n  let voiceoverPlayerService: VoiceoverPlayerService;\n\n  let displayedCard = new StateCard(\n    null,\n    null,\n    null,\n    new Interaction([], [], null, null, [], '', null),\n    [],\n    null,\n    '',\n    null\n  );\n\n  let explorationDict = {\n    states: {\n      Start: {\n        classifier_model_id: null,\n        recorded_voiceovers: {\n          voiceovers_mapping: {\n            ca_placeholder_0: {},\n            feedback_1: {},\n            rule_input_2: {},\n            content: {},\n            default_outcome: {},\n          },\n        },\n        solicit_answer_details: false,\n        interaction: {\n          solution: null,\n          confirmed_unclassified_answers: [],\n          id: 'TextInput',\n          hints: [],\n          customization_args: {\n            rows: {\n              value: 1,\n            },\n            placeholder: {\n              value: {\n                unicode_str: '',\n                content_id: 'ca_placeholder_0',\n              },\n            },\n            catchMisspellings: {\n              value: false,\n            },\n          },\n          answer_groups: [\n            {\n              outcome: {\n                missing_prerequisite_skill_id: null,\n                refresher_exploration_id: null,\n                labelled_as_correct: false,\n                feedback: {\n                  content_id: 'feedback_1',\n                  html: '<p>Good Job</p>',\n                },\n                param_changes: [],\n                dest_if_really_stuck: null,\n                dest: 'Mid',\n              },\n              training_data: [],\n              rule_specs: [\n                {\n                  inputs: {\n                    x: {\n                      normalizedStrSet: ['answer'],\n                      contentId: 'rule_input_2',\n                    },\n                  },\n                  rule_type: 'FuzzyEquals',\n                },\n              ],\n              tagged_skill_misconception_id: null,\n            },\n          ],\n          default_outcome: {\n            missing_prerequisite_skill_id: null,\n            refresher_exploration_id: null,\n            labelled_as_correct: false,\n            feedback: {\n              content_id: 'default_outcome',\n              html: '<p>Try again.</p>',\n            },\n            param_changes: [],\n            dest_if_really_stuck: null,\n            dest: 'Start',\n          },\n        },\n        param_changes: [],\n        card_is_checkpoint: true,\n        linked_skill_id: null,\n        content: {\n          content_id: 'content',\n          html: '<p>First Question</p>',\n        },\n      },\n      End: {\n        classifier_model_id: null,\n        recorded_voiceovers: {\n          voiceovers_mapping: {\n            content: {},\n          },\n        },\n        solicit_answer_details: false,\n        interaction: {\n          solution: null,\n          confirmed_unclassified_answers: [],\n          id: 'EndExploration',\n          hints: [],\n          customization_args: {\n            recommendedExplorationIds: {\n              value: ['recommnendedExplorationId'],\n            },\n          },\n          answer_groups: [],\n          default_outcome: null,\n        },\n        param_changes: [],\n        card_is_checkpoint: false,\n        linked_skill_id: null,\n        content: {\n          content_id: 'content',\n          html: 'Congratulations, you have finished!',\n        },\n      },\n      Mid: {\n        classifier_model_id: null,\n        recorded_voiceovers: {\n          voiceovers_mapping: {\n            ca_placeholder_0: {},\n            feedback_1: {},\n            rule_input_2: {},\n            content: {},\n            default_outcome: {},\n          },\n        },\n        solicit_answer_details: false,\n        interaction: {\n          solution: null,\n          confirmed_unclassified_answers: [],\n          id: 'TextInput',\n          hints: [],\n          customization_args: {\n            rows: {\n              value: 1,\n            },\n            placeholder: {\n              value: {\n                unicode_str: '',\n                content_id: 'ca_placeholder_0',\n              },\n            },\n            catchMisspellings: {\n              value: false,\n            },\n          },\n          answer_groups: [\n            {\n              outcome: {\n                missing_prerequisite_skill_id: null,\n                refresher_exploration_id: null,\n                labelled_as_correct: false,\n                feedback: {\n                  content_id: 'feedback_1',\n                  html: ' <p>Good Job</p>',\n                },\n                param_changes: [],\n                dest_if_really_stuck: null,\n                dest: 'End',\n              },\n              training_data: [],\n              rule_specs: [\n                {\n                  inputs: {\n                    x: {\n                      normalizedStrSet: ['answer'],\n                      contentId: 'rule_input_2',\n                    },\n                  },\n                  rule_type: 'FuzzyEquals',\n                },\n              ],\n              tagged_skill_misconception_id: null,\n            },\n          ],\n          default_outcome: {\n            missing_prerequisite_skill_id: null,\n            refresher_exploration_id: null,\n            labelled_as_correct: false,\n            feedback: {\n              content_id: 'default_outcome',\n              html: '<p>try again.</p>',\n            },\n            param_changes: [],\n            dest_if_really_stuck: null,\n            dest: 'Mid',\n          },\n        },\n        param_changes: [],\n        card_is_checkpoint: false,\n        linked_skill_id: null,\n        content: {\n          content_id: 'content',\n          html: '<p>Second Question</p>',\n        },\n      },\n    },\n    auto_tts_enabled: true,\n    version: 2,\n    draft_change_list_id: 9,\n    is_version_of_draft_valid: null,\n    title: 'Exploration',\n    language_code: 'en',\n    init_state_name: 'Start',\n    param_changes: [],\n    next_content_id_index: 4,\n    param_specs: null,\n    draft_changes: null,\n  };\n\n  let explorationResponse: FetchExplorationBackendResponse = {\n    exploration_id: 'exp_id',\n    is_logged_in: true,\n    session_id: 'KERH',\n    displayable_language_codes: [],\n    exploration: {\n      init_state_name: 'Start',\n      param_changes: [],\n      param_specs: null,\n      title: 'Exploration',\n      language_code: 'en',\n      objective: 'To learn',\n      states: explorationDict.states,\n      next_content_id_index: explorationDict.next_content_id_index,\n    },\n    exploration_metadata: {\n      title: 'Exploration',\n      category: 'Algebra',\n      objective: 'To learn',\n      language_code: 'en',\n      tags: [],\n      blurb: '',\n      author_notes: '',\n      states_schema_version: 50,\n      init_state_name: 'Introduction',\n      param_specs: {},\n      param_changes: [],\n      auto_tts_enabled: false,\n      edits_allowed: true,\n    },\n    version: 2,\n    can_edit: true,\n    preferred_audio_language_code: 'en',\n    preferred_language_codes: [],\n    auto_tts_enabled: true,\n    record_playthrough_probability: 1,\n    draft_change_list_id: 0,\n    has_viewed_lesson_info_modal_once: false,\n    furthest_reached_checkpoint_exp_version: 1,\n    furthest_reached_checkpoint_state_name: 'End',\n    most_recently_reached_checkpoint_state_name: 'Mid',\n    most_recently_reached_checkpoint_exp_version: 2,\n  };\n\n  let sampleExpResponse: FetchExplorationBackendResponse = {\n    exploration_id: 'exp_id',\n    is_logged_in: true,\n    session_id: 'KERH',\n    displayable_language_codes: [],\n    exploration: {\n      init_state_name: 'Start',\n      param_changes: [],\n      param_specs: null,\n      title: 'Exploration',\n      language_code: 'en',\n      objective: 'To learn',\n      states: explorationDict.states,\n      next_content_id_index: explorationDict.next_content_id_index,\n    },\n    exploration_metadata: {\n      title: 'Exploration',\n      category: 'Algebra',\n      objective: 'To learn',\n      language_code: 'en',\n      tags: [],\n      blurb: '',\n      author_notes: '',\n      states_schema_version: 50,\n      init_state_name: 'Introduction',\n      param_specs: {},\n      param_changes: [],\n      auto_tts_enabled: false,\n      edits_allowed: true,\n    },\n    version: 2,\n    can_edit: true,\n    preferred_audio_language_code: 'en',\n    preferred_language_codes: [],\n    auto_tts_enabled: true,\n    record_playthrough_probability: 1,\n    draft_change_list_id: 0,\n    has_viewed_lesson_info_modal_once: false,\n    furthest_reached_checkpoint_exp_version: 1,\n    furthest_reached_checkpoint_state_name: 'End',\n    most_recently_reached_checkpoint_state_name: null,\n    most_recently_reached_checkpoint_exp_version: 2,\n  };\n  let uniqueProgressIdResponse = '123456';\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [ConversationSkinComponent, MockTranslatePipe],\n      providers: [\n        SolutionObjectFactory,\n        {\n          provide: WindowRef,\n          useClass: MockWindowRef,\n        },\n        {\n          provide: TranslateService,\n          useClass: MockTranslateService,\n        },\n      ],\n      schemas: [NO_ERRORS_SCHEMA],\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(ConversationSkinComponent);\n    componentInstance = fixture.componentInstance;\n\n    alertsService = TestBed.inject(AlertsService);\n    audioPlayerService = TestBed.inject(AudioPlayerService);\n    autogeneratedAudioPlayerService = TestBed.inject(\n      AutogeneratedAudioPlayerService\n    );\n    collectionPlayerBackendApiService = TestBed.inject(\n      CollectionPlayerBackendApiService\n    );\n    conceptCardBackendApiService = TestBed.inject(ConceptCardBackendApiService);\n    contentTranslationManagerService = TestBed.inject(\n      ContentTranslationManagerService\n    );\n    contextService = TestBed.inject(ContextService);\n    conversationFlowService = TestBed.inject(ConversationFlowService);\n    currentInteractionService = TestBed.inject(CurrentInteractionService);\n    editableExplorationBackendApiService = TestBed.inject(\n      EditableExplorationBackendApiService\n    );\n    explorationEngineService = TestBed.inject(ExplorationEngineService);\n    explorationPlayerStateService = TestBed.inject(\n      ExplorationPlayerStateService\n    );\n    explorationRecommendationsService = TestBed.inject(\n      ExplorationRecommendationsService\n    );\n    explorationSummaryBackendApiService = TestBed.inject(\n      ExplorationSummaryBackendApiService\n    );\n    fatigueDetectionService = TestBed.inject(FatigueDetectionService);\n    interactionObjectFactory = TestBed.inject(InteractionObjectFactory);\n    focusManagerService = TestBed.inject(FocusManagerService);\n    audioTranslationLanguageService = TestBed.inject(\n      AudioTranslationLanguageService\n    );\n    guestCollectionProgressService = TestBed.inject(\n      GuestCollectionProgressService\n    );\n    hintsAndSolutionManagerService = TestBed.inject(\n      HintsAndSolutionManagerService\n    );\n    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);\n    imagePreloaderService = TestBed.inject(ImagePreloaderService);\n    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);\n    learnerParamsService = TestBed.inject(LearnerParamsService);\n    loaderService = TestBed.inject(LoaderService);\n    localStorageService = TestBed.inject(LocalStorageService);\n    messengerService = TestBed.inject(MessengerService);\n    numberAttemptsService = TestBed.inject(NumberAttemptsService);\n    playerPositionService = TestBed.inject(PlayerPositionService);\n    playerTranscriptService = TestBed.inject(PlayerTranscriptService);\n    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);\n    questionPlayerStateService = TestBed.inject(QuestionPlayerStateService);\n    readOnlyCollectionBackendApiService = TestBed.inject(\n      ReadOnlyCollectionBackendApiService\n    );\n    refresherExplorationConfirmationModalService = TestBed.inject(\n      RefresherExplorationConfirmationModalService\n    );\n    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);\n    statsReportingService = TestBed.inject(StatsReportingService);\n    solutionObjectFactory = TestBed.inject(SolutionObjectFactory);\n    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);\n    urlInterpolationService = TestBed.inject(UrlInterpolationService);\n    urlService = TestBed.inject(UrlService);\n    userService = TestBed.inject(UserService);\n    windowDimensionsService = TestBed.inject(WindowDimensionsService);\n    windowRef = TestBed.inject(WindowRef);\n    readOnlyExplorationBackendApiService = TestBed.inject(\n      ReadOnlyExplorationBackendApiService\n    );\n    stateObjectFactory = TestBed.inject(StateObjectFactory);\n    answerClassificationService = TestBed.inject(AnswerClassificationService);\n    conceptCardManagerService = TestBed.inject(ConceptCardManagerService);\n    translateService = TestBed.inject(TranslateService);\n    learnerDashboardBackendApiService = TestBed.inject(\n      LearnerDashboardBackendApiService\n    );\n    audioTranslationLanguageService = TestBed.inject(\n      AudioTranslationLanguageService\n    );\n    voiceoverPlayerService = TestBed.inject(VoiceoverPlayerService);\n  }));\n\n  it('should create && adjust page height on resize of window', fakeAsync(() => {\n    spyOn(componentInstance, 'adjustPageHeight').and.stub();\n    componentInstance.adjustPageHeightOnresize();\n\n    expect(componentInstance).toBeDefined();\n\n    windowRef.nativeWindow.onresize(null);\n    tick(200);\n\n    expect(componentInstance.adjustPageHeight).toHaveBeenCalled();\n  }));\n\n  it('should initialize component', fakeAsync(() => {\n    let collectionId = 'id';\n    let expId = 'exp_id';\n    let isInPreviewMode = false;\n    let isIframed = true;\n    let collectionSummary = {\n      is_admin: true,\n      summaries: [],\n      user_email: '',\n      is_topic_manager: false,\n      username: true,\n    };\n    let newStateName = 'newState';\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', true)\n      )\n    );\n    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(\n      collectionId,\n      null\n    );\n    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n\n    spyOn(\n      readOnlyCollectionBackendApiService,\n      'loadCollectionAsync'\n    ).and.returnValue(\n      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))\n    );\n    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);\n    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(\n      isInPreviewMode\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'getCurrentEngineService'\n    ).and.returnValue(explorationEngineService);\n    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');\n    spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n    spyOn(loaderService, 'showLoadingScreen');\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      'oppia_avatar_url'\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'isInQuestionPlayerMode'\n    ).and.returnValues(true, false);\n    spyOn(componentInstance, 'initializePage');\n    spyOn(\n      collectionPlayerBackendApiService,\n      'fetchCollectionSummariesAsync'\n    ).and.returnValue(Promise.resolve(collectionSummary));\n    spyOn(questionPlayerStateService, 'hintUsed');\n    spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n    spyOn(questionPlayerStateService, 'solutionViewed');\n    spyOn(imagePreloaderService, 'onStateChange');\n    spyOn(componentInstance, 'fetchCompletedChaptersCount');\n    spyOn(statsReportingService, 'recordExplorationCompleted');\n    spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n    spyOn(\n      guestCollectionProgressService,\n      'recordExplorationCompletedInCollection'\n    );\n    spyOn(\n      componentInstance,\n      'doesCollectionAllowsGuestProgress'\n    ).and.returnValue(true);\n    spyOn(statsReportingService, 'recordMaybeLeaveEvent');\n    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');\n    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});\n    spyOn(messengerService, 'sendMessage');\n    spyOn(\n      readOnlyExplorationBackendApiService,\n      'loadLatestExplorationAsync'\n    ).and.returnValue(Promise.resolve(explorationResponse));\n    spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue([\n      'Start',\n      'Mid',\n    ]);\n    spyOn(\n      editableExplorationBackendApiService,\n      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'\n    ).and.returnValue(\n      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})\n    );\n\n    let mockOnHintConsumed = new EventEmitter();\n    let mockOnSolutionViewedEventEmitter = new EventEmitter();\n    let mockOnPlayerStateChange = new EventEmitter();\n    let mockOnNewCardOpened = new EventEmitter();\n    let mockOnHintsExhausted = new EventEmitter();\n    let mockOnLearnerReallyStuck = new EventEmitter();\n    let mockOnLearnerGetsReallyStuck = new EventEmitter();\n\n    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(\n      mockOnNewCardOpened\n    );\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintsExhausted'\n    ).and.returnValue(mockOnHintsExhausted);\n    spyOnProperty(\n      conceptCardManagerService,\n      'onLearnerGetsReallyStuck'\n    ).and.returnValue(mockOnLearnerGetsReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onLearnerReallyStuck'\n    ).and.returnValue(mockOnLearnerReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintConsumed'\n    ).and.returnValue(mockOnHintConsumed);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onSolutionViewedEventEmitter'\n    ).and.returnValue(mockOnSolutionViewedEventEmitter);\n    spyOnProperty(\n      explorationPlayerStateService,\n      'onPlayerStateChange'\n    ).and.returnValue(mockOnPlayerStateChange);\n\n    componentInstance.nextCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = false;\n    componentInstance.hasInteractedAtLeastOnce = true;\n    componentInstance.displayedCard = displayedCard;\n\n    componentInstance.ngOnInit();\n    windowRef.nativeWindow.onresize(null);\n\n    mockOnNewCardOpened.emit(componentInstance.nextCard);\n    mockOnHintsExhausted.emit();\n    mockOnLearnerGetsReallyStuck.emit();\n    mockOnLearnerReallyStuck.emit();\n    mockOnHintConsumed.emit();\n    mockOnSolutionViewedEventEmitter.emit();\n    mockOnPlayerStateChange.emit();\n    mockOnPlayerStateChange.emit(newStateName);\n    tick(100);\n\n    componentInstance.redirectToRefresherExplorationConfirmed = true;\n\n    spyOn(alertsService, 'addWarning');\n    componentInstance.ngOnInit();\n\n    windowRef.nativeWindow.onresize(null);\n    tick(1000);\n  }));\n\n  it('should initialize component as logged in user', fakeAsync(() => {\n    let collectionId = 'id';\n    let expId = 'exp_id';\n    let isInPreviewMode = false;\n    let isIframed = false;\n    let collectionSummary = {\n      is_admin: true,\n      summaries: [],\n      user_email: '',\n      is_topic_manager: false,\n      username: true,\n    };\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', true)\n      )\n    );\n    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(\n      collectionId,\n      null\n    );\n    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n\n    spyOn(\n      readOnlyCollectionBackendApiService,\n      'loadCollectionAsync'\n    ).and.returnValue(\n      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))\n    );\n    spyOn(componentInstance, 'fetchCompletedChaptersCount').and.callThrough();\n    spyOn(\n      learnerDashboardBackendApiService,\n      'fetchLearnerCompletedChaptersCountDataAsync'\n    ).and.returnValue(\n      Promise.resolve({\n        completedChaptersCount: 1,\n      })\n    );\n    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);\n    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(\n      isInPreviewMode\n    );\n    spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n    spyOn(loaderService, 'showLoadingScreen');\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      'oppia_avatar_url'\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'isInQuestionPlayerMode'\n    ).and.returnValues(true, false);\n    spyOn(componentInstance, 'initializePage');\n    spyOn(\n      collectionPlayerBackendApiService,\n      'fetchCollectionSummariesAsync'\n    ).and.returnValue(Promise.resolve(collectionSummary));\n    spyOn(questionPlayerStateService, 'hintUsed');\n    spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n    spyOn(questionPlayerStateService, 'solutionViewed');\n    spyOn(imagePreloaderService, 'onStateChange');\n    spyOn(statsReportingService, 'recordExplorationCompleted');\n    spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n    spyOn(\n      guestCollectionProgressService,\n      'recordExplorationCompletedInCollection'\n    );\n    spyOn(\n      componentInstance,\n      'doesCollectionAllowsGuestProgress'\n    ).and.returnValue(true);\n    spyOn(statsReportingService, 'recordMaybeLeaveEvent');\n    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');\n    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});\n    spyOn(messengerService, 'sendMessage');\n    spyOn(\n      readOnlyExplorationBackendApiService,\n      'loadLatestExplorationAsync'\n    ).and.returnValue(Promise.resolve(sampleExpResponse));\n\n    let mockOnHintConsumed = new EventEmitter();\n    let mockOnSolutionViewedEventEmitter = new EventEmitter();\n    let mockOnPlayerStateChange = new EventEmitter();\n    let mockOnNewCardOpened = new EventEmitter();\n    let mockOnHintsExhausted = new EventEmitter();\n    let mockOnLearnerReallyStuck = new EventEmitter();\n    let mockOnLearnerGetsReallyStuck = new EventEmitter();\n\n    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(\n      mockOnNewCardOpened\n    );\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintsExhausted'\n    ).and.returnValue(mockOnHintsExhausted);\n    spyOnProperty(\n      conceptCardManagerService,\n      'onLearnerGetsReallyStuck'\n    ).and.returnValue(mockOnLearnerGetsReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onLearnerReallyStuck'\n    ).and.returnValue(mockOnLearnerReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintConsumed'\n    ).and.returnValue(mockOnHintConsumed);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onSolutionViewedEventEmitter'\n    ).and.returnValue(mockOnSolutionViewedEventEmitter);\n    spyOnProperty(\n      explorationPlayerStateService,\n      'onPlayerStateChange'\n    ).and.returnValue(mockOnPlayerStateChange);\n\n    componentInstance.nextCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = true;\n    componentInstance.isIframed = false;\n    componentInstance.hasInteractedAtLeastOnce = true;\n    componentInstance.displayedCard = displayedCard;\n\n    componentInstance.ngOnInit();\n    windowRef.nativeWindow.onresize(null);\n\n    // Tick has been used here because\n    // the windowRef.nativeWindow.onresize function\n    // calls adjustPageHeight function where we have used setTimeout\n    // for 100 sec by making tick(100) we make sure setTimout code calls.\n    tick(100);\n  }));\n\n  it('should initialize component as logged out user', fakeAsync(() => {\n    let collectionId = 'id';\n    let expId = 'exp_id';\n    let isInPreviewMode = false;\n    let isIframed = false;\n    let collectionSummary = {\n      is_admin: true,\n      summaries: [],\n      user_email: '',\n      is_topic_manager: false,\n      username: true,\n    };\n    let expResponse = sampleExpResponse;\n    expResponse.is_logged_in = false;\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', false)\n      )\n    );\n    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(\n      collectionId,\n      null\n    );\n    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n\n    spyOn(\n      readOnlyCollectionBackendApiService,\n      'loadCollectionAsync'\n    ).and.returnValue(\n      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))\n    );\n    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);\n    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(\n      isInPreviewMode\n    );\n    spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n    spyOn(loaderService, 'showLoadingScreen');\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      'oppia_avatar_url'\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'isInQuestionPlayerMode'\n    ).and.returnValues(true, false);\n    spyOn(componentInstance, 'initializePage');\n    spyOn(\n      collectionPlayerBackendApiService,\n      'fetchCollectionSummariesAsync'\n    ).and.returnValue(Promise.resolve(collectionSummary));\n    spyOn(questionPlayerStateService, 'hintUsed');\n    spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n    spyOn(questionPlayerStateService, 'solutionViewed');\n    spyOn(imagePreloaderService, 'onStateChange');\n    spyOn(componentInstance, 'fetchCompletedChaptersCount');\n    spyOn(statsReportingService, 'recordExplorationCompleted');\n    spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n    spyOn(\n      guestCollectionProgressService,\n      'recordExplorationCompletedInCollection'\n    );\n    spyOn(\n      componentInstance,\n      'doesCollectionAllowsGuestProgress'\n    ).and.returnValue(true);\n    spyOn(statsReportingService, 'recordMaybeLeaveEvent');\n    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');\n    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});\n    spyOn(messengerService, 'sendMessage');\n    spyOn(\n      readOnlyExplorationBackendApiService,\n      'loadLatestExplorationAsync'\n    ).and.returnValue(Promise.resolve(expResponse));\n    spyOn(\n      editableExplorationBackendApiService,\n      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'\n    ).and.returnValue(\n      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})\n    );\n\n    let mockOnHintConsumed = new EventEmitter();\n    let mockOnSolutionViewedEventEmitter = new EventEmitter();\n    let mockOnPlayerStateChange = new EventEmitter();\n    let mockOnNewCardOpened = new EventEmitter();\n    let mockOnHintsExhausted = new EventEmitter();\n    let mockOnLearnerReallyStuck = new EventEmitter();\n    let mockOnLearnerGetsReallyStuck = new EventEmitter();\n\n    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(\n      mockOnNewCardOpened\n    );\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintsExhausted'\n    ).and.returnValue(mockOnHintsExhausted);\n    spyOnProperty(\n      conceptCardManagerService,\n      'onLearnerGetsReallyStuck'\n    ).and.returnValue(mockOnLearnerGetsReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onLearnerReallyStuck'\n    ).and.returnValue(mockOnLearnerReallyStuck);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintConsumed'\n    ).and.returnValue(mockOnHintConsumed);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onSolutionViewedEventEmitter'\n    ).and.returnValue(mockOnSolutionViewedEventEmitter);\n    spyOnProperty(\n      explorationPlayerStateService,\n      'onPlayerStateChange'\n    ).and.returnValue(mockOnPlayerStateChange);\n\n    componentInstance.nextCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = false;\n    componentInstance.isIframed = false;\n    componentInstance.hasInteractedAtLeastOnce = true;\n    componentInstance.displayedCard = displayedCard;\n\n    componentInstance.ngOnInit();\n    windowRef.nativeWindow.onresize(null);\n\n    // Tick has been used here because\n    // the windowRef.nativeWindow.onresize function\n    // calls adjustPageHeight function where we have used setTimeout\n    // for 100 sec by making tick(100) we make sure setTimout code calls.\n    tick(100);\n  }));\n\n  it(\n    'should convert logged out progress to logged in progress when user ' +\n      'signs in',\n    fakeAsync(() => {\n      let collectionId = 'id';\n      let expId = 'exp_id';\n      let isInPreviewMode = false;\n      let isIframed = false;\n      let collectionSummary = {\n        is_admin: true,\n        summaries: [],\n        user_email: '',\n        is_topic_manager: false,\n        username: true,\n      };\n      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n      spyOn(userService, 'getUserInfoAsync').and.returnValue(\n        Promise.resolve(\n          new UserInfo([], false, false, false, false, false, '', '', '', true)\n        )\n      );\n      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(\n        collectionId,\n        null\n      );\n      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n\n      spyOn(\n        readOnlyCollectionBackendApiService,\n        'loadCollectionAsync'\n      ).and.returnValue(\n        Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))\n      );\n      spyOn(explorationEngineService, 'getExplorationId').and.returnValue(\n        expId\n      );\n      spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(\n        isInPreviewMode\n      );\n      spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n      spyOn(loaderService, 'showLoadingScreen');\n      spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n        'oppia_avatar_url'\n      );\n      spyOn(\n        explorationPlayerStateService,\n        'isInQuestionPlayerMode'\n      ).and.returnValues(true, false);\n      spyOn(componentInstance, 'initializePage');\n      spyOn(\n        collectionPlayerBackendApiService,\n        'fetchCollectionSummariesAsync'\n      ).and.returnValue(Promise.resolve(collectionSummary));\n      spyOn(questionPlayerStateService, 'hintUsed');\n      spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n      spyOn(questionPlayerStateService, 'solutionViewed');\n      spyOn(imagePreloaderService, 'onStateChange');\n      spyOn(statsReportingService, 'recordExplorationCompleted');\n      spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n      spyOn(\n        guestCollectionProgressService,\n        'recordExplorationCompletedInCollection'\n      );\n      spyOn(\n        componentInstance,\n        'doesCollectionAllowsGuestProgress'\n      ).and.returnValue(true);\n      spyOn(statsReportingService, 'recordMaybeLeaveEvent');\n      spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');\n      spyOn(learnerParamsService, 'getAllParams').and.returnValue({});\n      spyOn(messengerService, 'sendMessage');\n      spyOn(\n        readOnlyExplorationBackendApiService,\n        'loadLatestExplorationAsync'\n      ).and.returnValue(Promise.resolve(sampleExpResponse));\n      spyOn(\n        editableExplorationBackendApiService,\n        'changeLoggedOutProgressToLoggedInProgressAsync'\n      ).and.returnValue(Promise.resolve());\n\n      let mockOnHintConsumed = new EventEmitter();\n      let mockOnSolutionViewedEventEmitter = new EventEmitter();\n      let mockOnPlayerStateChange = new EventEmitter();\n      let mockOnNewCardOpened = new EventEmitter();\n      let mockOnHintsExhausted = new EventEmitter();\n      let mockOnLearnerReallyStuck = new EventEmitter();\n      let mockOnLearnerGetsReallyStuck = new EventEmitter();\n\n      spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(\n        mockOnNewCardOpened\n      );\n      spyOnProperty(\n        hintsAndSolutionManagerService,\n        'onHintsExhausted'\n      ).and.returnValue(mockOnHintsExhausted);\n      spyOnProperty(\n        conceptCardManagerService,\n        'onLearnerGetsReallyStuck'\n      ).and.returnValue(mockOnLearnerGetsReallyStuck);\n      spyOnProperty(\n        hintsAndSolutionManagerService,\n        'onLearnerReallyStuck'\n      ).and.returnValue(mockOnLearnerReallyStuck);\n      spyOnProperty(\n        hintsAndSolutionManagerService,\n        'onHintConsumed'\n      ).and.returnValue(mockOnHintConsumed);\n      spyOnProperty(\n        hintsAndSolutionManagerService,\n        'onSolutionViewedEventEmitter'\n      ).and.returnValue(mockOnSolutionViewedEventEmitter);\n      spyOnProperty(\n        explorationPlayerStateService,\n        'onPlayerStateChange'\n      ).and.returnValue(mockOnPlayerStateChange);\n      spyOn(\n        localStorageService,\n        'getUniqueProgressIdOfLoggedOutLearner'\n      ).and.returnValue('abcdef');\n      spyOn(localStorageService, 'removeUniqueProgressIdOfLoggedOutLearner');\n\n      componentInstance.nextCard = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'EndExploration', null),\n        [],\n        null,\n        '',\n        null\n      );\n      componentInstance.isLoggedIn = true;\n      componentInstance.isIframed = false;\n      componentInstance.hasInteractedAtLeastOnce = true;\n      componentInstance.displayedCard = displayedCard;\n\n      componentInstance.ngOnInit();\n      tick(100);\n\n      expect(\n        editableExplorationBackendApiService.changeLoggedOutProgressToLoggedInProgressAsync\n      ).toHaveBeenCalled();\n      expect(\n        localStorageService.removeUniqueProgressIdOfLoggedOutLearner\n      ).toHaveBeenCalled();\n    })\n  );\n\n  it('should show alert when collection summaries are not loaded', fakeAsync(() => {\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', true)\n      )\n    );\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(true);\n    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(\n      'collection_id'\n    );\n    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n    spyOn(\n      localStorageService,\n      'getUniqueProgressIdOfLoggedOutLearner'\n    ).and.returnValue(null);\n    spyOn(\n      collectionPlayerBackendApiService,\n      'fetchCollectionSummariesAsync'\n    ).and.returnValue(Promise.reject());\n    spyOn(alertsService, 'addWarning');\n\n    componentInstance.ngOnInit();\n    tick();\n\n    expect(contextService.isInExplorationEditorPage).toHaveBeenCalled();\n    expect(urlService.getCollectionIdFromExplorationUrl).toHaveBeenCalled();\n    expect(\n      collectionPlayerBackendApiService.fetchCollectionSummariesAsync\n    ).toHaveBeenCalled();\n    expect(alertsService.addWarning).toHaveBeenCalledWith(\n      'There was an error while fetching the collection ' + 'summary.'\n    );\n  }));\n\n  it('should tell if submit button is disabled', () => {\n    let displayedCardIndex = 1;\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(\n      displayedCardIndex\n    );\n    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);\n    spyOn(currentInteractionService, 'isSubmitButtonDisabled').and.returnValue(\n      true\n    );\n\n    expect(componentInstance.isSubmitButtonDisabled()).toBeTrue();\n    expect(componentInstance.isSubmitButtonDisabled()).toBeFalse();\n  });\n\n  it(\n    'should release solution when the learner gets stuck' +\n      ' if no stuck state exists after a predetermined time',\n    fakeAsync(() => {\n      // Release solution if stuck state is null.\n      componentInstance.nextCardIfStuck = null;\n      let solutionSpy = spyOn(\n        hintsAndSolutionManagerService,\n        'releaseSolution'\n      );\n      let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');\n      componentInstance.solutionForState = solutionObjectFactory.createNew(\n        true,\n        'answer',\n        'Html',\n        'XyzID'\n      );\n      componentInstance.numberOfIncorrectSubmissions = 3;\n      componentInstance.triggerIfLearnerStuckAction();\n      tick(\n        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC\n      );\n      tick(ExplorationPlayerConstants.WAIT_BEFORE_REALLY_STUCK_MSEC);\n\n      expect(solutionSpy).toHaveBeenCalled();\n      expect(redirectionSpy).not.toHaveBeenCalled();\n      flush();\n    })\n  );\n\n  it(\n    'should direct the learner to the stuck' +\n      ' when the learner gets stuck and such a state exists after a' +\n      ' predetermined time',\n    fakeAsync(() => {\n      spyOn(componentInstance, 'showPendingCard');\n      spyOn(translateService, 'instant').and.callThrough();\n      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');\n\n      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(\n        false\n      );\n      componentInstance.nextCardIfStuck = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'EndExploration', null),\n        [],\n        null,\n        '',\n        null\n      );\n      componentInstance.triggerIfLearnerStuckAction();\n      tick(\n        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC\n      );\n\n      expect(translateService.instant).toHaveBeenCalledWith(\n        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'\n      );\n      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(\n        true\n      );\n      flush();\n    })\n  );\n\n  it(\n    'should immediately release solution when the learner gets stuck' +\n      ' if no stuck state exists',\n    fakeAsync(() => {\n      // Release solution if stuck state is null.\n      componentInstance.nextCardIfStuck = null;\n      let solutionSpy = spyOn(\n        hintsAndSolutionManagerService,\n        'releaseSolution'\n      );\n      let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');\n      componentInstance.solutionForState = solutionObjectFactory.createNew(\n        true,\n        'answer',\n        'Html',\n        'XyzID'\n      );\n      componentInstance.numberOfIncorrectSubmissions = 3;\n      componentInstance.triggerIfLearnerStuckActionDirectly();\n\n      expect(solutionSpy).toHaveBeenCalled();\n      expect(redirectionSpy).not.toHaveBeenCalled();\n    })\n  );\n\n  it(\n    'should immediately direct the learner to the stuck' +\n      ' when the learner gets stuck and such a state exists',\n    fakeAsync(() => {\n      spyOn(translateService, 'instant').and.callThrough();\n      spyOn(componentInstance, 'showPendingCard');\n      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');\n      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(\n        false\n      );\n      componentInstance.nextCardIfStuck = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'EndExploration', null),\n        [],\n        null,\n        '',\n        null\n      );\n      componentInstance.triggerIfLearnerStuckActionDirectly();\n\n      expect(translateService.instant).toHaveBeenCalledWith(\n        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'\n      );\n      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(\n        true\n      );\n    })\n  );\n\n  it('should redirect the learner to stuck state', fakeAsync(() => {\n    spyOn(componentInstance, 'showPendingCard');\n    componentInstance.nextCardIfStuck = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n\n    componentInstance.triggerRedirectionToStuckState();\n\n    expect(componentInstance.nextCard).toEqual(\n      componentInstance.nextCardIfStuck\n    );\n    expect(componentInstance.showPendingCard).toHaveBeenCalled();\n  }));\n\n  it('should fetch completed chapters count if user is logged in', fakeAsync(() => {\n    spyOn(\n      learnerDashboardBackendApiService,\n      'fetchLearnerCompletedChaptersCountDataAsync'\n    ).and.returnValue(\n      Promise.resolve({\n        completedChaptersCount: 1,\n      })\n    );\n    componentInstance.isLoggedIn = false;\n\n    componentInstance.fetchCompletedChaptersCount();\n    tick();\n\n    expect(\n      learnerDashboardBackendApiService.fetchLearnerCompletedChaptersCountDataAsync\n    ).not.toHaveBeenCalled();\n    expect(componentInstance.completedChaptersCount).toBeUndefined();\n\n    componentInstance.isLoggedIn = true;\n\n    componentInstance.fetchCompletedChaptersCount();\n    tick();\n\n    expect(\n      learnerDashboardBackendApiService.fetchLearnerCompletedChaptersCountDataAsync\n    ).toHaveBeenCalled();\n\n    expect(componentInstance.completedChaptersCount).toEqual(1);\n  }));\n\n  it('should tell if collection allows guest progress', () => {\n    expect(componentInstance.doesCollectionAllowsGuestProgress('')).toBeFalse();\n  });\n\n  it('should change card', () => {\n    spyOn(playerPositionService, 'recordNavigationButtonClick');\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(explorationEngineService.onUpdateActiveStateIfInEditor, 'emit');\n    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(\n      'state_name'\n    );\n    spyOn(playerPositionService, 'changeCurrentQuestion');\n\n    componentInstance.changeCard(1);\n\n    expect(\n      playerPositionService.recordNavigationButtonClick\n    ).toHaveBeenCalled();\n    expect(playerPositionService.setDisplayedCardIndex).toHaveBeenCalled();\n    expect(\n      explorationEngineService.onUpdateActiveStateIfInEditor.emit\n    ).toHaveBeenCalled();\n    expect(playerPositionService.getCurrentStateName).toHaveBeenCalled();\n    expect(playerPositionService.changeCurrentQuestion).toHaveBeenCalled();\n  });\n\n  it(\n    'should navigate to the most recently reached checkpoint ' +\n      'on page load if user is logged in',\n    fakeAsync(() => {\n      let stateCardNames = ['Start', 'Mid', 'End'];\n      let stateCards: StateCard[] = [];\n      for (let stateName in stateCardNames) {\n        stateCards.push(\n          new StateCard(\n            stateName,\n            '<p>Testing</p>',\n            null,\n            new Interaction([], [], null, null, [], 'Continue', null),\n            [],\n            null,\n            'content',\n            null\n          )\n        );\n      }\n      let alertMessageElement = document.createElement('div');\n      alertMessageElement.className = 'oppia-exploration-checkpoints-message';\n      const expResponse = explorationResponse;\n      expResponse.exploration.states.Mid.card_is_checkpoint = true;\n\n      spyOn(userService, 'getUserInfoAsync').and.returnValue(\n        Promise.resolve(\n          new UserInfo([], false, false, false, false, false, '', '', '', true)\n        )\n      );\n      spyOn(playerPositionService, 'init').and.callFake(callb => {\n        callb();\n      });\n      componentInstance.questionPlayerConfig = {};\n      spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');\n      spyOn(playerPositionService.onLoadedMostRecentCheckpoint, 'emit');\n      spyOn(focusManagerService, 'setFocusIfOnDesktop');\n      spyOn(loaderService, 'hideLoadingScreen');\n      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n      spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValues(\n        'en',\n        'en',\n        'en',\n        'pq'\n      );\n      spyOn(\n        explorationPlayerStateService,\n        'initializeQuestionPlayer'\n      ).and.callFake((config, callb, questionAreAvailable) => {\n        callb(displayedCard, 'label');\n      });\n      spyOn(\n        explorationPlayerStateService,\n        'isInQuestionPlayerMode'\n      ).and.returnValue(false);\n      spyOn(componentInstance, 'adjustPageHeight');\n      spyOn(playerPositionService.onNewCardOpened, 'emit');\n      componentInstance.isIframed = true;\n      spyOn(playerPositionService, 'setDisplayedCardIndex');\n      spyOn(playerPositionService, 'getCurrentStateName').and.returnValues(\n        'Start',\n        'Mid',\n        'End'\n      );\n      spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);\n      spyOn(\n        readOnlyExplorationBackendApiService,\n        'loadLatestExplorationAsync'\n      ).and.returnValue(Promise.resolve(expResponse));\n      spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue(\n        ['Start', 'Mid']\n      );\n\n      spyOn(explorationEngineService, 'getStateCardByName').and.returnValues(\n        stateCards[0],\n        stateCards[1],\n        stateCards[2]\n      );\n\n      spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);\n      spyOn(explorationEngineService, 'getState').and.returnValue(\n        stateObjectFactory.createFromBackendDict(\n          'Mid',\n          expResponse.exploration.states.Mid\n        )\n      );\n      spyOn(document, 'querySelector')\n        .withArgs('.oppia-exploration-checkpoints-message')\n        .and.returnValue(alertMessageElement);\n\n      componentInstance.explorationId = expResponse.exploration_id;\n      componentInstance.displayedCard = displayedCard;\n      componentInstance.isLoggedIn = true;\n      componentInstance.isIframed = false;\n      componentInstance.alertMessageTimeout = 5;\n\n      componentInstance.initializePage();\n      tick(100);\n\n      expect(componentInstance.prevSessionStatesProgress).toEqual(['Start']);\n      expect(componentInstance.mostRecentlyReachedCheckpoint).toBe('Mid');\n    })\n  );\n\n  it(\n    'should display the exploration after the the progress reminder modal' +\n      'has loaded',\n    () => {\n      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n      spyOn(contextService, 'isInExplorationPlayerPage').and.returnValue(true);\n      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(\n        null\n      );\n      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n      spyOn(explorationEngineService, 'getExplorationId').and.returnValue(\n        'expl_1'\n      );\n      spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(false);\n      spyOn(urlService, 'isIframed').and.returnValue(false);\n\n      componentInstance.ngOnInit();\n      expect(componentInstance.hasFullyLoaded).toBe(false);\n      explorationPlayerStateService.onShowProgressModal.emit();\n      expect(componentInstance.hasFullyLoaded).toBe(true);\n    }\n  );\n\n  it('should determine if chapter was completed for the first time', fakeAsync(() => {\n    componentInstance.isLoggedIn = true;\n    componentInstance.completedChaptersCount = 0;\n    spyOn(explorationPlayerStateService, 'recordNewCardAdded');\n    spyOn(focusManagerService, 'setFocusIfOnDesktop');\n    spyOn(componentInstance, 'scrollToTop');\n    spyOn(playerPositionService.onNewCardOpened, 'emit');\n    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(\n      'en'\n    );\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);\n    spyOn(contentTranslationManagerService, 'displayTranslations');\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);\n    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(playerPositionService, 'changeCurrentQuestion');\n    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(true);\n    spyOn(urlService, 'getUrlParams').and.returnValue({\n      topic_url_fragment: 'topicUrlFragment',\n      classroom_url_fragment: 'classroomUrlFragment',\n      story_url_fragment: 'storyUrlFragment',\n      node_id: 'nodeId',\n    });\n    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');\n    let readOnlyStoryNode = new ReadOnlyStoryNode(\n      'nodeId',\n      '',\n      '',\n      [],\n      [],\n      [],\n      '',\n      false,\n      '',\n      null,\n      false,\n      '',\n      ''\n    );\n    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync').and.returnValue(\n      Promise.resolve(\n        new StoryPlaythrough(\n          'nodeId',\n          [readOnlyStoryNode, readOnlyStoryNode],\n          '',\n          '',\n          '',\n          ''\n        )\n      )\n    );\n    spyOn(\n      learnerDashboardBackendApiService,\n      'fetchLearnerCompletedChaptersCountDataAsync'\n    ).and.returnValue(\n      Promise.resolve({\n        completedChaptersCount: 1,\n      })\n    );\n    spyOn(\n      storyViewerBackendApiService,\n      'recordChapterCompletionAsync'\n    ).and.returnValue(\n      Promise.resolve({\n        readyForReviewTest: true,\n        nextNodeId: '',\n        summaries: [],\n      })\n    );\n\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = true;\n    spyOn(\n      conversationFlowService,\n      'isSupplementalCardNonempty'\n    ).and.returnValues(false, true, true, false);\n    spyOn(componentInstance, 'animateToOneCard').and.callFake(callb => {\n      callb();\n    });\n\n    componentInstance.showPendingCard();\n    tick(1000);\n\n    expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(true);\n    expect(componentInstance.completedChaptersCount).toBe(1);\n\n    componentInstance.completedChaptersCount = 1;\n    componentInstance.chapterIsCompletedForTheFirstTime = false;\n\n    componentInstance.showPendingCard();\n    tick(1000);\n\n    expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(false);\n\n    flush();\n  }));\n\n  it('should unsubscribe on destroy', () => {\n    spyOn(componentInstance.directiveSubscriptions, 'unsubscribe');\n\n    componentInstance.ngOnDestroy();\n\n    expect(\n      componentInstance.directiveSubscriptions.unsubscribe\n    ).toHaveBeenCalled();\n  });\n\n  it('should always ask learner for answer details', () => {\n    spyOn(\n      explorationEngineService,\n      'getAlwaysAskLearnerForAnswerDetails'\n    ).and.returnValues(true, false);\n\n    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeTrue();\n    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeFalse();\n  });\n\n  it('should get can ask learner for answer info', () => {\n    spyOn(\n      learnerAnswerInfoService,\n      'getCanAskLearnerForAnswerInfo'\n    ).and.returnValues(true, false);\n\n    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeTrue();\n    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeFalse();\n  });\n\n  it('should initialize learner answer info service', () => {\n    spyOn(learnerAnswerInfoService, 'initLearnerAnswerInfoService');\n\n    componentInstance.initLearnerAnswerInfoService(\n      null,\n      null,\n      null,\n      null,\n      false\n    );\n\n    expect(\n      learnerAnswerInfoService.initLearnerAnswerInfoService\n    ).toHaveBeenCalled();\n  });\n\n  it('should tell if correctness footer is enabled', () => {\n    componentInstance.answerIsCorrect = true;\n\n    spyOn(\n      playerPositionService,\n      'hasLearnerJustSubmittedAnAnswer'\n    ).and.returnValue(true);\n\n    expect(componentInstance.isCorrectnessFooterEnabled()).toBeTrue();\n  });\n\n  it('should get static image url', () => {\n    let imageUrl = 'image_url';\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      imageUrl\n    );\n\n    expect(componentInstance.getStaticImageUrl('')).toEqual(imageUrl);\n  });\n\n  it('should get content focus label', () => {\n    let index = 1;\n\n    expect(componentInstance.getContentFocusLabel(index)).toEqual(\n      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index\n    );\n  });\n\n  it('should reload exploration', () => {\n    spyOn(windowRef.nativeWindow.location, 'reload');\n\n    componentInstance.reloadExploration();\n\n    expect(windowRef.nativeWindow.location.reload).toHaveBeenCalled();\n  });\n\n  it('should tell if display card is terminal', () => {\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n\n    expect(componentInstance.isOnTerminalCard()).toBeTrue();\n  });\n\n  it('should return to exploration after concept card is compeleted', () => {\n    let numCards = 20;\n    spyOn(playerTranscriptService, 'addPreviousCard');\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(numCards);\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n\n    componentInstance.returnToExplorationAfterConceptCard();\n\n    expect(playerTranscriptService.addPreviousCard).toHaveBeenCalled();\n    expect(playerTranscriptService.getNumCards).toHaveBeenCalled();\n    expect(\n      playerPositionService.setDisplayedCardIndex\n    ).toHaveBeenCalledOnceWith(numCards - 1);\n  });\n\n  it('should tell if current is at end of transcript', () => {\n    let index = 1;\n    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(\n      index\n    );\n\n    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeTrue();\n    expect(playerTranscriptService.isLastCard).toHaveBeenCalledWith(index);\n  });\n\n  it('should hide loading screen if question are not available', () => {\n    spyOn(loaderService, 'hideLoadingScreen');\n\n    componentInstance.showQuestionAreNotAvailable();\n\n    expect(loaderService.hideLoadingScreen).toHaveBeenCalled();\n  });\n\n  it('should initialize page', fakeAsync(() => {\n    spyOn(playerPositionService, 'init').and.callFake(callb => {\n      callb();\n    });\n    spyOn(urlService, 'getUrlParams').and.returnValues(\n      {\n        lang: 'pq',\n      },\n      {\n        lang: 'en',\n      },\n      {\n        lang: 'en',\n      },\n      {\n        lang: 'pq',\n      }\n    );\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', true)\n      )\n    );\n    componentInstance.questionPlayerConfig = {};\n    spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');\n    spyOn(focusManagerService, 'setFocusIfOnDesktop');\n    spyOn(loaderService, 'hideLoadingScreen');\n    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValues(\n      'pq',\n      'en',\n      'en',\n      'pq'\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'initializeQuestionPlayer'\n    ).and.callFake((config, callb, questionAreAvailable) => {\n      callb(displayedCard, 'label');\n    });\n    spyOn(componentInstance, 'adjustPageHeight');\n    spyOn(playerPositionService.onNewCardOpened, 'emit');\n    componentInstance.isIframed = true;\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);\n\n    componentInstance.explorationId = explorationResponse.exploration_id;\n    componentInstance.displayedCard = displayedCard;\n\n    componentInstance.initializePage();\n    tick(100);\n    expect(componentInstance.hasInteractedAtLeastOnce).toBeFalse();\n    expect(componentInstance.recommendedExplorationSummaries).toEqual([]);\n    expect(playerPositionService.init).toHaveBeenCalled();\n\n    componentInstance.questionPlayerConfig = null;\n    spyOn(playerPositionService, 'getDisplayedCardIndex');\n    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);\n    spyOn(playerPositionService.onActiveCardChanged, 'emit');\n    spyOn(audioPlayerService.onAutoplayAudio, 'emit');\n    spyOn(autogeneratedAudioPlayerService, 'cancel');\n    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);\n    spyOn(componentInstance, 'getContentFocusLabel');\n    spyOn(explorationPlayerStateService, 'initializePlayer').and.callFake(\n      callb => {\n        callb(displayedCard, 'label');\n      }\n    );\n\n    componentInstance._nextFocusLabel = 'focus_label';\n    componentInstance.initializePage();\n    tick(100);\n\n    componentInstance.questionPlayerConfig = null;\n    let topicIdToPrerequisiteTopicIds = {\n      topicId1: [],\n      topicId2: ['topicId1'],\n      topicId3: ['topicId2'],\n    };\n\n    componentInstance.diagnosticTestTopicTrackerModel =\n      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds);\n\n    spyOn(explorationPlayerStateService, 'initializeDiagnosticPlayer');\n\n    componentInstance.initializePage();\n    tick(100);\n\n    expect(playerPositionService.init).toHaveBeenCalled();\n    expect(\n      explorationPlayerStateService.initializeDiagnosticPlayer\n    ).toHaveBeenCalled();\n  }));\n\n  it('should register analytics when user visit using iframe', () => {\n    spyOn(siteAnalyticsService, 'registerVisitOppiaFromIframeEvent');\n\n    componentInstance.onNavigateFromIframe();\n\n    expect(\n      siteAnalyticsService.registerVisitOppiaFromIframeEvent\n    ).toHaveBeenCalled();\n  });\n\n  it('should submit answer from progress nav and toggle submit clicked', () => {\n    componentInstance.displayedCard = displayedCard;\n    spyOn(displayedCard, 'toggleSubmitClicked');\n    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');\n    spyOn(currentInteractionService, 'submitAnswer');\n\n    componentInstance.submitAnswerFromProgressNav();\n\n    expect(currentInteractionService.submitAnswer).toHaveBeenCalled();\n    expect(displayedCard.toggleSubmitClicked).toHaveBeenCalledOnceWith(true);\n  });\n\n  it('should show learn again button', () => {\n    componentInstance.displayedCard = {\n      getStateName: () => null,\n    } as StateCard;\n\n    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(\n      false,\n      true,\n      true,\n      true\n    );\n\n    expect(componentInstance.isLearnAgainButton()).toBeFalse();\n\n    componentInstance.displayedCard = displayedCard;\n\n    expect(componentInstance.isLearnAgainButton()).toBeFalse();\n\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'Continue', null),\n      [],\n      null,\n      '',\n      null\n    );\n\n    expect(componentInstance.isLearnAgainButton()).toBeFalse();\n\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'ImageClickInput', null),\n      [],\n      null,\n      '',\n      null\n    );\n\n    componentInstance.pendingCardWasSeenBefore = true;\n    componentInstance.answerIsCorrect = false;\n\n    expect(componentInstance.isLearnAgainButton()).toBeTrue();\n  });\n\n  it('should jump to the revision state via changing card', () => {\n    const currentCard = new StateCard(\n      'currentCard',\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'Continue', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.displayedCard = currentCard;\n\n    componentInstance.nextCard = new StateCard(\n      'revisionState',\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'ImageClickInput', null),\n      [],\n      null,\n      '',\n      null\n    );\n    spyOn(componentInstance, 'isLearnAgainButton').and.returnValue(true);\n    spyOn(playerTranscriptService, 'findIndexOfLatestStateWithName')\n      .withArgs('revisionState')\n      .and.returnValue(2);\n    const changeCard = spyOn(componentInstance, 'changeCard');\n    const recordNewCardAdded = spyOn(\n      explorationPlayerStateService,\n      'recordNewCardAdded'\n    );\n\n    componentInstance.showUpcomingCard();\n\n    expect(currentCard.isCompleted()).toBeFalse();\n    expect(recordNewCardAdded).not.toHaveBeenCalled();\n    expect(changeCard).toHaveBeenCalledWith(2);\n  });\n\n  it('should adjust page height on scroll', fakeAsync(() => {\n    componentInstance.lastRequestedHeight = document.body.scrollHeight + 100;\n    componentInstance.lastRequestedScroll = false;\n    spyOn(messengerService, 'sendMessage');\n\n    let callbSpy = jasmine.createSpy('adjust page height callback');\n    let scrollValue = true;\n\n    componentInstance.adjustPageHeight(scrollValue, callbSpy);\n    tick(150);\n\n    expect(messengerService.sendMessage).toHaveBeenCalled();\n    expect(componentInstance.lastRequestedScroll).toEqual(scrollValue);\n    expect(callbSpy).toHaveBeenCalled();\n  }));\n\n  it('should get exploration link', () => {\n    componentInstance.recommendedExplorationSummaries = [{id: ''}];\n\n    expect(componentInstance.getExplorationLink()).toEqual('#');\n\n    let expId = '123';\n    let collectionId = '980';\n    let storyUrlFragment = 'story_fragment';\n    let nodeId = 'node_id';\n    let topicUrlFragment = 'topic_url_fragment';\n    let classroomUrlFragment = 'classroom_fragment';\n    componentInstance.recommendedExplorationSummaries = [\n      {\n        id: expId,\n        parentExplorationIds: ['4566', 's9af0'],\n        nextNodeId: nodeId,\n      },\n    ];\n    spyOn(urlService, 'getUrlParams').and.returnValues(\n      {\n        collection_id: collectionId,\n      },\n      {\n        story_url_fragment: storyUrlFragment,\n        node_id: nodeId,\n        topic_url_fragment: topicUrlFragment,\n        classroom_url_fragment: classroomUrlFragment,\n      },\n      {\n        story_url_fragment: storyUrlFragment,\n        node_id: nodeId,\n        topic_url_fragment: topicUrlFragment,\n        classroom_url_fragment: classroomUrlFragment,\n      }\n    );\n\n    expect(componentInstance.getExplorationLink()).toEqual(\n      '/explore/' +\n        expId +\n        '?collection_id=' +\n        collectionId +\n        '&parent=' +\n        componentInstance.recommendedExplorationSummaries[0]\n          .parentExplorationIds[0]\n    );\n    expect(urlService.getUrlParams).toHaveBeenCalled();\n\n    componentInstance.parentExplorationIds = null;\n    componentInstance.storyNodeIdToAdd = nodeId;\n\n    expect(componentInstance.getExplorationLink()).toEqual(\n      '/explore/' +\n        expId +\n        '?parent=' +\n        componentInstance.recommendedExplorationSummaries[0]\n          .parentExplorationIds[0] +\n        '&topic_url_fragment=' +\n        topicUrlFragment +\n        '&classroom_url_fragment=' +\n        classroomUrlFragment +\n        '&story_url_fragment=' +\n        storyUrlFragment +\n        '&node_id=' +\n        nodeId\n    );\n\n    spyOn(urlService, 'getPathname').and.returnValue(\n      '/story/story-url-fragment'\n    );\n    spyOn(urlService, 'getStoryUrlFragmentFromLearnerUrl').and.returnValue(\n      storyUrlFragment\n    );\n    spyOn(urlService, 'getTopicUrlFragmentFromLearnerUrl').and.returnValue(\n      topicUrlFragment\n    );\n    spyOn(urlService, 'getClassroomUrlFragmentFromLearnerUrl').and.returnValue(\n      classroomUrlFragment\n    );\n\n    expect(componentInstance.getExplorationLink()).toEqual(\n      '/explore/' +\n        expId +\n        '?parent=' +\n        componentInstance.recommendedExplorationSummaries[0]\n          .parentExplorationIds[0] +\n        '&topic_url_fragment=' +\n        topicUrlFragment +\n        '&classroom_url_fragment=' +\n        classroomUrlFragment +\n        '&story_url_fragment=' +\n        storyUrlFragment +\n        '&node_id=' +\n        nodeId\n    );\n    expect(urlService.getPathname).toHaveBeenCalled();\n    expect(urlService.getStoryUrlFragmentFromLearnerUrl).toHaveBeenCalled();\n    expect(urlService.getTopicUrlFragmentFromLearnerUrl).toHaveBeenCalled();\n    expect(urlService.getClassroomUrlFragmentFromLearnerUrl).toHaveBeenCalled();\n  });\n\n  it('should tell if current supplemental card is non empty', () => {\n    componentInstance.displayedCard = displayedCard;\n    spyOn(\n      conversationFlowService,\n      'isSupplementalCardNonempty'\n    ).and.returnValues(true, false);\n\n    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeTrue();\n    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeFalse();\n  });\n\n  it('should tell if supplemental nav is shown', () => {\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'NumberWithUnits', null),\n      [],\n      null,\n      '',\n      null\n    );\n    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(\n      false,\n      true\n    );\n    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(\n      true\n    );\n    expect(componentInstance.isSupplementalNavShown()).toBeFalse();\n    expect(componentInstance.isSupplementalNavShown()).toBeTrue();\n  });\n\n  it('should show pending card', fakeAsync(() => {\n    spyOn(explorationPlayerStateService, 'recordNewCardAdded');\n    spyOn(focusManagerService, 'setFocusIfOnDesktop');\n    spyOn(componentInstance, 'scrollToTop');\n    spyOn(playerPositionService.onNewCardOpened, 'emit');\n    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(\n      'en'\n    );\n    spyOn(conversationFlowService, 'addNewCard');\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);\n    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(playerPositionService, 'changeCurrentQuestion');\n    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(true);\n    spyOn(urlService, 'getUrlParams').and.returnValue({\n      topic_url_fragment: 'topicUrlFragment',\n      classroom_url_fragment: 'classroomUrlFragment',\n      story_url_fragment: 'storyUrlFragment',\n      node_id: 'nodeId',\n    });\n    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');\n    let readOnlyStoryNode = new ReadOnlyStoryNode(\n      'nodeId',\n      '',\n      '',\n      [],\n      [],\n      [],\n      '',\n      false,\n      '',\n      null,\n      false,\n      '',\n      ''\n    );\n    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync').and.returnValue(\n      Promise.resolve(\n        new StoryPlaythrough(\n          'nodeId',\n          [readOnlyStoryNode, readOnlyStoryNode],\n          '',\n          '',\n          '',\n          ''\n        )\n      )\n    );\n    spyOn(\n      storyViewerBackendApiService,\n      'recordChapterCompletionAsync'\n    ).and.returnValues(\n      Promise.resolve({\n        readyForReviewTest: true,\n        nextNodeId: '',\n        summaries: [],\n      })\n    );\n\n    componentInstance.alertMessageTimeout = 5;\n\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = true;\n    spyOn(\n      conversationFlowService,\n      'isSupplementalCardNonempty'\n    ).and.returnValues(false, true, true, false);\n    spyOn(componentInstance, 'animateToOneCard').and.callFake(callb => {\n      callb();\n    });\n\n    componentInstance.showPendingCard();\n    tick(1000);\n\n    componentInstance.isLoggedIn = false;\n\n    componentInstance.showPendingCard();\n    tick(1000);\n\n    expect(explorationPlayerStateService.recordNewCardAdded).toHaveBeenCalled();\n  }));\n\n  it('should scroll to bottom', fakeAsync(() => {\n    componentInstance.scrollToBottom();\n    tick(200);\n\n    spyOn(window, '$').and.returnValue({\n      offset: () => {\n        return {top: 10};\n      },\n      outerHeight: () => 10,\n      scrollTop: () => 0,\n      height: () => 0,\n      animate: () => {},\n    } as unknown as JQLite);\n\n    componentInstance.scrollToBottom();\n    tick(200);\n    expect(window.$).toHaveBeenCalled();\n  }));\n\n  it('should scroll to top', fakeAsync(() => {\n    let animateSpy = jasmine.createSpy('jquery spy');\n    spyOn(window, '$').and.returnValue({\n      animate: animateSpy,\n    } as unknown as JQLite);\n    componentInstance.scrollToTop();\n    tick(1000);\n    expect(animateSpy).toHaveBeenCalled();\n  }));\n\n  it('should show upcoming card', () => {\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);\n    spyOn(displayedCard, 'getStateName').and.returnValue(null);\n    componentInstance.displayedCard = displayedCard;\n    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(\n      false,\n      true,\n      true,\n      true,\n      true\n    );\n    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(\n      true,\n      false,\n      false,\n      false,\n      false\n    );\n    spyOn(componentInstance, 'returnToExplorationAfterConceptCard');\n\n    componentInstance.showUpcomingCard();\n\n    componentInstance.questionSessionCompleted = true;\n    spyOn(questionPlayerStateService.onQuestionSessionCompleted, 'emit');\n    spyOn(questionPlayerStateService, 'getQuestionPlayerStateData');\n\n    componentInstance.showUpcomingCard();\n\n    componentInstance.questionSessionCompleted = false;\n    componentInstance.moveToExploration = true;\n    spyOn(explorationPlayerStateService, 'moveToExploration');\n\n    componentInstance.showUpcomingCard();\n\n    componentInstance.moveToExploration = false;\n    let stateCard = new StateCard(\n      'stateName',\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    stateCard.markAsCompleted();\n    componentInstance.displayedCard = stateCard;\n    componentInstance.nextCard = stateCard;\n    componentInstance.conceptCard = new ConceptCard(\n      new SubtitledHtml('', ''),\n      [],\n      null\n    );\n    spyOn(explorationPlayerStateService, 'recordNewCardAdded');\n    spyOn(conversationFlowService, 'addNewCard');\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);\n    spyOn(\n      conversationFlowService,\n      'isSupplementalCardNonempty'\n    ).and.returnValues(false, true);\n    spyOn(playerTranscriptService, 'getCard');\n    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(componentInstance, 'animateToTwoCards').and.callFake(callb => {\n      callb();\n    });\n    spyOn(playerPositionService, 'changeCurrentQuestion');\n    spyOn(componentInstance, 'showPendingCard');\n    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);\n    spyOn(\n      explorationEngineService,\n      'getAuthorRecommendedExpIdsByStateName'\n    ).and.returnValue([]);\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(true);\n    spyOn(userService, 'setReturnUrl');\n    spyOn(urlService, 'getUrlParams').and.returnValue({\n      topic_url_fragment: 'topicUrlFragment',\n      classroom_url_fragment: 'classroomUrlFragment',\n      story_url_fragment: 'storyUrlFragment',\n      node_id: 'nodeId',\n    });\n\n    componentInstance.isLoggedIn = false;\n\n    componentInstance.showUpcomingCard();\n\n    componentInstance.conceptCard = null;\n    componentInstance.answerIsCorrect = true;\n\n    componentInstance.showUpcomingCard();\n  });\n\n  it('should submit answer and reset current answer state', fakeAsync(() => {\n    spyOn(displayedCard, 'updateCurrentAnswer');\n    componentInstance.displayedCard = displayedCard;\n    componentInstance.answerIsBeingProcessed = true;\n\n    componentInstance.submitAnswer('', null);\n\n    expect(displayedCard.updateCurrentAnswer).toHaveBeenCalledOnceWith(null);\n    componentInstance.answerIsBeingProcessed = false;\n    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');\n    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(\n      true\n    );\n    let explorationModeSpy = spyOn(\n      explorationPlayerStateService,\n      'isPresentingIsolatedQuestions'\n    );\n    explorationModeSpy.and.returnValue(false);\n    componentInstance.isInPreviewMode = false;\n    spyOn(fatigueDetectionService, 'recordSubmissionTimestamp');\n    spyOn(fatigueDetectionService, 'isSubmittingTooFast').and.returnValues(\n      true,\n      false\n    );\n    spyOn(fatigueDetectionService, 'displayTakeBreakMessage');\n    let lastCardInteraction = interactionObjectFactory.createFromBackendDict({\n      id: 'TextInput',\n      answer_groups: [],\n      default_outcome: null,\n      confirmed_unclassified_answers: [],\n      customization_args: {\n        rows: {\n          value: true,\n        },\n        placeholder: {\n          value: 1,\n        },\n      },\n      hints: [],\n      solution: null,\n    });\n    let lastCard = StateCard.createNewCard(\n      'Card 1',\n      'Content html',\n      'Interaction text',\n      lastCardInteraction,\n      null,\n      'content_id',\n      audioTranslationLanguageService\n    );\n    spyOn(playerTranscriptService, 'getLastCard').and.returnValue(lastCard);\n    spyOn(explorationPlayerStateService.onOppiaFeedbackAvailable, 'emit');\n    spyOn(componentInstance, 'showPendingCard');\n    componentInstance.submitAnswer('', null);\n\n    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(\n      false,\n      false,\n      false,\n      true\n    );\n    spyOn(componentInstance, 'initLearnerAnswerInfoService');\n    spyOn(explorationEngineService, 'getState');\n    spyOn(numberAttemptsService, 'submitAttempt');\n    spyOn(playerTranscriptService, 'addNewInput');\n    spyOn(componentInstance, 'getCanAskLearnerForAnswerInfo').and.returnValues(\n      true,\n      false\n    );\n    spyOn(playerTranscriptService, 'addNewResponse');\n    spyOn(learnerAnswerInfoService, 'getSolicitAnswerDetailsQuestion');\n    spyOn(playerPositionService.onHelpCardAvailable, 'emit');\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n\n    componentInstance.submitAnswer('', null);\n    tick(200);\n\n    spyOn(playerPositionService, 'recordAnswerSubmission');\n    spyOn(\n      explorationPlayerStateService,\n      'getCurrentEngineService'\n    ).and.returnValue(explorationEngineService);\n    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(\n      'en'\n    );\n\n    let callback = (\n      answer: string,\n      interactionRulesService: InteractionRulesService,\n      successCallback: (\n        nextCard: StateCard,\n        refreshInteraction: boolean,\n        feedbackHtml: string,\n        feedbackAudioTranslations: BindableVoiceovers,\n        refresherExplorationId: string,\n        missingPrerequisiteSkillId: string,\n        remainOnCurrentCard: boolean,\n        taggedSkillMisconceptionId: string,\n        wasOldStateInitial: boolean,\n        isFirstHit: boolean,\n        isFinalQuestion: boolean,\n        nextCardIfReallyStuck: StateCard | null,\n        focusLabel: string\n      ) => void\n    ) => {\n      let stateCard = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'EndExploration', null),\n        [],\n        null,\n        '',\n        null\n      );\n      successCallback(\n        stateCard,\n        true,\n        'feedback',\n        null,\n        'refresherId',\n        '',\n        false,\n        '',\n        true,\n        false,\n        true,\n        null,\n        ''\n      );\n      successCallback(\n        stateCard,\n        true,\n        '',\n        null,\n        'refresherId',\n        '',\n        false,\n        '',\n        true,\n        false,\n        true,\n        null,\n        ''\n      );\n      successCallback(\n        stateCard,\n        true,\n        'feedback',\n        null,\n        'refresherId',\n        '',\n        false,\n        '',\n        true,\n        false,\n        false,\n        null,\n        ''\n      );\n      successCallback(\n        stateCard,\n        true,\n        '',\n        null,\n        'refresherId',\n        '',\n        false,\n        '',\n        true,\n        false,\n        false,\n        null,\n        ''\n      );\n      successCallback(\n        stateCard,\n        true,\n        'feedback',\n        null,\n        '',\n        'skill_id',\n        true,\n        '',\n        true,\n        false,\n        false,\n        null,\n        ''\n      );\n      explorationModeSpy.and.returnValue(true);\n      componentInstance.displayedCard = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'TextInput', null),\n        [],\n        null,\n        '',\n        null\n      );\n      spyOn(\n        explorationPlayerStateService,\n        'isInDiagnosticTestPlayerMode'\n      ).and.returnValue(true);\n      successCallback(\n        stateCard,\n        true,\n        'feedback',\n        null,\n        '',\n        'skill_id',\n        true,\n        '',\n        true,\n        false,\n        false,\n        null,\n        ''\n      );\n      componentInstance.displayedCard = new StateCard(\n        null,\n        null,\n        null,\n        new Interaction([], [], null, null, [], 'ImageClickInput', null),\n        [],\n        null,\n        '',\n        null\n      );\n      explorationModeSpy.and.returnValue(false);\n      successCallback(\n        stateCard,\n        true,\n        'feedback',\n        null,\n        'refresherId',\n        'skill_id',\n        true,\n        '',\n        true,\n        false,\n        false,\n        null,\n        ''\n      );\n      return false;\n    };\n    spyOn(\n      answerClassificationService,\n      'isAnswerOnlyMisspelled'\n    ).and.returnValue(true);\n    spyOn(explorationEngineService, 'submitAnswer').and.callFake(callback);\n    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(\n      'oldState'\n    );\n    spyOn(statsReportingService, 'recordStateTransition');\n    spyOn(learnerParamsService, 'getAllParams');\n    spyOn(statsReportingService, 'recordStateCompleted');\n    spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n    spyOn(\n      explorationPlayerStateService,\n      'isInQuestionPlayerMode'\n    ).and.returnValue(true);\n    spyOn(componentInstance, 'showUpcomingCard');\n    spyOn(fatigueDetectionService, 'reset');\n    spyOn(numberAttemptsService, 'reset');\n    spyOn(questionPlayerStateService, 'answerSubmitted');\n    spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n    spyOn(playerTranscriptService, 'updateLatestInteractionHtml');\n    spyOn(\n      conceptCardBackendApiService,\n      'loadConceptCardsAsync'\n    ).and.returnValue(\n      Promise.resolve([new ConceptCard(new SubtitledHtml('', ''), [], null)])\n    );\n\n    spyOn(\n      explorationSummaryBackendApiService,\n      'loadPublicExplorationSummariesAsync'\n    ).and.returnValue(\n      Promise.resolve({\n        summaries: [{} as ExplorationSummaryDict],\n      })\n    );\n    spyOn(\n      refresherExplorationConfirmationModalService,\n      'displayRedirectConfirmationModal'\n    ).and.callFake((id, callb) => {\n      callb();\n    });\n    spyOn(statsReportingService, 'recordLeaveForRefresherExp');\n    spyOn(playerTranscriptService, 'hasEncounteredStateBefore').and.returnValue(\n      true\n    );\n    spyOn(explorationPlayerStateService, 'recordNewCardAdded');\n\n    componentInstance.explorationActuallyStarted = false;\n\n    componentInstance.submitAnswer('', null);\n    tick(2000);\n  }));\n\n  it('should be able to set active voiceover content ID', fakeAsync(() => {\n    spyOn(voiceoverPlayerService, 'setActiveVoiceover');\n    let interaction = interactionObjectFactory.createFromBackendDict({\n      id: 'TextInput',\n      answer_groups: [],\n      default_outcome: {\n        missing_prerequisite_skill_id: null,\n        refresher_exploration_id: null,\n        labelled_as_correct: false,\n        feedback: {\n          content_id: 'default_outcome',\n          html: 'Wrong answer',\n        },\n        param_changes: [],\n        dest_if_really_stuck: null,\n        dest: 'Start',\n      },\n      confirmed_unclassified_answers: [],\n      customization_args: {\n        rows: {\n          value: true,\n        },\n        placeholder: {\n          value: 1,\n        },\n      },\n      hints: [],\n      solution: null,\n    });\n\n    let displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      interaction,\n      [],\n      null,\n      '',\n      null\n    );\n\n    componentInstance.displayedCard = displayedCard;\n\n    componentInstance.setActiveVoiceover('Wrong answer');\n    expect(voiceoverPlayerService.setActiveVoiceover).toHaveBeenCalledWith(\n      'default_outcome'\n    );\n  }));\n\n  it('should get recommended summaries when exploration in story chapter mode', fakeAsync(() => {\n    let alertMessageElement = document.createElement('div');\n    alertMessageElement.className = 'oppia-exploration-checkpoints-message';\n    spyOn(explorationPlayerStateService, 'recordNewCardAdded');\n    spyOn(focusManagerService, 'setFocusIfOnDesktop');\n    spyOn(componentInstance, 'scrollToTop');\n    spyOn(playerPositionService.onNewCardOpened, 'emit');\n    spyOn(conversationFlowService, 'addNewCard');\n    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);\n    spyOn(\n      conversationFlowService,\n      'isSupplementalCardNonempty'\n    ).and.returnValue(false);\n    spyOn(playerPositionService, 'setDisplayedCardIndex');\n    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);\n    spyOn(playerPositionService, 'changeCurrentQuestion');\n    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);\n    spyOn(\n      explorationEngineService,\n      'getAuthorRecommendedExpIdsByStateName'\n    ).and.returnValue([]);\n    spyOn(\n      explorationPlayerStateService,\n      'isInStoryChapterMode'\n    ).and.returnValue(false);\n    spyOn(\n      explorationRecommendationsService,\n      'getRecommendedSummaryDicts'\n    ).and.callFake((ids, recommendations, callb) => {\n      callb(null);\n    });\n    spyOn(document, 'querySelector')\n      .withArgs('.oppia-exploration-checkpoints-message')\n      .and.returnValue(alertMessageElement);\n\n    componentInstance.alertMessageTimeout = 5;\n\n    componentInstance.displayedCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n\n    componentInstance.nextCard = displayedCard;\n    componentInstance.showPendingCard();\n    tick(2000);\n  }));\n\n  it('should check whether hacky translations are displayed or not', () => {\n    spyOn(\n      i18nLanguageCodeService,\n      'isHackyTranslationAvailable'\n    ).and.returnValues(false, true);\n    spyOn(i18nLanguageCodeService, 'isCurrentLanguageEnglish').and.returnValues(\n      false,\n      false\n    );\n\n    let expId = 'exp_id';\n\n    let hackyStoryTitleTranslationIsDisplayed =\n      componentInstance.isHackyExpTitleTranslationDisplayed(expId);\n    expect(hackyStoryTitleTranslationIsDisplayed).toBe(false);\n    hackyStoryTitleTranslationIsDisplayed =\n      componentInstance.isHackyExpTitleTranslationDisplayed(expId);\n    expect(hackyStoryTitleTranslationIsDisplayed).toBe(true);\n  });\n\n  it('should check if current card was completed in a previous session', () => {\n    let mockStateCard = new StateCard(\n      'Temp2',\n      '',\n      '',\n      new Interaction([], [], null, null, [], null, null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.displayedCard = mockStateCard;\n    componentInstance.prevSessionStatesProgress = ['Temp1', 'Temp2'];\n    expect(\n      componentInstance.isDisplayedCardCompletedInPrevSession()\n    ).toBeTrue();\n    componentInstance.prevSessionStatesProgress = ['Temp1'];\n    expect(\n      componentInstance.isDisplayedCardCompletedInPrevSession()\n    ).toBeFalse();\n  });\n\n  it('should tell if progress clearance message is shown or not', () => {\n    expect(componentInstance.isProgressClearanceMessageShown()).toBeFalse();\n\n    componentInstance.showProgressClearanceMessage = true;\n\n    expect(componentInstance.isProgressClearanceMessageShown()).toBeTrue();\n  });\n\n  it('should update when submit button is enabled', () => {\n    componentInstance.submitButtonIsDisabled = false;\n    spyOn(componentInstance, 'isSubmitButtonDisabled').and.returnValue(\n      !componentInstance.submitButtonIsDisabled\n    );\n\n    componentInstance.ngAfterViewChecked();\n\n    expect(componentInstance.submitButtonIsDisabled).toBeTrue();\n    expect(componentInstance.isSubmitButtonDisabled).toHaveBeenCalled();\n  });\n\n  it('should be able to set appropriate flags for the diagnostic test', fakeAsync(() => {\n    let collectionId = 'id';\n    let expId = 'exp_id';\n    let isInPreviewMode = false;\n    let isIframed = true;\n    let collectionSummary = {\n      is_admin: true,\n      summaries: [],\n      user_email: '',\n      is_topic_manager: false,\n      username: true,\n    };\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(\n        new UserInfo([], false, false, false, false, false, '', '', '', true)\n      )\n    );\n    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(\n      collectionId,\n      null\n    );\n    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);\n\n    spyOn(\n      readOnlyCollectionBackendApiService,\n      'loadCollectionAsync'\n    ).and.returnValue(\n      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))\n    );\n    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);\n    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(\n      isInPreviewMode\n    );\n    spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n    spyOn(loaderService, 'showLoadingScreen');\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      'oppia_avatar_url'\n    );\n    spyOn(\n      explorationPlayerStateService,\n      'isInQuestionPlayerMode'\n    ).and.returnValues(true, false);\n    spyOn(componentInstance, 'initializePage');\n    spyOn(\n      collectionPlayerBackendApiService,\n      'fetchCollectionSummariesAsync'\n    ).and.returnValue(Promise.resolve(collectionSummary));\n    spyOn(questionPlayerStateService, 'hintUsed');\n    spyOn(questionPlayerEngineService, 'getCurrentQuestion');\n    spyOn(questionPlayerStateService, 'solutionViewed');\n    spyOn(imagePreloaderService, 'onStateChange');\n    spyOn(componentInstance, 'fetchCompletedChaptersCount');\n    spyOn(statsReportingService, 'recordExplorationCompleted');\n    spyOn(statsReportingService, 'recordExplorationActuallyStarted');\n    spyOn(\n      guestCollectionProgressService,\n      'recordExplorationCompletedInCollection'\n    );\n    spyOn(\n      componentInstance,\n      'doesCollectionAllowsGuestProgress'\n    ).and.returnValue(true);\n    spyOn(statsReportingService, 'recordMaybeLeaveEvent');\n    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');\n    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});\n    spyOn(messengerService, 'sendMessage');\n    spyOn(\n      readOnlyExplorationBackendApiService,\n      'loadLatestExplorationAsync'\n    ).and.returnValue(Promise.resolve(explorationResponse));\n    spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue([\n      'Start',\n      'Mid',\n    ]);\n    spyOn(\n      editableExplorationBackendApiService,\n      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'\n    ).and.returnValue(\n      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})\n    );\n\n    let mockOnHintConsumed = new EventEmitter();\n    let mockOnSolutionViewedEventEmitter = new EventEmitter();\n    let mockOnPlayerStateChange = new EventEmitter();\n\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onHintConsumed'\n    ).and.returnValue(mockOnHintConsumed);\n    spyOnProperty(\n      hintsAndSolutionManagerService,\n      'onSolutionViewedEventEmitter'\n    ).and.returnValue(mockOnSolutionViewedEventEmitter);\n    spyOnProperty(\n      explorationPlayerStateService,\n      'onPlayerStateChange'\n    ).and.returnValue(mockOnPlayerStateChange);\n\n    componentInstance.nextCard = new StateCard(\n      null,\n      null,\n      null,\n      new Interaction([], [], null, null, [], 'EndExploration', null),\n      [],\n      null,\n      '',\n      null\n    );\n    componentInstance.isLoggedIn = false;\n    componentInstance.hasInteractedAtLeastOnce = true;\n    componentInstance.displayedCard = displayedCard;\n\n    expect(componentInstance.feedbackIsEnabled).toBeTrue();\n    expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeFalse();\n    expect(componentInstance.inputOutputHistoryIsShown).toBeTrue();\n    expect(componentInstance.navigationThroughCardHistoryIsEnabled).toBeTrue();\n    expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeTrue();\n    expect(componentInstance.skipButtonIsShown).toBeFalse();\n\n    const topicIdToPrerequisiteTopicIds = {\n      topicId1: [],\n      topicId2: ['topicId1'],\n      topicId3: ['topicId2'],\n    };\n\n    componentInstance.diagnosticTestTopicTrackerModel =\n      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds);\n    tick();\n\n    componentInstance.ngOnInit();\n    tick(2000);\n\n    expect(componentInstance.feedbackIsEnabled).toBeFalse();\n    expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeTrue();\n    expect(componentInstance.inputOutputHistoryIsShown).toBeFalse();\n    expect(componentInstance.navigationThroughCardHistoryIsEnabled).toBeFalse();\n    expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeFalse();\n    expect(componentInstance.skipButtonIsShown).toBeTrue();\n  }));\n\n  it('should be able to skip the current question', fakeAsync(() => {\n    let sampleCard = StateCard.createNewCard(\n      'State 2',\n      '<p>Content</p>',\n      '',\n      // This throws \"Type null is not assignable to type\n      // 'string'.\" We need to suppress this error\n      // because of the need to test validations. This\n      // throws an error only in the frontend test and\n      // not in the frontend.\n      // @ts-ignore\n      null,\n      null,\n      'content',\n      audioTranslationLanguageService\n    );\n\n    let callback = (successCallback: (nextCard: StateCard) => void) => {\n      successCallback(sampleCard);\n    };\n    spyOn(explorationPlayerStateService, 'skipCurrentQuestion').and.callFake(\n      callback\n    );\n    spyOn(componentInstance, 'showPendingCard');\n\n    componentInstance.skipCurrentQuestion();\n\n    expect(\n      explorationPlayerStateService.skipCurrentQuestion\n    ).toHaveBeenCalled();\n    expect(componentInstance.showPendingCard).toHaveBeenCalled();\n  }));\n\n  it('should tell if window can show two cards', () => {\n    spyOn(windowDimensionsService, 'getWidth').and.returnValue(\n      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX + 1\n    );\n\n    expect(componentInstance.canWindowShowTwoCards()).toBeTrue();\n  });\n\n  it('should animate to one card', fakeAsync(() => {\n    let doneCallbackSpy = jasmine.createSpy('done callback');\n    componentInstance.animateToOneCard(doneCallbackSpy);\n\n    tick(600);\n    expect(componentInstance.isAnimatingToOneCard).toBeFalse();\n    expect(doneCallbackSpy).toHaveBeenCalled();\n  }));\n\n  it('should animate to two cards', fakeAsync(() => {\n    let doneCallbackSpy = jasmine.createSpy('done callback');\n    componentInstance.animateToTwoCards(doneCallbackSpy);\n\n    tick(1000);\n    expect(componentInstance.isAnimatingToTwoCards).toBeFalse();\n    expect(doneCallbackSpy).toHaveBeenCalled();\n  }));\n});\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/conversation-skin.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the conversation skin.\n */\n\nimport {Subscription} from 'rxjs';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {ServicesConstants} from 'services/services.constants';\nimport {ChangeDetectorRef, Component, Input} from '@angular/core';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {AlertsService} from 'services/alerts.service';\nimport {AudioPlayerService} from 'services/audio-player.service';\nimport {AudioTranslationLanguageService} from '../services/audio-translation-language.service';\nimport {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';\nimport {ConceptCardBackendApiService} from 'domain/skill/concept-card-backend-api.service';\nimport {ContextService} from 'services/context.service';\nimport {CurrentInteractionService} from '../services/current-interaction.service';\nimport {ExplorationEngineService} from '../services/exploration-engine.service';\nimport {ExplorationPlayerStateService} from '../services/exploration-player-state.service';\nimport {ExplorationRecommendationsService} from '../services/exploration-recommendations.service';\nimport {FatigueDetectionService} from '../services/fatigue-detection.service';\nimport {FocusManagerService} from 'services/stateful/focus-manager.service';\nimport {GuestCollectionProgressService} from 'domain/collection/guest-collection-progress.service';\nimport {HintsAndSolutionManagerService} from '../services/hints-and-solution-manager.service';\nimport {\n  I18nLanguageCodeService,\n  TranslationKeyType,\n} from 'services/i18n-language-code.service';\nimport {ImagePreloaderService} from '../services/image-preloader.service';\nimport {LearnerAnswerInfoService} from '../services/learner-answer-info.service';\nimport {LearnerParamsService} from '../services/learner-params.service';\nimport {LoaderService} from 'services/loader.service';\nimport {MessengerService} from 'services/messenger.service';\nimport {NumberAttemptsService} from '../services/number-attempts.service';\nimport {PlayerPositionService} from '../services/player-position.service';\nimport {PlayerTranscriptService} from '../services/player-transcript.service';\nimport {QuestionPlayerEngineService} from '../services/question-player-engine.service';\nimport {ReadOnlyCollectionBackendApiService} from 'domain/collection/read-only-collection-backend-api.service';\nimport {RefresherExplorationConfirmationModalService} from '../services/refresher-exploration-confirmation-modal.service';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\nimport {StatsReportingService} from '../services/stats-reporting.service';\nimport {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {UserService} from 'services/user.service';\nimport {LocalStorageService} from 'services/local-storage.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {QuestionPlayerStateService} from 'components/question-directives/question-player/services/question-player-state.service';\nimport {State} from 'domain/state/StateObjectFactory';\nimport {InteractionRulesService} from '../services/answer-classification.service';\nimport INTERACTION_SPECS from 'interactions/interaction_specs.json';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {ExplorationPlayerConstants} from '../exploration-player-page.constants';\nimport {AppConstants} from 'app.constants';\nimport {TopicViewerDomainConstants} from 'domain/topic_viewer/topic-viewer-domain.constants';\nimport {StoryViewerDomainConstants} from 'domain/story_viewer/story-viewer-domain.constants';\nimport {ConceptCard} from 'domain/skill/concept-card.model';\nimport {CollectionPlayerBackendApiService} from 'pages/collection-player-page/services/collection-player-backend-api.service';\nimport {ExplorationSummaryBackendApiService} from 'domain/summary/exploration-summary-backend-api.service';\nimport {LearnerExplorationSummary} from 'domain/summary/learner-exploration-summary.model';\nimport {EditableExplorationBackendApiService} from 'domain/exploration/editable-exploration-backend-api.service';\nimport {ReadOnlyExplorationBackendApiService} from 'domain/exploration/read-only-exploration-backend-api.service';\nimport {StateObjectsBackendDict} from 'domain/exploration/StatesObjectFactory';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\nimport {LearnerDashboardBackendApiService} from 'domain/learner_dashboard/learner-dashboard-backend-api.service';\nimport {ConversationFlowService} from '../services/conversation-flow.service';\n\nimport './conversation-skin.component.css';\nimport {ConceptCardManagerService} from '../services/concept-card-manager.service';\nimport {TranslateService} from '@ngx-translate/core';\nimport {Solution} from 'domain/exploration/SolutionObjectFactory';\nimport {EntityVoiceoversService} from 'services/entity-voiceovers.services';\nimport {VoiceoverPlayerService} from '../services/voiceover-player.service';\n\n// Note: This file should be assumed to be in an IIFE, and the constants below\n// should only be used within this file.\nconst TIME_FADEOUT_MSEC = 100;\nconst TIME_HEIGHT_CHANGE_MSEC = 500;\nconst TIME_FADEIN_MSEC = 100;\nconst TIME_NUM_CARDS_CHANGE_MSEC = 500;\n\n@Component({\n  selector: 'oppia-conversation-skin',\n  templateUrl: './conversation-skin.component.html',\n  styleUrls: ['./conversation-skin.component.css'],\n})\nexport class ConversationSkinComponent {\n  @Input() questionPlayerConfig;\n  @Input() diagnosticTestTopicTrackerModel;\n  directiveSubscriptions = new Subscription();\n\n  TIME_PADDING_MSEC = 250;\n  TIME_SCROLL_MSEC = 600;\n  MIN_CARD_LOADING_DELAY_MSEC = 950;\n\n  hasInteractedAtLeastOnce: boolean = false;\n  _nextFocusLabel = null;\n  _editorPreviewMode;\n  explorationActuallyStarted: boolean = false;\n\n  CONTINUE_BUTTON_FOCUS_LABEL =\n    ExplorationPlayerConstants.CONTINUE_BUTTON_FOCUS_LABEL;\n\n  isLoggedIn: boolean;\n  voiceoversAreLoaded: boolean = false;\n  storyNodeIdToAdd: string;\n  inStoryMode: boolean = false;\n  collectionId: string;\n  collectionTitle: string;\n  answerIsBeingProcessed: boolean = false;\n  explorationId: string;\n  isInPreviewMode: boolean;\n  isIframed: boolean;\n  hasFullyLoaded = false;\n  recommendedExplorationSummaries = [];\n  answerIsCorrect = false;\n  nextCard;\n  nextCardIfStuck: StateCard | null;\n  alertMessage = {};\n  pendingCardWasSeenBefore: boolean = false;\n  OPPIA_AVATAR_IMAGE_URL: string;\n  displayedCard: StateCard;\n  upcomingInlineInteractionHtml;\n  responseTimeout: NodeJS.Timeout | null = null;\n  correctnessFooterIsShown: boolean = true;\n  DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER =\n    AppConstants.DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR;\n\n  // If the exploration is iframed, send data to its parent about\n  // its height so that the parent can be resized as necessary.\n  lastRequestedHeight: number = 0;\n  lastRequestedScroll: boolean = false;\n  startCardChangeAnimation: boolean;\n  collectionSummary;\n  redirectToRefresherExplorationConfirmed;\n  isAnimatingToTwoCards: boolean;\n  isAnimatingToOneCard: boolean;\n  isRefresherExploration: boolean;\n  parentExplorationIds: string[];\n  conceptCard: ConceptCard;\n  questionSessionCompleted: boolean;\n  moveToExploration: boolean;\n  upcomingInteractionInstructions;\n  visitedStateNames: string[] = [];\n  completedStateNames: string[] = [];\n  prevSessionStatesProgress: string[] = [];\n  mostRecentlyReachedCheckpoint: string;\n  numberOfIncorrectSubmissions: number = 0;\n  showProgressClearanceMessage: boolean = false;\n  alertMessageTimeout = 6000;\n  // 'completedChaptersCount' is fetched via a HTTP request.\n  // Until the response is received, it remains undefined.\n  completedChaptersCount: number | undefined;\n  chapterIsCompletedForTheFirstTime: boolean = false;\n  pidInUrl: string;\n  submitButtonIsDisabled = true;\n  solutionForState: Solution | null = null;\n  isLearnerReallyStuck: boolean = false;\n  continueToReviseStateButtonIsVisible: boolean = false;\n  showInteraction: boolean = true;\n\n  // The fields are used to customize the component for the diagnostic player,\n  // question player, and exploration player page.\n  feedbackIsEnabled: boolean = true;\n  learnerCanOnlyAttemptQuestionOnce: boolean = false;\n  inputOutputHistoryIsShown: boolean = true;\n  navigationThroughCardHistoryIsEnabled: boolean = true;\n  checkpointCelebrationModalIsEnabled: boolean = true;\n  skipButtonIsShown: boolean = false;\n\n  constructor(\n    private windowRef: WindowRef,\n    private alertsService: AlertsService,\n    private audioPlayerService: AudioPlayerService,\n    private audioTranslationLanguageService: AudioTranslationLanguageService,\n    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,\n    private changeDetectorRef: ChangeDetectorRef,\n    private collectionPlayerBackendApiService: CollectionPlayerBackendApiService,\n    private conceptCardBackendApiService: ConceptCardBackendApiService,\n    private contextService: ContextService,\n    private currentInteractionService: CurrentInteractionService,\n    private explorationEngineService: ExplorationEngineService,\n    private explorationPlayerStateService: ExplorationPlayerStateService,\n    private explorationRecommendationsService: ExplorationRecommendationsService,\n    private explorationSummaryBackendApiService: ExplorationSummaryBackendApiService,\n    private fatigueDetectionService: FatigueDetectionService,\n    private focusManagerService: FocusManagerService,\n    private guestCollectionProgressService: GuestCollectionProgressService,\n    private hintsAndSolutionManagerService: HintsAndSolutionManagerService,\n    private conceptCardManagerService: ConceptCardManagerService,\n    private i18nLanguageCodeService: I18nLanguageCodeService,\n    private imagePreloaderService: ImagePreloaderService,\n    private learnerAnswerInfoService: LearnerAnswerInfoService,\n    private learnerParamsService: LearnerParamsService,\n    private loaderService: LoaderService,\n    private messengerService: MessengerService,\n    private localStorageService: LocalStorageService,\n    private numberAttemptsService: NumberAttemptsService,\n    private playerPositionService: PlayerPositionService,\n    private playerTranscriptService: PlayerTranscriptService,\n    private questionPlayerEngineService: QuestionPlayerEngineService,\n    private questionPlayerStateService: QuestionPlayerStateService,\n    private readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService,\n    private refresherExplorationConfirmationModalService: RefresherExplorationConfirmationModalService,\n    private siteAnalyticsService: SiteAnalyticsService,\n    private statsReportingService: StatsReportingService,\n    private storyViewerBackendApiService: StoryViewerBackendApiService,\n    private urlInterpolationService: UrlInterpolationService,\n    private urlService: UrlService,\n    private userService: UserService,\n    private windowDimensionsService: WindowDimensionsService,\n    private editableExplorationBackendApiService: EditableExplorationBackendApiService,\n    private readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService,\n    private platformFeatureService: PlatformFeatureService,\n    private translateService: TranslateService,\n    private learnerDashboardBackendApiService: LearnerDashboardBackendApiService,\n    private conversationFlowService: ConversationFlowService,\n    private entityVoiceoversService: EntityVoiceoversService,\n    private voiceoverPlayerService: VoiceoverPlayerService\n  ) {}\n\n  adjustPageHeightOnresize(): void {\n    this.windowRef.nativeWindow.onresize = () => {\n      this.adjustPageHeight(false, null);\n    };\n  }\n\n  ngOnInit(): void {\n    this._editorPreviewMode = this.contextService.isInExplorationEditorPage();\n\n    this.collectionId = this.urlService.getCollectionIdFromExplorationUrl();\n    this.pidInUrl = this.urlService.getPidFromUrl();\n\n    if (this.collectionId) {\n      this.readOnlyCollectionBackendApiService\n        .loadCollectionAsync(this.collectionId)\n        .then(collection => {\n          this.collectionTitle = collection.getTitle();\n        });\n    } else {\n      this.collectionTitle = null;\n    }\n\n    if (this.diagnosticTestTopicTrackerModel) {\n      this.feedbackIsEnabled = false;\n      this.learnerCanOnlyAttemptQuestionOnce = true;\n      this.inputOutputHistoryIsShown = false;\n      this.navigationThroughCardHistoryIsEnabled = false;\n      this.checkpointCelebrationModalIsEnabled = false;\n      this.skipButtonIsShown = true;\n      this.correctnessFooterIsShown = false;\n    }\n\n    if (!this.contextService.isInExplorationPlayerPage()) {\n      this.checkpointCelebrationModalIsEnabled = false;\n    }\n\n    this.explorationId = this.explorationEngineService.getExplorationId();\n    this.isInPreviewMode = this.explorationEngineService.isInPreviewMode();\n    this.isIframed = this.urlService.isIframed();\n    this.loaderService.showLoadingScreen('Loading');\n\n    this.OPPIA_AVATAR_IMAGE_URL =\n      this.urlInterpolationService.getStaticCopyrightedImageUrl(\n        '/avatar/oppia_avatar_100px.svg'\n      );\n\n    if (this.explorationPlayerStateService.isInQuestionPlayerMode()) {\n      this.directiveSubscriptions.add(\n        this.hintsAndSolutionManagerService.onHintConsumed.subscribe(() => {\n          this.questionPlayerStateService.hintUsed(\n            this.questionPlayerEngineService.getCurrentQuestion()\n          );\n        })\n      );\n\n      this.directiveSubscriptions.add(\n        this.hintsAndSolutionManagerService.onSolutionViewedEventEmitter.subscribe(\n          () => {\n            this.questionPlayerStateService.solutionViewed(\n              this.questionPlayerEngineService.getCurrentQuestion()\n            );\n          }\n        )\n      );\n    }\n\n    this.directiveSubscriptions.add(\n      this.explorationPlayerStateService.onShowProgressModal.subscribe(() => {\n        this.hasFullyLoaded = true;\n      })\n    );\n\n    this.directiveSubscriptions.add(\n      this.playerPositionService.onNewCardOpened.subscribe(\n        (newCard: StateCard) => {\n          this.solutionForState = newCard.getSolution();\n          this.numberOfIncorrectSubmissions = 0;\n          this.nextCardIfStuck = null;\n          this.continueToReviseStateButtonIsVisible = false;\n          this.triggerIfLearnerStuckAction();\n        }\n      )\n    );\n\n    this.directiveSubscriptions.add(\n      this.hintsAndSolutionManagerService.onLearnerReallyStuck.subscribe(() => {\n        this.triggerIfLearnerStuckActionDirectly();\n      })\n    );\n\n    this.directiveSubscriptions.add(\n      this.hintsAndSolutionManagerService.onHintsExhausted.subscribe(() => {\n        this.triggerIfLearnerStuckAction();\n      })\n    );\n\n    this.directiveSubscriptions.add(\n      this.conceptCardManagerService.onLearnerGetsReallyStuck.subscribe(() => {\n        this.isLearnerReallyStuck = true;\n        this.triggerIfLearnerStuckActionDirectly();\n      })\n    );\n\n    this.directiveSubscriptions.add(\n      this.explorationPlayerStateService.onPlayerStateChange.subscribe(\n        newStateName => {\n          if (!newStateName) {\n            return;\n          }\n          // To restart the preloader for the new state if required.\n          if (!this._editorPreviewMode) {\n            this.imagePreloaderService.onStateChange(newStateName);\n          }\n          // Ensure the transition to a terminal state properly logs\n          // the end of the exploration.\n          if (!this._editorPreviewMode && this.nextCard.isTerminal()) {\n            const currentEngineService =\n              this.explorationPlayerStateService.getCurrentEngineService();\n            this.statsReportingService.recordExplorationCompleted(\n              newStateName,\n              this.learnerParamsService.getAllParams(),\n              String(\n                this.completedChaptersCount && this.completedChaptersCount + 1\n              ),\n              String(this.playerTranscriptService.getNumCards()),\n              currentEngineService.getLanguageCode()\n            );\n\n            // If the user is a guest, has completed this exploration\n            // within the context of a collection, and the collection is\n            // allowlisted, record their temporary progress.\n\n            if (\n              this.doesCollectionAllowsGuestProgress(this.collectionId) &&\n              !this.isLoggedIn\n            ) {\n              this.guestCollectionProgressService.recordExplorationCompletedInCollection(\n                this.collectionId,\n                this.explorationId\n              );\n            }\n\n            // For single state explorations, when the exploration\n            // reachesthe terminal state and explorationActuallyStarted\n            // is false, record exploration actual start event.\n            if (!this.explorationActuallyStarted) {\n              this.statsReportingService.recordExplorationActuallyStarted(\n                newStateName\n              );\n              this.explorationActuallyStarted = true;\n            }\n          }\n        }\n      )\n    );\n\n    // Moved the following code to then section as isLoggedIn\n    // variable needs to be defined before the following code is executed.\n    this.userService.getUserInfoAsync().then(async userInfo => {\n      this.isLoggedIn = userInfo.isLoggedIn();\n\n      this.windowRef.nativeWindow.addEventListener('beforeunload', e => {\n        if (this.redirectToRefresherExplorationConfirmed) {\n          return;\n        }\n        if (\n          this.hasInteractedAtLeastOnce &&\n          !this.isInPreviewMode &&\n          !this.displayedCard.isTerminal() &&\n          !this.explorationPlayerStateService.isInQuestionMode()\n        ) {\n          this.statsReportingService.recordMaybeLeaveEvent(\n            this.playerTranscriptService.getLastStateName(),\n            this.learnerParamsService.getAllParams()\n          );\n\n          let confirmationMessage =\n            'Please save your progress before navigating away from the' +\n            ' page; else, you will lose your exploration progress.';\n          (e || this.windowRef.nativeWindow.event).returnValue =\n            confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n\n      let pid =\n        this.localStorageService.getUniqueProgressIdOfLoggedOutLearner();\n      if (pid && this.isLoggedIn) {\n        await this.editableExplorationBackendApiService.changeLoggedOutProgressToLoggedInProgressAsync(\n          this.explorationId,\n          pid\n        );\n        this.localStorageService.removeUniqueProgressIdOfLoggedOutLearner();\n      }\n\n      this.adjustPageHeightOnresize();\n\n      this.currentInteractionService.setOnSubmitFn(\n        this.submitAnswer.bind(this)\n      );\n      this.startCardChangeAnimation = false;\n      this.initializePage();\n\n      this.collectionSummary = null;\n\n      if (this.collectionId) {\n        this.collectionPlayerBackendApiService\n          .fetchCollectionSummariesAsync(this.collectionId)\n          .then(\n            response => {\n              this.collectionSummary = response.summaries[0];\n            },\n            () => {\n              this.alertsService.addWarning(\n                'There was an error while fetching the collection ' + 'summary.'\n              );\n            }\n          );\n      }\n\n      this.fetchCompletedChaptersCount();\n\n      // We do not save checkpoints progress for iframes.\n      if (\n        !this.isIframed &&\n        !this._editorPreviewMode &&\n        !this.explorationPlayerStateService.isInQuestionPlayerMode() &&\n        !this.explorationPlayerStateService.isInDiagnosticTestPlayerMode()\n      ) {\n        // For the first state which is always a checkpoint.\n        let firstStateName: string;\n        let expVersion: number;\n        this.readOnlyExplorationBackendApiService\n          .loadLatestExplorationAsync(this.explorationId, this.pidInUrl)\n          .then(response => {\n            expVersion = response.version;\n            firstStateName = response.exploration.init_state_name;\n            this.mostRecentlyReachedCheckpoint =\n              response.most_recently_reached_checkpoint_state_name;\n            // If the exploration is freshly started, mark the first state\n            // as the most recently reached checkpoint.\n            if (!this.mostRecentlyReachedCheckpoint && this.isLoggedIn) {\n              this.editableExplorationBackendApiService.recordMostRecentlyReachedCheckpointAsync(\n                this.explorationId,\n                expVersion,\n                firstStateName,\n                true\n              );\n            }\n            this.explorationPlayerStateService.setLastCompletedCheckpoint(\n              firstStateName\n            );\n          });\n        this.visitedStateNames.push(firstStateName);\n      }\n    });\n  }\n\n  doesCollectionAllowsGuestProgress(collectionId: string | never): boolean {\n    let allowedCollectionIds =\n      AppConstants.ALLOWED_COLLECTION_IDS_FOR_SAVING_GUEST_PROGRESS;\n    return (\n      (allowedCollectionIds as readonly []).indexOf(collectionId as never) !==\n      -1\n    );\n  }\n\n  isSubmitButtonDisabled(): boolean {\n    let currentIndex = this.playerPositionService.getDisplayedCardIndex();\n    // This check is added because it was observed that when returning\n    // to current card after navigating through previous cards, using\n    // the arrows, the Submit button was sometimes falsely disabled.\n    // Also, since a learner's answers would always be in the current\n    // card, this additional check doesn't interfere with its normal\n    // working.\n    if (!this.playerTranscriptService.isLastCard(currentIndex)) {\n      return false;\n    }\n    return this.currentInteractionService.isSubmitButtonDisabled();\n  }\n\n  ngAfterViewChecked(): void {\n    let submitButtonIsDisabled = this.isSubmitButtonDisabled();\n    if (submitButtonIsDisabled !== this.submitButtonIsDisabled) {\n      this.submitButtonIsDisabled = submitButtonIsDisabled;\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  changeCard(index: number): void {\n    this.playerPositionService.recordNavigationButtonClick();\n    this.playerPositionService.setDisplayedCardIndex(index);\n    this.explorationEngineService.onUpdateActiveStateIfInEditor.emit(\n      this.playerPositionService.getCurrentStateName()\n    );\n    this.playerPositionService.changeCurrentQuestion(index);\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n\n  alwaysAskLearnerForAnswerDetails(): boolean {\n    return this.explorationEngineService.getAlwaysAskLearnerForAnswerDetails();\n  }\n\n  getCanAskLearnerForAnswerInfo(): boolean {\n    return this.learnerAnswerInfoService.getCanAskLearnerForAnswerInfo();\n  }\n\n  fetchCompletedChaptersCount(): void {\n    if (this.isLoggedIn) {\n      this.learnerDashboardBackendApiService\n        .fetchLearnerCompletedChaptersCountDataAsync()\n        .then(data => {\n          this.completedChaptersCount = data.completedChaptersCount;\n        });\n    }\n  }\n\n  initLearnerAnswerInfoService(\n    entityId: string,\n    state: State,\n    answer: string,\n    interactionRulesService: InteractionRulesService,\n    alwaysAskLearnerForAnswerInfo: boolean\n  ): void {\n    this.learnerAnswerInfoService.initLearnerAnswerInfoService(\n      entityId,\n      state,\n      answer,\n      interactionRulesService,\n      alwaysAskLearnerForAnswerInfo\n    );\n  }\n\n  isCorrectnessFooterEnabled(): boolean {\n    return (\n      this.correctnessFooterIsShown &&\n      this.answerIsCorrect &&\n      this.playerPositionService.hasLearnerJustSubmittedAnAnswer()\n    );\n  }\n\n  isLearnAgainButton(): boolean {\n    let conceptCardIsBeingShown =\n      this.displayedCard.getStateName() === null &&\n      !this.explorationPlayerStateService.isInQuestionMode();\n    if (conceptCardIsBeingShown) {\n      return false;\n    }\n    let interaction = this.displayedCard.getInteraction();\n\n    if (!interaction.id) {\n      // An editor might also try to view preview tab without adding\n      // interaction to concept card.\n      return false;\n    }\n\n    if (INTERACTION_SPECS[interaction.id].is_linear) {\n      return false;\n    }\n    return this.pendingCardWasSeenBefore && !this.answerIsCorrect;\n  }\n\n  private _getRandomSuffix(): string {\n    // This is a bit of a hack. When a refresh to a component property\n    // happens, Angular compares the new value of the property to its previous\n    // value. If they are the same, then the property is not updated.\n    // Appending a random suffix makes the new value different from the\n    // previous one, and thus indirectly forces a refresh.\n    let randomSuffix = '';\n    let N = Math.round(Math.random() * 1000);\n    for (let i = 0; i < N; i++) {\n      randomSuffix += ' ';\n    }\n    return randomSuffix;\n  }\n\n  getStaticImageUrl(imagePath: string): string {\n    return this.urlInterpolationService.getStaticImageUrl(imagePath);\n  }\n\n  getContentFocusLabel(index: number): string {\n    return ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index;\n  }\n\n  adjustPageHeight(scroll: boolean, callback: () => void): void {\n    setTimeout(() => {\n      let newHeight = document.body.scrollHeight;\n      if (\n        Math.abs(this.lastRequestedHeight - newHeight) > 50.5 ||\n        (scroll && !this.lastRequestedScroll)\n      ) {\n        // Sometimes setting iframe height to the exact content height\n        // still produces scrollbar, so adding 50 extra px.\n        newHeight += 50;\n        this.messengerService.sendMessage(\n          ServicesConstants.MESSENGER_PAYLOAD.HEIGHT_CHANGE,\n          {\n            height: newHeight,\n            scroll: scroll,\n          }\n        );\n        this.lastRequestedHeight = newHeight;\n        this.lastRequestedScroll = scroll;\n      }\n\n      if (callback) {\n        callback();\n      }\n    }, 100);\n  }\n\n  getExplorationLink(): string {\n    if (\n      this.recommendedExplorationSummaries &&\n      this.recommendedExplorationSummaries[0]\n    ) {\n      if (!this.recommendedExplorationSummaries[0].id) {\n        return '#';\n      } else {\n        let result = '/explore/' + this.recommendedExplorationSummaries[0].id;\n        let urlParams = this.urlService.getUrlParams();\n        let parentExplorationIds =\n          this.recommendedExplorationSummaries[0].parentExplorationIds;\n\n        let collectionIdToAdd = this.collectionId;\n        let storyUrlFragmentToAdd = null;\n        let topicUrlFragment = null;\n        let classroomUrlFragment = null;\n        // Replace the collection ID with the one in the URL if it\n        // exists in urlParams.\n        if (parentExplorationIds && urlParams.hasOwnProperty('collection_id')) {\n          collectionIdToAdd = urlParams.collection_id;\n        } else if (\n          this.urlService.getPathname().match(/\\/story\\/(\\w|-){12}/g) &&\n          this.recommendedExplorationSummaries[0].nextNodeId\n        ) {\n          storyUrlFragmentToAdd =\n            this.urlService.getStoryUrlFragmentFromLearnerUrl();\n          topicUrlFragment =\n            this.urlService.getTopicUrlFragmentFromLearnerUrl();\n          classroomUrlFragment =\n            this.urlService.getClassroomUrlFragmentFromLearnerUrl();\n        } else if (\n          urlParams.hasOwnProperty('story_url_fragment') &&\n          urlParams.hasOwnProperty('node_id') &&\n          urlParams.hasOwnProperty('topic_url_fragment') &&\n          urlParams.hasOwnProperty('classroom_url_fragment')\n        ) {\n          topicUrlFragment = urlParams.topic_url_fragment;\n          classroomUrlFragment = urlParams.classroom_url_fragment;\n          storyUrlFragmentToAdd = urlParams.story_url_fragment;\n        }\n\n        if (collectionIdToAdd) {\n          result = this.urlService.addField(\n            result,\n            'collection_id',\n            collectionIdToAdd\n          );\n        }\n        if (parentExplorationIds) {\n          for (let i = 0; i < parentExplorationIds.length - 1; i++) {\n            result = this.urlService.addField(\n              result,\n              'parent',\n              parentExplorationIds[i]\n            );\n          }\n        }\n        if (storyUrlFragmentToAdd && this.storyNodeIdToAdd) {\n          result = this.urlService.addField(\n            result,\n            'topic_url_fragment',\n            topicUrlFragment\n          );\n          result = this.urlService.addField(\n            result,\n            'classroom_url_fragment',\n            classroomUrlFragment\n          );\n          result = this.urlService.addField(\n            result,\n            'story_url_fragment',\n            storyUrlFragmentToAdd\n          );\n          result = this.urlService.addField(\n            result,\n            'node_id',\n            this.storyNodeIdToAdd\n          );\n        }\n        return result;\n      }\n    }\n  }\n\n  reloadExploration(): void {\n    this.windowRef.nativeWindow.location.reload();\n  }\n\n  isOnTerminalCard(): boolean {\n    return this.displayedCard && this.displayedCard.isTerminal();\n  }\n\n  isCurrentSupplementalCardNonempty(): boolean {\n    return (\n      this.displayedCard &&\n      this.conversationFlowService.isSupplementalCardNonempty(\n        this.displayedCard\n      )\n    );\n  }\n\n  isSupplementalNavShown(): boolean {\n    if (\n      this.displayedCard.getStateName() === null &&\n      !this.explorationPlayerStateService.isInQuestionMode()\n    ) {\n      return false;\n    }\n    let interaction = this.displayedCard.getInteraction();\n    return (\n      Boolean(interaction.id) &&\n      INTERACTION_SPECS[interaction.id].show_generic_submit_button &&\n      this.isCurrentCardAtEndOfTranscript()\n    );\n  }\n\n  private _recordLeaveForRefresherExp(refresherExpId): void {\n    if (!this._editorPreviewMode) {\n      this.statsReportingService.recordLeaveForRefresherExp(\n        this.playerPositionService.getCurrentStateName(),\n        refresherExpId\n      );\n    }\n  }\n\n  private _navigateToMostRecentlyReachedCheckpoint() {\n    let states: StateObjectsBackendDict;\n    this.readOnlyExplorationBackendApiService\n      .loadLatestExplorationAsync(this.explorationId, this.pidInUrl)\n      .then(response => {\n        states = response.exploration.states;\n        this.mostRecentlyReachedCheckpoint =\n          response.most_recently_reached_checkpoint_state_name;\n\n        this.prevSessionStatesProgress =\n          this.explorationEngineService.getShortestPathToState(\n            states,\n            this.mostRecentlyReachedCheckpoint\n          );\n\n        let indexToRedirectTo = 0;\n\n        for (let i = 0; i < this.prevSessionStatesProgress.length; i++) {\n          // Set state name of a previously completed state.\n          let stateName = this.prevSessionStatesProgress[i];\n          // Skip the card if it has already been added to transcript.\n          if (\n            !this.playerTranscriptService.hasEncounteredStateBefore(stateName)\n          ) {\n            let stateCard =\n              this.explorationEngineService.getStateCardByName(stateName);\n            this._addNewCard(stateCard);\n          }\n\n          if (this.mostRecentlyReachedCheckpoint === stateName) {\n            break;\n          }\n\n          this.visitedStateNames.push(stateName);\n          indexToRedirectTo += 1;\n        }\n\n        // Remove the last card from progress as it is not completed\n        // yet and is only most recently reached.\n        this.prevSessionStatesProgress.pop();\n\n        if (indexToRedirectTo > 0) {\n          setTimeout(() => {\n            let alertInfoElement = document.querySelector(\n              '.oppia-exploration-checkpoints-message'\n            );\n\n            // Remove the alert message after 6 sec.\n            if (alertInfoElement) {\n              alertInfoElement.remove();\n            }\n          }, this.alertMessageTimeout);\n        }\n\n        // Move to most recently reached checkpoint card.\n        this.changeCard(indexToRedirectTo);\n        this.playerPositionService.onLoadedMostRecentCheckpoint.emit();\n      });\n  }\n\n  // Navigates to the currently-active card, and resets the\n  // 'show previous responses' setting.\n  private _navigateToDisplayedCard(): void {\n    let index = this.playerPositionService.getDisplayedCardIndex();\n    this.displayedCard = this.playerTranscriptService.getCard(index);\n\n    if (\n      index > 0 &&\n      !this.isIframed &&\n      !this._editorPreviewMode &&\n      !this.explorationPlayerStateService.isInQuestionPlayerMode() &&\n      !this.explorationPlayerStateService.isInDiagnosticTestPlayerMode()\n    ) {\n      let currentState = this.explorationEngineService.getState();\n      let currentStateName = currentState.name;\n      if (\n        currentState.cardIsCheckpoint &&\n        !this.visitedStateNames.includes(currentStateName) &&\n        !this.prevSessionStatesProgress.includes(currentStateName)\n      ) {\n        this.readOnlyExplorationBackendApiService\n          .loadLatestExplorationAsync(this.explorationId)\n          .then(response => {\n            this.explorationPlayerStateService.setLastCompletedCheckpoint(\n              currentStateName\n            );\n            this.editableExplorationBackendApiService.recordMostRecentlyReachedCheckpointAsync(\n              this.explorationId,\n              response.version,\n              currentStateName,\n              this.isLoggedIn,\n              this.explorationPlayerStateService.getUniqueProgressUrlId()\n            );\n          });\n        this.visitedStateNames.push(currentStateName);\n      }\n    }\n\n    this.playerPositionService.onActiveCardChanged.emit();\n\n    this.audioPlayerService.onAutoplayAudio.emit();\n    /* A hash value is added to URL for scrolling to Oppia feedback\n        when answer is submitted by user in mobile view. This hash value\n        has to be reset each time a new card is loaded to prevent\n        unwanted scrolling in the new card. */\n\n    // $location.hash(null);\n\n    // We must cancel the autogenerated audio player here, or else a\n    // bug where the autogenerated audio player generates duplicate\n    // utterances occurs.\n    this.autogeneratedAudioPlayerService.cancel();\n    if (\n      this._nextFocusLabel &&\n      this.playerTranscriptService.isLastCard(index)\n    ) {\n      this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);\n    } else {\n      this.focusManagerService.setFocusIfOnDesktop(\n        this.getContentFocusLabel(index)\n      );\n    }\n  }\n\n  returnToExplorationAfterConceptCard(): void {\n    this.playerTranscriptService.addPreviousCard();\n    let numCards = this.playerTranscriptService.getNumCards();\n    this.playerPositionService.setDisplayedCardIndex(numCards - 1);\n  }\n\n  isCurrentCardAtEndOfTranscript(): boolean {\n    return this.playerTranscriptService.isLastCard(\n      this.playerPositionService.getDisplayedCardIndex()\n    );\n  }\n\n  private _addNewCard(newCard): void {\n    this.conversationFlowService.addNewCard(newCard);\n\n    let totalNumCards = this.playerTranscriptService.getNumCards();\n\n    let previousSupplementalCardIsNonempty =\n      totalNumCards > 1 &&\n      this.conversationFlowService.isSupplementalCardNonempty(\n        this.playerTranscriptService.getCard(totalNumCards - 2)\n      );\n\n    let nextSupplementalCardIsNonempty =\n      this.conversationFlowService.isSupplementalCardNonempty(\n        this.playerTranscriptService.getLastCard()\n      );\n\n    if (\n      totalNumCards > 1 &&\n      this.canWindowShowTwoCards() &&\n      !previousSupplementalCardIsNonempty &&\n      nextSupplementalCardIsNonempty\n    ) {\n      this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);\n      this.animateToTwoCards(function () {});\n    } else if (\n      totalNumCards > 1 &&\n      this.canWindowShowTwoCards() &&\n      previousSupplementalCardIsNonempty &&\n      !nextSupplementalCardIsNonempty\n    ) {\n      this.animateToOneCard(() => {\n        this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);\n      });\n    } else {\n      this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);\n    }\n    this.playerPositionService.changeCurrentQuestion(\n      this.playerPositionService.getDisplayedCardIndex()\n    );\n\n    if (this.displayedCard && this.displayedCard.isTerminal()) {\n      this.isRefresherExploration = false;\n      this.parentExplorationIds =\n        this.urlService.getQueryFieldValuesAsList('parent');\n      let recommendedExplorationIds = [];\n      let includeAutogeneratedRecommendations = false;\n\n      if (this.parentExplorationIds.length > 0) {\n        this.isRefresherExploration = true;\n        let parentExplorationId =\n          this.parentExplorationIds[this.parentExplorationIds.length - 1];\n        recommendedExplorationIds.push(parentExplorationId);\n      } else {\n        recommendedExplorationIds =\n          this.explorationEngineService.getAuthorRecommendedExpIdsByStateName(\n            this.displayedCard.getStateName()\n          );\n        includeAutogeneratedRecommendations = true;\n      }\n\n      if (this.explorationPlayerStateService.isInStoryChapterMode()) {\n        recommendedExplorationIds = [];\n        includeAutogeneratedRecommendations = false;\n        let topicUrlFragment =\n          this.urlService.getUrlParams().topic_url_fragment;\n        let classroomUrlFragment =\n          this.urlService.getUrlParams().classroom_url_fragment;\n        let storyUrlFragment =\n          this.urlService.getUrlParams().story_url_fragment;\n        let nodeId = this.urlService.getUrlParams().node_id;\n        this.inStoryMode = true;\n        this.storyViewerBackendApiService\n          .fetchStoryDataAsync(\n            topicUrlFragment,\n            classroomUrlFragment,\n            storyUrlFragment\n          )\n          .then(res => {\n            let nextStoryNode: LearnerExplorationSummary[] = [];\n            for (let i = 0; i < res.nodes.length; i++) {\n              if (res.nodes[i].id === nodeId && i + 1 < res.nodes.length) {\n                this.storyNodeIdToAdd = res.nodes[i].destinationNodeIds[0];\n                nextStoryNode.push(res.nodes[i + 1].explorationSummary);\n                break;\n              }\n            }\n            this.recommendedExplorationSummaries = nextStoryNode;\n          });\n        if (this.isLoggedIn) {\n          this.storyViewerBackendApiService\n            .recordChapterCompletionAsync(\n              topicUrlFragment,\n              classroomUrlFragment,\n              storyUrlFragment,\n              nodeId\n            )\n            .then(returnObject => {\n              if (returnObject.readyForReviewTest) {\n                (\n                  this.windowRef.nativeWindow as {location: string | Location}\n                ).location = this.urlInterpolationService.interpolateUrl(\n                  TopicViewerDomainConstants.REVIEW_TESTS_URL_TEMPLATE,\n                  {\n                    topic_url_fragment: topicUrlFragment,\n                    classroom_url_fragment: classroomUrlFragment,\n                    story_url_fragment: storyUrlFragment,\n                  }\n                );\n              }\n              this.learnerDashboardBackendApiService\n                .fetchLearnerCompletedChaptersCountDataAsync()\n                .then(responseData => {\n                  let newCompletedChaptersCount =\n                    responseData.completedChaptersCount;\n                  if (\n                    newCompletedChaptersCount !== this.completedChaptersCount\n                  ) {\n                    this.completedChaptersCount = newCompletedChaptersCount;\n                    this.chapterIsCompletedForTheFirstTime = true;\n                  }\n                });\n            });\n        } else {\n          let loginRedirectUrl = this.urlInterpolationService.interpolateUrl(\n            StoryViewerDomainConstants.STORY_PROGRESS_URL_TEMPLATE,\n            {\n              topic_url_fragment: topicUrlFragment,\n              classroom_url_fragment: classroomUrlFragment,\n              story_url_fragment: storyUrlFragment,\n              node_id: nodeId,\n            }\n          );\n          this.userService.setReturnUrl(loginRedirectUrl);\n        }\n      } else {\n        this.explorationRecommendationsService.getRecommendedSummaryDicts(\n          recommendedExplorationIds,\n          includeAutogeneratedRecommendations,\n          summaries => {\n            this.recommendedExplorationSummaries = summaries;\n          }\n        );\n      }\n\n      if (!this.showProgressClearanceMessage) {\n        this.showProgressClearanceMessage = true;\n        setTimeout(() => {\n          let alertInfoElement = document.querySelector(\n            '.oppia-exploration-checkpoints-message'\n          );\n\n          // Remove the alert message after 6 sec.\n          if (alertInfoElement) {\n            alertInfoElement.remove();\n          }\n        }, this.alertMessageTimeout);\n      }\n    }\n  }\n\n  triggerIfLearnerStuckAction(): void {\n    if (this.responseTimeout) {\n      clearTimeout(this.responseTimeout);\n      this.responseTimeout = null;\n    }\n    this.responseTimeout = setTimeout(() => {\n      if (this.nextCardIfStuck && this.nextCardIfStuck !== this.displayedCard) {\n        // Let the learner know about the redirection to a state\n        // for clearing concepts.\n        this.playerTranscriptService.addNewResponseToExistingFeedback(\n          this.translateService.instant(\n            'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'\n          )\n        );\n        // Enable visibility of ContinueToRevise button.\n        this.continueToReviseStateButtonIsVisible = true;\n      } else if (\n        this.solutionForState !== null &&\n        this.numberOfIncorrectSubmissions >=\n          ExplorationPlayerConstants.MAX_INCORRECT_ANSWERS_BEFORE_RELEASING_SOLUTION\n      ) {\n        // Release solution if no separate state for addressing\n        // the stuck learner exists and the solution exists.\n        this.hintsAndSolutionManagerService.releaseSolution();\n      }\n    }, ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC);\n  }\n\n  triggerIfLearnerStuckActionDirectly(): void {\n    if (this.responseTimeout) {\n      clearTimeout(this.responseTimeout);\n      this.responseTimeout = null;\n    }\n    // Directly trigger action for the really stuck learner.\n    if (this.nextCardIfStuck && this.nextCardIfStuck !== this.displayedCard) {\n      this.playerTranscriptService.addNewResponseToExistingFeedback(\n        this.translateService.instant('I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE')\n      );\n      // Enable visibility of ContinueToRevise button.\n      this.continueToReviseStateButtonIsVisible = true;\n    } else if (\n      this.solutionForState !== null &&\n      this.numberOfIncorrectSubmissions >=\n        ExplorationPlayerConstants.MAX_INCORRECT_ANSWERS_BEFORE_RELEASING_SOLUTION\n    ) {\n      // Release solution if it exists.\n      this.hintsAndSolutionManagerService.releaseSolution();\n    }\n  }\n\n  triggerRedirectionToStuckState(): void {\n    // Redirect the learner.\n    this.nextCard = this.nextCardIfStuck;\n    this.showInteraction = false;\n    this.showPendingCard();\n  }\n\n  showQuestionAreNotAvailable(): void {\n    this.loaderService.hideLoadingScreen();\n  }\n\n  private _initializeDirectiveComponents(initialCard, focusLabel): void {\n    this._addNewCard(initialCard);\n    this.nextCard = initialCard;\n    if (!this.explorationPlayerStateService.isInDiagnosticTestPlayerMode()) {\n      this.explorationPlayerStateService.onPlayerStateChange.emit(\n        this.nextCard.getStateName()\n      );\n    }\n\n    // We do not store checkpoints progress for iframes hence we do not\n    // need to consider redirecting the user to the most recently\n    // reached checkpoint on exploration initial load in that case.\n    if (\n      !this.isIframed &&\n      !this._editorPreviewMode &&\n      !this.explorationPlayerStateService.isInQuestionPlayerMode() &&\n      !this.explorationPlayerStateService.isInDiagnosticTestPlayerMode()\n    ) {\n      // Navigate the learner to the most recently reached checkpoint state.\n      this._navigateToMostRecentlyReachedCheckpoint();\n    }\n    this.hasFullyLoaded = true;\n\n    this.focusManagerService.setFocusIfOnDesktop(focusLabel);\n    this.loaderService.hideLoadingScreen();\n\n    // If the exploration is embedded, use the url language code\n    // as site language. If the url language code is not supported\n    // as site language, English is used as default.\n    let langCodes = AppConstants.SUPPORTED_SITE_LANGUAGES.map(language => {\n      return language.id;\n    }) as string[];\n    if (this.isIframed) {\n      let urlLanguageCode = this.urlService.getUrlParams().lang;\n      if (urlLanguageCode && langCodes.indexOf(urlLanguageCode) !== -1) {\n        this.i18nLanguageCodeService.setI18nLanguageCode(urlLanguageCode);\n      } else {\n        this.i18nLanguageCodeService.setI18nLanguageCode('en');\n      }\n    }\n    this.adjustPageHeight(false, null);\n    this.windowRef.nativeWindow.scrollTo(0, 0);\n\n    // The timeout is needed in order to give the recipient of the\n    // broadcast sufficient time to load.\n    setTimeout(() => {\n      this.playerPositionService.onNewCardOpened.emit(initialCard);\n    });\n  }\n\n  skipCurrentQuestion(): void {\n    this.explorationPlayerStateService.skipCurrentQuestion(nextCard => {\n      this.nextCard = nextCard;\n      this.showPendingCard();\n    });\n  }\n\n  initializePage(): void {\n    this.hasInteractedAtLeastOnce = false;\n    this.recommendedExplorationSummaries = [];\n    this.playerPositionService.init(this._navigateToDisplayedCard.bind(this));\n    if (this.questionPlayerConfig) {\n      this.explorationPlayerStateService.initializeQuestionPlayer(\n        this.questionPlayerConfig,\n        this._initializeDirectiveComponents.bind(this),\n        this.showQuestionAreNotAvailable\n      );\n    } else if (this.diagnosticTestTopicTrackerModel) {\n      this.explorationPlayerStateService.initializeDiagnosticPlayer(\n        this.diagnosticTestTopicTrackerModel,\n        this._initializeDirectiveComponents.bind(this)\n      );\n    } else {\n      this.explorationPlayerStateService.initializePlayer(\n        this._initializeDirectiveComponents.bind(this)\n      );\n    }\n  }\n\n  submitAnswer(\n    answer: string,\n    interactionRulesService: InteractionRulesService\n  ): void {\n    this.displayedCard.updateCurrentAnswer(null);\n\n    // Safety check to prevent double submissions from occurring.\n    if (\n      this.answerIsBeingProcessed ||\n      !this.isCurrentCardAtEndOfTranscript() ||\n      this.displayedCard.isCompleted()\n    ) {\n      return;\n    }\n\n    if (!this.isInPreviewMode) {\n      this.fatigueDetectionService.recordSubmissionTimestamp();\n      if (this.fatigueDetectionService.isSubmittingTooFast()) {\n        this.fatigueDetectionService.displayTakeBreakMessage();\n        this.explorationPlayerStateService.onOppiaFeedbackAvailable.emit();\n        return;\n      }\n    }\n\n    if (\n      !this.isInPreviewMode &&\n      !this.explorationPlayerStateService.isPresentingIsolatedQuestions() &&\n      AppConstants.ENABLE_SOLICIT_ANSWER_DETAILS_FEATURE\n    ) {\n      this.initLearnerAnswerInfoService(\n        this.explorationId,\n        this.explorationEngineService.getState(),\n        answer,\n        interactionRulesService,\n        this.alwaysAskLearnerForAnswerDetails()\n      );\n    }\n\n    this.numberAttemptsService.submitAttempt();\n\n    this.answerIsBeingProcessed = true;\n    this.hasInteractedAtLeastOnce = true;\n\n    this.playerTranscriptService.addNewInput(answer, false);\n\n    if (this.getCanAskLearnerForAnswerInfo()) {\n      setTimeout(() => {\n        this.playerTranscriptService.addNewResponse(\n          this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion()\n        );\n        this.answerIsBeingProcessed = false;\n        this.playerPositionService.onHelpCardAvailable.emit({\n          helpCardHtml:\n            this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion(),\n          hasContinueButton: false,\n        });\n      }, 100);\n      return;\n    }\n\n    let timeAtServerCall = new Date().getTime();\n    this.playerPositionService.recordAnswerSubmission();\n    let currentEngineService =\n      this.explorationPlayerStateService.getCurrentEngineService();\n    this.answerIsCorrect = currentEngineService.submitAnswer(\n      answer,\n      interactionRulesService,\n      (\n        nextCard,\n        refreshInteraction,\n        feedbackHtml,\n        feedbackAudioTranslations,\n        refresherExplorationId,\n        missingPrerequisiteSkillId,\n        remainOnCurrentCard,\n        taggedSkillMisconceptionId,\n        wasOldStateInitial,\n        isFirstHit,\n        isFinalQuestion,\n        nextCardIfReallyStuck,\n        focusLabel\n      ) => {\n        this.nextCard = nextCard;\n        this.nextCardIfStuck = nextCardIfReallyStuck;\n        if (\n          !this._editorPreviewMode &&\n          !this.explorationPlayerStateService.isPresentingIsolatedQuestions()\n        ) {\n          let oldStateName = this.playerPositionService.getCurrentStateName();\n          if (!remainOnCurrentCard) {\n            this.statsReportingService.recordStateTransition(\n              oldStateName,\n              nextCard.getStateName(),\n              answer,\n              this.learnerParamsService.getAllParams(),\n              isFirstHit,\n              String(\n                this.completedChaptersCount && this.completedChaptersCount + 1\n              ),\n              String(this.playerTranscriptService.getNumCards()),\n              currentEngineService.getLanguageCode()\n            );\n\n            this.statsReportingService.recordStateCompleted(oldStateName);\n          }\n          if (nextCard.isTerminal()) {\n            this.statsReportingService.recordStateCompleted(\n              nextCard.getStateName()\n            );\n          }\n          if (wasOldStateInitial && !this.explorationActuallyStarted) {\n            this.statsReportingService.recordExplorationActuallyStarted(\n              oldStateName\n            );\n            this.explorationActuallyStarted = true;\n          }\n        }\n\n        if (\n          !this.explorationPlayerStateService.isPresentingIsolatedQuestions()\n        ) {\n          this.explorationPlayerStateService.onPlayerStateChange.emit(\n            nextCard.getStateName()\n          );\n        } else if (\n          this.explorationPlayerStateService.isInQuestionPlayerMode()\n        ) {\n          this.questionPlayerStateService.answerSubmitted(\n            this.questionPlayerEngineService.getCurrentQuestion(),\n            !remainOnCurrentCard,\n            taggedSkillMisconceptionId\n          );\n        }\n\n        let millisecsLeftToWait: number;\n        if (!this.displayedCard.isInteractionInline()) {\n          // Do not wait if the interaction is supplemental -- there's\n          // already a delay bringing in the help card.\n          millisecsLeftToWait = 1.0;\n        } else if (\n          this.explorationPlayerStateService.isInDiagnosticTestPlayerMode()\n        ) {\n          // Do not wait if the player mode is the diagnostic test. Since no\n          // feedback will be presented after attempting a question so delaying\n          // is not required.\n          millisecsLeftToWait = 1.0;\n        } else {\n          millisecsLeftToWait = Math.max(\n            this.MIN_CARD_LOADING_DELAY_MSEC -\n              (new Date().getTime() - timeAtServerCall),\n            1.0\n          );\n        }\n\n        setTimeout(() => {\n          this.explorationPlayerStateService.onOppiaFeedbackAvailable.emit();\n          this.setActiveVoiceover(feedbackHtml);\n          this.voiceoverPlayerService.setActiveComponentName(\n            AppConstants.COMPONENT_NAME_FEEDBACK\n          );\n\n          this.audioPlayerService.onAutoplayAudio.emit({\n            audioTranslations: feedbackAudioTranslations,\n            html: feedbackHtml,\n            componentName: AppConstants.COMPONENT_NAME_FEEDBACK,\n          });\n\n          if (remainOnCurrentCard) {\n            this.giveFeedbackAndStayOnCurrentCard(\n              feedbackHtml,\n              missingPrerequisiteSkillId,\n              refreshInteraction,\n              refresherExplorationId\n            );\n          } else {\n            this.moveToNewCard(feedbackHtml, isFinalQuestion, nextCard);\n          }\n          this.answerIsBeingProcessed = false;\n        }, millisecsLeftToWait);\n      }\n    );\n  }\n\n  setActiveVoiceover(feedbackHtml: string): void {\n    let interaction = this.displayedCard.getInteraction();\n\n    let feedbackContentId =\n      interaction.getContentIdForMatchingHtml(feedbackHtml);\n\n    if (feedbackContentId) {\n      this.voiceoverPlayerService.setActiveVoiceover(feedbackContentId);\n    }\n  }\n\n  private giveFeedbackAndStayOnCurrentCard(\n    feedbackHtml: string | null,\n    missingPrerequisiteSkillId: string | null,\n    refreshInteraction: boolean,\n    refresherExplorationId: string | null\n  ) {\n    this.numberOfIncorrectSubmissions++;\n    this.hintsAndSolutionManagerService.recordWrongAnswer();\n    this.conceptCardManagerService.recordWrongAnswer();\n    this.playerTranscriptService.addNewResponse(feedbackHtml);\n    let helpCardAvailable = false;\n    if (feedbackHtml && !this.displayedCard.isInteractionInline()) {\n      helpCardAvailable = true;\n    }\n\n    if (helpCardAvailable) {\n      this.playerPositionService.onHelpCardAvailable.emit({\n        helpCardHtml: feedbackHtml,\n        hasContinueButton: false,\n      });\n    }\n    if (missingPrerequisiteSkillId) {\n      this.displayedCard.markAsCompleted();\n      this.conceptCardBackendApiService\n        .loadConceptCardsAsync([missingPrerequisiteSkillId])\n        .then(conceptCardObject => {\n          this.conceptCard = conceptCardObject[0];\n          if (helpCardAvailable) {\n            this.playerPositionService.onHelpCardAvailable.emit({\n              helpCardHtml: feedbackHtml,\n              hasContinueButton: true,\n            });\n          }\n        });\n    }\n    if (refreshInteraction) {\n      // Replace the previous interaction with another of the\n      // same type.\n      this._nextFocusLabel = this.focusManagerService.generateFocusLabel();\n      this.playerTranscriptService.updateLatestInteractionHtml(\n        this.displayedCard.getInteractionHtml() + this._getRandomSuffix()\n      );\n    }\n\n    this.redirectToRefresherExplorationConfirmed = false;\n\n    if (refresherExplorationId) {\n      // TODO(bhenning): Add tests to verify the event is\n      // properly recorded.\n      let confirmRedirection = () => {\n        this.redirectToRefresherExplorationConfirmed = true;\n        this._recordLeaveForRefresherExp(refresherExplorationId);\n      };\n      this.explorationSummaryBackendApiService\n        .loadPublicExplorationSummariesAsync([refresherExplorationId])\n        .then(response => {\n          if (response.summaries.length > 0) {\n            this.refresherExplorationConfirmationModalService.displayRedirectConfirmationModal(\n              refresherExplorationId,\n              confirmRedirection\n            );\n          }\n        });\n    }\n    this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);\n    this.scrollToBottom();\n  }\n\n  private moveToNewCard(\n    feedbackHtml: string | null,\n    isFinalQuestion: boolean,\n    nextCard: StateCard\n  ) {\n    // There is a new card. If there is no feedback, move on\n    // immediately. Otherwise, give the learner a chance to read\n    // the feedback, and display a 'Continue' button.\n    this.pendingCardWasSeenBefore = false;\n    this.displayedCard.markAsCompleted();\n    if (isFinalQuestion) {\n      if (this.explorationPlayerStateService.isInQuestionPlayerMode()) {\n        // We will redirect to the results page here.\n        this.questionSessionCompleted = true;\n      }\n      this.moveToExploration = true;\n      if (feedbackHtml) {\n        this.playerTranscriptService.addNewResponse(feedbackHtml);\n        if (!this.displayedCard.isInteractionInline()) {\n          this.playerPositionService.onHelpCardAvailable.emit({\n            helpCardHtml: feedbackHtml,\n            hasContinueButton: true,\n          });\n        }\n      } else {\n        this.showUpcomingCard();\n      }\n      this.answerIsBeingProcessed = false;\n      return;\n    }\n    this.fatigueDetectionService.reset();\n    this.numberAttemptsService.reset();\n\n    let _isNextInteractionInline = this.nextCard.isInteractionInline();\n    this.upcomingInlineInteractionHtml = _isNextInteractionInline\n      ? this.nextCard.getInteractionHtml()\n      : '';\n    this.upcomingInteractionInstructions =\n      this.nextCard.getInteractionInstructions();\n\n    if (feedbackHtml) {\n      if (\n        this.playerTranscriptService.hasEncounteredStateBefore(\n          nextCard.getStateName()\n        )\n      ) {\n        this.pendingCardWasSeenBefore = true;\n      }\n      this.playerTranscriptService.addNewResponse(feedbackHtml);\n      if (!this.displayedCard.isInteractionInline()) {\n        this.playerPositionService.onHelpCardAvailable.emit({\n          helpCardHtml: feedbackHtml,\n          hasContinueButton: true,\n        });\n      }\n      this.playerPositionService.onNewCardAvailable.emit();\n      this._nextFocusLabel =\n        ExplorationPlayerConstants.CONTINUE_BUTTON_FOCUS_LABEL;\n      this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);\n      this.scrollToBottom();\n    } else {\n      this.playerTranscriptService.addNewResponse(feedbackHtml);\n      // If there is no feedback, it immediately moves on\n      // to next card. Therefore this.answerIsCorrect needs\n      // to be set to false before it proceeds to next card.\n      this.answerIsCorrect = false;\n      this.showPendingCard();\n    }\n    this.currentInteractionService.clearPresubmitHooks();\n  }\n\n  showPendingCard(): void {\n    this.startCardChangeAnimation = true;\n    this.explorationPlayerStateService.recordNewCardAdded();\n\n    setTimeout(\n      () => {\n        this._addNewCard(this.nextCard);\n\n        this.upcomingInlineInteractionHtml = null;\n        this.upcomingInteractionInstructions = null;\n      },\n      0.1 * TIME_FADEOUT_MSEC + 0.1 * TIME_HEIGHT_CHANGE_MSEC\n    );\n\n    setTimeout(\n      () => {\n        this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);\n        this.scrollToTop();\n      },\n      0.1 * TIME_FADEOUT_MSEC + TIME_HEIGHT_CHANGE_MSEC + 0.5 * TIME_FADEIN_MSEC\n    );\n\n    setTimeout(\n      () => {\n        this.startCardChangeAnimation = false;\n      },\n      0.1 * TIME_FADEOUT_MSEC +\n        TIME_HEIGHT_CHANGE_MSEC +\n        TIME_FADEIN_MSEC +\n        this.TIME_PADDING_MSEC\n    );\n\n    this.playerPositionService.onNewCardOpened.emit(this.nextCard);\n  }\n\n  showUpcomingCard(): void {\n    let currentIndex = this.playerPositionService.getDisplayedCardIndex();\n    let conceptCardIsBeingShown =\n      this.displayedCard.getStateName() === null &&\n      !this.explorationPlayerStateService.isInQuestionMode();\n    if (\n      conceptCardIsBeingShown &&\n      this.playerTranscriptService.isLastCard(currentIndex)\n    ) {\n      this.returnToExplorationAfterConceptCard();\n      return;\n    }\n    if (this.questionSessionCompleted) {\n      this.questionPlayerStateService.onQuestionSessionCompleted.emit(\n        this.questionPlayerStateService.getQuestionPlayerStateData()\n      );\n      return;\n    }\n    if (this.moveToExploration) {\n      this.moveToExploration = false;\n      this.explorationPlayerStateService.moveToExploration(\n        this._initializeDirectiveComponents.bind(this)\n      );\n      return;\n    }\n    if (\n      this.displayedCard.isCompleted() &&\n      this.nextCard.getStateName() === this.displayedCard.getStateName() &&\n      this.conceptCard\n    ) {\n      this.explorationPlayerStateService.recordNewCardAdded();\n      this._addNewCard(\n        StateCard.createNewCard(\n          null,\n          this.conceptCard.getExplanation().html,\n          null,\n          null,\n          null,\n          null,\n          this.audioTranslationLanguageService\n        )\n      );\n      return;\n    }\n    if (this.isLearnAgainButton()) {\n      const indexOfRevisionCard =\n        this.playerTranscriptService.findIndexOfLatestStateWithName(\n          this.nextCard.getStateName()\n        );\n      if (indexOfRevisionCard !== null) {\n        this.displayedCard.markAsNotCompleted();\n        this.changeCard(indexOfRevisionCard);\n        return;\n      }\n    }\n    /* This is for the following situation:\n        if A->B->C is the arrangement of cards and C redirected to A,\n        then after this, B and C are visited cards and hence\n        pendingCardWasSeenBefore would be true during both these\n        transitions and as answerIsCorrect is set to false below,\n        Continue would briefly change to Learn Again (after it is\n        clicked) during these transitions which is not required.\n        Also, if the 'if' check is not there, Learn Again button would\n        briefly switched to Continue before going to next card. */\n    if (this.answerIsCorrect) {\n      this.pendingCardWasSeenBefore = false;\n    }\n    this.answerIsCorrect = false;\n    this.showPendingCard();\n  }\n\n  scrollToBottom(): void {\n    setTimeout(() => {\n      let tutorCard = $('.conversation-skin-main-tutor-card');\n\n      if (tutorCard && tutorCard.length === 0) {\n        return;\n      }\n      let tutorCardBottom = tutorCard.offset().top + tutorCard.outerHeight();\n      if ($(window).scrollTop() + $(window).height() < tutorCardBottom) {\n        $('html, body').animate(\n          {\n            scrollTop: tutorCardBottom - $(window).height() + 12,\n          },\n          {\n            duration: this.TIME_SCROLL_MSEC,\n            easing: 'easeOutQuad',\n          }\n        );\n      }\n    }, 100);\n  }\n\n  scrollToTop(): void {\n    setTimeout(() => {\n      $('html, body').animate(\n        {\n          scrollTop: 0,\n        },\n        800,\n        'easeOutQuart'\n      );\n      return false;\n    });\n  }\n\n  onNavigateFromIframe(): void {\n    this.siteAnalyticsService.registerVisitOppiaFromIframeEvent(\n      this.explorationId\n    );\n  }\n\n  submitAnswerFromProgressNav(): void {\n    this.displayedCard.toggleSubmitClicked(true);\n    this.currentInteractionService.submitAnswer();\n  }\n\n  getRecommendedExpTitleTranslationKey(explorationId: string): string {\n    return this.i18nLanguageCodeService.getExplorationTranslationKey(\n      explorationId,\n      TranslationKeyType.TITLE\n    );\n  }\n\n  isHackyExpTitleTranslationDisplayed(explorationId: string): boolean {\n    let recommendedExpTitleTranslationKey =\n      this.getRecommendedExpTitleTranslationKey(explorationId);\n    return (\n      this.i18nLanguageCodeService.isHackyTranslationAvailable(\n        recommendedExpTitleTranslationKey\n      ) && !this.i18nLanguageCodeService.isCurrentLanguageEnglish()\n    );\n  }\n\n  isDisplayedCardCompletedInPrevSession(): boolean {\n    return (\n      this.displayedCard.getInteraction() &&\n      this.prevSessionStatesProgress.indexOf(\n        this.displayedCard.getStateName()\n      ) !== -1\n    );\n  }\n\n  isProgressClearanceMessageShown(): boolean {\n    return this.showProgressClearanceMessage;\n  }\n\n  // Returns whether the screen is wide enough to fit two\n  // cards (e.g., the tutor and supplemental cards) side-by-side.\n  canWindowShowTwoCards(): boolean {\n    return (\n      this.windowDimensionsService.getWidth() >\n      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX\n    );\n  }\n\n  animateToTwoCards(doneCallback: () => void): void {\n    this.isAnimatingToTwoCards = true;\n    setTimeout(\n      () => {\n        this.isAnimatingToTwoCards = false;\n        if (doneCallback) {\n          doneCallback();\n        }\n      },\n      TIME_NUM_CARDS_CHANGE_MSEC + TIME_FADEIN_MSEC + this.TIME_PADDING_MSEC\n    );\n  }\n\n  animateToOneCard(doneCallback: () => void): void {\n    this.isAnimatingToOneCard = true;\n    setTimeout(() => {\n      this.isAnimatingToOneCard = false;\n      if (doneCallback) {\n        doneCallback();\n      }\n    }, TIME_NUM_CARDS_CHANGE_MSEC);\n  }\n}\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/ratings-and-recommendations.component.html",
      "content": "<ng-template #popContent>\n  <oppia-feedback-popup (closePopover)=\"closePopover()\"></oppia-feedback-popup>\n</ng-template>\n<div class=\"conversation-skin-final-summary\">\n  <div *ngIf=\"userIsLoggedIn && !explorationIsInPreviewMode\" class=\"conversation-skin-final-ratings\">\n    <div class=\"conversation-skin-final-ratings-header\"\n         tabindex=\"0\"\n         translate=\"I18N_PLAYER_RATE_EXPLORATION\">\n    </div>\n    <div placement=\"bottom\"\n         [ngbPopover]=\"popContent\"\n         trigger=\"manual\"\n         (click)=\"togglePopover\"\n         #feedbackPopOver=\"ngbPopover\"\n         [autoClose]=\"false\">\n      <oppia-rating-display [ratingValue]=\"userRating\"\n                            [isEditable]=\"true\"\n                            (edit)=\"submitUserRating($event)\"\n                            class=\"conversation-skin-final-ratings-display\">\n      </oppia-rating-display>\n    </div>\n  </div>\n\n  <div *ngIf=\"!collectionSummary && !inStoryMode && recommendedExplorationSummaries && recommendedExplorationSummaries.length > 0\"\n       class=\"conversation-skin-final-recommendations\">\n    <div *ngIf=\"recommendedExplorationSummaries.length > 0\">\n      <div class=\"conversation-skin-final-recommendations-header-container\">\n        <span *ngIf=\"!collectionSummary && !isRefresherExploration\" class=\"conversation-skin-final-recommendations-header\"\n              translate=\"I18N_END_EXPLORATION_RECOMMENDATION_MESSAGE\">\n        </span>\n      </div>\n      <div class=\"ratings-and-recommendations-exp-summary-tiles-container conversation-skin-recommended-activities-container\">\n        <oppia-exploration-summary-tile *ngFor=\"let exp of (recommendedExplorationSummaries|limitTo:3)\"\n                                        [collectionId]=\"collectionId\"\n                                        [explorationId]=\"exp.id\"\n                                        [explorationTitle]=\"exp.title\"\n                                        [parentExplorationIds]=\"parentExplorationIds\"\n                                        [lastUpdatedMsec]=\"exp.lastUpdatedMsec\"\n                                        [objective]=\"exp.objective\"\n                                        [category]=\"exp.category\"\n                                        [ratings]=\"exp.ratings\"\n                                        [thumbnailIconUrl]=\"exp.thumbnailIconUrl\"\n                                        [thumbnailBgColor]=\"exp.thumbnailBgColor\"\n                                        [numViews]=\"exp.numViews\"\n                                        [isCommunityOwned]=\"exp.communityOwned\"\n                                        [mobileCutoffPx]=\"5000\"\n                                        class=\"ratings-component-oppia-exploration-summary-tile\">\n        </oppia-exploration-summary-tile>\n      </div>\n    </div>\n  </div>\n\n  <div *ngIf=\"inStoryMode && !userIsLoggedIn && !isSignUpSectionHidden()\" class=\"conversation-skin-login-container e2e-test-end-chapter-sign-up-section\">\n    <div class=\"conversation-skin-congratulations-text\" translate=\"I18N_CHAPTER_COMPLETION\"></div>\n    <span class=\"conversation-skin-login-text text-secondary\" translate=\"I18N_SAVE_PROGRESS\"></span>\n    <div class=\"mt-2\">\n      <button mat-button class=\"md-raised oppia-sign-up-button e2e-test-login-button text-light\" (click)=\"signIn('.oppia-sign-up-button')\">\n        SIGN UP\n      </button>\n    </div>\n    <div class=\"conversation-skin-login-secondary-options\">\n      <button class=\"conversation-skin-login-button\">\n        Already have an account?\n        <span class=\"conversation-skin-login-button-text\" translate=\"\" (click)=\"signIn('.conversation-skin-login-button-text')\">Sign In</span>\n      </button>\n      <button class=\"conversation-skin-hide-sign-up-section-button e2e-test-dismiss-sign-up-section-button\">\n        <span class=\"conversation-skin-hide-sign-up-section-text\" translate=\"I18N_SIGNUP_SECTION_DONT_ASK_ME_AGAIN\" (click)=\"hideSignUpSection()\"></span>\n      </button>\n    </div>\n  </div>\n  <div *ngIf=\"inStoryMode  && storyId\">\n    <oppia-post-chapter-recommendations [nextStoryNodeLink]=\"nextLessonLink\"\n                                        [nextStoryNodeThumbnailUrl]=\"nextStoryNodeIconUrl ? nextStoryNodeIconUrl : ''\"\n                                        [nextStoryNodeThumbnailBgColor]=\"nextStoryNode ? nextStoryNode.thumbnailBgColor : ''\"\n                                        [nextStoryNodeTitle]=\"nextStoryNode ? nextStoryNode.title : ''\"\n                                        [practiceQuestionsAreEnabled]=\"practiceQuestionsAreEnabled\">\n    </oppia-post-chapter-recommendations>\n  </div>\n\n  <div *ngIf=\"inStoryMode\" class=\"conversation-skin-back-to-collection-container\">\n    <a [href]=\"storyViewerUrl\" class=\"conversation-skin-back-to-collection\" translate=\"I18N_PLAYER_RETURN_TO_STORY\"></a>\n  </div>\n  <div *ngIf=\"!collectionSummary && !isRefresherExploration && !inStoryMode\" class=\"conversation-skin-back-to-collection-container\">\n    <a href=\"/community-library\" class=\"conversation-skin-back-to-collection\" translate=\"I18N_PLAYER_RETURN_TO_LIBRARY\"></a>\n  </div>\n  <div *ngIf=\"collectionSummary && !isRefresherExploration\" class=\"conversation-skin-back-to-collection-container\">\n    <a [href]=\"'/collection/' + collectionId\" class=\"conversation-skin-back-to-collection\" translate=\"I18N_PLAYER_BACK_TO_COLLECTION\"></a>\n  </div>\n</div>\n\n<style>\n  .oppia-sign-up-button {\n    background-color: #00645c;\n    border-radius: 15px;\n    font-size: 1em;\n    margin-bottom: 25px;\n    min-width: max-content;\n    width: 154px;\n  }\n  .conversation-skin-final-summary {\n    margin-bottom: 25px;\n    margin-top: 20px;\n  }\n\n  .conversation-skin-final-ratings-header {\n    color: #064b46;\n    margin: 20px 0 0;\n  }\n\n  .conversation-skin-final-ratings {\n    background-color: white;\n    border-bottom: 2px solid #bbb;\n    border-top: 2px solid #bbb;\n    margin: 0 auto 60px;\n    padding: 0 0 20px 0;\n    text-align: center;\n  }\n\n  .conversation-skin-final-ratings-display {\n    color: #064b46;\n    letter-spacing: 10px;\n  }\n\n  .conversation-skin-final-recommendations-header {\n    color: #064b46;\n    font-size: 150%;\n  }\n\n  .conversation-skin-final-recommendations-header-container {\n    text-align: center;\n  }\n\n  .conversation-skin-recommended-activities-container {\n    padding-top: 10px;\n  }\n\n  .conversation-skin-back-to-collection-container {\n    border: 1px solid #00645c;\n    border-radius: 40px;\n    margin: auto;\n    padding: 5px;\n    text-align: center;\n    width: 35%;\n  }\n\n  .conversation-skin-back-to-collection {\n    color: #064b46;\n  }\n\n  .conversation-skin-login-container {\n    background-color: #fff;\n    border-bottom: 2px solid #bbb;\n    border-top: 2px solid #bbb;\n    margin-bottom: 24px;\n    margin-top: 24px;\n    padding: 1.5em 2em;\n    padding-bottom: 0.5em;\n    text-align: center;\n    width: 100%;\n  }\n\n  .conversation-skin-login-container .conversation-skin-login-text {\n    font-size: 0.8em;\n  }\n\n  .conversation-skin-login-container .conversation-skin-congratulations-text {\n    font-size: 1.2em;\n    font-weight: 500;\n  }\n\n  .conversation-skin-login-container .conversation-skin-hide-sign-up-section-text {\n    color: #00645c;\n    cursor: pointer;\n    text-decoration: underline;\n  }\n\n  .conversation-skin-login-container .conversation-skin-login-button-text {\n    color: #00645c;\n    cursor: pointer;\n    text-decoration: underline;\n  }\n\n  .conversation-skin-login-container .conversation-skin-login-secondary-options {\n    display: flex;\n    justify-content: space-between;\n  }\n\n  .conversation-skin-login-secondary-options button {\n    background: none;\n    border: none;\n    cursor: default;\n    font-size: 0.8em;\n  }\n\n  .ratings-and-recommendations-exp-summary-tiles-container {\n      align-items: center;\n      display: flex;\n      flex-direction: column;\n      height: 100%;\n      margin-left: auto;\n      margin-right: auto;\n      padding-bottom: 24px;\n      padding-top: 24px;\n  }\n\n  @media screen and (max-width: 959px) {\n    .conversation-skin-final-summary {\n      margin: 0 auto;\n      max-width: 650px;\n      width: 100%;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/ratings-and-recommendations.component.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for ratings and recommendations component.\n */\n\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\nimport {EventEmitter, NO_ERRORS_SCHEMA} from '@angular/core';\nimport {\n  ComponentFixture,\n  fakeAsync,\n  TestBed,\n  tick,\n  waitForAsync,\n} from '@angular/core/testing';\nimport {NgbPopoverModule} from '@ng-bootstrap/ng-bootstrap';\nimport {TranslateService} from '@ngx-translate/core';\nimport {MockTranslateService} from 'components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';\nimport {AlertsService} from 'services/alerts.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {UserService} from 'services/user.service';\nimport {LearnerViewRatingService} from '../services/learner-view-rating.service';\nimport {MockLimitToPipe} from 'pages/exploration-player-page/templates/lesson-information-card-modal.component.spec';\nimport {RatingsAndRecommendationsComponent} from './ratings-and-recommendations.component';\nimport {ExplorationPlayerStateService} from './../services/exploration-player-state.service';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {LocalStorageService} from 'services/local-storage.service';\nimport {AssetsBackendApiService} from 'services/assets-backend-api.service';\nimport {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';\nimport {TopicViewerBackendApiService} from 'domain/topic_viewer/topic-viewer-backend-api.service';\nimport {StoryPlaythrough} from 'domain/story_viewer/story-playthrough.model';\nimport {ReadOnlyStoryNode} from 'domain/story_viewer/read-only-story-node.model';\nimport {ReadOnlyTopic} from 'domain/topic_viewer/read-only-topic-object.factory';\nimport {LearnerExplorationSummary} from 'domain/summary/learner-exploration-summary.model';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\n\ndescribe('Ratings and recommendations component', () => {\n  let fixture: ComponentFixture<RatingsAndRecommendationsComponent>;\n  let componentInstance: RatingsAndRecommendationsComponent;\n  let alertsService: AlertsService;\n  let learnerViewRatingService: LearnerViewRatingService;\n  let urlService: UrlService;\n  let userService: UserService;\n  let explorationPlayerStateService: ExplorationPlayerStateService;\n  let urlInterpolationService: UrlInterpolationService;\n  let localStorageService: LocalStorageService;\n  let assetsBackendApiService: AssetsBackendApiService;\n  let storyViewerBackendApiService: StoryViewerBackendApiService;\n  let topicViewerBackendApiService: TopicViewerBackendApiService;\n  let siteAnalyticsService: SiteAnalyticsService;\n\n  const mockNgbPopover = jasmine.createSpyObj('NgbPopover', [\n    'close',\n    'toggle',\n    'open',\n  ]);\n\n  class MockWindowRef {\n    nativeWindow = {\n      location: {\n        search: '',\n        pathname: '/path/name',\n        reload: () => {},\n      },\n    };\n  }\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule, NgbPopoverModule],\n      declarations: [RatingsAndRecommendationsComponent, MockLimitToPipe],\n      providers: [\n        AlertsService,\n        LearnerViewRatingService,\n        UrlService,\n        UserService,\n        ExplorationPlayerStateService,\n        UrlInterpolationService,\n        AssetsBackendApiService,\n        StoryViewerBackendApiService,\n        TopicViewerBackendApiService,\n        LocalStorageService,\n        {\n          provide: WindowRef,\n          useClass: MockWindowRef,\n        },\n        {\n          provide: TranslateService,\n          useClass: MockTranslateService,\n        },\n      ],\n      schemas: [NO_ERRORS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(RatingsAndRecommendationsComponent);\n    componentInstance = fixture.componentInstance;\n    alertsService = TestBed.inject(AlertsService);\n    learnerViewRatingService = TestBed.inject(LearnerViewRatingService);\n    urlService = TestBed.inject(UrlService);\n    userService = TestBed.inject(UserService);\n    explorationPlayerStateService = TestBed.inject(\n      ExplorationPlayerStateService\n    );\n    urlInterpolationService = TestBed.inject(UrlInterpolationService);\n    localStorageService = TestBed.inject(LocalStorageService);\n    assetsBackendApiService = TestBed.inject(AssetsBackendApiService);\n    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);\n    topicViewerBackendApiService = TestBed.inject(TopicViewerBackendApiService);\n    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);\n  });\n\n  it(\n    'should populate internal properties and subscribe to event' +\n      ' listeners on initialize',\n    fakeAsync(() => {\n      const collectionId = 'collection_id';\n      const userRating = 5;\n      const mockOnRatingUpdated = new EventEmitter<void>();\n      const readOnlyStoryNode1 = new ReadOnlyStoryNode(\n        'node_1',\n        '',\n        '',\n        [],\n        [],\n        [],\n        '',\n        false,\n        '',\n        {} as LearnerExplorationSummary,\n        false,\n        'bg_color_1',\n        'filename_1'\n      );\n      const readOnlyStoryNode2 = new ReadOnlyStoryNode(\n        'node_2',\n        '',\n        '',\n        [],\n        [],\n        [],\n        '',\n        false,\n        '',\n        {} as LearnerExplorationSummary,\n        false,\n        'bg_color_2',\n        'filename_2'\n      );\n\n      expect(componentInstance.inStoryMode).toBe(undefined);\n      expect(componentInstance.storyViewerUrl).toBe(undefined);\n      expect(componentInstance.practiceQuestionsAreEnabled).toBe(false);\n\n      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(\n        collectionId\n      );\n      spyOn(learnerViewRatingService, 'getUserRating').and.returnValue(\n        userRating\n      );\n      spyOn(alertsService, 'addSuccessMessage');\n      spyOn(learnerViewRatingService, 'init').and.callFake(\n        (callb: (rating: number) => void) => {\n          callb(userRating);\n        }\n      );\n      spyOn(\n        explorationPlayerStateService,\n        'isInStoryChapterMode'\n      ).and.returnValue(true);\n      spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue(\n        'dummy_story_viewer_page_url'\n      );\n      spyOnProperty(\n        learnerViewRatingService,\n        'onRatingUpdated'\n      ).and.returnValue(mockOnRatingUpdated);\n      spyOn(componentInstance, 'getIconUrl').and.returnValue('thumbnail_url');\n      spyOn(urlService, 'getUrlParams').and.returnValue({\n        story_url_fragment: 'story_url_fragment',\n        topic_url_fragment: 'topic_url_fragment',\n        classroom_url_fragment: 'classroom_url_fragment',\n        node_id: 'node_1',\n      });\n      spyOn(\n        storyViewerBackendApiService,\n        'fetchStoryDataAsync'\n      ).and.returnValue(\n        Promise.resolve(\n          new StoryPlaythrough(\n            'story_id',\n            [readOnlyStoryNode1, readOnlyStoryNode2],\n            '',\n            '',\n            '',\n            ''\n          )\n        )\n      );\n      spyOn(\n        topicViewerBackendApiService,\n        'fetchTopicDataAsync'\n      ).and.returnValue(\n        Promise.resolve(\n          new ReadOnlyTopic(\n            'topic_name',\n            'topic_Id',\n            'description',\n            [],\n            [],\n            [],\n            [],\n            {},\n            {},\n            true,\n            'metatag',\n            'page_title_fragment'\n          )\n        )\n      );\n\n      // This throws \"Type 'null' is not assignable to parameter of type\n      // 'QuestionPlayerConfig'.\" We need to suppress this error because\n      // of the need to test validations. This throws an error because\n      // the value is null.\n      // @ts-ignore\n      componentInstance.questionPlayerConfig = null;\n\n      componentInstance.ngOnInit();\n      mockOnRatingUpdated.emit();\n      tick(1000);\n\n      expect(\n        explorationPlayerStateService.isInStoryChapterMode\n      ).toHaveBeenCalled();\n      expect(componentInstance.inStoryMode).toBe(true);\n      expect(componentInstance.storyId).toBe('story_id');\n      expect(componentInstance.nextStoryNode).toBe(readOnlyStoryNode2);\n      expect(componentInstance.getIconUrl).toHaveBeenCalledWith(\n        'story_id',\n        'filename_2'\n      );\n      expect(componentInstance.nextStoryNodeIconUrl).toBe('thumbnail_url');\n      expect(urlInterpolationService.interpolateUrl).toHaveBeenCalled();\n      expect(componentInstance.storyViewerUrl).toBe(\n        'dummy_story_viewer_page_url'\n      );\n      expect(componentInstance.practiceQuestionsAreEnabled).toBe(true);\n      expect(componentInstance.userRating).toEqual(userRating);\n      expect(alertsService.addSuccessMessage).toHaveBeenCalled();\n      expect(learnerViewRatingService.getUserRating).toHaveBeenCalled();\n      expect(componentInstance.collectionId).toEqual(collectionId);\n    })\n  );\n\n  it(\n    'should not generate story page url and determine the next story node' +\n      'if not in story mode',\n    fakeAsync(() => {\n      expect(componentInstance.inStoryMode).toBe(undefined);\n      expect(componentInstance.storyViewerUrl).toBe(undefined);\n\n      spyOn(\n        explorationPlayerStateService,\n        'isInStoryChapterMode'\n      ).and.returnValue(false);\n      spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue(\n        'dummy_story_viewer_page_url'\n      );\n\n      componentInstance.ngOnInit();\n      tick();\n\n      expect(\n        explorationPlayerStateService.isInStoryChapterMode\n      ).toHaveBeenCalled();\n      expect(componentInstance.inStoryMode).toBe(false);\n      expect(urlInterpolationService.interpolateUrl).not.toHaveBeenCalled();\n      expect(componentInstance.storyViewerUrl).toBe(undefined);\n    })\n  );\n\n  it('should obtain next chapter thumbnail url', () => {\n    spyOn(assetsBackendApiService, 'getThumbnailUrlForPreview').and.returnValue(\n      'dummy_thumbnail_url'\n    );\n\n    expect(componentInstance.getIconUrl('story_id', 'thumbnail_filename')).toBe(\n      'dummy_thumbnail_url'\n    );\n    expect(\n      assetsBackendApiService.getThumbnailUrlForPreview\n    ).toHaveBeenCalledWith('story', 'story_id', 'thumbnail_filename');\n  });\n\n  it('should toggle popover when user clicks on rating stars', () => {\n    componentInstance.feedbackPopOver = mockNgbPopover;\n\n    componentInstance.togglePopover();\n\n    // Using feedback popover directly here breaks the principle of\n    // independent unit tests. Hence, mock is used here.\n    // The mock doesn't allow us to check its final state.\n    // So, using a spy on function toggle instead.\n    expect(componentInstance.feedbackPopOver.toggle).toHaveBeenCalled();\n  });\n\n  it('should close popover when user clicks on cancel button', () => {\n    componentInstance.feedbackPopOver = mockNgbPopover;\n\n    componentInstance.closePopover();\n\n    // Using feedback popover directly here breaks the principle of\n    // independent unit tests. Hence, mock is used here.\n    // The mock doesn't allow us to check its final state.\n    // So, using a spy on function toggle instead.\n    expect(componentInstance.feedbackPopOver.close).toHaveBeenCalled();\n  });\n\n  it('should submit user rating when user clicks on rating star', () => {\n    spyOn(learnerViewRatingService, 'submitUserRating');\n    componentInstance.feedbackPopOver = mockNgbPopover;\n    const userRating = 5;\n\n    componentInstance.submitUserRating(userRating);\n\n    expect(learnerViewRatingService.submitUserRating).toHaveBeenCalledWith(\n      userRating\n    );\n  });\n\n  it('should redirect to sign in page when user clicks on signin button', fakeAsync(() => {\n    spyOn(siteAnalyticsService, 'registerNewSignupEvent');\n    spyOn(userService, 'getLoginUrlAsync').and.returnValue(\n      Promise.resolve('login_url')\n    );\n\n    componentInstance.signIn('.sign-in-button');\n    tick();\n\n    expect(userService.getLoginUrlAsync).toHaveBeenCalled();\n    expect(siteAnalyticsService.registerNewSignupEvent).toHaveBeenCalled();\n  }));\n\n  it(\n    'should reload the page if user clicks on signin button and ' +\n      'login url is not available',\n    fakeAsync(() => {\n      spyOn(siteAnalyticsService, 'registerNewSignupEvent');\n      spyOn(userService, 'getLoginUrlAsync').and.returnValue(\n        Promise.resolve('')\n      );\n\n      componentInstance.signIn('.sign-in-button');\n      tick();\n\n      expect(userService.getLoginUrlAsync).toHaveBeenCalled();\n      expect(siteAnalyticsService.registerNewSignupEvent).toHaveBeenCalled();\n    })\n  );\n\n  it(\"should save user's sign up section preference to localStorage\", () => {\n    spyOn(localStorageService, 'updateEndChapterSignUpSectionHiddenPreference');\n\n    componentInstance.hideSignUpSection();\n\n    expect(\n      localStorageService.updateEndChapterSignUpSectionHiddenPreference\n    ).toHaveBeenCalledWith('true');\n  });\n\n  it(\"should get user's sign up section preference from localStorage\", () => {\n    const getPreferenceSpy = spyOn(\n      localStorageService,\n      'getEndChapterSignUpSectionHiddenPreference'\n    ).and.returnValue('true');\n\n    expect(componentInstance.isSignUpSectionHidden()).toBe(true);\n    expect(\n      localStorageService.getEndChapterSignUpSectionHiddenPreference\n    ).toHaveBeenCalled();\n\n    getPreferenceSpy.and.returnValue(null);\n\n    expect(componentInstance.isSignUpSectionHidden()).toBe(false);\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/ratings-and-recommendations.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for ratings and recommendations to be shown\n * on conversation skin.\n */\n\nimport {Component, Input, ViewChild} from '@angular/core';\nimport {NgbPopover} from '@ng-bootstrap/ng-bootstrap';\nimport {CollectionSummary} from 'domain/collection/collection-summary.model';\nimport {LearnerExplorationSummary} from 'domain/summary/learner-exploration-summary.model';\nimport {Subscription} from 'rxjs';\nimport {AlertsService} from 'services/alerts.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {UserService} from 'services/user.service';\nimport {LearnerViewRatingService} from '../services/learner-view-rating.service';\nimport {ExplorationPlayerStateService} from './../services/exploration-player-state.service';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {TopicViewerDomainConstants} from 'domain/topic_viewer/topic-viewer-domain.constants';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\nimport {LocalStorageService} from 'services/local-storage.service';\nimport {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';\nimport {TopicViewerBackendApiService} from 'domain/topic_viewer/topic-viewer-backend-api.service';\nimport {ReadOnlyTopic} from 'domain/topic_viewer/read-only-topic-object.factory';\nimport {ReadOnlyStoryNode} from 'domain/story_viewer/read-only-story-node.model';\nimport {AssetsBackendApiService} from 'services/assets-backend-api.service';\nimport {AppConstants} from 'app.constants';\nimport {SiteAnalyticsService} from 'services/site-analytics.service';\n\ninterface ResultActionButton {\n  type: string;\n  i18nId: string;\n  url?: string;\n}\n\nexport interface QuestionPlayerConfig {\n  resultActionButtons: ResultActionButton[];\n  skillList: string[];\n  skillDescriptions: string[];\n  questionCount: number;\n  questionPlayerMode?: {\n    modeType: string;\n    passCutoff: number;\n  };\n  questionsSortedByDifficulty: boolean;\n}\n\n@Component({\n  selector: 'oppia-ratings-and-recommendations',\n  templateUrl: './ratings-and-recommendations.component.html',\n})\nexport class RatingsAndRecommendationsComponent {\n  // These properties are initialized using Angular lifecycle hooks\n  // and we need to do non-null assertion. For more information, see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  @Input() userIsLoggedIn!: boolean;\n  @Input() explorationIsInPreviewMode!: boolean;\n  @Input() questionPlayerConfig!: QuestionPlayerConfig;\n  @Input() collectionSummary!: CollectionSummary;\n  @Input() isRefresherExploration!: boolean;\n  @Input() recommendedExplorationSummaries!: LearnerExplorationSummary[];\n  @Input() parentExplorationIds!: string[];\n  // The below property will be undefined when the current chapter\n  // is the last chapter of a story.\n  @Input() nextLessonLink!: string | undefined;\n  inStoryMode!: boolean;\n  // The below properties will be undefined if the exploration is not being\n  // played in story mode, i.e. inStoryMode is false.\n  storyViewerUrl!: string | undefined;\n  nextStoryNodeIconUrl!: string | undefined;\n  storyId!: string | undefined;\n  collectionId!: string | null;\n  userRating!: number;\n  nextStoryNode: ReadOnlyStoryNode | null = null;\n  practiceQuestionsAreEnabled: boolean = false;\n  directiveSubscriptions = new Subscription();\n  @ViewChild('feedbackPopOver') feedbackPopOver!: NgbPopover;\n\n  constructor(\n    private alertsService: AlertsService,\n    private learnerViewRatingService: LearnerViewRatingService,\n    private urlService: UrlService,\n    private userService: UserService,\n    private windowRef: WindowRef,\n    private explorationPlayerStateService: ExplorationPlayerStateService,\n    private urlInterpolationService: UrlInterpolationService,\n    private platformFeatureService: PlatformFeatureService,\n    private localStorageService: LocalStorageService,\n    private storyViewerBackendApiService: StoryViewerBackendApiService,\n    private topicViewerBackendApiService: TopicViewerBackendApiService,\n    private assetsBackendApiService: AssetsBackendApiService,\n    private siteAnalyticsService: SiteAnalyticsService\n  ) {}\n\n  ngOnInit(): void {\n    this.inStoryMode =\n      this.explorationPlayerStateService.isInStoryChapterMode();\n    if (this.inStoryMode) {\n      let topicUrlFragment = this.urlService.getUrlParams().topic_url_fragment;\n      let storyUrlFragment = this.urlService.getUrlParams().story_url_fragment;\n      let classroomUrlFragment =\n        this.urlService.getUrlParams().classroom_url_fragment;\n      let nodeId = this.urlService.getUrlParams().node_id;\n      this.storyViewerBackendApiService\n        .fetchStoryDataAsync(\n          topicUrlFragment,\n          classroomUrlFragment,\n          storyUrlFragment\n        )\n        .then(storyData => {\n          this.storyId = storyData.id;\n          for (let i = 0; i < storyData.nodes.length; i++) {\n            if (\n              storyData.nodes[i].id === nodeId &&\n              i + 1 < storyData.nodes.length\n            ) {\n              this.nextStoryNode = storyData.nodes[i + 1];\n              this.nextStoryNodeIconUrl = this.getIconUrl(\n                this.storyId,\n                this.nextStoryNode.thumbnailFilename\n              );\n              break;\n            }\n          }\n        });\n      this.storyViewerUrl = this.urlInterpolationService.interpolateUrl(\n        TopicViewerDomainConstants.STORY_VIEWER_URL_TEMPLATE,\n        {\n          topic_url_fragment: topicUrlFragment,\n          classroom_url_fragment: classroomUrlFragment,\n          story_url_fragment: storyUrlFragment,\n        }\n      );\n\n      this.topicViewerBackendApiService\n        .fetchTopicDataAsync(topicUrlFragment, classroomUrlFragment)\n        .then((topicData: ReadOnlyTopic) => {\n          this.practiceQuestionsAreEnabled =\n            topicData.getPracticeTabIsDisplayed();\n        });\n    }\n    this.collectionId = this.urlService.getCollectionIdFromExplorationUrl();\n\n    this.directiveSubscriptions.add(\n      this.learnerViewRatingService.onRatingUpdated.subscribe(() => {\n        this.userRating = this.learnerViewRatingService.getUserRating();\n        this.alertsService.addSuccessMessage('Rating saved!');\n      })\n    );\n\n    if (!this.questionPlayerConfig) {\n      this.learnerViewRatingService.init(userRating => {\n        this.userRating = userRating;\n      });\n    }\n  }\n\n  getIconUrl(storyId: string, thumbnailFilename: string): string {\n    return this.assetsBackendApiService.getThumbnailUrlForPreview(\n      AppConstants.ENTITY_TYPE.STORY,\n      storyId,\n      thumbnailFilename\n    );\n  }\n\n  togglePopover(): void {\n    this.feedbackPopOver.toggle();\n  }\n\n  closePopover(): void {\n    this.feedbackPopOver.close();\n  }\n\n  submitUserRating(ratingValue: number): void {\n    this.learnerViewRatingService.submitUserRating(ratingValue);\n  }\n\n  signIn(srcElement: string): void {\n    this.siteAnalyticsService.registerNewSignupEvent(srcElement);\n    this.userService.getLoginUrlAsync().then(loginUrl => {\n      if (loginUrl) {\n        (\n          this.windowRef.nativeWindow as {location: string | Location}\n        ).location = loginUrl;\n      } else {\n        this.windowRef.nativeWindow.location.reload();\n      }\n    });\n  }\n\n  hideSignUpSection(): void {\n    this.localStorageService.updateEndChapterSignUpSectionHiddenPreference(\n      'true'\n    );\n  }\n\n  isSignUpSectionHidden(): boolean {\n    return (\n      this.localStorageService.getEndChapterSignUpSectionHiddenPreference() ===\n      'true'\n    );\n  }\n}\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/tutor-card.component.html",
      "content": "<oppia-end-chapter-confetti #confetti\n                            class=\"end-chapter-confetti\">\n</oppia-end-chapter-confetti>\n<oppia-audio-bar *ngIf=\"showAudioBar()\"></oppia-audio-bar>\n<div class=\"oppia-learner-view-card\" [@fadeInOut]=\"this.displayedCard\"\n     [ngStyle]=\"{'margin-top': isAudioBarExpandedOnMobileDevice() ? '60px' : '30px'}\">\n  <oppia-end-chapter-check-mark #checkMark\n                                [ngClass]=\"{'check-mark-hidden': checkMarkHidden, 'check-mark-skipped': checkMarkSkipped}\"\n                                class=\"end-chapter-check-mark\">\n  </oppia-end-chapter-check-mark>\n  <div class=\"oppia-learner-view-card-content\"\n       [ngClass]=\"{'learner-view-card-transition-class': isOnTerminalCard(), 'card-content-hidden': !checkMarkHidden}\">\n    <div class=\"oppia-learner-view-card-top-section\">\n      <oppia-content-language-selector></oppia-content-language-selector>\n      <img class=\"conversation-skin-oppia-avatar\"\n           [src]=\"OPPIA_AVATAR_IMAGE_URL\"\n           alt=\"\"\n           *ngIf=\"avatarImageIsShown\">\n      <div class=\"oppia-rte-viewer oppia-learner-view-card-top-content\"\n           [ngClass]=\"getContentAudioHighlightClass()\">\n        <div tabindex=\"0\">\n          <oppia-rte-output-display [rteString]=\"displayedCard.getContentHtml()\"\n                                    class=\"e2e-test-conversation-content\">\n          </oppia-rte-output-display>\n        </div>\n        <div *ngIf=\"isContentAudioTranslationAvailable()\"\n             class=\"conversation-skin-audio-controls\">\n        </div>\n      </div>\n    </div>\n\n    <div *ngIf=\"inputOutputHistoryIsShown && (displayedCard.getInputResponsePairs().length > 1 && isInteractionInline()) || (displayedCard.getInputResponsePairs().length > 0 && !isInteractionInline())\">\n      <h4 class=\"conversation-skin-responses-dropdown-container\"\n          (click)=\"toggleShowPreviousResponses()\">\n        <span class=\"conversation-skin-responses-dropdown-text\">\n          <span>\n            {{ 'I18N_PLAYER_PREVIOUS_RESPONSES' | translate:{previousResponses: displayedCard.getInputResponsePairs().length - (isInteractionInline() ? 1 : 0)} }}\n          </span>\n          <span class=\"conversation-skin-responses-dropdown-icon\">\n            <i class=\"fas fa-play conversation-skin-responses-dropdown-icon\" [ngClass]=\"{'conversation-skin-responses-dropdown-icon-rotated': arePreviousResponsesShown}\"></i>\n          </span>\n        </span>\n      </h4>\n    </div>\n\n    <div class=\"conversation-skin-tutor-card-middle-section\"\n         *ngIf=\"(arePreviousResponsesShown && !conceptCardIsBeingShown)\" [@expandInOut]>\n      <div *ngFor=\"let responsePair of displayedCard.getInputResponsePairs(); index as index\">\n        <div *ngIf=\"index !== (displayedCard.getInputResponsePairs().length - 1) || !isInteractionInline()\">\n          <oppia-input-response-pair [data]=\"responsePair\"\n                                     [profilePicturePngDataUrl]=\"profilePicturePngDataUrl\"\n                                     [profilePictureWebpDataUrl]=\"profilePictureWebpDataUrl\"\n                                     [oppiaAvatarImageUrl]=\"OPPIA_AVATAR_IMAGE_URL\"\n                                     [inputResponsePairId]=\"getInputResponsePairId($index)\"\n                                     [isLastPair]=\"false\"\n                                     [feedbackIsEnabled]=\"feedbackIsEnabled\">\n          </oppia-input-response-pair>\n        </div>\n      </div>\n    </div>\n\n    <!-- If the interaction is inline, always show the most recent response pair, if there is one. -->\n    <div class=\"conversation-skin-tutor-card-bottom-section\" *ngIf=\"isInteractionInline() && displayedCard.getInputResponsePairs().length > 0\">\n      <oppia-input-response-pair [data]=\"displayedCard.getInputResponsePairs()[displayedCard.getInputResponsePairs().length - 1]\"\n                                 [bottomSection]=\"true\"\n                                 [profilePicturePngDataUrl]=\"profilePicturePngDataUrl\"\n                                 [profilePictureWebpDataUrl]=\"profilePictureWebpDataUrl\"\n                                 [oppiaAvatarImageUrl]=\"OPPIA_AVATAR_IMAGE_URL\"\n                                 [inputResponsePairId]=\"getInputResponsePairId(displayedCard.getInputResponsePairs().length - 1)\"\n                                 [isLastPair]=\"true\"\n                                 [feedbackIsEnabled]=\"feedbackIsEnabled\">\n      </oppia-input-response-pair>\n    </div>\n\n    <!--\n      Show the interaction (if it is inline) or the interaction instructions\n      (if the interaction is supplemental).\n\n      In addition, if the exploration is iframed, the terminal card will\n      have no learner input section, so we do not show it.\n    -->\n    <div *ngIf=\"!displayedCardWasCompletedInPrevSession && isInteractionInline() && !shouldHideInteraction && isCurrentCardAtEndOfTranscript() && !waitingForOppiaFeedback &&\n    ((displayedCard.getInteractionHtml() && !displayedCard.isCompleted()) || displayedCard.isCompleted()) &&\n    (!isOnTerminalCard() || !isIframed || displayedCard.isCompleted())\">\n      <div class=\"conversation-skin-inline-interaction\">\n        <!-- The seemingly redundant check for isInteractionInline() is necessary\n          because the parent ng-show does not remove the element from the DOM.\n          This can lead to two conflicting copies of the interaction for\n          non-inline interactions. -->\n        <div *ngIf=\"isInteractionInline() && displayedCard.getInteractionHtml() && !displayedCard.isCompleted() && !conceptCardIsBeingShown\">\n          <oppia-interaction-display classStr=\"e2e-test-conversation-input\"\n                                     [htmlData]=\"displayedCard.getInteractionHtml()\">\n          </oppia-interaction-display>\n        </div>\n      </div>\n    </div>\n\n    <div *ngIf=\"!isInteractionInline() && !conceptCardIsBeingShown\"\n         class=\"conversation-skin-inline-interaction\">\n      <div class=\"oppia-conversation-skin-instruction-container\">\n        <span [ngClass]=\"{'conversation-skin-instruction-disabled': !interactionIsActive}\">\n          {{ interactionInstructions | translate }}\n        </span>\n        <i *ngIf=\"canWindowShowTwoCards() && !isLanguageRTL()\" [ngClass]=\"{'conversation-skin-instruction-disabled': !interactionIsActive}\" class=\"fas fa-arrow-right position-relative\"></i>\n        <i *ngIf=\"canWindowShowTwoCards() && isLanguageRTL()\" [ngClass]=\"{'conversation-skin-instruction-disabled': !interactionIsActive}\" class=\"fas fa-arrow-left position-relative\"></i>\n        <i *ngIf=\"!canWindowShowTwoCards()\" [ngClass]=\"{'conversation-skin-instruction-disabled': !interactionIsActive}\" class=\"fas fa-arrow-down position-relative\"></i>\n      </div>\n\n      <div *ngIf=\"!displayedCard.getInteractionId() && !isOnTerminalCard() && !conceptCardIsBeingShown\">\n        <div class=\"conversation-skin-inline-interaction\">\n          <span class=\"oppia-no-interaction-text\">\n            <strong>Error</strong>: No interaction specified for '{{ displayedCard.getStateName() }}'.\n          </span>\n        </div>\n      </div>\n    </div>\n    <div *ngIf=\"isOnTerminalCard() && milestoneMessageIsToBeDisplayed && generateMilestoneMessage() && !setNextMilestoneAndCheckIfProgressBarIsShown()\">\n      <div class=\"conversation-skin-milestone-message\">\n        <div class=\"milestone-message-star-container\">\n          <img [src]=\"getStaticImageUrl('/general/milestone-message-star-icon.svg')\" class=\"star-icon\">\n          <p class=\"completed-chapter-count\">{{ completedChaptersCount }}</p>\n        </div>\n        <span class=\"milestone-message-text\">{{ generateMilestoneMessage() }}</span>\n      </div>\n    </div>\n    <div *ngIf=\"isOnTerminalCard() && setNextMilestoneAndCheckIfProgressBarIsShown()\">\n      <div class=\"conversation-skin-milestone-message milestone-progress-message\">\n        <div class=\"milestone-message-progress-bar-container\">\n          <div class=\"milestone-progress-bar-outer\">\n            <div class=\"milestone-progress-bar-inner\"\n                 [style.width.%]=\"(completedChaptersCount / nextMilestoneChapterCount) * 100\">\n            </div>\n          </div>\n          <div class=\"milestone-message-star-container\">\n            <img [src]=\"getStaticImageUrl('/general/milestone-message-star-icon.svg')\"\n                 class=\"star-icon\">\n            <p class=\"chapters-left-count\">{{ nextMilestoneChapterCount }}</p>\n          </div>\n        </div>\n        <span class=\"milestone-message-text\">\n          {{ 'I18N_END_CHAPTER_MILESTONE_PROGRESS_MESSAGE' | translate:{chaptersToGo: nextMilestoneChapterCount - completedChaptersCount, messageFormat: true} }}\n        </span>\n      </div>\n    </div>\n\n    <oppia-ratings-and-recommendations *ngIf=\"!isIframed && isOnTerminalCard() && isCurrentCardAtEndOfTranscript()\"\n                                       [userIsLoggedIn]=\"userIsLoggedIn\"\n                                       [explorationIsInPreviewMode]=\"explorationIsInPreviewMode\"\n                                       [questionPlayerConfig]=\"questionPlayerConfig\"\n                                       [collectionSummary]=\"collectionSummary\"\n                                       [isRefresherExploration]=\"isRefresherExploration\"\n                                       [recommendedExplorationSummaries]=\"recommendedExplorationSummaries\"\n                                       [parentExplorationIds]=\"parentExplorationIds\"\n                                       [nextLessonLink]=\"nextLessonLink\">\n    </oppia-ratings-and-recommendations>\n\n    <div *ngIf=\"displayedCardWasCompletedInPrevSession && !conceptCardIsBeingShown && (displayedCard.getInteractionId() != 'Continue')\">\n      <div class=\"conversation-skin-oppia-feedback-container conversation-skin-oppia-completed-state-card\">\n        <img class=\"conversation-skin-oppia-avatar rounded-circle\"\n             [src]=\"OPPIA_AVATAR_IMAGE_URL\"\n             alt=\"\">\n        <div class=\"conversation-skin-oppia-feedback-content\">\n          {{ 'I18N_EXPLORATION_STATE_PREVIOUSLY_COMPLETED' | translate }}\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n<oppia-checkpoint-celebration-modal class=\"checkpoint-celebration-modal-container\" *ngIf=\"checkpointCelebrationModalIsEnabled\">\n</oppia-checkpoint-celebration-modal>\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/tutor-card.component.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for the Tutor Card Component.\n */\n\nimport {SimpleChanges} from '@angular/core';\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\nimport {NO_ERRORS_SCHEMA, EventEmitter} from '@angular/core';\nimport {\n  ComponentFixture,\n  fakeAsync,\n  TestBed,\n  tick,\n  waitForAsync,\n  flush,\n} from '@angular/core/testing';\nimport {TranslateService} from '@ngx-translate/core';\nimport {AppConstants} from 'app.constants';\nimport {Interaction} from 'domain/exploration/InteractionObjectFactory';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport {AudioBarStatusService} from 'services/audio-bar-status.service';\nimport {AudioPlayerService} from 'services/audio-player.service';\nimport {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';\nimport {ContextService} from 'services/context.service';\nimport {DeviceInfoService} from 'services/contextual/device-info.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {UserService} from 'services/user.service';\nimport {MockTranslatePipe} from 'tests/unit-test-utils';\nimport {ExplorationPlayerConstants} from '../exploration-player-page.constants';\nimport {AudioPreloaderService} from '../services/audio-preloader.service';\nimport {AudioTranslationManagerService} from '../services/audio-translation-manager.service';\nimport {CurrentInteractionService} from '../services/current-interaction.service';\nimport {ExplorationPlayerStateService} from '../services/exploration-player-state.service';\nimport {LearnerAnswerInfoService} from '../services/learner-answer-info.service';\nimport {PlayerPositionService} from '../services/player-position.service';\nimport {TutorCardComponent} from './tutor-card.component';\nimport {I18nLanguageCodeService} from 'services/i18n-language-code.service';\nimport {EndChapterCheckMarkComponent} from './end-chapter-check-mark.component';\nimport {EndChapterConfettiComponent} from './end-chapter-confetti.component';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\nimport {InteractionCustomizationArgs} from 'interactions/customization-args-defs';\nimport {UserInfo} from 'domain/user/user-info.model';\nimport {VoiceoverPlayerService} from '../services/voiceover-player.service';\n\nclass MockWindowRef {\n  nativeWindow = {\n    location: {\n      hash: '',\n      pathname: '/path/name',\n    },\n    matchMedia: function (query: string) {\n      return {\n        matches: false,\n      };\n    },\n  };\n}\n\nclass MockPlatformFeatureService {\n  get status(): object {\n    return {\n      EnableVoiceoverContribution: {\n        isEnabled: false,\n      },\n      AddVoiceoverWithAccent: {\n        isEnabled: false,\n      },\n    };\n  }\n}\n\nclass MockTranslateService {\n  onLangChange: EventEmitter<string> = new EventEmitter();\n  instant(key: string, interpolateParams?: Object): string {\n    return key;\n  }\n}\n\ndescribe('Tutor card component', () => {\n  let fixture: ComponentFixture<TutorCardComponent>;\n  let componentInstance: TutorCardComponent;\n\n  let audioBarStatusService: AudioBarStatusService;\n  let audioPlayerService: AudioPlayerService;\n  let audioPreloaderService: AudioPreloaderService;\n  let audioTranslationManagerService: AudioTranslationManagerService;\n  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;\n  let contextService: ContextService;\n  let currentInteractionService: CurrentInteractionService;\n  let deviceInfoService: DeviceInfoService;\n  let explorationPlayerStateService: ExplorationPlayerStateService;\n  let i18nLanguageCodeService: I18nLanguageCodeService;\n  let playerPositionService: PlayerPositionService;\n  let urlInterpolationService: UrlInterpolationService;\n  let urlService: UrlService;\n  let userService: UserService;\n  let windowDimensionsService: WindowDimensionsService;\n  let windowRef: WindowRef;\n  let translateService: TranslateService;\n  let voiceoverPlayerService: VoiceoverPlayerService;\n\n  let mockDisplayedCard = new StateCard(\n    '',\n    '',\n    '',\n    new Interaction(\n      [],\n      [],\n      {} as InteractionCustomizationArgs,\n      null,\n      [],\n      'EndExploration',\n      // This throws \"Argument of type 'null' is not assignable to parameter of\n      // type 'RecordedVoiceovers'.\" We need to suppress this error because of\n      // the need to test validations. This throws an error only in the\n      // frontend tests and not in the frontend.\n      // @ts-ignore\n      null\n    ),\n    [],\n    // This throws \"Argument of type 'null' is not assignable to parameter of\n    // type 'RecordedVoiceovers'.\" We need to suppress this error because of\n    // the need to test validations. This throws an error only in the\n    // frontend tests and not in the frontend.\n    // @ts-ignore\n    null,\n    '',\n    null\n  );\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [TutorCardComponent, MockTranslatePipe],\n      providers: [\n        AudioBarStatusService,\n        AudioPlayerService,\n        AudioPreloaderService,\n        AudioTranslationManagerService,\n        AutogeneratedAudioPlayerService,\n        ContextService,\n        CurrentInteractionService,\n        DeviceInfoService,\n        ExplorationPlayerStateService,\n        LearnerAnswerInfoService,\n        PlayerPositionService,\n        UrlInterpolationService,\n        UrlService,\n        UserService,\n        WindowDimensionsService,\n        {\n          provide: WindowRef,\n          useClass: MockWindowRef,\n        },\n        {\n          provide: PlatformFeatureService,\n          useClass: MockPlatformFeatureService,\n        },\n        {\n          provide: TranslateService,\n          useClass: MockTranslateService,\n        },\n      ],\n      schemas: [NO_ERRORS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(TutorCardComponent);\n    componentInstance = fixture.componentInstance;\n    audioBarStatusService = TestBed.inject(AudioBarStatusService);\n    audioPlayerService = TestBed.inject(AudioPlayerService);\n    audioPreloaderService = TestBed.inject(AudioPreloaderService);\n    audioTranslationManagerService = TestBed.inject(\n      AudioTranslationManagerService\n    );\n    autogeneratedAudioPlayerService = TestBed.inject(\n      AutogeneratedAudioPlayerService\n    );\n    contextService = TestBed.inject(ContextService);\n    currentInteractionService = TestBed.inject(CurrentInteractionService);\n    deviceInfoService = TestBed.inject(DeviceInfoService);\n    explorationPlayerStateService = TestBed.inject(\n      ExplorationPlayerStateService\n    );\n    playerPositionService = TestBed.inject(PlayerPositionService);\n    urlInterpolationService = TestBed.inject(UrlInterpolationService);\n    urlService = TestBed.inject(UrlService);\n    userService = TestBed.inject(UserService);\n    windowDimensionsService = TestBed.inject(WindowDimensionsService);\n    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);\n    windowRef = TestBed.inject(WindowRef);\n    voiceoverPlayerService = TestBed.inject(VoiceoverPlayerService);\n    translateService = TestBed.inject(TranslateService);\n\n    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL').and.returnValue(\n      true\n    );\n    spyOn(userService, 'getProfileImageDataUrl').and.returnValue([\n      'default-image-url-png',\n      'default-image-url-webp',\n    ]);\n  });\n\n  afterEach(() => {\n    componentInstance.ngOnDestroy();\n  });\n\n  it('should initialize', fakeAsync(() => {\n    const sampleUserInfoBackendObject = {\n      roles: ['USER_ROLE'],\n      is_moderator: false,\n      is_curriculum_admin: false,\n      is_super_admin: false,\n      is_topic_manager: false,\n      can_create_collections: true,\n      preferred_site_language_code: null,\n      username: 'tester',\n      email: 'test@test.com',\n      user_is_logged_in: true,\n    };\n    const sampleUserInfo = UserInfo.createFromBackendDict(\n      sampleUserInfoBackendObject\n    );\n    let mockOnActiveCardChangedEventEmitter = new EventEmitter<void>();\n    let mockOnOppiaFeedbackAvailableEventEmitter = new EventEmitter<void>();\n    let isIframed = false;\n\n    spyOn(contextService, 'isInExplorationEditorPage').and.returnValues(\n      true,\n      false\n    );\n    spyOn(urlService, 'isIframed').and.returnValue(isIframed);\n    spyOn(deviceInfoService, 'isMobileDevice').and.returnValue(true);\n    spyOn(audioBarStatusService, 'isAudioBarExpanded').and.returnValue(true);\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValues(\n      'avatar_url',\n      'profile_url',\n      'default image path'\n    );\n    spyOn(componentInstance, 'updateDisplayedCard');\n    spyOnProperty(playerPositionService, 'onActiveCardChanged').and.returnValue(\n      mockOnActiveCardChangedEventEmitter\n    );\n    spyOnProperty(\n      explorationPlayerStateService,\n      'onOppiaFeedbackAvailable'\n    ).and.returnValue(mockOnOppiaFeedbackAvailableEventEmitter);\n    spyOn(componentInstance, 'getInputResponsePairId').and.returnValue('hash');\n    componentInstance.displayedCard = mockDisplayedCard;\n    spyOn(userService, 'getUserInfoAsync').and.returnValue(\n      Promise.resolve(sampleUserInfo)\n    );\n\n    componentInstance.ngOnInit();\n    componentInstance.isAudioBarExpandedOnMobileDevice();\n    mockOnOppiaFeedbackAvailableEventEmitter.emit();\n    mockOnActiveCardChangedEventEmitter.emit();\n    tick();\n    tick();\n\n    componentInstance.ngOnInit();\n    tick();\n    tick();\n    expect(componentInstance.profilePicturePngDataUrl).toEqual(\n      'default-image-url-png'\n    );\n    expect(componentInstance.profilePictureWebpDataUrl).toEqual(\n      'default-image-url-webp'\n    );\n\n    expect(componentInstance.isIframed).toEqual(isIframed);\n    expect(contextService.isInExplorationEditorPage).toHaveBeenCalled();\n    expect(urlService.isIframed).toHaveBeenCalled();\n    expect(deviceInfoService.isMobileDevice).toHaveBeenCalled();\n    expect(audioBarStatusService.isAudioBarExpanded).toHaveBeenCalled();\n    expect(urlInterpolationService.getStaticImageUrl).toHaveBeenCalled();\n    expect(componentInstance.getInputResponsePairId).toHaveBeenCalled();\n  }));\n\n  it('should set default profile pictures when username is null', fakeAsync(() => {\n    spyOn(componentInstance, 'updateDisplayedCard');\n    let userInfo = {\n      isLoggedIn: () => true,\n      getUsername: () => null,\n    };\n\n    spyOn(userService, 'getUserInfoAsync').and.resolveTo(userInfo as UserInfo);\n\n    componentInstance.ngOnInit();\n    tick();\n\n    expect(componentInstance.profilePicturePngDataUrl).toBe(\n      urlInterpolationService.getStaticImageUrl(\n        AppConstants.DEFAULT_PROFILE_IMAGE_PNG_PATH\n      )\n    );\n    expect(componentInstance.profilePictureWebpDataUrl).toBe(\n      urlInterpolationService.getStaticImageUrl(\n        AppConstants.DEFAULT_PROFILE_IMAGE_WEBP_PATH\n      )\n    );\n  }));\n\n  it('should refresh displayed card on changes', fakeAsync(() => {\n    let updateDisplayedCardSpy = spyOn(\n      componentInstance,\n      'updateDisplayedCard'\n    );\n    spyOn(componentInstance, 'isOnTerminalCard');\n    const changes: SimpleChanges = {\n      displayedCard: {\n        previousValue: false,\n        currentValue: true,\n        firstChange: false,\n        isFirstChange: () => false,\n      },\n    };\n    componentInstance.ngOnChanges(changes);\n    expect(updateDisplayedCardSpy).toHaveBeenCalled();\n    expect(componentInstance.isOnTerminalCard).toHaveBeenCalled();\n  }));\n\n  it('should trigger celebratory animation if on the last card of a chapter', fakeAsync(() => {\n    spyOn(componentInstance, 'updateDisplayedCard');\n    spyOn(componentInstance, 'isOnTerminalCard').and.returnValue(true);\n    spyOn(componentInstance, 'triggerCelebratoryAnimation');\n    componentInstance.animationHasPlayedOnce = false;\n    componentInstance.inStoryMode = true;\n    const changes: SimpleChanges = {\n      displayedCard: {\n        previousValue: false,\n        currentValue: true,\n        firstChange: false,\n        isFirstChange: () => false,\n      },\n    };\n\n    componentInstance.ngOnChanges(changes);\n\n    expect(componentInstance.updateDisplayedCard).toHaveBeenCalled();\n    expect(componentInstance.triggerCelebratoryAnimation).toHaveBeenCalled();\n  }));\n\n  it('should not trigger celebratory animation if not in story mode', fakeAsync(() => {\n    spyOn(componentInstance, 'updateDisplayedCard');\n    spyOn(componentInstance, 'isOnTerminalCard').and.returnValue(true);\n    spyOn(componentInstance, 'triggerCelebratoryAnimation');\n    componentInstance.animationHasPlayedOnce = false;\n    componentInstance.inStoryMode = false;\n    const changes: SimpleChanges = {\n      displayedCard: {\n        previousValue: false,\n        currentValue: true,\n        firstChange: false,\n        isFirstChange: () => false,\n      },\n    };\n\n    componentInstance.ngOnChanges(changes);\n\n    expect(componentInstance.updateDisplayedCard).toHaveBeenCalled();\n    expect(\n      componentInstance.triggerCelebratoryAnimation\n    ).not.toHaveBeenCalled();\n  }));\n\n  it(\n    'should animate the check mark and the confetti ' +\n      'if animations are enabled',\n    fakeAsync(() => {\n      expect(componentInstance.checkMarkHidden).toBe(true);\n      expect(componentInstance.animationHasPlayedOnce).toBe(false);\n      expect(componentInstance.checkMarkSkipped).toBe(false);\n\n      spyOn(windowRef.nativeWindow, 'matchMedia').and.callThrough();\n      componentInstance.checkMarkComponent =\n        jasmine.createSpyObj<EndChapterCheckMarkComponent>(\n          'EndChapterCheckMarkComponent',\n          ['animateCheckMark']\n        );\n      componentInstance.confettiComponent =\n        jasmine.createSpyObj<EndChapterConfettiComponent>(\n          'EndChapterConfettiComponent',\n          ['animateConfetti']\n        );\n\n      componentInstance.triggerCelebratoryAnimation();\n\n      tick(1);\n      expect(\n        componentInstance.checkMarkComponent.animateCheckMark\n      ).toHaveBeenCalled();\n      expect(componentInstance.animationHasPlayedOnce).toBe(true);\n\n      tick(2000);\n      expect(\n        componentInstance.confettiComponent.animateConfetti\n      ).toHaveBeenCalled();\n\n      tick(4000);\n      expect(componentInstance.checkMarkHidden).toBe(true);\n    })\n  );\n\n  it(\n    'should not animate the confetti if animations ' + 'are not enabled',\n    fakeAsync(() => {\n      expect(componentInstance.checkMarkHidden).toBe(true);\n      expect(componentInstance.animationHasPlayedOnce).toBe(false);\n      expect(componentInstance.checkMarkSkipped).toBe(false);\n\n      spyOn(windowRef.nativeWindow, 'matchMedia').and.returnValue({\n        matches: true,\n        media: 'prefers-reduced-motion',\n        addListener: () => {},\n        removeListener: () => {},\n        addEventListener: () => {},\n        removeEventListener: () => {},\n        onchange: () => {},\n        dispatchEvent: (ev: Event) => true,\n      });\n      componentInstance.checkMarkComponent =\n        jasmine.createSpyObj<EndChapterCheckMarkComponent>(\n          'EndChapterCheckMarkComponent',\n          ['animateCheckMark']\n        );\n      componentInstance.confettiComponent =\n        jasmine.createSpyObj<EndChapterConfettiComponent>(\n          'EndChapterConfettiComponent',\n          ['animateConfetti']\n        );\n\n      componentInstance.triggerCelebratoryAnimation();\n\n      tick(1);\n      expect(\n        componentInstance.checkMarkComponent.animateCheckMark\n      ).toHaveBeenCalled();\n      expect(componentInstance.animationHasPlayedOnce).toBe(true);\n\n      tick(2000);\n      expect(\n        componentInstance.confettiComponent.animateConfetti\n      ).not.toHaveBeenCalled();\n\n      tick(500);\n      expect(componentInstance.checkMarkHidden).toBe(true);\n    })\n  );\n\n  it('should skip animation when a click is made onscreen', fakeAsync(() => {\n    expect(componentInstance.checkMarkSkipped).toBe(false);\n\n    spyOn(window, 'clearTimeout');\n    componentInstance.checkMarkComponent =\n      jasmine.createSpyObj<EndChapterCheckMarkComponent>(\n        'EndChapterCheckMarkComponent',\n        ['animateCheckMark']\n      );\n    componentInstance.confettiComponent =\n      jasmine.createSpyObj<EndChapterConfettiComponent>(\n        'EndChapterConfettiComponent',\n        ['animateConfetti']\n      );\n    componentInstance.triggerCelebratoryAnimation();\n    let fakeClickEvent = new MouseEvent('click');\n    document.dispatchEvent(fakeClickEvent);\n\n    tick(1);\n    expect(clearTimeout).toHaveBeenCalled();\n    expect(componentInstance.checkMarkSkipped).toBe(true);\n    tick(500);\n    expect(componentInstance.checkMarkHidden).toBe(true);\n\n    flush();\n  }));\n\n  it(\"should not skip animation if it hasn't been triggered yet\", fakeAsync(() => {\n    let fakeClickEvent = new MouseEvent('click');\n    document.dispatchEvent(fakeClickEvent);\n\n    expect(componentInstance.checkMarkSkipped).toBe(false);\n  }));\n\n  it('should correctly generate the milestone message', () => {\n    componentInstance.inStoryMode = true;\n    componentInstance.milestoneMessageIsToBeDisplayed = true;\n    componentInstance.completedChaptersCount = 1;\n    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();\n    spyOn(translateService, 'instant').and.callThrough();\n\n    expect(componentInstance.generateMilestoneMessage()).toBe(\n      'I18N_END_CHAPTER_MILESTONE_MESSAGE_1'\n    );\n    expect(translateService.instant).toHaveBeenCalledWith(\n      'I18N_END_CHAPTER_MILESTONE_MESSAGE_1'\n    );\n\n    componentInstance.completedChaptersCount = 5;\n\n    expect(componentInstance.generateMilestoneMessage()).toBe(\n      'I18N_END_CHAPTER_MILESTONE_MESSAGE_2'\n    );\n    expect(translateService.instant).toHaveBeenCalledWith(\n      'I18N_END_CHAPTER_MILESTONE_MESSAGE_2'\n    );\n  });\n\n  it('should generate an empty message if the milestone is not to be displayed', () => {\n    componentInstance.inStoryMode = true;\n    componentInstance.completedChaptersCount = 1;\n    componentInstance.milestoneMessageIsToBeDisplayed = false;\n    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();\n    spyOn(translateService, 'instant').and.callThrough();\n\n    expect(componentInstance.generateMilestoneMessage()).toBe('');\n    expect(translateService.instant).not.toHaveBeenCalled();\n  });\n\n  it('should generate an empty message if not in story mode', () => {\n    componentInstance.inStoryMode = false;\n    componentInstance.milestoneMessageIsToBeDisplayed = true;\n    componentInstance.completedChaptersCount = 1;\n    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();\n    spyOn(translateService, 'instant').and.callThrough();\n\n    expect(componentInstance.generateMilestoneMessage()).toBe('');\n    expect(translateService.instant).not.toHaveBeenCalled();\n  });\n\n  it(\n    'should generate an empty message if completed chapters count ' +\n      'is not eligible for a milestone',\n    () => {\n      componentInstance.inStoryMode = true;\n      componentInstance.milestoneMessageIsToBeDisplayed = true;\n      componentInstance.completedChaptersCount = 2;\n      spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();\n      spyOn(translateService, 'instant').and.callThrough();\n\n      expect(componentInstance.generateMilestoneMessage()).toBe('');\n      expect(translateService.instant).not.toHaveBeenCalled();\n    }\n  );\n\n  it('should correctly show milestone progress bar', () => {\n    componentInstance.inStoryMode = true;\n    componentInstance.milestoneMessageIsToBeDisplayed = false;\n    componentInstance.completedChaptersCount = 2;\n    spyOn(\n      componentInstance,\n      'setNextMilestoneAndCheckIfProgressBarIsShown'\n    ).and.callThrough();\n\n    expect(\n      componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n    ).toBe(true);\n    expect(componentInstance.nextMilestoneChapterCount).toBe(5);\n\n    componentInstance.completedChaptersCount = 4;\n\n    expect(\n      componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n    ).toBe(true);\n    expect(componentInstance.nextMilestoneChapterCount).toBe(5);\n\n    spyOn(\n      componentInstance,\n      'isCompletedChaptersCountGreaterThanLastMilestone'\n    ).and.returnValue(false);\n    spyOn(\n      componentInstance,\n      'isMilestoneReachedAndMilestoneMessageToBeDisplayed'\n    ).and.returnValue(false);\n    componentInstance.completedChaptersCount = 55;\n    componentInstance.milestoneMessageIsToBeDisplayed = true;\n\n    expect(\n      componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n    ).toBe(false);\n  });\n\n  it(\n    'should not show milestone progress bar if completed chapters count ' +\n      'is greater than 50',\n    () => {\n      componentInstance.inStoryMode = true;\n      componentInstance.milestoneMessageIsToBeDisplayed = false;\n      componentInstance.completedChaptersCount = 51;\n      spyOn(\n        componentInstance,\n        'setNextMilestoneAndCheckIfProgressBarIsShown'\n      ).and.callThrough();\n\n      expect(\n        componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n      ).toBe(false);\n      expect(componentInstance.nextMilestoneChapterCount).toBeNull();\n    }\n  );\n\n  it('should not show milestone progress bar if not in story mode', () => {\n    componentInstance.inStoryMode = false;\n    componentInstance.milestoneMessageIsToBeDisplayed = false;\n    componentInstance.completedChaptersCount = 1;\n    spyOn(\n      componentInstance,\n      'setNextMilestoneAndCheckIfProgressBarIsShown'\n    ).and.callThrough();\n\n    expect(\n      componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n    ).toBe(false);\n    expect(componentInstance.nextMilestoneChapterCount).toBeNull();\n  });\n\n  it(\n    'should not show milestone progress bar if milestone message is to be ' +\n      'displayed, and completed chapters count is a milestone',\n    () => {\n      componentInstance.inStoryMode = true;\n      componentInstance.milestoneMessageIsToBeDisplayed = true;\n      componentInstance.completedChaptersCount = 1;\n      spyOn(\n        componentInstance,\n        'setNextMilestoneAndCheckIfProgressBarIsShown'\n      ).and.callThrough();\n\n      expect(\n        componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n      ).toBe(false);\n      expect(componentInstance.nextMilestoneChapterCount).toBeNull();\n    }\n  );\n\n  it(\n    'should show milestone progress bar even if the completed chapters count' +\n      ' is a milestone, if the milestone message is not to be displayed',\n    () => {\n      componentInstance.inStoryMode = true;\n      componentInstance.milestoneMessageIsToBeDisplayed = false;\n      componentInstance.completedChaptersCount = 10;\n      spyOn(\n        componentInstance,\n        'setNextMilestoneAndCheckIfProgressBarIsShown'\n      ).and.callThrough();\n\n      expect(\n        componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown()\n      ).toBe(true);\n      expect(componentInstance.nextMilestoneChapterCount).toBe(25);\n    }\n  );\n\n  it(\n    'should correctly determine if new milestone is reached and message is ' +\n      'to be displayed',\n    () => {\n      componentInstance.milestoneMessageIsToBeDisplayed = true;\n      componentInstance.completedChaptersCount = 1;\n\n      expect(\n        componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed()\n      ).toBe(true);\n\n      componentInstance.completedChaptersCount = 2;\n\n      expect(\n        componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed()\n      ).toBe(false);\n\n      componentInstance.milestoneMessageIsToBeDisplayed = false;\n      componentInstance.completedChaptersCount = 1;\n\n      expect(\n        componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed()\n      ).toBe(false);\n    }\n  );\n\n  it(\n    'should correctly determine if completed chapters count is greater than ' +\n      'last milestone',\n    () => {\n      componentInstance.completedChaptersCount = 1;\n\n      expect(\n        componentInstance.isCompletedChaptersCountGreaterThanLastMilestone()\n      ).toBe(false);\n\n      componentInstance.completedChaptersCount = 51;\n\n      expect(\n        componentInstance.isCompletedChaptersCountGreaterThanLastMilestone()\n      ).toBe(true);\n    }\n  );\n\n  it('should update displayed card', fakeAsync(() => {\n    mockDisplayedCard.markAsCompleted();\n    componentInstance.displayedCard = mockDisplayedCard;\n    let mockOnNewCardAvailableEventEmitter = new EventEmitter<void>();\n\n    spyOnProperty(playerPositionService, 'onNewCardAvailable').and.returnValue(\n      mockOnNewCardAvailableEventEmitter\n    );\n    spyOn(currentInteractionService, 'registerPresubmitHook').and.callFake(\n      callb => callb()\n    );\n    spyOn(audioTranslationManagerService, 'clearSecondaryAudioTranslations');\n    spyOn(audioTranslationManagerService, 'setContentAudioTranslations');\n    spyOn(audioPlayerService, 'clear');\n    spyOn(audioPreloaderService, 'clearMostRecentlyRequestedAudioFilename');\n    spyOn(autogeneratedAudioPlayerService, 'cancel');\n\n    componentInstance.updateDisplayedCard();\n    mockOnNewCardAvailableEventEmitter.emit();\n    tick();\n\n    expect(\n      audioTranslationManagerService.clearSecondaryAudioTranslations\n    ).toHaveBeenCalled();\n    expect(\n      audioTranslationManagerService.setContentAudioTranslations\n    ).toHaveBeenCalled();\n    expect(audioPlayerService.clear).toHaveBeenCalled();\n    expect(\n      audioPreloaderService.clearMostRecentlyRequestedAudioFilename\n    ).toHaveBeenCalled();\n    expect(autogeneratedAudioPlayerService.cancel).toHaveBeenCalled();\n  }));\n\n  it('should get the static image url from the image path', () => {\n    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(\n      '/assets/images/general/milestone-message-star-icon.svg'\n    );\n\n    expect(\n      componentInstance.getStaticImageUrl(\n        '/general/milestone-message-star-icon.svg'\n      )\n    ).toBe('/assets/images/general/milestone-message-star-icon.svg');\n    expect(urlInterpolationService.getStaticImageUrl).toHaveBeenCalledWith(\n      '/general/milestone-message-star-icon.svg'\n    );\n  });\n\n  it('should tell if audio bar is expanded on mobile device', () => {\n    spyOn(deviceInfoService, 'isMobileDevice').and.returnValue(true);\n    spyOn(audioBarStatusService, 'isAudioBarExpanded').and.returnValue(true);\n    expect(componentInstance.isAudioBarExpandedOnMobileDevice()).toBeTrue();\n  });\n\n  it('should update displayed card', fakeAsync(() => {\n    componentInstance.displayedCard = mockDisplayedCard;\n    let mockOnNewCardAvailableEventEmitter = new EventEmitter<void>();\n    spyOnProperty(playerPositionService, 'onNewCardAvailable').and.returnValue(\n      mockOnNewCardAvailableEventEmitter\n    );\n    mockOnNewCardAvailableEventEmitter.emit();\n    spyOn(currentInteractionService, 'registerPresubmitHook').and.callFake(\n      callb => callb()\n    );\n    spyOn(mockDisplayedCard, 'getInteraction').and.returnValue(\n      // This throws \"Type 'null' is not assignable to type\n      // 'InteractionCustomizationArgs'.\" We need to suppress this error\n      // because of the need to test validations. This throws an error\n      // because the value of interaction is null.\n      // @ts-ignore\n      new Interaction([], [], null, null, [], '', null)\n    );\n    spyOn(mockDisplayedCard, 'isCompleted').and.returnValue(true);\n    spyOn(audioTranslationManagerService, 'setContentAudioTranslations');\n    spyOn(audioPlayerService, 'clear');\n    spyOn(audioPreloaderService, 'clearMostRecentlyRequestedAudioFilename');\n    spyOn(autogeneratedAudioPlayerService, 'cancel');\n  }));\n\n  it('should get RTL language status correctly', () => {\n    expect(componentInstance.isLanguageRTL()).toEqual(true);\n  });\n\n  it('should check if interaction is inline', () => {\n    componentInstance.conceptCardIsBeingShown = true;\n    componentInstance.displayedCard = mockDisplayedCard;\n    expect(componentInstance.isInteractionInline()).toBeTrue();\n    componentInstance.conceptCardIsBeingShown = false;\n    spyOn(mockDisplayedCard, 'isInteractionInline').and.returnValue(false);\n    componentInstance.displayedCard = mockDisplayedCard;\n    expect(componentInstance.isInteractionInline()).toBeFalse();\n  });\n\n  it('should get content audio highlight class', () => {\n    spyOn(\n      audioTranslationManagerService,\n      'getCurrentComponentName'\n    ).and.returnValue(AppConstants.COMPONENT_NAME_CONTENT);\n    let audioPlayerServiceSpy = spyOn(audioPlayerService, 'isPlaying');\n    audioPlayerServiceSpy.and.returnValue(false);\n    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(true);\n    expect(componentInstance.getContentAudioHighlightClass()).toEqual(\n      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS\n    );\n\n    spyOn(\n      componentInstance,\n      'isVoiceoverContributionWithAccentEnabled'\n    ).and.returnValue(true);\n    audioPlayerServiceSpy.and.returnValue(true);\n    spyOn(voiceoverPlayerService, 'getActiveComponentName').and.returnValue(\n      AppConstants.COMPONENT_NAME_CONTENT\n    );\n    expect(componentInstance.getContentAudioHighlightClass()).toBe(\n      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS\n    );\n  });\n\n  it('should throw error if background image are empty', fakeAsync(() => {\n    spyOn(audioTranslationManagerService, 'getCurrentComponentName')\n      // This throws \"Argument of type 'null' is not assignable to parameter of\n      // type 'String'.\" We need to suppress this error because of\n      // the need to test validations. This throws an error because the\n      // value of interaction is null.\n      // @ts-ignore\n      .and.returnValue(null);\n    spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);\n    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(false);\n    expect(componentInstance.getContentAudioHighlightClass()).toBeNull();\n  }));\n\n  it('should get content focus label', () => {\n    expect(componentInstance.getContentFocusLabel(1)).toEqual(\n      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + 1\n    );\n  });\n\n  it('should toggle show previous responses', () => {\n    componentInstance.arePreviousResponsesShown = false;\n    componentInstance.toggleShowPreviousResponses();\n    expect(componentInstance.arePreviousResponsesShown).toBeTrue();\n  });\n\n  it('should tell if window is narrow', () => {\n    spyOn(windowDimensionsService, 'isWindowNarrow').and.returnValue(true);\n    expect(componentInstance.isWindowNarrow()).toBeTrue();\n  });\n\n  it('should show two cards', () => {\n    spyOn(windowDimensionsService, 'getWidth').and.returnValue(300);\n    expect(componentInstance.canWindowShowTwoCards()).toBeFalse();\n  });\n\n  it('should tell if audio bar can be shown', () => {\n    componentInstance.isIframed = false;\n    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValue(\n      false\n    );\n    expect(componentInstance.showAudioBar()).toBeTrue();\n  });\n\n  it('should tell if content audio translation is available', () => {\n    componentInstance.conceptCardIsBeingShown = true;\n    componentInstance.displayedCard = mockDisplayedCard;\n    expect(componentInstance.isContentAudioTranslationAvailable()).toBeFalse();\n    componentInstance.conceptCardIsBeingShown = false;\n    spyOn(\n      mockDisplayedCard,\n      'isContentAudioTranslationAvailable'\n    ).and.returnValue(true);\n    componentInstance.displayedCard = mockDisplayedCard;\n    expect(componentInstance.isContentAudioTranslationAvailable()).toBeTrue();\n  });\n\n  it('should check if current card is at end of transcript', () => {\n    componentInstance.displayedCard = mockDisplayedCard;\n    spyOn(mockDisplayedCard, 'isCompleted').and.returnValue(true);\n    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeFalse();\n  });\n\n  it('should tell if on a terminal card', () => {\n    componentInstance.displayedCard = mockDisplayedCard;\n    spyOn(mockDisplayedCard, 'isTerminal').and.returnValue(true);\n    expect(componentInstance.isOnTerminalCard()).toBeTrue();\n  });\n\n  it('should get input response pair id', () => {\n    expect(componentInstance.getInputResponsePairId(1)).toEqual(\n      'input-response-pair-1'\n    );\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/exploration-player-page/learner-experience/tutor-card.component.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the Tutor Card.\n */\n\nimport {\n  Component,\n  Input,\n  SimpleChanges,\n  ViewChild,\n  Renderer2,\n} from '@angular/core';\nimport {TranslateService} from '@ngx-translate/core';\nimport {AppConstants} from 'app.constants';\nimport {BindableVoiceovers} from 'domain/exploration/recorded-voiceovers.model';\nimport {StateCard} from 'domain/state_card/state-card.model';\nimport {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';\nimport cloneDeep from 'lodash/cloneDeep';\nimport isEqual from 'lodash/isEqual';\nimport {Subscription} from 'rxjs';\nimport {AudioBarStatusService} from 'services/audio-bar-status.service';\nimport {AudioPlayerService} from 'services/audio-player.service';\nimport {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';\nimport {ContextService} from 'services/context.service';\nimport {DeviceInfoService} from 'services/contextual/device-info.service';\nimport {UrlService} from 'services/contextual/url.service';\nimport {WindowDimensionsService} from 'services/contextual/window-dimensions.service';\nimport {WindowRef} from 'services/contextual/window-ref.service';\nimport {UserService} from 'services/user.service';\nimport {ExplorationPlayerConstants} from '../exploration-player-page.constants';\nimport {AudioPreloaderService} from '../services/audio-preloader.service';\nimport {AudioTranslationManagerService} from '../services/audio-translation-manager.service';\nimport {CurrentInteractionService} from '../services/current-interaction.service';\nimport {ExplorationPlayerStateService} from '../services/exploration-player-state.service';\nimport {LearnerAnswerInfoService} from '../services/learner-answer-info.service';\nimport {PlayerPositionService} from '../services/player-position.service';\nimport {I18nLanguageCodeService} from 'services/i18n-language-code.service';\nimport {\n  animate,\n  keyframes,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\nimport {CollectionSummary} from 'domain/collection/collection-summary.model';\nimport {LearnerExplorationSummary} from 'domain/summary/learner-exploration-summary.model';\nimport {EndChapterCheckMarkComponent} from './end-chapter-check-mark.component';\nimport {EndChapterConfettiComponent} from './end-chapter-confetti.component';\nimport {PlatformFeatureService} from 'services/platform-feature.service';\nimport {QuestionPlayerConfig} from './ratings-and-recommendations.component';\n\nconst CHECK_MARK_HIDE_DELAY_IN_MSECS = 500;\nconst REDUCED_MOTION_ANIMATION_DURATION_IN_MSECS = 2000;\nconst CONFETTI_ANIMATION_DELAY_IN_MSECS = 2000;\nconst STANDARD_ANIMATION_DURATION_IN_MSECS = 4000;\nconst MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS = [1, 5, 10, 25, 50];\n\nimport './tutor-card.component.css';\nimport {VoiceoverPlayerService} from '../services/voiceover-player.service';\n\n@Component({\n  selector: 'oppia-tutor-card',\n  templateUrl: './tutor-card.component.html',\n  styleUrls: ['./tutor-card.component.css'],\n  animations: [\n    trigger('expandInOut', [\n      state(\n        'in',\n        style({\n          overflow: 'visible',\n          height: '*',\n        })\n      ),\n      state(\n        'out',\n        style({\n          overflow: 'hidden',\n          height: '0px',\n          display: 'none',\n        })\n      ),\n      transition('in => out', animate('500ms ease-in-out')),\n      transition('out => in', [\n        style({display: 'block'}),\n        animate('500ms ease-in-out'),\n      ]),\n    ]),\n    trigger('fadeInOut', [\n      transition('void => *', []),\n      transition('* <=> *', [\n        style({opacity: 0}),\n        animate(\n          '1s ease',\n          keyframes([style({opacity: 0}), style({opacity: 1})])\n        ),\n      ]),\n    ]),\n  ],\n})\nexport class TutorCardComponent {\n  // These properties are initialized using Angular lifecycle hooks\n  // and we need to do non-null assertion. For more information, see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  @ViewChild('checkMark') checkMarkComponent!: EndChapterCheckMarkComponent;\n  @ViewChild('confetti') confettiComponent!: EndChapterConfettiComponent;\n  @Input() displayedCard!: StateCard;\n  @Input() displayedCardWasCompletedInPrevSession!: boolean;\n  @Input() startCardChangeAnimation!: boolean;\n  @Input() avatarImageIsShown!: boolean;\n  @Input() shouldHideInteraction!: boolean;\n  @Input() userIsLoggedIn!: boolean;\n  @Input() explorationIsInPreviewMode!: boolean;\n  @Input() questionPlayerConfig!: QuestionPlayerConfig;\n  @Input() collectionSummary!: CollectionSummary;\n  @Input() isRefresherExploration!: boolean;\n  @Input() recommendedExplorationSummaries!: LearnerExplorationSummary[];\n  @Input() parentExplorationIds!: string[];\n  @Input() inStoryMode!: boolean;\n  @Input() nextLessonLink!: string;\n  @Input() completedChaptersCount!: number;\n  @Input() milestoneMessageIsToBeDisplayed!: boolean;\n  @Input() feedbackIsEnabled!: boolean;\n  @Input() learnerCanOnlyAttemptQuestionOnce!: boolean;\n  @Input() inputOutputHistoryIsShown!: boolean;\n  @Input() checkpointCelebrationModalIsEnabled!: boolean;\n  private _editorPreviewMode!: boolean;\n  lastAnswer!: {answerDetails: string} | string | null;\n  conceptCardIsBeingShown!: boolean;\n  interactionIsActive!: boolean;\n  waitingForOppiaFeedback: boolean = false;\n  interactionInstructions!: string | null;\n  contentAudioTranslations!: BindableVoiceovers;\n  isIframed!: boolean;\n  getCanAskLearnerForAnswerInfo!: () => boolean;\n  OPPIA_AVATAR_IMAGE_URL!: string;\n  profilePicturePngDataUrl!: string;\n  profilePictureWebpDataUrl!: string;\n  directiveSubscriptions = new Subscription();\n  arePreviousResponsesShown: boolean = false;\n  nextMilestoneChapterCount: number | null = null;\n  checkMarkHidden: boolean = true;\n  animationHasPlayedOnce: boolean = false;\n  checkMarkSkipped: boolean = false;\n  confettiAnimationTimeout!: NodeJS.Timeout;\n  skipClickListener: Function | null = null;\n  username!: string | null;\n\n  constructor(\n    private audioBarStatusService: AudioBarStatusService,\n    private audioPlayerService: AudioPlayerService,\n    private audioPreloaderService: AudioPreloaderService,\n    private audioTranslationManagerService: AudioTranslationManagerService,\n    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,\n    private contextService: ContextService,\n    private currentInteractionService: CurrentInteractionService,\n    private deviceInfoService: DeviceInfoService,\n    private explorationPlayerStateService: ExplorationPlayerStateService,\n    private i18nLanguageCodeService: I18nLanguageCodeService,\n    private learnerAnswerInfoService: LearnerAnswerInfoService,\n    private playerPositionService: PlayerPositionService,\n    private urlInterpolationService: UrlInterpolationService,\n    private urlService: UrlService,\n    private userService: UserService,\n    private windowDimensionsService: WindowDimensionsService,\n    private windowRef: WindowRef,\n    public platformFeatureService: PlatformFeatureService,\n    private renderer: Renderer2,\n    private translateService: TranslateService,\n    private voiceoverPlayerService: VoiceoverPlayerService\n  ) {}\n\n  async getUserInfoAsync(): Promise<void> {\n    const userInfo = await this.userService.getUserInfoAsync();\n    this.username = userInfo.getUsername();\n    if (!this._editorPreviewMode) {\n      if (this.username !== null) {\n        [this.profilePicturePngDataUrl, this.profilePictureWebpDataUrl] =\n          this.userService.getProfileImageDataUrl(this.username);\n      } else {\n        this.profilePictureWebpDataUrl =\n          this.urlInterpolationService.getStaticImageUrl(\n            AppConstants.DEFAULT_PROFILE_IMAGE_WEBP_PATH\n          );\n        this.profilePicturePngDataUrl =\n          this.urlInterpolationService.getStaticImageUrl(\n            AppConstants.DEFAULT_PROFILE_IMAGE_PNG_PATH\n          );\n      }\n    } else {\n      this.profilePictureWebpDataUrl =\n        this.urlInterpolationService.getStaticImageUrl(\n          AppConstants.DEFAULT_PROFILE_IMAGE_WEBP_PATH\n        );\n      this.profilePicturePngDataUrl =\n        this.urlInterpolationService.getStaticImageUrl(\n          AppConstants.DEFAULT_PROFILE_IMAGE_PNG_PATH\n        );\n    }\n  }\n\n  ngOnInit(): void {\n    this._editorPreviewMode = this.contextService.isInExplorationEditorPage();\n    this.getUserInfoAsync();\n    this.isIframed = this.urlService.isIframed();\n    this.getCanAskLearnerForAnswerInfo =\n      this.learnerAnswerInfoService.getCanAskLearnerForAnswerInfo;\n    this.OPPIA_AVATAR_IMAGE_URL =\n      this.urlInterpolationService.getStaticCopyrightedImageUrl(\n        '/avatar/oppia_avatar_100px.svg'\n      );\n\n    this.directiveSubscriptions.add(\n      this.explorationPlayerStateService.onOppiaFeedbackAvailable.subscribe(\n        () => {\n          this.waitingForOppiaFeedback = false;\n\n          // Auto scroll to the new feedback on mobile device.\n          if (this.deviceInfoService.isMobileDevice()) {\n            let latestFeedbackIndex =\n              this.displayedCard.getInputResponsePairs().length - 1;\n\n            this.windowRef.nativeWindow.location.hash =\n              this.getInputResponsePairId(latestFeedbackIndex);\n          }\n        }\n      )\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.directiveSubscriptions.unsubscribe();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (\n      changes.displayedCard &&\n      !isEqual(\n        changes.displayedCard.previousValue,\n        changes.displayedCard.currentValue\n      )\n    ) {\n      this.updateDisplayedCard();\n    }\n    if (\n      this.isOnTerminalCard() &&\n      !this.animationHasPlayedOnce &&\n      this.inStoryMode\n    ) {\n      this.triggerCelebratoryAnimation();\n    }\n  }\n\n  triggerCelebratoryAnimation(): void {\n    this.checkMarkHidden = false;\n    this.checkMarkComponent.animateCheckMark();\n    this.skipClickListener = this.renderer.listen('document', 'click', () => {\n      clearTimeout(this.confettiAnimationTimeout);\n      this.checkMarkSkipped = true;\n      setTimeout(() => {\n        this.checkMarkHidden = true;\n      }, CHECK_MARK_HIDE_DELAY_IN_MSECS);\n    });\n    this.animationHasPlayedOnce = true;\n    let mediaQuery = this.windowRef.nativeWindow.matchMedia(\n      '(prefers-reduced-motion)'\n    );\n    if (mediaQuery.matches) {\n      setTimeout(() => {\n        this.checkMarkSkipped = true;\n        setTimeout(() => {\n          this.checkMarkHidden = true;\n          if (this.skipClickListener) {\n            this.skipClickListener();\n          }\n          this.skipClickListener = null;\n        }, CHECK_MARK_HIDE_DELAY_IN_MSECS);\n      }, REDUCED_MOTION_ANIMATION_DURATION_IN_MSECS);\n    } else {\n      this.confettiAnimationTimeout = setTimeout(() => {\n        this.confettiComponent.animateConfetti();\n      }, CONFETTI_ANIMATION_DELAY_IN_MSECS);\n      setTimeout(() => {\n        this.checkMarkHidden = true;\n        if (this.skipClickListener) {\n          this.skipClickListener();\n        }\n        this.skipClickListener = null;\n      }, STANDARD_ANIMATION_DURATION_IN_MSECS);\n    }\n  }\n\n  generateMilestoneMessage(): string {\n    if (\n      !this.inStoryMode ||\n      !this.milestoneMessageIsToBeDisplayed ||\n      !this.completedChaptersCount ||\n      !MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS.includes(\n        this.completedChaptersCount\n      )\n    ) {\n      return '';\n    }\n    let chapterCountMessageIndex =\n      MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS.indexOf(\n        this.completedChaptersCount\n      ) + 1;\n    let milestoneMessageTranslationKey =\n      'I18N_END_CHAPTER_MILESTONE_MESSAGE_' + chapterCountMessageIndex;\n    return this.translateService.instant(milestoneMessageTranslationKey);\n  }\n\n  setNextMilestoneAndCheckIfProgressBarIsShown(): boolean {\n    if (\n      !this.inStoryMode ||\n      this.isCompletedChaptersCountGreaterThanLastMilestone() ||\n      this.isMilestoneReachedAndMilestoneMessageToBeDisplayed()\n    ) {\n      this.nextMilestoneChapterCount = null;\n      return false;\n    }\n\n    if (\n      !this.milestoneMessageIsToBeDisplayed &&\n      MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS.includes(\n        this.completedChaptersCount\n      )\n    ) {\n      let chapterCountIndex =\n        MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS.indexOf(\n          this.completedChaptersCount\n        );\n      this.nextMilestoneChapterCount =\n        MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS[chapterCountIndex + 1];\n      return true;\n    }\n\n    for (let milestoneCount of MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS) {\n      if (milestoneCount > this.completedChaptersCount) {\n        this.nextMilestoneChapterCount = milestoneCount;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isMilestoneReachedAndMilestoneMessageToBeDisplayed(): boolean {\n    return (\n      this.milestoneMessageIsToBeDisplayed &&\n      MILESTONE_SPECIFIC_COMPLETED_CHAPTER_COUNTS.includes(\n        this.completedChaptersCount\n      )\n    );\n  }\n\n  isCompletedChaptersCountGreaterThanLastMilestone(): boolean {\n    return this.completedChaptersCount > 50;\n  }\n\n  getStaticImageUrl(imagePath: string): string {\n    return this.urlInterpolationService.getStaticImageUrl(imagePath);\n  }\n\n  isAudioBarExpandedOnMobileDevice(): boolean {\n    return (\n      this.deviceInfoService.isMobileDevice() &&\n      this.audioBarStatusService.isAudioBarExpanded()\n    );\n  }\n\n  isLanguageRTL(): boolean {\n    return this.i18nLanguageCodeService.isCurrentLanguageRTL();\n  }\n\n  updateDisplayedCard(): void {\n    this.arePreviousResponsesShown = false;\n    this.lastAnswer = null;\n    this.conceptCardIsBeingShown = Boolean(\n      !this.displayedCard.getInteraction()\n    );\n    this.interactionIsActive = !this.displayedCard.isCompleted();\n    this.directiveSubscriptions.add(\n      this.playerPositionService.onNewCardAvailable.subscribe(\n        () => (this.interactionIsActive = false)\n      )\n    );\n    this.currentInteractionService.registerPresubmitHook(() => {\n      this.waitingForOppiaFeedback = true;\n    });\n\n    if (!this.interactionIsActive) {\n      this.lastAnswer = this.displayedCard.getLastAnswer();\n    }\n\n    if (!this.conceptCardIsBeingShown) {\n      this.interactionInstructions =\n        this.displayedCard.getInteractionInstructions();\n      this.contentAudioTranslations = this.displayedCard.getVoiceovers();\n\n      this.voiceoverPlayerService.setActiveVoiceover(\n        this.displayedCard.contentId\n      );\n      this.voiceoverPlayerService.setActiveComponentName(\n        AppConstants.COMPONENT_NAME_CONTENT\n      );\n\n      this.audioTranslationManagerService.clearSecondaryAudioTranslations();\n      this.audioTranslationManagerService.setContentAudioTranslations(\n        cloneDeep(this.contentAudioTranslations),\n        this.displayedCard.getContentHtml(),\n        AppConstants.COMPONENT_NAME_CONTENT\n      );\n      this.audioPlayerService.clear();\n      this.audioPreloaderService.clearMostRecentlyRequestedAudioFilename();\n      this.autogeneratedAudioPlayerService.cancel();\n    }\n  }\n\n  isInteractionInline(): boolean {\n    if (this.conceptCardIsBeingShown) {\n      return true;\n    }\n    return this.displayedCard.isInteractionInline();\n  }\n\n  isVoiceoverContributionWithAccentEnabled(): boolean {\n    return this.platformFeatureService.status.AddVoiceoverWithAccent.isEnabled;\n  }\n\n  // This function returns null if audio is not available.\n  getContentAudioHighlightClass(): string | null {\n    if (\n      this.isVoiceoverContributionWithAccentEnabled() &&\n      this.voiceoverPlayerService.getActiveComponentName() ===\n        AppConstants.COMPONENT_NAME_CONTENT &&\n      this.audioPlayerService.isPlaying()\n    ) {\n      return ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS;\n    } else if (\n      !this.isVoiceoverContributionWithAccentEnabled() &&\n      this.audioTranslationManagerService.getCurrentComponentName() ===\n        AppConstants.COMPONENT_NAME_CONTENT &&\n      (this.audioPlayerService.isPlaying() ||\n        this.autogeneratedAudioPlayerService.isPlaying())\n    ) {\n      return ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS;\n    }\n\n    return null;\n  }\n\n  getContentFocusLabel(index: number): string {\n    return ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index;\n  }\n\n  toggleShowPreviousResponses(): void {\n    this.arePreviousResponsesShown = !this.arePreviousResponsesShown;\n  }\n\n  isWindowNarrow(): boolean {\n    return this.windowDimensionsService.isWindowNarrow();\n  }\n\n  canWindowShowTwoCards(): boolean {\n    return (\n      this.windowDimensionsService.getWidth() >\n      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX\n    );\n  }\n\n  showAudioBar(): boolean {\n    return (\n      !this.isIframed && !this.explorationPlayerStateService.isInQuestionMode()\n    );\n  }\n\n  isContentAudioTranslationAvailable(): boolean {\n    if (this.conceptCardIsBeingShown) {\n      return false;\n    }\n    return this.displayedCard.isContentAudioTranslationAvailable();\n  }\n\n  isCurrentCardAtEndOfTranscript(): boolean {\n    return !this.displayedCard.isCompleted();\n  }\n\n  isOnTerminalCard(): boolean {\n    return this.displayedCard.isTerminal();\n  }\n\n  getInputResponsePairId(index: number): string {\n    return 'input-response-pair-' + index;\n  }\n}\n"
    },
    {
      "filename": "core/tests/webdriverio_utils/ReleaseCoordinatorPage.js",
      "content": "// Copyright 2023 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Page object for the release-coordinator page, for use in\n * WebdriverIO tests.\n */\n\nvar action = require('./action.js');\nvar general = require('./general.js');\nvar waitFor = require('./waitFor.js');\n\nvar ReleaseCoordinatorPage = function () {\n  var RELEASE_COORDINATOR_URL_SUFFIX = '/release-coordinator';\n  var featureFlagElementsSelector = function () {\n    return $$('.e2e-test-feature-flag');\n  };\n  var featureFlagElement = $('.e2e-test-feature-flag');\n  var featureNameLocator = '.e2e-test-feature-name';\n  var featuresTab = $('.e2e-test-features-tab');\n  var saveButtonLocator = '.e2e-test-save-button';\n  var valueSelectorLocator = '.e2e-test-value-selector';\n  var statusMessage = $('.e2e-test-status-message');\n\n  this.get = async function () {\n    await browser.url(RELEASE_COORDINATOR_URL_SUFFIX);\n    await waitFor.pageToFullyLoad();\n  };\n\n  this.getFeaturesTab = async function () {\n    await this.get();\n    await action.click('Release coordinator features tab', featuresTab);\n    await waitFor.visibilityOf(\n      featureFlagElement,\n      'Feature flags not showing up'\n    );\n  };\n\n  // Remove this method after the dummy_feature_flag_for_e2e_tests feature flag\n  // is deprecated.\n  this.getDummyFeatureFlagForE2ETests = async function () {\n    var featureFlagElements = await featureFlagElementsSelector();\n    var count = featureFlagElements.length;\n    for (let i = 0; i < count; i++) {\n      var elem = featureFlagElements[i];\n      if (\n        (await elem.$(featureNameLocator).getText()) ===\n        'dummy_feature_flag_for_e2e_tests'\n      ) {\n        return elem;\n      }\n    }\n\n    return null;\n  };\n\n  this.getImprovementsTabFeatureElement = async function () {\n    var featureFlagElements = await featureFlagElementsSelector();\n    var count = featureFlagElements.length;\n    for (let i = 0; i < count; i++) {\n      var elem = featureFlagElements[i];\n      if (\n        (await elem.$(featureNameLocator).getText()) ===\n        'is_improvements_tab_enabled'\n      ) {\n        return elem;\n      }\n    }\n\n    return null;\n  };\n\n  // Remove this method after the enable_voiceover_contribution feature flag\n  // is deprecated.\n  this.getVoiceoverContributionFeatureElement = async function () {\n    var featureFlagElements = await featureFlagElementsSelector();\n    var count = featureFlagElements.length;\n    for (let i = 0; i < count; i++) {\n      var elem = featureFlagElements[i];\n      if (\n        (await elem.$(featureNameLocator).getText()) ===\n        'enable_voiceover_contribution'\n      ) {\n        return elem;\n      }\n    }\n\n    return null;\n  };\n\n  // TODO(#18881): Remove this method after the cd_admin_dashboard_new_ui\n  // feature flag is deprecated.\n  this.getCdAdminDashboardNewUiFeatureElement = async function () {\n    var featureFlagElements = await featureFlagElementsSelector();\n    var count = featureFlagElements.length;\n    for (let i = 0; i < count; i++) {\n      var elem = featureFlagElements[i];\n      if (\n        (await elem.$(featureNameLocator).getText()) ===\n        'cd_admin_dashboard_new_ui'\n      ) {\n        return elem;\n      }\n    }\n\n    return null;\n  };\n\n  // Remove this method after the serial_chapter_launch_curriculum_admin_view\n  // feature flag is deprecated.\n  this.getSerialChapterCurriculumAdminFeatureElement = async function () {\n    var featureFlagElements = await featureFlagElementsSelector();\n    var count = featureFlagElements.length;\n    for (let i = 0; i < count; i++) {\n      var elem = featureFlagElements[i];\n      if (\n        (await action.getText('Feature Flag', elem.$(featureNameLocator))) ===\n        'serial_chapter_launch_curriculum_admin_view'\n      ) {\n        return elem;\n      }\n    }\n\n    return null;\n  };\n\n  // This function is meant to be used to enable a feature gated behind\n  // a feature flag.\n  this.enableFeature = async function (featureElement) {\n    await waitFor.visibilityOf(\n      featureElement.$(valueSelectorLocator),\n      'Enabling force-enable property takes too long to appear'\n    );\n\n    await featureElement.$(valueSelectorLocator).selectByVisibleText('Yes');\n    await this.saveChangeOfFeature(featureElement);\n  };\n\n  this.disableFeatureFlag = async function (featureFlagElement) {\n    await waitFor.visibilityOf(\n      featureFlagElement.$(valueSelectorLocator),\n      'Disabling force-enable property takes too long to appear'\n    );\n\n    await featureFlagElement.$(valueSelectorLocator).selectByVisibleText('No');\n    await this.saveChangeOfFeature(featureFlagElement);\n  };\n\n  this.saveChangeOfFeature = async function (featureElement) {\n    await action.click(\n      'Save feature button',\n      featureElement.$(saveButtonLocator)\n    );\n\n    await general.acceptAlert();\n    await waitFor.visibilityOf(statusMessage);\n  };\n};\n\nexports.ReleaseCoordinatorPage = ReleaseCoordinatorPage;\n"
    }
  ]
}