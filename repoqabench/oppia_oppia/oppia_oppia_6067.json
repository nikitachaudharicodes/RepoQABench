{
  "repo_name": "oppia_oppia",
  "issue_id": "6067",
  "issue_description": "# The linter should report if we use the args-name for a non-keyword argument\n\nPylint reports when we don't mention the args-name for a keyword argument as 'non-explicit-keyword-args' message.\r\nThe linter should also provide for the other way around -- i.e, it should also report if we use the args-name for a non-keyword argument.\r\n",
  "issue_comments": [
    {
      "id": 454760966,
      "user": "KhalidRmb",
      "body": "HI! I would like to work on this. @lilithxxx "
    },
    {
      "id": 454772553,
      "user": "lilithxxx",
      "body": "Hi @KhalidRmb have you signed the CLA? You can do that by following the steps [here](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up) to get started. After that you can start working on the issue. Thanks!"
    },
    {
      "id": 454774254,
      "user": "KhalidRmb",
      "body": "Yes, I've done it and set everything up. Thanks!"
    },
    {
      "id": 454776139,
      "user": "lilithxxx",
      "body": "Well then I guess you can start working on it! Thanks!"
    },
    {
      "id": 494624827,
      "user": "brianrodri",
      "body": "Hmm I really don't like the idea of disallowing named positional args. The worst they do is add some overhead, the best is far more readable code. If anything, we should add checks to ensure that the kwargs are using the right names.\r\n\r\nI don't see a reason to follow through with this besides following pylint's example, which I feel is a mistake. Any thoughts @seanlip @lilithxxx?\r\n\r\nA good argument for keeping this: https://www.youtube.com/watch?v=wf-BqAjZb8M#t=43m15s"
    },
    {
      "id": 494935044,
      "user": "seanlip",
      "body": "For large codebases like this one with many new contributors, I think it is helpful to have standardized conventions. So there are two possibilities: (a) enforce names for all positional args, (b) disallow names for all positional args. I think \"allow it but not consistently\" isn't really a convention, and would prefer not to go that route.\r\n\r\nPersonally I don't think adding additional named positional args makes the code that much more readable, though perhaps I'm already used to the workflow of traversing the code to find what function is being referred to. On the other hand, I do find it useful to know when we're overwriting a default arg, and the existing convention of adding names solely for those args helps with that. So, I slightly prefer (b), but would be happy with either as long as it is applied consistently throughout the codebase. \r\n\r\n(I agree that it's also worth adding checks to ensure that the kwargs are using the right names.)\r\n\r\n@oppia/dev-workflow-team -- any thoughts?"
    },
    {
      "id": 495221098,
      "user": "brianrodri",
      "body": "Hmm I've found the opposite experience, I find it frustrating *needing* to look up a function's definition (especially in tests/code reviews), and find having as much context at call sites more valuable than knowing whether we're overriding a keyword argument. This is especially true since I use vim, and don't use any plugins to look things up yet. Still, I don't feel like we should force writers to gravitate to a certain IDE, they should code in whatever they feel most comfortable in.\r\n\r\nAlso, I don't see the need to make it an all-or-nothing choice, that sounds too extreme. Instead, we could just provide guidelines like:\r\n\r\n> Named positional arguments provide readers a much richer experience for reviewing code. Do not force readers to look up the definition of a function, instead, provide helpful context at call-sites so that the function's purpose is immediately obvious. Naming positional arguments is especially helpful for this.\r\n>\r\n> Here are guidelines for naming positional arguments:\r\n> - Prefer naming arguments when their purpose is not immediately obvious from surrounding context.\r\n>   ```diff\r\n>   - twitter_search('code style', 10, False, True)\r\n>   + twitter_search('code style', numtweets=10, retweets=False, unicode=True)\r\n>   ```\r\n>\r\n> - Avoid naming positional arguments when their purpose *is* immediately obvious:\r\n>   ```diff\r\n>   - assertEqual(lhs=one, rhs=1)\r\n>   + assertEqual(one, 1)\r\n>   ```\r\n>\r\n> - Prefer naming positional arguments when many arguments with literal types are grouped together:\r\n>   ```diff\r\n>     self.save_new_topic(\r\n>             # GOOD: These are self-documenting thanks to their values.\r\n>             self.topic_id, self.owner_id, 'Name', 'Description',\r\n>   -         [], [], [], [], 1)\r\n>   +         canonical_story_ids=[], additional_story_ids=[],\r\n>   +         uncategorized_skill_ids=[], subtopics=[], next_subtopic_id=1)\r\n>   ```\r\n>\r\n> In general, prioritize making it easy to **read your code**, even if it takes more effort to write.\r\n>\r\n> **Tip:** Pass well-named values to functions to avoid naming arguments altogether:\r\n> ```python3\r\n> canonical_story_ids = []\r\n> additional_story_ids = []\r\n> uncategorized_skill_ids = []\r\n> subtopics = []\r\n> next_subtopic_id = 1\r\n>\r\n> self.save_new_topic(\r\n>         self.topic_id, self.owner_id, 'Name', 'Description',\r\n>         canonical_story_ids, additional_story_ids,\r\n>         uncategorized_skill_ids, subtopics, next_subtopic_id)\r\n> ```\r\n>\r\n\r\n---\r\n\r\nSide note: A nice thing about eventually moving to Python3 is we can force writers to name their kwargs at \"compile-time\":\r\n\r\n[Docs](https://docs.python.org/3.5/reference/compound_stmts.html#function-definitions)\r\n> \r\n```python\r\ndef func_with_kwargs(a, b, *, c=None, b=None):  # Python3-only\r\n    pass\r\n\r\nfunc_with_kwargs(a, b, 5)  # Will not \"compile\", must write as `c=5`\r\n```"
    },
    {
      "id": 495359701,
      "user": "seanlip",
      "body": "I think that's a reasonable proposal, although personally I still lean towards the current system. For reference I use Sublime Text which AFAIK doesn't have automatic code referencing (or much IDE functionality), but my workflow is basically Ctrl+Shift+F to see where the function is defined. (I'm fine doing this when reviewing too -- it helps to see the full docstring etc. for functions that I am not familiar with.)\r\n\r\nThat said, that's just one opinion, and I'm open to this being changed. It does depart from how we've done things in the past, though, so I feel like we should loop in @oppia/dev-workflow-team to see what they think (since they maintain the dev workflow tooling), and possibly anyone from oppia-dev@ who is interested. If there's general support for a change then let's do it; if people are ambivalent or prefer the current rules, let's not. Does that sound good?"
    },
    {
      "id": 495363733,
      "user": "lilithxxx",
      "body": "I personally agree with @seanlip, I too go to the function definition and check out what it's doing. I am fine with the current workflow, but if you want to change the system it's fine too!"
    },
    {
      "id": 496003943,
      "user": "brianrodri",
      "body": "Sorry, not sure you mean by current system. Does that mean to say we are already disallowing names for positional args?\r\n\r\nIf we don't want to make any changes, I'd rather we just close this issue since I'm still strongly against removing the feature. If anything I think we should change this to \"make sure named arguments are using the correct name\"."
    },
    {
      "id": 496025231,
      "user": "seanlip",
      "body": "Yes, we are already disallowing names for positional args, but informally through code review (pretty much as long as this codebase has been around). This issue is just converting this to an automatic lint check instead."
    },
    {
      "id": 496025386,
      "user": "lilithxxx",
      "body": "So @seanlip @brianrodri what conclusion can be drawn here?"
    },
    {
      "id": 496025892,
      "user": "seanlip",
      "body": "I think the question is not so much what to do with this issue, as what style standard the codebase should follow. Historically, we have been going with disallowing names for positional args, but only in code review. The reason this hasn't come up recently is because infractions happen only very rarely.\r\n\r\nWe need to decide whether to continue doing that or not. It seems to me like:\r\n- @brianrodri prefers removing this convention\r\n- @lilithxxx is fine with the current system but is also fine with changes to it\r\n- @seanlip prefers the current system\r\n\r\nSo I think we're still stuck on getting more feedback from @oppia/dev-workflow-team (or the oppia-dev@ folks as a whole). Probably @oppia/dev-workflow-team should be the decider since they maintain the lint checks."
    },
    {
      "id": 496028345,
      "user": "anubhavsinha98",
      "body": "Hi @seanlip, @brianrodri & @lilithxxx I went through all the suggestions in the thread. I think we should continue with the current system, as I also go to the function definition and check what's actually going on there. These are my opinions."
    },
    {
      "id": 496119219,
      "user": "apb7",
      "body": "Hi everyone, weighing in here, I prefer the current system where we mandate to name keyword arguments during a function call. Regarding naming positional arguments, I agree with @brianrodri -- they tend to increase readability at some places, for example, [here](https://github.com/oppia/oppia/pull/6761#discussion_r285389692) and [these guidelines](https://github.com/oppia/oppia/issues/6067#issuecomment-495221098) look good but I feel we should either allow naming of all positional args or disallow naming of all positional args, since this will help us to enforce a convention and implement a check for the same. Thanks!"
    },
    {
      "id": 497456017,
      "user": "lilithxxx",
      "body": "After discussing with @oppia/dev-workflow-team its been decided to go with the current system, i.e disallowing names for positional args. This is currently being done via code review and thus this issue still remains open to add an automated check for the same."
    },
    {
      "id": 574003925,
      "user": "kevinlee12",
      "body": "Filed #8423 "
    }
  ],
  "text_context": "# The linter should report if we use the args-name for a non-keyword argument\n\nPylint reports when we don't mention the args-name for a keyword argument as 'non-explicit-keyword-args' message.\r\nThe linter should also provide for the other way around -- i.e, it should also report if we use the args-name for a non-keyword argument.\r\n\n\nHI! I would like to work on this. @lilithxxx \n\nHi @KhalidRmb have you signed the CLA? You can do that by following the steps [here](https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#setting-things-up) to get started. After that you can start working on the issue. Thanks!\n\nYes, I've done it and set everything up. Thanks!\n\nWell then I guess you can start working on it! Thanks!\n\nHmm I really don't like the idea of disallowing named positional args. The worst they do is add some overhead, the best is far more readable code. If anything, we should add checks to ensure that the kwargs are using the right names.\r\n\r\nI don't see a reason to follow through with this besides following pylint's example, which I feel is a mistake. Any thoughts @seanlip @lilithxxx?\r\n\r\nA good argument for keeping this: https://www.youtube.com/watch?v=wf-BqAjZb8M#t=43m15s\n\nFor large codebases like this one with many new contributors, I think it is helpful to have standardized conventions. So there are two possibilities: (a) enforce names for all positional args, (b) disallow names for all positional args. I think \"allow it but not consistently\" isn't really a convention, and would prefer not to go that route.\r\n\r\nPersonally I don't think adding additional named positional args makes the code that much more readable, though perhaps I'm already used to the workflow of traversing the code to find what function is being referred to. On the other hand, I do find it useful to know when we're overwriting a default arg, and the existing convention of adding names solely for those args helps with that. So, I slightly prefer (b), but would be happy with either as long as it is applied consistently throughout the codebase. \r\n\r\n(I agree that it's also worth adding checks to ensure that the kwargs are using the right names.)\r\n\r\n@oppia/dev-workflow-team -- any thoughts?\n\nHmm I've found the opposite experience, I find it frustrating *needing* to look up a function's definition (especially in tests/code reviews), and find having as much context at call sites more valuable than knowing whether we're overriding a keyword argument. This is especially true since I use vim, and don't use any plugins to look things up yet. Still, I don't feel like we should force writers to gravitate to a certain IDE, they should code in whatever they feel most comfortable in.\r\n\r\nAlso, I don't see the need to make it an all-or-nothing choice, that sounds too extreme. Instead, we could just provide guidelines like:\r\n\r\n> Named positional arguments provide readers a much richer experience for reviewing code. Do not force readers to look up the definition of a function, instead, provide helpful context at call-sites so that the function's purpose is immediately obvious. Naming positional arguments is especially helpful for this.\r\n>\r\n> Here are guidelines for naming positional arguments:\r\n> - Prefer naming arguments when their purpose is not immediately obvious from surrounding context.\r\n>   ```diff\r\n>   - twitter_search('code style', 10, False, True)\r\n>   + twitter_search('code style', numtweets=10, retweets=False, unicode=True)\r\n>   ```\r\n>\r\n> - Avoid naming positional arguments when their purpose *is* immediately obvious:\r\n>   ```diff\r\n>   - assertEqual(lhs=one, rhs=1)\r\n>   + assertEqual(one, 1)\r\n>   ```\r\n>\r\n> - Prefer naming positional arguments when many arguments with literal types are grouped together:\r\n>   ```diff\r\n>     self.save_new_topic(\r\n>             # GOOD: These are self-documenting thanks to their values.\r\n>             self.topic_id, self.owner_id, 'Name', 'Description',\r\n>   -         [], [], [], [], 1)\r\n>   +         canonical_story_ids=[], additional_story_ids=[],\r\n>   +         uncategorized_skill_ids=[], subtopics=[], next_subtopic_id=1)\r\n>   ```\r\n>\r\n> In general, prioritize making it easy to **read your code**, even if it takes more effort to write.\r\n>\r\n> **Tip:** Pass well-named values to functions to avoid naming arguments altogether:\r\n> ```python3\r\n> canonical_story_ids = []\r\n> additional_story_ids = []\r\n> uncategorized_skill_ids = []\r\n> subtopics = []\r\n> next_subtopic_id = 1\r\n>\r\n> self.save_new_topic(\r\n>         self.topic_id, self.owner_id, 'Name', 'Description',\r\n>         canonical_story_ids, additional_story_ids,\r\n>         uncategorized_skill_ids, subtopics, next_subtopic_id)\r\n> ```\r\n>\r\n\r\n---\r\n\r\nSide note: A nice thing about eventually moving to Python3 is we can force writers to name their kwargs at \"compile-time\":\r\n\r\n[Docs](https://docs.python.org/3.5/reference/compound_stmts.html#function-definitions)\r\n> \r\n```python\r\ndef func_with_kwargs(a, b, *, c=None, b=None):  # Python3-only\r\n    pass\r\n\r\nfunc_with_kwargs(a, b, 5)  # Will not \"compile\", must write as `c=5`\r\n```\n\nI think that's a reasonable proposal, although personally I still lean towards the current system. For reference I use Sublime Text which AFAIK doesn't have automatic code referencing (or much IDE functionality), but my workflow is basically Ctrl+Shift+F to see where the function is defined. (I'm fine doing this when reviewing too -- it helps to see the full docstring etc. for functions that I am not familiar with.)\r\n\r\nThat said, that's just one opinion, and I'm open to this being changed. It does depart from how we've done things in the past, though, so I feel like we should loop in @oppia/dev-workflow-team to see what they think (since they maintain the dev workflow tooling), and possibly anyone from oppia-dev@ who is interested. If there's general support for a change then let's do it; if people are ambivalent or prefer the current rules, let's not. Does that sound good?\n\nI personally agree with @seanlip, I too go to the function definition and check out what it's doing. I am fine with the current workflow, but if you want to change the system it's fine too!\n\nSorry, not sure you mean by current system. Does that mean to say we are already disallowing names for positional args?\r\n\r\nIf we don't want to make any changes, I'd rather we just close this issue since I'm still strongly against removing the feature. If anything I think we should change this to \"make sure named arguments are using the correct name\".\n\nYes, we are already disallowing names for positional args, but informally through code review (pretty much as long as this codebase has been around). This issue is just converting this to an automatic lint check instead.\n\nSo @seanlip @brianrodri what conclusion can be drawn here?\n\nI think the question is not so much what to do with this issue, as what style standard the codebase should follow. Historically, we have been going with disallowing names for positional args, but only in code review. The reason this hasn't come up recently is because infractions happen only very rarely.\r\n\r\nWe need to decide whether to continue doing that or not. It seems to me like:\r\n- @brianrodri prefers removing this convention\r\n- @lilithxxx is fine with the current system but is also fine with changes to it\r\n- @seanlip prefers the current system\r\n\r\nSo I think we're still stuck on getting more feedback from @oppia/dev-workflow-team (or the oppia-dev@ folks as a whole). Probably @oppia/dev-workflow-team should be the decider since they maintain the lint checks.\n\nHi @seanlip, @brianrodri & @lilithxxx I went through all the suggestions in the thread. I think we should continue with the current system, as I also go to the function definition and check what's actually going on there. These are my opinions.\n\nHi everyone, weighing in here, I prefer the current system where we mandate to name keyword arguments during a function call. Regarding naming positional arguments, I agree with @brianrodri -- they tend to increase readability at some places, for example, [here](https://github.com/oppia/oppia/pull/6761#discussion_r285389692) and [these guidelines](https://github.com/oppia/oppia/issues/6067#issuecomment-495221098) look good but I feel we should either allow naming of all positional args or disallow naming of all positional args, since this will help us to enforce a convention and implement a check for the same. Thanks!\n\nAfter discussing with @oppia/dev-workflow-team its been decided to go with the current system, i.e disallowing names for positional args. This is currently being done via code review and thus this issue still remains open to add an automated check for the same.\n\nFiled #8423 ",
  "pr_link": "https://github.com/oppia/oppia/pull/6761",
  "code_context": [
    {
      "filename": "core/controllers/acl_decorators.py",
      "content": "# coding: utf-8\n#\n# Copyright 2017 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Decorators to provide authorization across the site.\"\"\"\n\nimport urllib\n\nfrom core.controllers import base\nfrom core.domain import feedback_services\nfrom core.domain import question_services\nfrom core.domain import rights_manager\nfrom core.domain import role_services\nfrom core.domain import skill_services\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_services\nfrom core.domain import suggestion_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nimport feconf\n\ncurrent_user_services = models.Registry.import_current_user_services()\n\n(suggestion_models,) = models.Registry.import_models([models.NAMES.suggestion])\n\n\ndef open_access(handler):\n    \"\"\"Decorator to give access to everyone.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that can\n            also give access to everyone.\n    \"\"\"\n\n    def test_can_access(self, *args, **kwargs):\n        \"\"\"Gives access to everyone.\n\n        Args:\n            *args: *. Arguments.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n        \"\"\"\n        return handler(self, *args, **kwargs)\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_play_exploration(handler):\n    \"\"\"Decorator to check whether user can play given exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now can check\n            if users can play a given exploration.\n    \"\"\"\n\n    def test_can_play(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can play the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n        \"\"\"\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise self.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if exploration_rights is None:\n            raise self.PageNotFoundException\n\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_play.__wrapped__ = True\n\n    return test_can_play\n\n\ndef can_view_skill(handler):\n    \"\"\"Decorator to check whether user can play a given skill.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that can also\n            check if the user can play a given skill.\n    \"\"\"\n\n    def test_can_play(self, skill_id, **kwargs):\n        \"\"\"Checks if the user can play the skill.\n\n        Args:\n            skill_id: str. The skill id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            bool. Whether the user can play the given skill.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n        \"\"\"\n        # This is a temporary check, since a decorator is required for every\n        # method. Once skill publishing is done, whether given skill is\n        # published should be checked here.\n        skill = skill_services.get_skill_by_id(skill_id, strict=False)\n\n        if skill is not None:\n            return handler(self, skill_id, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_play.__wrapped__ = True\n\n    return test_can_play\n\n\ndef can_play_collection(handler):\n    \"\"\"Decorator to check whether user can play given collection.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that can also\n            check if a user can play a given collection.\n    \"\"\"\n\n    def test_can_play(self, collection_id, **kwargs):\n        \"\"\"Checks if the user can play the collection.\n\n        Args:\n            collection_id: str. The collection id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n        \"\"\"\n        collection_rights = rights_manager.get_collection_rights(\n            collection_id, strict=False)\n\n        if collection_rights is None:\n            raise self.PageNotFoundException\n\n        if rights_manager.check_can_access_activity(\n                self.user, collection_rights):\n            return handler(self, collection_id, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_play.__wrapped__ = True\n\n    return test_can_play\n\n\ndef can_download_exploration(handler):\n    \"\"\"Decorator to check whether user can download given exploration.\n    If a user is authorized to play given exploration, they can download it.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that can also check\n            if the user has permission to download a given\n            exploration.\n    \"\"\"\n\n    def test_can_download(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can download the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n        \"\"\"\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if exploration_rights is None:\n            raise self.PageNotFoundException\n\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_download.__wrapped__ = True\n\n    return test_can_download\n\n\ndef can_view_exploration_stats(handler):\n    \"\"\"Decorator to check whether user can view exploration stats.\n    If a user is authorized to play given exploration, they can view its stats.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that checks if the user\n            has permission to view exploration stats.\n    \"\"\"\n\n    def test_can_view_stats(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can view the exploration stats.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n        \"\"\"\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if exploration_rights is None:\n            raise self.PageNotFoundException\n\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.PageNotFoundException\n    test_can_view_stats.__wrapped__ = True\n\n    return test_can_view_stats\n\n\ndef can_edit_collection(handler):\n    \"\"\"Decorator to check whether the user can edit collection.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that checks if\n            the user has permission to edit a given collection.\n    \"\"\"\n\n    def test_can_edit(self, collection_id, **kwargs):\n        \"\"\"Checks if the user is logged in and can edit the collection.\n\n        Args:\n            collection_id: str. The collection id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to edit the collection.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        collection_rights = rights_manager.get_collection_rights(\n            collection_id, strict=False)\n        if collection_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_edit_activity(\n                self.user, collection_rights):\n            return handler(self, collection_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to edit this collection.')\n    test_can_edit.__wrapped__ = True\n\n    return test_can_edit\n\n\ndef can_manage_email_dashboard(handler):\n    \"\"\"Decorator to check whether user can access email dashboard.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user has permission to access the email\n            dashboard.\n    \"\"\"\n\n    def test_can_manage_emails(self, **kwargs):\n        \"\"\"Checks if the user is logged in and can access email dashboard.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to access the email dashboard.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        if role_services.ACTION_MANAGE_EMAIL_DASHBOARD in self.user.actions:\n            return handler(self, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to access email dashboard.')\n    test_can_manage_emails.__wrapped__ = True\n\n    return test_can_manage_emails\n\n\ndef can_access_moderator_page(handler):\n    \"\"\"Decorator to check whether user can access moderator page.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user has permission to access the moderator\n            page.\n    \"\"\"\n\n    def test_can_access_moderator_page(self, **kwargs):\n        \"\"\"Checks if the user is logged in and can access moderator page.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to access the moderator page.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        if role_services.ACTION_ACCESS_MODERATOR_PAGE in self.user.actions:\n            return handler(self, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to access moderator page.')\n    test_can_access_moderator_page.__wrapped__ = True\n\n    return test_can_access_moderator_page\n\n\ndef can_send_moderator_emails(handler):\n    \"\"\"Decorator to check whether user can send moderator emails.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user has permission to send moderator emails.\n    \"\"\"\n\n    def test_can_send_moderator_emails(self, **kwargs):\n        \"\"\"Checks if the user is logged in and can send moderator emails.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to send moderator emails.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        if role_services.ACTION_SEND_MODERATOR_EMAILS in self.user.actions:\n            return handler(self, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to send moderator emails.')\n    test_can_send_moderator_emails.__wrapped__ = True\n\n    return test_can_send_moderator_emails\n\n\ndef can_manage_own_profile(handler):\n    \"\"\"Decorator to check whether user can manage their profile.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to manage their profile.\n    \"\"\"\n\n    def test_can_manage_profile(self, **kwargs):\n        \"\"\"Checks if the user is logged in and can manage their profile.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to manage profile or preferences.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        if role_services.ACTION_MANAGE_PROFILE in self.user.actions:\n            return handler(self, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to manage profile or preferences.')\n    test_can_manage_profile.__wrapped__ = True\n\n    return test_can_manage_profile\n\n\ndef can_access_admin_page(handler):\n    \"\"\"Decorator that checks if the current user is a super admin.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user is a super admin.\n    \"\"\"\n\n    def test_super_admin(self, **kwargs):\n        \"\"\"Checks if the user is logged in and is a super admin.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user is not a super admin\n                of the application.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        if not current_user_services.is_current_user_super_admin():\n            raise self.UnauthorizedUserException(\n                '%s is not a super admin of this application' % self.user_id)\n        return handler(self, **kwargs)\n    test_super_admin.__wrapped__ = True\n\n    return test_super_admin\n\n\ndef can_upload_exploration(handler):\n    \"\"\"Decorator that checks if the current user can upload exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to upload an exploration.\n    \"\"\"\n\n    def test_can_upload(self, **kwargs):\n        \"\"\"Checks if the user can upload exploration.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to upload an exploration.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        if not current_user_services.is_current_user_super_admin():\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to upload exploration.')\n        return handler(self, **kwargs)\n    test_can_upload.__wrapped__ = True\n\n    return test_can_upload\n\n\ndef can_create_exploration(handler):\n    \"\"\"Decorator to check whether the user can create an exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if a user has permission to create an exploration.\n    \"\"\"\n\n    def test_can_create(self, **kwargs):\n        \"\"\"Checks if the user can create an exploration.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to create an exploration.\n        \"\"\"\n        if self.user_id is None:\n            raise self.NotLoggedInException\n\n        if role_services.ACTION_CREATE_EXPLORATION in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to create an exploration.')\n    test_can_create.__wrapped__ = True\n\n    return test_can_create\n\n\ndef can_create_collection(handler):\n    \"\"\"Decorator to check whether the user can create a collection.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if a user has permission to create a collection.\n    \"\"\"\n\n    def test_can_create(self, **kwargs):\n        \"\"\"Checks if the user can create a collection.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to create a collection.\n        \"\"\"\n        if self.user_id is None:\n            raise self.NotLoggedInException\n\n        if role_services.ACTION_CREATE_COLLECTION in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to create a collection.')\n    test_can_create.__wrapped__ = True\n\n    return test_can_create\n\n\ndef can_access_creator_dashboard(handler):\n    \"\"\"Decorator to check whether the user can access creator dashboard page.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if a\n            user has permission to access the creator dashboard page.\n    \"\"\"\n\n    def test_can_access(self, **kwargs):\n        \"\"\"Checks if the user can access the creator dashboard page.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to access creator dashboard.\n        \"\"\"\n        if self.user_id is None:\n            raise self.NotLoggedInException\n\n        if role_services.ACTION_ACCESS_CREATOR_DASHBOARD in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to access creator dashboard.')\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_create_feedback_thread(handler):\n    \"\"\"Decorator to check whether the user can create a feedback thread.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to create a feedback thread.\n    \"\"\"\n\n    def test_can_access(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can create a feedback thread.\n\n        Args:\n            exploration_id: str. The ID of the exploration where the thread will\n                be created.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to create an exploration feedback.\n        \"\"\"\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to create exploration feedback.')\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_view_feedback_thread(handler):\n    \"\"\"Decorator to check whether the user can view a feedback thread.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to view a feedback thread.\n    \"\"\"\n\n    def test_can_access(self, thread_id, **kwargs):\n        \"\"\"Checks if the user can view a feedback thread.\n\n        Args:\n            thread_id: str. The feedback thread id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            InvalidInputException: The thread ID is not valid.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to view an exploration feedback.\n        \"\"\"\n        if '.' not in thread_id:\n            raise self.InvalidInputException('Thread ID must contain a .')\n\n        exploration_id = feedback_services.get_exp_id_from_thread_id(thread_id)\n\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, thread_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to view exploration feedback.')\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_comment_on_feedback_thread(handler):\n    \"\"\"Decorator to check whether the user can comment on feedback thread.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user has permission to comment on a given feedback\n            thread.\n    \"\"\"\n\n    def test_can_access(self, thread_id, **kwargs):\n        \"\"\"Checks if the user can comment on the feedback thread.\n\n        Args:\n            thread_id: str. The feedback thread id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            InvalidInputException: The thread ID is not valid.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to comment on an exploration feedback.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        if '.' not in thread_id:\n            raise self.InvalidInputException('Thread ID must contain a .')\n\n        exploration_id = feedback_services.get_exp_id_from_thread_id(thread_id)\n\n        if exploration_id in feconf.DISABLED_EXPLORATION_IDS:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if rights_manager.check_can_access_activity(\n                self.user, exploration_rights):\n            return handler(self, thread_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to comment on exploration'\n                ' feedback.')\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_rate_exploration(handler):\n    \"\"\"Decorator to check whether the user can give rating to given\n    exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to rate a given exploration.\n    \"\"\"\n\n    def test_can_rate(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can rate the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to rate an exploration.\n        \"\"\"\n        if (role_services.ACTION_RATE_ANY_PUBLIC_EXPLORATION in\n                self.user.actions):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to give ratings to explorations.')\n    test_can_rate.__wrapped__ = True\n\n    return test_can_rate\n\n\ndef can_flag_exploration(handler):\n    \"\"\"Decorator to check whether user can flag given exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user can flag a given exploration.\n    \"\"\"\n\n    def test_can_flag(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can flag the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to flag an exploration.\n        \"\"\"\n        if role_services.ACTION_FLAG_EXPLORATION in self.user.actions:\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to flag explorations.')\n    test_can_flag.__wrapped__ = True\n\n    return test_can_flag\n\n\ndef can_subscribe_to_users(handler):\n    \"\"\"Decorator to check whether user can subscribe/unsubscribe a creator.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to subscribe/unsubscribe a creator.\n    \"\"\"\n\n    def test_can_subscribe(self, **kwargs):\n        \"\"\"Checks if the user can subscribe/unsubscribe a creator.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to manage subscriptions.\n        \"\"\"\n        if role_services.ACTION_SUBSCRIBE_TO_USERS in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to manage subscriptions.')\n    test_can_subscribe.__wrapped__ = True\n\n    return test_can_subscribe\n\n\ndef can_edit_exploration(handler):\n    \"\"\"Decorator to check whether the user can edit given exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to edit a given exploration.\n    \"\"\"\n\n    def test_can_edit(self, exploration_id, *args, **kwargs):\n        \"\"\"Checks if the user can edit the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            *args: *. Arguments.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to edit an exploration.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n        if exploration_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_edit_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, *args, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to edit this exploration.')\n    test_can_edit.__wrapped__ = True\n\n    return test_can_edit\n\n\ndef can_voiceover_exploration(handler):\n    \"\"\"Decorator to check whether the user can voiceover given exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if a\n            user has permission to voiceover a given exploration.\n    \"\"\"\n\n    def test_can_voiceover(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can voiceover the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: dict(str: *). Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to voiceover an exploration.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n        if exploration_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_voiceover_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to voiceover this exploration.')\n    test_can_voiceover.__wrapped__ = True\n\n    return test_can_voiceover\n\n\ndef can_delete_exploration(handler):\n    \"\"\"Decorator to check whether user can delete exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that checks if\n            a user has permission to delete a given\n            exploration.\n    \"\"\"\n\n    def test_can_delete(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can delete the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                permissions to delete an exploration.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if rights_manager.check_can_delete_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'User %s does not have permissions to delete exploration %s' %\n                (self.user_id, exploration_id))\n    test_can_delete.__wrapped__ = True\n\n    return test_can_delete\n\n\ndef can_suggest_changes_to_exploration(handler):\n    \"\"\"Decorator to check whether a user can make suggestions to an\n    exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to make suggestions to an\n            exploration.\n    \"\"\"\n\n    def test_can_suggest(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can make suggestions to an exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to give suggestions to an exploration.\n        \"\"\"\n        if role_services.ACTION_SUGGEST_CHANGES in self.user.actions:\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to give suggestions to this '\n                'exploration.')\n    test_can_suggest.__wrapped__ = True\n\n    return test_can_suggest\n\n\ndef can_suggest_changes(handler):\n    \"\"\"Decorator to check whether a user can make suggestions.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to make suggestions.\n    \"\"\"\n\n    def test_can_suggest(self, **kwargs):\n        \"\"\"Checks if the user can make suggestions to an exploration.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to make suggestions.\n        \"\"\"\n        if role_services.ACTION_SUGGEST_CHANGES in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to make suggestions.')\n    test_can_suggest.__wrapped__ = True\n\n    return test_can_suggest\n\n\ndef can_resubmit_suggestion(handler):\n    \"\"\"Decorator to check whether a user can resubmit a suggestion.\"\"\"\n\n    def test_can_resubmit_suggestion(self, suggestion_id, **kwargs):\n        \"\"\"Checks if the use can edit the given suggestion.\n\n        Args:\n            suggestion_id: str. The ID of the suggestion.\n            **kwargs: *. keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to edit this suggestion.\n        \"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        if not suggestion:\n            raise self.InvalidInputException(\n                'No suggestion found with given suggestion id')\n\n        if suggestion_services.check_can_resubmit_suggestion(\n                suggestion_id, self.user_id):\n            return handler(self, suggestion_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to resubmit this suggestion.')\n    test_can_resubmit_suggestion.__wrapped__ = True\n\n    return test_can_resubmit_suggestion\n\n\ndef can_publish_exploration(handler):\n    \"\"\"Decorator to check whether user can publish exploration.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also\n            checks if the user has permission to publish an\n            exploration.\n    \"\"\"\n\n    def test_can_publish(self, exploration_id, *args, **kwargs):\n        \"\"\"Checks if the user can publish the exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            *args: arguments.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to publish an exploration.\n        \"\"\"\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if exploration_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_publish_activity(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, *args, **kwargs)\n\n        raise base.UserFacingExceptions.UnauthorizedUserException(\n            'You do not have credentials to publish this exploration.')\n    test_can_publish.__wrapped__ = True\n\n    return test_can_publish\n\n\ndef can_publish_collection(handler):\n    \"\"\"Decorator to check whether user can publish collection.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if a user has permission to publish a collection.\n    \"\"\"\n\n    def test_can_publish_collection(self, collection_id, **kwargs):\n        \"\"\"Checks if the user can publish the collection.\n\n        Args:\n            collection_id: str. The collection id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to publish a collection.\n        \"\"\"\n        collection_rights = rights_manager.get_collection_rights(\n            collection_id, strict=False)\n        if collection_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_publish_activity(\n                self.user, collection_rights):\n            return handler(self, collection_id, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to publish this collection.')\n    test_can_publish_collection.__wrapped__ = True\n\n    return test_can_publish_collection\n\n\ndef can_unpublish_collection(handler):\n    \"\"\"Decorator to check whether user can unpublish a given\n    collection.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that also checks if\n            the user has permission to unpublish a collection.\n    \"\"\"\n\n    def test_can_unpublish_collection(self, collection_id, **kwargs):\n        \"\"\"Checks if the user can unpublish the collection.\n\n        Args:\n            collection_id: str. The collection id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to unpublish a collection.\n        \"\"\"\n        collection_rights = rights_manager.get_collection_rights(\n            collection_id, strict=False)\n        if collection_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if rights_manager.check_can_unpublish_activity(\n                self.user, collection_rights):\n            return handler(self, collection_id, **kwargs)\n\n        raise self.UnauthorizedUserException(\n            'You do not have credentials to unpublish this collection.')\n    test_can_unpublish_collection.__wrapped__ = True\n\n    return test_can_unpublish_collection\n\n\ndef can_modify_exploration_roles(handler):\n    \"\"\"Decorators to check whether user can manage rights related to an\n    exploration.\n\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user has permission to manage rights related to an\n            exploration.\n    \"\"\"\n\n    def test_can_modify(self, exploration_id, **kwargs):\n        \"\"\"Checks if the user can modify the rights related to an exploration.\n\n        Args:\n            exploration_id: str. The exploration id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to change the rights for an exploration.\n        \"\"\"\n        exploration_rights = rights_manager.get_exploration_rights(\n            exploration_id, strict=False)\n\n        if rights_manager.check_can_modify_activity_roles(\n                self.user, exploration_rights):\n            return handler(self, exploration_id, **kwargs)\n        else:\n            raise base.UserFacingExceptions.UnauthorizedUserException(\n                'You do not have credentials to change rights for this '\n                'exploration.')\n    test_can_modify.__wrapped__ = True\n\n    return test_can_modify\n\n\ndef can_perform_cron_tasks(handler):\n    \"\"\"Decorator to ensure that the handler is being called by cron or by a\n    superadmin of the application.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also ensures that\n            the handler can only be executed if it is called by cron or by\n            a superadmin of the application.\n    \"\"\"\n\n    def test_can_perform(self, **kwargs):\n        \"\"\"Checks if the handler is called by cron or by a superadmin of the\n        application.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            UnauthorizedUserException: The user does not have\n                credentials to access the page.\n        \"\"\"\n        if (self.request.headers.get('X-AppEngine-Cron') is None and\n                not self.is_super_admin):\n            raise self.UnauthorizedUserException(\n                'You do not have the credentials to access this page.')\n        else:\n            return handler(self, **kwargs)\n    test_can_perform.__wrapped__ = True\n\n    return test_can_perform\n\n\ndef can_access_learner_dashboard(handler):\n    \"\"\"Decorator to check access to learner dashboard.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            one can access the learner dashboard.\n    \"\"\"\n\n    def test_can_access(self, **kwargs):\n        \"\"\"Checks if the user can access the learner dashboard.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n        \"\"\"\n        if role_services.ACTION_ACCESS_LEARNER_DASHBOARD in self.user.actions:\n            return handler(self, **kwargs)\n        else:\n            raise self.NotLoggedInException\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_manage_question_skill_status(handler):\n    \"\"\"Decorator to check whether the user can publish a question and link it\n    to a skill.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if the\n            given user has permission to publish a question and link it\n            to a skill.\n    \"\"\"\n\n    def test_can_manage_question_skill_status(self, **kwargs):\n        \"\"\"Checks if the user can publish a question directly.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to publish a question.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        if (\n                role_services.ACTION_MANAGE_QUESTION_SKILL_STATUS in\n                self.user.actions):\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to publish a question.')\n    test_can_manage_question_skill_status.__wrapped__ = True\n\n    return test_can_manage_question_skill_status\n\n\ndef require_user_id(handler):\n    \"\"\"Decorator that checks if a user_id is associated to the current\n    session. If not, NotLoggedInException is raised.\n    \"\"\"\n\n    def test_login(self, **kwargs):\n        \"\"\"Checks if the user for the current session is logged in.\n        If not, raises NotLoggedInException.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n        return handler(self, **kwargs)\n    test_login.__wrapped__ = True\n\n    return test_login\n\n\ndef require_user_id_else_redirect_to_homepage(handler):\n    \"\"\"Decorator that checks if a user_id is associated to the current\n    session. If not, the user is redirected to the main page.\n    Note that the user may not yet have registered.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if a given user_id is associated with the current\n            session.\n    \"\"\"\n\n    def test_login(self, **kwargs):\n        \"\"\"Checks if the user for the current session is logged in.\n        If not, redirects the user to the home page.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n        \"\"\"\n        if not self.user_id:\n            self.redirect('/')\n            return\n        return handler(self, **kwargs)\n    test_login.__wrapped__ = True\n\n    return test_login\n\n\ndef can_edit_topic(handler):\n    \"\"\"Decorator to check whether the user can edit given topic.\"\"\"\n\n    def test_can_edit(self, topic_id, *args, **kwargs):\n        \"\"\"Checks whether the user can edit a given topic.\n\n        Args:\n            topic_id: str. The topic id.\n            *args: arguments.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to edit a topic.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        topic_rights = topic_services.get_topic_rights(topic_id, strict=False)\n        if topic_rights is None or topic is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if topic_services.check_can_edit_topic(self.user, topic_rights):\n            return handler(self, topic_id, *args, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this topic.')\n    test_can_edit.__wrapped__ = True\n\n    return test_can_edit\n\n\ndef can_edit_question(handler):\n    \"\"\"Decorator to check whether the user can edit given question.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            whether the user has permission to edit a given question.\n    \"\"\"\n\n    def test_can_edit(self, question_id, **kwargs):\n        \"\"\"Checks whether the user can edit the given question.\n\n        Args:\n            question_id: str. The question id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to edit a question.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        question_rights = question_services.get_question_rights(\n            question_id, strict=False)\n\n        if question_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if (\n                role_services.ACTION_EDIT_ANY_QUESTION in self.user.actions or\n                question_rights.is_creator(self.user_id)):\n            return handler(self, question_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this question.')\n    test_can_edit.__wrapped__ = True\n\n    return test_can_edit\n\n\ndef can_view_question_editor(handler):\n    \"\"\"Decorator to check whether the user can view any question editor.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to view any question editor.\n    \"\"\"\n\n    def test_can_view_question_editor(self, question_id, **kwargs):\n        \"\"\"Checks whether the user can view the question editor.\n\n        Args:\n            question_id: str. The question id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                enough rights to access the question editor.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        question_rights = question_services.get_question_rights(\n            question_id, strict=False)\n\n        if question_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if (\n                role_services.ACTION_VISIT_ANY_QUESTION_EDITOR in\n                self.user.actions or question_rights.is_creator(self.user_id)):\n            return handler(self, question_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to access the questions editor'\n                % self.user_id)\n    test_can_view_question_editor.__wrapped__ = True\n\n    return test_can_view_question_editor\n\n\ndef can_delete_question(handler):\n    \"\"\"Decorator to check whether the user can delete a question.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to delete a question.\n    \"\"\"\n\n    def test_can_delete_question(self, question_id, **kwargs):\n        \"\"\"Checks whether the user can delete a given question.\n\n        Args:\n            question_id: str. The question id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to delete the question.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if (role_services.ACTION_DELETE_ANY_QUESTION in\n                user_actions_info.actions):\n            return handler(self, question_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to delete the'\n                ' question.' % self.user_id)\n    test_can_delete_question.__wrapped__ = True\n\n    return test_can_delete_question\n\n\ndef can_add_new_story_to_topic(handler):\n    \"\"\"Decorator to check whether the user can add a story to a given topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user has permission to add a story to a given topic.\n    \"\"\"\n\n    def test_can_add_story(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can add a story to\n        a given topic.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to add a story to a given topic.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        topic_rights = topic_services.get_topic_rights(topic_id, strict=False)\n        if topic_rights is None or topic is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if topic_services.check_can_edit_topic(self.user, topic_rights):\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to add a story to this topic.')\n    test_can_add_story.__wrapped__ = True\n\n    return test_can_add_story\n\n\ndef can_edit_story(handler):\n    \"\"\"Decorator to check whether the user can edit a story belonging to a given\n    topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            a user has permission to edit a story for a given topic.\n    \"\"\"\n\n    def test_can_edit_story(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can edit a story belonging to\n        a given topic.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to edit a story belonging to a\n                given topic.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        topic_rights = topic_services.get_topic_rights(topic_id, strict=False)\n        if topic_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if topic_services.check_can_edit_topic(self.user, topic_rights):\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this story.')\n    test_can_edit_story.__wrapped__ = True\n\n    return test_can_edit_story\n\n\ndef can_edit_skill(handler):\n    \"\"\"Decorator to check whether the user can edit a skill, which can be\n    independent or belong to a topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user has permission to edit a skill.\n    \"\"\"\n    def test_can_edit_skill(self, skill_id, **kwargs):\n        \"\"\"Test to see if user can edit a given skill by checking if\n        logged in and using can_user_edit_skill.\n\n        Args:\n            skill_id: str. The skill ID.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The given page cannot be found.\n            UnauthorizedUserException: The user does not have the\n                credentials to edit the given skill.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        skill_rights = skill_services.get_skill_rights(skill_id, strict=False)\n        if skill_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if role_services.ACTION_EDIT_PUBLIC_SKILLS in self.user.actions:\n            if not skill_rights.is_private():\n                return handler(self, skill_id, **kwargs)\n            elif skill_rights.is_private() and skill_rights.is_creator(\n                    self.user.user_id):\n                return handler(self, skill_id, **kwargs)\n            else:\n                raise self.UnauthorizedUserException(\n                    'You do not have credentials to edit this skill.')\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this skill.')\n\n    test_can_edit_skill.__wrapped__ = True\n    return test_can_edit_skill\n\n\ndef can_delete_skill(handler):\n    \"\"\"Decorator to check whether the user can delete a skill.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            if the user can delete a skill.\n    \"\"\"\n\n    def test_can_delete_skill(self, **kwargs):\n        \"\"\"Checks whether the user can delete a skill.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to delete a skill.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n        if role_services.ACTION_DELETE_ANY_SKILL in user_actions_info.actions:\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to delete the skill.')\n\n    test_can_delete_skill.__wrapped__ = True\n    return test_can_delete_skill\n\n\ndef can_create_skill(handler):\n    \"\"\"Decorator to check whether the user can create a skill, which can be\n    independent or added to a topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks if\n            the user has permission to create a skill.\n    \"\"\"\n    def test_can_create_skill(self, **kwargs):\n        \"\"\"Checks whether the user can create a skill, which can be\n        independent or belong to a topic.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                credentials to create a skill.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n        if role_services.ACTION_CREATE_NEW_SKILL in user_actions_info.actions:\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to create a skill.')\n\n    test_can_create_skill.__wrapped__ = True\n    return test_can_create_skill\n\n\ndef can_publish_skill(handler):\n    \"\"\"Decorator to check whether the user can publish a skill.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also\n            checks whether the user has permission to publish\n            a skill.\n    \"\"\"\n    def test_can_publish_skill(self, skill_id, **kwargs):\n        \"\"\"Tests whether the user can publish a given skill by checking\n        if the user is logged in and using can_user_publish_skill.\n\n        Args:\n            skill_id: str. The skill ID.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the desired function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The given page cannot be found.\n            UnauthorizedUserException: The given user does not have\n                credentials to publish the given skill.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        skill_rights = skill_services.get_skill_rights(skill_id, strict=False)\n        if skill_rights is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if role_services.ACTION_PUBLISH_OWNED_SKILL not in self.user.actions:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this skill.')\n        elif skill_rights.is_creator(self.user.user_id):\n            return handler(self, skill_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to edit this skill.')\n\n    test_can_publish_skill.__wrapped__ = True\n\n    return test_can_publish_skill\n\n\ndef can_delete_story(handler):\n    \"\"\"Decorator to check whether the user can delete a story in a given\n    topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also checks\n            whether the user has permission to delete a story in a\n            given topic.\n    \"\"\"\n\n    def test_can_delete_story(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can delete a story in\n        a given topic.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            PageNotFoundException: The page is not found.\n            UnauthorizedUserException: The user does not have\n                credentials to delete a story.\n        \"\"\"\n        if not self.user_id:\n            raise base.UserFacingExceptions.NotLoggedInException\n\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        topic_rights = topic_services.get_topic_rights(topic_id, strict=False)\n        if topic_rights is None or topic is None:\n            raise base.UserFacingExceptions.PageNotFoundException\n\n        if topic_services.check_can_edit_topic(self.user, topic_rights):\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                'You do not have credentials to delete this story.')\n    test_can_delete_story.__wrapped__ = True\n\n    return test_can_delete_story\n\n\ndef can_delete_topic(handler):\n    \"\"\"Decorator to check whether the user can delete a topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now also\n            checks if the user can delete a given topic.\n    \"\"\"\n\n    def test_can_delete_topic(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can delete a given topic.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to delete a given topic.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if role_services.ACTION_DELETE_TOPIC in user_actions_info.actions:\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to delete the'\n                ' topic.' % self.user_id)\n    test_can_delete_topic.__wrapped__ = True\n\n    return test_can_delete_topic\n\n\ndef can_create_topic(handler):\n    \"\"\"Decorator to check whether the user can create a topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that also checks\n            if the user can create a topic.\n    \"\"\"\n\n    def test_can_create_topic(self, **kwargs):\n        \"\"\"Checks whether the user can create a topic.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to create a topic.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if role_services.ACTION_CREATE_NEW_TOPIC in user_actions_info.actions:\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to create a'\n                ' topic.' % self.user_id)\n    test_can_create_topic.__wrapped__ = True\n\n    return test_can_create_topic\n\n\ndef can_access_topics_and_skills_dashboard(handler):\n    \"\"\"Decorator to check whether the user can access the topics and skills\n    dashboard.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that also checks if\n            the user can access the topics and skills dashboard.\n    \"\"\"\n\n    def test_can_access_topics_and_skills_dashboard(self, **kwargs):\n        \"\"\"Checks whether the user can access the topics and skills\n        dashboard.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to access the topics and skills\n                dashboard.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if (\n                role_services.ACTION_ACCESS_TOPICS_AND_SKILLS_DASHBOARD in\n                user_actions_info.actions):\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to access the topics and skills'\n                ' dashboard.' % self.user_id)\n    test_can_access_topics_and_skills_dashboard.__wrapped__ = True\n\n    return test_can_access_topics_and_skills_dashboard\n\n\ndef can_view_any_topic_editor(handler):\n    \"\"\"Decorator to check whether the user can view any topic editor.\n\n    Args:\n        handler: function. The newly decorated function.\n\n    Returns:\n        function. The newly decorated function that also checks\n            if the user can view any topic editor.\n    \"\"\"\n\n    def test_can_view_any_topic_editor(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can view any topic editor.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to view any topic editor.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n        topic_domain.Topic.require_valid_topic_id(topic_id)\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if (\n                role_services.ACTION_VISIT_ANY_TOPIC_EDITOR in\n                user_actions_info.actions):\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to view any topic editor.'\n                % self.user_id)\n    test_can_view_any_topic_editor.__wrapped__ = True\n\n    return test_can_view_any_topic_editor\n\n\ndef can_manage_rights_for_topic(handler):\n    \"\"\"Decorator to check whether the user can manage a topic's rights.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that also checks\n            if the user can manage a given topic's rights.\n    \"\"\"\n\n    def test_can_manage_topic_rights(self, topic_id, **kwargs):\n        \"\"\"Checks whether the user can manage a topic's rights.\n\n        Args:\n            topic_id: str. The topic id.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to assign roles for a given topic.\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if (\n                role_services.ACTION_MANAGE_TOPIC_RIGHTS in\n                user_actions_info.actions):\n            return handler(self, topic_id, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to assign roles for the '\n                'topic.' % self.user_id)\n    test_can_manage_topic_rights.__wrapped__ = True\n\n    return test_can_manage_topic_rights\n\n\ndef can_change_topic_publication_status(handler):\n    \"\"\"Decorator to check whether the user can publish or unpublish a topic.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user can publish or unpublish a topic.\n    \"\"\"\n\n    def test_can_change_topic_publication_status(self, **kwargs):\n        \"\"\"Checks whether the user can can publish or unpublish a topic.\n\n        Args:\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n            UnauthorizedUserException: The user does not have\n                enough rights to publish or unpublish the topic..\n        \"\"\"\n        if not self.user_id:\n            raise self.NotLoggedInException\n\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n\n        if (\n                role_services.ACTION_CHANGE_TOPIC_STATUS in\n                user_actions_info.actions):\n            return handler(self, **kwargs)\n        else:\n            raise self.UnauthorizedUserException(\n                '%s does not have enough rights to publish or unpublish the '\n                'topic.' % self.user_id)\n    test_can_change_topic_publication_status.__wrapped__ = True\n\n    return test_can_change_topic_publication_status\n\n\ndef can_access_topic_viewer_page(handler):\n    \"\"\"Decorator to check whether user can access topic viewer page.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user can access the given topic viewer page.\n    \"\"\"\n\n    def test_can_access(self, topic_name, **kwargs):\n        \"\"\"Checks if the user can access topic viewer page.\n\n        Args:\n            topic_name: str. The name of the topic.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The given page cannot be found.\n        \"\"\"\n        topic_name = urllib.unquote_plus(topic_name)\n        topic = topic_services.get_topic_by_name(topic_name)\n\n        if topic is None:\n            raise self.PageNotFoundException\n\n        topic_id = topic.id\n        topic_rights = topic_services.get_topic_rights(\n            topic_id, strict=False)\n\n        if topic_rights.topic_is_published:\n            return handler(self, topic_name, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_access_story_viewer_page(handler):\n    \"\"\"Decorator to check whether user can access story viewer page.\n\n    Args:\n        handler: function.  The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user can access the given story viewer page.\n    \"\"\"\n\n    def test_can_access(self, story_id, **kwargs):\n        \"\"\"Checks if the user can access story viewer page.\n\n        Args:\n            story_id: str. The unique id of the story.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of the decorated function.\n\n        Raises:\n            PageNotFoundException: The given page cannot be found.\n        \"\"\"\n        story = story_services.get_story_by_id(story_id, strict=False)\n\n        if story is None:\n            raise self.PageNotFoundException\n\n        story_rights = story_services.get_story_rights(\n            story_id, strict=False)\n\n        if story_rights.story_is_published:\n            return handler(self, story_id, **kwargs)\n        else:\n            raise self.PageNotFoundException\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef can_access_subtopic_viewer_page(handler):\n    \"\"\"Decorator to check whether user can access subtopic page viewer.\n\n    Args:\n        handler: function. The function to be decorated.\n\n    Returns:\n        function. The newly decorated function that now checks\n            if the user can access the give subtopic viewer page.\n    \"\"\"\n\n    def test_can_access(self, topic_id, subtopic_id, **kwargs):\n        \"\"\"Checks if the user can access subtopic viewer page.\n\n        Args:\n            topic_id: str. The id of the topic.\n            subtopic_id: str. The id of the Subtopic.\n            **kwargs: *. Keyword arguments.\n\n        Returns:\n            *. The return value of decorated function.\n\n        Raises:\n            PageNotFoundException: The given page cannot be found.\n        \"\"\"\n        subtopic_page = subtopic_page_services.get_subtopic_page_by_id(\n            topic_id, subtopic_id, strict=False)\n        if subtopic_page is None:\n            raise self.PageNotFoundException\n        else:\n            return handler(self, topic_id, subtopic_id, **kwargs)\n    test_can_access.__wrapped__ = True\n\n    return test_can_access\n\n\ndef get_decorator_for_accepting_suggestion(decorator):\n    \"\"\"Function that takes a decorator as an argument and then applies some\n    common checks and then checks the permissions specified by the passed in\n    decorator.\n\n    Args:\n        decorator: function. The decorator to be used to verify permissions\n            for accepting/rejecting suggestions.\n\n    Returns:\n        function. The new decorator which includes all the permission checks for\n            accepting/rejecting suggestions. These permissions include:\n            - Admins can accept/reject any suggestion.\n            - Users with scores above threshold can accept/reject any suggestion\n            in that category.\n            - Any user with edit permissions to the target entity can\n            accept/reject suggestions for that entity.\n    \"\"\"\n    def generate_decorator_for_handler(handler):\n        \"\"\"Function that generates a decorator for a given handler.\n\n        Args:\n            handler: function. The function to be decorated.\n\n        Returns:\n            function. The newly decorated function that has common\n                checks and permissions specified by passed in\n                decorator.\n\n        Raises:\n            NotLoggedInException: The user is not logged in.\n        \"\"\"\n        def test_can_accept_suggestion(\n                self, target_id, suggestion_id, **kwargs):\n            \"\"\"Returns a (possibly-decorated) handler to test whether a\n            suggestion can be accepted based on the user actions and roles.\n\n            Args:\n                target_id: str. The target id.\n                suggestion_id: str. The suggestion id.\n                **kwargs: *. Keyword arguments.\n\n            Returns:\n                function. The (possibly-decorated) handler for accepting a\n                    suggestion.\n\n            Raises:\n                NotLoggedInException: The user is not logged in.\n            \"\"\"\n            if not self.user_id:\n                raise base.UserFacingExceptions.NotLoggedInException\n            user_actions_info = user_services.UserActionsInfo(self.user_id)\n            if (\n                    role_services.ACTION_ACCEPT_ANY_SUGGESTION in\n                    user_actions_info.actions):\n                return handler(self, target_id, suggestion_id, **kwargs)\n\n            if len(suggestion_id.split('.')) != 3:\n                raise self.InvalidInputException(\n                    'Invalid format for suggestion_id.'\n                    ' It must contain 3 parts separated by \\'.\\'')\n\n            suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n\n            if suggestion is None:\n                raise self.PageNotFoundException\n\n            if suggestion_services.check_user_can_review_in_category(\n                    self.user_id, suggestion.score_category):\n                return handler(self, target_id, suggestion_id, **kwargs)\n\n            return decorator(handler)(self, target_id, suggestion_id, **kwargs)\n\n        test_can_accept_suggestion.__wrapped__ = True\n        return test_can_accept_suggestion\n\n    return generate_decorator_for_handler\n"
    },
    {
      "filename": "core/controllers/acl_decorators_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2017 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for core.domain.acl_decorators.\"\"\"\n\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.domain import question_services\nfrom core.domain import rights_manager\nfrom core.domain import skill_services\nfrom core.domain import suggestion_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.tests import test_utils\nimport feconf\n\nimport webapp2\nimport webtest\n\n\nclass PlayExplorationDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests for play exploration decorator.\"\"\"\n    user_email = 'user@example.com'\n    username = 'user'\n    published_exp_id = 'exp_id_1'\n    private_exp_id = 'exp_id_2'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id):\n            return self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(PlayExplorationDecoratorTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_can_not_access_exploration_with_disabled_exploration_ids(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_exploration/%s'\n                % (feconf.DISABLED_EXPLORATION_IDS[0]), expected_status_int=404)\n\n    def test_guest_can_access_published_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.published_exp_id)\n        self.assertEqual(response['exploration_id'], self.published_exp_id)\n\n    def test_guest_cannot_access_private_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_exploration/%s' % self.private_exp_id,\n                expected_status_int=404)\n\n    def test_admin_can_access_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_owner_can_access_private_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_logged_in_user_cannot_access_not_owned_exploration(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_exploration/%s' % self.private_exp_id,\n                expected_status_int=404)\n        self.logout()\n\n\nclass PlayCollectionDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests for play collection decorator.\"\"\"\n    user_email = 'user@example.com'\n    username = 'user'\n    published_exp_id = 'exp_id_1'\n    private_exp_id = 'exp_id_2'\n    published_col_id = 'col_id_1'\n    private_col_id = 'col_id_2'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_play_collection\n        def get(self, collection_id):\n            return self.render_json({'collection_id': collection_id})\n\n    def setUp(self):\n        super(PlayCollectionDecoratorTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_collection/<collection_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        self.save_new_valid_collection(\n            self.published_col_id, self.owner_id,\n            exploration_id=self.published_col_id)\n        self.save_new_valid_collection(\n            self.private_col_id, self.owner_id,\n            exploration_id=self.private_col_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n        rights_manager.publish_collection(self.owner, self.published_col_id)\n\n    def test_guest_can_access_published_collection(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_collection/%s' % self.published_col_id)\n        self.assertEqual(response['collection_id'], self.published_col_id)\n\n    def test_guest_cannot_access_private_collection(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_collection/%s' % self.private_col_id,\n                expected_status_int=404)\n\n    def test_admin_can_access_private_collection(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n    def test_owner_can_access_private_collection(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_play_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n    def test_logged_in_user_cannot_access_not_owned_private_collection(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_collection/%s' % self.private_col_id,\n                expected_status_int=404)\n        self.logout()\n\n    def test_cannot_access_collection_with_invalid_collection_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_play_collection/invalid_collection_id',\n                expected_status_int=404)\n        self.logout()\n\n\nclass EditCollectionDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_edit_collection decorator.\"\"\"\n    user_email = 'user@example.com'\n    username = 'user'\n    published_exp_id = 'exp_id_1'\n    private_exp_id = 'exp_id_2'\n    published_col_id = 'col_id_1'\n    private_col_id = 'col_id_2'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_edit_collection\n        def get(self, collection_id):\n            return self.render_json({'collection_id': collection_id})\n\n    def setUp(self):\n        super(EditCollectionDecoratorTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_collection_editors([self.OWNER_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_edit_collection/<collection_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        self.save_new_valid_collection(\n            self.published_col_id, self.owner_id,\n            exploration_id=self.published_col_id)\n        self.save_new_valid_collection(\n            self.private_col_id, self.owner_id,\n            exploration_id=self.private_col_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n        rights_manager.publish_collection(self.owner, self.published_col_id)\n\n    def test_can_not_edit_collection_with_invalid_collection_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_collection/invalid_col_id', expected_status_int=404)\n        self.logout()\n\n    def test_guest_cannot_edit_collection_via_json_handler(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_collection/%s' % self.published_col_id,\n                expected_status_int=401)\n\n    def test_guest_is_redirected_when_using_html_handler(self):\n        with self.swap(\n            self.MockHandler, 'GET_HANDLER_ERROR_RETURN_TYPE',\n            feconf.HANDLER_TYPE_HTML):\n            response = self.mock_testapp.get(\n                '/mock_edit_collection/%s' % self.published_col_id,\n                expect_errors=True)\n        self.assertEqual(response.status_int, 302)\n\n    def test_normal_user_cannot_edit_collection(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_collection/%s' % self.private_col_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_owner_can_edit_owned_collection(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n    def test_moderator_cannot_edit_private_collection(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_collection/%s' % self.private_col_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_moderator_can_edit_public_collection(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_collection/%s' % self.published_col_id)\n        self.assertEqual(response['collection_id'], self.published_col_id)\n        self.logout()\n\n    def test_admin_can_edit_any_private_collection(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n\nclass CreateExplorationDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_create_exploration decorator.\"\"\"\n    username = 'banneduser'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_create_exploration\n        def get(self):\n            self.render_json({'success': True})\n\n    def setUp(self):\n        super(CreateExplorationDecoratorTests, self).setUp()\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.set_banned_users([self.username])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/create', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_cannot_create_exploration(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/create', expected_status_int=401)\n        self.logout()\n\n    def test_normal_user_can_create_exploration(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/create')\n        self.assertEqual(response['success'], True)\n        self.logout()\n\n    def test_guest_cannot_create_exploration_via_json_handler(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/create', expected_status_int=401)\n\n    def test_guest_is_redirected_when_using_html_handler(self):\n        with self.swap(\n            self.MockHandler, 'GET_HANDLER_ERROR_RETURN_TYPE',\n            feconf.HANDLER_TYPE_HTML):\n            response = self.mock_testapp.get('/mock/create', expect_errors=True)\n        self.assertEqual(response.status_int, 302)\n\n\nclass CreateCollectionDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_create_collection decorator.\"\"\"\n    username = 'collectioneditor'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_create_collection\n        def get(self):\n            self.render_json({'success': True})\n\n    def setUp(self):\n        super(CreateCollectionDecoratorTests, self).setUp()\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_collection_editors([self.username])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/create', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_guest_cannot_create_collection_via_json_handler(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/create', expected_status_int=401)\n\n    def test_guest_is_redirected_when_using_html_handler(self):\n        with self.swap(\n            self.MockHandler, 'GET_HANDLER_ERROR_RETURN_TYPE',\n            feconf.HANDLER_TYPE_HTML):\n            response = self.mock_testapp.get('/mock/create', expect_errors=True)\n        self.assertEqual(response.status_int, 302)\n\n    def test_normal_user_cannot_create_collection(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/create', expected_status_int=401)\n        self.logout()\n\n    def test_collection_editor_can_create_collection(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/create')\n        self.assertEqual(response['success'], True)\n        self.logout()\n\n    def test_admins_can_create_collection(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/create')\n        self.assertEqual(response['success'], True)\n        self.logout()\n\n\nclass AccessCreatorDashboardTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_access_creator_dashboard decorator.\"\"\"\n    username = 'banneduser'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_access_creator_dashboard\n        def get(self):\n            self.render_json({'success': True})\n\n    def setUp(self):\n        super(AccessCreatorDashboardTests, self).setUp()\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.set_banned_users([self.username])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/access', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_cannot_access_editor_dashboard(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/access', expected_status_int=401)\n        self.logout()\n\n    def test_normal_user_can_access_editor_dashboard(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/access')\n        self.assertEqual(response['success'], True)\n\n\nclass CommentOnFeedbackThreadTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_comment_on_feedback_thread decorator.\"\"\"\n    published_exp_id = 'exp_0'\n    private_exp_id = 'exp_1'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_comment_on_feedback_thread\n        def get(self, thread_id):\n            self.render_json({'thread_id': thread_id})\n\n    def setUp(self):\n        super(CommentOnFeedbackThreadTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_comment_on_feedback_thread/<thread_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_can_not_comment_on_feedback_threads_with_disabled_exp_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % feconf.DISABLED_EXPLORATION_IDS[0],\n                expected_status_int=404)\n        self.logout()\n\n    def test_viewer_cannot_comment_on_feedback_for_private_exploration(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % self.private_exp_id, expected_status_int=401)\n            self.assertEqual(\n                response['error'], 'You do not have credentials to comment on '\n                'exploration feedback.')\n        self.logout()\n\n    def test_can_not_comment_on_feedback_threads_with_invalid_thread_id(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_comment_on_feedback_thread/invalid_thread_id',\n                expected_status_int=400)\n            self.assertEqual(response['error'], 'Thread ID must contain a .')\n        self.logout()\n\n    def test_guest_cannot_comment_on_feedback_threads_via_json_handler(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id), expected_status_int=401)\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.published_exp_id), expected_status_int=401)\n\n    def test_guest_is_redirected_when_using_html_handler(self):\n        with self.swap(\n            self.MockHandler, 'GET_HANDLER_ERROR_RETURN_TYPE',\n            feconf.HANDLER_TYPE_HTML):\n            response = self.mock_testapp.get(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id), expect_errors=True)\n            self.assertEqual(response.status_int, 302)\n            response = self.mock_testapp.get(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.published_exp_id), expect_errors=True)\n            self.assertEqual(response.status_int, 302)\n\n    def test_owner_can_comment_on_feedback_for_private_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id))\n        self.logout()\n\n    def test_moderator_can_comment_on_feeback_for_public_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.published_exp_id))\n        self.logout()\n\n    def test_admin_can_comment_on_feeback_for_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_comment_on_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id))\n        self.logout()\n\n\nclass CreateFeedbackThreadTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_create_feedback_thread decorator.\"\"\"\n    published_exp_id = 'exp_0'\n    private_exp_id = 'exp_1'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_create_feedback_thread\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(CreateFeedbackThreadTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_create_feedback_thread/<exploration_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_can_not_create_feedback_threads_with_disabled_exp_id(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_create_feedback_thread/%s'\n                % (feconf.DISABLED_EXPLORATION_IDS[0]), expected_status_int=404)\n\n    def test_viewer_cannot_create_feedback_for_private_exploration(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_create_feedback_thread/%s' % self.private_exp_id,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'], 'You do not have credentials to create '\n                'exploration feedback.')\n        self.logout()\n\n    def test_guest_can_create_feedback_threads_for_public_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_create_feedback_thread/%s' % self.published_exp_id)\n\n    def test_owner_cannot_create_feedback_for_private_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_create_feedback_thread/%s' % self.private_exp_id)\n        self.logout()\n\n    def test_moderator_can_create_feeback_for_public_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_create_feedback_thread/%s' % self.published_exp_id)\n        self.logout()\n\n    def test_admin_can_create_feeback_for_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_create_feedback_thread/%s' % self.private_exp_id)\n        self.logout()\n\n\nclass ViewFeedbackThreadTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_view_feedback_thread decorator.\"\"\"\n    published_exp_id = 'exp_0'\n    private_exp_id = 'exp_1'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_view_feedback_thread\n        def get(self, thread_id):\n            self.render_json({'thread_id': thread_id})\n\n    def setUp(self):\n        super(ViewFeedbackThreadTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_view_feedback_thread/<thread_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_can_not_view_feedback_threads_with_disabled_exp_id(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % feconf.DISABLED_EXPLORATION_IDS[0],\n                expected_status_int=404)\n\n    def test_viewer_cannot_view_feedback_for_private_exploration(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % self.private_exp_id, expected_status_int=401)\n            self.assertEqual(\n                response['error'], 'You do not have credentials to view '\n                'exploration feedback.')\n        self.logout()\n\n    def test_guest_can_view_feedback_threads_for_public_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % (self.published_exp_id))\n\n    def test_owner_cannot_view_feedback_for_private_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id))\n        self.logout()\n\n    def test_moderator_can_view_feeback_for_public_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % (self.published_exp_id))\n        self.logout()\n\n    def test_admin_can_view_feeback_for_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_view_feedback_thread/exploration.%s.thread1'\n                % (self.private_exp_id))\n        self.logout()\n\n\nclass ManageEmailDashboardTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_manage_email_dashboard decorator.\"\"\"\n    query_id = 'query_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_manage_email_dashboard\n        def get(self):\n            return self.render_json({'success': 1})\n\n        @acl_decorators.can_manage_email_dashboard\n        def put(self, query_id):\n            return self.render_json({'query_id': query_id})\n\n    def setUp(self):\n\n        super(ManageEmailDashboardTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [\n                webapp2.Route('/mock/', self.MockHandler),\n                webapp2.Route('/mock/<query_id>', self.MockHandler)\n            ],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_moderator_cannot_access_email_dashboard(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_access_email_dashboard(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/')\n        self.assertEqual(response['success'], 1)\n\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.mock_testapp.put('/mock/%s' % self.query_id)\n        self.assertEqual(response.status_int, 200)\n        self.logout()\n\n\nclass RateExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_rate_exploration decorator.\"\"\"\n    username = 'user'\n    user_email = 'user@example.com'\n    exp_id = 'exp_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_rate_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(RateExplorationTests, self).setUp()\n        self.signup(self.user_email, self.username)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_guest_cannot_give_rating(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.exp_id, expected_status_int=401)\n\n    def test_normal_user_can_give_rating(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.exp_id)\n        self.assertEqual(response['exploration_id'], self.exp_id)\n        self.logout()\n\n\nclass AccessModeratorPageTests(test_utils.GenericTestBase):\n    username = 'user'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_access_moderator_page\n        def get(self):\n            return self.render_json({'success': 1})\n\n    def setUp(self):\n        super(AccessModeratorPageTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_normal_user_cannot_access_moderator_page(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_access_moderator_page(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/')\n        self.assertEqual(response['success'], 1)\n        self.logout()\n\n\nclass FlagExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_flag_exploration decorator.\"\"\"\n    username = 'user'\n    user_email = 'user@example.com'\n    exp_id = 'exp_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_flag_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(FlagExplorationTests, self).setUp()\n        self.signup(self.user_email, self.username)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_guest_cannot_flag_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.exp_id, expected_status_int=401)\n\n    def test_normal_user_can_flag_exploration(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.exp_id)\n        self.assertEqual(response['exploration_id'], self.exp_id)\n        self.logout()\n\n\nclass SubscriptionToUsersTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_subscribe_to_users decorator.\"\"\"\n    username = 'user'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_subscribe_to_users\n        def get(self):\n            self.render_json({'success': True})\n\n    def setUp(self):\n        super(SubscriptionToUsersTests, self).setUp()\n        self.signup(self.user_email, self.username)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_guest_cannot_subscribe_to_users(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n\n    def test_normal_user_can_subscribe_to_users(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/')\n        self.assertEqual(response['success'], True)\n        self.logout()\n\n\nclass SendModeratorEmailsTests(test_utils.GenericTestBase):\n\n    username = 'user'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_send_moderator_emails\n        def get(self):\n            return self.render_json({'success': 1})\n\n    def setUp(self):\n        super(SendModeratorEmailsTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_normal_user_cannot_send_moderator_emails(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_send_moderator_emails(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/')\n        self.assertEqual(response['success'], 1)\n        self.logout()\n\n\nclass VoiceoverExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_voiceover_exploration decorator.\"\"\"\n    role = rights_manager.ROLE_VOICE_ARTIST\n    username = 'user'\n    user_email = 'user@example.com'\n    banned_username = 'banneduser'\n    banned_user_email = 'banneduser@example.com'\n    published_exp_id_1 = 'exp_1'\n    published_exp_id_2 = 'exp_2'\n    private_exp_id_1 = 'exp_3'\n    private_exp_id_2 = 'exp_4'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_voiceover_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(VoiceoverExplorationTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.signup(self.banned_user_email, self.banned_username)\n        self.signup(self.VOICE_ARTIST_EMAIL, self.VOICE_ARTIST_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.voice_artist_id = self.get_user_id_from_email(\n            self.VOICE_ARTIST_EMAIL)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_banned_users([self.banned_username])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id_1, self.owner_id)\n        self.save_new_valid_exploration(\n            self.published_exp_id_2, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id_1, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id_2, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id_1)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id_2)\n\n        rights_manager.assign_role_for_exploration(\n            self.owner, self.published_exp_id_1, self.voice_artist_id,\n            self.role)\n        rights_manager.assign_role_for_exploration(\n            self.owner, self.private_exp_id_1, self.voice_artist_id, self.role)\n\n    def test_banned_user_cannot_voiceover_exploration(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.private_exp_id_1, expected_status_int=401)\n        self.logout()\n\n    def test_owner_can_voiceover_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.private_exp_id_1)\n        self.assertEqual(response['exploration_id'], self.private_exp_id_1)\n        self.logout()\n\n    def test_moderator_can_voiceover_public_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.published_exp_id_1)\n        self.assertEqual(response['exploration_id'], self.published_exp_id_1)\n        self.logout()\n\n    def test_moderator_cannot_voiceover_private_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.private_exp_id_1, expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_voiceover_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.private_exp_id_1)\n        self.assertEqual(response['exploration_id'], self.private_exp_id_1)\n        self.logout()\n\n    def test_voice_artist_can_only_voiceover_assigned_public_exploration(self):\n        self.login(self.VOICE_ARTIST_EMAIL)\n        # Checking voice artist can voiceover assigned public exploration.\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.published_exp_id_1)\n        self.assertEqual(response['exploration_id'], self.published_exp_id_1)\n\n        # Checking voice artist cannot voiceover public exploration which he/she\n        # is not assigned for.\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.published_exp_id_2, expected_status_int=401)\n        self.logout()\n\n    def test_voice_artist_can_only_voiceover_assigned_private_exploration(self):\n        self.login(self.VOICE_ARTIST_EMAIL)\n        # Checking voice artist can voiceover assigned private exploration.\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.private_exp_id_1)\n        self.assertEqual(response['exploration_id'], self.private_exp_id_1)\n\n        # Checking voice artist cannot voiceover private exploration which\n        # he/she is not assigned for.\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.private_exp_id_2, expected_status_int=401)\n        self.logout()\n\n    def test_user_without_voice_artist_role_of_exploration_cannot_voiceover_public_exploration(self): # pylint: disable=line-too-long\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.published_exp_id_1, expected_status_int=401)\n        self.logout()\n\n    def test_user_without_voice_artist_role_of_exploration_cannot_voiceover_private_exploration(self): # pylint: disable=line-too-long\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.private_exp_id_1, expected_status_int=401)\n        self.logout()\n\n\nclass EditExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_edit_exploration decorator.\"\"\"\n    username = 'banneduser'\n    user_email = 'user@example.com'\n    published_exp_id = 'exp_0'\n    private_exp_id = 'exp_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_edit_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(EditExplorationTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_banned_users([self.username])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_edit_exploration/<exploration_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_can_not_edit_exploration_with_invalid_exp_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_exploration/invalid_exp_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_banned_user_cannot_edit_exploration(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_exploration/%s' % self.private_exp_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_owner_can_edit_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_moderator_can_edit_public_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_exploration/%s' % self.published_exp_id)\n        self.assertEqual(response['exploration_id'], self.published_exp_id)\n        self.logout()\n\n    def test_moderator_cannot_edit_private_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_exploration/%s' % self.private_exp_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_edit_private_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n\nclass ManageOwnProfileTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_manage_own_profile.\"\"\"\n\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n    username = 'user'\n    user_email = 'user@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_manage_own_profile\n        def get(self):\n            return self.render_json({'success': 1})\n\n    def setUp(self):\n        super(ManageOwnProfileTests, self).setUp()\n        self.signup(self.banned_user_email, self.banned_user)\n        self.signup(self.user_email, self.username)\n        self.set_banned_users([self.banned_user])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_cannot_update_preferences(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n        self.logout()\n\n    def test_normal_user_can_manage_preferences(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/')\n        self.assertEqual(response['success'], 1)\n        self.logout()\n\n\nclass UploadExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_upload_exploration decorator.\"\"\"\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_upload_exploration\n        def get(self):\n            return self.render_json({})\n\n    def setUp(self):\n        super(UploadExplorationTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_upload_exploration/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_super_admin_can_upload_explorations(self):\n        self.login(self.ADMIN_EMAIL, is_super_admin=True)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_upload_exploration/')\n        self.logout()\n\n    def test_normal_user_cannot_upload_explorations(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_upload_exploration/', expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You do not have credentials to upload exploration.')\n        self.logout()\n\n    def test_guest_cannot_upload_explorations(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_upload_exploration/', expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass DeleteExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_delete_exploration decorator.\"\"\"\n    private_exp_id = 'exp_0'\n    published_exp_id = 'exp_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_delete_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(DeleteExplorationTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.moderator_id = self.get_user_id_from_email(self.MODERATOR_EMAIL)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_delete_exploration/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n\n    def test_guest_can_not_delete_exploration(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_delete_exploration/%s' % self.private_exp_id,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n    def test_owner_can_delete_owned_private_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_delete_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_moderator_can_delete_published_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_delete_exploration/%s' % self.published_exp_id)\n        self.assertEqual(response['exploration_id'], self.published_exp_id)\n        self.logout()\n\n    def test_owner_cannot_delete_published_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_delete_exploration/%s' % self.published_exp_id,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'User %s does not have permissions to delete exploration %s'\n                % (self.owner_id, self.published_exp_id))\n        self.logout()\n\n    def test_moderator_cannot_delete_private_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_delete_exploration/%s' % self.private_exp_id,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'User %s does not have permissions to delete exploration %s'\n                % (self.moderator_id, self.private_exp_id))\n        self.logout()\n\n\nclass SuggestChangesToExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_suggest_changes_to_exploration decorator.\"\"\"\n    username = 'user'\n    user_email = 'user@example.com'\n    banned_username = 'banneduser'\n    banned_user_email = 'banned@example.com'\n    exploration_id = 'exp_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_suggest_changes_to_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(SuggestChangesToExplorationTests, self).setUp()\n        self.signup(self.user_email, self.username)\n        self.signup(self.banned_user_email, self.banned_username)\n        self.set_banned_users([self.banned_username])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_cannot_suggest_changes(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.exploration_id, expected_status_int=401)\n        self.logout()\n\n    def test_normal_user_can_suggest_changes(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.exploration_id)\n        self.assertEqual(response['exploration_id'], self.exploration_id)\n        self.logout()\n\n\nclass SuggestChangesDecoratorsTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_suggest_changes decorator.\"\"\"\n    username = 'user'\n    user_email = 'user@example.com'\n    banned_username = 'banneduser'\n    banned_user_email = 'banned@example.com'\n    exploration_id = 'exp_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_suggest_changes\n        def get(self):\n            self.render_json({})\n\n    def setUp(self):\n        super(SuggestChangesDecoratorsTests, self).setUp()\n        self.signup(self.user_email, self.username)\n        self.signup(self.banned_user_email, self.banned_username)\n        self.set_banned_users([self.banned_username])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_cannot_suggest_changes(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock', expected_status_int=401)\n        self.logout()\n\n    def test_normal_user_can_suggest_changes(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock')\n        self.logout()\n\n\nclass ResubmitSuggestionDecoratorsTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_resubmit_suggestion decorator.\"\"\"\n    owner_username = 'owner'\n    owner_email = 'owner@example.com'\n    author_username = 'author'\n    author_email = 'author@example.com'\n    username = 'user'\n    user_email = 'user@example.com'\n    TARGET_TYPE = 'exploration'\n    SUGGESTION_TYPE = 'edit_exploration_state_content'\n    exploration_id = 'exp_id'\n    target_version_id = 1\n    change_dict = {\n        'cmd': 'edit_state_property',\n        'property_name': 'content',\n        'state_name': 'Introduction',\n        'new_value': ''\n    }\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_resubmit_suggestion\n        def get(self, suggestion_id):\n            self.render_json({'suggestion_id': suggestion_id})\n\n    def setUp(self):\n        super(ResubmitSuggestionDecoratorsTests, self).setUp()\n        self.signup(self.author_email, self.author_username)\n        self.signup(self.user_email, self.username)\n        self.signup(self.owner_email, self.owner_username)\n        self.author_id = self.get_user_id_from_email(self.author_email)\n        self.owner_id = self.get_user_id_from_email(self.owner_email)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<suggestion_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_default_exploration(self.exploration_id, self.owner_id)\n        suggestion_services.create_suggestion(\n            self.SUGGESTION_TYPE, self.TARGET_TYPE,\n            self.exploration_id, self.target_version_id,\n            self.author_id,\n            self.change_dict, '', None)\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id),\n             ('target_id', self.exploration_id)])[0]\n        self.suggestion_id = suggestion.suggestion_id\n\n    def test_author_can_resubmit_suggestion(self):\n        self.login(self.author_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.suggestion_id)\n        self.assertEqual(response['suggestion_id'], self.suggestion_id)\n        self.logout()\n\n    def test_non_author_cannot_resubmit_suggestion(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.suggestion_id, expected_status_int=401)\n        self.logout()\n\n\nclass DecoratorForAcceptingSuggestionTests(test_utils.GenericTestBase):\n    \"\"\"Tests for get_decorator_for_accepting_suggestion decorator.\"\"\"\n    AUTHOR_USERNAME = 'author'\n    AUTHOR_EMAIL = 'author@example.com'\n    VIEWER_USERNAME = 'user'\n    VIEWER_EMAIL = 'user@example.com'\n    TARGET_TYPE = 'exploration'\n    SUGGESTION_TYPE = 'edit_exploration_state_content'\n    EXPLORATION_ID = 'exp_id'\n    TARGET_VERSION_ID = 1\n    CHANGE_DICT = {\n        'cmd': 'edit_state_property',\n        'property_name': 'content',\n        'state_name': 'Introduction',\n        'new_value': ''\n    }\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.get_decorator_for_accepting_suggestion(\n            acl_decorators.can_edit_exploration)\n        def get(self, target_id, suggestion_id):\n            self.render_json({\n                'target_id': target_id,\n                'suggestion_id': suggestion_id\n            })\n\n    def setUp(self):\n        super(DecoratorForAcceptingSuggestionTests, self).setUp()\n        self.signup(self.AUTHOR_EMAIL, self.AUTHOR_USERNAME)\n        self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_accept_suggestion/<target_id>/<suggestion_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_default_exploration(self.EXPLORATION_ID, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.EXPLORATION_ID)\n        suggestion_services.create_suggestion(\n            self.SUGGESTION_TYPE, self.TARGET_TYPE,\n            self.EXPLORATION_ID, self.TARGET_VERSION_ID,\n            self.author_id,\n            self.CHANGE_DICT, '', None)\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id),\n             ('target_id', self.EXPLORATION_ID)])[0]\n        self.suggestion_id = suggestion.suggestion_id\n\n    def test_guest_cannot_accept_suggestion(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_accept_suggestion/%s/%s'\n                % (self.EXPLORATION_ID, self.suggestion_id),\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n    def test_owner_can_accept_suggestion(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_accept_suggestion/%s/%s'\n                % (self.EXPLORATION_ID, self.suggestion_id))\n        self.assertEqual(response['suggestion_id'], self.suggestion_id)\n        self.assertEqual(response['target_id'], self.EXPLORATION_ID)\n        self.logout()\n\n    def test_viewer_cannot_accept_suggestion(self):\n        self.login(self.VIEWER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_accept_suggestion/%s/%s'\n                % (self.EXPLORATION_ID, self.suggestion_id),\n                expected_status_int=401)\n        self.logout()\n\n\nclass PublishExplorationTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_publish_exploration decorator.\"\"\"\n    private_exp_id = 'exp_0'\n    public_exp_id = 'exp_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_publish_exploration\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(PublishExplorationTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_publish_exploration/<exploration_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.public_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        rights_manager.publish_exploration(self.owner, self.public_exp_id)\n\n    def test_cannot_publish_exploration_with_invalid_exp_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_exploration/invalid_exp_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_owner_can_publish_owned_exploration(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_already_published_exploration_cannot_be_published(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_exploration/%s' % self.public_exp_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_moderator_cannot_publish_private_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_exploration/%s' % self.private_exp_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_publish_any_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_exploration/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n\n\nclass ModifyExplorationRolesTests(test_utils.GenericTestBase):\n    \"\"\"Tests for can_modify_exploration_roles decorator.\"\"\"\n    private_exp_id = 'exp_0'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_modify_exploration_roles\n        def get(self, exploration_id):\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self):\n        super(ModifyExplorationRolesTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_admins([self.ADMIN_USERNAME])\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/<exploration_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n\n    def test_owner_can_modify_exploration_roles(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n    def test_moderator_cannot_modify_roles_of_unowned_exploration(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock/%s' % self.private_exp_id, expected_status_int=401)\n        self.logout()\n\n    def test_admin_can_modify_roles_of_any_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock/%s' % self.private_exp_id)\n        self.assertEqual(response['exploration_id'], self.private_exp_id)\n        self.logout()\n\n\nclass CollectionPublishStatusTests(test_utils.GenericTestBase):\n    \"\"\"Tests can_publish_collection and can_unpublish_collection decorators.\"\"\"\n\n    user_email = 'user@example.com'\n    username = 'user'\n    published_exp_id = 'exp_id_1'\n    private_exp_id = 'exp_id_2'\n    published_col_id = 'col_id_1'\n    private_col_id = 'col_id_2'\n\n    class MockPublishHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_publish_collection\n        def get(self, collection_id):\n            return self.render_json({'collection_id': collection_id})\n\n    class MockUnpublishHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_unpublish_collection\n        def get(self, collection_id):\n            return self.render_json({'collection_id': collection_id})\n\n    def setUp(self):\n        super(CollectionPublishStatusTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.MODERATOR_EMAIL, self.MODERATOR_USERNAME)\n        self.signup(self.user_email, self.username)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_moderators([self.MODERATOR_USERNAME])\n        self.set_collection_editors([self.OWNER_USERNAME])\n        self.owner = user_services.UserActionsInfo(self.owner_id)\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [\n                webapp2.Route(\n                    '/mock_publish_collection/<collection_id>',\n                    self.MockPublishHandler),\n                webapp2.Route(\n                    '/mock_unpublish_collection/<collection_id>',\n                    self.MockUnpublishHandler)\n            ],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_valid_exploration(\n            self.published_exp_id, self.owner_id)\n        self.save_new_valid_exploration(\n            self.private_exp_id, self.owner_id)\n        self.save_new_valid_collection(\n            self.published_col_id, self.owner_id,\n            exploration_id=self.published_col_id)\n        self.save_new_valid_collection(\n            self.private_col_id, self.owner_id,\n            exploration_id=self.private_col_id)\n        rights_manager.publish_exploration(self.owner, self.published_exp_id)\n        rights_manager.publish_collection(self.owner, self.published_col_id)\n\n    def test_cannot_publish_collection_with_invalid_exp_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_collection/invalid_col_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_cannot_unpublish_collection_with_invalid_exp_id(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_unpublish_collection/invalid_col_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_owner_can_publish_collection(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n    def test_owner_cannot_unpublish_public_collection(self):\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_unpublish_collection/%s' % self.published_col_id,\n                expected_status_int=401)\n        self.logout()\n\n    def test_moderator_can_unpublish_public_collection(self):\n        self.login(self.MODERATOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_unpublish_collection/%s' % self.published_col_id)\n        self.assertEqual(response['collection_id'], self.published_col_id)\n        self.logout()\n\n    def test_admin_can_publish_any_collection(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_collection/%s' % self.private_col_id)\n        self.assertEqual(response['collection_id'], self.private_col_id)\n        self.logout()\n\n    def test_admin_cannot_publish_already_published_collection(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_collection/%s' % self.published_col_id,\n                expected_status_int=401)\n        self.logout()\n\n\nclass AccessLearnerDashboardDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests the decorator can_access_learner_dashboard.\"\"\"\n\n    user = 'user'\n    user_email = 'user@example.com'\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_access_learner_dashboard\n        def get(self):\n            return self.render_json({})\n\n    def setUp(self):\n        super(AccessLearnerDashboardDecoratorTests, self).setUp()\n        self.signup(self.user_email, self.user)\n        self.signup(self.banned_user_email, self.banned_user)\n        self.set_banned_users([self.banned_user])\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock/', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_banned_user_is_redirected(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/', expected_status_int=401)\n        self.logout()\n\n    def test_exploration_editor_can_access_learner_dashboard(self):\n        self.login(self.user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock/')\n        self.logout()\n\n\nclass EditTopicDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests the decorator can_edit_topic.\"\"\"\n    manager_username = 'topicmanager'\n    manager_email = 'topicmanager@example.com'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n    topic_id = 'topic_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_edit_topic\n        def get(self, topic_id):\n            self.render_json({'topic_id': topic_id})\n\n    def setUp(self):\n        super(EditTopicDecoratorTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.manager_email, self.manager_username)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_topic_managers([self.manager_username])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.manager_id = self.get_user_id_from_email(self.manager_email)\n        self.viewer_id = self.get_user_id_from_email(self.viewer_email)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.manager = user_services.UserActionsInfo(self.manager_id)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_edit_topic/<topic_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_topic(\n            self.topic_id, self.viewer_id, 'Name', 'Description', [], [],\n            [], [], 1)\n        topic_services.create_new_topic_rights(self.topic_id, self.admin_id)\n        topic_services.assign_role(\n            self.admin, self.manager, topic_domain.ROLE_MANAGER, self.topic_id)\n\n    def test_can_not_edit_topic_with_invalid_topic_id(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_topic/invalid_topic_id', expected_status_int=404)\n        self.logout()\n\n    def test_admin_can_edit_topic(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock_edit_topic/%s' % self.topic_id)\n        self.assertEqual(response['topic_id'], self.topic_id)\n        self.logout()\n\n    def test_topic_manager_can_edit_topic(self):\n        self.login(self.manager_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock_edit_topic/%s' % self.topic_id)\n        self.assertEqual(response['topic_id'], self.topic_id)\n        self.logout()\n\n    def test_normal_user_cannot_edit_topic(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_topic/%s' % self.topic_id, expected_status_int=401)\n        self.logout()\n\n\nclass AddStoryToTopicTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_add_new_story_to_topic.\"\"\"\n    manager_username = 'topicmanager'\n    manager_email = 'topicmanager@example.com'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n    topic_id = 'topic_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_add_new_story_to_topic\n        def get(self, topic_id):\n            self.render_json({'topic_id': topic_id})\n\n    def setUp(self):\n        super(AddStoryToTopicTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.manager_email, self.manager_username)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_topic_managers([self.manager_username])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.manager_id = self.get_user_id_from_email(self.manager_email)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.manager = user_services.UserActionsInfo(self.manager_id)\n        self.viewer_id = self.get_user_id_from_email(self.viewer_email)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_add_story_to_topic/<topic_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.save_new_topic(\n            self.topic_id, self.viewer_id, 'Name', 'Description', [], [],\n            [], [], 1)\n        topic_services.create_new_topic_rights(self.topic_id, self.admin_id)\n        topic_services.assign_role(\n            self.admin, self.manager, topic_domain.ROLE_MANAGER, self.topic_id)\n\n    def test_can_not_add_story_to_topic_with_invalid_topic_id(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_add_story_to_topic/invalid_topic_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_admin_can_add_story_to_topic(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_add_story_to_topic/%s' % self.topic_id)\n        self.assertEqual(response['topic_id'], self.topic_id)\n        self.logout()\n\n    def test_topic_manager_can_add_story_to_topic(self):\n        self.login(self.manager_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_add_story_to_topic/%s' % self.topic_id)\n        self.assertEqual(response['topic_id'], self.topic_id)\n        self.logout()\n\n    def test_normal_user_cannot_add_story_to_topic(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_add_story_to_topic/%s' % self.topic_id,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have credentials to add a story to this topic.')\n        self.logout()\n\n    def test_guest_cannot_add_story_to_topic(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_add_story_to_topic/%s' % self.topic_id,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass CreateSkillTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_create_skill.\"\"\"\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_create_skill\n        def get(self):\n            self.render_json({})\n\n    def setUp(self):\n        super(CreateSkillTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.banned_user_email, self.banned_user)\n        self.set_banned_users([self.banned_user])\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_create_skill', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_admin_can_create_skill(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_create_skill')\n        self.logout()\n\n    def test_banned_user_cannot_create_skill(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_create_skill', expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have credentials to create a skill.')\n        self.logout()\n\n    def test_guest_cannot_add_create_skill(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_create_skill', expected_status_int=401)\n\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass PublishSkillTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_publish_skill.\"\"\"\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n    skill_id_1 = '1'\n    skill_id_2 = '2'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_publish_skill\n        def get(self, skill_id):\n            self.render_json({'skill_id': skill_id})\n\n    def setUp(self):\n        super(PublishSkillTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n\n        self.set_admins([self.ADMIN_USERNAME, self.EDITOR_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n\n        self.signup(self.viewer_email, self.viewer_username)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_publish_skill/<skill_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        skill_services.create_new_skill_rights(self.skill_id_1, self.admin_id)\n        skill_services.create_new_skill_rights(self.skill_id_2, self.editor_id)\n\n    def test_can_not_publish_skill_with_invalid_skill_id(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_publish_skill/invalid_skill_id', expected_status_int=404)\n        self.logout()\n\n    def test_admin_can_publish_skill(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_publish_skill/%s' % self.skill_id_1)\n        self.logout()\n\n    def test_editor_can_publish_skill(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_publish_skill/%s' % self.skill_id_2)\n        self.logout()\n\n    def test_editor_cannot_publish_skill_created_by_admin(self):\n        self.login(self.EDITOR_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_skill/%s' % self.skill_id_1,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have credentials to edit this skill.')\n        self.logout()\n\n    def test_viewer_cannot_publish_skill(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_skill/%s' % self.skill_id_1,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have credentials to edit this skill.')\n        self.logout()\n\n    def test_guest_cannot_publish_skill(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_publish_skill/%s' % self.skill_id_1,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass ManageQuestionSkillStatusTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_manage_question_skill_status.\"\"\"\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n    skill_id = '1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_manage_question_skill_status\n        def get(self, skill_id):\n            self.render_json({'skill_id': skill_id})\n\n    def setUp(self):\n        super(ManageQuestionSkillStatusTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.viewer_email, self.viewer_username)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_manage_question_skill_status/<skill_id>',\n                self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        self.question_id = question_services.get_new_question_id()\n        self.question = self.save_new_question(\n            self.question_id, self.admin_id,\n            self._create_valid_question_data('ABC'), [self.skill_id])\n        question_services.create_new_question_skill_link(\n            self.admin_id, self.question_id, self.skill_id, 0.5)\n\n    def test_admin_can_manage_question_skill_status(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_manage_question_skill_status/%s' % self.skill_id)\n            self.assertEqual(response['skill_id'], self.skill_id)\n        self.logout()\n\n    def test_viewer_cannot_manage_question_skill_status(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_manage_question_skill_status/%s' % self.skill_id,\n                expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have credentials to publish a question.')\n        self.logout()\n\n    def test_guest_cannot_manage_question_skill_status(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_manage_question_skill_status/%s' % self.skill_id,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass CreateTopicTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_create_topic.\"\"\"\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_create_topic\n        def get(self):\n            self.render_json({})\n\n    def setUp(self):\n        super(CreateTopicTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.banned_user_email, self.banned_user)\n        self.set_banned_users([self.banned_user])\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_create_topic', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_admin_can_create_topic(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_create_topic')\n        self.logout()\n\n    def test_banned_user_cannot_create_topic(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_create_topic', expected_status_int=401)\n            self.assertIn(\n                'does not have enough rights to create a topic.',\n                response['error'])\n        self.logout()\n\n    def test_guest_cannot_create_topic(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_create_topic', expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass ManageRightsForTopicTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_manage_rights_for_topic.\"\"\"\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n    topic_id = 'topic_1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_manage_rights_for_topic\n        def get(self, topic_id):\n            self.render_json({'topic_id': topic_id})\n\n    def setUp(self):\n        super(ManageRightsForTopicTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.banned_user_email, self.banned_user)\n        self.set_banned_users([self.banned_user])\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_manage_rights_for_topic/<topic_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        topic_services.create_new_topic_rights(self.topic_id, self.admin_id)\n\n    def test_admin_can_manage_rights(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_manage_rights_for_topic/%s' % self.topic_id)\n        self.logout()\n\n    def test_banned_user_cannot_manage_rights(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_manage_rights_for_topic/%s' % self.topic_id,\n                expected_status_int=401)\n            self.assertIn(\n                'does not have enough rights to assign roles for the topic.',\n                response['error'])\n        self.logout()\n\n    def test_guest_cannot_manage_rights(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_manage_rights_for_topic/%s' % self.topic_id,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass ChangeTopicPublicationStatusTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_change_topic_publication_status.\"\"\"\n    banned_user = 'banneduser'\n    banned_user_email = 'banned@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_change_topic_publication_status\n        def get(self):\n            self.render_json({})\n\n    def setUp(self):\n        super(ChangeTopicPublicationStatusTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.banned_user_email, self.banned_user)\n        self.set_banned_users([self.banned_user])\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_change_publication_status', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_admin_can_change_topic_publication_status(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_change_publication_status')\n        self.logout()\n\n    def test_banned_user_cannot_change_topic_publication_status(self):\n        self.login(self.banned_user_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_change_publication_status', expected_status_int=401)\n            self.assertIn(\n                'does not have enough rights to publish or unpublish the '\n                'topic.', response['error'])\n        self.logout()\n\n    def test_guest_cannot_change_topic_publication_status(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_change_publication_status', expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n\nclass PerformCronTaskTests(test_utils.GenericTestBase):\n    \"\"\"Tests for decorator can_perform_cron_tasks.\"\"\"\n\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_perform_cron_tasks\n        def get(self):\n            self.render_json({})\n\n    def setUp(self):\n        super(PerformCronTaskTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.set_admins([self.ADMIN_USERNAME])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.signup(self.viewer_email, self.viewer_username)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_perform_cron_task', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_super_admin_can_perform_cron_tasks(self):\n        self.login(self.ADMIN_EMAIL, is_super_admin=True)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json('/mock_perform_cron_task')\n        self.logout()\n\n    def test_normal_user_cannot_perform_cron_tasks(self):\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_perform_cron_task', expected_status_int=401)\n            self.assertEqual(\n                response['error'],\n                'You do not have the credentials to access this page.')\n        self.logout()\n\n\nclass EditSkillDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests permissions for accessing the skill editor.\"\"\"\n    second_admin_username = 'adm2'\n    second_admin_email = 'adm2@example.com'\n    manager_username = 'topicmanager'\n    manager_email = 'topicmanager@example.com'\n    viewer_username = 'viewer'\n    viewer_email = 'viewer@example.com'\n    skill_id = '1'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_edit_skill\n        def get(self, skill_id):\n            self.render_json({'skill_id': skill_id})\n\n    def setUp(self):\n        super(EditSkillDecoratorTests, self).setUp()\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n        self.signup(self.second_admin_email, self.second_admin_username)\n        self.signup(self.manager_email, self.manager_username)\n        self.signup(self.viewer_email, self.viewer_username)\n        self.set_admins([self.ADMIN_USERNAME, self.second_admin_username])\n        self.set_topic_managers([self.manager_username])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.second_admin_id = self.get_user_id_from_email(\n            self.second_admin_email)\n        self.manager_id = self.get_user_id_from_email(self.manager_email)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.manager = user_services.UserActionsInfo(self.manager_id)\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_edit_skill/<skill_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        skill_services.create_new_skill_rights(self.skill_id, self.admin_id)\n\n    def test_cannot_edit_skill_with_invalid_skill_id(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_custom_response(\n                '/mock_edit_skill/', 'text/plain', expected_status_int=404)\n        self.logout()\n\n    def test_admin_can_edit_skill(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock_edit_skill/%s' % self.skill_id)\n        self.assertEqual(response['skill_id'], self.skill_id)\n        self.logout()\n\n    def test_admin_can_edit_other_public_skill(self):\n        skill_services.publish_skill(self.skill_id, self.admin_id)\n        self.login(self.second_admin_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock_edit_skill/%s' % self.skill_id)\n        self.assertEqual(response['skill_id'], self.skill_id)\n        self.logout()\n\n    def test_admin_can_not_edit_other_private_skill(self):\n        self.login(self.second_admin_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_skill/%s' % self.skill_id, expected_status_int=401)\n        self.logout()\n\n    def test_topic_manager_can_not_edit_private_skill(self):\n        self.login(self.manager_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_skill/%s' % self.skill_id, expected_status_int=401)\n        self.logout()\n\n    def test_topic_manager_can_edit_public_skill(self):\n        skill_services.publish_skill(self.skill_id, self.admin_id)\n        self.login(self.manager_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json('/mock_edit_skill/%s' % self.skill_id)\n        self.assertEqual(response['skill_id'], self.skill_id)\n        self.logout()\n\n    def test_normal_user_can_not_edit_public_skill(self):\n        skill_services.publish_skill(self.skill_id, self.admin_id)\n        self.login(self.viewer_email)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_skill/%s' % self.skill_id, expected_status_int=401)\n\n\nclass EditQuestionDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests the decorator can_edit_question.\"\"\"\n    question_id = 'question_id'\n\n    class MockHandler(base.BaseHandler):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n        @acl_decorators.can_edit_question\n        def get(self, question_id):\n            self.render_json({'question_id': question_id})\n\n    def setUp(self):\n        super(EditQuestionDecoratorTests, self).setUp()\n\n        self.signup(self.ADMIN_EMAIL, username=self.ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup('a@example.com', 'A')\n        self.signup('b@example.com', 'B')\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.user_id_admin = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.user_id_a = self.get_user_id_from_email('a@example.com')\n        self.user_id_b = self.get_user_id_from_email('b@example.com')\n\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_topic_managers([user_services.get_username(self.user_id_a)])\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.manager_id = self.get_user_id_from_email('a@example.com')\n\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_edit_question/<question_id>', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        question_services.create_new_question_rights(\n            self.question_id, self.ADMIN_EMAIL)\n\n    def test_guest_cannot_edit_question(self):\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_question/%s' % self.question_id,\n                expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n    def test_cannot_edit_question_with_invalid_question_id(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_question/invalid_question_id',\n                expected_status_int=404)\n        self.logout()\n\n    def test_admin_can_edit_question(self):\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_question/%s' % self.question_id)\n        self.assertEqual(response['question_id'], self.question_id)\n        self.logout()\n\n    def test_topic_manager_can_edit_question(self):\n        self.login('a@example.com')\n        with self.swap(self, 'testapp', self.mock_testapp):\n            response = self.get_json(\n                '/mock_edit_question/%s' % self.question_id)\n        self.assertEqual(response['question_id'], self.question_id)\n        self.logout()\n\n    def test_any_user_cannot_edit_question(self):\n        self.login('b@example.com')\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.get_json(\n                '/mock_edit_question/%s' % self.question_id,\n                expected_status_int=401)\n        self.logout()\n"
    },
    {
      "filename": "core/controllers/topic_editor.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Controllers for the topics editor, from where topics are edited and stories\nare created.\n\"\"\"\n\nfrom constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.domain import dependency_registry\nfrom core.domain import email_manager\nfrom core.domain import interaction_registry\nfrom core.domain import obj_services\nfrom core.domain import question_services\nfrom core.domain import role_services\nfrom core.domain import skill_services\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_domain\nfrom core.domain import subtopic_page_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nimport feconf\nimport utils\n\nimport jinja2\n\n\nclass TopicEditorStoryHandler(base.BaseHandler):\n    \"\"\"Manages the creation of a story and receiving of all story summaries for\n    display in topic editor page.\n    \"\"\"\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id):\n        \"\"\"Handles GET requests.\"\"\"\n        topic = topic_services.get_topic_by_id(topic_id)\n        canonical_story_summaries = story_services.get_story_summaries_by_ids(\n            topic.canonical_story_ids)\n        additional_story_summaries = story_services.get_story_summaries_by_ids(\n            topic.additional_story_ids)\n\n        canonical_story_summary_dicts = [\n            summary.to_dict() for summary in canonical_story_summaries]\n        additional_story_summary_dicts = [\n            summary.to_dict() for summary in additional_story_summaries]\n\n        self.values.update({\n            'canonical_story_summary_dicts': canonical_story_summary_dicts,\n            'additional_story_summary_dicts': additional_story_summary_dicts\n        })\n        self.render_json(self.values)\n\n    @acl_decorators.can_add_new_story_to_topic\n    def post(self, topic_id):\n        \"\"\"Handles POST requests.\n        Currently, this only adds the story to the canonical story id list of\n        the topic.\n        \"\"\"\n        topic_domain.Topic.require_valid_topic_id(topic_id)\n        title = self.payload.get('title')\n\n        story_domain.Story.require_valid_title(title)\n\n        new_story_id = story_services.get_new_story_id()\n        story = story_domain.Story.create_default_story(\n            new_story_id, title, topic_id)\n        story_services.save_new_story(self.user_id, story)\n        self.render_json({\n            'storyId': new_story_id\n        })\n\n\nclass TopicEditorQuestionHandler(base.BaseHandler):\n    \"\"\"Manages the creation of a question and receiving of all question\n    summaries for display in topic editor page.\n    \"\"\"\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id):\n        \"\"\"Handles GET requests.\"\"\"\n        start_cursor = self.request.get('cursor')\n        topic = topic_services.get_topic_by_id(topic_id)\n        skill_ids = topic.get_all_skill_ids()\n\n        question_summaries, skill_descriptions, next_start_cursor = (\n            question_services.get_question_summaries_and_skill_descriptions(\n                constants.NUM_QUESTIONS_PER_PAGE, skill_ids, start_cursor)\n        )\n        return_dicts = []\n        for index, summary in enumerate(question_summaries):\n            return_dicts.append({\n                'summary': summary.to_dict(),\n                'skill_description': skill_descriptions[index]\n            })\n\n        self.values.update({\n            'question_summary_dicts': return_dicts,\n            'next_start_cursor': next_start_cursor\n        })\n        self.render_json(self.values)\n\n\nclass TopicEditorPage(base.BaseHandler):\n    \"\"\"The editor page for a single topic.\"\"\"\n\n    EDITOR_PAGE_DEPENDENCY_IDS = ['codemirror']\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id):\n        \"\"\"Handles GET requests.\"\"\"\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n\n        if topic is None:\n            raise self.PageNotFoundException(\n                Exception('The topic with the given id doesn\\'t exist.'))\n\n        interaction_ids = feconf.ALLOWED_QUESTION_INTERACTION_IDS\n\n        interaction_dependency_ids = (\n            interaction_registry.Registry.get_deduplicated_dependency_ids(\n                interaction_ids))\n        dependencies_html, additional_angular_modules = (\n            dependency_registry.Registry.get_deps_html_and_angular_modules(\n                interaction_dependency_ids + self.EDITOR_PAGE_DEPENDENCY_IDS))\n\n        interaction_templates = (\n            interaction_registry.Registry.get_interaction_html(\n                interaction_ids))\n\n        self.values.update({\n            'topic_id': topic.id,\n            'DEFAULT_OBJECT_VALUES': obj_services.get_default_object_values(),\n            'additional_angular_modules': additional_angular_modules,\n            'INTERACTION_SPECS': interaction_registry.Registry.get_all_specs(),\n            'interaction_templates': jinja2.utils.Markup(\n                interaction_templates),\n            'dependencies_html': jinja2.utils.Markup(dependencies_html)\n        })\n\n        self.render_template('dist/topic-editor-page.mainpage.html')\n\n\nclass EditableSubtopicPageDataHandler(base.BaseHandler):\n    \"\"\"The data handler for subtopic pages.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id, subtopic_id):\n        \"\"\"Handles GET requests.\"\"\"\n        subtopic_page = subtopic_page_services.get_subtopic_page_by_id(\n            topic_id, subtopic_id, strict=False)\n\n        if subtopic_page is None:\n            raise self.PageNotFoundException(\n                'The subtopic page with the given id doesn\\'t exist.')\n\n        self.values.update({\n            'subtopic_page': subtopic_page.to_dict()\n        })\n\n        self.render_json(self.values)\n\n\nclass EditableTopicDataHandler(base.BaseHandler):\n    \"\"\"A data handler for topics which supports writing.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    def _require_valid_version(self, version_from_payload, topic_version):\n        \"\"\"Check that the payload version matches the given topic\n        version.\n        \"\"\"\n        if version_from_payload is None:\n            raise base.BaseHandler.InvalidInputException(\n                'Invalid POST request: a version must be specified.')\n\n        if version_from_payload != topic_version:\n            raise base.BaseHandler.InvalidInputException(\n                'Trying to update version %s of topic from version %s, '\n                'which is too old. Please reload the page and try again.'\n                % (topic_version, version_from_payload))\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id):\n        \"\"\"Populates the data on the individual topic page.\"\"\"\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n\n        if topic is None:\n            raise self.PageNotFoundException(\n                Exception('The topic with the given id doesn\\'t exist.'))\n\n        skill_ids = topic.get_all_skill_ids()\n\n        skill_id_to_description_dict = (\n            skill_services.get_skill_descriptions_by_ids(topic_id, skill_ids))\n\n        self.values.update({\n            'topic_dict': topic.to_dict(),\n            'skill_id_to_description_dict': skill_id_to_description_dict\n        })\n\n        self.render_json(self.values)\n\n    @acl_decorators.can_edit_topic\n    def put(self, topic_id):\n        \"\"\"Updates properties of the given topic.\n        Also, each change_dict given for editing should have an additional\n        property called is_topic_change, which would be a boolean. If True, it\n        means that change is for a topic (includes adding and removing\n        subtopics), while False would mean it is for a Subtopic Page (this\n        includes editing its html data as of now).\n        \"\"\"\n        topic_domain.Topic.require_valid_topic_id(topic_id)\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n\n        version = self.payload.get('version')\n        self._require_valid_version(version, topic.version)\n\n        commit_message = self.payload.get('commit_message')\n        topic_and_subtopic_page_change_dicts = self.payload.get(\n            'topic_and_subtopic_page_change_dicts')\n        topic_and_subtopic_page_change_list = []\n        for change in topic_and_subtopic_page_change_dicts:\n            if change['change_affects_subtopic_page']:\n                topic_and_subtopic_page_change_list.append(\n                    subtopic_page_domain.SubtopicPageChange(change))\n            else:\n                topic_and_subtopic_page_change_list.append(\n                    topic_domain.TopicChange(change))\n        try:\n            topic_services.update_topic_and_subtopic_pages(\n                self.user_id, topic_id, topic_and_subtopic_page_change_list,\n                commit_message)\n        except utils.ValidationError as e:\n            raise self.InvalidInputException(e)\n\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        skill_ids = topic.get_all_skill_ids()\n\n        skill_id_to_description_dict = (\n            skill_services.get_skill_descriptions_by_ids(topic_id, skill_ids))\n\n        self.values.update({\n            'topic_dict': topic.to_dict(),\n            'skill_id_to_description_dict': skill_id_to_description_dict\n        })\n\n        self.render_json(self.values)\n\n    @acl_decorators.can_delete_topic\n    def delete(self, topic_id):\n        \"\"\"Handles Delete requests.\"\"\"\n        topic_domain.Topic.require_valid_topic_id(topic_id)\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        if topic is None:\n            raise self.PageNotFoundException(\n                'The topic with the given id doesn\\'t exist.')\n        topic_services.delete_topic(self.user_id, topic_id)\n\n        self.render_json(self.values)\n\n\nclass TopicRightsHandler(base.BaseHandler):\n    \"\"\"A handler for returning topic rights.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.can_view_any_topic_editor\n    def get(self, topic_id):\n        \"\"\"Returns the TopicRights object of a topic.\"\"\"\n        topic_rights = topic_services.get_topic_rights(topic_id, strict=False)\n        if topic_rights is None:\n            raise self.InvalidInputException(\n                'Expected a valid topic id to be provided.')\n        user_actions_info = user_services.UserActionsInfo(self.user_id)\n        can_edit_topic = topic_services.check_can_edit_topic(\n            user_actions_info, topic_rights)\n\n        can_publish_topic = (\n            role_services.ACTION_CHANGE_TOPIC_STATUS in\n            user_actions_info.actions)\n\n        self.values.update({\n            'can_edit_topic': can_edit_topic,\n            'published': topic_rights.topic_is_published,\n            'can_publish_topic': can_publish_topic\n        })\n\n        self.render_json(self.values)\n\n\nclass TopicPublishSendMailHandler(base.BaseHandler):\n    \"\"\"A handler for sending mail to admins to review and publish topic.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.can_view_any_topic_editor\n    def put(self, topic_id):\n        \"\"\"Returns the TopicRights object of a topic.\"\"\"\n        topic_url = feconf.TOPIC_EDITOR_URL_PREFIX + '/' + topic_id\n        if feconf.CAN_SEND_EMAILS:\n            email_manager.send_mail_to_admin(\n                'Request to review and publish a topic',\n                '%s wants to publish topic: %s at URL %s, please review'\n                ' and publish if it looks good.'\n                % (self.username, self.payload.get('topic_name'), topic_url))\n\n        self.render_json(self.values)\n\n\nclass TopicPublishHandler(base.BaseHandler):\n    \"\"\"A handler for publishing and unpublishing topics.\"\"\"\n\n    @acl_decorators.can_change_topic_publication_status\n    def put(self, topic_id):\n        \"\"\"Publishes or unpublishes a topic.\"\"\"\n        topic = topic_services.get_topic_by_id(topic_id, strict=False)\n        if topic is None:\n            raise self.PageNotFoundException\n\n        topic_domain.Topic.require_valid_topic_id(topic_id)\n\n        publish_status = self.payload.get('publish_status')\n\n        if not isinstance(publish_status, bool):\n            raise self.InvalidInputException(\n                'Publish status should only be true or false.')\n\n        try:\n            if publish_status:\n                topic_services.publish_topic(topic_id, self.user_id)\n            else:\n                topic_services.unpublish_topic(topic_id, self.user_id)\n        except Exception as e:\n            raise self.UnauthorizedUserException(e)\n\n        self.render_json(self.values)\n"
    },
    {
      "filename": "core/controllers/topic_editor_test.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the topic editor page.\"\"\"\n\nfrom constants import constants\nfrom core.domain import question_services\nfrom core.domain import skill_services\nfrom core.domain import story_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.tests import test_utils\nimport feconf\n\n\nclass BaseTopicEditorControllerTests(test_utils.GenericTestBase):\n\n    def setUp(self):\n        \"\"\"Completes the sign-up process for the various users.\"\"\"\n        super(BaseTopicEditorControllerTests, self).setUp()\n        self.signup(self.TOPIC_MANAGER_EMAIL, self.TOPIC_MANAGER_USERNAME)\n        self.signup(self.NEW_USER_EMAIL, self.NEW_USER_USERNAME)\n        self.signup(self.ADMIN_EMAIL, self.ADMIN_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.ADMIN_EMAIL)\n        self.topic_manager_id = self.get_user_id_from_email(\n            self.TOPIC_MANAGER_EMAIL)\n        self.new_user_id = self.get_user_id_from_email(\n            self.NEW_USER_EMAIL)\n\n        self.set_admins([self.ADMIN_USERNAME])\n        self.set_topic_managers([self.TOPIC_MANAGER_USERNAME])\n\n        self.topic_manager = user_services.UserActionsInfo(\n            self.topic_manager_id)\n        self.admin = user_services.UserActionsInfo(self.admin_id)\n        self.new_user = user_services.UserActionsInfo(self.new_user_id)\n        self.skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(self.skill_id, self.admin_id, 'Skill Description')\n        self.topic_id = topic_services.get_new_topic_id()\n        self.save_new_topic(\n            self.topic_id, self.admin_id, 'Name', 'Description', [], [],\n            [self.skill_id], [], 1)\n        changelist = [topic_domain.TopicChange({\n            'cmd': topic_domain.CMD_ADD_SUBTOPIC,\n            'title': 'Title',\n            'subtopic_id': 1\n        })]\n        topic_services.update_topic_and_subtopic_pages(\n            self.admin_id, self.topic_id, changelist, 'Added subtopic.')\n\n\nclass TopicEditorStoryHandlerTests(BaseTopicEditorControllerTests):\n\n    def test_handler_updates_story_summary_dicts(self):\n        self.login(self.ADMIN_EMAIL)\n\n        topic_id = topic_services.get_new_topic_id()\n        canonical_story_id = story_services.get_new_story_id()\n        additional_story_id = story_services.get_new_story_id()\n\n        # 'self.topic_id' does not contain any canonical_story_summary_dicts\n        # or additional_story_summary_dicts.\n        response = self.get_json(\n            '%s/%s' % (feconf.TOPIC_EDITOR_STORY_URL, self.topic_id))\n\n        self.assertEqual(response['canonical_story_summary_dicts'], [])\n        self.assertEqual(response['additional_story_summary_dicts'], [])\n\n        self.save_new_topic(\n            topic_id, self.admin_id, 'New name', 'New description',\n            [canonical_story_id], [additional_story_id], [self.skill_id],\n            [], 1)\n\n        self.save_new_story(\n            canonical_story_id, self.admin_id, 'title', 'description',\n            'note', topic_id)\n        self.save_new_story(\n            additional_story_id, self.admin_id, 'another title',\n            'another description', 'another note', topic_id)\n\n        response = self.get_json(\n            '%s/%s' % (feconf.TOPIC_EDITOR_STORY_URL, topic_id))\n        canonical_story_summary_dicts = response[\n            'canonical_story_summary_dicts'][0]\n        additional_story_summary_dicts = response[\n            'additional_story_summary_dicts'][0]\n\n        self.assertEqual(\n            canonical_story_summary_dicts['description'], 'description')\n        self.assertEqual(canonical_story_summary_dicts['title'], 'title')\n        self.assertEqual(\n            canonical_story_summary_dicts['id'], canonical_story_id)\n        self.assertEqual(\n            additional_story_summary_dicts['description'],\n            'another description')\n        self.assertEqual(\n            additional_story_summary_dicts['title'], 'another title')\n        self.assertEqual(\n            additional_story_summary_dicts['id'], additional_story_id)\n\n        self.logout()\n\n    def test_story_creation(self):\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        json_response = self.post_json(\n            '%s/%s' % (feconf.TOPIC_EDITOR_STORY_URL, self.topic_id),\n            {'title': 'Story title'},\n            csrf_token=csrf_token)\n        story_id = json_response['storyId']\n        self.assertEqual(len(story_id), 12)\n        self.assertIsNotNone(\n            story_services.get_story_by_id(story_id, strict=False))\n        self.logout()\n\n\nclass TopicEditorQuestionHandlerTests(BaseTopicEditorControllerTests):\n\n    def test_get(self):\n        # Create 5 questions linked to the same skill.\n        for i in range(0, 3): #pylint: disable=unused-variable\n            question_id = question_services.get_new_question_id()\n            self.save_new_question(\n                question_id, self.admin_id,\n                self._create_valid_question_data('ABC'), [self.skill_id])\n            question_services.create_new_question_skill_link(\n                self.admin_id, question_id, self.skill_id, 0.5)\n\n        self.login(self.ADMIN_EMAIL)\n        with self.swap(constants, 'NUM_QUESTIONS_PER_PAGE', 1):\n            json_response = self.get_json(\n                '%s/%s?cursor=' % (\n                    feconf.TOPIC_EDITOR_QUESTION_URL, self.topic_id\n                ))\n            question_summary_dicts = json_response['question_summary_dicts']\n            self.assertEqual(len(question_summary_dicts), 1)\n            next_start_cursor = json_response['next_start_cursor']\n            json_response = self.get_json(\n                '%s/%s?cursor=%s' % (\n                    feconf.TOPIC_EDITOR_QUESTION_URL, self.topic_id,\n                    next_start_cursor\n                ))\n            question_summary_dicts_2 = (\n                json_response['question_summary_dicts'])\n            self.assertEqual(len(question_summary_dicts_2), 1)\n            self.assertEqual(\n                question_summary_dicts[0]['skill_description'],\n                'Skill Description')\n            self.assertNotEqual(\n                question_summary_dicts[0]['summary']['id'],\n                question_summary_dicts_2[0]['summary']['id'])\n        self.logout()\n\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        self.get_json(\n            '%s/%s?cursor=' % (\n                feconf.TOPIC_EDITOR_QUESTION_URL, self.topic_id))\n        self.logout()\n\n        topic_services.assign_role(\n            self.admin, self.topic_manager, topic_domain.ROLE_MANAGER,\n            self.topic_id)\n\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        json_response = self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_QUESTION_URL, self.topic_id\n            ))\n        question_summary_dicts = json_response['question_summary_dicts']\n        self.assertEqual(len(question_summary_dicts), 3)\n        self.logout()\n\n        self.login(self.NEW_USER_EMAIL)\n        self.get_json(\n            '%s/%s?cursor=' % (\n                feconf.TOPIC_EDITOR_QUESTION_URL, self.topic_id\n            ), expected_status_int=401)\n        self.logout()\n\n\nclass SubtopicPageEditorTests(BaseTopicEditorControllerTests):\n\n    def test_get_can_not_access_handler_with_invalid_topic_id(self):\n        self.login(self.ADMIN_EMAIL)\n\n        self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, topic_services.get_new_topic_id()),\n            expected_status_int=404)\n\n        self.logout()\n\n    def test_editable_subtopic_page_get(self):\n        # Check that non-admins and non-topic managers cannot access the\n        # editable subtopic data.\n        self.login(self.NEW_USER_EMAIL)\n        self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 1), expected_status_int=401)\n        self.logout()\n\n        # Check that topic managers not assigned to this topic can\n        # access its subtopic pages.\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        json_response = self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 1))\n        self.assertEqual({\n            'subtitled_html': {\n                'html': '',\n                'content_id': 'content'\n            },\n            'content_ids_to_audio_translations': {\n                'content': {}\n            },\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {}\n                }\n            }\n        }, json_response['subtopic_page']['page_contents'])\n        self.logout()\n\n        topic_services.assign_role(\n            self.admin, self.topic_manager, topic_domain.ROLE_MANAGER,\n            self.topic_id)\n\n        # Check that topic managers can access the subtopic page.\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        json_response = self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 1))\n        self.assertEqual({\n            'subtitled_html': {\n                'html': '',\n                'content_id': 'content'\n            },\n            'content_ids_to_audio_translations': {\n                'content': {}\n            },\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {}\n                }\n            },\n        }, json_response['subtopic_page']['page_contents'])\n        self.logout()\n\n        # Check that admins can access the editable subtopic data.\n        self.login(self.ADMIN_EMAIL)\n        json_response = self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 1))\n        self.assertEqual({\n            'subtitled_html': {\n                'html': '',\n                'content_id': 'content'\n            },\n            'content_ids_to_audio_translations': {\n                'content': {}\n            },\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {}\n                }\n            }\n        }, json_response['subtopic_page']['page_contents'])\n        self.logout()\n\n\nclass TopicEditorTests(BaseTopicEditorControllerTests):\n\n    def test_get_can_not_access_topic_page_with_invalid_topic_id(self):\n        self.login(self.ADMIN_EMAIL)\n\n        self.get_html_response(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_URL_PREFIX,\n                topic_services.get_new_topic_id()), expected_status_int=404)\n\n        self.logout()\n\n    def test_access_topic_editor_page(self):\n        \"\"\"Test access to editor pages for the sample topic.\"\"\"\n\n        # Check that non-admin and topic_manager cannot access the editor\n        # page.\n        self.login(self.NEW_USER_EMAIL)\n        self.get_html_response(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id),\n            expected_status_int=401)\n        self.logout()\n\n        # Check that admins can access the editor page.\n        self.login(self.ADMIN_EMAIL)\n        self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        self.logout()\n\n        # Check that any topic manager can access the editor page.\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        self.logout()\n\n\n    def test_editable_topic_handler_get(self):\n        # Check that non-admins cannot access the editable topic data.\n        self.login(self.NEW_USER_EMAIL)\n        self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            expected_status_int=401)\n        self.logout()\n\n        # Check that admins can access the editable topic data.\n        self.login(self.ADMIN_EMAIL)\n\n        json_response = self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id))\n        self.assertEqual(self.topic_id, json_response['topic_dict']['id'])\n        self.assertEqual(\n            'Skill Description',\n            json_response['skill_id_to_description_dict'][self.skill_id])\n        self.logout()\n\n        # Check that editable topic handler is accessed only when a topic id\n        # passed has an associated topic.\n        self.login(self.ADMIN_EMAIL)\n\n        self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX,\n                topic_services.get_new_topic_id()), expected_status_int=404)\n\n        self.logout()\n\n    def test_editable_topic_handler_put_raises_error_with_invalid_name(self):\n        change_cmd = {\n            'version': 2,\n            'commit_message': 'Changed name',\n            'topic_and_subtopic_page_change_dicts': [{\n                'change_affects_subtopic_page': False,\n                'cmd': 'update_topic_property',\n                'property_name': 'name',\n                'old_value': '',\n                'new_value': 0\n            }]\n        }\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n\n        json_response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            change_cmd, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(json_response['error'], 'Name should be a string.')\n\n    def test_editable_topic_handler_put(self):\n        # Check that admins can edit a topic.\n        change_cmd = {\n            'version': 2,\n            'commit_message': 'Some changes and added a subtopic.',\n            'topic_and_subtopic_page_change_dicts': [{\n                'change_affects_subtopic_page': False,\n                'cmd': 'update_topic_property',\n                'property_name': 'name',\n                'old_value': '',\n                'new_value': 'A new name'\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_html',\n                'old_value': {\n                    'html': '',\n                    'content_id': 'content'\n                },\n                'subtopic_id': 1,\n                'new_value': {\n                    'html': '<p>New Data</p>',\n                    'content_id': 'content'\n                }\n            }, {\n                'change_affects_subtopic_page': False,\n                'cmd': 'add_subtopic',\n                'subtopic_id': 2,\n                'title': 'Title2'\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_html',\n                'old_value': {\n                    'html': '',\n                    'content_id': 'content'\n                },\n                'new_value': {\n                    'html': '<p>New Value</p>',\n                    'content_id': 'content'\n                },\n                'subtopic_id': 2\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_audio',\n                'old_value': {\n                    'content': {}\n                },\n                'new_value': {\n                    'content': {\n                        'en': {\n                            'filename': 'test.mp3',\n                            'file_size_bytes': 100,\n                            'needs_update': False\n                        }\n                    }\n                },\n                'subtopic_id': 2\n            }]\n        }\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n\n        json_response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            change_cmd, csrf_token=csrf_token)\n        self.assertEqual(self.topic_id, json_response['topic_dict']['id'])\n        self.assertEqual('A new name', json_response['topic_dict']['name'])\n        self.assertEqual(2, len(json_response['topic_dict']['subtopics']))\n        self.assertEqual(\n            'Skill Description',\n            json_response['skill_id_to_description_dict'][self.skill_id])\n\n        # Test if the corresponding subtopic pages were created.\n        json_response = self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 1))\n        self.assertEqual({\n            'subtitled_html': {\n                'html': '<p>New Data</p>',\n                'content_id': 'content'\n            },\n            'content_ids_to_audio_translations': {\n                'content': {}\n            },\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {}\n                }\n            }\n        }, json_response['subtopic_page']['page_contents'])\n        json_response = self.get_json(\n            '%s/%s/%s' % (\n                feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n                self.topic_id, 2))\n        self.assertEqual({\n            'subtitled_html': {\n                'html': '<p>New Value</p>',\n                'content_id': 'content'\n            },\n            'content_ids_to_audio_translations': {\n                'content': {\n                    'en': {\n                        'file_size_bytes': 100,\n                        'filename': 'test.mp3',\n                        'needs_update': False\n                    }\n                }\n            },\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {}\n                }\n            }\n        }, json_response['subtopic_page']['page_contents'])\n        self.logout()\n\n        # Test that any topic manager cannot edit the topic.\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            change_cmd, csrf_token=csrf_token, expected_status_int=401)\n        self.logout()\n\n        # Check that non-admins and non-topic managers cannot edit a topic.\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            change_cmd, csrf_token=csrf_token, expected_status_int=401)\n\n        # Check that topic can not be edited when version is None.\n        self.login(self.ADMIN_EMAIL)\n\n        json_response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            {'version': None}, csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(\n            json_response['error'],\n            'Invalid POST request: a version must be specified.')\n\n        self.logout()\n\n        # Check topic can not be edited when payload version differs from\n        # topic version.\n        self.login(self.ADMIN_EMAIL)\n\n        topic_id_1 = topic_services.get_new_topic_id()\n        self.save_new_topic(\n            topic_id_1, self.admin_id, 'Name 1', 'Description 1', [], [],\n            [self.skill_id], [], 1)\n\n        json_response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, topic_id_1),\n            {'version': '3'}, csrf_token=csrf_token,\n            expected_status_int=400)\n\n        self.assertEqual(\n            json_response['error'],\n            'Trying to update version 1 of topic from version 3, '\n            'which is too old. Please reload the page and try again.')\n\n        self.logout()\n\n    def test_editable_topic_handler_put_for_assigned_topic_manager(self):\n        change_cmd = {\n            'version': 2,\n            'commit_message': 'Some changes and added a subtopic.',\n            'topic_and_subtopic_page_change_dicts': [{\n                'change_affects_subtopic_page': False,\n                'cmd': 'update_topic_property',\n                'property_name': 'name',\n                'old_value': '',\n                'new_value': 'A new name'\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_html',\n                'old_value': {\n                    'html': '',\n                    'content_id': 'content'\n                },\n                'subtopic_id': 1,\n                'new_value': {\n                    'html': '<p>New Data</p>',\n                    'content_id': 'content'\n                }\n            }, {\n                'change_affects_subtopic_page': False,\n                'cmd': 'add_subtopic',\n                'subtopic_id': 2,\n                'title': 'Title2'\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_html',\n                'old_value': {\n                    'html': '',\n                    'content_id': 'content'\n                },\n                'new_value': {\n                    'html': '<p>New Value</p>',\n                    'content_id': 'content'\n                },\n                'subtopic_id': 2\n            }, {\n                'change_affects_subtopic_page': True,\n                'cmd': 'update_subtopic_page_property',\n                'property_name': 'page_contents_audio',\n                'old_value': {\n                    'content': {}\n                },\n                'new_value': {\n                    'content': {\n                        'en': {\n                            'filename': 'test.mp3',\n                            'file_size_bytes': 100,\n                            'needs_update': False\n                        }\n                    }\n                },\n                'subtopic_id': 2\n            }]\n        }\n        # Assign the topic manager to the topic.\n        topic_services.assign_role(\n            self.admin, self.topic_manager, topic_domain.ROLE_MANAGER,\n            self.topic_id)\n\n        self.login(self.TOPIC_MANAGER_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        # Check that the topic manager can edit the topic now.\n        json_response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            change_cmd, csrf_token=csrf_token)\n        self.assertEqual(self.topic_id, json_response['topic_dict']['id'])\n        self.assertEqual('A new name', json_response['topic_dict']['name'])\n        self.assertEqual(2, len(json_response['topic_dict']['subtopics']))\n        self.logout()\n\n    def test_guest_can_not_delete_topic(self):\n        response = self.delete_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            expected_status_int=401)\n        self.assertEqual(\n            response['error'],\n            'You must be logged in to access this resource.')\n\n    def test_editable_topic_handler_delete(self):\n        # Check that admins can delete a topic.\n        self.login(self.ADMIN_EMAIL)\n        self.delete_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            expected_status_int=200)\n        self.logout()\n\n        # Check that non-admins cannot delete a topic.\n        self.login(self.NEW_USER_EMAIL)\n        self.delete_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX, self.topic_id),\n            expected_status_int=401)\n        self.logout()\n\n        # Check that topic can not be deleted when the topic id passed does\n        # not have a topic associated with it.\n        self.login(self.ADMIN_EMAIL)\n\n        self.delete_json(\n            '%s/%s' % (\n                feconf.TOPIC_EDITOR_DATA_URL_PREFIX,\n                topic_services.get_new_topic_id()), expected_status_int=404)\n\n        self.logout()\n\n\nclass TopicPublishSendMailHandlerTests(BaseTopicEditorControllerTests):\n\n    def test_send_mail(self):\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        with self.swap(feconf, 'CAN_SEND_EMAILS', True):\n            self.put_json(\n                '%s/%s' % (\n                    feconf.TOPIC_SEND_MAIL_URL_PREFIX, self.topic_id),\n                {'topic_name': 'Topic Name'}, csrf_token=csrf_token)\n        messages = self.mail_stub.get_sent_messages(\n            to=feconf.ADMIN_EMAIL_ADDRESS)\n        expected_email_html_body = (\n            'wants to publish topic: Topic Name at URL %s, please review'\n            ' and publish if it looks good.'\n            % (feconf.TOPIC_EDITOR_URL_PREFIX + '/' + self.topic_id))\n        self.assertEqual(len(messages), 1)\n        self.assertIn(\n            expected_email_html_body,\n            messages[0].html.decode())\n\n\nclass TopicRightsHandlerTests(BaseTopicEditorControllerTests):\n\n    def test_get_topic_rights(self):\n        \"\"\"Test the get topic rights functionality.\"\"\"\n        self.login(self.ADMIN_EMAIL)\n        # Test whether admin can access topic rights.\n        json_response = self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_RIGHTS_URL_PREFIX, self.topic_id))\n        self.assertEqual(json_response['published'], False)\n        self.assertEqual(json_response['can_publish_topic'], True)\n        self.logout()\n\n        self.login(self.NEW_USER_EMAIL)\n        # Test that other users cannot access topic rights.\n        self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_RIGHTS_URL_PREFIX, self.topic_id),\n            expected_status_int=401)\n        self.logout()\n\n    def test_can_not_get_topic_rights_when_topic_id_has_no_associated_topic(\n            self):\n        self.login(self.ADMIN_EMAIL)\n\n        json_response = self.get_json(\n            '%s/%s' % (\n                feconf.TOPIC_RIGHTS_URL_PREFIX,\n                topic_services.get_new_topic_id()), expected_status_int=400)\n        self.assertEqual(\n            json_response['error'],\n            'Expected a valid topic id to be provided.')\n\n        self.logout()\n\n\nclass TopicPublishHandlerTests(BaseTopicEditorControllerTests):\n\n    def test_get_can_not_access_handler_with_invalid_publish_status(self):\n        self.login(self.ADMIN_EMAIL)\n\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': 'invalid_status'}, csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(\n            response['error'],\n            'Publish status should only be true or false.')\n\n        self.logout()\n\n    def test_publish_and_unpublish_topic(self):\n        \"\"\"Test the publish and unpublish functionality.\"\"\"\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        # Test whether admin can publish and unpublish a topic.\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': True}, csrf_token=csrf_token)\n        topic_rights = topic_services.get_topic_rights(self.topic_id)\n        self.assertTrue(topic_rights.topic_is_published)\n\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': False}, csrf_token=csrf_token)\n        topic_rights = topic_services.get_topic_rights(self.topic_id)\n        self.assertFalse(topic_rights.topic_is_published)\n        self.logout()\n\n        self.login(self.NEW_USER_EMAIL)\n        # Test that other users cannot access topic rights.\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': False}, csrf_token=csrf_token,\n            expected_status_int=401)\n\n        self.logout()\n\n    def test_get_can_not_access_handler_with_invalid_topic_id(self):\n        self.login(self.ADMIN_EMAIL)\n\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n\n        new_topic_id = topic_services.get_new_topic_id()\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, new_topic_id),\n            {'publish_status': True}, csrf_token=csrf_token,\n            expected_status_int=404)\n\n    def test_cannot_publish_a_published_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': True}, csrf_token=csrf_token)\n        topic_rights = topic_services.get_topic_rights(self.topic_id)\n        self.assertTrue(topic_rights.topic_is_published)\n\n        response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': True}, csrf_token=csrf_token,\n            expected_status_int=401)\n        self.assertEqual(response['error'], 'The topic is already published.')\n\n    def test_cannot_unpublish_an_unpublished_exploration(self):\n        self.login(self.ADMIN_EMAIL)\n        response = self.get_html_response(\n            '%s/%s' % (feconf.TOPIC_EDITOR_URL_PREFIX, self.topic_id))\n        csrf_token = self.get_csrf_token_from_response(response)\n        topic_rights = topic_services.get_topic_rights(self.topic_id)\n        self.assertFalse(topic_rights.topic_is_published)\n\n        response = self.put_json(\n            '%s/%s' % (\n                feconf.TOPIC_STATUS_URL_PREFIX, self.topic_id),\n            {'publish_status': False}, csrf_token=csrf_token,\n            expected_status_int=401)\n        self.assertEqual(response['error'], 'The topic is already unpublished.')\n"
    },
    {
      "filename": "feconf.py",
      "content": "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Stores various configuration options and constants for Oppia.\"\"\"\n\nimport copy\nimport datetime\nimport os\n\nfrom constants import constants  # pylint: disable=relative-import\n\n# The datastore model ID for the list of featured activity references. This\n# value should not be changed.\nACTIVITY_REFERENCE_LIST_FEATURED = 'featured'\nALL_ACTIVITY_REFERENCE_LIST_TYPES = [ACTIVITY_REFERENCE_LIST_FEATURED]\n\n# The values which a post_commit_status can have: public, private.\nPOST_COMMIT_STATUS_PUBLIC = 'public'\nPOST_COMMIT_STATUS_PRIVATE = 'private'\n\n# Whether to unconditionally log info messages.\nDEBUG = False\n\n# When DEV_MODE is true check that we are running in development environment.\n# The SERVER_SOFTWARE environment variable does not exist in Travis, hence the\n# need for an explicit check.\nif (constants.DEV_MODE and os.getenv('SERVER_SOFTWARE') and\n        not os.getenv('SERVER_SOFTWARE', default='').startswith('Development')):\n    raise Exception('DEV_MODE can\\'t be true on production.')\n\nCLASSIFIERS_DIR = os.path.join('extensions', 'classifiers')\nTESTS_DATA_DIR = os.path.join('core', 'tests', 'data')\nSAMPLE_EXPLORATIONS_DIR = os.path.join('data', 'explorations')\nSAMPLE_COLLECTIONS_DIR = os.path.join('data', 'collections')\nCONTENT_VALIDATION_DIR = os.path.join('core', 'domain')\n\n# backend_prod_files contain processed JS and HTML files that are served by\n# Jinja, we are moving away from Jinja so this folder might not be needed later\n# (#6964)\nEXTENSIONS_DIR_PREFIX = (\n    'backend_prod_files' if not constants.DEV_MODE else '')\nACTIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'actions'))\nISSUES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'issues'))\nINTERACTIONS_DIR = (\n    os.path.join('extensions', 'interactions'))\nRTE_EXTENSIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'rich_text_components'))\nRTE_EXTENSIONS_DEFINITIONS_PATH = (\n    os.path.join('assets', 'rich_text_components_definitions.js'))\n\nOBJECT_TEMPLATES_DIR = os.path.join('extensions', 'objects', 'templates')\n\n# Choose production templates folder when we are in production mode.\nif not constants.DEV_MODE:\n    FRONTEND_TEMPLATES_DIR = (\n        os.path.join('backend_prod_files', 'templates', 'head'))\nelse:\n    FRONTEND_TEMPLATES_DIR = os.path.join('core', 'templates', 'dev', 'head')\nDEPENDENCIES_TEMPLATES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'dependencies'))\n\nVALUE_GENERATORS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'value_generators')\nVALUE_GENERATORS_DIR = os.path.join('extensions', 'value_generators')\n\nVISUALIZATIONS_DIR = os.path.join(\n    'extensions', 'visualizations')\nVISUALIZATIONS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'visualizations')\n\nOBJECT_DEFAULT_VALUES_FILE_PATH = os.path.join(\n    'extensions', 'objects', 'object_defaults.json')\nRULES_DESCRIPTIONS_FILE_PATH = os.path.join(\n    os.getcwd(), 'extensions', 'interactions', 'rule_templates.json')\n\n# A mapping of interaction ids to classifier properties.\nINTERACTION_CLASSIFIER_MAPPING = {\n    'TextInput': {\n        'algorithm_id': 'TextClassifier',\n        'current_data_schema_version': 1\n    },\n    'CodeRepl': {\n        'algorithm_id': 'CodeClassifier',\n        'current_data_schema_version': 1\n    }\n}\n# Classifier job time to live (in mins).\nCLASSIFIER_JOB_TTL_MINS = 5\nTRAINING_JOB_STATUS_COMPLETE = 'COMPLETE'\nTRAINING_JOB_STATUS_FAILED = 'FAILED'\nTRAINING_JOB_STATUS_NEW = 'NEW'\nTRAINING_JOB_STATUS_PENDING = 'PENDING'\n\nALLOWED_TRAINING_JOB_STATUSES = [\n    TRAINING_JOB_STATUS_COMPLETE,\n    TRAINING_JOB_STATUS_FAILED,\n    TRAINING_JOB_STATUS_NEW,\n    TRAINING_JOB_STATUS_PENDING\n]\n\n# The maximum number of characters allowed for userbio length.\nMAX_BIO_LENGTH_IN_CHARS = 2000\n\nALLOWED_TRAINING_JOB_STATUS_CHANGES = {\n    TRAINING_JOB_STATUS_COMPLETE: [],\n    TRAINING_JOB_STATUS_NEW: [TRAINING_JOB_STATUS_PENDING],\n    TRAINING_JOB_STATUS_PENDING: [TRAINING_JOB_STATUS_COMPLETE,\n                                  TRAINING_JOB_STATUS_FAILED],\n    TRAINING_JOB_STATUS_FAILED: [TRAINING_JOB_STATUS_NEW]\n}\n\nENTITY_TYPE_EXPLORATION = 'exploration'\nENTITY_TYPE_TOPIC = 'topic'\nENTITY_TYPE_QUESTION = 'question'\n\n# The maximum number of activities allowed in the playlist of the learner. This\n# limit applies to both the explorations playlist and the collections playlist.\nMAX_LEARNER_PLAYLIST_ACTIVITY_COUNT = 10\n\n# The minimum number of training samples required for training a classifier.\nMIN_TOTAL_TRAINING_EXAMPLES = 50\n\n# The minimum number of assigned labels required for training a classifier.\nMIN_ASSIGNED_LABELS = 2\n\n# Default label for classification algorithms.\nDEFAULT_CLASSIFIER_LABEL = '_default'\n\n# The maximum number of results to retrieve in a datastore query.\nDEFAULT_QUERY_LIMIT = 1000\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library/top_rated page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FULL_PAGE = 20\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library/recently_published page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FULL_PAGE = 20\n\n# The current version of the dashboard stats blob schema. If any backward-\n# incompatible changes are made to the stats blob schema in the data store,\n# this version number must be changed.\nCURRENT_DASHBOARD_STATS_SCHEMA_VERSION = 1\n\n# The current version of the exploration states blob schema. If any backward-\n# incompatible changes are made to the states blob schema in the data store,\n# this version number must be changed and the exploration migration job\n# executed.\nCURRENT_STATE_SCHEMA_VERSION = 29\n\n# The current version of the all collection blob schemas (such as the nodes\n# structure within the Collection domain object). If any backward-incompatible\n# changes are made to any of the blob schemas in the data store, this version\n# number must be changed.\nCURRENT_COLLECTION_SCHEMA_VERSION = 6\n\n# The current version of story contents dict in the story schema.\nCURRENT_STORY_CONTENTS_SCHEMA_VERSION = 1\n\n# The current version of skill contents dict in the skill schema.\nCURRENT_SKILL_CONTENTS_SCHEMA_VERSION = 1\n\n# The current version of misconceptions dict in the skill schema.\nCURRENT_MISCONCEPTIONS_SCHEMA_VERSION = 1\n\n# The current version of subtopics dict in the topic schema.\nCURRENT_SUBTOPIC_SCHEMA_VERSION = 1\n\n# The current version of page_contents dict in the subtopic page schema.\nCURRENT_SUBTOPIC_PAGE_CONTENTS_SCHEMA_VERSION = 1\n\n# This value should be updated in the event of any\n# StateAnswersModel.submitted_answer_list schema change.\nCURRENT_STATE_ANSWERS_SCHEMA_VERSION = 1\n\n# This value should be updated if the schema of LearnerAnswerInfo\n# dict schema changes.\nCURRENT_LEARNER_ANSWER_INFO_SCHEMA_VERSION = 1\n\n# The default number of exploration tiles to load at a time in the search\n# results page.\nSEARCH_RESULTS_PAGE_SIZE = 20\n\n# The default number of commits to show on a page in the exploration history\n# tab.\nCOMMIT_LIST_PAGE_SIZE = 50\n\n# The default number of items to show on a page in the exploration feedback\n# tab.\nFEEDBACK_TAB_PAGE_SIZE = 20\n\n# The maximum number of top unresolved answers which should be aggregated\n# from all of the submitted answers.\nTOP_UNRESOLVED_ANSWERS_LIMIT = 20\n\n# Default title for a newly-minted exploration.\nDEFAULT_EXPLORATION_TITLE = ''\n# Default category for a newly-minted exploration.\nDEFAULT_EXPLORATION_CATEGORY = ''\n# Default objective for a newly-minted exploration.\nDEFAULT_EXPLORATION_OBJECTIVE = ''\n\n# NOTE TO DEVELOPERS: If any of the 5 constants below are modified, the\n# corresponding field in NEW_STATE_TEMPLATE in constants.js also has to be\n# modified.\n\n# Default name for the initial state of an exploration.\nDEFAULT_INIT_STATE_NAME = 'Introduction'\n# Default content id for the state's content.\nDEFAULT_NEW_STATE_CONTENT_ID = 'content'\n# Default content id for the interaction's default outcome.\nDEFAULT_OUTCOME_CONTENT_ID = 'default_outcome'\n# Default content id for the explanation in the concept card of a skill.\nDEFAULT_EXPLANATION_CONTENT_ID = 'explanation'\n# Default recorded_voiceovers dict for a default state template.\nDEFAULT_RECORDED_VOICEOVERS = {\n    'voiceovers_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# Default written_translations dict for a default state template.\nDEFAULT_WRITTEN_TRANSLATIONS = {\n    'translations_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# The default content text for the initial state of an exploration.\nDEFAULT_INIT_STATE_CONTENT_STR = ''\n\n# Whether new explorations should have automatic text-to-speech enabled\n# by default.\nDEFAULT_AUTO_TTS_ENABLED = True\n\n# Default title for a newly-minted collection.\nDEFAULT_COLLECTION_TITLE = ''\n# Default category for a newly-minted collection.\nDEFAULT_COLLECTION_CATEGORY = ''\n# Default objective for a newly-minted collection.\nDEFAULT_COLLECTION_OBJECTIVE = ''\n\n# Default description for a newly-minted story.\nDEFAULT_STORY_DESCRIPTION = ''\n# Default notes for a newly-minted story.\nDEFAULT_STORY_NOTES = ''\n\n# Default explanation for a newly-minted skill.\nDEFAULT_SKILL_EXPLANATION = ''\n# Default name for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NAME = ''\n# Default notes for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NOTES = ''\n# Default feedback for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_FEEDBACK = ''\n# Default content_id for explanation subtitled html.\nDEFAULT_SKILL_EXPLANATION_CONTENT_ID = 'explanation'\n\n# Default description for a newly-minted topic.\nDEFAULT_TOPIC_DESCRIPTION = ''\n# Default content id for the subtopic page's content.\nDEFAULT_SUBTOPIC_PAGE_CONTENT_ID = 'content'\n\n# Default ID of VM which is used for training classifier.\nDEFAULT_VM_ID = 'vm_default'\n# Shared secret key for default VM.\nDEFAULT_VM_SHARED_SECRET = '1a2b3c4e'\n\n# An array containing the accepted image formats (as determined by the imghdr\n# module) and the corresponding allowed extensions in the filenames of uploaded\n# images.\nACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS = {\n    'jpeg': ['jpg', 'jpeg'],\n    'png': ['png'],\n    'gif': ['gif'],\n}\n\n# An array containing the accepted audio extensions for uploaded files and\n# the corresponding MIME types.\nACCEPTED_AUDIO_EXTENSIONS = {\n    'mp3': ['audio/mp3']\n}\n\n# Prefix for data sent from the server to the client via JSON.\nXSSI_PREFIX = ')]}\\'\\n'\n# A regular expression for alphanumeric characters.\nALPHANUMERIC_REGEX = r'^[A-Za-z0-9]+$'\n# A regular expression for tags.\nTAG_REGEX = r'^[a-z ]+$'\n\n# Invalid names for parameters used in expressions.\nAUTOMATICALLY_SET_PARAMETER_NAMES = ['answer', 'choices']\nINVALID_PARAMETER_NAMES = AUTOMATICALLY_SET_PARAMETER_NAMES + [\n    'abs', 'all', 'and', 'any', 'else', 'floor', 'if', 'log', 'or',\n    'pow', 'round', 'then']\n\n# These are here rather than in rating_services.py to avoid import\n# circularities with exp_services.\n# TODO (Jacob) Refactor exp_services to remove this problem.\n_EMPTY_RATINGS = {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}\n\n\ndef get_empty_ratings():\n    \"\"\"Returns a copy of the empty ratings object.\n\n    Returns:\n        dict. Copy of the '_EMPTY_RATINGS' dict object which contains the empty\n            ratings.\n    \"\"\"\n    return copy.deepcopy(_EMPTY_RATINGS)\n\n\n# Empty scaled average rating as a float.\nEMPTY_SCALED_AVERAGE_RATING = 0.0\n\n# To use GAE email service.\nEMAIL_SERVICE_PROVIDER_GAE = 'gae_email_service'\n# To use mailgun email service.\nEMAIL_SERVICE_PROVIDER_MAILGUN = 'mailgun_email_service'\n# Use GAE email service by default.\nEMAIL_SERVICE_PROVIDER = EMAIL_SERVICE_PROVIDER_GAE\n# If the Mailgun email API is used, the \"None\" below should be replaced\n# with the Mailgun API key.\nMAILGUN_API_KEY = None\n# If the Mailgun email API is used, the \"None\" below should be replaced\n# with the Mailgun domain name (ending with mailgun.org).\nMAILGUN_DOMAIN_NAME = None\n\n# Committer id for system actions.\nSYSTEM_COMMITTER_ID = 'admin'\n# Domain name for email address.\nINCOMING_EMAILS_DOMAIN_NAME = 'example.com'\nSYSTEM_EMAIL_ADDRESS = 'system@example.com'\nSYSTEM_EMAIL_NAME = '.'\nADMIN_EMAIL_ADDRESS = 'testadmin@example.com'\nNOREPLY_EMAIL_ADDRESS = 'noreply@example.com'\n# Ensure that SYSTEM_EMAIL_ADDRESS and ADMIN_EMAIL_ADDRESS are both valid and\n# correspond to owners of the app before setting this to True. If\n# SYSTEM_EMAIL_ADDRESS is not that of an app owner, email messages from this\n# address cannot be sent. If True then emails can be sent to any user.\nCAN_SEND_EMAILS = False\n# If you want to turn on this facility please check the email templates in the\n# send_role_notification_email() function in email_manager.py and modify them\n# accordingly.\nCAN_SEND_EDITOR_ROLE_EMAILS = False\n# If enabled then emails will be sent to creators for feedback messages.\nCAN_SEND_FEEDBACK_MESSAGE_EMAILS = False\n# If enabled subscription emails will be sent to that user.\nCAN_SEND_SUBSCRIPTION_EMAILS = False\n# Time to wait before sending feedback message emails (currently set to 1\n# hour).\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_COUNTDOWN_SECS = 3600\n# Whether to send an email when new feedback message is received for\n# an exploration.\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_PREFERENCE = True\n# Whether to send an email to all the creator's subscribers when he/she\n# publishes an exploration.\nDEFAULT_SUBSCRIPTION_EMAIL_PREFERENCE = True\n# Whether exploration feedback emails are muted,\n# when the user has not specified a preference.\nDEFAULT_FEEDBACK_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether exploration suggestion emails are muted,\n# when the user has not specified a preference.\nDEFAULT_SUGGESTION_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether to send email updates to a user who has not specified a preference.\nDEFAULT_EMAIL_UPDATES_PREFERENCE = False\n# Whether to send an invitation email when the user is granted\n# new role permissions in an exploration.\nDEFAULT_EDITOR_ROLE_EMAIL_PREFERENCE = True\n# Whether to require an email to be sent, following a moderator action.\nREQUIRE_EMAIL_ON_MODERATOR_ACTION = False\n# Timespan in minutes before allowing duplicate emails.\nDUPLICATE_EMAIL_INTERVAL_MINS = 2\n# Number of digits after decimal to which the average ratings value in the\n# dashboard is rounded off to.\nAVERAGE_RATINGS_DASHBOARD_PRECISION = 2\n# Whether to enable maintenance mode on the site. For non-admins, this redirects\n# all HTTP requests to the maintenance page. This is the only check which\n# determines whether the site is in maintenance mode to avoid queries to the\n# database by non-admins.\nENABLE_MAINTENANCE_MODE = False\n\n# The interactions permissible for a question.\nALLOWED_QUESTION_INTERACTION_IDS = [\n    'TextInput', 'MultipleChoiceInput', 'NumericInput']\n\n# Flag to disable sending emails related to reviews for suggestions. To be\n# flipped after deciding (and implementing) whether a user should be scored\n# only for curated lessons.\nSEND_SUGGESTION_REVIEW_RELATED_EMAILS = False\n# To prevent recording scores for users until details like whether to score\n# users for only curated lessons is confirmed.\nENABLE_RECORDING_OF_SCORES = False\n\n# No. of pretest questions to display.\nNUM_PRETEST_QUESTIONS = 3\n\n# Whether to automatically accept suggestions after a threshold time.\nENABLE_AUTO_ACCEPT_OF_SUGGESTIONS = False\n\nEMAIL_INTENT_SIGNUP = 'signup'\nEMAIL_INTENT_DAILY_BATCH = 'daily_batch'\nEMAIL_INTENT_EDITOR_ROLE_NOTIFICATION = 'editor_role_notification'\nEMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION = 'feedback_message_notification'\nEMAIL_INTENT_SUBSCRIPTION_NOTIFICATION = 'subscription_notification'\nEMAIL_INTENT_SUGGESTION_NOTIFICATION = 'suggestion_notification'\nEMAIL_INTENT_REPORT_BAD_CONTENT = 'report_bad_content'\nEMAIL_INTENT_MARKETING = 'marketing'\nEMAIL_INTENT_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nEMAIL_INTENT_DELETE_EXPLORATION = 'delete_exploration'\nEMAIL_INTENT_QUERY_STATUS_NOTIFICATION = 'query_status_notification'\nEMAIL_INTENT_ONBOARD_REVIEWER = 'onboard_reviewer'\nEMAIL_INTENT_REVIEW_SUGGESTIONS = 'review_suggestions'\n# Possible intents for email sent in bulk.\nBULK_EMAIL_INTENT_MARKETING = 'bulk_email_marketing'\nBULK_EMAIL_INTENT_IMPROVE_EXPLORATION = 'bulk_email_improve_exploration'\nBULK_EMAIL_INTENT_CREATE_EXPLORATION = 'bulk_email_create_exploration'\nBULK_EMAIL_INTENT_CREATOR_REENGAGEMENT = 'bulk_email_creator_reengagement'\nBULK_EMAIL_INTENT_LEARNER_REENGAGEMENT = 'bulk_email_learner_reengagement'\nBULK_EMAIL_INTENT_TEST = 'bulk_email_test'\n\nMESSAGE_TYPE_FEEDBACK = 'feedback'\nMESSAGE_TYPE_SUGGESTION = 'suggestion'\n\nMODERATOR_ACTION_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nDEFAULT_SALUTATION_HTML_FN = (\n    lambda recipient_username: 'Hi %s,' % recipient_username)\nDEFAULT_SIGNOFF_HTML_FN = (\n    lambda sender_username: (\n        'Thanks!<br>%s (Oppia moderator)' % sender_username))\n\nVALID_MODERATOR_ACTIONS = {\n    MODERATOR_ACTION_UNPUBLISH_EXPLORATION: {\n        'email_config': 'unpublish_exploration_email_html_body',\n        'email_subject_fn': (\n            lambda exp_title: (\n                'Your Oppia exploration \"%s\" has been unpublished' % exp_title)\n        ),\n        'email_intent': 'unpublish_exploration',\n        'email_salutation_html_fn': DEFAULT_SALUTATION_HTML_FN,\n        'email_signoff_html_fn': DEFAULT_SIGNOFF_HTML_FN,\n    },\n}\n\n# When the site terms were last updated, in UTC.\nREGISTRATION_PAGE_LAST_UPDATED_UTC = datetime.datetime(2015, 10, 14, 2, 40, 0)\n\n# Format of string for dashboard statistics logs.\n# NOTE TO DEVELOPERS: This format should not be changed, since it is used in\n# the existing storage models for UserStatsModel.\nDASHBOARD_STATS_DATETIME_STRING_FORMAT = '%Y-%m-%d'\n\n# The maximum size of an uploaded file, in bytes.\nMAX_FILE_SIZE_BYTES = 1048576\n\n# The maximum playback length of an audio file, in seconds.\nMAX_AUDIO_FILE_LENGTH_SEC = 300\n\n# The maximum number of questions to be fetched at one time.\nMAX_QUESTIONS_FETCHABLE_AT_ONE_TIME = 20\n\n# The minimum score required for a user to review suggestions of a particular\n# category.\nMINIMUM_SCORE_REQUIRED_TO_REVIEW = 10\n\n# The prefix for an 'accepted suggestion' commit message.\nCOMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX = 'Accepted suggestion by'\n\n# User id and username for exploration migration bot. Commits made by this bot\n# are not reflected in the exploration summary models, but are recorded in the\n# exploration commit log.\nMIGRATION_BOT_USER_ID = 'OppiaMigrationBot'\nMIGRATION_BOT_USERNAME = 'OppiaMigrationBot'\n\n# User id and username for suggestion bot. This bot will be used to accept\n# suggestions automatically after a threshold time.\nSUGGESTION_BOT_USER_ID = 'OppiaSuggestionBot'\nSUGGESTION_BOT_USERNAME = 'OppiaSuggestionBot'\n\n# Ids and locations of the permitted extensions.\nALLOWED_RTE_EXTENSIONS = {\n    'Collapsible': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Collapsible')\n    },\n    'Image': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Image')\n    },\n    'Link': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Link')\n    },\n    'Math': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Math')\n    },\n    'Tabs': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Tabs')\n    },\n    'Video': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Video')\n    },\n}\n\n# The list of interaction IDs which correspond to interactions that set their\n# is_linear property to true. Linear interactions do not support branching and\n# thus only allow for default answer classification. This value is guarded by a\n# test in extensions.interactions.base_test.\nLINEAR_INTERACTION_IDS = ['Continue']\n\n# Demo explorations to load through the admin panel. The id assigned to each\n# exploration is based on the key of the exploration in this dict, so ensure it\n# doesn't change once it's in the list. Only integer-based indices should be\n# used in this list, as it maintains backward compatibility with how demo\n# explorations used to be assigned IDs. The value of each entry in this dict is\n# either a YAML file or a directory (depending on whether it ends in .yaml).\n# These explorations can be found under data/explorations.\nDEMO_EXPLORATIONS = {\n    u'0': 'welcome.yaml',\n    u'1': 'multiples.yaml',\n    u'2': 'binary_search',\n    u'3': 'root_linear_coefficient_theorem.yaml',\n    u'4': 'three_balls',\n    # TODO(bhenning): Replace demo exploration '5' with a new exploration\n    # described in #1376.\n    u'6': 'boot_verbs.yaml',\n    u'7': 'hola.yaml',\n    u'8': 'adventure.yaml',\n    u'9': 'pitch_perfect.yaml',\n    u'10': 'test_interactions',\n    u'11': 'modeling_graphs',\n    u'12': 'protractor_test_1.yaml',\n    u'13': 'solar_system',\n    u'14': 'about_oppia.yaml',\n    u'15': 'classifier_demo_exploration.yaml',\n    u'16': 'all_interactions',\n    u'17': 'audio_test',\n    u'18': 'code_classifier_test.yaml',\n    u'19': 'example_exploration_in_collection1.yaml',\n    u'20': 'example_exploration_in_collection2.yaml',\n    u'21': 'example_exploration_in_collection3.yaml',\n    u'22': 'protractor_mobile_test_exploration.yaml',\n    u'23': 'rating_test.yaml',\n    u'24': 'learner_flow_test.yaml',\n    u'25': 'exploration_player_test.yaml',\n}\n\nDEMO_COLLECTIONS = {\n    u'0': 'welcome_to_collections.yaml',\n    u'1': 'learner_flow_test_collection.yaml'\n}\n\n# IDs of explorations which should not be displayable in either the learner or\n# editor views.\nDISABLED_EXPLORATION_IDS = ['5']\n\n# Oppia Google Group URL.\nGOOGLE_GROUP_URL = (\n    'https://groups.google.com/forum/?place=forum/oppia#!forum/oppia')\n\n# External URL for the Foundation site.\nFOUNDATION_SITE_URL = 'http://oppiafoundation.org'\n\n# Prefix for all taskqueue-related URLs.\nTASKQUEUE_URL_PREFIX = '/task'\nTASK_URL_FEEDBACK_MESSAGE_EMAILS = (\n    '%s/email/batchfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FEEDBACK_STATUS_EMAILS = (\n    '%s/email/feedbackthreadstatuschangeemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FLAG_EXPLORATION_EMAILS = (\n    '%s/email/flagexplorationemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_INSTANT_FEEDBACK_EMAILS = (\n    '%s/email/instantfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_SUGGESTION_EMAILS = (\n    '%s/email/suggestionemailhandler' % TASKQUEUE_URL_PREFIX)\n\n# TODO(sll): Add all other URLs here.\nADMIN_URL = '/admin'\nADMIN_ROLE_HANDLER_URL = '/adminrolehandler'\nCOLLECTION_DATA_URL_PREFIX = '/collection_handler/data'\nCOLLECTION_EDITOR_DATA_URL_PREFIX = '/collection_editor_handler/data'\nCOLLECTION_SUMMARIES_DATA_URL = '/collectionsummarieshandler/data'\nCOLLECTION_RIGHTS_PREFIX = '/collection_editor_handler/rights'\nCOLLECTION_PUBLISH_PREFIX = '/collection_editor_handler/publish'\nCOLLECTION_UNPUBLISH_PREFIX = '/collection_editor_handler/unpublish'\nCOLLECTION_EDITOR_URL_PREFIX = '/collection_editor/create'\nCOLLECTION_URL_PREFIX = '/collection'\nCONCEPT_CARD_DATA_URL_PREFIX = '/concept_card_handler'\nCREATOR_DASHBOARD_DATA_URL = '/creatordashboardhandler/data'\nCREATOR_DASHBOARD_URL = '/creator_dashboard'\nCUSTOM_NONPROFITS_LANDING_PAGE_URL = '/nonprofits'\nCUSTOM_PARENTS_LANDING_PAGE_URL = '/parents'\nCUSTOM_PARTNERS_LANDING_PAGE_URL = '/partners'\nCUSTOM_TEACHERS_LANDING_PAGE_URL = '/teachers'\nCUSTOM_VOLUNTEERS_LANDING_PAGE_URL = '/volunteers'\nDASHBOARD_CREATE_MODE_URL = '%s?mode=create' % CREATOR_DASHBOARD_URL\nEDITOR_URL_PREFIX = '/create'\nEXPLORATION_DATA_PREFIX = '/createhandler/data'\nEXPLORATION_FEATURES_PREFIX = '/explorehandler/features'\nEXPLORATION_INIT_URL_PREFIX = '/explorehandler/init'\nEXPLORATION_METADATA_SEARCH_URL = '/exploration/metadata_search'\nEXPLORATION_PRETESTS_URL_PREFIX = '/pretest_handler'\nEXPLORATION_RIGHTS_PREFIX = '/createhandler/rights'\nEXPLORATION_STATE_ANSWER_STATS_PREFIX = '/createhandler/state_answer_stats'\nEXPLORATION_STATUS_PREFIX = '/createhandler/status'\nEXPLORATION_SUMMARIES_DATA_URL = '/explorationsummarieshandler/data'\nEXPLORATION_URL_PREFIX = '/explore'\nEXPLORATION_URL_EMBED_PREFIX = '/embed/exploration'\nFEEDBACK_STATS_URL_PREFIX = '/feedbackstatshandler'\nFEEDBACK_THREAD_URL_PREFIX = '/threadhandler'\nFEEDBACK_THREADLIST_URL_PREFIX = '/threadlisthandler'\nFEEDBACK_THREADLIST_URL_PREFIX_FOR_TOPICS = '/threadlisthandlerfortopic'\nFEEDBACK_THREAD_VIEW_EVENT_URL = '/feedbackhandler/thread_view_event'\nFLAG_EXPLORATION_URL_PREFIX = '/flagexplorationhandler'\nFRACTIONS_LANDING_PAGE_URL = '/fractions'\nTOPIC_LANDING_PAGE_URL = '/learn/<subject>/<topic>'\nLEARNER_DASHBOARD_URL = '/learner_dashboard'\nLEARNER_DASHBOARD_DATA_URL = '/learnerdashboardhandler/data'\nLEARNER_DASHBOARD_IDS_DATA_URL = '/learnerdashboardidshandler/data'\nLEARNER_DASHBOARD_FEEDBACK_THREAD_DATA_URL = '/learnerdashboardthreadhandler'\nLEARNER_PLAYLIST_DATA_URL = '/learnerplaylistactivityhandler'\nLEARNER_INCOMPLETE_ACTIVITY_DATA_URL = '/learnerincompleteactivityhandler'\nLIBRARY_GROUP_DATA_URL = '/librarygrouphandler'\nLIBRARY_INDEX_URL = '/library'\nLIBRARY_INDEX_DATA_URL = '/libraryindexhandler'\nLIBRARY_RECENTLY_PUBLISHED_URL = '/library/recently_published'\nLIBRARY_SEARCH_URL = '/search/find'\nLIBRARY_SEARCH_DATA_URL = '/searchhandler/data'\nLIBRARY_TOP_RATED_URL = '/library/top_rated'\nMERGE_SKILLS_URL = '/merge_skills_handler'\nNEW_COLLECTION_URL = '/collection_editor_handler/create_new'\nNEW_EXPLORATION_URL = '/contributehandler/create_new'\nNEW_QUESTION_URL = '/question_editor_handler/create_new'\nNEW_SKILL_URL = '/skill_editor_handler/create_new'\nTOPIC_EDITOR_STORY_URL = '/topic_editor_story_handler'\nTOPIC_EDITOR_QUESTION_URL = '/topic_editor_question_handler'\nNEW_TOPIC_URL = '/topic_editor_handler/create_new'\nNOTIFICATIONS_DASHBOARD_URL = '/notifications_dashboard'\nPREFERENCES_URL = '/preferences'\nPRACTICE_SESSION_URL_PREFIX = '/practice_session'\nPRACTICE_SESSION_DATA_URL_PREFIX = '/practice_session/data'\nPREFERENCES_DATA_URL = '/preferenceshandler/data'\nQUESTION_EDITOR_DATA_URL_PREFIX = '/question_editor_handler/data'\nQUESTION_SKILL_LINK_URL_PREFIX = '/manage_question_skill_link'\nQUESTIONS_URL_PREFIX = '/question_player_handler'\nRECENT_COMMITS_DATA_URL = '/recentcommitshandler/recent_commits'\nRECENT_FEEDBACK_MESSAGES_DATA_URL = '/recent_feedback_messages'\nREVIEW_TEST_DATA_URL_PREFIX = '/review_test_handler/data'\nREVIEW_TEST_URL_PREFIX = '/review_test'\nROBOTS_TXT_URL = '/robots.txt'\nSITE_LANGUAGE_DATA_URL = '/save_site_language'\nSIGNUP_DATA_URL = '/signuphandler/data'\nSIGNUP_URL = '/signup'\nSKILL_EDITOR_DATA_URL_PREFIX = '/skill_editor_handler/data'\nSKILL_EDITOR_URL_PREFIX = '/skill_editor'\nSKILL_EDITOR_QUESTION_URL = '/skill_editor_question_handler'\nSKILL_RIGHTS_URL_PREFIX = '/skill_editor_handler/rights'\nSKILL_PUBLISH_URL_PREFIX = '/skill_editor_handler/publish_skill'\nSPLASH_URL = '/splash'\nSTORY_DATA_HANDLER = '/story_data_handler'\nSTORY_EDITOR_URL_PREFIX = '/story_editor'\nSTORY_EDITOR_DATA_URL_PREFIX = '/story_editor_handler/data'\nSTORY_NODE_COMPLETION_URL_PREFIX = '/story_node_completion_handler'\nSTORY_VIEWER_URL_PREFIX = '/story'\nSUBTOPIC_DATA_HANDLER = '/subtopic_data_handler'\nSUGGESTION_ACTION_URL_PREFIX = '/suggestionactionhandler'\nSUGGESTION_LIST_URL_PREFIX = '/suggestionlisthandler'\nSUGGESTION_URL_PREFIX = '/suggestionhandler'\nSUBSCRIBE_URL_PREFIX = '/subscribehandler'\nSUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX = '/subtopic_page_editor_handler/data'\nTOPIC_VIEWER_URL_PREFIX = '/topic'\nTOPIC_DATA_HANDLER = '/topic_data_handler'\nTOPIC_EDITOR_DATA_URL_PREFIX = '/topic_editor_handler/data'\nTOPIC_EDITOR_URL_PREFIX = '/topic_editor'\nTOPIC_RIGHTS_URL_PREFIX = '/rightshandler/get_topic_rights'\nTOPIC_SEND_MAIL_URL_PREFIX = '/rightshandler/send_topic_publish_mail'\nTOPIC_STATUS_URL_PREFIX = '/rightshandler/change_topic_status'\nTOPICS_AND_SKILLS_DASHBOARD_DATA_URL = '/topics_and_skills_dashboard/data'\nTOPICS_AND_SKILLS_DASHBOARD_URL = '/topics_and_skills_dashboard'\nUNSUBSCRIBE_URL_PREFIX = '/unsubscribehandler'\nUPLOAD_EXPLORATION_URL = '/contributehandler/upload'\nUSER_EXPLORATION_EMAILS_PREFIX = '/createhandler/notificationpreferences'\nUSERNAME_CHECK_DATA_URL = '/usernamehandler/data'\nVOICEOVER_DATA_PREFIX = '/createhandler/voiceover'\n\n# Event types.\nEVENT_TYPE_ALL_STATS = 'all_stats'\nEVENT_TYPE_STATE_HIT = 'state_hit'\nEVENT_TYPE_STATE_COMPLETED = 'state_complete'\nEVENT_TYPE_ANSWER_SUBMITTED = 'answer_submitted'\nEVENT_TYPE_DEFAULT_ANSWER_RESOLVED = 'default_answer_resolved'\nEVENT_TYPE_NEW_THREAD_CREATED = 'feedback_thread_created'\nEVENT_TYPE_THREAD_STATUS_CHANGED = 'feedback_thread_status_changed'\nEVENT_TYPE_RATE_EXPLORATION = 'rate_exploration'\nEVENT_TYPE_SOLUTION_HIT = 'solution_hit'\nEVENT_TYPE_LEAVE_FOR_REFRESHER_EXP = 'leave_for_refresher_exp'\n# The values for these event types should be left as-is for backwards\n# compatibility.\nEVENT_TYPE_START_EXPLORATION = 'start'\nEVENT_TYPE_ACTUAL_START_EXPLORATION = 'actual_start'\nEVENT_TYPE_MAYBE_LEAVE_EXPLORATION = 'leave'\nEVENT_TYPE_COMPLETE_EXPLORATION = 'complete'\n\n# Play type constants.\nPLAY_TYPE_PLAYTEST = 'playtest'\nPLAY_TYPE_NORMAL = 'normal'\n\n# Predefined commit messages.\nCOMMIT_MESSAGE_EXPLORATION_DELETED = 'Exploration deleted.'\nCOMMIT_MESSAGE_COLLECTION_DELETED = 'Collection deleted.'\nCOMMIT_MESSAGE_QUESTION_DELETED = 'Question deleted.'\nCOMMIT_MESSAGE_SKILL_DELETED = 'Skill deleted.'\nCOMMIT_MESSAGE_STORY_DELETED = 'Story deleted.'\nCOMMIT_MESSAGE_SUBTOPIC_PAGE_DELETED = 'Subtopic page deleted.'\nCOMMIT_MESSAGE_TOPIC_DELETED = 'Topic deleted.'\n\n# Max number of playthroughs for an issue.\nMAX_PLAYTHROUGHS_FOR_ISSUE = 5\n\n# Unfinished features.\nSHOW_TRAINABLE_UNRESOLVED_ANSWERS = False\n# Number of unresolved answers to be displayed in the dashboard for each\n# exploration.\nTOP_UNRESOLVED_ANSWERS_COUNT_DASHBOARD = 3\n# Number of open feedback to be displayed in the dashboard for each exploration.\nOPEN_FEEDBACK_COUNT_DASHBOARD = 3\n# NOTE TO DEVELOPERS: This should be synchronized with App.js.\nENABLE_ML_CLASSIFIERS = False\nSHOW_COLLECTION_NAVIGATION_TAB_HISTORY = False\nSHOW_COLLECTION_NAVIGATION_TAB_STATS = False\n\n# The regular expression used to identify whether a string contains float value.\n# The regex must match with regex that is stored in vmconf.py file of Oppia-ml.\n# If this regex needs to be modified then first of all shutdown Oppia-ml VM.\n# Then update the regex constant in here and Oppia both.\n# Run any migration job that is required to migrate existing trained models\n# before starting Oppia-ml again.\nFLOAT_VERIFIER_REGEX = (\n    '^([-+]?\\\\d*\\\\.\\\\d+)$|^([-+]?(\\\\d*\\\\.?\\\\d+|\\\\d+\\\\.?\\\\d*)e[-+]?\\\\d*)$')\n\n# Current event models schema version. All event models with an\n# event_schema_version of 1 are the events collected before the rework of the\n# statistics framework which brought about the recording of new event models;\n# these models include all models recorded before Feb 2018.\nCURRENT_EVENT_MODELS_SCHEMA_VERSION = 2\n\n# Output formats of downloaded explorations.\nOUTPUT_FORMAT_JSON = 'json'\nOUTPUT_FORMAT_ZIP = 'zip'\n\n# Types of updates shown in the 'recent updates' table in the dashboard page.\nUPDATE_TYPE_EXPLORATION_COMMIT = 'exploration_commit'\nUPDATE_TYPE_COLLECTION_COMMIT = 'collection_commit'\nUPDATE_TYPE_FEEDBACK_MESSAGE = 'feedback_thread'\n\n# Possible values for user query status.\n# Valid status transitions are: processing --> completed --> archived\n# or processing --> failed.\nUSER_QUERY_STATUS_PROCESSING = 'processing'\nUSER_QUERY_STATUS_COMPLETED = 'completed'\nUSER_QUERY_STATUS_ARCHIVED = 'archived'\nUSER_QUERY_STATUS_FAILED = 'failed'\n\n# The time difference between which to consider two login events \"close\". This\n# is taken to be 12 hours.\nPROXIMAL_TIMEDELTA_SECS = 12 * 60 * 60\n\n# The i18n id for the header of the \"Featured Activities\" category in the\n# library index page.\nLIBRARY_CATEGORY_FEATURED_ACTIVITIES = 'I18N_LIBRARY_GROUPS_FEATURED_ACTIVITIES'\n# The i18n id for the header of the \"Top Rated Explorations\" category in the\n# library index page.\nLIBRARY_CATEGORY_TOP_RATED_EXPLORATIONS = (\n    'I18N_LIBRARY_GROUPS_TOP_RATED_EXPLORATIONS')\n# The i18n id for the header of the \"Recently Published\" category in the\n# library index page.\nLIBRARY_CATEGORY_RECENTLY_PUBLISHED = 'I18N_LIBRARY_GROUPS_RECENTLY_PUBLISHED'\n\n# The group name that appears at the end of the url for the recently published\n# page.\nLIBRARY_GROUP_RECENTLY_PUBLISHED = 'recently_published'\n# The group name that appears at the end of the url for the top rated page.\nLIBRARY_GROUP_TOP_RATED = 'top_rated'\n\n# Defaults for topic similarities.\nDEFAULT_TOPIC_SIMILARITY = 0.5\nSAME_TOPIC_SIMILARITY = 1.0\n\n# The following are all page descriptions for the meta tag.\nCONTACT_PAGE_DESCRIPTION = (\n    'Contact the Oppia team, submit feedback, and learn how to get involved '\n    'with the Oppia project.')\nCREATE_PAGE_DESCRIPTION = (\n    'Help others learn new things. Create lessons through explorations and '\n    'share your knowledge with the community.')\nCREATOR_DASHBOARD_PAGE_DESCRIPTION = (\n    'Keep track of the lessons you have created, as well as feedback from '\n    'learners.')\nDONATE_PAGE_DESCRIPTION = (\n    'Donate to The Oppia Foundation.')\nLIBRARY_GROUP_PAGE_DESCRIPTION = (\n    'Discover top-rated or recently-published explorations on Oppia. Learn '\n    'from these explorations or help improve an existing one for the '\n    'community.')\nLIBRARY_PAGE_DESCRIPTION = (\n    'Looking to learn something new? Find explorations created by professors, '\n    'teachers and Oppia users in a subject you\\'re interested in, and start '\n    'exploring!')\nPREFERENCES_PAGE_DESCRIPTION = (\n    'Change your Oppia profile settings and preferences')\nSEARCH_PAGE_DESCRIPTION = (\n    'Discover a new exploration to learn from, or help improve an existing '\n    'one for the community.')\nSIGNUP_PAGE_DESCRIPTION = (\n    'Sign up for Oppia and begin exploring a new subject.')\nTHANKS_PAGE_DESCRIPTION = (\n    'Thank you for donating to The Oppia Foundation.')\n\n# The type of the response returned by a handler when an exception is raised.\nHANDLER_TYPE_HTML = 'html'\nHANDLER_TYPE_JSON = 'json'\nHANDLER_TYPE_DOWNLOADABLE = 'downloadable'\n\n# Following are the constants for the role IDs.\nROLE_ID_GUEST = 'GUEST'\nROLE_ID_BANNED_USER = 'BANNED_USER'\nROLE_ID_EXPLORATION_EDITOR = 'EXPLORATION_EDITOR'\nROLE_ID_COLLECTION_EDITOR = 'COLLECTION_EDITOR'\nROLE_ID_TOPIC_MANAGER = 'TOPIC_MANAGER'\nROLE_ID_MODERATOR = 'MODERATOR'\nROLE_ID_ADMIN = 'ADMIN'\n\n# Intent of the User making query to role structure via admin interface. Used\n# to store audit data regarding queries to role IDs.\nROLE_ACTION_UPDATE = 'update'\nROLE_ACTION_VIEW_BY_USERNAME = 'view_by_username'\nROLE_ACTION_VIEW_BY_ROLE = 'view_by_role'\n\nVIEW_METHOD_ROLE = 'role'\nVIEW_METHOD_USERNAME = 'username'\n\nQUESTION_BATCH_SIZE = 10\n\nSTATE_ANSWER_STATS_MIN_FREQUENCY = 2\n\nRTE_FORMAT_TEXTANGULAR = 'text-angular'\n\nRTE_FORMAT_CKEDITOR = 'ck-editor'\n\n# RTE content specifications according to the type of the editor.\nRTE_CONTENT_SPEC = {\n    'RTE_TYPE_TEXTANGULAR': {\n        # Valid parent-child relation in TextAngular.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', 'div', 'pre', '[document]', 'ol', 'ul', 'li'],\n            'b': ['i', 'li', 'p', 'pre'],\n            'br': ['b', 'i', 'li', 'p'],\n            'i': ['b', 'li', 'p', 'pre'],\n            'li': ['ol', 'ul'],\n            'ol': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'ul': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-collapsible': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-video': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-tabs': ['b', 'i', 'li', 'p', 'pre']\n        },\n        # Valid html tags in TextAngular.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'b',\n            'br',\n            'i',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n    },\n    'RTE_TYPE_CKEDITOR': {\n        # Valid parent-child relation in CKEditor.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', '[document]', 'li'],\n            'strong': ['em', 'li', 'p', 'pre'],\n            'em': ['strong', 'li', 'p', 'pre'],\n            'br': ['strong', 'em', 'li', 'p'],\n            'li': ['ol', 'ul'],\n            'ol': ['li', 'blockquote', 'pre', '[document]'],\n            'ul': ['li', 'blockquote', 'pre', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', 'li', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-collapsible': [\n                'blockquote', 'li', '[document]'\n            ],\n            'oppia-noninteractive-video': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-tabs': ['blockquote', 'li', '[document]']\n        },\n        # Valid html tags in CKEditor.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'strong',\n            'br',\n            'em',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n\n    }\n}\n\n# A dict representing available landing pages, having subject as a key and list\n# of topics as the value.\n# Note: This dict needs to be keep in sync with frontend TOPIC_LANDING_PAGE_DATA\n# oppia constant defined in\n# core/templates/dev/head/pages/landing-pages/TopicLandingPage.js file.\nAVAILABLE_LANDING_PAGES = {\n    'maths': ['fractions', 'negative-numbers', 'ratios']\n}\n"
    },
    {
      "filename": "main.py",
      "content": "# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"URL routing definitions, and some basic error/warmup handlers.\"\"\"\n\nimport logging\n\n# pylint: disable=relative-import\nfrom constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import admin\nfrom core.controllers import base\nfrom core.controllers import classifier\nfrom core.controllers import collection_editor\nfrom core.controllers import collection_viewer\nfrom core.controllers import concept_card_viewer\nfrom core.controllers import creator_dashboard\nfrom core.controllers import custom_landing_pages\nfrom core.controllers import editor\nfrom core.controllers import email_dashboard\nfrom core.controllers import features\nfrom core.controllers import feedback\nfrom core.controllers import learner_dashboard\nfrom core.controllers import learner_playlist\nfrom core.controllers import library\nfrom core.controllers import moderator\nfrom core.controllers import pages\nfrom core.controllers import practice_sessions\nfrom core.controllers import profile\nfrom core.controllers import question_editor\nfrom core.controllers import reader\nfrom core.controllers import recent_commits\nfrom core.controllers import resources\nfrom core.controllers import review_tests\nfrom core.controllers import skill_editor\nfrom core.controllers import story_editor\nfrom core.controllers import story_viewer\nfrom core.controllers import subscriptions\nfrom core.controllers import subtopic_viewer\nfrom core.controllers import suggestion\nfrom core.controllers import topic_editor\nfrom core.controllers import topic_viewer\nfrom core.controllers import topics_and_skills_dashboard\nfrom core.controllers import voice_artist\nfrom core.domain import user_services\nfrom core.platform import models\nimport feconf\n\nfrom mapreduce import main as mapreduce_main\nfrom mapreduce import parameters as mapreduce_parameters\nimport webapp2\nfrom webapp2_extras import routes\n\n# pylint: enable=relative-import\n\n\ncurrent_user_services = models.Registry.import_current_user_services()\ntransaction_services = models.Registry.import_transaction_services()\n\n\nclass FrontendErrorHandler(base.BaseHandler):\n    \"\"\"Handles errors arising from the frontend.\"\"\"\n\n    REQUIRE_PAYLOAD_CSRF_CHECK = False\n\n    @acl_decorators.open_access\n    def post(self):\n        \"\"\"Records errors reported by the frontend.\"\"\"\n        logging.error('Frontend error: %s' % self.payload.get('error'))\n        self.render_json(self.values)\n\n\nclass WarmupPage(base.BaseHandler):\n    \"\"\"Handles warmup requests.\"\"\"\n\n    @acl_decorators.open_access\n    def get(self):\n        \"\"\"Handles GET warmup requests.\"\"\"\n        pass\n\n\nclass HomePageRedirectPage(base.BaseHandler):\n    \"\"\"When a request is made to '/', check the user's login status, and\n    redirect them appropriately.\n    \"\"\"\n    @acl_decorators.open_access\n    def get(self):\n        if self.user_id and user_services.has_fully_registered(self.user_id):\n            user_settings = user_services.get_user_settings(\n                self.user_id)\n            default_dashboard = user_settings.default_dashboard\n            if default_dashboard == constants.DASHBOARD_TYPE_CREATOR:\n                self.redirect(feconf.CREATOR_DASHBOARD_URL)\n            else:\n                self.redirect(feconf.LEARNER_DASHBOARD_URL)\n        else:\n            self.redirect(feconf.SPLASH_URL)\n\n\ndef get_redirect_route(regex_route, handler, defaults=None):\n    \"\"\"Returns a route that redirects /foo/ to /foo.\n\n    Warning: this method strips off parameters after the trailing slash. URLs\n    with parameters should be formulated without the trailing slash.\n    \"\"\"\n    if defaults is None:\n        defaults = {}\n    name = regex_route.replace('/', '_')\n    return routes.RedirectRoute(\n        regex_route, handler, name, strict_slash=True, defaults=defaults)\n\n\ndef authorization_wrapper(self, *args, **kwargs):\n    \"\"\"This request handler wrapper only admits internal requests from\n    taskqueue workers. If the request is invalid, it leads to a 403 Error page.\n    \"\"\"\n    # Internal requests should have an \"X-AppEngine-TaskName\" header\n    # (see cloud.google.com/appengine/docs/standard/python/taskqueue/push/).\n    if 'X-AppEngine-TaskName' not in self.request.headers:\n        self.response.out.write('Forbidden')\n        self.response.set_status(403)\n        return\n    self.real_dispatch(*args, **kwargs)\n\n\ndef ui_access_wrapper(self, *args, **kwargs):\n    \"\"\"This request handler wrapper directly serves UI pages\n    for MapReduce dashboards.\n    \"\"\"\n    self.real_dispatch(*args, **kwargs)\n\n\nMAPREDUCE_HANDLERS = []\n\nfor path, handler_class in mapreduce_main.create_handlers_map():\n    if path.startswith('.*/pipeline'):\n        if 'pipeline/rpc/' in path or path == '.*/pipeline(/.+)':\n            path = path.replace('.*/pipeline', '/mapreduce/ui/pipeline')\n        else:\n            path = path.replace('.*/pipeline', '/mapreduce/worker/pipeline')\n    else:\n        if '_callback' in path:\n            path = path.replace('.*', '/mapreduce/worker', 1)\n        elif '/list_configs' in path:\n            continue\n        else:\n            path = path.replace('.*', '/mapreduce/ui', 1)\n\n    if '/ui/' in path or path.endswith('/ui'):\n        if (hasattr(handler_class, 'dispatch') and\n                not hasattr(handler_class, 'real_dispatch')):\n            handler_class.real_dispatch = handler_class.dispatch\n            handler_class.dispatch = ui_access_wrapper\n        MAPREDUCE_HANDLERS.append((path, handler_class))\n    else:\n        if (hasattr(handler_class, 'dispatch') and\n                not hasattr(handler_class, 'real_dispatch')):\n            handler_class.real_dispatch = handler_class.dispatch\n            handler_class.dispatch = authorization_wrapper\n        MAPREDUCE_HANDLERS.append((path, handler_class))\n\n# Tell map/reduce internals that this is now the base path to use.\nmapreduce_parameters.config.BASE_PATH = '/mapreduce/worker'\n\n# Register the URLs with the classes responsible for handling them.\nURLS = MAPREDUCE_HANDLERS + [\n    get_redirect_route(r'/_ah/warmup', WarmupPage),\n    get_redirect_route(r'/', HomePageRedirectPage),\n\n    get_redirect_route(feconf.SPLASH_URL, pages.SplashPage),\n    get_redirect_route(r'/about', pages.AboutPage),\n    get_redirect_route(r'/get_started', pages.GetStartedPage),\n    get_redirect_route(r'/foundation', pages.FoundationRedirectPage),\n    get_redirect_route(r'/credits', pages.AboutRedirectPage),\n    get_redirect_route(r'/teach', pages.TeachPage),\n    get_redirect_route(r'/participate', pages.TeachRedirectPage),\n    get_redirect_route(r'/site_guidelines', pages.TeachRedirectPage),\n    get_redirect_route(r'/console_errors', pages.ConsoleErrorPage),\n    get_redirect_route(r'/contact', pages.ContactPage),\n\n    get_redirect_route(r'/forum', pages.ForumRedirectPage),\n    get_redirect_route(r'/donate', pages.DonatePage),\n    get_redirect_route(r'/thanks', pages.ThanksPage),\n    get_redirect_route(r'/terms', pages.TermsPage),\n    get_redirect_route(r'/privacy', pages.PrivacyPage),\n\n    get_redirect_route(r'%s' % feconf.ADMIN_URL, admin.AdminPage),\n    get_redirect_route(r'/adminhandler', admin.AdminHandler),\n    get_redirect_route(r'/adminrolehandler', admin.AdminRoleHandler),\n    get_redirect_route(r'/adminjoboutput', admin.AdminJobOutputHandler),\n    get_redirect_route(\n        r'/admintopicscsvdownloadhandler',\n        admin.AdminTopicsCsvFileDownloader),\n\n    get_redirect_route(\n        feconf.NOTIFICATIONS_DASHBOARD_URL,\n        creator_dashboard.NotificationsDashboardPage),\n    get_redirect_route(\n        r'/notificationsdashboardhandler/data',\n        creator_dashboard.NotificationsDashboardHandler),\n    get_redirect_route(\n        r'/notificationshandler', creator_dashboard.NotificationsHandler),\n    get_redirect_route(\n        r'%s' % feconf.CREATOR_DASHBOARD_URL,\n        creator_dashboard.CreatorDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.CREATOR_DASHBOARD_DATA_URL,\n        creator_dashboard.CreatorDashboardHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_EXPLORATION_URL,\n        creator_dashboard.NewExplorationHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_COLLECTION_URL,\n        creator_dashboard.NewCollectionHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_SKILL_URL,\n        topics_and_skills_dashboard.NewSkillHandler),\n    get_redirect_route(\n        r'%s/<comma_separated_skill_ids>' % feconf.NEW_QUESTION_URL,\n        question_editor.QuestionCreationHandler),\n    get_redirect_route(\n        r'%s/<topic_name>' % feconf.PRACTICE_SESSION_URL_PREFIX,\n        practice_sessions.PracticeSessionsPage),\n    get_redirect_route(\n        r'%s/<topic_name>' % feconf.PRACTICE_SESSION_DATA_URL_PREFIX,\n        practice_sessions.PracticeSessionsPageDataHandler),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.REVIEW_TEST_DATA_URL_PREFIX,\n        review_tests.ReviewTestsPageDataHandler),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.REVIEW_TEST_URL_PREFIX,\n        review_tests.ReviewTestsPage),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.STORY_DATA_HANDLER,\n        story_viewer.StoryPageDataHandler),\n    get_redirect_route(\n        r'%s/<story_id>/<node_id>' % feconf.STORY_NODE_COMPLETION_URL_PREFIX,\n        story_viewer.StoryNodeCompletionHandler),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.STORY_VIEWER_URL_PREFIX,\n        story_viewer.StoryPage),\n    get_redirect_route(\n        r'%s/<topic_id>/<subtopic_id>' %\n        feconf.SUBTOPIC_DATA_HANDLER,\n        subtopic_viewer.SubtopicPageDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_STORY_URL,\n        topic_editor.TopicEditorStoryHandler),\n    get_redirect_route(\n        r'%s/<topic_name>' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        topic_viewer.TopicViewerPage),\n    get_redirect_route(\n        r'%s/<topic_name>' % feconf.TOPIC_DATA_HANDLER,\n        topic_viewer.TopicPageDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_QUESTION_URL,\n        topic_editor.TopicEditorQuestionHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_TOPIC_URL,\n        topics_and_skills_dashboard.NewTopicHandler),\n    get_redirect_route(\n        r'%s' % feconf.UPLOAD_EXPLORATION_URL,\n        creator_dashboard.UploadExplorationHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_URL,\n        learner_dashboard.LearnerDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_DATA_URL,\n        learner_dashboard.LearnerDashboardHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_IDS_DATA_URL,\n        learner_dashboard.LearnerDashboardIdsHandler),\n    get_redirect_route(\n        r'%s/<thread_id>' %\n        feconf.LEARNER_DASHBOARD_FEEDBACK_THREAD_DATA_URL,\n        learner_dashboard.LearnerDashboardFeedbackThreadHandler),\n    get_redirect_route(\n        r'%s' % feconf.TOPICS_AND_SKILLS_DASHBOARD_URL,\n        topics_and_skills_dashboard.TopicsAndSkillsDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.MERGE_SKILLS_URL,\n        topics_and_skills_dashboard.MergeSkillHandler),\n    get_redirect_route(\n        r'%s' % feconf.TOPICS_AND_SKILLS_DASHBOARD_DATA_URL,\n        topics_and_skills_dashboard.TopicsAndSkillsDashboardPageDataHandler),\n\n    get_redirect_route(\n        r'%s/<activity_type>/<activity_id>' %\n        feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL,\n        reader.LearnerIncompleteActivityHandler),\n\n    get_redirect_route(\n        r'%s/<activity_type>/<activity_id>' % feconf.LEARNER_PLAYLIST_DATA_URL,\n        learner_playlist.LearnerPlaylistHandler),\n\n    get_redirect_route(\n        r'/assetsdevhandler/<exploration_id>/'\n        'assets/<asset_type:(image|audio)>/<encoded_filename>',\n        resources.AssetDevHandler),\n    get_redirect_route(\n        r'/value_generator_handler/<generator_id>',\n        resources.ValueGeneratorHandler),\n    get_redirect_route(r'/promo_bar_handler', resources.PromoBarHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.FRACTIONS_LANDING_PAGE_URL,\n        custom_landing_pages.FractionLandingRedirectPage),\n    get_redirect_route(\n        r'%s' % feconf.TOPIC_LANDING_PAGE_URL,\n        custom_landing_pages.TopicLandingPage),\n    get_redirect_route(\n        r'%s' % feconf.CUSTOM_PARENTS_LANDING_PAGE_URL,\n        custom_landing_pages.StewardsLandingPage),\n    get_redirect_route(\n        r'%s' % feconf.CUSTOM_PARTNERS_LANDING_PAGE_URL,\n        custom_landing_pages.StewardsLandingPage),\n    get_redirect_route(\n        r'%s' % feconf.CUSTOM_NONPROFITS_LANDING_PAGE_URL,\n        custom_landing_pages.StewardsLandingPage),\n    get_redirect_route(\n        r'%s' % feconf.CUSTOM_TEACHERS_LANDING_PAGE_URL,\n        custom_landing_pages.StewardsLandingPage),\n    get_redirect_route(\n        r'%s' % feconf.CUSTOM_VOLUNTEERS_LANDING_PAGE_URL,\n        custom_landing_pages.StewardsLandingPage),\n\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_INDEX_URL, library.LibraryPage),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_INDEX_DATA_URL, library.LibraryIndexHandler),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_RECENTLY_PUBLISHED_URL,\n        library.LibraryGroupPage),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_TOP_RATED_URL, library.LibraryGroupPage),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_GROUP_DATA_URL,\n        library.LibraryGroupIndexHandler),\n    get_redirect_route(r'%s' % feconf.LIBRARY_SEARCH_URL, library.LibraryPage),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_SEARCH_DATA_URL, library.SearchHandler),\n    get_redirect_route(r'/gallery', library.LibraryRedirectPage),\n    get_redirect_route(r'/contribute', library.LibraryRedirectPage),\n    get_redirect_route(r'/learn', library.LibraryRedirectPage),\n    get_redirect_route(r'/playtest', library.LibraryRedirectPage),\n    get_redirect_route(\n        feconf.EXPLORATION_SUMMARIES_DATA_URL,\n        library.ExplorationSummariesHandler),\n    get_redirect_route(\n        feconf.COLLECTION_SUMMARIES_DATA_URL,\n        library.CollectionSummariesHandler),\n\n    get_redirect_route(r'/profile/<username>', profile.ProfilePage),\n    get_redirect_route(\n        r'/profilehandler/data/<username>', profile.ProfileHandler),\n    get_redirect_route(feconf.PREFERENCES_URL, profile.PreferencesPage),\n    get_redirect_route(\n        feconf.PREFERENCES_DATA_URL, profile.PreferencesHandler),\n    get_redirect_route(\n        r'/preferenceshandler/profile_picture', profile.ProfilePictureHandler),\n    get_redirect_route(\n        r'/preferenceshandler/profile_picture_by_username/<username>',\n        profile.ProfilePictureHandlerByUsernameHandler),\n    get_redirect_route(r'%s' % feconf.SIGNUP_URL, profile.SignupPage),\n    get_redirect_route(r'%s' % feconf.SIGNUP_DATA_URL, profile.SignupHandler),\n    get_redirect_route(\n        r'%s' % feconf.USERNAME_CHECK_DATA_URL, profile.UsernameCheckHandler),\n    get_redirect_route(\n        r'%s' % feconf.SITE_LANGUAGE_DATA_URL, profile.SiteLanguageHandler),\n    get_redirect_route(r'/userinfohandler', profile.UserInfoHandler),\n    get_redirect_route(r'/url_handler', profile.UrlHandler),\n    get_redirect_route(r'/moderator', moderator.ModeratorPage),\n    get_redirect_route(\n        r'/moderatorhandler/featured', moderator.FeaturedActivitiesHandler),\n    get_redirect_route(\n        r'/moderatorhandler/email_draft', moderator.EmailDraftHandler),\n\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_URL_PREFIX,\n        reader.ExplorationPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_URL_EMBED_PREFIX,\n        reader.ExplorationEmbedPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_INIT_URL_PREFIX,\n        reader.ExplorationHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_PRETESTS_URL_PREFIX,\n        reader.PretestHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_FEATURES_PREFIX,\n        features.ExplorationFeaturesHandler),\n    get_redirect_route(\n        '/explorehandler/exploration_start_event/<exploration_id>',\n        reader.ExplorationStartEventHandler),\n    get_redirect_route(\n        '/explorehandler/exploration_actual_start_event/<exploration_id>',\n        reader.ExplorationActualStartEventHandler),\n    get_redirect_route(\n        '/explorehandler/solution_hit_event/<exploration_id>',\n        reader.SolutionHitEventHandler),\n    get_redirect_route(\n        r'/explorehandler/state_hit_event/<exploration_id>',\n        reader.StateHitEventHandler),\n    get_redirect_route(\n        r'/explorehandler/state_complete_event/<exploration_id>',\n        reader.StateCompleteEventHandler),\n    get_redirect_route(\n        r'/explorehandler/leave_for_refresher_exp_event/<exploration_id>',\n        reader.LeaveForRefresherExpEventHandler),\n    get_redirect_route(\n        r'/explorehandler/answer_submitted_event/<exploration_id>',\n        reader.AnswerSubmittedEventHandler),\n    get_redirect_route(\n        r'/explorehandler/give_feedback/<exploration_id>',\n        reader.ReaderFeedbackHandler),\n    get_redirect_route(\n        r'/explorehandler/exploration_complete_event/<exploration_id>',\n        reader.ExplorationCompleteEventHandler),\n    get_redirect_route(\n        r'/explorehandler/exploration_maybe_leave_event/<exploration_id>',\n        reader.ExplorationMaybeLeaveHandler),\n    get_redirect_route(\n        r'/explorehandler/stats_events/<exploration_id>',\n        reader.StatsEventsHandler),\n    get_redirect_route(\n        r'/explorehandler/store_playthrough/<exploration_id>',\n        reader.StorePlaythroughHandler),\n    get_redirect_route(\n        r'/explorehandler/rating/<exploration_id>', reader.RatingHandler),\n    get_redirect_route(\n        r'/explorehandler/recommendations/<exploration_id>',\n        reader.RecommendationsHandler),\n\n    get_redirect_route(\n        r'%s/<question_id>' % feconf.QUESTION_EDITOR_DATA_URL_PREFIX,\n        question_editor.EditableQuestionDataHandler),\n\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EDITOR_URL_PREFIX,\n        editor.ExplorationPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_DATA_PREFIX,\n        editor.ExplorationHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.VOICEOVER_DATA_PREFIX,\n        voice_artist.ExplorationVoiceoverHandler),\n    get_redirect_route(\n        r'/createhandler/download/<exploration_id>',\n        editor.ExplorationFileDownloader),\n    get_redirect_route(\n        r'/createhandler/imageupload/<exploration_id>',\n        editor.ImageUploadHandler),\n    get_redirect_route(\n        r'/createhandler/audioupload/<exploration_id>',\n        voice_artist.AudioUploadHandler),\n    get_redirect_route(\n        r'/createhandler/state_yaml/<exploration_id>',\n        editor.StateYamlHandler),\n    get_redirect_route(\n        r'/createhandler/revert/<exploration_id>',\n        editor.ExplorationRevertHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_RIGHTS_PREFIX,\n        editor.ExplorationRightsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_STATUS_PREFIX,\n        editor.ExplorationStatusHandler),\n    get_redirect_route(\n        r'/createhandler/moderatorrights/<exploration_id>',\n        editor.ExplorationModeratorRightsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.USER_EXPLORATION_EMAILS_PREFIX,\n        editor.UserExplorationEmailsHandler),\n    get_redirect_route(\n        r'/createhandler/snapshots/<exploration_id>',\n        editor.ExplorationSnapshotsHandler),\n    get_redirect_route(\n        r'/createhandler/statistics/<exploration_id>',\n        editor.ExplorationStatisticsHandler),\n    get_redirect_route(\n        r'/createhandler/state_rules_stats/<exploration_id>/<escaped_state_name>',  # pylint: disable=line-too-long\n        editor.StateRulesStatsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_STATE_ANSWER_STATS_PREFIX,\n        editor.StateAnswerStatisticsHandler),\n    get_redirect_route(\n        r'/createhandler/started_tutorial_event/<exploration_id>',\n        editor.StartedTutorialEventHandler),\n    get_redirect_route(\n        r'/createhandler/started_translation_tutorial_event/<exploration_id>',\n        voice_artist.StartedTranslationTutorialEventHandler),\n    get_redirect_route(\n        r'/createhandler/autosave_draft/<exploration_id>',\n        editor.EditorAutosaveHandler),\n    get_redirect_route(\n        r'/createhandler/autosave_voiceover_draft/<exploration_id>',\n        voice_artist.VoiceArtistAutosaveHandler),\n    get_redirect_route(\n        r'/createhandler/get_top_unresolved_answers/<exploration_id>',\n        editor.TopUnresolvedAnswersHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.RECENT_COMMITS_DATA_URL,\n        recent_commits.RecentCommitsHandler),\n    get_redirect_route(\n        r'%s' % feconf.RECENT_FEEDBACK_MESSAGES_DATA_URL,\n        feedback.RecentFeedbackMessagesHandler),\n\n    get_redirect_route(\n        r'%s/<thread_id>' % feconf.FEEDBACK_THREAD_VIEW_EVENT_URL,\n        feedback.FeedbackThreadViewEventHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FEEDBACK_THREADLIST_URL_PREFIX,\n        feedback.ThreadListHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.FEEDBACK_THREADLIST_URL_PREFIX_FOR_TOPICS,\n        feedback.ThreadListHandlerForTopicsHandler),\n    get_redirect_route(\n        r'%s/<thread_id>' % feconf.FEEDBACK_THREAD_URL_PREFIX,\n        feedback.ThreadHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FEEDBACK_STATS_URL_PREFIX,\n        feedback.FeedbackStatsHandler),\n    get_redirect_route(\n        r'%s/' % feconf.SUGGESTION_URL_PREFIX,\n        suggestion.SuggestionHandler),\n    get_redirect_route(\n        r'%s' % feconf.QUESTIONS_URL_PREFIX,\n        reader.QuestionPlayerHandler),\n    get_redirect_route(\n        r'%s/exploration/<target_id>/<suggestion_id>' %\n        feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.SuggestionToExplorationActionHandler),\n    get_redirect_route(\n        r'%s/resubmit/<suggestion_id>' % feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.ResubmitSuggestionHandler),\n    get_redirect_route(\n        r'%s/topic/<target_id>/<suggestion_id>' %\n        feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.SuggestionToTopicActionHandler),\n    get_redirect_route(\n        r'%s' % feconf.SUGGESTION_LIST_URL_PREFIX,\n        suggestion.SuggestionListHandler),\n    get_redirect_route(\n        r'%s' % feconf.SUBSCRIBE_URL_PREFIX,\n        subscriptions.SubscribeHandler),\n    get_redirect_route(\n        r'%s' % feconf.UNSUBSCRIBE_URL_PREFIX,\n        subscriptions.UnsubscribeHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FLAG_EXPLORATION_URL_PREFIX,\n        reader.FlagExplorationHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_URL_PREFIX,\n        collection_viewer.CollectionPage),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_DATA_URL_PREFIX,\n        collection_viewer.CollectionDataHandler),\n\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_EDITOR_URL_PREFIX,\n        collection_editor.CollectionEditorPage),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_EDITOR_DATA_URL_PREFIX,\n        collection_editor.EditableCollectionDataHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_RIGHTS_PREFIX,\n        collection_editor.CollectionRightsHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_PUBLISH_PREFIX,\n        collection_editor.CollectionPublishHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_UNPUBLISH_PREFIX,\n        collection_editor.CollectionUnpublishHandler),\n\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_URL_PREFIX,\n        topic_editor.TopicEditorPage),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_DATA_URL_PREFIX,\n        topic_editor.EditableTopicDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>/<subtopic_id>' %\n        feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n        topic_editor.EditableSubtopicPageDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_RIGHTS_URL_PREFIX,\n        topic_editor.TopicRightsHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_STATUS_URL_PREFIX,\n        topic_editor.TopicPublishHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_SEND_MAIL_URL_PREFIX,\n        topic_editor.TopicPublishSendMailHandler),\n\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.CONCEPT_CARD_DATA_URL_PREFIX,\n        concept_card_viewer.ConceptCardDataHandler),\n    get_redirect_route(\n        r'%s/<question_id>/<skill_id>' % feconf.QUESTION_SKILL_LINK_URL_PREFIX,\n        question_editor.QuestionSkillLinkHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_EDITOR_URL_PREFIX,\n        skill_editor.SkillEditorPage),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_EDITOR_QUESTION_URL,\n        skill_editor.SkillEditorQuestionHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_EDITOR_DATA_URL_PREFIX,\n        skill_editor.EditableSkillDataHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_RIGHTS_URL_PREFIX,\n        skill_editor.SkillRightsHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_PUBLISH_URL_PREFIX,\n        skill_editor.SkillPublishHandler),\n\n    get_redirect_route(\n        r'%s/<topic_id>/<story_id>' % feconf.STORY_EDITOR_URL_PREFIX,\n        story_editor.StoryEditorPage),\n    get_redirect_route(\n        r'%s/<topic_id>/<story_id>' % feconf.STORY_EDITOR_DATA_URL_PREFIX,\n        story_editor.EditableStoryDataHandler),\n\n    get_redirect_route(r'/emaildashboard', email_dashboard.EmailDashboardPage),\n    get_redirect_route(\n        r'/emaildashboarddatahandler',\n        email_dashboard.EmailDashboardDataHandler),\n    get_redirect_route(\n        r'/querystatuscheck', email_dashboard.QueryStatusCheckHandler),\n    get_redirect_route(\n        r'/emaildashboardresult/<query_id>',\n        email_dashboard.EmailDashboardResultPage),\n    get_redirect_route(\n        r'/emaildashboardcancelresult/<query_id>',\n        email_dashboard.EmailDashboardCancelEmailHandler),\n    get_redirect_route(\n        r'/emaildashboardtestbulkemailhandler/<query_id>',\n        email_dashboard.EmailDashboardTestBulkEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.EXPLORATION_METADATA_SEARCH_URL,\n        collection_editor.ExplorationMetadataSearchHandler),\n    get_redirect_route(\n        r'/explorationdataextractionhandler', admin.DataExtractionQueryHandler),\n    get_redirect_route(r'/frontend_errors', FrontendErrorHandler),\n    get_redirect_route(r'/logout', base.LogoutPage),\n\n    get_redirect_route(\n        r'/issuesdatahandler/<exploration_id>', editor.FetchIssuesHandler),\n\n    get_redirect_route(\n        r'/ml/trainedclassifierhandler', classifier.TrainedClassifierHandler),\n    get_redirect_route(\n        r'/ml/nextjobhandler', classifier.NextJobHandler),\n\n    get_redirect_route(\n        r'/playthroughdatahandler/<exploration_id>/<playthrough_id>',\n        editor.FetchPlaythroughHandler),\n\n    get_redirect_route(\n        r'/resolveissuehandler/<exploration_id>', editor.ResolveIssueHandler),\n\n    # 404 error handler.\n    get_redirect_route(r'/<:.*>', base.Error404Handler),\n]\n\nURLS_TO_SERVE = []\n\nif (feconf.ENABLE_MAINTENANCE_MODE and\n        not current_user_services.is_current_user_super_admin()):\n    # Show only the maintenance mode page.\n    URLS_TO_SERVE = [\n        get_redirect_route(r'%s' % feconf.ADMIN_URL, admin.AdminPage),\n        get_redirect_route(r'/adminhandler', admin.AdminHandler),\n        get_redirect_route(r'/adminrolehandler', admin.AdminRoleHandler),\n        get_redirect_route(r'/adminjoboutput', admin.AdminJobOutputHandler),\n        get_redirect_route(\n            r'/admintopicscsvdownloadhandler',\n            admin.AdminTopicsCsvFileDownloader),\n        get_redirect_route(r'/<:.*>', pages.MaintenancePage)]\nelse:\n    URLS_TO_SERVE = URLS\n\napp = transaction_services.toplevel_wrapper(  # pylint: disable=invalid-name\n    webapp2.WSGIApplication(URLS_TO_SERVE, debug=feconf.DEBUG))\n"
    }
  ],
  "questions": [],
  "golden_answers": [],
  "questions_generated": [
    "What is the current functionality of the linter regarding keyword arguments in the oppia_oppia repository?",
    "What change is being proposed for the linter in the oppia_oppia repository?",
    "What are the two possibilities discussed for handling named positional arguments in the oppia_oppia codebase?",
    "What arguments are made for and against allowing named positional arguments in the oppia_oppia codebase?",
    "How does the community propose to address the readability issue introduced by named positional arguments?",
    "In the context of the oppia_oppia codebase, how might decorators like 'open_access' interact with the proposed linter changes?"
  ],
  "golden_answers_generated": [
    "The current functionality of the linter in the oppia_oppia repository is to report when the args-name is not mentioned for a keyword argument. This is reported as a 'non-explicit-keyword-args' message by Pylint.",
    "The proposed change is to extend the linter's functionality to also report cases where args-names are used for non-keyword arguments. This aims to enforce consistent naming conventions for arguments in function calls.",
    "The two possibilities discussed are: (a) enforce names for all positional arguments, or (b) disallow names for all positional arguments. There is a preference for consistent application of either approach throughout the codebase.",
    "Arguments for allowing named positional arguments include improved readability and reduced need to look up function definitions. Arguments against include potential overhead and a preference for consistent use of argument naming conventions.",
    "The community suggests providing guidelines for naming positional arguments to enhance readability without mandating strict all-or-nothing conventions. This approach emphasizes balancing readability with flexibility for developers.",
    "Decorators like 'open_access' could be impacted by the proposed linter changes if they use named positional arguments. The linter would report such usages if the change is implemented to disallow names for positional arguments, potentially requiring updates to these decorators for compliance."
  ]
}