{
  "repo_name": "oppia_oppia",
  "issue_id": "5280",
  "issue_description": "# Add auto-scrolling mechanism in the Drag and Drop interaction\n\nThe current `Drag and Drop Sort` interaction requires automatic scrolling in the Drag and drop editor so that the editor is automatically scrolled up and down when the learner is dragging the tile. Automatic scrolling has already been implemented but is not working on Oppia. So, debugging is required to find out the possible cause behind the bug.\r\n\r\n### Repro Steps:\r\n* Open Creator Dashboard and click 'Create' button to create new exploration.\r\n* From the interactions modal, choose `Drag and Drop Sort` interaction.\r\n* Add around 7 - 8 choices in the interaction so that they don't fit into the max sized div element.\r\n* Try to drag an item beyond the boundaries of the div element.\r\n\r\n### Expected behaviour:\r\nIt should trigger the auto-scrolling event so that it can be scrolled automatically.\r\n\r\n### Observed behaviour:\r\nNo such event is triggered and the learner has to scroll manually. See nothing happens when an item is dragged out of the boundaries.\r\n![screen shot 2018-08-01 at 4 44 24 pm](https://user-images.githubusercontent.com/26625980/43518627-4fdabe92-95aa-11e8-950a-ecb8cdfa972b.png)\r\n\r\n### Impact on usability:\r\nIf the item size is too large (in case of images) or there are more than 6 items, they won't fit into the max. sized div element and so, the learner has to manually scroll until this issue is fixed.\r\n\r\n### Few approaches already tried:\r\nSee `angular-ui-tree` [doc](https://github.com/angular-ui-tree/angular-ui-tree/blob/master/README.md) to read about how `data-scroll-container` attribute is working and its demo implementation. The auto-scrolling is working fine if we run the code independently but not after integrating it with Oppia.\r\n* Changed the class name of the element to ensure that it's not overridden by some other class. But concluded that the `data-scroll-container` attribute is not getting override anywhere.\r\n* Added separate `div` tag for just the drag and drop container in HTML.\r\n* Removed different tags in the HTML to ensure if anything is hindering in its path.\r\n* Added CSS to make the drag and drop element `overflow: scroll`. It made manual scrolling possible but not auto-scrolling.\r\n* Referred links: [#49](https://github.com/angular-ui-tree/angular-ui-tree/issues/49) ; [#814](https://github.com/angular-ui-tree/angular-ui-tree/pull/814). There is not much about the issue on Stack Overflow.\r\n",
  "issue_comments": [
    {
      "id": 409427923,
      "user": "prasanna08",
      "body": "Hi @vibhor98,\r\n\r\ncan you update this issue with following details:\r\n* Repro instructions and screenshots\r\n* Impact of this issue on usability on desktop and mobile devices.\r\n* The approaches that you have tried and have failed to solve the problem.\r\n* The possible cause(s) of the problem (if you have found any).\r\n* The part of documentation of angular-ui-tree where auto-scrolling is mentioned.\r\n* Any GitHub issues / stackoverflow links that you visited when solving this problem.\r\n* Anything else that you think is important to mention since this is very important issue."
    },
    {
      "id": 409540602,
      "user": "vibhor98",
      "body": "Hi @prasanna08, I've updated the issue. "
    },
    {
      "id": 409698689,
      "user": "seanlip",
      "body": "I think you might want to dig into the third-party code (it's open source) to understand how data-scroll-container works. You can then perhaps find a way to introspect what element it's being applied to. \r\n\r\nAlso, by examining the third-party code and looking at the case that works (the demo implementation), could you provide, in this issue thread, a step-by-step breakdown of the actions and events that should happen, in sequence, when you perform a drag-beyond-boundaries action? We can then examine what happens in the Oppia case and compare it to this expected list of actions."
    },
    {
      "id": 409838246,
      "user": "vibhor98",
      "body": "Sounds like a good approach! I'll update you shortly. Thanks!"
    },
    {
      "id": 409992163,
      "user": "vibhor98",
      "body": "Following are the series of actions that take place as soon as the dragging starts:\r\n1. The scope of the dragged element is created.\r\n2. It keeps a watch on the `scrollContainer` variable to get its value if its a string.\r\n3. Then, while dragging it keeps the track of the cursor position.\r\n4. If cursor's y-coordinate is less than starting coordinate of the container, scroll top event is triggered and similar thing happens for scroll down case.\r\n5. If the `scrollContainer` has `null` value (if the attribute isn't defined in Html tag), then the scroll event takes place for the entire window using `window.scrollBy()` method.\r\n\r\nFor reference, please see this [patch](https://github.com/angular-ui-tree/angular-ui-tree/pull/814/files) that incorporates the auto-scrolling mechanism. "
    },
    {
      "id": 410017798,
      "user": "seanlip",
      "body": "Ok, good start. So next step is to log what scrollContainer is, as well as\nits dimensions, then compare to what you would expect them to be. Are they\ncorrect?\n\nI can think of several failure cases: wrong element is selected as\nscrollContainer, scroll container boundary extends beyond what you see\nvisually, etc. Now that you have a breakdown, try and done deeper into it.\n"
    },
    {
      "id": 410454281,
      "user": "vibhor98",
      "body": "Understanding third party code was not easy for me. But still this is what I could dig out:\r\n* `scrollContainer` just contains the CSS class of the container in which scrolling happens. Like: `.drag-and-drop-sort-container` in our case.\r\n* Then the element corresponding to this class is extracted using `document.querySelector`.\r\n* The exact position of the element is find out by using `getBoundingClientRect()` method. This method gives the left, right, top and bottom coordinates of the selected element and its position relative to the viewport.\r\n* I think this is the root cause of the issue. In Oppia, this method gives zeros in all the cases. While it should give the exact position of the element in viewport as it is giving in case of demo implementation. I'm not sure why this is happening right now but probably its fix can solve our problem."
    },
    {
      "id": 410475915,
      "user": "seanlip",
      "body": "That's great, @vibhor98! This is definitely a path towards solving the problem, and as you say, understanding why getBoundingClientRect() is doing what it's doing (and finding a way to get it to do the right thing) should help. In order to do this you will probably need to read up a bit more on what getBoundingClientRect() does, too."
    },
    {
      "id": 410491209,
      "user": "prasanna08",
      "body": "Also, try looking at output of `getBoundingClientRect()` method for parent `div`s of the `div` which you have set as data-scroll-container."
    },
    {
      "id": 410533212,
      "user": "vibhor98",
      "body": "The output of this method is still zero in the parent divs as well but it's not the case with demo implementation.\r\n\r\nI tried to know more about it but couldn't find the possible cause why it's not giving us the dimensions. Probably somewhere CSS rule is hindering its way to calculate the dimensions (not sure). This `div` element is explicitly given `width` and `height` property but still it fails to compute them. Ideally, it should give these dimensions as described [here](https://stackoverflow.com/questions/20654526/getboundingclientrect-inside-overflowscroll/21204347).\r\n\r\n**References:** [Ref1](\r\nhttps://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&cad=rja&uact=8&ved=2ahUKEwis8YGVqtbcAhWKvI8KHXRABaMQFjACegQIBxAB&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F20654526%2Fgetboundingclientrect-inside-overflowscroll%2F21204347&usg=AOvVaw1L2Hn7RSht4zV9ZJ2x1XuY), [Ref2](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements)"
    },
    {
      "id": 410539900,
      "user": "seanlip",
      "body": "Consider searching for something like \"getboundingclientrect returns 0\" or \"getboundingclientrect returns 0 angular\". I think you'll get results that might be useful; you're probably not the first person who's run into this problem :)"
    },
    {
      "id": 410571015,
      "user": "prasanna08",
      "body": "HI @vibhor98,\r\n\r\nWhen I suggested looking at the output of `getBoundingClientRect()` for parent divs, I meant keep looking until you find something non-zero. So I did that and found the following results:\r\n\r\n* Output for `drag-and-drop-sort-container` is 0.\r\n* Output for `drag-and-drop-sort-form-container` is 0.\r\n* Output for `oppia-interactive-drag-and-drop-sort-input` is also 0.\r\n* Output for `protractor-test-conversation-input` **is not 0**.\r\n\r\nNow, if you look at the structure you would find that `protractor-test-conversation-input` is the classused by `angular-html-bind` tag to dynamically inject the `oppia-interactive-drag-and-drop-sort-input` directive in the HTML. The `oppia-interactive-drag-and-drop-sort-input` is not part of original HTML file. It is being generated dynamically by HTML Formatter that we use for interactions.\r\n\r\nWhat this means is that issue is with the dynamically generated tags/directives. A quick google search reveals [this](https://stackoverflow.com/questions/37403448/getboundingclientrect-return-zero-for-angular-directive-at-run-time). Now you have to figure out rest of the stuff.  \r\n"
    },
    {
      "id": 411536864,
      "user": "vibhor98",
      "body": "Hi, the actual problem when we get all the zeros is due to dynamic loading of the pages in Angular. It works fine for static pages. I tried various methods like: `$evalAsync` and `$timeout` to ensure that the dimension of the element is calculated only when it's loaded into the DOM as described [here](https://stackoverflow.com/questions/17301572/angularjs-evalasync-vs-timeout). But it doesn't seem to work. It may be a bug or feature enhancement on their side. I've already filed an issue in `angular-ui-tree` repo so that they may find this bug as well.\r\n\r\n@prasanna08, we can't add `protractor-test-input` class into data-scroll-container as it needs to be made scrollable first which is not expected. Also, data-scroll-container attribute is assigned to each item's element while using `ng-repeat`. "
    },
    {
      "id": 411544501,
      "user": "seanlip",
      "body": "Hi @vibhor98, thanks for the update. Just so you know, though -- \"it doesn't seem to work\" won't work here. All the code of the dependent library is open source, so you'll still need to figure out what part of that library is causing problems. Otherwise, it's still unclear whether it's a bug in that library or a bug in our code.\r\n\r\nPlease link to the issue that you filed in angular-ui-tree, for future reference.\r\n\r\nFinally, I think we need a clearer reason than \"is due to dynamic loading of the pages in Angular\", too. I still don't have a clear understanding of what is going on, from your explanation. Does getBoundingClientRect() eventually (after a while) return a nonzero value, or does it never return a nonzero value at all? If the former then maybe you can initialize the ui-tree element after that. If the latter then the problem is on our end."
    },
    {
      "id": 412175576,
      "user": "vibhor98",
      "body": "Hi @seanlip, sorry for the unclear explanation. I meant that [this](https://github.com/angular-ui-tree/angular-ui-tree/blob/d67ed0f28fe9acdddf0cde2775f0b049e8eecec9/source/directives/uiTreeNode.js#L362) code segment in `angular-ui-tree` module is causing the problem. It even doesn't wait for the element to get rendered in DOM  and ends up computing all zeros due to dynamic loading of the pages. I checked that `getBoundingClientRect()` always returns zeros even after a while. But we can't say our implementation is wrong as it's working fine independently.\r\n\r\n[Link](https://github.com/angular-ui-tree/angular-ui-tree/issues/1023) to the original issue in `ui-tree` repo. Thanks!"
    },
    {
      "id": 412176933,
      "user": "seanlip",
      "body": "Ok, sure. But we still need to find a fix.\n\nIf you patch the UI tree code, that is fine. We can host a modified version\nin our own repo or contribute a fix upstream. In other words, you don't\nneed to treat the UI tree code as immutable.\n\nBut success in this issue means actually fixing the issue (it does not\nmatter whether the fix is in this code or in the library), or finding a\ndifferent library to use instead that doesn't have this issue. If your fix\ninvolves changes to ui-tree then list the required changes in your PR so\nthat folks can modify their local repo before testing.\n>\n>\n"
    },
    {
      "id": 412319556,
      "user": "vibhor98",
      "body": "As an update, I got that `getBoundingClientRect()` is returning non-zero value in the editor mode but there only the interaction preview is shown and we can't really have scrolling there to test. Whereas in preview and learner mode, the dimensions are all zeros. So, I was looking since yesterday for anything dissimilar in both the cases that may cause the problem. I looked at all the directive hierarchies in both the learner and editor modes and understood how really an interaction is rendered dynamically in both the cases. I found that they're rendering the exactly same Html template for the interaction. So, there's no difference between the two."
    },
    {
      "id": 412322900,
      "user": "vibhor98",
      "body": "So, I looked at all the parent divs and found that `protractor-test-conversation-input` onwards we get non-zero dimensions of the elements. I found that the container specific for this interaction had its own dimensions and that was hindering the way for computing correct dimensions inside this div. So, I deleted all the extra divs and set data scroll container to a generic class of div containing `protractor-test-conversation-input` class and scrolling is working as expected now. CSS attributes for this class is set inside interaction's template so that it does not affect other interactions as it's generic for all. As the problem is resolved, I'll make a PR soon! 😄 "
    }
  ],
  "text_context": "# Add auto-scrolling mechanism in the Drag and Drop interaction\n\nThe current `Drag and Drop Sort` interaction requires automatic scrolling in the Drag and drop editor so that the editor is automatically scrolled up and down when the learner is dragging the tile. Automatic scrolling has already been implemented but is not working on Oppia. So, debugging is required to find out the possible cause behind the bug.\r\n\r\n### Repro Steps:\r\n* Open Creator Dashboard and click 'Create' button to create new exploration.\r\n* From the interactions modal, choose `Drag and Drop Sort` interaction.\r\n* Add around 7 - 8 choices in the interaction so that they don't fit into the max sized div element.\r\n* Try to drag an item beyond the boundaries of the div element.\r\n\r\n### Expected behaviour:\r\nIt should trigger the auto-scrolling event so that it can be scrolled automatically.\r\n\r\n### Observed behaviour:\r\nNo such event is triggered and the learner has to scroll manually. See nothing happens when an item is dragged out of the boundaries.\r\n![screen shot 2018-08-01 at 4 44 24 pm](https://user-images.githubusercontent.com/26625980/43518627-4fdabe92-95aa-11e8-950a-ecb8cdfa972b.png)\r\n\r\n### Impact on usability:\r\nIf the item size is too large (in case of images) or there are more than 6 items, they won't fit into the max. sized div element and so, the learner has to manually scroll until this issue is fixed.\r\n\r\n### Few approaches already tried:\r\nSee `angular-ui-tree` [doc](https://github.com/angular-ui-tree/angular-ui-tree/blob/master/README.md) to read about how `data-scroll-container` attribute is working and its demo implementation. The auto-scrolling is working fine if we run the code independently but not after integrating it with Oppia.\r\n* Changed the class name of the element to ensure that it's not overridden by some other class. But concluded that the `data-scroll-container` attribute is not getting override anywhere.\r\n* Added separate `div` tag for just the drag and drop container in HTML.\r\n* Removed different tags in the HTML to ensure if anything is hindering in its path.\r\n* Added CSS to make the drag and drop element `overflow: scroll`. It made manual scrolling possible but not auto-scrolling.\r\n* Referred links: [#49](https://github.com/angular-ui-tree/angular-ui-tree/issues/49) ; [#814](https://github.com/angular-ui-tree/angular-ui-tree/pull/814). There is not much about the issue on Stack Overflow.\r\n\n\nHi @vibhor98,\r\n\r\ncan you update this issue with following details:\r\n* Repro instructions and screenshots\r\n* Impact of this issue on usability on desktop and mobile devices.\r\n* The approaches that you have tried and have failed to solve the problem.\r\n* The possible cause(s) of the problem (if you have found any).\r\n* The part of documentation of angular-ui-tree where auto-scrolling is mentioned.\r\n* Any GitHub issues / stackoverflow links that you visited when solving this problem.\r\n* Anything else that you think is important to mention since this is very important issue.\n\nHi @prasanna08, I've updated the issue. \n\nI think you might want to dig into the third-party code (it's open source) to understand how data-scroll-container works. You can then perhaps find a way to introspect what element it's being applied to. \r\n\r\nAlso, by examining the third-party code and looking at the case that works (the demo implementation), could you provide, in this issue thread, a step-by-step breakdown of the actions and events that should happen, in sequence, when you perform a drag-beyond-boundaries action? We can then examine what happens in the Oppia case and compare it to this expected list of actions.\n\nSounds like a good approach! I'll update you shortly. Thanks!\n\nFollowing are the series of actions that take place as soon as the dragging starts:\r\n1. The scope of the dragged element is created.\r\n2. It keeps a watch on the `scrollContainer` variable to get its value if its a string.\r\n3. Then, while dragging it keeps the track of the cursor position.\r\n4. If cursor's y-coordinate is less than starting coordinate of the container, scroll top event is triggered and similar thing happens for scroll down case.\r\n5. If the `scrollContainer` has `null` value (if the attribute isn't defined in Html tag), then the scroll event takes place for the entire window using `window.scrollBy()` method.\r\n\r\nFor reference, please see this [patch](https://github.com/angular-ui-tree/angular-ui-tree/pull/814/files) that incorporates the auto-scrolling mechanism. \n\nOk, good start. So next step is to log what scrollContainer is, as well as\nits dimensions, then compare to what you would expect them to be. Are they\ncorrect?\n\nI can think of several failure cases: wrong element is selected as\nscrollContainer, scroll container boundary extends beyond what you see\nvisually, etc. Now that you have a breakdown, try and done deeper into it.\n\n\nUnderstanding third party code was not easy for me. But still this is what I could dig out:\r\n* `scrollContainer` just contains the CSS class of the container in which scrolling happens. Like: `.drag-and-drop-sort-container` in our case.\r\n* Then the element corresponding to this class is extracted using `document.querySelector`.\r\n* The exact position of the element is find out by using `getBoundingClientRect()` method. This method gives the left, right, top and bottom coordinates of the selected element and its position relative to the viewport.\r\n* I think this is the root cause of the issue. In Oppia, this method gives zeros in all the cases. While it should give the exact position of the element in viewport as it is giving in case of demo implementation. I'm not sure why this is happening right now but probably its fix can solve our problem.\n\nThat's great, @vibhor98! This is definitely a path towards solving the problem, and as you say, understanding why getBoundingClientRect() is doing what it's doing (and finding a way to get it to do the right thing) should help. In order to do this you will probably need to read up a bit more on what getBoundingClientRect() does, too.\n\nAlso, try looking at output of `getBoundingClientRect()` method for parent `div`s of the `div` which you have set as data-scroll-container.\n\nThe output of this method is still zero in the parent divs as well but it's not the case with demo implementation.\r\n\r\nI tried to know more about it but couldn't find the possible cause why it's not giving us the dimensions. Probably somewhere CSS rule is hindering its way to calculate the dimensions (not sure). This `div` element is explicitly given `width` and `height` property but still it fails to compute them. Ideally, it should give these dimensions as described [here](https://stackoverflow.com/questions/20654526/getboundingclientrect-inside-overflowscroll/21204347).\r\n\r\n**References:** [Ref1](\r\nhttps://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&cad=rja&uact=8&ved=2ahUKEwis8YGVqtbcAhWKvI8KHXRABaMQFjACegQIBxAB&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F20654526%2Fgetboundingclientrect-inside-overflowscroll%2F21204347&usg=AOvVaw1L2Hn7RSht4zV9ZJ2x1XuY), [Ref2](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements)\n\nConsider searching for something like \"getboundingclientrect returns 0\" or \"getboundingclientrect returns 0 angular\". I think you'll get results that might be useful; you're probably not the first person who's run into this problem :)\n\nHI @vibhor98,\r\n\r\nWhen I suggested looking at the output of `getBoundingClientRect()` for parent divs, I meant keep looking until you find something non-zero. So I did that and found the following results:\r\n\r\n* Output for `drag-and-drop-sort-container` is 0.\r\n* Output for `drag-and-drop-sort-form-container` is 0.\r\n* Output for `oppia-interactive-drag-and-drop-sort-input` is also 0.\r\n* Output for `protractor-test-conversation-input` **is not 0**.\r\n\r\nNow, if you look at the structure you would find that `protractor-test-conversation-input` is the classused by `angular-html-bind` tag to dynamically inject the `oppia-interactive-drag-and-drop-sort-input` directive in the HTML. The `oppia-interactive-drag-and-drop-sort-input` is not part of original HTML file. It is being generated dynamically by HTML Formatter that we use for interactions.\r\n\r\nWhat this means is that issue is with the dynamically generated tags/directives. A quick google search reveals [this](https://stackoverflow.com/questions/37403448/getboundingclientrect-return-zero-for-angular-directive-at-run-time). Now you have to figure out rest of the stuff.  \r\n\n\nHi, the actual problem when we get all the zeros is due to dynamic loading of the pages in Angular. It works fine for static pages. I tried various methods like: `$evalAsync` and `$timeout` to ensure that the dimension of the element is calculated only when it's loaded into the DOM as described [here](https://stackoverflow.com/questions/17301572/angularjs-evalasync-vs-timeout). But it doesn't seem to work. It may be a bug or feature enhancement on their side. I've already filed an issue in `angular-ui-tree` repo so that they may find this bug as well.\r\n\r\n@prasanna08, we can't add `protractor-test-input` class into data-scroll-container as it needs to be made scrollable first which is not expected. Also, data-scroll-container attribute is assigned to each item's element while using `ng-repeat`. \n\nHi @vibhor98, thanks for the update. Just so you know, though -- \"it doesn't seem to work\" won't work here. All the code of the dependent library is open source, so you'll still need to figure out what part of that library is causing problems. Otherwise, it's still unclear whether it's a bug in that library or a bug in our code.\r\n\r\nPlease link to the issue that you filed in angular-ui-tree, for future reference.\r\n\r\nFinally, I think we need a clearer reason than \"is due to dynamic loading of the pages in Angular\", too. I still don't have a clear understanding of what is going on, from your explanation. Does getBoundingClientRect() eventually (after a while) return a nonzero value, or does it never return a nonzero value at all? If the former then maybe you can initialize the ui-tree element after that. If the latter then the problem is on our end.\n\nHi @seanlip, sorry for the unclear explanation. I meant that [this](https://github.com/angular-ui-tree/angular-ui-tree/blob/d67ed0f28fe9acdddf0cde2775f0b049e8eecec9/source/directives/uiTreeNode.js#L362) code segment in `angular-ui-tree` module is causing the problem. It even doesn't wait for the element to get rendered in DOM  and ends up computing all zeros due to dynamic loading of the pages. I checked that `getBoundingClientRect()` always returns zeros even after a while. But we can't say our implementation is wrong as it's working fine independently.\r\n\r\n[Link](https://github.com/angular-ui-tree/angular-ui-tree/issues/1023) to the original issue in `ui-tree` repo. Thanks!\n\nOk, sure. But we still need to find a fix.\n\nIf you patch the UI tree code, that is fine. We can host a modified version\nin our own repo or contribute a fix upstream. In other words, you don't\nneed to treat the UI tree code as immutable.\n\nBut success in this issue means actually fixing the issue (it does not\nmatter whether the fix is in this code or in the library), or finding a\ndifferent library to use instead that doesn't have this issue. If your fix\ninvolves changes to ui-tree then list the required changes in your PR so\nthat folks can modify their local repo before testing.\n>\n>\n\n\nAs an update, I got that `getBoundingClientRect()` is returning non-zero value in the editor mode but there only the interaction preview is shown and we can't really have scrolling there to test. Whereas in preview and learner mode, the dimensions are all zeros. So, I was looking since yesterday for anything dissimilar in both the cases that may cause the problem. I looked at all the directive hierarchies in both the learner and editor modes and understood how really an interaction is rendered dynamically in both the cases. I found that they're rendering the exactly same Html template for the interaction. So, there's no difference between the two.\n\nSo, I looked at all the parent divs and found that `protractor-test-conversation-input` onwards we get non-zero dimensions of the elements. I found that the container specific for this interaction had its own dimensions and that was hindering the way for computing correct dimensions inside this div. So, I deleted all the extra divs and set data scroll container to a generic class of div containing `protractor-test-conversation-input` class and scrolling is working as expected now. CSS attributes for this class is set inside interaction's template so that it does not affect other interactions as it's generic for all. As the problem is resolved, I'll make a PR soon! 😄 ",
  "pr_link": "https://github.com/angular-ui-tree/angular-ui-tree/pull/814",
  "code_context": [
    {
      "filename": "source/directives/uiTreeNode.js",
      "content": "(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n    .directive('uiTreeNode', ['treeConfig', 'UiTreeHelper', '$window', '$document', '$timeout', '$q',\n      function (treeConfig, UiTreeHelper, $window, $document, $timeout, $q) {\n        return {\n          require: ['^uiTreeNodes', '^uiTree'],\n          restrict: 'A',\n          controller: 'TreeNodeController',\n          link: function (scope, element, attrs, controllersArr) {\n            var config = {},\n              hasTouch = 'ontouchstart' in window,\n              firstMoving,\n              dragInfo,\n              pos,\n              placeElm,\n              hiddenPlaceElm,\n              dragElm,\n              scrollContainerElm,\n              treeScope = null,\n              elements, // As a parameter for callbacks\n              dragDelaying = true,\n              dragStarted = false,\n              dragTimer = null,\n              body = document.body,\n              html = document.documentElement,\n              document_height,\n              document_width,\n              dragStart,\n              tagName,\n              dragMove,\n              dragEnd,\n              dragStartEvent,\n              dragMoveEvent,\n              dragEndEvent,\n              dragCancelEvent,\n              dragDelay,\n              bindDragStartEvents,\n              bindDragMoveEvents,\n              unbindDragMoveEvents,\n              keydownHandler,\n              outOfBounds,\n              isHandleChild,\n              el,\n              isUiTreeRoot;\n\n            //Adding configured class to ui-tree-node.\n            angular.extend(config, treeConfig);\n\n            if (config.nodeClass) {\n              element.addClass(config.nodeClass);\n            }\n\n            //Call init function in nodeCtrl, sets parent node and sets up sub nodes.\n            scope.init(controllersArr);\n\n            scope.collapsed = !!UiTreeHelper.getNodeAttribute(scope, 'collapsed') || treeConfig.defaultCollapsed;\n            scope.expandOnHover = !!UiTreeHelper.getNodeAttribute(scope, 'expandOnHover');\n            scope.scrollContainer = UiTreeHelper.getNodeAttribute(scope, 'scrollContainer') || attrs.scrollContainer || null;\n            scope.sourceOnly = scope.nodropEnabled || scope.$treeScope.nodropEnabled;\n\n            scope.$watch(attrs.collapsed, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.collapsed = val;\n              }\n            });\n\n            //Watches to trigger behavior based on actions and settings.\n            scope.$watch('collapsed', function (val) {\n              UiTreeHelper.setNodeAttribute(scope, 'collapsed', val);\n              attrs.$set('collapsed', val);\n            });\n\n            scope.$watch(attrs.expandOnHover, function(val) {\n              if ((typeof val) === 'boolean' || (typeof val) === 'number') {\n                scope.expandOnHover = val;\n              }\n            });\n\n            scope.$watch('expandOnHover', function (val) {\n              UiTreeHelper.setNodeAttribute(scope, 'expandOnHover', val);\n              attrs.$set('expandOnHover', val);\n            });\n\n            attrs.$observe('scrollContainer', function(val) {\n              if ((typeof val) === 'string') {\n                scope.scrollContainer = val;\n              }\n            });\n\n            scope.$watch('scrollContainer', function(val) {\n              UiTreeHelper.setNodeAttribute(scope, 'scrollContainer', val);\n              attrs.$set('scrollContainer', val);\n              scrollContainerElm = document.querySelector(val);\n            });\n\n            scope.$on('angular-ui-tree:collapse-all', function () {\n              scope.collapsed = true;\n            });\n\n            scope.$on('angular-ui-tree:expand-all', function () {\n              scope.collapsed = false;\n            });\n\n            /**\n             * Called when the user has grabbed a node and started dragging it.\n             *\n             * @param {MouseEvent} e event that is triggered by DOM.\n             * @return undefined?\n             */\n            dragStart = function (e) {\n\n              //Disable right click.\n              if (!hasTouch && (e.button === 2 || e.which === 3)) {\n                return;\n              }\n\n              //Event has already fired in other scope.\n              if (e.uiTreeDragging || (e.originalEvent && e.originalEvent.uiTreeDragging)) {\n                return;\n              }\n\n              //The node being dragged.\n              var eventElm = angular.element(e.target),\n                isHandleChild,\n                cloneElm,\n                eventElmTagName,\n                tagName,\n                eventObj,\n                tdElm,\n                hStyle,\n                isTreeNode,\n                isTreeNodeHandle;\n\n              //If the target element is a child element of a ui-tree-handle,\n              // use the containing handle element as target element.\n              isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(eventElm);\n              if (isHandleChild) {\n                eventElm = angular.element(isHandleChild);\n              }\n\n              cloneElm = element.clone();\n              isTreeNode = UiTreeHelper.elementIsTreeNode(eventElm);\n              isTreeNodeHandle = UiTreeHelper.elementIsTreeNodeHandle(eventElm);\n\n              //If we are not triggering mousedown on our uiTree or any of it's parts, return.\n              if (!isTreeNode && !isTreeNodeHandle) {\n                return;\n              }\n\n              //If we are not triggering mousedown on our uiTree or any of it's parts, return.\n              if (isTreeNode && UiTreeHelper.elementContainsTreeNodeHandler(eventElm)) {\n                return;\n              }\n\n              //Dragging not allowed on inputs or buttons.\n              eventElmTagName = eventElm.prop('tagName').toLowerCase();\n              if (eventElmTagName == 'input' ||\n                  eventElmTagName == 'textarea' ||\n                  eventElmTagName == 'button' ||\n                  eventElmTagName == 'select') {\n                return;\n              }\n\n              //Check if it or it's parents has a 'data-nodrag' attribute\n              el = angular.element(e.target);\n              //TODO(jcarter): This may be breaking the changing nest level within self.\n              while (el && el[0] && el[0] !== element && !isUiTreeRoot) {\n\n                //Checking that I can access attributes.\n                if (el[0].attributes) {\n                  isUiTreeRoot = el[0].attributes['ui-tree'];\n                }\n\n                //If the node mark as `nodrag`, DONOT drag it.\n                if (UiTreeHelper.nodrag(el)) {\n                  return;\n                }\n                el = el.parent();\n              }\n\n              //If users beforeDrag calback returns falsey, do not initiate.\n              if (!scope.beforeDrag(scope)) {\n                return;\n              }\n\n              //Set property checked at start of function to prevent running logic again.\n              e.uiTreeDragging = true;\n              if (e.originalEvent) {\n                e.originalEvent.uiTreeDragging = true;\n              }\n              e.preventDefault();\n\n              //Get original event if TouchEvent.\n              eventObj = UiTreeHelper.eventObj(e);\n\n              //Set boolean used to specify beginning of move.\n              firstMoving = true;\n\n              //Setting drag info properties and methods in scope of node being moved.\n              dragInfo = UiTreeHelper.dragInfo(scope);\n\n              //Determine tage name of element ui-tree-node is on.\n              tagName = element.prop('tagName');\n\n              if (tagName.toLowerCase() === 'tr') {\n\n                //Create a new table column as placeholder.\n                placeElm = angular.element($window.document.createElement(tagName));\n\n                //Create a column placeholder and set colspan to whole row length.\n                tdElm = angular.element($window.document.createElement('td'))\n                    .addClass(config.placeholderClass)\n                    .attr('colspan', element[0].children.length);\n                placeElm.append(tdElm);\n              } else {\n\n                //If not a table just duplicate element and add placeholder class.\n                placeElm = angular.element($window.document.createElement(tagName))\n                    .addClass(config.placeholderClass);\n              }\n\n              //Create a hidden placeholder and add class from config.\n              hiddenPlaceElm = angular.element($window.document.createElement(tagName));\n              if (config.hiddenClass) {\n                hiddenPlaceElm.addClass(config.hiddenClass);\n              }\n\n              //Getting starting position of element being moved.\n              pos = UiTreeHelper.positionStarted(eventObj, element);\n              placeElm.css('height', UiTreeHelper.height(element) + 'px');\n\n              //Creating drag element to represent node.\n              dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName')))\n                  .addClass(scope.$parentNodesScope.$element.attr('class')).addClass(config.dragClass);\n              dragElm.css('width', UiTreeHelper.width(element) + 'px');\n              dragElm.css('z-index', 9999);\n\n              //Prevents cursor to change rapidly in Opera 12.16 and IE when dragging an element.\n              hStyle = (element[0].querySelector('.angular-ui-tree-handle') || element[0]).currentStyle;\n              if (hStyle) {\n                document.body.setAttribute('ui-tree-cursor', $document.find('body').css('cursor') || '');\n                $document.find('body').css({'cursor': hStyle.cursor + '!important'});\n              }\n\n              //If tree is sourceOnly (noDragDrop) don't show placeholder when moving about it.\n              if (scope.sourceOnly) {\n                placeElm.css('display', 'none');\n              }\n\n              //Insert placeholder.\n              element.after(placeElm);\n              element.after(hiddenPlaceElm);\n              if (dragInfo.isClone() && scope.sourceOnly) {\n                dragElm.append(cloneElm);\n              } else {\n                dragElm.append(element);\n              }\n\n              //Create drag element.\n              $document.find('body').append(dragElm);\n\n              //Set drag elements position on screen.\n              dragElm.css({\n                'left': eventObj.pageX - pos.offsetX + 'px',\n                'top': eventObj.pageY - pos.offsetY + 'px'\n              });\n              elements = {\n                placeholder: placeElm,\n                dragging: dragElm\n              };\n\n              //Create all drag/move bindings.\n              bindDragMoveEvents();\n\n              //Fire dragStart callback.\n              scope.$apply(function () {\n                scope.$treeScope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));\n              });\n\n              //Get bounds of document.\n              document_height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n              document_width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n            };\n\n            dragMove = function (e) {\n              var eventObj = UiTreeHelper.eventObj(e),\n                prev,\n                next,\n                leftElmPos,\n                topElmPos,\n                top_scroll,\n                bottom_scroll,\n                scrollContainerElmRect,\n                target,\n                decrease,\n                targetX,\n                targetY,\n                displayElm,\n                targetNode,\n                targetElm,\n                isEmpty,\n                scrollDownBy,\n                scrollUpBy,\n                targetOffset,\n                targetBefore;\n\n              //If check ensures that drag element was created.\n              if (dragElm) {\n                e.preventDefault();\n\n                //Deselect anything (text, etc.) that was selected when move began.\n                if ($window.getSelection) {\n                  $window.getSelection().removeAllRanges();\n                } else if ($window.document.selection) {\n                  $window.document.selection.empty();\n                }\n\n                //Get top left positioning of element being moved.\n                leftElmPos = eventObj.pageX - pos.offsetX;\n                topElmPos = eventObj.pageY - pos.offsetY;\n\n                //dragElm can't leave the screen on the left.\n                if (leftElmPos < 0) {\n                  leftElmPos = 0;\n                }\n\n                //dragElm can't leave the screen on the top.\n                if (topElmPos < 0) {\n                  topElmPos = 0;\n                }\n\n                //dragElm can't leave the screen on the bottom.\n                if ((topElmPos + 10) > document_height) {\n                  topElmPos = document_height - 10;\n                }\n\n                //dragElm can't leave the screen on the right.\n                if ((leftElmPos + 10) > document_width) {\n                  leftElmPos = document_width - 10;\n                }\n\n                //Updating element being moved css.\n                dragElm.css({\n                  'left': leftElmPos + 'px',\n                  'top': topElmPos + 'px'\n                });\n\n                if (scrollContainerElm) {\n                  //Getting position to top and bottom of container element.\n                  scrollContainerElmRect = scrollContainerElm.getBoundingClientRect();\n                  top_scroll = scrollContainerElm.scrollTop;\n                  bottom_scroll = top_scroll + scrollContainerElm.clientHeight;\n\n                  //To scroll down if cursor y-position is greater than the bottom position of the container vertical scroll\n                  if (scrollContainerElmRect.bottom < eventObj.clientY && bottom_scroll < scrollContainerElm.scrollHeight) {\n                    scrollDownBy = Math.min(scrollContainerElm.scrollHeight - bottom_scroll, 10);\n                    scrollContainerElm.scrollTop += scrollDownBy;\n                  }\n\n                  //To scroll top if cursor y-position is less than the top position of the container vertical scroll\n                  if (scrollContainerElmRect.top > eventObj.clientY && top_scroll > 0) {\n                    scrollUpBy = Math.min(top_scroll, 10);\n                    scrollContainerElm.scrollTop -= scrollUpBy;\n                  }\n                } else {\n                  //Getting position to top and bottom of page.\n                  top_scroll = window.pageYOffset || $window.document.documentElement.scrollTop;\n                  bottom_scroll = top_scroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);\n\n                  //To scroll down if cursor y-position is greater than the bottom position of the window vertical scroll\n                  if (bottom_scroll < eventObj.pageY && bottom_scroll < document_height) {\n                    scrollDownBy = Math.min(document_height - bottom_scroll, 10);\n                    window.scrollBy(0, scrollDownBy);\n                  }\n\n                  //To scroll top if cursor y-position is less than the top position of the window vertical scroll\n                  if (top_scroll > eventObj.pageY) {\n                    scrollUpBy = Math.min(top_scroll, 10);\n                    window.scrollBy(0, -scrollUpBy);\n                  }\n                }\n\n                //Calling service to update position coordinates based on move.\n                UiTreeHelper.positionMoved(e, pos, firstMoving);\n                if (firstMoving) {\n                  firstMoving = false;\n                  return;\n                }\n\n                //Setting X point for elementFromPoint.\n                decrease = (UiTreeHelper.offset(dragElm).left - UiTreeHelper.offset(placeElm).left) >= config.threshold;\n\n                targetX = eventObj.pageX - ($window.pageXOffset ||\n                    $window.document.body.scrollLeft ||\n                    $window.document.documentElement.scrollLeft) -\n                    ($window.document.documentElement.clientLeft || 0);\n\n                targetY = eventObj.pageY - ($window.pageYOffset ||\n                    $window.document.body.scrollTop ||\n                    $window.document.documentElement.scrollTop) -\n                    ($window.document.documentElement.clientTop || 0);\n\n                //Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always\n                // pick the drag element itself as the target. To prevent this, we hide the drag element while\n                // selecting the target.\n                if (angular.isFunction(dragElm.hide)) {\n                  dragElm.hide();\n                } else {\n                  displayElm = dragElm[0].style.display;\n                  dragElm[0].style.display = 'none';\n                }\n\n                //When using elementFromPoint() inside an iframe, you have to call\n                // elementFromPoint() twice to make sure IE8 returns the correct value\n                //MDN: The elementFromPoint() method of the Document interface returns the topmost element at the specified coordinates.\n                $window.document.elementFromPoint(targetX, targetY);\n\n                //Set target element (element in specified x/y coordinates).\n                targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));\n\n                //If the target element is a child element of a ui-tree-handle,\n                // use the containing handle element as target element\n                isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(targetElm);\n                if (isHandleChild) {\n                  targetElm = angular.element(isHandleChild);\n                }\n\n                if (angular.isFunction(dragElm.show)) {\n                  dragElm.show();\n                } else {\n                  dragElm[0].style.display = displayElm;\n                }\n\n                //This checks if angularUiTree attributes are found on element.\n                outOfBounds = !UiTreeHelper.elementIsTreeNodeHandle(targetElm) &&\n                    !UiTreeHelper.elementIsTreeNode(targetElm) &&\n                    !UiTreeHelper.elementIsTreeNodes(targetElm) &&\n                    !UiTreeHelper.elementIsTree(targetElm) &&\n                    !UiTreeHelper.elementIsPlaceholder(targetElm);\n\n                //Detect out of bounds condition, update drop target display, and prevent drop, also reset parent to source.\n                if (outOfBounds) {\n\n                  //Remove the placeholder.\n                  placeElm.remove();\n\n                  //If the target was an empty tree, replace the empty element placeholder.\n                  if (treeScope) {\n                    treeScope.resetEmptyElement();\n                    treeScope = null;\n                  }\n\n                  //Reset parent to source parent.\n                  dragInfo.resetParent();\n                }\n\n                // move horizontal\n                if (pos.dirAx && pos.distAxX >= config.levelThreshold) {\n                  pos.distAxX = 0;\n\n                  // increase horizontal level if previous sibling exists and is not collapsed\n                  if (pos.distX > 0) {\n                    prev = dragInfo.prev();\n                    if (prev && !prev.collapsed\n                      && prev.accept(scope, prev.childNodesCount())) {\n                      prev.$childNodesScope.$element.append(placeElm);\n                      dragInfo.moveTo(prev.$childNodesScope, prev.childNodes(), prev.childNodesCount());\n                    }\n                  }\n\n                  // decrease horizontal level\n                  if (pos.distX < 0) {\n                    // we can't decrease a level if an item preceeds the current one\n                    next = dragInfo.next();\n                    if (!next) {\n                      target = dragInfo.parentNode(); // As a sibling of it's parent node\n                      if (target\n                        && target.$parentNodesScope.accept(scope, target.index() + 1)) {\n                        target.$element.after(placeElm);\n                        dragInfo.moveTo(target.$parentNodesScope, target.siblings(), target.index() + 1);\n                      }\n                    }\n                  }\n                }\n\n                // move vertical\n                if (!pos.dirAx) {\n                  //Assigning scope to target you are moving draggable to.\n                  if (UiTreeHelper.elementIsTree(targetElm)) {\n                    targetNode = targetElm.controller('uiTree').scope;\n                  } else if (UiTreeHelper.elementIsTreeNodeHandle(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeHandle').scope;\n                  } else if (UiTreeHelper.elementIsTreeNode(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNode').scope;\n                  } else if (UiTreeHelper.elementIsTreeNodes(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNodes').scope;\n                  } else if (UiTreeHelper.elementIsPlaceholder(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNodes').scope;\n                  } else if (targetElm.controller('uiTreeNode')) {\n                    //Is a child element of a node.\n                    targetNode = targetElm.controller('uiTreeNode').scope;\n                  }\n\n                  //Check it's new position.\n                  isEmpty = false;\n\n                  //Exit if target is not a uiTree or child of one.\n                  if (!targetNode) {\n                    return;\n                  }\n\n                  //Show the placeholder if it was hidden for nodrop-enabled and this is a new tree\n                  if (targetNode.$treeScope && !targetNode.$parent.nodropEnabled && !targetNode.$treeScope.nodropEnabled) {\n                    placeElm.css('display', '');\n                  }\n\n                  //Set whether target tree is empty or not.\n                  if (targetNode.$type === 'uiTree' && targetNode.dragEnabled) {\n                    isEmpty = targetNode.isEmpty();\n                  }\n\n                  //If target is a handle set new target to handle's node.\n                  if (targetNode.$type === 'uiTreeHandle') {\n                    targetNode = targetNode.$nodeScope;\n                  }\n\n                  //Check if it is a uiTreeNode or it's an empty tree.\n                  if (targetNode.$type !== 'uiTreeNode' && !isEmpty) {\n                    return;\n                  }\n\n                  //If placeholder move from empty tree, reset it.\n                  if (treeScope && placeElm.parent()[0] != treeScope.$element[0]) {\n                    treeScope.resetEmptyElement();\n                    treeScope = null;\n                  }\n\n                  //It's an empty tree\n                  if (isEmpty) {\n                    treeScope = targetNode;\n                    if (targetNode.$nodesScope.accept(scope, 0)) {\n                      targetNode.place(placeElm);\n                      dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);\n                    }\n                  //Not empty and drag enabled.\n                  } else if (targetNode.dragEnabled()) {\n\n                      //Setting/Resetting data for exanding on hover.\n                      if (angular.isDefined(scope.expandTimeoutOn) && scope.expandTimeoutOn !== targetNode.id) {\n                        $timeout.cancel(scope.expandTimeout);\n                        delete scope.expandTimeout;\n                        delete scope.expandTimeoutOn;\n\n                        scope.$callbacks.expandTimeoutCancel();\n                      }\n\n                      //Determining if expansion is needed.\n                      if (targetNode.collapsed) {\n                        if (scope.expandOnHover === true || (angular.isNumber(scope.expandOnHover) && scope.expandOnHover === 0)) {\n                          targetNode.collapsed = false;\n                        } else if (scope.expandOnHover !== false && angular.isNumber(scope.expandOnHover) && scope.expandOnHover > 0) {\n\n                          //Triggering expansion.\n                          if (angular.isUndefined(scope.expandTimeoutOn)) {\n                            scope.expandTimeoutOn = targetNode.$id;\n\n                            scope.$callbacks.expandTimeoutStart();\n                            scope.expandTimeout = $timeout(function()\n                            {\n                              scope.$callbacks.expandTimeoutEnd();\n                              targetNode.collapsed = false;\n                            }, scope.expandOnHover);\n                          }\n                        }\n                      }\n\n                    //Get the element of ui-tree-node\n                    targetElm = targetNode.$element;\n                    targetOffset = UiTreeHelper.offset(targetElm);\n                    targetBefore = targetNode.horizontal ? eventObj.pageX < (targetOffset.left + UiTreeHelper.width(targetElm) / 2)\n                      : eventObj.pageY < (targetOffset.top + UiTreeHelper.height(targetElm) / 2);\n\n                    if (targetNode.$parentNodesScope.accept(scope, targetNode.index())) {\n                      if (targetBefore) {\n                        targetElm[0].parentNode.insertBefore(placeElm[0], targetElm[0]);\n                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index());\n                      } else {\n                        targetElm.after(placeElm);\n                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index() + 1);\n                      }\n\n                    //We have to check if it can add the dragging node as a child.\n                    } else if (!targetBefore && targetNode.accept(scope, targetNode.childNodesCount())) {\n                      targetNode.$childNodesScope.$element.append(placeElm);\n                      dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), targetNode.childNodesCount());\n                    } else {\n                      outOfBounds = true;\n                      dragInfo.resetParent();\n                    }\n                  }\n                }\n\n                //Triggering dragMove callback.\n                scope.$apply(function () {\n                  scope.$treeScope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));\n                });\n              }\n            };\n\n            dragEnd = function (e) {\n\n              var dragEventArgs = dragInfo.eventArgs(elements, pos);\n\n              e.preventDefault();\n\n              //TODO(jcarter): Is dragStart need to be unbound?\n              unbindDragMoveEvents();\n\n              //This cancel the collapse/expand login running.\n              $timeout.cancel(scope.expandTimeout);\n\n              scope.$treeScope.$apply(function () {\n                $q.when(scope.$treeScope.$callbacks.beforeDrop(dragEventArgs))\n\n                     //Promise resolved (or callback didn't return false)\n                    .then(function (allowDrop) {\n                      if (allowDrop !== false && scope.$$allowNodeDrop && !outOfBounds) {\n\n                        //Node drop accepted.\n                        dragInfo.apply();\n\n                        //Fire the dropped callback only if the move was successful.\n                        scope.$treeScope.$callbacks.dropped(dragEventArgs);\n                      } else {\n\n                        //Drop canceled - revert the node to its original position.\n                        bindDragStartEvents();\n                      }\n                    })\n\n                    //Promise rejected - revert the node to its original position.\n                    .catch(function () {\n                      bindDragStartEvents();\n                    })\n                    .finally(function () {\n\n                      //Replace placeholder with newly dropped element.\n                      hiddenPlaceElm.replaceWith(scope.$element);\n                      placeElm.remove();\n\n                      //Remove drag element if still in DOM.\n                      if (dragElm) {\n                        dragElm.remove();\n                        dragElm = null;\n                      }\n\n                      //Fire dragStope callback.\n                      scope.$treeScope.$callbacks.dragStop(dragEventArgs);\n                      scope.$$allowNodeDrop = false;\n                      dragInfo = null;\n\n                      //Restore cursor in Opera 12.16 and IE\n                      var oldCur = document.body.getAttribute('ui-tree-cursor');\n                      if (oldCur !== null) {\n                        $document.find('body').css({'cursor': oldCur});\n                        document.body.removeAttribute('ui-tree-cursor');\n                      }\n                    });\n              });\n            };\n\n            dragStartEvent = function (e) {\n              if (scope.dragEnabled()) {\n                dragStart(e);\n              }\n            };\n\n            dragMoveEvent = function (e) {\n              dragMove(e);\n            };\n\n            dragEndEvent = function (e) {\n              scope.$$allowNodeDrop = true;\n              dragEnd(e);\n            };\n\n            dragCancelEvent = function (e) {\n              dragEnd(e);\n            };\n\n            dragDelay = (function () {\n              var to;\n\n              return {\n                exec: function (fn, ms) {\n                  if (!ms) {\n                    ms = 0;\n                  }\n                  this.cancel();\n                  to = $timeout(fn, ms);\n                },\n                cancel: function () {\n                  $timeout.cancel(to);\n                }\n              };\n            })();\n\n            keydownHandler = function (e) {\n              if (e.keyCode === 27) {\n                dragEndEvent(e);\n              }\n            };\n\n            /**\n             * Binds the mouse/touch events to enable drag start for this node.\n             */\n            //This is outside of bindDragMoveEvents because of the potential for a delay setting.\n            bindDragStartEvents = function () {\n              element.bind('touchstart mousedown', function (e) {\n                //Don't call drag delay if no delay was specified.\n                if (scope.dragDelay > 0) {\n                  dragDelay.exec(function () {\n                    dragStartEvent(e);\n                  }, scope.dragDelay);\n                } else {\n                  dragStartEvent(e);\n                }\n              });\n              element.bind('touchend touchcancel mouseup', function () {\n                if (scope.dragDelay > 0) {\n                  dragDelay.cancel();\n                }\n              });\n            };\n            bindDragStartEvents();\n\n            /**\n             * Binds mouse/touch events that handle moving/dropping this dragged node\n             */\n            bindDragMoveEvents = function () {\n              angular.element($document).bind('touchend', dragEndEvent);\n              angular.element($document).bind('touchcancel', dragEndEvent);\n              angular.element($document).bind('touchmove', dragMoveEvent);\n              angular.element($document).bind('mouseup', dragEndEvent);\n              angular.element($document).bind('mousemove', dragMoveEvent);\n              angular.element($document).bind('mouseleave', dragCancelEvent);\n              angular.element($document).bind('keydown', keydownHandler);\n            };\n\n            /**\n             * Unbinds mouse/touch events that handle moving/dropping this dragged node.\n             */\n            unbindDragMoveEvents = function () {\n              angular.element($document).unbind('touchend', dragEndEvent);\n              angular.element($document).unbind('touchcancel', dragEndEvent);\n              angular.element($document).unbind('touchmove', dragMoveEvent);\n              angular.element($document).unbind('mouseup', dragEndEvent);\n              angular.element($document).unbind('mousemove', dragMoveEvent);\n              angular.element($document).unbind('mouseleave', dragCancelEvent);\n              angular.element($document).unbind('keydown', keydownHandler);\n            };\n          }\n        };\n      }\n    ]);\n})();\n"
    },
    {
      "filename": "source/directives/uiTreeNode.spec.js",
      "content": "(function () {\n  'use strict';\n\n  describe('the uiTreeNode directive', function () {\n    var $rootScope, $compile, $scope, element;\n\n    beforeEach(module('ui.tree'));\n    beforeEach(inject(function ($injector) {\n      $rootScope = $injector.get('$rootScope');\n      $compile = $injector.get('$compile');\n      $scope = $rootScope.$new();\n\n      $scope.items = [{\n        'id': 42,\n        'title': 'Node 42'\n      }];\n    }));\n\n    function createElement(template) {\n      template = template || '<div ui-tree><ol ui-tree-nodes ng-model=\"items\"><li ng-repeat=\"item in items\" ui-tree-node><div ui-tree-handle>{{item.title}}</div></li></ol></div>';\n      element = angular.element(template);\n      $compile(element)($scope);\n      $scope.$digest();\n      return element;\n    }\n\n    describe('collapsed', function () {\n      beforeEach(function () {\n        element = createElement();\n      });\n\n      it('should collapse on receiving the angular-ui-tree:collapse-all event', function () {\n        $rootScope.$broadcast('angular-ui-tree:collapse-all');\n        $scope.$digest();\n\n        expect(element.find('[ui-tree-node]').attr('collapsed')).toEqual('true');\n        expect(element.find('[ui-tree-node]').scope().collapsed).toEqual(true);\n      });\n\n      it('should expand on receiving the angular-ui-tree:expand-all event', function () {\n        $rootScope.$broadcast('angular-ui-tree:expand-all');\n        $scope.$digest();\n\n        expect(element.find('[ui-tree-node]').attr('collapsed')).toEqual('false');\n        expect(element.find('[ui-tree-node]').scope().collapsed).toEqual(false);\n      });\n    });\n\n    describe('scrollContainer', function() {\n      it('should allow setting an alternative container for scrolling', function () {\n        var element = createElement('<div class=\"wrapper\" ui-tree><ul ui-tree-nodes ng-model=\"items\"><li ng-repeat=\"item in items\" ui-tree-node data-scroll-container=\".wrapper\"></li></ul></div>');\n        $scope.$digest();\n        expect(element.find('[ui-tree-node]').scope().scrollContainer).toEqual('.wrapper');\n      });\n\n      it('should be null by default', function () {\n        var element = createElement();\n        $scope.$digest();\n        expect(element.find('[ui-tree-node]').scope().scrollContainer).toEqual(null);\n      });\n\n      it('should allow changing of the container dynamically', function () {\n        $scope.container = '.wrapper';\n        var element = createElement('<div class=\"wrapper\" ui-tree><ul ui-tree-nodes ng-model=\"items\"><li ng-repeat=\"item in items\" ui-tree-node data-scroll-container=\"{{container}}\"></li></ul></div>');\n        $scope.$digest();\n        expect(element.find('[ui-tree-node]').scope().scrollContainer).toEqual('.wrapper');\n\n        $scope.container = '.foo';\n        $scope.$digest();\n        expect(element.find('[ui-tree-node]').scope().scrollContainer).toEqual('.foo');\n      });\n    });\n  });\n\n}());\n"
    }
  ]
}