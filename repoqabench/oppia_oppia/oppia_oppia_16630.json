{
  "repo_name": "oppia_oppia",
  "issue_id": "16630",
  "issue_description": "# [BUG]: Contributor dashboard header collapsing animation not working properly.\n\n### Describe the bug\r\n\r\nCurrently the appearing and collapsing animation of CD header is very jumpy and odd and doesn't really serve much purpose given the collapsed version of the header is not much smaller than the normal version.\r\n\r\n### Steps To Reproduce\r\n\r\n1. Go to https://oppiatestserver.appspot.com/contributor-dashboard#\r\n2. In 'My Contribution' tab, try to scroll down.\r\n3. Observe the behaviour as shown in the video.\r\n\r\n### Expected Behavior\r\n\r\nHeader collapsing should not be disturbing.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://user-images.githubusercontent.com/41409951/204082926-4a97b430-fc2f-4aae-bbc0-96783da60358.mov\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\n107.0.5304.110\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n## How to resolve for new contributors:\r\nThis issue regards the [contributor dashboard page](https://www.oppia.org/contributor-dashboard). \r\n- See the [user documentation](https://oppia-user-guide.readthedocs.io/en/latest/contributor/contribute.html) for how contributing translations/questions on the contributor dashboard works. \r\n- See [this](https://docs.google.com/document/d/1JYX4nvTcblaVVYAlTi7rApE0lWSBx0v_ZCCr_8WW4Wc/edit#heading=h.1nfdy29ioghr) doc for instructions on how to populate contributor dashboard data during local dev testing. \r\n- The code for the contributor dashboard header can be found [here](https://github.com/oppia/oppia/blob/develop/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html).",
  "issue_comments": [
    {
      "id": 1363197726,
      "user": "kshitij01042002",
      "body": "@Shivkant-Chauhan can you assign me this? I can try to solve this"
    },
    {
      "id": 1364027892,
      "user": "Shivkant-Chauhan",
      "body": "@kshitij01042002 Sorry, please see above Chris has a PR opened for it and i think the work on this issue is going on.. feel free to take up another issue from the Issues section. thanks!"
    },
    {
      "id": 1376600333,
      "user": "sagangwee",
      "body": "@chris7716 I don't think https://github.com/oppia/oppia/pull/16513 addresses this issue, right?"
    },
    {
      "id": 1376668980,
      "user": "chris7716",
      "body": "> @chris7716 I don't think #16513 addresses this issue, right?\r\n\r\nCorrect."
    },
    {
      "id": 1377588986,
      "user": "github-actions[bot]",
      "body": "Hi @sagangwee, thanks for proposing this as a good first issue. I am removing the label for now and looping in @DubeySandeep to approve the label. It will be added back if approved. Thanks!"
    },
    {
      "id": 1378703047,
      "user": "kushvahasumit",
      "body": "hey mentor , can i work on this . \r\n"
    },
    {
      "id": 1378857854,
      "user": "seanlip",
      "body": "@kushvahasumit  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!"
    },
    {
      "id": 1379954584,
      "user": "AjayGurjar1",
      "body": "i want to work on this issues please assign me this issue "
    },
    {
      "id": 1379959242,
      "user": "seanlip",
      "body": "@AjayGurjar1 Please see the comment above.\r\n\r\n(Also, if you are here for GSoC, please note that the ability to read and follow instructions is a skill that we take into account during selection.)"
    },
    {
      "id": 1379965849,
      "user": "AjayGurjar1",
      "body": "ok sir i will take care about it and thanks for guide me "
    },
    {
      "id": 1380403947,
      "user": "kushvahasumit",
      "body": "> @kushvahasumit Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n> \r\n> Please also follow the other instructions on that wiki page if you have not yet done so. Thanks!\r\n\r\nThakyou sir for guidance , i will try to solve shortly."
    },
    {
      "id": 1384931477,
      "user": "Strikker0",
      "body": "To solve the issue of a jumpy and odd animation of the CD header:\r\n\r\nReview the animation code: Check the animation code for any issues such as incorrect timing, easing or keyframe values that could be causing the jumpiness.\r\n\r\nSimplify the animation: Consider simplifying the animation by removing unnecessary elements or reducing the number of keyframes.\r\n\r\nTest different easing functions: Try different easing functions such as ease-in, ease-out, or linear to see if one of them produces a smoother animation.\r\n\r\nUse CSS transitions: CSS transitions are typically smoother than JavaScript-based animations.\r\n\r\nConsider removing the animation: If the animation is not serving any purpose and the collapsed version of the header is not much smaller than the normal version, consider removing it altogether.\r\n\r\nTest it on different devices: test the animation on different devices to make sure that the animation is consistent across all devices.\r\n\r\nIt's important to note that the solution you use will depend on the specific details of the animation and the tools you have available.\r\n\r\ncan u assign this issue o me I will try my best to solve his issue?\r\n"
    },
    {
      "id": 1384953519,
      "user": "harshit-senpai",
      "body": "Hey mentor, can I work on this? I have read the documentation."
    },
    {
      "id": 1384991943,
      "user": "seanlip",
      "body": "@Strikker0 I have the same guidance for you as I had in the other issue, which is to please provide the names of the files and the changes you wish to make to them.\r\n\r\n@harshit-senpai Please read the comments above, especially https://github.com/oppia/oppia/issues/16630#issuecomment-1378857854. I'm happy to assign this issue to the first person who replies with the necessary information. We ask for this in order to avoid people \"squatting\" on issues for long periods of time."
    },
    {
      "id": 1385023001,
      "user": "riyagupta2011",
      "body": "To solve this issue of a jumpy header we can minimize the height of the header and make the navigation collapse slowly using the CSS animation which will not make it look bulky. For the same, we had to make changes in the contributor-dashboard-page.component.html.\r\nCould you please assign me the issue I will try my best to solve it."
    },
    {
      "id": 1385027696,
      "user": "seanlip",
      "body": "@riyagupta2011 Please show a video of what you are proposing -- I'm not quite sure what you are describing.\r\n\r\nIf the video looks good, we can assign you this issue."
    },
    {
      "id": 1385031917,
      "user": "riyagupta2011",
      "body": "Ok, I will shortly provide the video of the change."
    },
    {
      "id": 1385070110,
      "user": "riyagupta2011",
      "body": "\r\n\r\nhttps://user-images.githubusercontent.com/98754072/212857236-40dce4ca-56a9-429a-b6ff-a348cc0834cf.mp4\r\n\r\nI just changed the height and make the animation slow we can also make it look good by shifting the avatar to the left and making some more changes."
    },
    {
      "id": 1385080955,
      "user": "seanlip",
      "body": "Ah, thanks @riyagupta2011. I took a look at your video, and I think there's a bit of a clarity gap in the original issue. I think the problem is that the animation is not smooth, not that it is fast.\r\n\r\nIt would be easier to see this in the \"Translate Text\" tab. I would suggest something like this -- as you scroll down from the top, the \"Translate Text\" heading and otter image get a bit smaller and the text below it fades out. Similarly for the dropdown on the right -- the idea is to make the translation smooth and not \"one navbar replaced with another\".\r\n\r\nDoes this help clarify, and if so, want to try again?\r\n\r\nThanks!"
    },
    {
      "id": 1385273293,
      "user": "riyagupta2011",
      "body": "Sorry, sir I just misunderstand the issue I look at your suggestion and will try to work and fix it."
    },
    {
      "id": 1385674909,
      "user": "parthn2",
      "body": "Hi @seanlip, I was looking for this issue for 2-3 days but I was getting problem setting up Oppia on my local machine, so wasn't able to play with the variables and find out exactly whats making out this behaviour, but what I get an instinct of and reading a bit of code is that the problem lies is in 'defaultHeaderVisible' variable which is present in this file 'oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.ts' and it is the one responsible for the behaviour.\r\n\r\nTo be more specific, it is most probably due to this function\r\n```\r\n  scrollFunction(): void {\r\n    if (this.windowRef.nativeWindow.pageYOffset >= 80) {\r\n      this.defaultHeaderVisible = false;\r\n    } else {\r\n      this.defaultHeaderVisible = true;\r\n    }\r\n  }\r\n```\r\n\r\nThis function makes the header visible when windows height becomes less than 80 but when it happens in turn it enlarges the window size and makes it greater than 80. That is the reason if we reduce the hieght of window to a greater extent, it behaves normally.\r\n\r\nThats all what I have gathered during my inspection. Please do tell if I am on right path?"
    },
    {
      "id": 1386897200,
      "user": "seanlip",
      "body": "@parthn2 It's probably related, but this isn't enough analysis for me to confidently assign you to this issue. Please see my response to @riyagupta2011 above if you still want to attempt this."
    },
    {
      "id": 1399180913,
      "user": "AdityaRaimec22",
      "body": "Hello, @seanlip I found the solution of the issue. Basically the issue is related with CSS. So, I made the the changes in the file \"oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html\" .\r\nAnd got the below shown result\r\n\r\nhttps://user-images.githubusercontent.com/118007662/213844354-c933aac6-f342-4986-9523-351605d732f2.mp4\r\n\r\nPLEASE ASSIGN ME this ISSUE.\r\nAND If you need any changes do let me know. I will definitely get you the desired result."
    },
    {
      "id": 1399186118,
      "user": "seanlip",
      "body": "@AdityaRaimec22 No, this doesn't address the issue; you've removed the collapsed header altogether. See https://github.com/oppia/oppia/issues/16630#issuecomment-1385080955 for a more detailed suggestion."
    },
    {
      "id": 1399264259,
      "user": "LovedeepSingh19",
      "body": "hi, can I work on this issue."
    },
    {
      "id": 1399549636,
      "user": "seanlip",
      "body": "@LovedeepSingh19 Again, per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so.\r\n\r\n(And in future, make sure to read the existing comments on an issue before posting. Thanks!)"
    },
    {
      "id": 1399576802,
      "user": "CodeWizarz",
      "body": "@seanlip Hey sean, as @parthn2 said i went through the .ts file  and came across that the header collapses and runs in a loop while scrolling so i suggest we set the header should collapse once and should not repeat \r\n\r\nI came up with this solution\r\nlet headerCollapsed = false;\r\nscrollFunction(): void {\r\n    if (this.windowRef.nativeWindow.pageYOffset >= 80 && !headerCollapsed) {\r\n      this.defaultHeaderVisible = false;\r\n      headerCollapsed = true;\r\n    } else {\r\n      this.defaultHeaderVisible = true;\r\n    }\r\n  }\r\n\r\nCan this be of any helpfull. I'll be waiting for your kind reply\r\nYeah and Obviously I'm going to edit this file \"oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.ts\""
    },
    {
      "id": 1399768233,
      "user": "seanlip",
      "body": "@DevBobby Please take a look at https://github.com/oppia/oppia/issues/16630#issuecomment-1385080955 for the desired behaviour."
    },
    {
      "id": 1401547315,
      "user": "Flamki",
      "body": "@DevBobby we can simply change the display:block; it solve the issues\r\n"
    },
    {
      "id": 1410585419,
      "user": "Simer13",
      "body": "Wouldnt it work if we simply use the display: block as said in the file \r\nhttps://github.com/oppia/oppia/blob/develop/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html\r\n![Screenshot (34)](https://user-images.githubusercontent.com/113010708/215802467-72269013-1577-4809-a35d-3923ffe81cb9.png)\r\n"
    }
  ],
  "text_context": "# [BUG]: Contributor dashboard header collapsing animation not working properly.\n\n### Describe the bug\r\n\r\nCurrently the appearing and collapsing animation of CD header is very jumpy and odd and doesn't really serve much purpose given the collapsed version of the header is not much smaller than the normal version.\r\n\r\n### Steps To Reproduce\r\n\r\n1. Go to https://oppiatestserver.appspot.com/contributor-dashboard#\r\n2. In 'My Contribution' tab, try to scroll down.\r\n3. Observe the behaviour as shown in the video.\r\n\r\n### Expected Behavior\r\n\r\nHeader collapsing should not be disturbing.\r\n\r\n### Screenshots/Videos\r\n\r\n\r\nhttps://user-images.githubusercontent.com/41409951/204082926-4a97b430-fc2f-4aae-bbc0-96783da60358.mov\r\n\r\n\r\n\r\n### What device are you using?\r\n\r\nDesktop\r\n\r\n### Operating System\r\n\r\nMacOS\r\n\r\n### What browsers are you seeing the problem on?\r\n\r\nChrome\r\n\r\n### Browser version\r\n\r\n107.0.5304.110\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n## How to resolve for new contributors:\r\nThis issue regards the [contributor dashboard page](https://www.oppia.org/contributor-dashboard). \r\n- See the [user documentation](https://oppia-user-guide.readthedocs.io/en/latest/contributor/contribute.html) for how contributing translations/questions on the contributor dashboard works. \r\n- See [this](https://docs.google.com/document/d/1JYX4nvTcblaVVYAlTi7rApE0lWSBx0v_ZCCr_8WW4Wc/edit#heading=h.1nfdy29ioghr) doc for instructions on how to populate contributor dashboard data during local dev testing. \r\n- The code for the contributor dashboard header can be found [here](https://github.com/oppia/oppia/blob/develop/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html).\n\n@Shivkant-Chauhan can you assign me this? I can try to solve this\n\n@kshitij01042002 Sorry, please see above Chris has a PR opened for it and i think the work on this issue is going on.. feel free to take up another issue from the Issues section. thanks!\n\n@chris7716 I don't think https://github.com/oppia/oppia/pull/16513 addresses this issue, right?\n\n> @chris7716 I don't think #16513 addresses this issue, right?\r\n\r\nCorrect.\n\nHi @sagangwee, thanks for proposing this as a good first issue. I am removing the label for now and looping in @DubeySandeep to approve the label. It will be added back if approved. Thanks!\n\nhey mentor , can i work on this . \r\n\n\n@kushvahasumit  Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so. Thanks!\n\ni want to work on this issues please assign me this issue \n\n@AjayGurjar1 Please see the comment above.\r\n\r\n(Also, if you are here for GSoC, please note that the ability to read and follow instructions is a skill that we take into account during selection.)\n\nok sir i will take care about it and thanks for guide me \n\n> @kushvahasumit Per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n> \r\n> Please also follow the other instructions on that wiki page if you have not yet done so. Thanks!\r\n\r\nThakyou sir for guidance , i will try to solve shortly.\n\nTo solve the issue of a jumpy and odd animation of the CD header:\r\n\r\nReview the animation code: Check the animation code for any issues such as incorrect timing, easing or keyframe values that could be causing the jumpiness.\r\n\r\nSimplify the animation: Consider simplifying the animation by removing unnecessary elements or reducing the number of keyframes.\r\n\r\nTest different easing functions: Try different easing functions such as ease-in, ease-out, or linear to see if one of them produces a smoother animation.\r\n\r\nUse CSS transitions: CSS transitions are typically smoother than JavaScript-based animations.\r\n\r\nConsider removing the animation: If the animation is not serving any purpose and the collapsed version of the header is not much smaller than the normal version, consider removing it altogether.\r\n\r\nTest it on different devices: test the animation on different devices to make sure that the animation is consistent across all devices.\r\n\r\nIt's important to note that the solution you use will depend on the specific details of the animation and the tools you have available.\r\n\r\ncan u assign this issue o me I will try my best to solve his issue?\r\n\n\nHey mentor, can I work on this? I have read the documentation.\n\n@Strikker0 I have the same guidance for you as I had in the other issue, which is to please provide the names of the files and the changes you wish to make to them.\r\n\r\n@harshit-senpai Please read the comments above, especially https://github.com/oppia/oppia/issues/16630#issuecomment-1378857854. I'm happy to assign this issue to the first person who replies with the necessary information. We ask for this in order to avoid people \"squatting\" on issues for long periods of time.\n\nTo solve this issue of a jumpy header we can minimize the height of the header and make the navigation collapse slowly using the CSS animation which will not make it look bulky. For the same, we had to make changes in the contributor-dashboard-page.component.html.\r\nCould you please assign me the issue I will try my best to solve it.\n\n@riyagupta2011 Please show a video of what you are proposing -- I'm not quite sure what you are describing.\r\n\r\nIf the video looks good, we can assign you this issue.\n\nOk, I will shortly provide the video of the change.\n\n\r\n\r\nhttps://user-images.githubusercontent.com/98754072/212857236-40dce4ca-56a9-429a-b6ff-a348cc0834cf.mp4\r\n\r\nI just changed the height and make the animation slow we can also make it look good by shifting the avatar to the left and making some more changes.\n\nAh, thanks @riyagupta2011. I took a look at your video, and I think there's a bit of a clarity gap in the original issue. I think the problem is that the animation is not smooth, not that it is fast.\r\n\r\nIt would be easier to see this in the \"Translate Text\" tab. I would suggest something like this -- as you scroll down from the top, the \"Translate Text\" heading and otter image get a bit smaller and the text below it fades out. Similarly for the dropdown on the right -- the idea is to make the translation smooth and not \"one navbar replaced with another\".\r\n\r\nDoes this help clarify, and if so, want to try again?\r\n\r\nThanks!\n\nSorry, sir I just misunderstand the issue I look at your suggestion and will try to work and fix it.\n\nHi @seanlip, I was looking for this issue for 2-3 days but I was getting problem setting up Oppia on my local machine, so wasn't able to play with the variables and find out exactly whats making out this behaviour, but what I get an instinct of and reading a bit of code is that the problem lies is in 'defaultHeaderVisible' variable which is present in this file 'oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.ts' and it is the one responsible for the behaviour.\r\n\r\nTo be more specific, it is most probably due to this function\r\n```\r\n  scrollFunction(): void {\r\n    if (this.windowRef.nativeWindow.pageYOffset >= 80) {\r\n      this.defaultHeaderVisible = false;\r\n    } else {\r\n      this.defaultHeaderVisible = true;\r\n    }\r\n  }\r\n```\r\n\r\nThis function makes the header visible when windows height becomes less than 80 but when it happens in turn it enlarges the window size and makes it greater than 80. That is the reason if we reduce the hieght of window to a greater extent, it behaves normally.\r\n\r\nThats all what I have gathered during my inspection. Please do tell if I am on right path?\n\n@parthn2 It's probably related, but this isn't enough analysis for me to confidently assign you to this issue. Please see my response to @riyagupta2011 above if you still want to attempt this.\n\nHello, @seanlip I found the solution of the issue. Basically the issue is related with CSS. So, I made the the changes in the file \"oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html\" .\r\nAnd got the below shown result\r\n\r\nhttps://user-images.githubusercontent.com/118007662/213844354-c933aac6-f342-4986-9523-351605d732f2.mp4\r\n\r\nPLEASE ASSIGN ME this ISSUE.\r\nAND If you need any changes do let me know. I will definitely get you the desired result.\n\n@AdityaRaimec22 No, this doesn't address the issue; you've removed the collapsed header altogether. See https://github.com/oppia/oppia/issues/16630#issuecomment-1385080955 for a more detailed suggestion.\n\nhi, can I work on this issue.\n\n@LovedeepSingh19 Again, per the guidance at https://github.com/oppia/oppia/wiki/Contributing-code-to-Oppia#choosing-a-good-first-issue, please provide an explanation of what your PR will do (with names of files you're changing, what you plan to change in each file, etc.). If it looks good, we can assign you to this issue.\r\n\r\nPlease also follow the other instructions on that wiki page if you have not yet done so.\r\n\r\n(And in future, make sure to read the existing comments on an issue before posting. Thanks!)\n\n@seanlip Hey sean, as @parthn2 said i went through the .ts file  and came across that the header collapses and runs in a loop while scrolling so i suggest we set the header should collapse once and should not repeat \r\n\r\nI came up with this solution\r\nlet headerCollapsed = false;\r\nscrollFunction(): void {\r\n    if (this.windowRef.nativeWindow.pageYOffset >= 80 && !headerCollapsed) {\r\n      this.defaultHeaderVisible = false;\r\n      headerCollapsed = true;\r\n    } else {\r\n      this.defaultHeaderVisible = true;\r\n    }\r\n  }\r\n\r\nCan this be of any helpfull. I'll be waiting for your kind reply\r\nYeah and Obviously I'm going to edit this file \"oppia/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.ts\"\n\n@DevBobby Please take a look at https://github.com/oppia/oppia/issues/16630#issuecomment-1385080955 for the desired behaviour.\n\n@DevBobby we can simply change the display:block; it solve the issues\r\n\n\nWouldnt it work if we simply use the display: block as said in the file \r\nhttps://github.com/oppia/oppia/blob/develop/core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html\r\n![Screenshot (34)](https://user-images.githubusercontent.com/113010708/215802467-72269013-1577-4809-a35d-3923ffe81cb9.png)\r\n",
  "pr_link": "https://github.com/oppia/oppia/pull/16513",
  "code_context": [
    {
      "filename": "assets/constants.ts",
      "content": "// We are using eslint disable here for multilines because we have used quotes\n// around properties at a lot of places so it is not possible to use\n// \"eslint disable next line\" for each of them.\n/* eslint-disable oppia/no-multiline-disable */\n/* eslint-disable quote-props */\n/* eslint-disable  @typescript-eslint/quotes */\n/* Don't modify anything outside the {} brackets.\n * Insides of the {} brackets should be formatted as a JSON object.\n * JSON rules:\n * 1. All keys and string values must be enclosed in double quotes.\n * 2. Each key/value pair should be on a new line.\n * 3. All values and keys must be constant, you can't use any Javascript\n *    functions.\n */\n\n/**\n * @fileoverview Initializes constants for the Oppia codebase.\n */\n\nexport default {\n  // The term 'staging' is used instead of the classroom url fragment field\n  // in the URL for topics that are not yet attached to a classroom.\n  \"CLASSROOM_URL_FRAGMENT_FOR_UNATTACHED_TOPICS\": \"staging\",\n\n  // Acceptable URL schemes for links.\n  \"ACCEPTABLE_SCHEMES\": [\"https\", \"\"],\n\n  // The default classroom URL fragment to use when the provided classroom URL\n  // fragment in the controller is invalid.\n  \"DEFAULT_CLASSROOM_URL_FRAGMENT\": \"math\",\n\n  \"ALL_CATEGORIES\": [\"Algebra\", \"Algorithms\", \"Architecture\", \"Arithmetic\",\n    \"Art\", \"Astronomy\", \"Biology\", \"Business\", \"Calculus\", \"Chemistry\",\n    \"Combinatorics\", \"Computing\", \"Economics\", \"Education\", \"Engineering\",\n    \"English\", \"Environment\", \"Gaulish\", \"Geography\", \"Geometry\", \"Government\",\n    \"Graph Theory\", \"History\", \"Languages\", \"Latin\", \"Law\", \"Logic\",\n    \"Mathematics\", \"Medicine\", \"Music\", \"Philosophy\", \"Physics\", \"Poetry\",\n    \"Probability\", \"Programming\", \"Puzzles\", \"Reading\", \"Spanish\", \"Sport\",\n    \"Statistics\", \"Trigonometry\", \"Welcome\"],\n  \"ACTIVITY_TYPE_EXPLORATION\": \"exploration\",\n  \"ACTIVITY_TYPE_COLLECTION\": \"collection\",\n  \"ACTIVITY_TYPE_STORY\": \"story\",\n  \"ACTIVITY_TYPE_LEARN_TOPIC\": \"learntopic\",\n  \"DISABLED_EXPLORATION_IDS\": [\"5\"],\n  \"TESTING_CONSTANT\": \"test\",\n  \"LIBRARY_TILE_WIDTH_PX\": 208,\n  \"LIBRARY_MOBILE_TILE_WIDTH_PX\": 350,\n  \"DASHBOARD_TYPE_CREATOR\": \"creator\",\n  \"DASHBOARD_TYPE_LEARNER\": \"learner\",\n  \"DEFAULT_COLOR\": \"#a33f40\",\n  \"DEFAULT_THUMBNAIL_ICON\": \"Lightbulb\",\n  \"DEFAULT_CATEGORY_ICON\": \"Lightbulb\",\n\n  \"ACTION_ACCEPT_SUGGESTION\": \"accept\",\n  \"ACTION_REJECT_SUGGESTION\": \"reject\",\n\n  \"SKILL_STATUS_OPTIONS\": {\n    \"ALL\": \"All\",\n    \"ASSIGNED\": \"Assigned\",\n    \"UNASSIGNED\": \"Unassigned\"\n  },\n  \"TOPIC_MINIMUM_QUESTIONS_TO_PRACTICE\": 10,\n  \"TOPIC_SKILL_DASHBOARD_SORT_OPTIONS\": {\n    \"IncreasingCreatedOn\": \"Newly Created\",\n    \"DecreasingCreatedOn\": \"Oldest Created\",\n    \"IncreasingUpdatedOn\": \"Most Recently Updated\",\n    \"DecreasingUpdatedOn\": \"Least Recently Updated\"\n  },\n  // These categories are shown in the library navbar. The categories should\n  // be in sorted order.\n  \"SEARCH_DROPDOWN_CATEGORIES\": [\"Algorithms\", \"Architecture\", \"Art\",\n    \"Biology\", \"Business\", \"Chemistry\", \"Economics\", \"English\", \"Geography\",\n    \"History\", \"Mathematics\", \"Medicine\", \"Music\", \"Physics\", \"Programming\",\n    \"Reading\", \"Statistics\"],\n\n  // These classrooms are shown in the add learner group syllabus filters.\n  \"SEARCH_DROPDOWN_CLASSROOMS\": [\"math\"],\n\n  // These types are shown in the add learner group syllabus filters.\n  \"SEARCH_DROPDOWN_TYPES\": [\"Skill\", \"Story\"],\n\n  // The default language code for an exploration.\n  \"DEFAULT_LANGUAGE_CODE\": \"en\",\n\n  // Hacky translation keys for classroom, topic, skill, exploration\n  // and subtopic names and descriptions. Needs to be updated whenever\n  // any new class, topic, skill, exploration or subtopic is added or a\n  // previous one is deleted.\n  // TODO(#14645): Remove these keys once translation service is extended.\n  \"HACKY_TRANSLATION_KEYS\": [\n    \"I18N_CLASSROOM_MATH_TITLE\",\n    \"I18N_TOPIC_iX9kYCjnouWN_TITLE\",\n    \"I18N_TOPIC_sWBXKH4PZcK6_TITLE\",\n    \"I18N_TOPIC_C4fqwrvqWpRm_TITLE\",\n    \"I18N_TOPIC_qW12maD4hiA8_TITLE\",\n    \"I18N_TOPIC_dLmjjMDbCcrf_TITLE\",\n    \"I18N_TOPIC_0abdeaJhmfPm_TITLE\",\n    \"I18N_TOPIC_5g0nxGUmx5J5_TITLE\",\n    \"I18N_TOPIC_iX9kYCjnouWN_DESCRIPTION\",\n    \"I18N_TOPIC_sWBXKH4PZcK6_DESCRIPTION\",\n    \"I18N_TOPIC_C4fqwrvqWpRm_DESCRIPTION\",\n    \"I18N_TOPIC_qW12maD4hiA8_DESCRIPTION\",\n    \"I18N_TOPIC_dLmjjMDbCcrf_DESCRIPTION\",\n    \"I18N_TOPIC_0abdeaJhmfPm_DESCRIPTION\",\n    \"I18N_TOPIC_5g0nxGUmx5J5_DESCRIPTION\",\n    \"I18N_EXPLORATION_K645IfRNzpKy_TITLE\",\n    \"I18N_EXPLORATION_K645IfRNzpKy_DESCRIPTION\",\n    \"I18N_EXPLORATION_Knvx24p24qPO_TITLE\",\n    \"I18N_EXPLORATION_Knvx24p24qPO_DESCRIPTION\",\n    \"I18N_EXPLORATION_aAkDKVDR53cG_TITLE\",\n    \"I18N_EXPLORATION_aAkDKVDR53cG_DESCRIPTION\",\n    \"I18N_EXPLORATION_avwshGklKLJE_TITLE\",\n    \"I18N_EXPLORATION_avwshGklKLJE_DESCRIPTION\",\n    \"I18N_EXPLORATION_OKxYhsWONHZV_TITLE\",\n    \"I18N_EXPLORATION_OKxYhsWONHZV_DESCRIPTION\",\n    \"I18N_EXPLORATION_BJd7yHIxpqkq_TITLE\",\n    \"I18N_EXPLORATION_BJd7yHIxpqkq_DESCRIPTION\",\n    \"I18N_EXPLORATION_W0xq3jW5GzDF_TITLE\",\n    \"I18N_EXPLORATION_W0xq3jW5GzDF_DESCRIPTION\",\n    \"I18N_EXPLORATION_53Ka3mQ6ra5A_TITLE\",\n    \"I18N_EXPLORATION_53Ka3mQ6ra5A_DESCRIPTION\",\n    \"I18N_EXPLORATION_VKXd8qHsxLml_TITLE\",\n    \"I18N_EXPLORATION_VKXd8qHsxLml_DESCRIPTION\",\n    \"I18N_EXPLORATION_PsfDKdhd6Esz_TITLE\",\n    \"I18N_EXPLORATION_PsfDKdhd6Esz_DESCRIPTION\",\n    \"I18N_EXPLORATION_9DITEN8BUEHw_TITLE\",\n    \"I18N_EXPLORATION_9DITEN8BUEHw_DESCRIPTION\",\n    \"I18N_EXPLORATION_R7WpsSfmDQPV_TITLE\",\n    \"I18N_EXPLORATION_R7WpsSfmDQPV_DESCRIPTION\",\n    \"I18N_EXPLORATION_zIBYaqfDJrJC_TITLE\",\n    \"I18N_EXPLORATION_zIBYaqfDJrJC_DESCRIPTION\",\n    \"I18N_EXPLORATION_1904tpP0CYwY_TITLE\",\n    \"I18N_EXPLORATION_1904tpP0CYwY_DESCRIPTION\",\n    \"I18N_EXPLORATION_cQDibOXQbpi7_TITLE\",\n    \"I18N_EXPLORATION_cQDibOXQbpi7_DESCRIPTION\",\n    \"I18N_EXPLORATION_MRJeVrKafW6G_TITLE\",\n    \"I18N_EXPLORATION_MRJeVrKafW6G_DESCRIPTION\",\n    \"I18N_EXPLORATION_hNOP3TwRJhsz_TITLE\",\n    \"I18N_EXPLORATION_hNOP3TwRJhsz_DESCRIPTION\",\n    \"I18N_EXPLORATION_zTg2hzTz37jP_TITLE\",\n    \"I18N_EXPLORATION_zTg2hzTz37jP_DESCRIPTION\",\n    \"I18N_EXPLORATION_8HTzQQUPiK5i_TITLE\",\n    \"I18N_EXPLORATION_8HTzQQUPiK5i_DESCRIPTION\",\n    \"I18N_EXPLORATION_40a3vjmZ7Fwu_TITLE\",\n    \"I18N_EXPLORATION_40a3vjmZ7Fwu_DESCRIPTION\",\n    \"I18N_EXPLORATION_WulCxGAmGE61_TITLE\",\n    \"I18N_EXPLORATION_WulCxGAmGE61_DESCRIPTION\",\n    \"I18N_EXPLORATION_lOU0XPC2BnE9_TITLE\",\n    \"I18N_EXPLORATION_lOU0XPC2BnE9_DESCRIPTION\",\n    \"I18N_EXPLORATION_wE9pyaC5np3n_TITLE\",\n    \"I18N_EXPLORATION_wE9pyaC5np3n_DESCRIPTION\",\n    \"I18N_EXPLORATION_umPkwp0L1M0-_TITLE\",\n    \"I18N_EXPLORATION_umPkwp0L1M0-_DESCRIPTION\",\n    \"I18N_EXPLORATION_MjZzEVOG47_1_TITLE\",\n    \"I18N_EXPLORATION_MjZzEVOG47_1_DESCRIPTION\",\n    \"I18N_EXPLORATION_9trAQhj6uUC2_TITLE\",\n    \"I18N_EXPLORATION_9trAQhj6uUC2_DESCRIPTION\",\n    \"I18N_EXPLORATION_rfX8jNkPnA-1_TITLE\",\n    \"I18N_EXPLORATION_rfX8jNkPnA-1_DESCRIPTION\",\n    \"I18N_EXPLORATION_0FBWxCE5egOw_TITLE\",\n    \"I18N_EXPLORATION_0FBWxCE5egOw_DESCRIPTION\",\n    \"I18N_EXPLORATION_670bU6d9JGBh_TITLE\",\n    \"I18N_EXPLORATION_670bU6d9JGBh_DESCRIPTION\",\n    \"I18N_EXPLORATION_aHikhPlxYgOH_TITLE\",\n    \"I18N_EXPLORATION_aHikhPlxYgOH_DESCRIPTION\",\n    \"I18N_EXPLORATION_-tMgcP1i_4au_TITLE\",\n    \"I18N_EXPLORATION_-tMgcP1i_4au_DESCRIPTION\",\n    \"I18N_EXPLORATION_zW39GLG_BdN2_TITLE\",\n    \"I18N_EXPLORATION_zW39GLG_BdN2_DESCRIPTION\",\n    \"I18N_EXPLORATION_Xa3B_io-2WI5_TITLE\",\n    \"I18N_EXPLORATION_Xa3B_io-2WI5_DESCRIPTION\",\n    \"I18N_EXPLORATION_6Q6IyIDkjpYC_TITLE\",\n    \"I18N_EXPLORATION_6Q6IyIDkjpYC_DESCRIPTION\",\n    \"I18N_EXPLORATION_osw1m5Q3jK41_TITLE\",\n    \"I18N_EXPLORATION_osw1m5Q3jK41_DESCRIPTION\",\n    \"I18N_EXPLORATION_2mzzFVDLuAj8_TITLE\",\n    \"I18N_EXPLORATION_2mzzFVDLuAj8_DESCRIPTION\",\n    \"I18N_EXPLORATION_5NWuolNcwH6e_TITLE\",\n    \"I18N_EXPLORATION_5NWuolNcwH6e_DESCRIPTION\",\n    \"I18N_EXPLORATION_k2bQ7z5XHNbK_TITLE\",\n    \"I18N_EXPLORATION_k2bQ7z5XHNbK_DESCRIPTION\",\n    \"I18N_EXPLORATION_tIoSb3HZFN6e_TITLE\",\n    \"I18N_EXPLORATION_tIoSb3HZFN6e_DESCRIPTION\",\n    \"I18N_EXPLORATION_nLmUS6lbmvnl_TITLE\",\n    \"I18N_EXPLORATION_nLmUS6lbmvnl_DESCRIPTION\",\n    \"I18N_EXPLORATION_Vgde5_ZVqrq5_TITLE\",\n    \"I18N_EXPLORATION_Vgde5_ZVqrq5_DESCRIPTION\",\n    \"I18N_EXPLORATION_RvopsvVdIb0J_TITLE\",\n    \"I18N_EXPLORATION_RvopsvVdIb0J_DESCRIPTION\",\n    \"I18N_EXPLORATION_zVbqxwck0KaC_TITLE\",\n    \"I18N_EXPLORATION_zVbqxwck0KaC_DESCRIPTION\",\n    \"I18N_EXPLORATION_rDJojPOc0KgJ_TITLE\",\n    \"I18N_EXPLORATION_rDJojPOc0KgJ_DESCRIPTION\",\n    \"I18N_EXPLORATION_kYSrbNDCv5sH_TITLE\",\n    \"I18N_EXPLORATION_kYSrbNDCv5sH_DESCRIPTION\",\n    \"I18N_EXPLORATION_K89Hgj2qRSzw_TITLE\",\n    \"I18N_EXPLORATION_K89Hgj2qRSzw_DESCRIPTION\",\n    \"I18N_EXPLORATION_lNpxiuqufPiw_TITLE\",\n    \"I18N_EXPLORATION_lNpxiuqufPiw_DESCRIPTION\",\n    \"I18N_EXPLORATION_Jbgc3MlRiY07_TITLE\",\n    \"I18N_EXPLORATION_Jbgc3MlRiY07_DESCRIPTION\",\n    \"I18N_EXPLORATION_rwN3YPG9XWZa_TITLE\",\n    \"I18N_EXPLORATION_rwN3YPG9XWZa_DESCRIPTION\",\n    \"I18N_EXPLORATION_nTMZwH7i0DdW_TITLE\",\n    \"I18N_EXPLORATION_nTMZwH7i0DdW_DESCRIPTION\",\n    \"I18N_EXPLORATION_IrbGLTicm0BI_TITLE\",\n    \"I18N_EXPLORATION_IrbGLTicm0BI_DESCRIPTION\",\n    \"I18N_EXPLORATION_v8fonNnX4Ub1_TITLE\",\n    \"I18N_EXPLORATION_v8fonNnX4Ub1_DESCRIPTION\",\n    \"I18N_EXPLORATION_ibeLZqbbjbKF_TITLE\",\n    \"I18N_EXPLORATION_ibeLZqbbjbKF_DESCRIPTION\",\n    \"I18N_EXPLORATION_BDIln52yGfeH_TITLE\",\n    \"I18N_EXPLORATION_BDIln52yGfeH_DESCRIPTION\",\n    \"I18N_EXPLORATION_SR1IKIdLxnm1_TITLE\",\n    \"I18N_EXPLORATION_SR1IKIdLxnm1_DESCRIPTION\",\n    \"I18N_EXPLORATION_m1nvGABWeUoh_TITLE\",\n    \"I18N_EXPLORATION_m1nvGABWeUoh_DESCRIPTION\",\n    \"I18N_EXPLORATION_zNb0Bh27QtJ4_TITLE\",\n    \"I18N_EXPLORATION_zNb0Bh27QtJ4_DESCRIPTION\",\n    \"I18N_EXPLORATION_5I4srORrwjt2_TITLE\",\n    \"I18N_EXPLORATION_5I4srORrwjt2_DESCRIPTION\",\n    \"I18N_EXPLORATION_aqJ07xrTFNLF_TITLE\",\n    \"I18N_EXPLORATION_aqJ07xrTFNLF_DESCRIPTION\",\n    \"I18N_EXPLORATION_0X0KC9DXWwra_TITLE\",\n    \"I18N_EXPLORATION_0X0KC9DXWwra_DESCRIPTION\",\n    \"I18N_STORY_RRVMHsZ5Mobh_TITLE\",\n    \"I18N_STORY_RRVMHsZ5Mobh_DESCRIPTION\",\n    \"I18N_STORY_Qu6THxP29tOy_TITLE\",\n    \"I18N_STORY_Qu6THxP29tOy_DESCRIPTION\",\n    \"I18N_STORY_vfJDB3JAdwIx_TITLE\",\n    \"I18N_STORY_vfJDB3JAdwIx_DESCRIPTION\",\n    \"I18N_STORY_rqnxwceQyFnv_TITLE\",\n    \"I18N_STORY_rqnxwceQyFnv_DESCRIPTION\",\n    \"I18N_STORY_3M5VBajMccXO_TITLE\",\n    \"I18N_STORY_3M5VBajMccXO_DESCRIPTION\",\n    \"I18N_STORY_JhiDkq01dqgC_TITLE\",\n    \"I18N_STORY_JhiDkq01dqgC_DESCRIPTION\",\n    \"I18N_STORY_ialKSV0VYV0B_TITLE\",\n    \"I18N_STORY_ialKSV0VYV0B_DESCRIPTION\",\n    \"I18N_SUBTOPIC_iX9kYCjnouWN_place-names-and-values_TITLE\",\n    \"I18N_SUBTOPIC_iX9kYCjnouWN_naming-numbers_TITLE\",\n    \"I18N_SUBTOPIC_iX9kYCjnouWN_comparing-numbers_TITLE\",\n    \"I18N_SUBTOPIC_iX9kYCjnouWN_rounding-numbers_TITLE\",\n    \"I18N_SUBTOPIC_sWBXKH4PZcK6_adding-numbers_TITLE\",\n    \"I18N_SUBTOPIC_sWBXKH4PZcK6_subtracting-numbers_TITLE\",\n    \"I18N_SUBTOPIC_sWBXKH4PZcK6_addition-subtraction_TITLE\",\n    \"I18N_SUBTOPIC_sWBXKH4PZcK6_estimation_TITLE\",\n    \"I18N_SUBTOPIC_sWBXKH4PZcK6_sequences _TITLE\",\n    \"I18N_SUBTOPIC_C4fqwrvqWpRm_basic-concepts_TITLE\",\n    \"I18N_SUBTOPIC_C4fqwrvqWpRm_memorizing-expressions_TITLE\",\n    \"I18N_SUBTOPIC_C4fqwrvqWpRm_multiplication-techniques_TITLE\",\n    \"I18N_SUBTOPIC_C4fqwrvqWpRm_rules-to-simplify_TITLE\",\n    \"I18N_SUBTOPIC_qW12maD4hiA8_basic-concepts_TITLE\",\n    \"I18N_SUBTOPIC_qW12maD4hiA8_techniques-of-division_TITLE\",\n    \"I18N_SUBTOPIC_qW12maD4hiA8_problem-solving_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_order-of-operations_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_variables_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_modelling-scenarios_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_problem-solving_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_algebraic-expressions_TITLE\",\n    \"I18N_SUBTOPIC_dLmjjMDbCcrf_solving-equations_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_what-is-a-fraction_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_fractions-of-a-group_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_equivalent-fractions_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_mixed-numbers_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_number-line_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_comparing-fractions_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_adding-fractions_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_subtracting-fractions_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_multiplying-fractions_TITLE\",\n    \"I18N_SUBTOPIC_0abdeaJhmfPm_dividing-fractions_TITLE\",\n    \"I18N_SUBTOPIC_5g0nxGUmx5J5_what-is-a-ratio_TITLE\",\n    \"I18N_SUBTOPIC_5g0nxGUmx5J5_equivalent-ratios_TITLE\",\n    \"I18N_SUBTOPIC_5g0nxGUmx5J5_calculations-with-ratios_TITLE\",\n    \"I18N_SUBTOPIC_5g0nxGUmx5J5_combining-ratios_TITLE\"\n  ],\n\n  \"ALLOWED_THUMBNAIL_BG_COLORS\": {\n    \"chapter\": [\"#F8BF74\", \"#D68F78\", \"#8EBBB6\", \"#B3D8F1\"],\n    \"topic\": [\"#C6DCDA\"],\n    \"subtopic\": [\"#FFFFFF\"],\n    \"story\": [\"#F8BF74\", \"#D68F78\", \"#8EBBB6\", \"#B3D8F1\"]\n  },\n\n  \"ALLOWED_IMAGE_FORMATS\": [\"svg\", \"png\", \"jpeg\", \"jpg\", \"gif\"],\n  \"MAX_ALLOWED_IMAGE_SIZE_IN_KB_FOR_BLOG\": 1024,\n\n  \"TASK_TYPE_HIGH_BOUNCE_RATE\": \"high_bounce_rate\",\n  \"TASK_TYPE_INEFFECTIVE_FEEDBACK_LOOP\": \"ineffective_feedback_loop\",\n  \"TASK_TYPE_SUCCESSIVE_INCORRECT_ANSWERS\": \"successive_incorrect_answers\",\n  \"TASK_TYPE_NEEDS_GUIDING_RESPONSES\": \"needs_guiding_responses\",\n\n  \"TASK_STATUS_OPEN\": \"open\",\n  \"TASK_STATUS_OBSOLETE\": \"obsolete\",\n  \"TASK_STATUS_RESOLVED\": \"resolved\",\n\n  \"TASK_ENTITY_TYPE_EXPLORATION\": \"exploration\",\n\n  \"TASK_TARGET_TYPE_STATE\": \"state\",\n\n  // Filters for adding new syllabus items to learner groups.\n  \"DEFAULT_ADD_SYLLABUS_FILTER\": \"All\",\n  \"LEARNER_GROUP_ADD_STORY_FILTER\": \"Story\",\n  \"LEARNER_GROUP_ADD_SKILL_FILTER\": \"Skill\",\n\n  // Roles in exploration.\n  \"ROLE_OWNER\": \"owner\",\n  \"ROLE_EDITOR\": \"editor\",\n  \"ROLE_VOICE_ARTIST\": \"voice artist\",\n  \"ROLE_VIEWER\": \"viewer\",\n\n  // The supported tags for the mailing list subscriptions.\n  \"MAILING_LIST_ANDROID_TAG\": \"Android\",\n  \"MAILING_LIST_WEB_TAG\": \"Web\",\n  // Regex to validate the format of Math rich-text component SVGs. If this is\n  // changed in the future, the existing filenames on the server should be\n  // handled as well.\n  // eslint-disable-next-line max-len\n  \"MATH_SVG_FILENAME_REGEX\": \"mathImg_[a-z0-9_]+_height_[0-9d]+_width_[0-9d]+_vertical_[0-9d]+.(svg)$\",\n\n  // This regex validates whether a given string is in the format of YYYY-MM-DD\n  // format.\n  \"DATE_REGEX\": \"^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$\",\n\n  // The SVG tag-specific attribute allowlist is based on the list of tags and\n  // and attributes specified in this project:\n  // https://github.com/cure53/DOMPurify\n  // The mapping of SVG tag to attribute is based on the following pages:\n  // https://github.com/wooorm/svg-element-attributes/blob/master/index.json\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n  // https://www.w3schools.com/graphics/svg_reference.asp\n  \"SVG_ATTRS_ALLOWLIST\": {\n    \"a\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"download\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"href\",\n      \"hreflang\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"ping\",\n      \"pointer-events\",\n      \"property\",\n      \"referrerpolicy\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"target\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"type\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"altglyph\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"format\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"glyphref\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"rotate\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"altglyphdef\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"altglyphitem\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"animatecolor\": [\n      \"about\",\n      \"accumulate\",\n      \"additive\",\n      \"alignment-baseline\",\n      \"attributename\",\n      \"attributetype\",\n      \"baseline-shift\",\n      \"begin\",\n      \"by\",\n      \"calcmode\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dur\",\n      \"enable-background\",\n      \"end\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"from\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"keysplines\",\n      \"keytimes\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"max\",\n      \"min\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"repeatcount\",\n      \"repeatdur\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"restart\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"to\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"values\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"animatemotion\": [\n      \"about\",\n      \"accumulate\",\n      \"additive\",\n      \"begin\",\n      \"by\",\n      \"calcmode\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"dur\",\n      \"end\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"from\",\n      \"href\",\n      \"id\",\n      \"keypoints\",\n      \"keysplines\",\n      \"keytimes\",\n      \"lang\",\n      \"max\",\n      \"min\",\n      \"origin\",\n      \"path\",\n      \"property\",\n      \"rel\",\n      \"repeatcount\",\n      \"repeatdur\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"restart\",\n      \"rev\",\n      \"rotate\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"to\",\n      \"typeof\",\n      \"values\"\n    ],\n    \"animatetransform\": [\n      \"about\",\n      \"accumulate\",\n      \"additive\",\n      \"attributename\",\n      \"attributetype\",\n      \"begin\",\n      \"by\",\n      \"calcmode\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"dur\",\n      \"end\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"from\",\n      \"href\",\n      \"id\",\n      \"keysplines\",\n      \"keytimes\",\n      \"lang\",\n      \"max\",\n      \"min\",\n      \"property\",\n      \"rel\",\n      \"repeatcount\",\n      \"repeatdur\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"restart\",\n      \"rev\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"to\",\n      \"type\",\n      \"typeof\",\n      \"values\"\n    ],\n    \"audio\": [\n      \"about\",\n      \"begin\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"dur\",\n      \"end\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"id\",\n      \"lang\",\n      \"max\",\n      \"min\",\n      \"property\",\n      \"rel\",\n      \"repeatcount\",\n      \"repeatdur\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"restart\",\n      \"rev\",\n      \"style\",\n      \"syncbehavior\",\n      \"syncmaster\",\n      \"synctolerance\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"canvas\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"circle\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"cx\",\n      \"cy\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"property\",\n      \"r\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"clippath\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"clippathunits\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"defs\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"desc\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"ellipse\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"cx\",\n      \"cy\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"rx\",\n      \"ry\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"feblend\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"in2\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"mode\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fecolormatrix\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"type\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"values\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fecomponenttransfer\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fecomposite\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"in2\",\n      \"k1\",\n      \"k2\",\n      \"k3\",\n      \"k4\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"operator\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"feconvolvematrix\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"bias\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"divisor\",\n      \"dominant-baseline\",\n      \"edgemode\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kernelmatrix\",\n      \"kernelunitlength\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"order\",\n      \"overflow\",\n      \"pointer-events\",\n      \"preservealpha\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"targetx\",\n      \"targety\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fediffuselighting\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"diffuseconstant\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kernelunitlength\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"surfacescale\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fedisplacementmap\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"in2\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"scale\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"xchannelselector\",\n      \"y\",\n      \"ychannelselector\"\n    ],\n    \"fedistantlight\": [\n      \"about\",\n      \"azimuth\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"elevation\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"feflood\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fefunca\": [\n      \"about\",\n      \"amplitude\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"exponent\",\n      \"id\",\n      \"intercept\",\n      \"lang\",\n      \"offset\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"slope\",\n      \"style\",\n      \"tabindex\",\n      \"tablevalues\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"fefuncb\": [\n      \"about\",\n      \"amplitude\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"exponent\",\n      \"id\",\n      \"intercept\",\n      \"lang\",\n      \"offset\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"slope\",\n      \"style\",\n      \"tabindex\",\n      \"tablevalues\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"fefuncg\": [\n      \"about\",\n      \"amplitude\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"exponent\",\n      \"id\",\n      \"intercept\",\n      \"lang\",\n      \"offset\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"slope\",\n      \"style\",\n      \"tabindex\",\n      \"tablevalues\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"fefuncr\": [\n      \"about\",\n      \"amplitude\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"exponent\",\n      \"id\",\n      \"intercept\",\n      \"lang\",\n      \"offset\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"slope\",\n      \"style\",\n      \"tabindex\",\n      \"tablevalues\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"fegaussianblur\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"edgemode\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stddeviation\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"femerge\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"femergenode\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"in\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"femorphology\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"operator\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"radius\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"feoffset\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fepointlight\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\",\n      \"x\",\n      \"y\",\n      \"z\"\n    ],\n    \"fespecularlighting\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kernelunitlength\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"specularconstant\",\n      \"specularexponent\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"surfacescale\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"fespotlight\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"limitingconeangle\",\n      \"pointsatx\",\n      \"pointsaty\",\n      \"pointsatz\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"specularexponent\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\",\n      \"x\",\n      \"y\",\n      \"z\"\n    ],\n    \"fetile\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"in\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"feturbulence\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"basefrequency\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"numoctaves\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"result\",\n      \"rev\",\n      \"seed\",\n      \"shape-rendering\",\n      \"stitchtiles\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"type\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"filter\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"filterres\",\n      \"filterunits\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"primitiveunits\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"font\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"horiz-adv-x\",\n      \"horiz-origin-x\",\n      \"horiz-origin-y\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"vert-adv-y\",\n      \"vert-origin-x\",\n      \"vert-origin-y\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"g\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"glyph\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"arabic-form\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"d\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-name\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"horiz-adv-x\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"orientation\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode\",\n      \"unicode-bidi\",\n      \"vert-adv-y\",\n      \"vert-origin-x\",\n      \"vert-origin-y\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"glyphref\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"format\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"glyphref\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"hkern\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"g1\",\n      \"g2\",\n      \"id\",\n      \"k\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\",\n      \"u1\",\n      \"u2\"\n    ],\n    \"image\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"crossorigin\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"href\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"type\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"line\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x1\",\n      \"x2\",\n      \"y1\",\n      \"y2\"\n    ],\n    \"lineargradient\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"gradienttransform\",\n      \"gradientunits\",\n      \"href\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"spreadmethod\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x1\",\n      \"x2\",\n      \"y1\",\n      \"y2\"\n    ],\n    \"marker\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"markerheight\",\n      \"markerunits\",\n      \"markerwidth\",\n      \"mask\",\n      \"opacity\",\n      \"orient\",\n      \"overflow\",\n      \"pointer-events\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"refx\",\n      \"refy\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"viewbox\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"mask\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"maskcontentunits\",\n      \"maskunits\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"metadata\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"mpath\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"externalresourcesrequired\",\n      \"href\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"path\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"d\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"pattern\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"href\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"patterncontentunits\",\n      \"patterntransform\",\n      \"patternunits\",\n      \"pointer-events\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"viewbox\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"polygon\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"points\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"polyline\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"points\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"radialgradient\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"cx\",\n      \"cy\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"fr\",\n      \"fx\",\n      \"fy\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"gradienttransform\",\n      \"gradientunits\",\n      \"href\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"r\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"spreadmethod\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"rect\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pathlength\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"rx\",\n      \"ry\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"stop\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"offset\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"style\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"media\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"title\",\n      \"type\",\n      \"typeof\"\n    ],\n    \"svg\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"baseprofile\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"contentscripttype\",\n      \"contentstyletype\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"height\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"playbackorder\",\n      \"playbackorder\",\n      \"pointer-events\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"snapshottime\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"syncbehaviordefault\",\n      \"synctolerancedefault\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"timelinebegin\",\n      \"timelinebegin\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"version\",\n      \"viewbox\",\n      \"visibility\",\n      \"width\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"xmlns\",\n      \"xmlns:xlink\",\n      \"y\",\n      \"zoomandpan\"\n    ],\n    \"switch\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"symbol\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"refx\",\n      \"refy\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"viewbox\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"text\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"editable\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"lengthadjust\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"rotate\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"textlength\",\n      \"transform\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"textpath\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"href\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"lengthadjust\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"method\",\n      \"opacity\",\n      \"overflow\",\n      \"path\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"shape-rendering\",\n      \"side\",\n      \"spacing\",\n      \"startoffset\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"textlength\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\"\n    ],\n    \"title\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"id\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"typeof\"\n    ],\n    \"tref\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"lengthadjust\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"resource\",\n      \"rev\",\n      \"rotate\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"textlength\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"tspan\": [\n      \"about\",\n      \"alignment-baseline\",\n      \"baseline-shift\",\n      \"class\",\n      \"clip\",\n      \"clip-path\",\n      \"clip-rule\",\n      \"color\",\n      \"color-interpolation\",\n      \"color-interpolation-filters\",\n      \"color-profile\",\n      \"color-rendering\",\n      \"content\",\n      \"cursor\",\n      \"datatype\",\n      \"direction\",\n      \"display\",\n      \"dominant-baseline\",\n      \"dx\",\n      \"dy\",\n      \"enable-background\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"fill-opacity\",\n      \"fill-rule\",\n      \"filter\",\n      \"flood-color\",\n      \"flood-opacity\",\n      \"focusable\",\n      \"focushighlight\",\n      \"font-family\",\n      \"font-size\",\n      \"font-size-adjust\",\n      \"font-stretch\",\n      \"font-style\",\n      \"font-variant\",\n      \"font-weight\",\n      \"glyph-orientation-horizontal\",\n      \"glyph-orientation-vertical\",\n      \"id\",\n      \"image-rendering\",\n      \"kerning\",\n      \"lang\",\n      \"lengthadjust\",\n      \"letter-spacing\",\n      \"lighting-color\",\n      \"marker-end\",\n      \"marker-mid\",\n      \"marker-start\",\n      \"mask\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"opacity\",\n      \"overflow\",\n      \"pointer-events\",\n      \"property\",\n      \"rel\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"rev\",\n      \"rotate\",\n      \"shape-rendering\",\n      \"stop-color\",\n      \"stop-opacity\",\n      \"stroke\",\n      \"stroke-dasharray\",\n      \"stroke-dashoffset\",\n      \"stroke-linecap\",\n      \"stroke-linejoin\",\n      \"stroke-miterlimit\",\n      \"stroke-opacity\",\n      \"stroke-width\",\n      \"style\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"text-anchor\",\n      \"text-decoration\",\n      \"text-rendering\",\n      \"textlength\",\n      \"typeof\",\n      \"unicode-bidi\",\n      \"visibility\",\n      \"word-spacing\",\n      \"writing-mode\",\n      \"x\",\n      \"y\"\n    ],\n    \"video\": [\n      \"about\",\n      \"begin\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"dur\",\n      \"end\",\n      \"externalresourcesrequired\",\n      \"fill\",\n      \"focusable\",\n      \"focushighlight\",\n      \"height\",\n      \"id\",\n      \"initialvisibility\",\n      \"lang\",\n      \"max\",\n      \"min\",\n      \"nav-down\",\n      \"nav-down-left\",\n      \"nav-down-right\",\n      \"nav-left\",\n      \"nav-next\",\n      \"nav-prev\",\n      \"nav-right\",\n      \"nav-up\",\n      \"nav-up-left\",\n      \"nav-up-right\",\n      \"overlay\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"repeatcount\",\n      \"repeatdur\",\n      \"requiredextensions\",\n      \"requiredfeatures\",\n      \"requiredfonts\",\n      \"requiredformats\",\n      \"resource\",\n      \"restart\",\n      \"rev\",\n      \"style\",\n      \"syncbehavior\",\n      \"syncmaster\",\n      \"synctolerance\",\n      \"systemlanguage\",\n      \"tabindex\",\n      \"transform\",\n      \"transformbehavior\",\n      \"type\",\n      \"typeof\",\n      \"width\",\n      \"x\",\n      \"y\"\n    ],\n    \"view\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"externalresourcesrequired\",\n      \"id\",\n      \"lang\",\n      \"preserveaspectratio\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\",\n      \"viewbox\",\n      \"viewtarget\",\n      \"zoomandpan\"\n    ],\n    \"vkern\": [\n      \"about\",\n      \"class\",\n      \"content\",\n      \"datatype\",\n      \"g1\",\n      \"g2\",\n      \"id\",\n      \"k\",\n      \"lang\",\n      \"property\",\n      \"rel\",\n      \"resource\",\n      \"rev\",\n      \"style\",\n      \"tabindex\",\n      \"typeof\",\n      \"u1\",\n      \"u2\"\n    ]\n  },\n\n  // List of supported default categories. For now, each category has a specific\n  // color associated with it. Each category also has a thumbnail icon whose\n  // filename is '{{CategoryName}}.svg'.\n  \"CATEGORIES_TO_COLORS\": {\n    \"Mathematics\": \"#cd672b\",\n    \"Algebra\": \"#cd672b\",\n    \"Arithmetic\": \"#d68453\",\n    \"Calculus\": \"#b86330\",\n    \"Logic\": \"#d68453\",\n    \"Combinatorics\": \"#cf5935\",\n    \"Graph Theory\": \"#cf5935\",\n    \"Probability\": \"#cf5935\",\n    \"Statistics\": \"#cd672b\",\n    \"Geometry\": \"#d46949\",\n    \"Trigonometry\": \"#d46949\",\n\n    \"Algorithms\": \"#d0982a\",\n    \"Computing\": \"#bb8b2f\",\n    \"Programming\": \"#d9aa53\",\n\n    \"Astronomy\": \"#879d6c\",\n    \"Biology\": \"#97a766\",\n    \"Chemistry\": \"#aab883\",\n    \"Engineering\": \"#8b9862\",\n    \"Environment\": \"#aba86d\",\n    \"Medicine\": \"#97a766\",\n    \"Physics\": \"#879d6c\",\n\n    \"Architecture\": \"#6e3466\",\n    \"Art\": \"#895a83\",\n    \"Music\": \"#6a3862\",\n    \"Philosophy\": \"#613968\",\n    \"Poetry\": \"#7f507f\",\n\n    \"English\": \"#193a69\",\n    \"Languages\": \"#1b4174\",\n    \"Latin\": \"#3d5a89\",\n    \"Reading\": \"#193a69\",\n    \"Spanish\": \"#405185\",\n    \"Gaulish\": \"#1b4174\",\n\n    \"Business\": \"#387163\",\n    \"Economics\": \"#5d8b7f\",\n    \"Geography\": \"#3c6d62\",\n    \"Government\": \"#538270\",\n    \"History\": \"#3d6b52\",\n    \"Law\": \"#538270\",\n\n    \"Education\": \"#942e20\",\n    \"Puzzles\": \"#a8554a\",\n    \"Sport\": \"#893327\",\n    \"Welcome\": \"#992a2b\"\n  },\n\n  \"INVALID_RTE_COMPONENTS_FOR_BLOG_POST_EDITOR\": [\"tabs\", \"skillreview\"],\n\n  // This is linked to VALID_RTE_COMPONENTS in android_validation_constants.\n  \"VALID_RTE_COMPONENTS_FOR_ANDROID\": [\"image\", \"math\", \"skillreview\"],\n\n  // This is linked to SUPPORTED_LANGUAGES in android_validation_constants.\n  \"SUPPORTED_CONTENT_LANGUAGES_FOR_ANDROID\": [{\n    \"code\": \"en\",\n    \"description\": \"English\",\n    \"decimal_separator\": \".\"\n  }],\n\n  // List of supported content languages in which we can create explorations or\n  // other entities. Each description has a parenthetical part that may be\n  // stripped out to give a shorter description.\n  // The decimal separators were derived from https://en.wikipedia.org/w/index.php?title=Decimal_separator&section=9#Usage_worldwide.\n  \"SUPPORTED_CONTENT_LANGUAGES\": [{\n    \"code\": \"en\",\n    \"description\": \"English\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"ar\",\n    \"description\": \" (Arabic)\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"sq\",\n    \"description\": \"shqip (Albanian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"am\",\n    \"description\": \" (Amharic)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"az\",\n    \"description\": \"Azeri (Azerbaijani)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"bg\",\n    \"description\": \" (Bulgarian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"bn\",\n    \"description\": \" (Bangla)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"ca\",\n    \"description\": \"catal (Catalan)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"zh\",\n    \"description\": \" (Chinese)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"hr\",\n    \"description\": \"hrvatski (Croatian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"cs\",\n    \"description\": \"etina (Czech)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"da\",\n    \"description\": \"dansk (Danish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"nl\",\n    \"description\": \"Nederlands (Dutch)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"fat\",\n    \"description\": \"Fanti\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"tl\",\n    \"description\": \"Filipino (Filipino)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"fi\",\n    \"description\": \"suomi (Finnish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"fr\",\n    \"description\": \"franais (French)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"lg\",\n    \"description\": \"Luganda (Ganda)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"de\",\n    \"description\": \"Deutsch (German)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"el\",\n    \"description\": \" (Greek)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ha\",\n    \"description\": \"Halshen Hausa (Hausa)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"he\",\n    \"description\": \" (Hebrew)\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"hi\",\n    \"description\": \" (Hindi)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"hi-en\",\n    \"description\": \"Hinglish\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"hu\",\n    \"description\": \"magyar (Hungarian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"id\",\n    \"description\": \"Bahasa Indonesia (Indonesian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ig\",\n    \"description\": \"ss gb (Igbo)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"it\",\n    \"description\": \"italiano (Italian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ja\",\n    \"description\": \" (Japanese)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"kab\",\n    \"description\": \"Taqbaylit (Kabyle)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ko\",\n    \"description\": \" (Korean)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"lv\",\n    \"description\": \"latvieu (Latvian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"lt\",\n    \"description\": \"lietuvi (Lithuanian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"mr\",\n    \"description\": \" (Marathi)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"no\",\n    \"description\": \"Norsk (Norwegian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"fa\",\n    \"description\": \" (Persian)\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"pcm\",\n    \"description\": \"Naij (Nigerian Pidgin)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"pl\",\n    \"description\": \"polszczyzna (Polish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"prs\",\n    \"description\": \" (Dari)\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"pt\",\n    \"description\": \"portugus (Portuguese)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ro\",\n    \"description\": \"romn (Romanian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ru\",\n    \"description\": \"p (Russian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"sr\",\n    \"description\": \"c (Serbian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"sk\",\n    \"description\": \"slovenina (Slovak)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"sl\",\n    \"description\": \"slovenina (Slovenian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"es\",\n    \"description\": \"espaol (Spanish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"sw\",\n    \"description\": \"kiswahili (Swahili)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"sv\",\n    \"description\": \"svenska (Swedish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ta\",\n    \"description\": \" (Tamil)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"th\",\n    \"description\": \" (Thai)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"code\": \"tr\",\n    \"description\": \"Trke (Turkish)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"uk\",\n    \"description\": \"y (Ukrainian)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"ur\",\n    \"description\": \" (Urdu)\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"vi\",\n    \"description\": \"Ting Vit (Vietnamese)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"code\": \"yo\",\n    \"description\": \"d Yob (Yoruba)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }],\n\n  // NOTE TO DEVELOPERS: While adding another language, please ensure that the\n  // languages are roughly in order of how much support we have for them in\n  // terms of lesson content translations.\n  // List of supported site languages in which the platform is offered.\n  // The decimal separators were derived from https://en.wikipedia.org/w/index.php?title=Decimal_separator&section=9#Usage_worldwide.\n  \"SUPPORTED_SITE_LANGUAGES\": [{\n    \"id\": \"en\",\n    \"text\": \"English\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"id\": \"pt-br\",\n    \"text\": \"Portugus (Brasil)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"ar\",\n    \"text\": \"\",\n    \"direction\": \"rtl\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"hi\",\n    \"text\": \"\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"id\": \"es\",\n    \"text\": \"Espaol\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"bn\",\n    \"text\": \"\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"id\": \"fr\",\n    \"text\": \"franais\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"id\",\n    \"text\": \"Bahasa Indonesia\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"pcm\",\n    \"text\": \"Naij (Nigerian Pidgin)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"uk\",\n    \"text\": \" \",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"sk\",\n    \"text\": \"slovenina\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"nl\",\n    \"text\": \"Nederlands\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"kab\",\n    \"text\": \"Taqbaylit (Kabyle)\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"vi\",\n    \"text\": \"Ting Vit\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"tr\",\n    \"text\": \"Trke\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \",\"\n  }, {\n    \"id\": \"zh-hans\",\n    \"text\": \"()\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }, {\n    \"id\": \"zh-hant\",\n    \"text\": \"()\",\n    \"direction\": \"ltr\",\n    \"decimal_separator\": \".\"\n  }],\n\n  // List of supported audio languages in which we have audio and translations\n  // for explorations or other entities.\n  // Related languages are used to prioritize an exploration's language when\n  // setting the default audio language.\n  \"SUPPORTED_AUDIO_LANGUAGES\": [{\n    \"id\": \"en\",\n    \"description\": \"English\",\n    \"relatedLanguages\": [\"en\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ak\",\n    \"description\": \"kn (Akan)\",\n    \"relatedLanguages\": [\"ak\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sq\",\n    \"description\": \"shqip (Albanian)\",\n    \"relatedLanguages\": [\"sq\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"am\",\n    \"description\": \" (Amharic)\",\n    \"relatedLanguages\": [\"am\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ar\",\n    \"description\": \" (Arabic)\",\n    \"relatedLanguages\": [\"ar\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"az\",\n    \"description\": \"Azeri (Azerbaijani)\",\n    \"relatedLanguages\": [\"az\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"bg\",\n    \"description\": \" (Bulgarian)\",\n    \"relatedLanguages\": [\"bg\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"bn\",\n    \"description\": \" (Bangla)\",\n    \"relatedLanguages\": [\"bn\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ms\",\n    \"description\": \" (Bahasa Melayu)\",\n    \"relatedLanguages\": [\"ms\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ca\",\n    \"description\": \"catal (Catalan)\",\n    \"relatedLanguages\": [\"ca\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"zh\",\n    \"description\": \" (Chinese)\",\n    \"relatedLanguages\": [\"zh\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"hr\",\n    \"description\": \"hrvatski (Croatian)\",\n    \"relatedLanguages\": [\"hr\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"cs\",\n    \"description\": \"etina (Czech)\",\n    \"relatedLanguages\": [\"cs\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"da\",\n    \"description\": \"dansk (Danish)\",\n    \"relatedLanguages\": [\"da\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"prs\",\n    \"description\": \" (Dari)\",\n    \"relatedLanguages\": [\"prs\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"nl\",\n    \"description\": \"Nederlands (Dutch)\",\n    \"relatedLanguages\": [\"nl\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ee\",\n    \"description\": \"Eegbe (Ewe)\",\n    \"relatedLanguages\": [\"ee\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"fat\",\n    \"description\": \"Fante (Fanti)\",\n    \"relatedLanguages\": [\"ak\", \"fat\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"tl\",\n    \"description\": \"Filipino (Filipino)\",\n    \"relatedLanguages\": [\"tl\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"fi\",\n    \"description\": \"suomi (Finnish)\",\n    \"relatedLanguages\": [\"fi\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"fr\",\n    \"description\": \"franais (French)\",\n    \"relatedLanguages\": [\"fr\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"lg\",\n    \"description\": \"Luganda (Ganda)\",\n    \"relatedLanguages\": [\"lg\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"de\",\n    \"description\": \"Deutsch (German)\",\n    \"relatedLanguages\": [\"de\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"el\",\n    \"description\": \" (Greek)\",\n    \"relatedLanguages\": [\"el\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"gaa\",\n    \"description\": \"G (Ga)\",\n    \"relatedLanguages\": [\"gaa\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ha\",\n    \"description\": \"Halshen Hausa (Hausa)\",\n    \"relatedLanguages\": [\"ha\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"he\",\n    \"description\": \" (Hebrew)\",\n    \"relatedLanguages\": [\"he\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"hi\",\n    \"description\": \" (Hindi)\",\n    \"relatedLanguages\": [\"hi\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"hi-en\",\n    \"description\": \"Hinglish\",\n    \"relatedLanguages\": [\"hi\", \"en\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"hu\",\n    \"description\": \"magyar (Hungarian)\",\n    \"relatedLanguages\": [\"hu\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"id\",\n    \"description\": \"Bahasa Indonesia (Indonesian)\",\n    \"relatedLanguages\": [\"id\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ig\",\n    \"description\": \"ss gb (Igbo)\",\n    \"relatedLanguages\": [\"igbo\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"it\",\n    \"description\": \"italiano (Italian)\",\n    \"relatedLanguages\": [\"it\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ja\",\n    \"description\": \" (Japanese)\",\n    \"relatedLanguages\": [\"ja\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"kab\",\n    \"description\": \"Taqbaylit (Kabyle)\",\n    \"relatedLanguages\": [\"kab\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ko\",\n    \"description\": \" (Korean)\",\n    \"relatedLanguages\": [\"ko\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"lv\",\n    \"description\": \"latvieu (Latvian)\",\n    \"relatedLanguages\": [\"lv\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"lt\",\n    \"description\": \"lietuvi (Lithuanian)\",\n    \"relatedLanguages\": [\"lt\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"mr\",\n    \"description\": \" (Marathi)\",\n    \"relatedLanguages\": [\"mr\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"no\",\n    \"description\": \"Norsk (Norwegian)\",\n    \"relatedLanguages\": [\"no\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"fa\",\n    \"description\": \" (Persian)\",\n    \"relatedLanguages\": [\"fa\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"pcm\",\n    \"description\": \"Naij (Nigerian Pidgin)\",\n    \"relatedLanguages\": [\"pcm\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"pl\",\n    \"description\": \"polszczyzna (Polish)\",\n    \"relatedLanguages\": [\"pl\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"pt\",\n    \"description\": \"portugus (Portuguese)\",\n    \"relatedLanguages\": [\"pt\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ps\",\n    \"description\": \" (Pashto)\",\n    \"relatedLanguages\": [\"ps\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"ro\",\n    \"description\": \"romn (Romanian)\",\n    \"relatedLanguages\": [\"ro\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ru\",\n    \"description\": \"p (Russian)\",\n    \"relatedLanguages\": [\"ru\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sr\",\n    \"description\": \"c (Serbian)\",\n    \"relatedLanguages\": [\"sr\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sk\",\n    \"description\": \"slovenina (Slovak)\",\n    \"relatedLanguages\": [\"sk\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sl\",\n    \"description\": \"slovenina (Slovenian)\",\n    \"relatedLanguages\": [\"sl\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"es\",\n    \"description\": \"espaol (Spanish)\",\n    \"relatedLanguages\": [\"es\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sw\",\n    \"description\": \"kiswahili (Swahili)\",\n    \"relatedLanguages\": [\"sw\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"sv\",\n    \"description\": \"svenska (Swedish)\",\n    \"relatedLanguages\": [\"sv\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ta\",\n    \"description\": \" (Tamil)\",\n    \"relatedLanguages\": [\"ta\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"te\",\n    \"description\": \" (Telugu)\",\n    \"relatedLanguages\": [\"te\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"th\",\n    \"description\": \" (Thai)\",\n    \"relatedLanguages\": [\"th\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"tr\",\n    \"description\": \"Trke (Turkish)\",\n    \"relatedLanguages\": [\"tr\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"uk\",\n    \"description\": \"y (Ukrainian)\",\n    \"relatedLanguages\": [\"uk\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"ur\",\n    \"description\": \" (Urdu)\",\n    \"relatedLanguages\": [\"ur\"],\n    \"direction\": \"rtl\"\n  }, {\n    \"id\": \"vi\",\n    \"description\": \"Ting Vit (Vietnamese)\",\n    \"relatedLanguages\": [\"vi\"],\n    \"direction\": \"ltr\"\n  }, {\n    \"id\": \"yo\",\n    \"description\": \"d Yob (Yoruba)\",\n    \"relatedLanguages\": [\"yo\"],\n    \"direction\": \"ltr\"\n  }],\n\n  \"AUTOGENERATED_AUDIO_LANGUAGES\": [{\n    \"id\": \"en-auto\",\n    \"description\": \"English (auto)\",\n    \"explorationLanguage\": \"en\",\n    \"speechSynthesisCode\": \"en-US\",\n    \"speechSynthesisCodeMobile\": \"en_US\"\n  }],\n\n  \"TRANSLATION_TIPS\": {\n    // Arabic.\n    \"ar\": [\n      // eslint-disable-next-line max-len\n      \"In Oppia, we prefer to use simple words that can be easily understood by children. For example, we use   instead of  . Furthermore, the English words that are used in the Arab society regularly can be translated as follows; Arabic word (The regularly used English word). For example, we can translate the word cupcakes this way;    (cupcakes). \",\n      // eslint-disable-next-line max-len\n      \"Use respectful ways and formal prefixes to address people. For example, use  and . \",\n      // eslint-disable-next-line max-len\n      \"If the name has a meaning in Arabic, or in English, such as Baker or Crumb, always use words that indicate that they are names before writing the name itself. For example, you can use one of the following words depending on the context;      .\",\n      \"Use the same voice (active or passive) as in the original English Text\",\n      // eslint-disable-next-line max-len\n      \"Preserve punctuation and bolding. If the original content has bold text, make sure it is bold in Arabic as well. If there are bullet points, double quotes, etc., make sure that the translated content also has bullet points and double quotes.\",\n      // eslint-disable-next-line max-len\n      \"Use the hyperlinks to different cards as shown in the original English Text.\"\n    ],\n    // Bangla.\n    \"bn\": [\n      // eslint-disable-next-line max-len\n      \"Use simple Bangla words that are used in daily communication. Note that common English words (pencil, etc.) can be written as transliterations (e.g  ).\",\n      \"Use proper punctuation.\",\n      \"Full stop = |\",\n      // eslint-disable-next-line max-len\n      \"Use the same voice (active or passive) as in the original English text.\",\n      // eslint-disable-next-line max-len\n      \"Preserve punctuation and bolding. If the original content has bold text, make sure it is bold in Bangla as well. If there are bullet points, double quotes, etc., make sure that the translated content also has bullet points and double quotes.\"\n    ],\n    // Chinese.\n    \"zh\": [\n      // eslint-disable-next-line max-len\n      \"Write fractions or numbers as they are, unless they are written out in words. For instance, one-fifth would be ()\",\n      // eslint-disable-next-line max-len\n      \"When referring to Mr. Baker (or, in general, Mr./Ms. followed by an occupation), leave it as Baker, since in certain cases Baker is the last name.\",\n      \"Make sure to use the correct punctuation:\",\n      \"Period = \",\n      \"Comma for compound sentences or translation phrases = \",\n      \"Comma for list of numbers or objects = \",\n      // eslint-disable-next-line max-len\n      \"Preserve bolding. If the original content has bold text, make sure it is bold in Chinese as well.\",\n      // eslint-disable-next-line max-len\n      \"Make sure that you have selected the correct words (e.g. words such as  and  ).\"\n    ],\n    // Hindi.\n    \"hi\": [\n      // eslint-disable-next-line max-len\n      \"Prefer simple Hindi words that are used in daily communication Note that common English words (pen, paper, cake, etc.) can be written as transliterations (, , ). For harder words, include the English word in parentheses, e.g.  (Numerator),  (Denominator),  (Fraction).\",\n      // eslint-disable-next-line max-len\n      \"Use respectful pronouns (like  instead of / ) and a corresponding respectful tone like , .\",\n      // eslint-disable-next-line max-len\n      \"Feel free to change the voice and order of phrases to make the text readable.\",\n      // eslint-disable-next-line max-len\n      \"Preserve punctuation and bolding. If the original content has bold text, make sure it is bold in Hindi as well. If there are bullet points, double quotes, etc., make sure that the translated content also has bullet points and double quotes.\",\n      // eslint-disable-next-line max-len\n      \"If the original card has components (such as pictures, links, and equations), these need to be added to the translated content. You can use the Copy tool for this -- click on the Copy tool and then click on the component you want to carry over. Also, double-click on the image and translate the alt text (and caption, if any).\",\n      // eslint-disable-next-line max-len\n      \"Refer to Glossary - https://docs.google.com/spreadsheets/d/13NMEnYqLZuMbeX1Z6XXG-femHkKNAN8KwjhaC67EkxI/edit#gid=0\"\n    ],\n    // Spanish.\n    \"es\": [\n      \"Include proper punctuation, blank!, question? and accent marks.\",\n      // eslint-disable-next-line max-len\n      \"In Spanish, the nouns are usually gendered. Make sure to use the correct article gender for the noun gender (el gato, la casa , las mujeres, los hombres etc.) El is usually used for masculine singular and la is usually for feminine singular. Los for masculine plural and las for feminine plural.\",\n      // eslint-disable-next-line max-len\n      \"Try to make sure that the accents are placed correctly as it can make a big difference in meaning for the reader (tu = your vs. t = informal you, si = if vs. s = yes).\",\n      // eslint-disable-next-line max-len\n      \"Preserve punctuation and bolding. If the original content has bold text, make sure it is bold in Spanish as well. If there are bullet points, double quotes, etc., make sure that the translated content also has bullet points and double quotes.\"\n    ],\n    // Portuguese.\n    \"pt\": [\n      // eslint-disable-next-line max-len\n      \"When translating names of mathematical terms, look for how these names are used in Brazilian education/literature instead of translating literally. For example, while the names may be similar in some cases (e.g. \\\"The Commutative Property of Multiplication\\\" would be \\\"A Propriedade Comutativa da Multiplicao\\\"), in other cases the literal translation will not match the names used in Brazil (e.g. \\\"The Carrying Method of multiplication\\\" would be \\\"O Mtodo Tradicional de Multiplicao\\\"). Also, terms like \\\"Place Values\\\" may have a different translation depending on the context, which may be \\\"casa\\\"/\\\"ordem\\\" or \\\"valor relativo\\\".\",\n      // eslint-disable-next-line max-len\n      \"When writing a number, remember that \\\",\\\" in English corresponds to \\\".\\\" in Portuguese, and vice-versa.\",\n      // eslint-disable-next-line max-len\n      \"Prefer to use friendly words and sentences for children. For example, instead of using \\\"Diga-me o nome...\\\" or \\\"vou pedir-lhe ajuda\\\", you can write the sentence with a more informal language like \\\"Me diga o nome...\\\" or \\\"vou pedir a sua ajuda\\\".\",\n      // eslint-disable-next-line max-len\n      \"In English some nouns/articles are neutral. In Portuguese the nouns are usually gendered. Be careful not to generate inconsistencies and make sure to use the correct article gender for the noun gender. For example: Nina and Sandra loved the cake. They went out to buy more. In Portuguese: Nina e Sandra adoraram o bolo. Elas saram para comprar mais.\",\n      // eslint-disable-next-line max-len\n      \"Preserve punctuation and bolding. If the original content has bold text, make sure it is bold in Portuguese as well. If there are bullet points, double quotes, etc., make sure that the translated content also has bullet points and double quotes.\",\n      // eslint-disable-next-line max-len\n      \"If the original card has components (such as pictures, links, and equations), these need to be added to the translated content. You can use the Copy tool for this -- click on the Copy tool and then click on the component you want to carry over. Also, double-click on the image and translate the alt text (and caption, if any).\",\n      // eslint-disable-next-line max-len\n      \"Images with text in English should be edited and replaced by the same images with the same text in Portuguese. If you don't know how to edit the image, please skip the translation.\",\n      // eslint-disable-next-line max-len\n      \"If you think you need more context in order to get the right terms and nouns, please play the lesson once before submitting the translation.\",\n      // eslint-disable-next-line max-len\n      \"Keep in mind that some English puns may not work for Portuguese, so you might need to adjust them or construct the same sentence without the pun.\",\n      \"When translating a currency, replace \\\"Dollar\\\" for \\\"Real\\\".\"\n    ]\n  },\n\n  // Types of view in creator dashboard page.\n  \"ALLOWED_CREATOR_DASHBOARD_DISPLAY_PREFS\": {\n    \"CARD\": \"card\",\n    \"LIST\": \"list\"\n  },\n\n  \"EMAIL_REGEX\": \"^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+\",\n\n  \"ALLOWED_QUESTION_INTERACTION_CATEGORIES\": [{\n    \"name\": \"Commonly Used\",\n    \"interaction_ids\": [\n      \"ImageClickInput\",\n      \"ItemSelectionInput\",\n      \"MultipleChoiceInput\",\n      \"TextInput\",\n      \"DragAndDropSortInput\",\n      \"NumericInput\"\n    ]\n  }, {\n    \"name\": \"Math\",\n    \"interaction_ids\": [\n      \"FractionInput\",\n      \"NumberWithUnits\",\n      \"NumericInput\"\n    ]\n  }],\n\n  // These are linked to the VALID_INTERACTION_IDS constant in\n  // android_validation_constants.py.\n  \"ALLOWED_EXPLORATION_IN_STORY_INTERACTION_CATEGORIES\": [{\n    \"name\": \"General\",\n    \"interaction_ids\": [\n      \"Continue\",\n      \"EndExploration\",\n      \"ImageClickInput\",\n      \"ItemSelectionInput\",\n      \"MultipleChoiceInput\",\n      \"TextInput\",\n      \"DragAndDropSortInput\"\n    ]\n  }, {\n    \"name\": \"Math\",\n    \"interaction_ids\": [\n      \"FractionInput\",\n      \"NumericInput\",\n      \"NumericExpressionInput\",\n      \"AlgebraicExpressionInput\",\n      \"MathEquationInput\",\n      \"NumberWithUnits\",\n      \"RatioExpressionInput\"\n    ]\n  }],\n\n  // These categories and interactions are displayed in the order in which they\n  // appear in the interaction selector.\n  \"ALLOWED_INTERACTION_CATEGORIES\": [{\n    \"name\": \"Commonly Used\",\n    \"interaction_ids\": [\n      \"Continue\",\n      \"EndExploration\",\n      \"ImageClickInput\",\n      \"ItemSelectionInput\",\n      \"MultipleChoiceInput\",\n      \"NumericInput\",\n      \"TextInput\",\n      \"DragAndDropSortInput\"\n    ]\n  }, {\n    \"name\": \"Math\",\n    \"interaction_ids\": [\n      \"FractionInput\",\n      \"GraphInput\",\n      \"NumericInput\",\n      \"SetInput\",\n      \"NumericExpressionInput\",\n      \"AlgebraicExpressionInput\",\n      \"MathEquationInput\",\n      \"NumberWithUnits\",\n      \"RatioExpressionInput\"\n    ]\n  }, {\n    \"name\": \"Programming\",\n    \"interaction_ids\": [\n      \"CodeRepl\",\n      \"PencilCodeEditor\"\n    ]\n  }, {\n    \"name\": \"Music\",\n    \"interaction_ids\": [\n      \"MusicNotesInput\"\n    ]\n  }, {\n    \"name\": \"Geography\",\n    \"interaction_ids\": [\n      \"InteractiveMap\"\n    ]\n  }],\n\n  \"MIN_CHOICES_IN_MULTIPLE_CHOICE_INPUT_CURATED_EXP\": 4,\n  \"MIN_CHOICES_IN_MULTIPLE_CHOICE_INPUT_REGULAR_EXP\": 2,\n\n  \"CONTRIBUTION_RIGHT_CATEGORY_REVIEW_TRANSLATION\": \"translation\",\n  \"CONTRIBUTION_RIGHT_CATEGORY_REVIEW_VOICEOVER\": \"voiceover\",\n  \"CONTRIBUTION_RIGHT_CATEGORY_REVIEW_QUESTION\": \"question\",\n  \"CONTRIBUTION_RIGHT_CATEGORY_SUBMIT_QUESTION\": \"submit_question\",\n  \"CONTRIBUTION_RIGHT_CATEGORIES\": [\n    \"translation\", \"voiceover\", \"question\", \"submit_question\"\n  ],\n\n  \"SUGGESTIONS_SORT_KEY_DATE\": \"Date\",\n\n  \"ACTION_REMOVE_ALL_REVIEW_RIGHTS\": \"all\",\n  \"ACTION_REMOVE_SPECIFIC_CONTRIBUTION_RIGHTS\": \"specific\",\n  \"USER_FILTER_CRITERION_USERNAME\": \"username\",\n  \"USER_FILTER_CRITERION_ROLE\": \"role\",\n\n  // Interaction IDs for which answer details cannot be solicited.\n  \"INTERACTION_IDS_WITHOUT_ANSWER_DETAILS\": [\"EndExploration\", \"Continue\"],\n\n  \"WHITELISTED_COLLECTION_IDS_FOR_SAVING_GUEST_PROGRESS\": [],\n\n  \"FEEDBACK_SUBJECT_MAX_CHAR_LIMIT\": 50,\n\n  \"MAX_CURRENT_GOALS_COUNT\": 5,\n\n  \"ACTIVITY_STATUS_PRIVATE\": \"private\",\n  \"ACTIVITY_STATUS_PUBLIC\": \"public\",\n\n  \"SITE_FEEDBACK_FORM_URL\": \"\",\n\n  \"SYSTEM_USER_IDS\": [\"admin\", \"OppiaMigrationBot\"],\n\n  // A string containing the disallowed characters in state or exploration\n  // names. The underscore is needed because spaces in names must be converted\n  // to underscores when displayed as part of a URL or key. The other\n  // conventions here are derived from the Wikipedia guidelines for naming\n  // articles.\n  \"INVALID_NAME_CHARS\": [\n    \":\", \"#\", \"/\", \"|\", \"_\", \"%\", \"<\", \">\", \"[\", \"]\", \"{\", \"}\", \"\\\\ufffd\",\n    \"\\\\\\\\\", \"\\\\u007f\", \"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\",\n    \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", \"\\\\b\", \"\\\\t\", \"\\\\n\", \"\\\\u000b\", \"\\\\f\",\n    \"\\\\r\", \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\",\n    \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\",\n    \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"\n  ],\n\n  \"DEFAULT_SKILL_DIFFICULTY\": 0.6,\n\n  \"INLINE_RTE_COMPONENTS\": [\"link\", \"math\", \"skillreview\"],\n\n  // If new difficulties are added or the names changed, only the constants\n  // below need to be edited.\n  \"SKILL_DIFFICULTY_EASY\": \"Easy\",\n  \"SKILL_DIFFICULTY_MEDIUM\": \"Medium\",\n  \"SKILL_DIFFICULTY_HARD\": \"Hard\",\n\n  \"SKILL_DIFFICULTIES\": [\"Easy\", \"Medium\", \"Hard\"],\n\n  \"SKILL_DIFFICULTY_LABEL_TO_FLOAT\": {\n    \"Easy\": 0.3,\n    \"Medium\": 0.6,\n    \"Hard\": 0.9\n  },\n\n  \"ENABLE_PREREQUISITE_SKILLS\": false,\n\n  \"ENABLE_NEW_STRUCTURE_VIEWER_UPDATES\": true,\n\n  \"ENABLE_SOLICIT_ANSWER_DETAILS_FEATURE\": true,\n\n  \"MAX_SKILLS_PER_QUESTION\": 3,\n\n  \"MAX_QUESTIONS_PER_SKILL\": 10,\n\n  \"NUM_EXPLORATIONS_PER_REVIEW_TEST\": 3,\n\n  \"NUM_QUESTIONS_PER_PAGE\": 10,\n\n  \"MIN_QUESTION_COUNT_FOR_A_DIAGNOSTIC_TEST_SKILL\": 3,\n\n  \"BULK_EMAIL_SERVICE_SIGNUP_URL\": \"\",\n\n  // The default number of opportunities to show on the contributor dashboard\n  // page.\n  \"OPPORTUNITIES_PAGE_SIZE\": 10,\n\n  // The breakpoint for mobile view for contributor dashboard in px.\n  // This value must be the same as the one specified in\n  // opportunities-list-item.component.html.\n  \"OPPORTUNITIES_LIST_ITEM_MOBILE_BREAKPOINT\": 700,\n\n  // Represents the string value indicating \"All topics\" in the Contributor\n  // Dashboard topic selector.\n  \"TOPIC_SENTINEL_NAME_ALL\": \"All\",\n\n  // The following character limit constraints follow from\n  // android_validation_constants.py. Both have to be kept in sync.\n\n  // This represents the maximum number of characters in the URL fragment for\n  // classroom in the classroom page URL. E.g. in /learn/math/...,\n  // 'math' is the 'classroom URL fragment'.\n  \"MAX_CHARS_IN_CLASSROOM_URL_FRAGMENT\": 20,\n  \"MAX_CHARS_IN_CLASSROOM_NAME\": 39,\n  \"MAX_CHARS_IN_TOPIC_NAME\": 39,\n  \"MAX_CHARS_IN_ABBREV_TOPIC_NAME\": 12,\n  // This represents the maximum number of characters in the URL fragment for\n  // topic in the topic page URL. E.g. in /learn/math/fractions/...,\n  // 'fractions' is the 'topic URL fragment'.\n  \"MAX_CHARS_IN_TOPIC_URL_FRAGMENT\": 20,\n  \"MAX_CHARS_IN_TOPIC_DESCRIPTION\": 240,\n  \"MAX_CHARS_IN_SUBTOPIC_TITLE\": 64,\n  \"MAX_CHARS_IN_SKILL_DESCRIPTION\": 100,\n  \"MAX_CHARS_IN_STORY_TITLE\": 39,\n  \"MAX_CHARS_IN_STORY_DESCRIPTION\": 1000,\n  \"MAX_CHARS_IN_EXPLORATION_TITLE\": 36,\n  \"MAX_CHARS_IN_CHAPTER_DESCRIPTION\": 152,\n  \"MAX_CHARS_IN_MISCONCEPTION_NAME\": 100,\n  \"MAX_CHARS_IN_BLOG_POST_TITLE\": 65,\n  \"MIN_CHARS_IN_BLOG_POST_TITLE\": 5,\n  \"MAX_CHARS_IN_BLOG_POST_SUMMARY\": 300,\n  \"MAX_CHARS_IN_LEARNER_GROUP_TITLE\": 36,\n  \"STORY_ID_LENGTH\": 12,\n  // This represents the maximum number of characters in the URL fragment for\n  // story in the story page URL. E.g.\n  // in /learn/math/fractions/story/bakery/..., 'bakery' is the\n  // 'story URL fragment'.\n  \"MAX_CHARS_IN_STORY_URL_FRAGMENT\": 30,\n  // This represents the maximum number of characters in the URL fragment for\n  // subtopic in the revision page URL. E.g.\n  // in /learn/math/fractions/revision/place-values, 'place-values' is the\n  // 'subtopic URL fragment'.\n  \"MAX_CHARS_IN_SUBTOPIC_URL_FRAGMENT\": 25,\n  // This represents the maximum number of characters in the URL fragment for\n  // the blog post.\n  \"MAX_CHARS_IN_BLOG_POST_URL_FRAGMENT\": 65,\n  // The recommended length for meta tag contents. Search engines will truncate\n  // results greater than this limit.\n  \"MAX_CHARS_IN_META_TAG_CONTENT\": 160,\n  \"MIN_CHARS_IN_PAGE_TITLE_FRAGMENT_FOR_WEB\": 5,\n  \"MAX_CHARS_IN_PAGE_TITLE_FRAGMENT_FOR_WEB\": 50,\n  // The maximum number of questions can exceed this by at most 3\n  // (i.e., 18 questions) in some special cases when the user has attempted 14\n  // questions and another topic is tested for more accurate results. For all\n  // other cases, 15 questions is the upper limit.\n  \"MAX_ALLOWED_QUESTIONS_IN_THE_DIAGNOSTIC_TEST\": 15,\n\n  \"NEW_STATE_TEMPLATE\": {\n    \"classifier_model_id\": null,\n    \"linked_skill_id\": null,\n    \"content\": {\n      \"html\": \"\",\n      \"content_id\": \"content\"\n    },\n    \"interaction\": {\n      \"id\": null,\n      \"customization_args\": {},\n      \"answer_groups\": [],\n      \"default_outcome\": {\n        \"dest\": \"Introduction\",\n        \"dest_if_really_stuck\": null,\n        \"feedback\": {\n          \"content_id\": \"default_outcome\",\n          \"html\": \"\"\n        },\n        \"labelled_as_correct\": false,\n        \"param_changes\": [],\n        \"refresher_exploration_id\": null,\n        \"missing_prerequisite_skill_id\": null\n      },\n      \"confirmed_unclassified_answers\": [],\n      \"hints\": [],\n      \"solution\": null\n    },\n    \"next_content_id_index\": 0,\n    \"param_changes\": [],\n    \"recorded_voiceovers\": {\n      \"voiceovers_mapping\": {\n        \"content\": {},\n        \"default_outcome\": {}\n      }\n    },\n    \"solicit_answer_details\": false,\n    \"card_is_checkpoint\": false,\n    \"written_translations\": {\n      \"translations_mapping\": {\n        \"content\": {},\n        \"default_outcome\": {}\n      }\n    }\n  },\n\n  // Data required for Firebase authentication.\n  //\n  // NOTE TO RELEASE COORDINATORS: Please change these to the production values,\n  // and change useEmulator to be false, before deploying to production.\n  \"FIREBASE_CONFIG_API_KEY\": \"fake-api-key\",\n  \"FIREBASE_CONFIG_AUTH_DOMAIN\": \"\",\n  \"FIREBASE_CONFIG_PROJECT_ID\": \"dev-project-id\",\n  \"FIREBASE_CONFIG_STORAGE_BUCKET\": \"\",\n  \"FIREBASE_CONFIG_MESSAGING_SENDER_ID\": \"\",\n  \"FIREBASE_CONFIG_APP_ID\": \"\",\n  \"FIREBASE_CONFIG_GOOGLE_CLIENT_ID\": \"\",\n\n  // The name of the cookie Oppia will place the session cookie into. The name\n  // is arbitrary. If it is changed later on, then the cookie will live on in\n  // the users' browsers as garbage (although it'd expire eventually).\n  \"FIREBASE_AUTH_SESSION_COOKIE_NAME\": \"session\",\n\n  \"ALLOW_YAML_FILE_UPLOAD\": false,\n\n  // A regular expression for tags.\n  \"TAG_REGEX\": \"^[a-z ]+$\",\n\n  // A regular expression for allowed character in tags for blog post.\n  \"BLOG_POST_TAG_REGEX\": \"^[a-zA-Z0-9 ]+$\",\n\n  // A regular expression for allowed characters in URL fragment fields.\n  \"VALID_URL_FRAGMENT_REGEX\": \"^[a-z]+(-[a-z]+)*$\",\n\n  // A regular expression for allowed characters for thumbnail filename.\n  \"VALID_THUMBNAIL_FILENAME_REGEX\": \"^[^.](?!.*/)(?!.*\\\\.\\\\.).*.svg$\",\n\n  // A regular expression for allowed entity id's.\n  \"ENTITY_ID_REGEX\": \"^[a-zA-Z0-9-_]{1,12}$\",\n\n  // A regular expression for allowed learner group IDs.\n  \"LEARNER_GROUP_ID_REGEX\": \"^[a-zA-Z]{1,12}$\",\n\n  // A regular expression for allowed characters in Title field for Blog Post.\n  // eslint-disable-next-line max-len\n  \"VALID_BLOG_POST_TITLE_REGEX\": \"^[a-zA-Z0-9][a-zA-Z0-9 ]+([-:][ a-zA-Z0-9]+)*$\",\n\n  // A regular expression for allowed characters in URL fragment for Blog Post.\n  \"VALID_URL_BLOG_FRAGMENT_REGEX\": \"^[a-z0-9]+(-[a-z0-9]+)*$\",\n\n  // A regular expression for allowed characters in URL fragment for Blog Post.\n  // eslint-disable-next-line max-len\n  \"VALID_THREAD_ID_REGEX\": \"(exploration|collection|skill).[a-zA-Z0-9]+.[a-zA-Z0-9=]+\",\n\n  // A regular expression for valid skill misconception id.\n  \"VALID_SKILL_MISCONCEPTION_ID_REGEX\": \"[A-Za-z0-9]{12}-[0-9]+\",\n\n  // A regular expression for allowed characters in author name field for Author\n  // details Model.\n  \"VALID_AUTHOR_NAME_REGEX\": \"^[a-zA-Z0-9][a-zA-Z0-9 ]+(-[a-zA-Z0-9]+)*$\",\n  // Invalid names for parameters used in expressions.\n  \"INVALID_PARAMETER_NAMES\": [\n    \"answer\", \"choices\", \"abs\", \"all\", \"and\", \"any\", \"else\",\n    \"floor\", \"if\", \"log\", \"or\", \"pow\", \"round\", \"then\"\n  ],\n\n  // Greek letters allowed in math interactions.\n  \"GREEK_LETTER_NAMES_TO_SYMBOLS\": {\n    \"alpha\": \"\",\n    \"beta\": \"\",\n    \"gamma\": \"\",\n    \"delta\": \"\",\n    \"epsilon\": \"\",\n    \"zeta\": \"\",\n    \"eta\": \"\",\n    \"theta\": \"\",\n    \"iota\": \"\",\n    \"kappa\": \"\",\n    \"lambda\": \"\",\n    \"mu\": \"\",\n    \"nu\": \"\",\n    \"xi\": \"\",\n    \"pi\": \"\",\n    \"rho\": \"\",\n    \"sigma\": \"\",\n    \"tau\": \"\",\n    \"upsilon\": \"\",\n    \"phi\": \"\",\n    \"chi\": \"\",\n    \"psi\": \"\",\n    \"omega\": \"\",\n    \"Gamma\": \"\",\n    \"Delta\": \"\",\n    \"Theta\": \"\",\n    \"Lambda\": \"\",\n    \"Xi\": \"\",\n    \"Pi\": \"\",\n    \"Sigma\": \"\",\n    \"Phi\": \"\",\n    \"Psi\": \"\",\n    \"Omega\": \"\"\n  },\n\n  // The greek letters in the list should be in sync with the\n  // GREEK_LETTER_NAMES_TO_SYMBOLS object's keys.\n  \"VALID_ALGEBRAIC_IDENTIFIERS\": [\n    \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\",\n    \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\",\n    \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\",\n    \"iota\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"xi\", \"pi\", \"rho\", \"sigma\", \"tau\",\n    \"upsilon\", \"phi\", \"chi\", \"psi\", \"omega\", \"Gamma\", \"Delta\", \"Theta\",\n    \"Lambda\", \"Xi\", \"Pi\", \"Sigma\", \"Phi\", \"Psi\", \"Omega\"],\n\n  // Valid allowed letters for math lessons.\n  \"VALID_ALLOWED_VARIABLES\": [\n    \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\",\n    \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\",\n    \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\"],\n\n  // Number of custom letters allowed in the on-screen keyboard for math\n  // interactions.\n  \"MAX_CUSTOM_LETTERS_FOR_OSK\": 10,\n\n  // Functions allowed in math interactions.\n  \"MATH_FUNCTION_NAMES\": [\n    \"log\", \"ln\", \"sqrt\", \"abs\", \"sin\", \"cos\", \"tan\", \"sec\", \"csc\", \"cot\",\n    \"arcsin\", \"arccos\", \"arctan\", \"sinh\", \"cosh\", \"tanh\"\n  ],\n\n  // Supported functions for math interactions.\n  \"SUPPORTED_FUNCTION_NAMES\": [\"sqrt\", \"abs\"],\n\n  \"OSK_MAIN_TAB\": \"mainTab\",\n  \"OSK_FUNCTIONS_TAB\": \"functionsTab\",\n  \"OSK_LETTERS_TAB\": \"lettersTab\",\n\n  \"CUSTOM_LETTERS_LATIN_TAB\": \"latinTab\",\n  \"CUSTOM_LETTERS_GREEK_TAB\": \"greekTab\",\n\n  // Name to human readable form mapping of the position of terms object.\n  \"POSITION_OF_TERMS_MAPPING\": [{\n    \"name\": \"lhs\",\n    \"humanReadableName\": \"on Left Hand Side\"\n  }, {\n    \"name\": \"rhs\",\n    \"humanReadableName\": \"on Right Hand Side\"\n  }, {\n    \"name\": \"both\",\n    \"humanReadableName\": \"on both sides\"\n  }, {\n    \"name\": \"irrelevant\",\n    \"humanReadableName\": \"with reordering allowed around =\"\n  }],\n\n  // Placeholder texts for the math interactions.\n  \"MATH_INTERACTION_PLACEHOLDERS\": {\n    \"AlgebraicExpressionInput\": \"I18N_INTERACTIONS_ALGEBRAIC_EXPR_INSTRUCTION\",\n    \"MathEquationInput\": \"I18N_INTERACTIONS_MATH_EQ_INSTRUCTION\",\n    // The following is user editable and hence, is not translated.\n    \"NumericExpressionInput\": \"Type an expression here, using only numbers.\"\n  },\n\n  // Unfinished features.\n  \"SHOW_TRAINABLE_UNRESOLVED_ANSWERS\": false,\n\n  // eslint-disable-next-line max-len\n  \"DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR\": \"Check out this interactive lesson on Oppia - a free platform for teaching and learning!\",\n\n  // eslint-disable-next-line max-len\n  \"DEFUALT_BLOG_POST_SHARE_TWITTER_TEXT\": \"Check out this new blog post on Oppia!\",\n\n  \"OPPORTUNITY_TYPE_SKILL\": \"skill\",\n  \"OPPORTUNITY_TYPE_TRANSLATION\": \"translation\",\n\n  // The bucket name is set to app_default_bucket which is used to store files\n  // in GCS when local development server is running. This should be changed\n  // in prod appropriately.\n  \"GCS_RESOURCE_BUCKET_NAME\": \"app_default_bucket\",\n\n  \"ENABLE_EXP_FEEDBACK_FOR_LOGGED_OUT_USERS\": true,\n\n  // Link to open when the Oppia avatar is clicked on any page.\n  \"OPPIA_AVATAR_LINK_URL\": null,\n\n  // Maximum allowed length of a username.\n  \"MAX_USERNAME_LENGTH\": 30,\n\n  // Maximum allowed length of a blog post author's name.\n  \"MAX_AUTHOR_NAME_LENGTH\": 35,\n\n  // Maximum allowed characters in a blog post author's bio.\n  \"MAX_CHARS_IN_AUTHOR_BIO\": 250,\n\n  // Maximum allowed length of a state name.\n  \"MAX_STATE_NAME_LENGTH\": 50,\n\n  // Maximum allowed length of unique progress url ID.\n  \"MAX_PROGRESS_URL_ID_LENGTH\": 6,\n\n  \"PLATFORM_PARAMETER_ALLOWED_BROWSER_TYPES\": [\n    \"Chrome\", \"Edge\", \"Safari\", \"Firefox\", \"Others\"],\n  \"PLATFORM_PARAMETER_ALLOWED_PLATFORM_TYPES\": [\"Web\", \"Android\", \"Backend\"],\n  // The ordering of in ALLOWED_APP_VERSION_FLAVORS implies the ordering\n  // of corresponding flavors, which is used in app_version_flavor filter for\n  // order comparison, with ordering: 'test' < 'alpha' < 'beta' < 'release'.\n  \"PLATFORM_PARAMETER_ALLOWED_APP_VERSION_FLAVORS\": [\n    \"test\", \"alpha\", \"beta\", \"release\"],\n  \"PLATFORM_PARAMETER_APP_VERSION_WITHOUT_HASH_REGEXP\":\n    \"^(\\\\d+(?:\\\\.\\\\d+){2})$\",\n  \"PLATFORM_PARAMETER_APP_VERSION_WITH_HASH_REGEXP\":\n    \"^(\\\\d+(?:\\\\.\\\\d+){2})(?:-[a-z0-9]+(?:-(.+))?)?$\",\n\n  // Maximum allowed commit message length. 375 characters because indexed\n  // fields must be at most 1500 bytes, and UTF-8 encoded characters can be\n  // up to 4 bytes long.\n  \"MAX_COMMIT_MESSAGE_LENGTH\": 375,\n  \"MAX_REVIEW_MESSAGE_LENGTH\": 10000,\n\n  \"EMAIL_DASHBOARD_PREDICATE_DEFINITION\": [\n    {\n      \"backend_id\": \"user_inactivity\",\n      \"backend_attr\": \"inactive_in_last_n_days\",\n      \"description\": \"Inactive in last n days\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"user_login_activity\",\n      \"backend_attr\": \"has_not_logged_in_for_n_days\",\n      \"description\": \"Has not logged in for n days\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"minimum_exp_created\",\n      \"backend_attr\": \"created_at_least_n_exps\",\n      \"description\": \"Has created at least n explorations\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"maximum_exp_created\",\n      \"backend_attr\": \"created_fewer_than_n_exps\",\n      \"description\": \"Has created fewer than n explorations\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"minimum_exp_edited\",\n      \"backend_attr\": \"edited_at_least_n_exps\",\n      \"description\": \"Has edited at least n explorations\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"maximum_exp_edited\",\n      \"backend_attr\": \"edited_fewer_than_n_exps\",\n      \"description\": \"Has edited fewer than n explorations\",\n      \"schema\": {\n        \"type\": \"int\",\n        \"validators\": [{\n          \"id\": \"is_at_least\",\n          \"min_value\": 0\n        }]\n      },\n      \"default_value\": null\n    },\n    {\n      \"backend_id\": \"created_collection\",\n      \"backend_attr\": \"created_collection\",\n      \"description\": \"Has created collection\",\n      \"schema\": {\n        \"type\": \"bool\",\n        \"validators\": [{\n          \"id\": \"is_nonempty\"\n        }]\n      },\n      \"default_value\": false\n    }\n  ],\n\n  // When the site cookie policy was last updated in UNIX time milliseconds.\n  \"COOKIE_POLICY_LAST_UPDATED_MSECS\": 1624909164000,\n\n  // Pages registered with angular router.\n  \"PAGES_REGISTERED_WITH_FRONTEND\": {\n    \"ABOUT\": {\n      \"ROUTE\": \"about\",\n      \"TITLE\": \"I18N_ABOUT_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        }\n      ]\n    },\n    \"ABOUT_FOUNDATION\": {\n      \"ROUTE\": \"about-foundation\",\n      \"TITLE\": \"About the Oppia Foundation | Oppia\",\n      \"META\": []\n    },\n    \"EXPLORATION_PLAYER\": {\n      \"ROUTE\": \"explore/:exploration_id\",\n      \"TITLE\": \"\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": []\n    },\n    \"EXPLORATION_PLAYER_EMBED\": {\n      \"ROUTE\": \"embed/exploration/:exploration_id\",\n      \"TITLE\": \"\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": []\n    },\n    \"ANDROID\": {\n      \"ROUTE\": \"android\",\n      \"TITLE\": \"Android | Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        }\n      ]\n    },\n    \"CONTACT\": {\n      \"ROUTE\": \"contact\",\n      \"TITLE\": \"I18N_CONTACT_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Contact the Oppia team, submit feedback, and learn how to get involved with the Oppia project.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Contact the Oppia team, submit feedback, and learn how to get involved with the Oppia project.\"\n        }\n      ]\n    },\n    \"DONATE\": {\n      \"ROUTE\": \"donate\",\n      \"TITLE\": \"Donate | Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Donate to The Oppia Foundation to enable more students to receive the quality education they deserve.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Donate to The Oppia Foundation to enable more students to receive the quality education they deserve.\"\n        }\n      ]\n    },\n    \"GET_STARTED\": {\n      \"ROUTE\": \"get-started\",\n      \"TITLE\": \"I18N_GET_STARTED_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          \"CONTENT\": \"Learn how to get started using Oppia.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          \"CONTENT\": \"Learn how to get started using Oppia.\"\n        }\n      ]\n    },\n    \"LICENSE\": {\n      \"ROUTE\": \"license\",\n      \"TITLE\": \"I18N_LICENSE_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          \"CONTENT\": \"License terms that Oppia is attributed under.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          \"CONTENT\": \"License terms that Oppia is attributed under.\"\n        }\n      ]\n    },\n    \"LOGIN\": {\n      \"ROUTE\": \"login\",\n      \"TITLE\": \"I18N_LOGIN_PAGE_TITLE\",\n      \"META\": []\n    },\n    \"LOGOUT\": {\n      \"ROUTE\": \"logout\",\n      \"TITLE\": \"I18N_LOGOUT_PAGE_BROWSER_TAB_TITLE\",\n      \"META\": []\n    },\n    \"PARTNERSHIPS\": {\n      \"ROUTE\": \"partnerships\",\n      \"TITLE\": \"Partnerships | Oppia\",\n      \"META\": []\n    },\n    \"PLAYBOOK\": {\n      \"ROUTE\": \"creator-guidelines\",\n      \"TITLE\": \"I18N_PLAYBOOK_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"The Oppia library is full of user-created lessons called 'explorations'. Read about how to participate in the community and begin creating explorations.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"The Oppia library is full of user-created lessons called 'explorations'. Read about how to participate in the community and begin creating explorations.\"\n        }\n      ]\n    },\n    \"PRIVACY\": {\n      \"ROUTE\": \"privacy-policy\",\n      \"TITLE\": \"I18N_PRIVACY_POLICY_PAGE_TITLE\",\n      \"META\": []\n    },\n    \"SIGNUP\": {\n      \"ROUTE\": \"signup\",\n      \"TITLE\": \"I18N_SIGNUP_PAGE_TITLE\",\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          \"CONTENT\": \"Sign up for Oppia and begin exploring a new subject.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          \"CONTENT\": \"Sign up for Oppia and begin exploring a new subject.\"\n        }\n      ]\n    },\n    \"TEACH\": {\n      \"ROUTE\": \"teach\",\n      \"TITLE\": \"I18N_TEACH_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"The Oppia library is full of user-created lessons called 'explorations'. Read about how to participate in the community and begin creating explorations.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"The Oppia library is full of user-created lessons called 'explorations'. Read about how to participate in the community and begin creating explorations.\"\n        }\n      ]\n    },\n    \"TERMS\": {\n      \"ROUTE\": \"terms\",\n      \"TITLE\": \"I18N_TERMS_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Oppia is a 501(c)(3) registered non-profit open-source e-learning platform. Learn about our terms and conditions for creating and distributing learning material.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Oppia is a 501(c)(3) registered non-profit open-source e-learning platform. Learn about our terms and conditions for creating and distributing learning material.\"\n        }\n      ]\n    },\n    \"THANKS\": {\n      \"ROUTE\": \"thanks\",\n      \"TITLE\": \"I18N_THANKS_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          \"CONTENT\": \"Thank you for donating to The Oppia Foundation!\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"property\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          \"CONTENT\": \"Thank you for donating to The Oppia Foundation!\"\n        }\n      ]\n    },\n    \"DELETE_ACCOUNT\": {\n      \"ROUTE\": \"delete-account\",\n      \"TITLE\": \"I18N_DELETE_ACCOUNT_PAGE_TITLE\",\n      \"META\": []\n    },\n    \"LIBRARY_INDEX\": {\n      \"ROUTE\": \"community-library\",\n      \"TITLE\": \"Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        }\n      ]\n    },\n    \"LIBRARY_RECENTLY_PUBLISHED\": {\n      \"ROUTE\": \"community-library/recently-published\",\n      \"TITLE\": \"Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        }\n      ]\n    },\n    \"LIBRARY_SEARCH\": {\n      \"ROUTE\": \"search/find\",\n      \"TITLE\": \"Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        }\n      ]\n    },\n    \"LIBRARY_TOP_RATED\": {\n      \"ROUTE\": \"community-library/top-rated\",\n      \"TITLE\": \"Oppia\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Looking to learn something new? Learn any subject of your choice created by professors, teachers and Oppia users! Free lessons are always available for any topic and level you want.\"\n        }\n      ]\n    },\n    \"PENDING_ACCOUNT_DELETION\": {\n      \"ROUTE\": \"pending-account-deletion\",\n      \"TITLE\": \"I18N_PENDING_ACCOUNT_DELETION_PAGE_TITLE\",\n      \"META\": []\n    },\n    \"PREFERENCES\": {\n      \"ROUTE\": \"preferences\",\n      \"TITLE\": \"I18N_PREFERENCES_PAGE_BROWSER_TAB_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          \"CONTENT\": \"Change your Oppia profile settings and preferences\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          \"CONTENT\": \"Change your Oppia profile settings and preferences\"\n        }\n      ]\n    },\n    \"PROFILE\": {\n      \"ROUTE\": \"profile/:username_fragment\",\n      \"TITLE\": \"I18N_PROFILE_PAGE_TITLE\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": []\n    },\n    \"RELEASE_COORDINATOR_PAGE\": {\n      \"ROUTE\": \"release-coordinator\",\n      \"TITLE\": \"I18N_RELEASE_COORDINATOR_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        }\n      ]\n    },\n    \"STORY_VIEWER\": {\n      // eslint-disable-next-line max-len\n      \"ROUTE\": \"learn/:classroom_url_fragment/:topic_url_fragment/story/:story_url_fragment\",\n      \"TITLE\": \"Oppia\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": []\n    },\n    \"VOLUNTEER\": {\n      \"ROUTE\": \"volunteer\",\n      \"TITLE\": \"Volunteer | Oppia\",\n      \"META\": []\n    },\n    \"CLASSROOM\": {\n      \"ROUTE\": \"learn/:classroom_url_fragment\",\n      \"TITLE\": \"Oppia\",\n      \"LIGHTWEIGHT\": true,\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it\"\n        }\n      ]\n    },\n    \"BLOG_HOMEPAGE\": {\n      \"ROUTE\": \"blog\",\n      \"TITLE\": \"I18N_BLOG_HOME_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        }\n      ]\n    },\n    \"BLOG_HOMEPAGE_SEARCH\": {\n      \"ROUTE\": \"blog/search/find\",\n      \"TITLE\": \"I18N_BLOG_HOME_PAGE_TITLE\",\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        }\n      ]\n    },\n    \"BLOG_AUTHOR_PROFILE_PAGE\": {\n      \"ROUTE\": \"blog/author/:author_username\",\n      \"TITLE\": \"I18N_BLOG_AUTHOR_PROFILE_PAGE_TITLE\",\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        }\n      ]\n    },\n    \"BLOG_POST_PAGE\": {\n      \"ROUTE\": \"blog/:blog_post_url_fragment\",\n      \"TITLE\": \"I18N_BLOG_POST_PAGE_TITLE\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"Read the latest on what's new and exciting with Oppia.\"\n        }\n      ]\n    },\n    \"LEARNER_GROUP_VIEWER\": {\n      \"ROUTE\": \"learner-group/:learner_group_id\",\n      \"TITLE\": \"I18N_LEARNER_GROUP_PAGE_TITLE\",\n      // Some routes contain url fragments, as syntax for url fragments are\n      // different for angular router and backend. They have to be registered\n      // manually in the backend. Please use angular router syntax here.\n      \"MANUALLY_REGISTERED_WITH_BACKEND\": true,\n      \"META\": []\n    },\n    \"SPLASH\": {\n      \"ROUTE\": \"\",\n      \"TITLE\": \"Oppia | Free, Online and Interactive Lessons for Anyone\",\n      \"LIGHTWEIGHT\": true,\n      \"META\": [\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        },\n        {\n          \"PROPERTY_TYPE\": \"itemprop\",\n          \"PROPERTY_VALUE\": \"og:description\",\n          // eslint-disable-next-line max-len\n          \"CONTENT\": \"With Oppia, you can access free lessons on math, physics, statistics, chemistry, music, history and more from anywhere in the world. Oppia is a nonprofit with the mission of providing high-quality education to those who lack access to it.\"\n        }\n      ]\n    }\n  },\n\n  \"STEWARDS_LANDING_PAGE\": {\n    \"ROUTES\": [\"parents\", \"partners\", \"nonprofits\", \"teachers\", \"volunteers\"],\n    \"TITLE\": \"Getting Started with Oppia\",\n    \"META\": []\n  },\n\n  // A dict representing available landing pages, having subject as a key\n  // and list of topics as the value.\n  // Note: This dict needs to be keep in sync with frontend\n  // TOPIC_LANDING_PAGE_DATA oppia constant defined in\n  // core/templates/pages/landing-pages/topic-landing-page/\n  // topic-landing-page.constants.ts file.\n  \"AVAILABLE_LANDING_PAGES\": {\n    \"math\": [\"fractions\", \"negative-numbers\", \"ratios\"]\n  },\n\n  \"SCHEMA_FOR_TOPIC_URL_FRAGMENTS\": {\n    \"schema\": {\n      \"type\": \"basestring\",\n      \"validators\": [{\n        \"id\": \"is_regex_matched\",\n        \"regex_pattern\": \"^[a-z]+(-[a-z]+)*$\"\n      }, {\n        \"id\": \"has_length_at_most\",\n        \"max_value\": 20\n      }]\n    }\n  },\n\n  \"SCHEMA_FOR_CLASSROOM_URL_FRAGMENTS\": {\n    \"schema\": {\n      \"type\": \"basestring\",\n      \"validators\": [{\n        \"id\": \"is_regex_matched\",\n        \"regex_pattern\": \"^[a-z]+(-[a-z]+)*$\"\n      }, {\n        \"id\": \"has_length_at_most\",\n        \"max_value\": 20\n      }]\n    }\n  },\n\n  \"SCHEMA_FOR_STORY_URL_FRAGMENTS\": {\n    \"schema\": {\n      \"type\": \"basestring\",\n      \"validators\": [{\n        \"id\": \"is_regex_matched\",\n        \"regex_pattern\": \"^[a-z]+(-[a-z]+)*$\"\n      }, {\n        \"id\": \"has_length_at_most\",\n        \"max_value\": 30\n      }]\n    }\n  },\n\n  \"DEV_MODE\": true,\n  \"EMULATOR_MODE\": true,\n  \"ASSET_TYPE_AUDIO\": \"audio\",\n  \"ASSET_TYPE_IMAGE\": \"image\",\n  \"ASSET_TYPE_THUMBNAIL\": \"thumbnail\",\n\n  \"FAVICON_ALERT_PATH\": \"/assets/images/favicon_alert/favicon_alert.ico\",\n\n  \"METADATA_PROPERTIES\": [\n    \"title\", \"category\", \"objective\", \"language_code\", \"tags\", \"blurb\",\n    \"author_notes\", \"states_schema_version\", \"init_state_name\", \"param_specs\",\n    \"param_changes\", \"auto_tts_enabled\", \"correctness_feedback_enabled\",\n    \"edits_allowed\"\n  ],\n  \"NON_METADATA_PROPERTIES\": [\"id\", \"states\"],\n  \"CONTRIBUTOR_CERTIFICATE_WIDTH\": 1493,\n  \"CONTRIBUTOR_CERTIFICATE_HEIGHT\": 1313\n} as const;\n"
    },
    {
      "filename": "core/controllers/contributor_dashboard.py",
      "content": "# Copyright 2019 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Controllers for the contributor dashboard page.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport json\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.domain import config_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import opportunity_domain\nfrom core.domain import opportunity_services\nfrom core.domain import state_domain\nfrom core.domain import story_fetchers\nfrom core.domain import suggestion_registry\nfrom core.domain import suggestion_services\nfrom core.domain import topic_fetchers\nfrom core.domain import translation_services\nfrom core.domain import user_services\n\nfrom typing import Dict, List, Optional, Sequence, Tuple, TypedDict, Union\n\n\nListOfContributorDashboardStatsTypes = Sequence[Union[\n    suggestion_registry.TranslationContributionStats,\n    suggestion_registry.TranslationReviewStats,\n    suggestion_registry.QuestionContributionStats,\n    suggestion_registry.QuestionReviewStats\n]]\n\n\nListOfContributorDashboardStatsDictTypes = Sequence[Union[\n    suggestion_registry.TranslationContributionStatsFrontendDict,\n    suggestion_registry.TranslationReviewStatsFrontendDict,\n    suggestion_registry.QuestionContributionStatsFrontendDict,\n    suggestion_registry.QuestionReviewStatsFrontendDict\n]]\n\n\nclass ClientSideSkillOpportunityDict(opportunity_domain.SkillOpportunityDict):\n    \"\"\"A dictionary representation of client side SkillOpportunity object.\"\"\"\n\n    topic_name: str\n\n\nclass ContributorDashboardPage(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Page showing the contributor dashboard.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        # TODO(#7402): Serve this page statically through app.yaml once\n        # the CONTRIBUTOR_DASHBOARD_ENABLED flag is removed.\n        if not config_domain.CONTRIBUTOR_DASHBOARD_IS_ENABLED.value:\n            raise self.PageNotFoundException\n        self.render_template('contributor-dashboard-page.mainpage.html')\n\n\nclass ContributionOpportunitiesHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of ContributionOpportunitiesHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    cursor: Optional[str]\n    language_code: Optional[str]\n    topic_name: Optional[str]\n\n\nclass ContributionOpportunitiesHandler(\n    base.BaseHandler[\n        Dict[str, str], ContributionOpportunitiesHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Provides data for opportunities available in different categories.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS = {\n        'opportunity_type': {\n            'schema': {\n                'type': 'basestring'\n            }\n        }\n    }\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'cursor': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'language_code': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_supported_audio_language_code'\n                    }]\n                },\n                'default_value': None\n            },\n            'topic_name': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def get(self, opportunity_type: str) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        assert self.normalized_request is not None\n        if not config_domain.CONTRIBUTOR_DASHBOARD_IS_ENABLED.value:\n            raise self.PageNotFoundException\n        search_cursor = self.normalized_request.get('cursor')\n        language_code = self.normalized_request.get('language_code')\n\n        if opportunity_type == constants.OPPORTUNITY_TYPE_SKILL:\n            skill_opportunities, next_cursor, more = (\n                self._get_skill_opportunities_with_corresponding_topic_name(\n                    search_cursor))\n\n        elif opportunity_type == constants.OPPORTUNITY_TYPE_TRANSLATION:\n            topic_name = self.normalized_request.get('topic_name')\n            if language_code is None:\n                raise self.InvalidInputException\n            translation_opportunities, next_cursor, more = (\n                self._get_translation_opportunity_dicts(\n                    language_code, topic_name, search_cursor))\n        else:\n            raise self.PageNotFoundException\n\n        self.values = {\n            'opportunities': (\n                skill_opportunities\n                if opportunity_type == constants.OPPORTUNITY_TYPE_SKILL\n                else translation_opportunities\n            ),\n            'next_cursor': next_cursor,\n            'more': more\n        }\n        self.render_json(self.values)\n\n    def _get_skill_opportunities_with_corresponding_topic_name(\n        self, cursor: Optional[str]\n    ) -> Tuple[\n        List[ClientSideSkillOpportunityDict], Optional[str], bool\n    ]:\n        \"\"\"Returns a list of skill opportunities available for questions with\n        a corresponding topic name.\n\n        Args:\n            cursor: str or None. If provided, the list of returned entities\n                starts from this datastore cursor. Otherwise, the returned\n                entities start from the beginning of the full list of entities.\n\n        Returns:\n            3-tuple(opportunities, cursor, more). where:\n                opportunities: list(dict). A list of dicts of skill opportunity\n                    details with additional corresponding topic_name.\n                cursor: str or None. A query cursor pointing to the next\n                    batch of results. If there are no more results, this might\n                    be None.\n                more: bool. If True, there are (probably) more results after\n                    this batch. If False, there are no further results after\n                    this batch.\n        \"\"\"\n        # We want to focus attention on lessons that are part of a classroom.\n        # See issue #12221.\n        classroom_topic_ids = []\n        for classroom_dict in config_domain.CLASSROOM_PAGES_DATA.value:\n            classroom_topic_ids.extend(classroom_dict['topic_ids'])\n        classroom_topics = topic_fetchers.get_topics_by_ids(classroom_topic_ids)\n        # Associate each skill with one classroom topic name.\n        # TODO(#8912): Associate each skill/skill opportunity with all linked\n        # topics.\n        classroom_topic_skill_id_to_topic_name = {}\n        for topic in classroom_topics:\n            if topic is None:\n                continue\n            for skill_id in topic.get_all_skill_ids():\n                classroom_topic_skill_id_to_topic_name[skill_id] = topic.name\n\n        skill_opportunities, cursor, more = (\n            opportunity_services.get_skill_opportunities(cursor))\n        opportunities: List[ClientSideSkillOpportunityDict] = []\n        # Fetch opportunities until we have at least a page's worth that\n        # correspond to a classroom or there are no more opportunities.\n        while len(opportunities) < constants.OPPORTUNITIES_PAGE_SIZE:\n            for skill_opportunity in skill_opportunities:\n                if (\n                        skill_opportunity.id\n                        in classroom_topic_skill_id_to_topic_name):\n                    skill_opportunity_dict = skill_opportunity.to_dict()\n                    client_side_skill_opportunity_dict: (\n                        ClientSideSkillOpportunityDict\n                    ) = {\n                        'id': skill_opportunity_dict['id'],\n                        'skill_description': skill_opportunity_dict[\n                            'skill_description'\n                        ],\n                        'question_count': skill_opportunity_dict[\n                            'question_count'\n                        ],\n                        'topic_name': (\n                            classroom_topic_skill_id_to_topic_name[\n                                skill_opportunity.id]\n                            )\n                    }\n                    opportunities.append(client_side_skill_opportunity_dict)\n            if (\n                    not more or\n                    len(opportunities) >= constants.OPPORTUNITIES_PAGE_SIZE):\n                break\n            skill_opportunities, cursor, more = (\n                opportunity_services.get_skill_opportunities(cursor))\n\n        return opportunities, cursor, more\n\n    def _get_translation_opportunity_dicts(\n        self,\n        language_code: str,\n        topic_name: Optional[str],\n        search_cursor: Optional[str]\n    ) -> Tuple[\n        List[opportunity_domain.PartialExplorationOpportunitySummaryDict],\n        Optional[str],\n        bool\n    ]:\n        \"\"\"Returns a list of translation opportunity dicts.\n\n        Args:\n            language_code: str. The language for which translation opportunities\n                should be fetched.\n            topic_name: str or None. The topic for which translation\n                opportunities should be fetched. If topic_name is None or empty,\n                fetch translation opportunities from all topics.\n            search_cursor: str or None. If provided, the list of returned\n                entities starts from this datastore cursor. Otherwise, the\n                returned entities start from the beginning of the full list of\n                entities.\n\n        Returns:\n            3-tuple(opportunities, cursor, more). where:\n            opportunities: list(dict). A list of ExplorationOpportunitySummary\n                dicts.\n            cursor: str or None. A query cursor pointing to the next batch of\n                results. If there are no more results, this might be None.\n            more: bool. If True, there are (probably) more results after this\n                batch. If False, there are no further results after this batch.\n        \"\"\"\n        opportunities, next_cursor, more = (\n            opportunity_services.get_translation_opportunities(\n                language_code, topic_name, search_cursor))\n        opportunity_dicts = [opp.to_dict() for opp in opportunities]\n        return opportunity_dicts, next_cursor, more\n\n\nclass ReviewableOpportunitiesHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of ReviewableOpportunitiesHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    topic_name: Optional[str]\n    language_code: str\n\n\nclass ReviewableOpportunitiesHandler(\n    base.BaseHandler[\n        Dict[str, str], ReviewableOpportunitiesHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Provides opportunities that have translation suggestions in review.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'topic_name': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            },\n            'language_code': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        assert self.normalized_request is not None\n        topic_name = self.normalized_request.get('topic_name')\n        language = self.normalized_request.get('language_code')\n        opportunity_dicts: List[\n            opportunity_domain.PartialExplorationOpportunitySummaryDict\n        ] = []\n        if self.user_id:\n            for opp in self._get_reviewable_exploration_opportunity_summaries(\n                self.user_id, topic_name, language\n            ):\n                if opp is not None:\n                    opportunity_dicts.append(opp.to_dict())\n        self.values = {\n            'opportunities': opportunity_dicts,\n        }\n        self.render_json(self.values)\n\n    def _get_reviewable_exploration_opportunity_summaries(\n        self, user_id: str, topic_name: Optional[str], language: Optional[str]\n    ) -> List[Optional[opportunity_domain.ExplorationOpportunitySummary]]:\n        \"\"\"Returns exploration opportunity summaries that have translation\n        suggestions that are reviewable by the supplied user. The result is\n        sorted in descending order by topic, story, and story node order.\n\n        Args:\n            user_id: str. The user ID of the user for which to filter\n                translation suggestions.\n            topic_name: str or None. A topic name for which to filter the\n                exploration opportunity summaries. If 'All' is supplied, all\n                available exploration opportunity summaries will be returned.\n            language: str. ISO 639-1 language code for which to filter the\n                exploration opportunity summaries. If it is None, all\n                available exploration opportunity summaries will be returned.\n\n        Returns:\n            list(ExplorationOpportunitySummary). A list of the matching\n            exploration opportunity summaries.\n\n        Raises:\n            Exception. No exploration_id found for the node_id.\n        \"\"\"\n        # 1. Fetch the eligible topics.\n        # 2. Fetch the stories for the topics.\n        # 3. Get the reviewable translation suggestion target IDs for the user.\n        # 4. Get story exploration nodes in order, filtering for explorations\n        # that have in review translation suggestions.\n        if topic_name is None:\n            topics = topic_fetchers.get_all_topics()\n        else:\n            topic = topic_fetchers.get_topic_by_name(topic_name)\n            if topic is None:\n                raise self.InvalidInputException(\n                    'The supplied input topic: %s is not valid' % topic_name)\n            topics = [topic]\n        topic_stories = story_fetchers.get_stories_by_ids(\n            [\n                reference.story_id\n                for topic in topics\n                for reference in topic.get_all_story_references()\n                if reference.story_is_published\n            ],\n            strict=True\n        )\n        topic_exp_ids = []\n        for story in topic_stories:\n            for node in story.story_contents.get_ordered_nodes():\n                if node.exploration_id is None:\n                    raise Exception(\n                        'No exploration_id found for the node_id: %s'\n                        % node.id\n                    )\n                topic_exp_ids.append(node.exploration_id)\n        in_review_suggestions, _ = (\n            suggestion_services\n            .get_reviewable_translation_suggestions_by_offset(\n                user_id, topic_exp_ids, None, 0, None, language))\n        # Filter out suggestions that should not be shown to the user.\n        # This is defined as a set as we only care about the unique IDs.\n        in_review_suggestion_target_ids = {\n            suggestion.target_id\n            for suggestion in\n            suggestion_services.get_suggestions_with_translatable_explorations(\n                in_review_suggestions)\n        }\n        exp_ids = [\n            exp_id\n            for exp_id in topic_exp_ids\n            if exp_id in in_review_suggestion_target_ids\n        ]\n        return list(\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                exp_ids).values())\n\n\nclass TranslatableTextHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of TranslatableTextHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    language_code: str\n    exp_id: str\n\n\nclass TranslatableTextHandler(\n    base.BaseHandler[\n        Dict[str, str], TranslatableTextHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Provides lessons content which can be translated in a given language.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'language_code': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_supported_audio_language_code'\n                    }]\n                }\n            },\n            'exp_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        assert self.normalized_request is not None\n        language_code = self.normalized_request['language_code']\n        exp_id = self.normalized_request['exp_id']\n\n        if not opportunity_services.is_exploration_available_for_contribution(\n                exp_id):\n            raise self.InvalidInputException('Invalid exp_id: %s' % exp_id)\n\n        exp = exp_fetchers.get_exploration_by_id(exp_id)\n        state_names_to_content_id_mapping = exp.get_translatable_text(\n            language_code)\n        reviewable_language_codes = []\n        if self.user_id:\n            contribution_rights = user_services.get_user_contribution_rights(\n                self.user_id)\n            reviewable_language_codes = (\n                contribution_rights.can_review_translation_for_language_codes)\n        if language_code not in reviewable_language_codes:\n            state_names_to_content_id_mapping = (\n                self._get_state_names_to_not_set_content_id_mapping(\n                    state_names_to_content_id_mapping\n                ))\n        state_names_to_not_in_review_content_id_mapping = (\n            self._get_state_names_to_not_in_review_content_id_mapping(\n                state_names_to_content_id_mapping,\n                suggestion_services\n                .get_translation_suggestions_in_review_by_exploration(\n                    exp_id, language_code)\n            )\n        )\n        self.values = {\n            'state_names_to_content_id_mapping': (\n                state_names_to_not_in_review_content_id_mapping),\n            'version': exp.version\n        }\n\n        self.render_json(self.values)\n\n    def _get_state_names_to_not_set_content_id_mapping(\n        self,\n        state_names_to_content_id_mapping: Dict[\n            str, Dict[str, state_domain.TranslatableItem]\n        ]\n    ) -> Dict[str, Dict[str, state_domain.TranslatableItem]]:\n        \"\"\"Returns a copy of the supplied state_names_to_content_id_mapping\n        minus any contents of which the data is set of strings.\n\n        Args:\n            state_names_to_content_id_mapping:\n                dict(str, dict(str, TranslatableItem)). A dict whose keys are\n                state names, and whose corresponding values are each dicts\n                mapping content IDs to the corresponding translatable items.\n\n        Returns:\n            dict(str, dict(str, TranslatableItem)). A dict where state_name\n            is the key and a dict with content_id as the key and\n            TranslatableItem as value.\n        \"\"\"\n        mapping_without_set_data_format = {}\n        for state_name in state_names_to_content_id_mapping:\n            content_id_to_translatable_item = (\n                state_names_to_content_id_mapping[state_name])\n            content_id_to_not_set_translatable_item = {}\n            for content_id, translatable_item in (\n                    content_id_to_translatable_item.items()):\n                if not translatable_item.is_set_data_format():\n                    content_id_to_not_set_translatable_item[content_id] = (\n                        translatable_item)\n            if content_id_to_not_set_translatable_item:\n                mapping_without_set_data_format[state_name] = (\n                    content_id_to_not_set_translatable_item)\n        return mapping_without_set_data_format\n\n    def _get_state_names_to_not_in_review_content_id_mapping(\n        self,\n        state_names_to_content_id_mapping: Dict[\n            str, Dict[str, state_domain.TranslatableItem]\n        ],\n        suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> Dict[str, Dict[str, state_domain.TranslatableItemDict]]:\n        \"\"\"Returns a copy of the supplied state_names_to_content_id_mapping\n        minus any contents found in suggestions.\n\n        Args:\n            state_names_to_content_id_mapping:\n                dict(str, dict(str, TranslatableItem)). A dict whose keys are\n                state names, and whose corresponding values are each dicts\n                mapping content IDs to the corresponding translatable items.\n            suggestions: list(Suggestion). A list of translation suggestions.\n\n        Returns:\n            dict(str, dict(str, TranslatableItem)). A dict where state_name\n            is the key and a dict with content_id as the key and\n            TranslatableItem as value.\n        \"\"\"\n        final_mapping = {}\n        for state_name in state_names_to_content_id_mapping:\n            content_id_to_translatable_item = dict(\n                state_names_to_content_id_mapping[state_name])\n            content_id_to_unsubmitted_translatable_item = {}\n            for content_id, item in content_id_to_translatable_item.items():\n                if not self._is_content_in_review(\n                        state_name, content_id, suggestions):\n                    content_id_to_unsubmitted_translatable_item[content_id] = (\n                        item)\n            if content_id_to_unsubmitted_translatable_item:\n                final_mapping[state_name] = {\n                    cid: translatable_item.to_dict()\n                    for cid, translatable_item in (\n                        content_id_to_unsubmitted_translatable_item.items())\n                }\n        return final_mapping\n\n    def _is_content_in_review(\n        self,\n        state_name: str,\n        content_id: str,\n        suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> bool:\n        \"\"\"Returns whether a suggestion exists in suggestions with a change dict\n        matching the supplied state_name and content_id.\n\n        Args:\n            state_name: str. Exploration state name.\n            content_id: str. Content ID.\n            suggestions: list(Suggestion). A list of translation suggestions.\n\n        Returns:\n            bool. True if suggestion exists in suggestions with a change dict\n            matching state_name and content_id, False otherwise.\n        \"\"\"\n        return any(\n            s.change.state_name == state_name and\n            s.change.content_id == content_id for s in suggestions)\n\n\nclass MachineTranslationStateTextsHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of MachineTranslationStateTextsHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    exp_id: str\n    state_name: str\n    content_ids: str\n    target_language_code: str\n\n\nclass MachineTranslationStateTextsHandler(\n    base.BaseHandler[\n        Dict[str, str], MachineTranslationStateTextsHandlerNormalizedRequestDict\n    ]\n):\n    \"\"\"Provides a machine translation of exploration content.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'exp_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'state_name': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'content_ids': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'target_language_code': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_supported_audio_language_code'\n                    }, {\n                        'id': 'is_valid_audio_language_code'\n                    }]\n                }\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests. Responds with a mapping from content id to\n        translation of form:\n\n            dict('translated_texts', dict(str, str|None))\n\n        If no translation is found for a given content id, that id is mapped to\n        None.\n\n        Params:\n            exp_id: str. The ID of the exploration being translated.\n            state_name: str. The name of the exploration state being translated.\n            content_ids: str[]. The content IDs of the texts to be translated.\n            target_language_code: str. The language code of the target\n                translation language.\n\n        Data Response:\n\n            dict('translated_texts': dict(str, str|None))\n\n            A dictionary containing the translated texts stored as a mapping\n                from content ID to the translated text. If an error occured\n                during retrieval of some content translations, but not others,\n                failed translations are mapped to None.\n\n        Raises:\n            400 (Bad Request): InvalidInputException. At least one input is\n                missing or improperly formatted.\n            404 (Not Found): PageNotFoundException. At least one identifier does\n                not correspond to an entry in the datastore.\n        \"\"\"\n        assert self.normalized_request is not None\n        exp_id = self.normalized_request['exp_id']\n\n        state_name = self.normalized_request['state_name']\n\n        content_ids_string = self.normalized_request['content_ids']\n        content_ids: List[str] = []\n        try:\n            content_ids = json.loads(content_ids_string)\n        except Exception as e:\n            raise self.InvalidInputException(\n                'Improperly formatted content_ids: %s' % content_ids_string\n            ) from e\n\n        target_language_code = self.normalized_request['target_language_code']\n\n        exp = exp_fetchers.get_exploration_by_id(exp_id, strict=False)\n        if exp is None:\n            raise self.PageNotFoundException()\n        state_names_to_content_id_mapping = exp.get_translatable_text(\n            target_language_code)\n        if state_name not in state_names_to_content_id_mapping:\n            raise self.PageNotFoundException()\n        content_id_to_translatable_item_mapping = (\n            state_names_to_content_id_mapping[state_name])\n        translated_texts: Dict[str, Optional[str]] = {}\n        for content_id in content_ids:\n            if content_id not in content_id_to_translatable_item_mapping:\n                translated_texts[content_id] = None\n                continue\n\n            source_text = content_id_to_translatable_item_mapping[\n                content_id].content\n            translated_texts[content_id] = (\n                translation_services.get_and_cache_machine_translation(\n                    exp.language_code, target_language_code, source_text)\n            )\n\n        self.values = {\n            'translated_texts': translated_texts\n        }\n        self.render_json(self.values)\n\n\nclass UserContributionRightsDataHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Provides contribution rights of the logged in user in translation,\n    voiceover and question category on the contributor dashboard.\n    \"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        contribution_rights = None\n        if self.username:\n            # Here we are sure that 'user_id' is not None because\n            # 'user_id' is recorded every time whenever a user claims\n            # an authentication whereas 'username' is recorded iff the\n            # user claims an authentication and successfully logged in.\n            assert self.user_id is not None\n            contribution_rights = user_services.get_user_contribution_rights(\n                self.user_id)\n        self.render_json({\n            'can_review_translation_for_language_codes': (\n                contribution_rights.can_review_translation_for_language_codes\n                if contribution_rights else []),\n            'can_review_voiceover_for_language_codes': (\n                contribution_rights.can_review_voiceover_for_language_codes\n                if contribution_rights else []),\n            'can_review_questions': (\n                contribution_rights.can_review_questions\n                if contribution_rights else False),\n            'can_suggest_questions': (\n                (contribution_rights.can_submit_questions\n                 if contribution_rights else False))\n        })\n\n\nclass FeaturedTranslationLanguagesHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Provides featured translation languages set in admin config.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        self.render_json({\n            'featured_translation_languages':\n                config_domain.FEATURED_TRANSLATION_LANGUAGES.value\n        })\n\n\nclass TranslatableTopicNamesHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Provides names of all translatable topics in the datastore.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        # Only published topics are translatable.\n        topic_summaries = topic_fetchers.get_published_topic_summaries()\n        topic_names = [summary.name for summary in topic_summaries]\n        self.values = {\n            'topic_names': topic_names\n        }\n        self.render_json(self.values)\n\n\nclass TranslationPreferenceHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of TranslationPreferenceHandler's\n    normalized_request dictionary.\n    \"\"\"\n\n    language_code: str\n\n\nclass TranslationPreferenceHandler(\n    base.BaseHandler[\n        TranslationPreferenceHandlerNormalizedRequestDict, Dict[str, str]\n    ]\n):\n    \"\"\"Provides the preferred translation language in the\n    contributor dashboard page.\n    \"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    # TODO(#15559): Rename 'is_supported_audio_language_code' and\n    # 'SUPPORTED_AUDIO_LANGUAGES' constant to make sure that the name\n    # clearly defines the purpose.\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {},\n        'POST': {\n            'language_code': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_supported_audio_language_code'\n                    }]\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_manage_own_account\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        assert self.user_id is not None\n        user_settings = user_services.get_user_settings(self.user_id)\n        return self.render_json({\n            'preferred_translation_language_code': (\n                user_settings.preferred_translation_language_code)\n        })\n\n    @acl_decorators.can_manage_own_account\n    def post(self) -> None:\n        \"\"\"Handles POST requests.\"\"\"\n        assert self.user_id is not None\n        assert self.normalized_payload is not None\n        language_code = self.normalized_payload['language_code']\n        user_services.update_preferred_translation_language_code(\n            self.user_id, language_code)\n        self.render_json({})\n\n\nclass ContributorStatsSummariesHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Returns contribution statistics for the supplied contribution type.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS = {\n        'username': {\n            'schema': {\n                'type': 'basestring'\n            }\n        },\n        'contribution_type': {\n            'schema': {\n                'type': 'basestring'\n            }\n        },\n        'contribution_subtype': {\n            'schema': {\n                'type': 'basestring'\n            }\n        }\n    }\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.can_fetch_contributor_dashboard_stats\n    def get(\n        self,\n        contribution_type: str,\n        contribution_subtype: str,\n        username: str\n    ) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        if contribution_type not in [\n            feconf.CONTRIBUTION_TYPE_TRANSLATION,\n            feconf.CONTRIBUTION_TYPE_QUESTION\n        ]:\n            raise self.InvalidInputException(\n                'Invalid contribution type %s.' % (contribution_type)\n            )\n        if contribution_subtype not in [\n            feconf.CONTRIBUTION_SUBTYPE_SUBMISSION,\n            feconf.CONTRIBUTION_SUBTYPE_REVIEW\n        ]:\n            raise self.InvalidInputException(\n                'Invalid contribution subtype %s.' % (contribution_subtype)\n            )\n\n        user_id = user_services.get_user_id_from_username(username)\n        # Here we are sure that user_id will never be None, because\n        # we are already handling the None case of user_id in\n        # `can_fetch_contributor_dashboard_stats` decorator by\n        # raising an exception.\n        assert user_id is not None\n        if contribution_type == feconf.CONTRIBUTION_TYPE_TRANSLATION:\n            if contribution_subtype == feconf.CONTRIBUTION_SUBTYPE_SUBMISSION:\n                stats: ListOfContributorDashboardStatsTypes = (\n                    suggestion_services.get_all_translation_contribution_stats(\n                        user_id))\n                self.values = {\n                    'translation_contribution_stats': _get_client_side_stats(\n                        stats)\n                }\n\n            if contribution_subtype == feconf.CONTRIBUTION_SUBTYPE_REVIEW:\n                stats = suggestion_services.get_all_translation_review_stats(\n                    user_id)\n                self.values = {\n                    'translation_review_stats': _get_client_side_stats(\n                        stats)\n                }\n\n        if contribution_type == feconf.CONTRIBUTION_TYPE_QUESTION:\n            if contribution_subtype == feconf.CONTRIBUTION_SUBTYPE_SUBMISSION:\n                stats = suggestion_services.get_all_question_contribution_stats(\n                    user_id)\n                self.values = {\n                    'question_contribution_stats': _get_client_side_stats(\n                        stats)\n                }\n\n            if contribution_subtype == feconf.CONTRIBUTION_SUBTYPE_REVIEW:\n                stats = suggestion_services.get_all_question_review_stats(\n                    user_id)\n                self.values = {\n                    'question_review_stats': _get_client_side_stats(stats)\n                }\n\n        self.render_json(self.values)\n\n\nclass ContributorCertificateHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Returns contributor certificate.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS = {\n        'username': {\n            'schema': {\n                'type': 'basestring',\n                'validators': [{\n                    'id': 'has_length_at_most',\n                    'max_value': constants.MAX_USERNAME_LENGTH\n                }]\n            }\n        },\n        'suggestion_type': {\n            'schema': {\n                'type': 'basestring',\n                'choices': feconf.SUGGESTION_TYPE_CHOICES\n            }\n        }\n    }\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'from_date': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_regex_matched',\n                        'regex_pattern': constants.DATE_REGEX\n                    }]\n                }\n            },\n            'to_date': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_regex_matched',\n                        'regex_pattern': constants.DATE_REGEX\n                    }]\n                }\n            },\n            'language': {\n                'schema': {\n                    'type': 'basestring',\n                    'validators': [{\n                        'id': 'is_supported_audio_language_code'\n                    }]\n                },\n                'default_value': None\n            },\n        }\n    }\n\n    @acl_decorators.can_fetch_all_contributor_dashboard_stats\n    def get(\n        self, username: str, suggestion_type: str\n    ) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        assert self.normalized_request is not None\n        from_date = self.normalized_request['from_date']\n        to_date = self.normalized_request['to_date']\n\n        # When generating the question contributors' certificates, we do not\n        # send language parameter. Hence, we will have to use\n        # self.normalized_request.get('language') in order to get the default\n        # value when language is not present in the request.\n        language = self.normalized_request.get('language')\n\n        from_datetime = datetime.datetime.strptime(from_date, '%Y-%m-%d')\n        to_datetime = datetime.datetime.strptime(to_date, '%Y-%m-%d')\n        if to_datetime.date() > datetime.datetime.now().date():\n            raise self.InvalidInputException(\n                'To date should not be a future date.')\n\n        response = suggestion_services.generate_contributor_certificate_data(\n            username, suggestion_type, language, from_datetime,\n            to_datetime)\n\n        self.render_json(response)\n\n\nclass ContributorAllStatsSummariesHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Returns all contribution statistics associated with the user.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS = {\n        'username': {\n            'schema': {\n                'type': 'basestring'\n            }\n        }\n    }\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.can_fetch_all_contributor_dashboard_stats\n    def get(self, username: str) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        user_id = user_services.get_user_id_from_username(username)\n        # Here we are sure that user_id will never be None, because\n        # we are already handling the None case of user_id in\n        # `can_fetch_all_contributor_dashboard_stats` decorator by\n        # raising an exception.\n        assert user_id is not None\n        stats = suggestion_services.get_all_contributor_stats(user_id)\n        response = {}\n\n        if stats.translation_contribution_stats is not None:\n            response['translation_contribution_stats'] = _get_client_side_stats(\n                stats.translation_contribution_stats)\n\n        if stats.translation_review_stats is not None:\n            response['translation_review_stats'] = _get_client_side_stats(\n                stats.translation_review_stats)\n\n        if stats.question_contribution_stats is not None:\n            response['question_contribution_stats'] = _get_client_side_stats(\n                stats.question_contribution_stats)\n\n        if stats.question_review_stats is not None:\n            response['question_review_stats'] = _get_client_side_stats(\n                stats.question_review_stats)\n\n        self.render_json(response)\n\n\ndef _get_client_side_stats(\n    backend_stats: ListOfContributorDashboardStatsTypes\n) -> ListOfContributorDashboardStatsDictTypes:\n    \"\"\"Returns corresponding stats dicts with all the necessary\n    information for the frontend.\n\n    Args:\n        backend_stats: list. Stats domain objects.\n\n    Returns:\n        list. Dict representations of TranslationContributionStats/\n        TranslationReviewStats/QuestionContributionStats/\n        QuestionReviewStats domain objects with additional keys:\n            topic_name: str. Topic name.\n            contribution_months: str. Unique translation contribution\n                months of format: \"%b %Y\", e.g. \"Jan 2021\".\n        Unnecessary keys topic_id, contribution_dates, contributor_user_id\n        are consequently deleted.\n\n    Raises:\n        Exception. No topic_id associated with stats object.\n    \"\"\"\n    stats_dicts = [\n        stats.to_frontend_dict() for stats in backend_stats\n    ]\n    topic_ids = []\n    for index, stats_dict in enumerate(stats_dicts):\n        if stats_dict['topic_id'] is None:\n            raise Exception(\n                'No topic_id associated with stats: %s.' %\n                type(backend_stats[index]).__name__\n            )\n        topic_ids.append(stats_dict['topic_id'])\n    topic_summaries = topic_fetchers.get_multi_topic_summaries(topic_ids)\n    topic_name_by_topic_id = {\n        topic_summary.id: topic_summary.name\n        for topic_summary in topic_summaries if topic_summary is not None\n    }\n    for stats_dict in stats_dicts:\n        # Here we are asserting that 'stats_dict['topic_id']' will never be None\n        # because above we are already handling the case of None 'topic_id' by\n        # raising an exception.\n        assert stats_dict['topic_id'] is not None\n        # Here we use MyPy ignore because 'stats_dict' is of union TypedDicts\n        # and MyPy is unable to infer on which TypedDict 'topic_name' key\n        # is added. So, due to this MyPy throws an error. Thus, to avoid\n        # the error, we use ignore here.\n        stats_dict['topic_name'] = topic_name_by_topic_id.get(  # type: ignore[index]\n            stats_dict['topic_id'], 'UNKNOWN')\n        # Here we use MyPy ignore because MyPy doesn't allow key deletion\n        # from TypedDict.\n        del stats_dict['topic_id']  # type: ignore[misc]\n    return stats_dicts\n"
    },
    {
      "filename": "core/controllers/contributor_dashboard_test.py",
      "content": "# Copyright 2019 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the contributor dashboard controllers.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.domain import config_services\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import state_domain\nfrom core.domain import story_domain\nfrom core.domain import story_fetchers\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_domain\nfrom core.domain import subtopic_page_services\nfrom core.domain import suggestion_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\nfrom typing import Dict, List, cast\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from mypy_imports import suggestion_models\n\n(suggestion_models,) = models.Registry.import_models([models.Names.SUGGESTION])\n\n\nclass ContributorDashboardPageTest(test_utils.GenericTestBase):\n    \"\"\"Test for showing contributor dashboard pages.\"\"\"\n\n    def test_page_with_disabled_contributor_dashboard_leads_to_404(\n        self\n    ) -> None:\n        config_services.set_property(\n            'admin', 'contributor_dashboard_is_enabled', False)\n        self.get_html_response(\n            feconf.CONTRIBUTOR_DASHBOARD_URL, expected_status_int=404)\n\n    def test_page_with_enabled_contributor_dashboard_loads_correctly(\n        self\n    ) -> None:\n        config_services.set_property(\n            'admin', 'contributor_dashboard_is_enabled', True)\n        response = self.get_html_response(feconf.CONTRIBUTOR_DASHBOARD_URL)\n        response.mustcontain(\n            '<contributor-dashboard-page></contributor-dashboard-page>')\n\n\nclass ContributionOpportunitiesHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Unit test for the ContributionOpportunitiesHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        user_services.allow_user_to_review_translation_in_language(\n            self.admin_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.admin_id, 'es')\n\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category=constants.ALL_CATEGORIES[i],\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        ) for i in range(3)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n\n        self.topic_id = '0'\n        topic = topic_domain.Topic.create_default_topic(\n            self.topic_id, 'topic', 'abbrev', 'description', 'fragm')\n        self.skill_id_0 = 'skill_id_0'\n        self.skill_id_1 = 'skill_id_1'\n        self._publish_valid_topic(topic, [self.skill_id_0, self.skill_id_1])\n\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_0', self.topic_id, '0')\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_1', self.topic_id, '1')\n\n        self.topic_id_1 = '1'\n        topic = topic_domain.Topic.create_default_topic(\n            self.topic_id_1, 'topic1', 'url-fragment', 'description', 'fragm')\n        self.skill_id_2 = 'skill_id_2'\n        self._publish_valid_topic(topic, [self.skill_id_2])\n\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_2', self.topic_id_1, '2')\n\n        # Add skill opportunity topic to a classroom.\n        config_services.set_property(\n            self.admin_id, 'classroom_pages_data', [{\n                'name': 'math',\n                'url_fragment': 'math-one',\n                'topic_ids': [self.topic_id],\n                'course_details': '',\n                'topic_list_intro': ''\n            }])\n\n        self.expected_skill_opportunity_dict_0 = {\n            'id': self.skill_id_0,\n            'skill_description': 'skill_description',\n            'question_count': 0,\n            'topic_name': 'topic'\n        }\n        self.expected_skill_opportunity_dict_1 = {\n            'id': self.skill_id_1,\n            'skill_description': 'skill_description',\n            'question_count': 0,\n            'topic_name': 'topic'\n        }\n        self.expected_skill_opportunity_dict_2 = {\n            'id': self.skill_id_2,\n            'skill_description': 'skill_description',\n            'question_count': 0,\n            'topic_name': 'topic1'\n        }\n\n        # The content_count is 2 for the expected dicts below since each\n        # corresponding exploration has one initial state and one end state.\n        self.expected_opportunity_dict_1 = {\n            'id': '0',\n            'topic_name': 'topic',\n            'story_title': 'title story_id_0',\n            'chapter_title': 'Node1',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n        self.expected_opportunity_dict_2 = {\n            'id': '1',\n            'topic_name': 'topic',\n            'story_title': 'title story_id_1',\n            'chapter_title': 'Node1',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n        self.expected_opportunity_dict_3 = {\n            'id': '2',\n            'topic_name': 'topic1',\n            'story_title': 'title story_id_2',\n            'chapter_title': 'Node1',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n        config_services.set_property(\n            'admin', 'contributor_dashboard_is_enabled', True)\n\n    def test_handler_with_disabled_dashboard_flag_raise_404(self) -> None:\n        config_services.set_property(\n            'admin', 'contributor_dashboard_is_enabled', True)\n\n        self.get_json(\n            '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={}, expected_status_int=200)\n\n        config_services.set_property(\n            'admin', 'contributor_dashboard_is_enabled', False)\n\n        self.get_json(\n            '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={}, expected_status_int=404)\n\n    def test_get_skill_opportunity_data(self) -> None:\n        response = self.get_json(\n            '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={})\n        self.assertEqual(\n            response['opportunities'], [\n                self.expected_skill_opportunity_dict_0,\n                self.expected_skill_opportunity_dict_1])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_skill_opportunity_data_does_not_return_non_classroom_topics(\n        self\n    ) -> None:\n        config_services.revert_property(\n            self.admin_id, 'classroom_pages_data')\n\n        response = self.get_json(\n            '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={})\n\n        self.assertEqual(\n            response['opportunities'], [])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_skill_opportunity_data_does_not_throw_for_deleted_topics(\n        self\n    ) -> None:\n        topic_services.delete_topic(self.admin_id, self.topic_id)\n\n        response = self.get_json(\n            '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={})\n\n        self.assertEqual(\n            response['opportunities'], [])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_translation_opportunities_fetches_matching_opportunities(\n        self\n    ) -> None:\n        response = self.get_json(\n            '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={'language_code': 'hi', 'topic_name': 'topic'})\n\n        self.assertEqual(\n            response['opportunities'], [\n                self.expected_opportunity_dict_1,\n                self.expected_opportunity_dict_2])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_skill_opportunity_data_pagination(self) -> None:\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 1):\n            response = self.get_json(\n                '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={})\n            self.assertEqual(len(response['opportunities']), 1)\n            self.assertEqual(\n                response['opportunities'],\n                [self.expected_skill_opportunity_dict_0])\n            self.assertTrue(response['more'])\n            self.assertIsInstance(response['next_cursor'], str)\n\n            next_cursor = response['next_cursor']\n            next_response = self.get_json(\n                '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={'cursor': next_cursor})\n\n            self.assertEqual(len(next_response['opportunities']), 1)\n            self.assertEqual(\n                next_response['opportunities'],\n                [self.expected_skill_opportunity_dict_1])\n            self.assertTrue(next_response['more'])\n            self.assertIsInstance(next_response['next_cursor'], str)\n\n            next_cursor = next_response['next_cursor']\n            next_response = self.get_json(\n                '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={'cursor': next_cursor})\n\n            # Skill 2 is not part of a Classroom topic and so its corresponding\n            # opportunity is not returned.\n            self.assertEqual(len(next_response['opportunities']), 0)\n            self.assertFalse(next_response['more'])\n            self.assertIsInstance(next_response['next_cursor'], str)\n\n    def test_get_skill_opportunity_data_pagination_multiple_fetches(\n        self\n    ) -> None:\n        # Unassign topic 0 from the classroom.\n        config_services.revert_property(self.admin_id, 'classroom_pages_data')\n\n        # Create a new topic.\n        topic_id = '9'\n        topic_name = 'topic9'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, topic_name, 'url-fragment-nine', 'description', 'fragm')\n        skill_id_3 = 'skill_id_3'\n        skill_id_4 = 'skill_id_4'\n        skill_id_5 = 'skill_id_5'\n        self._publish_valid_topic(\n            topic, [skill_id_3, skill_id_4, skill_id_5])\n\n        # Add new topic to a classroom.\n        config_services.set_property(\n            self.admin_id, 'classroom_pages_data', [{\n                'name': 'math',\n                'url_fragment': 'math-one',\n                'topic_ids': [topic_id],\n                'course_details': '',\n                'topic_list_intro': ''\n            }])\n\n        # Opportunities with IDs skill_id_0, skill_id_1, skill_id_2 will be\n        # fetched first. Since skill_id_0, skill_id_1, skill_id_2 are not linked\n        # to a classroom, another fetch will be made to retrieve skill_id_3,\n        # skill_id_4, skill_id_5 to fulfill the page size.\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 3):\n            response = self.get_json(\n                '%s/skill' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={})\n            self.assertEqual(len(response['opportunities']), 3)\n            self.assertEqual(\n                response['opportunities'],\n                [\n                    {\n                        'id': skill_id_3,\n                        'skill_description': 'skill_description',\n                        'question_count': 0,\n                        'topic_name': topic_name\n                    },\n                    {\n                        'id': skill_id_4,\n                        'skill_description': 'skill_description',\n                        'question_count': 0,\n                        'topic_name': topic_name\n                    },\n                    {\n                        'id': skill_id_5,\n                        'skill_description': 'skill_description',\n                        'question_count': 0,\n                        'topic_name': topic_name\n                    }\n                ])\n            self.assertFalse(response['more'])\n            self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_translation_opportunity_data_pagination(self) -> None:\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 1):\n            response = self.get_json(\n                '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={'language_code': 'hi', 'topic_name': 'topic'})\n            self.assertEqual(len(response['opportunities']), 1)\n            self.assertEqual(\n                response['opportunities'], [self.expected_opportunity_dict_1])\n            self.assertTrue(response['more'])\n            self.assertIsInstance(response['next_cursor'], str)\n\n            next_response = self.get_json(\n                '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={\n                    'language_code': 'hi',\n                    'topic_name': 'topic',\n                    'cursor': response['next_cursor']\n                }\n            )\n            self.assertEqual(len(next_response['opportunities']), 1)\n            self.assertEqual(\n                next_response['opportunities'],\n                [self.expected_opportunity_dict_2])\n            self.assertFalse(next_response['more'])\n            self.assertIsInstance(next_response['next_cursor'], str)\n\n    def test_get_translation_opportunity_with_invalid_language_code(\n        self\n    ) -> None:\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 1):\n            self.get_json(\n                '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                params={'language_code': 'invalid_lang_code'},\n                expected_status_int=400)\n\n    def test_get_translation_opportunity_without_language_code(self) -> None:\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 1):\n            self.get_json(\n                '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n                expected_status_int=400)\n\n    def test_get_translation_opportunities_without_topic_name_returns_all_topics( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        response = self.get_json(\n            '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={'language_code': 'hi'})\n\n        self.assertEqual(\n            response['opportunities'], [\n                self.expected_opportunity_dict_1,\n                self.expected_opportunity_dict_2,\n                self.expected_opportunity_dict_3])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_translation_opportunities_with_empty_topic_name_returns_all_topics( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        response = self.get_json(\n            '%s/translation' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n            params={'language_code': 'hi', 'topic_name': ''})\n\n        self.assertEqual(\n            response['opportunities'], [\n                self.expected_opportunity_dict_1,\n                self.expected_opportunity_dict_2,\n                self.expected_opportunity_dict_3])\n        self.assertFalse(response['more'])\n        self.assertIsInstance(response['next_cursor'], str)\n\n    def test_get_opportunity_for_invalid_opportunity_type(self) -> None:\n        with self.swap(constants, 'OPPORTUNITIES_PAGE_SIZE', 1):\n            self.get_json(\n                '%s/invalid_opportunity_type' % (\n                    feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL),\n                expected_status_int=404)\n\n    def test_get_reviewable_translation_opportunities_returns_in_review_suggestions( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Create a translation suggestion for exploration 0.\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.owner_id, change_dict, 'description')\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # Should only return opportunities that have corresponding translation\n        # suggestions in review (exploration 0).\n        self.assertEqual(\n            response['opportunities'], [self.expected_opportunity_dict_1])\n\n    def test_get_reviewable_translation_opportunities_filtering_language( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Create a translation suggestion in Hindi.\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.owner_id, change_dict, 'description')\n\n        # Create a translation suggestion in Spanish.\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'es',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content 2.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.owner_id, change_dict, 'description 2')\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'language_code': 'es'})\n        # Should only return opportunities in Spanish.\n        self.assertEqual(\n            response['opportunities'], [self.expected_opportunity_dict_2])\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'language_code': 'hi'})\n        # Should only return opportunities in Hindi.\n        self.assertEqual(\n            response['opportunities'], [self.expected_opportunity_dict_1])\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'language_code': 'pt'})\n        # Should be empty.\n        self.assertEqual(\n            response['opportunities'], [])\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL)\n        # Should return all opportunities.\n        self.assertEqual(\n            response['opportunities'], [self.expected_opportunity_dict_1, self.expected_opportunity_dict_2])\n\n    def test_raises_error_if_story_contain_none_exploration_id(self) -> None:\n        # Create a new exploration and linked story.\n        continue_state_name = 'continue state'\n        exp_100 = self.save_new_linear_exp_with_state_names_and_interactions(\n            '100',\n            self.owner_id,\n            ['Introduction', continue_state_name, 'End state'],\n            ['TextInput', 'Continue'],\n            category='Algebra',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_100.id)\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_100', self.topic_id,\n            exp_100.id)\n        corrupt_story = story_fetchers.get_story_by_id('story_id_100')\n        corrupt_story.story_contents.nodes[0].exploration_id = None\n        swap_with_corrupt_story = self.swap_to_always_return(\n            story_fetchers, 'get_stories_by_ids', [corrupt_story]\n        )\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        with self.assertRaisesRegex(\n            Exception,\n            'No exploration_id found for the node_id: node_1'\n        ):\n            with swap_with_corrupt_story:\n                self.get_json(\n                    '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n                    params={'topic_name': 'topic'}\n                )\n\n    def test_get_reviewable_translation_opportunities_when_state_is_removed(\n        self\n    ) -> None:\n        # Create a new exploration and linked story.\n        continue_state_name = 'continue state'\n        exp_100 = self.save_new_linear_exp_with_state_names_and_interactions(\n            '100',\n            self.owner_id,\n            ['Introduction', continue_state_name, 'End state'],\n            ['TextInput', 'Continue'],\n            category='Algebra',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_100.id)\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_100', self.topic_id,\n            exp_100.id)\n\n        # Create a translation suggestion for continue text.\n        continue_state = exp_100.states['continue state']\n        # Here we use cast because we are narrowing down the type from various\n        # customization args value types to 'SubtitledUnicode' type, and this\n        # is done because here we are accessing 'buttontext' key from continue\n        # customization arg whose value is always of SubtitledUnicode type.\n        subtitled_unicode_of_continue_button_text = cast(\n            state_domain.SubtitledUnicode,\n            continue_state.interaction.customization_args[\n                'buttonText'].value\n        )\n        content_id_of_continue_button_text = (\n            subtitled_unicode_of_continue_button_text.content_id\n        )\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': content_id_of_continue_button_text,\n            'language_code': 'hi',\n            'content_html': 'Continue',\n            'state_name': continue_state_name,\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_100.id, 1, self.owner_id, change_dict, 'description')\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # The newly created translation suggestion with valid exploration\n        # content should be returned.\n        self.assertEqual(\n            response['opportunities'],\n            [{\n                'id': exp_100.id,\n                'topic_name': 'topic',\n                'story_title': 'title story_id_100',\n                'chapter_title': 'Node1',\n                # Introduction + Continue + End state.\n                'content_count': 4,\n                'translation_counts': {},\n                'translation_in_review_counts': {}\n            }]\n        )\n\n        init_state = exp_100.states[exp_100.init_state_name]\n        default_outcome = init_state.interaction.default_outcome\n        assert default_outcome is not None\n        default_outcome_dict = default_outcome.to_dict()\n        default_outcome_dict['dest'] = 'End state'\n        exp_services.update_exploration(\n            self.owner_id, exp_100.id, [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME),\n                    'state_name': exp_100.init_state_name,\n                    'new_value': default_outcome_dict\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_DELETE_STATE,\n                    'state_name': 'continue state',\n                }),\n            ], 'delete state')\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # After the state is deleted, the corresponding suggestion should not be\n        # returned.\n        self.assertEqual(len(response['opportunities']), 0)\n\n    def test_get_reviewable_translation_opportunities_when_original_content_is_removed( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Create a new exploration and linked story.\n        continue_state_name = 'continue state'\n        exp_100 = self.save_new_linear_exp_with_state_names_and_interactions(\n            '100',\n            self.owner_id,\n            ['Introduction', continue_state_name, 'End state'],\n            ['TextInput', 'Continue'],\n            category='Algebra',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_100.id)\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_100', self.topic_id,\n            exp_100.id)\n\n        # Create a translation suggestion for the continue text.\n        continue_state = exp_100.states['continue state']\n        # Here we use cast because we are narrowing down the type from various\n        # customization args value types to 'SubtitledUnicode' type, and this\n        # is done because here we are accessing 'buttontext' key from continue\n        # customization arg whose value is always of SubtitledUnicode type.\n        subtitled_unicode_of_continue_button_text = cast(\n            state_domain.SubtitledUnicode,\n            continue_state.interaction.customization_args[\n                'buttonText'].value\n        )\n        content_id_of_continue_button_text = (\n            subtitled_unicode_of_continue_button_text.content_id\n        )\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': content_id_of_continue_button_text,\n            'language_code': 'hi',\n            'content_html': 'Continue',\n            'state_name': continue_state_name,\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_100.id, 1, self.owner_id, change_dict, 'description')\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # Since there was a valid translation suggestion created in the setup,\n        # and one suggestion created in this test case, 2 opportunities should\n        # be returned.\n        self.assertEqual(\n            response['opportunities'],\n            [{\n                'id': exp_100.id,\n                'topic_name': 'topic',\n                'story_title': 'title story_id_100',\n                'chapter_title': 'Node1',\n                # Introduction + Multiple choice with 2 options + End state.\n                'content_count': 4,\n                'translation_counts': {},\n                'translation_in_review_counts': {}\n            }]\n        )\n\n        exp_services.update_exploration(\n            self.owner_id, exp_100.id, [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS,\n                    'state_name': continue_state_name,\n                    'new_value': {\n                        'buttonText': {\n                            'value': {\n                                'content_id': 'choices_0',\n                                'unicode_str': 'Continua'\n                            }\n                        }\n                    }\n                })], 'Update continue cust args')\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # After the original exploration content is deleted, the corresponding\n        # suggestion should not be returned.\n        self.assertEqual(len(response['opportunities']), 0)\n\n    def test_get_reviewable_translation_opportunities_with_null_topic_name(\n        self\n    ) -> None:\n        # Create a translation suggestion for exploration 0.\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.owner_id, change_dict, 'description')\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json('%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL)\n\n        # Should return all available reviewable opportunities.\n        self.assertEqual(\n            response['opportunities'], [self.expected_opportunity_dict_1])\n\n    def test_get_reviewable_translation_opportunities_with_invalid_topic(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'Invalid'},\n            expected_status_int=400)\n\n    def test_get_reviewable_translation_opportunities_returns_opportunities_in_story_order( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Create new explorations 10, 20, 30.\n        exp_10 = self.save_new_valid_exploration(\n            '10',\n            self.owner_id,\n            title='title 10',\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_10.id)\n        exp_20 = self.save_new_valid_exploration(\n            '20',\n            self.owner_id,\n            title='title 20',\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_20.id)\n        exp_30 = self.save_new_valid_exploration(\n            '30',\n            self.owner_id,\n            title='title 30',\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        )\n        self.publish_exploration(self.owner_id, exp_30.id)\n\n        # Create a new story.\n        topic_id = '0'\n        story_title = 'story title'\n        story = story_domain.Story.create_default_story(\n            'story-id', story_title, 'description', topic_id, 'url-fragment')\n        story.language_code = 'en'\n\n        # Add explorations 10, 20, 30 as story nodes.\n        story.add_node('node_1', 'Node1')\n        story.update_node_exploration_id('node_1', exp_10.id)\n        story.add_node('node_2', 'Node2')\n        story.update_node_exploration_id('node_2', exp_20.id)\n        story.add_node('node_3', 'Node3')\n        story.update_node_exploration_id('node_3', exp_30.id)\n        story.update_node_destination_node_ids(\n            'node_1', ['node_2'])\n        story.update_node_destination_node_ids(\n            'node_2', ['node_3'])\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.add_canonical_story(self.owner_id, topic_id, story.id)\n        topic_services.publish_story(topic_id, story.id, self.admin_id)\n\n        # Create translation suggestions for the explorations.\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_10.id, 1, self.owner_id, change_dict, 'description')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_20.id, 1, self.owner_id, change_dict, 'description')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_30.id, 1, self.owner_id, change_dict, 'description')\n\n        expected_opportunity_dict_10 = {\n            'id': exp_10.id,\n            'topic_name': 'topic',\n            'story_title': story_title,\n            'chapter_title': 'Node1',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n        expected_opportunity_dict_20 = {\n            'id': exp_20.id,\n            'topic_name': 'topic',\n            'story_title': story_title,\n            'chapter_title': 'Node2',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n        expected_opportunity_dict_30 = {\n            'id': exp_30.id,\n            'topic_name': 'topic',\n            'story_title': story_title,\n            'chapter_title': 'Node3',\n            'content_count': 2,\n            'translation_counts': {},\n            'translation_in_review_counts': {}\n        }\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # Should return reviewable opportunities in story order.\n        self.assertEqual(\n            response['opportunities'],\n            [\n                expected_opportunity_dict_10,\n                expected_opportunity_dict_20,\n                expected_opportunity_dict_30])\n\n        # Update story node order to explorations 10 -> 30 -> 20.\n        story.update_node_destination_node_ids('node_1', ['node_3'])\n        story.update_node_destination_node_ids('node_2', [])\n        story.update_node_destination_node_ids('node_3', ['node_2'])\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.publish_story(topic_id, story.id, self.admin_id)\n\n        response = self.get_json(\n            '%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n            params={'topic_name': 'topic'})\n\n        # Should return reviewable opportunities in new story order.\n        self.assertEqual(\n            response['opportunities'],\n            [\n                expected_opportunity_dict_10,\n                expected_opportunity_dict_30,\n                expected_opportunity_dict_20])\n\n    def _publish_valid_topic(\n        self, topic: topic_domain.Topic, uncategorized_skill_ids: List[str]\n    ) -> None:\n        \"\"\"Saves and publishes a valid topic with linked skills and subtopic.\n\n        Args:\n            topic: Topic. The topic to be saved and published.\n            uncategorized_skill_ids: list(str). List of uncategorized skills IDs\n                to add to the supplied topic.\n        \"\"\"\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        subtopic_id = 1\n        subtopic_skill_id = 'subtopic_skill_id' + topic.id\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                subtopic_id, 'Title', [subtopic_skill_id], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = [subtopic_skill_id]\n        subtopic_page = (\n            subtopic_page_domain.SubtopicPage.create_default_subtopic_page(\n                subtopic_id, topic.id))\n        subtopic_page_services.save_subtopic_page(\n            self.owner_id, subtopic_page, 'Added subtopic',\n            [topic_domain.TopicChange({\n                'cmd': topic_domain.CMD_ADD_SUBTOPIC,\n                'subtopic_id': 1,\n                'title': 'Sample',\n                'url_fragment': 'sample-fragment'\n            })]\n        )\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(topic.id, self.admin_id)\n\n        for skill_id in uncategorized_skill_ids:\n            self.save_new_skill(\n                skill_id, self.admin_id, description='skill_description')\n            topic_services.add_uncategorized_skill(\n                self.admin_id, topic.id, skill_id)\n\n\nclass TranslatableTextHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Unit test for the ContributionOpportunitiesHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category=constants.ALL_CATEGORIES[i],\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        ) for i in range(2)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n\n        topic = topic_domain.Topic.create_default_topic(\n            '0', 'topic', 'abbrev', 'description', 'fragm')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_1'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = ['skill_id_1']\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(topic.id, self.admin_id)\n\n        stories = [story_domain.Story.create_default_story(\n            '%s' % i,\n            'title %d' % i,\n            'description %d' % i,\n            '0',\n            'title-%s' % chr(97 + i)\n        ) for i in range(2)]\n\n        for index, story in enumerate(stories):\n            story.language_code = 'en'\n            story_services.save_new_story(self.owner_id, story)\n            topic_services.add_canonical_story(\n                self.owner_id, topic.id, story.id)\n            topic_services.publish_story(topic.id, story.id, self.admin_id)\n            story_services.update_story(\n                self.owner_id, story.id, [story_domain.StoryChange({\n                    'cmd': 'add_story_node',\n                    'node_id': 'node_1',\n                    'title': 'Node1',\n                }), story_domain.StoryChange({\n                    'cmd': 'update_story_node_property',\n                    'property_name': 'exploration_id',\n                    'node_id': 'node_1',\n                    'old_value': None,\n                    'new_value': explorations[index].id\n                })], 'Changes.')\n\n    def test_handler_with_invalid_language_code_raise_exception(self) -> None:\n        self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'hi',\n            'exp_id': '0'\n        }, expected_status_int=200)\n\n        self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'invalid_lang_code',\n            'exp_id': '0'\n        }, expected_status_int=400)\n\n    def test_handler_with_exp_id_not_for_contribution_raise_exception(\n        self\n    ) -> None:\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'hi',\n            'exp_id': '0'\n        }, expected_status_int=200)\n\n        new_exp = exp_domain.Exploration.create_default_exploration(\n            'not_for_contribution')\n        exp_services.save_new_exploration(self.owner_id, new_exp)\n\n        self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'hi',\n            'exp_id': 'not_for_contribution'\n        }, expected_status_int=400)\n\n        self.logout()\n\n    def test_handler_returns_correct_data(self) -> None:\n        exp_services.update_exploration(\n            self.owner_id, '0', [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'Introduction',\n                'new_value': {\n                    'content_id': 'content',\n                    'html': '<p>A content to translate.</p>'\n                }\n            })], 'Changes content.')\n\n        output = self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'hi',\n            'exp_id': '0'\n        })\n\n        expected_output = {\n            'version': 2,\n            'state_names_to_content_id_mapping': {\n                'Introduction': {\n                    'content': {\n                        'content': (\n                            '<p>A content to translate.</p>'),\n                        'data_format': 'html',\n                        'content_type': 'content',\n                        'interaction_id': None,\n                        'rule_type': None\n                    }\n                },\n                'End State': {\n                    'content': {\n                        'content': '',\n                        'data_format': 'html',\n                        'content_type': 'content',\n                        'interaction_id': None,\n                        'rule_type': None\n                    }\n                }\n            }\n        }\n\n        self.assertEqual(output, expected_output)\n\n    def test_handler_does_not_return_in_review_content(self) -> None:\n        change_dict = {\n            'cmd': 'add_written_translation',\n            'state_name': 'Introduction',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.owner_id, change_dict, 'description')\n\n        output = self.get_json('/gettranslatabletexthandler', params={\n            'language_code': 'hi',\n            'exp_id': '0'\n        })\n\n        expected_output = {\n            'version': 1,\n            'state_names_to_content_id_mapping': {\n                'End State': {\n                    'content': {\n                        'content': '',\n                        'data_format': 'html',\n                        'content_type': 'content',\n                        'interaction_id': None,\n                        'rule_type': None\n                    }\n                }\n            }\n        }\n        self.assertEqual(output, expected_output)\n\n\nclass MachineTranslationStateTextsHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for MachineTranslationStateTextsHandler\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        self.exp_id = exp_fetchers.get_new_exploration_id()\n        exp = self.save_new_valid_exploration(\n            self.exp_id,\n            self.owner_id,\n            title='title',\n            category='category',\n            end_state_name='End State'\n        )\n\n        self.publish_exploration(self.owner_id, exp.id)\n\n    def test_handler_with_invalid_language_code_raises_exception(self) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'invalid_language_code'\n            }, expected_status_int=400)\n\n        error_msg = (\n            'Schema validation for \\'target_language_code\\' failed: '\n            'Validation failed: is_supported_audio_language_code ({}) for '\n            'object invalid_language_code')\n        self.assertEqual(\n            output['error'], error_msg)\n\n    def test_handler_with_no_target_language_code_raises_exception(\n        self\n    ) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'content_ids': '[\"content\"]',\n            }, expected_status_int=400)\n\n        error_msg = 'Missing key in handler args: target_language_code.'\n        self.assertEqual(\n            output['error'], error_msg)\n\n    def test_handler_with_invalid_exploration_id_returns_not_found(\n        self\n    ) -> None:\n        self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': 'invalid_exploration_id',\n                'state_name': 'End State',\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'es'\n            }, expected_status_int=404)\n\n    def test_handler_with_no_exploration_id_raises_exception(self) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'state_name': 'End State',\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'es'\n            }, expected_status_int=400)\n\n        error_msg = 'Missing key in handler args: exp_id.'\n        self.assertEqual(\n            output['error'], error_msg)\n\n    def test_handler_with_invalid_state_name_returns_not_found(self) -> None:\n        self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'invalid_state_name',\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'es'\n            }, expected_status_int=404)\n\n    def test_handler_with_no_state_name_raises_exception(self) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'es'\n            }, expected_status_int=400)\n\n        error_msg = 'Missing key in handler args: state_name.'\n        self.assertEqual(\n            output['error'], error_msg)\n\n    def test_handler_with_invalid_content_ids_returns_none(self) -> None:\n        exp_services.update_exploration(\n            self.owner_id, self.exp_id, [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'End State',\n                'new_value': {\n                    'content_id': 'content',\n                    'html': 'Please continue.'\n                }\n            })], 'Changes content.')\n\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'content_ids': '[\"invalid_content_id\", \"content\"]',\n                'target_language_code': 'es'\n            }, expected_status_int=200\n        )\n\n        expected_output = {\n            'translated_texts': {\n                'content': 'Por favor continua.',\n                'invalid_content_id': None\n            }\n        }\n        self.assertEqual(output, expected_output)\n\n    def test_handler_with_invalid_content_ids_format_raises_exception(\n        self\n    ) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'content_ids': 'invalid_format',\n                'target_language_code': 'es'\n            }, expected_status_int=400)\n        self.assertEqual(\n            output['error'],\n            'Improperly formatted content_ids: invalid_format')\n\n    def test_handler_with_empty_content_ids_returns_empty_response_dict(\n        self\n    ) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'content_ids': '[]',\n                'target_language_code': 'es'\n            }, expected_status_int=200\n        )\n        expected_output: Dict[str, Dict[str, str]] = {\n            'translated_texts': {}\n        }\n        self.assertEqual(output, expected_output)\n\n    def test_handler_with_missing_content_ids_parameter_raises_exception(\n        self\n    ) -> None:\n        output = self.get_json(\n            '/machine_translated_state_texts_handler', params={\n                'exp_id': self.exp_id,\n                'state_name': 'End State',\n                'target_language_code': 'en'\n            }, expected_status_int=400\n        )\n\n        error_msg = 'Missing key in handler args: content_ids.'\n        self.assertEqual(\n            output['error'], error_msg)\n\n    def test_handler_with_valid_input_returns_translation(self) -> None:\n        exp_services.update_exploration(\n            self.owner_id, self.exp_id, [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'Introduction',\n                'new_value': {\n                    'content_id': 'content',\n                    'html': 'Please continue.'\n                }\n            })], 'Changes content.')\n\n        output = self.get_json(\n            '/machine_translated_state_texts_handler',\n            params={\n                'exp_id': self.exp_id,\n                'state_name': 'Introduction',\n                'content_ids': '[\"content\"]',\n                'target_language_code': 'es'\n            },\n            expected_status_int=200\n        )\n\n        expected_output = {\n            'translated_texts': {'content': 'Por favor continua.'}\n        }\n        self.assertEqual(output, expected_output)\n\n\nclass UserContributionRightsDataHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the UserContributionRightsDataHandler.\"\"\"\n\n    def test_guest_user_check_contribution_rights(self) -> None:\n        response = self.get_json('/usercontributionrightsdatahandler')\n\n        self.assertEqual(\n            response, {\n                'can_review_translation_for_language_codes': [],\n                'can_review_voiceover_for_language_codes': [],\n                'can_review_questions': False,\n                'can_suggest_questions': False\n            })\n\n    def test_user_check_contribution_rights(self) -> None:\n        user_email = 'user@example.com'\n        self.signup(user_email, 'user')\n        user_id = self.get_user_id_from_email(user_email)\n        self.login(user_email)\n\n        response = self.get_json('/usercontributionrightsdatahandler')\n        self.assertEqual(\n            response, {\n                'can_review_translation_for_language_codes': [],\n                'can_review_voiceover_for_language_codes': [],\n                'can_review_questions': False,\n                'can_suggest_questions': False\n            })\n\n        user_services.allow_user_to_review_question(user_id)\n\n        response = self.get_json('/usercontributionrightsdatahandler')\n        self.assertEqual(\n            response, {\n                'can_review_translation_for_language_codes': [],\n                'can_review_voiceover_for_language_codes': [],\n                'can_review_questions': True,\n                'can_suggest_questions': False\n            })\n\n    def test_can_suggest_questions_flag_in_response(self) -> None:\n        user_email = 'user@example.com'\n        self.signup(user_email, 'user')\n        user_id = self.get_user_id_from_email(user_email)\n        self.login(user_email)\n\n        response = self.get_json('/usercontributionrightsdatahandler')\n        self.assertEqual(\n            response, {\n                'can_review_translation_for_language_codes': [],\n                'can_review_voiceover_for_language_codes': [],\n                'can_review_questions': False,\n                'can_suggest_questions': False\n            })\n\n        user_services.allow_user_to_submit_question(user_id)\n\n        response = self.get_json('/usercontributionrightsdatahandler')\n        self.assertEqual(\n            response, {\n                'can_review_translation_for_language_codes': [],\n                'can_review_voiceover_for_language_codes': [],\n                'can_review_questions': False,\n                'can_suggest_questions': True\n            })\n\n\nclass FeaturedTranslationLanguagesHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the FeaturedTranslationLanguagesHandler.\"\"\"\n\n    def test_get_featured_translation_languages(self) -> None:\n        response = self.get_json('/retrivefeaturedtranslationlanguages')\n        self.assertEqual(\n            response,\n            {'featured_translation_languages': []}\n        )\n\n        new_value = [\n            {'language_code': 'en', 'explanation': 'Partnership with ABC'}\n        ]\n        config_services.set_property(\n            'admin',\n            'featured_translation_languages',\n            new_value\n        )\n\n        response = self.get_json('/retrivefeaturedtranslationlanguages')\n        self.assertEqual(\n            response,\n            {'featured_translation_languages': new_value}\n        )\n\n\nclass TranslatableTopicNamesHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the TranslatableTopicNamesHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n    def test_get_translatable_topic_names(self) -> None:\n        response = self.get_json('/gettranslatabletopicnames')\n        self.assertEqual(\n            response,\n            {'topic_names': []}\n        )\n\n        topic_id = '0'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic', 'abbrev', 'description', 'fragm')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_3'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = ['skill_id_3']\n        topic_services.save_new_topic(self.owner_id, topic)\n\n        # Unpublished topics should not be returned.\n        response = self.get_json('/gettranslatabletopicnames')\n        self.assertEqual(len(response['topic_names']), 0)\n\n        topic_services.publish_topic(topic_id, self.admin_id)\n\n        response = self.get_json('/gettranslatabletopicnames')\n        self.assertEqual(\n            response,\n            {'topic_names': ['topic']}\n        )\n\n\nclass TranslationPreferenceHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the TranslationPreferenceHandler.\"\"\"\n\n    def test_get_preferred_translation_language_when_user_is_logged_in(\n        self\n    ) -> None:\n        user_email = 'user@example.com'\n        self.signup(user_email, 'user')\n        self.login(user_email)\n\n        response = self.get_json('/preferredtranslationlanguage')\n        self.assertIsNone(response['preferred_translation_language_code'])\n\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '/preferredtranslationlanguage',\n            {'language_code': 'en'},\n            csrf_token=csrf_token\n        )\n\n        response = self.get_json('/preferredtranslationlanguage')\n        self.assertEqual(response['preferred_translation_language_code'], 'en')\n        self.logout()\n\n    def test_handler_with_guest_user_raises_exception(self) -> None:\n        response = self.get_json(\n            '/preferredtranslationlanguage', expected_status_int=401)\n\n        error_msg = 'You must be logged in to access this resource.'\n        self.assertEqual(response['error'], error_msg)\n\n\nclass ContributorStatsSummariesHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the ContributorStatsSummariesHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n    def _publish_topic(self, topic_id: str, topic_name: str) -> None:\n        \"\"\"Creates and publishes a topic.\n\n        Args:\n            topic_id: str. Topic ID.\n            topic_name: str. Topic name.\n        \"\"\"\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, topic_name, 'abbrev', 'description', 'fragm')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_3'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = ['skill_id_3']\n        topic_services.save_new_topic(self.admin_id, topic)\n        topic_services.publish_topic(topic_id, self.admin_id)\n\n    def test_get_translation_contribution_stats(self) -> None:\n        # Create and publish a topic.\n        published_topic_id = 'topic_id'\n        published_topic_name = 'published_topic_name'\n        self._publish_topic(published_topic_id, published_topic_name)\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id=self.owner_id,\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836)\n            ]\n        )\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorstatssummaries/translation/submission/%s' % (\n                self.OWNER_USERNAME))\n\n        self.assertEqual(\n            response, {\n                'translation_contribution_stats': [\n                    {\n                        'language_code': 'es',\n                        'topic_name': 'published_topic_name',\n                        'submitted_translations_count': 2,\n                        'submitted_translation_word_count': 100,\n                        'accepted_translations_count': 1,\n                        'accepted_translations_without_reviewer_edits_count': (\n                            0),\n                        'accepted_translation_word_count': 50,\n                        'rejected_translations_count': 0,\n                        'rejected_translation_word_count': 0,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ]\n            })\n\n        self.logout()\n\n    def test_get_translation_review_stats(self) -> None:\n        # Create and publish a topic.\n        published_topic_id = 'topic_id'\n        published_topic_name = 'published_topic_name'\n        self._publish_topic(published_topic_id, published_topic_name)\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code='es',\n            reviewer_user_id=self.owner_id,\n            topic_id='topic_id',\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=1,\n            accepted_translations_count=1,\n            accepted_translations_with_reviewer_edits_count=0,\n            accepted_translation_word_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorstatssummaries/translation/review/%s' % (\n                self.OWNER_USERNAME))\n\n        self.assertEqual(\n            response, {\n                'translation_review_stats': [\n                    {\n                        'language_code': 'es',\n                        'topic_name': 'published_topic_name',\n                        'reviewed_translations_count': 1,\n                        'reviewed_translation_word_count': 1,\n                        'accepted_translations_count': 1,\n                        'accepted_translations_with_reviewer_edits_count': 0,\n                        'accepted_translation_word_count': 1,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ]\n            })\n\n        self.logout()\n\n    def test_get_question_contribution_stats(self) -> None:\n        # Create and publish a topic.\n        published_topic_id = 'topic_id'\n        published_topic_name = 'published_topic_name'\n        self._publish_topic(published_topic_id, published_topic_name)\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.owner_id,\n            topic_id='topic_id',\n            submitted_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_without_reviewer_edits_count=0,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorstatssummaries/question/submission/%s' % (\n                self.OWNER_USERNAME))\n\n        self.assertEqual(\n            response, {\n                'question_contribution_stats': [\n                    {\n                        'topic_name': 'published_topic_name',\n                        'submitted_questions_count': 1,\n                        'accepted_questions_count': 1,\n                        'accepted_questions_without_reviewer_edits_count': 0,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ]\n            })\n\n        self.logout()\n\n    def test_get_question_review_stats(self) -> None:\n        # Create and publish a topic.\n        published_topic_id = 'topic_id'\n        published_topic_name = 'published_topic_name'\n        self._publish_topic(published_topic_id, published_topic_name)\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.owner_id,\n            topic_id='topic_id',\n            reviewed_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_with_reviewer_edits_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorstatssummaries/question/review/%s' % (\n                self.OWNER_USERNAME))\n\n        self.assertEqual(\n            response, {\n                'question_review_stats': [\n                    {\n                        'topic_name': 'published_topic_name',\n                        'reviewed_questions_count': 1,\n                        'accepted_questions_count': 1,\n                        'accepted_questions_with_reviewer_edits_count': 1,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ]\n            })\n\n        self.logout()\n\n    def test_get_stats_with_invalid_contribution_type_raises_error(\n        self\n    ) -> None:\n        self.login(self.OWNER_EMAIL)\n        response = self.get_json(\n            '/contributorstatssummaries/a/review/%s' % (\n                self.OWNER_USERNAME), expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'Invalid contribution type a.')\n\n        self.logout()\n\n    def test_get_stats_with_invalid_contribution_subtype_raises_error(\n        self\n    ) -> None:\n        self.login(self.OWNER_EMAIL)\n        response = self.get_json(\n            '/contributorstatssummaries/question/a/%s' % (\n                self.OWNER_USERNAME), expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'Invalid contribution subtype a.')\n\n        self.logout()\n\n    def test_get_stats_without_logging_in_error(self) -> None:\n        response = self.get_json(\n            '/contributorstatssummaries/question/a/abc',\n            expected_status_int=401)\n\n        self.assertEqual(\n            response['error'], 'You must be logged in to access this resource.')\n\n    def test_get_all_stats_of_other_users_raises_error(self) -> None:\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorstatssummaries/question/review/abc',\n            expected_status_int=401)\n\n        self.assertEqual(\n            response['error'],\n            'The user %s is not allowed to fetch the stats of other users.' % (\n                self.OWNER_USERNAME))\n\n        self.logout()\n\n\nclass ContributorAllStatsSummariesHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Test for the ContributorAllStatsSummariesHandler.\"\"\"\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.NEW_USER_EMAIL, self.NEW_USER_USERNAME)\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.new_user_id = self.get_user_id_from_email(self.NEW_USER_EMAIL)\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        published_topic_id = 'topic_id'\n        published_topic_name = 'published_topic_name'\n        self._publish_topic(published_topic_id, published_topic_name)\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id=self.owner_id,\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836)\n            ]\n        )\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code='es',\n            reviewer_user_id=self.owner_id,\n            topic_id='topic_id',\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=1,\n            accepted_translations_count=1,\n            accepted_translations_with_reviewer_edits_count=0,\n            accepted_translation_word_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.owner_id,\n            topic_id='topic_id',\n            submitted_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_without_reviewer_edits_count=0,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.owner_id,\n            topic_id='topic_id',\n            reviewed_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_with_reviewer_edits_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n\n    def _publish_topic(self, topic_id: str, topic_name: str) -> None:\n        \"\"\"Creates and publishes a topic.\n\n        Args:\n            topic_id: str. Topic ID.\n            topic_name: str. Topic name.\n        \"\"\"\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, topic_name, 'abbrev', 'description', 'fragm')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_3'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = ['skill_id_3']\n        topic_services.save_new_topic(self.admin_id, topic)\n        topic_services.publish_topic(topic_id, self.admin_id)\n\n    def test_stats_for_new_user_are_empty(self) -> None:\n        self.login(self.NEW_USER_EMAIL)\n        class MockStats:\n            translation_contribution_stats = None\n            translation_review_stats = None\n            question_contribution_stats = None\n            question_review_stats = None\n\n        swap_get_stats = self.swap_with_checks(\n            suggestion_services, 'get_all_contributor_stats',\n            lambda _: MockStats(), expected_args=((self.new_user_id,),))\n\n        with swap_get_stats:\n            response = self.get_json(\n                '/contributorallstatssummaries/%s' % self.NEW_USER_USERNAME)\n        self.assertEqual(response, {})\n\n    def test_raises_error_if_no_topic_id_associated_with_stats_object(\n        self\n    ) -> None:\n        self.login(self.OWNER_EMAIL)\n        user_id = user_services.get_user_id_from_username(self.OWNER_USERNAME)\n        assert user_id is not None\n        corrupt_stats = (\n            suggestion_services.get_all_translation_contribution_stats(\n                user_id\n            )\n        )\n        corrupt_stats[0].topic_id = None\n\n        swap_with_corrupt_data = self.swap_to_always_return(\n            suggestion_services,\n            'get_all_translation_contribution_stats',\n            corrupt_stats\n        )\n\n        with self.assertRaisesRegex(\n            Exception,\n            'No topic_id associated with stats: '\n            'TranslationContributionStats.'\n        ):\n            with swap_with_corrupt_data:\n                self.get_json(\n                    '/contributorallstatssummaries/%s' % self.OWNER_USERNAME)\n\n    def test_get_all_stats(self) -> None:\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorallstatssummaries/%s' % self.OWNER_USERNAME)\n\n        self.assertEqual(\n            response, {\n                'translation_contribution_stats': [\n                    {\n                        'language_code': 'es',\n                        'topic_name': 'published_topic_name',\n                        'submitted_translations_count': 2,\n                        'submitted_translation_word_count': 100,\n                        'accepted_translations_count': 1,\n                        'accepted_translations_without_reviewer_edits_count': (\n                            0),\n                        'accepted_translation_word_count': 50,\n                        'rejected_translations_count': 0,\n                        'rejected_translation_word_count': 0,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ],\n                'translation_review_stats': [\n                    {\n                        'language_code': 'es',\n                        'topic_name': 'published_topic_name',\n                        'reviewed_translations_count': 1,\n                        'reviewed_translation_word_count': 1,\n                        'accepted_translations_count': 1,\n                        'accepted_translations_with_reviewer_edits_count': 0,\n                        'accepted_translation_word_count': 1,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ],\n                'question_contribution_stats': [\n                    {\n                        'topic_name': 'published_topic_name',\n                        'submitted_questions_count': 1,\n                        'accepted_questions_count': 1,\n                        'accepted_questions_without_reviewer_edits_count': 0,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ],\n                'question_review_stats': [\n                    {\n                        'topic_name': 'published_topic_name',\n                        'reviewed_questions_count': 1,\n                        'accepted_questions_count': 1,\n                        'accepted_questions_with_reviewer_edits_count': 1,\n                        'first_contribution_date': 'Mar 2021',\n                        'last_contribution_date': 'Mar 2021'\n                    }\n                ]\n            })\n\n        self.logout()\n\n    def test_get_stats_without_logging_in_error(self) -> None:\n        response = self.get_json(\n            '/contributorallstatssummaries/abc',\n            expected_status_int=401)\n\n        self.assertEqual(\n            response['error'], 'You must be logged in to access this resource.')\n\n    def test_get_all_stats_of_other_users_raises_error(self) -> None:\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorallstatssummaries/abc', expected_status_int=401\n        )\n\n        self.assertEqual(\n            response['error'],\n            'The user %s is not allowed to fetch the stats of other users.' % (\n                self.OWNER_USERNAME))\n\n        self.logout()\n\n    def test_get_contributor_certificate(self) -> None:\n        score_category: str = (\n            suggestion_models.SCORE_TYPE_TRANSLATION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n        change_cmd = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.owner_id,\n            self.OWNER_USERNAME, change_cmd, score_category,\n            'exploration.exp1.thread_6', 'hi')\n        from_date = datetime.datetime.today() - datetime.timedelta(days=1)\n        from_date_str = from_date.strftime('%Y-%m-%d')\n        to_date = datetime.datetime.today()\n        to_date_str = to_date.strftime('%Y-%m-%d')\n\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorcertificate/%s/%s?language=%s&'\n            'from_date=%s&to_date=%s' % (\n                self.OWNER_USERNAME, feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi', from_date_str, to_date_str\n            )\n        )\n\n        self.assertEqual(\n            response,\n            {\n                'from_date': from_date.strftime('%d %b %Y'),\n                'to_date': to_date.strftime('%d %b %Y'),\n                'contribution_hours': '0.01',\n                'team_lead': feconf.TRANSLATION_TEAM_LEAD,\n                'language': 'Hindi'\n            }\n        )\n\n        self.logout()\n\n    def test_get_contributor_certificate_raises_invalid_date_exception(\n        self\n    ) -> None:\n        from_date = datetime.datetime.today() - datetime.timedelta(days=1)\n        from_date_str = from_date.strftime('%Y-%m-%d')\n        to_date = datetime.datetime.today() + datetime.timedelta(days=1)\n        to_date_str = to_date.strftime('%Y-%m-%d')\n\n        self.login(self.OWNER_EMAIL)\n\n        response = self.get_json(\n            '/contributorcertificate/%s/%s?language=%s&'\n            'from_date=%s&to_date=%s' % (\n                self.OWNER_USERNAME, feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi', from_date_str, to_date_str\n            ),\n            expected_status_int=400\n        )\n\n        self.assertEqual(\n            response['error'],\n            'To date should not be a future date.'\n        )\n\n        self.logout()\n"
    },
    {
      "filename": "core/domain/suggestion_registry.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Registry for Oppia suggestions. Contains a BaseSuggestion class and\nsubclasses for each type of suggestion.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport datetime\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import change_domain\nfrom core.domain import config_domain\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import fs_services\nfrom core.domain import html_cleaner\nfrom core.domain import question_domain\nfrom core.domain import question_services\nfrom core.domain import skill_domain\nfrom core.domain import skill_fetchers\nfrom core.domain import state_domain\nfrom core.domain import user_services\nfrom core.platform import models\nfrom extensions import domain\n\nfrom typing import (\n    Any, Callable, Dict, List, Mapping, Optional, Set, Type, TypedDict, Union,\n    cast\n)\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from mypy_imports import suggestion_models\n\n(suggestion_models,) = models.Registry.import_models([models.Names.SUGGESTION])\n\n\nclass BaseSuggestionDict(TypedDict):\n    \"\"\"Dictionary representing the BaseSuggestion object.\"\"\"\n\n    suggestion_id: str\n    suggestion_type: str\n    target_type: str\n    target_id: str\n    target_version_at_submission: int\n    status: str\n    author_name: str\n    final_reviewer_id: Optional[str]\n    change: Dict[str, change_domain.AcceptableChangeDictTypes]\n    score_category: str\n    language_code: str\n    last_updated: float\n    edited_by_reviewer: bool\n\n\nclass BaseSuggestion:\n    \"\"\"Base class for a suggestion.\n\n    Attributes:\n        suggestion_id: str. The ID of the suggestion.\n        suggestion_type: str. The type of the suggestion.\n        target_type: str. The type of target entity being edited.\n        target_id: str. The ID of the target entity being edited.\n        target_version_at_submission: int. The version number of the target\n            entity at the time of creation of the suggestion.\n        status: str. The status of the suggestion.\n        author_id: str. The ID of the user who submitted the suggestion.\n        final_reviewer_id: str. The ID of the reviewer who has accepted/rejected\n            the suggestion.\n        change: Change. The details of the suggestion. This should be an\n            object of type ExplorationChange, TopicChange, etc.\n        score_category: str. The scoring category for the suggestion.\n        last_updated: datetime.datetime. Date and time when the suggestion\n            was last updated.\n        language_code: str|None. The ISO 639-1 code used to query suggestions\n            by language, or None if the suggestion type is not queryable by\n            language.\n        edited_by_reviewer: bool. Whether the suggestion is edited by the\n            reviewer.\n    \"\"\"\n\n    # Here, we explicitly defined all the attributes that are used in\n    # BaseSuggestion because in `to_dict`, `get_score_type` and other\n    # methods too we are accessing these attributes but due to the lack\n    # of definition in main implementation the types of these attributes\n    # are not available which causes MyPy to throw undefined attribute\n    # error for all attributes that are used in BaseSuggestion. Thus to\n    # provide type-info to MyPy about these attributes, we defined them\n    # as class variables.\n    suggestion_id: str\n    suggestion_type: str\n    target_type: str\n    target_id: str\n    target_version_at_submission: int\n    author_id: str\n    change: change_domain.BaseChange\n    score_category: str\n    last_updated: datetime.datetime\n    language_code: str\n    edited_by_reviewer: bool\n    image_context: str\n\n    def __init__(self, status: str, final_reviewer_id: Optional[str]) -> None:\n        \"\"\"Initializes a Suggestion object.\"\"\"\n        self.status = status\n        self.final_reviewer_id = final_reviewer_id\n\n    def to_dict(self) -> BaseSuggestionDict:\n        \"\"\"Returns a dict representation of a suggestion object.\n\n        Returns:\n            dict. A dict representation of a suggestion object.\n        \"\"\"\n        return {\n            'suggestion_id': self.suggestion_id,\n            'suggestion_type': self.suggestion_type,\n            'target_type': self.target_type,\n            'target_id': self.target_id,\n            'target_version_at_submission': self.target_version_at_submission,\n            'status': self.status,\n            'author_name': self.get_author_name(),\n            'final_reviewer_id': self.final_reviewer_id,\n            'change': self.change.to_dict(),\n            'score_category': self.score_category,\n            'language_code': self.language_code,\n            'last_updated': utils.get_time_in_millisecs(self.last_updated),\n            'edited_by_reviewer': self.edited_by_reviewer\n        }\n\n    def get_score_type(self) -> str:\n        \"\"\"Returns the first part of the score category. The first part refers\n        to the the type of scoring. The value of this part will be among\n        suggestion_models.SCORE_TYPE_CHOICES.\n\n        Returns:\n            str. The first part of the score category.\n        \"\"\"\n        return self.score_category.split(\n            suggestion_models.SCORE_CATEGORY_DELIMITER)[0]\n\n    def get_author_name(self) -> str:\n        \"\"\"Returns the author's username.\n\n        Returns:\n            str. The username of the author of the suggestion.\n        \"\"\"\n        return user_services.get_username(self.author_id)\n\n    def get_score_sub_type(self) -> str:\n        \"\"\"Returns the second part of the score category. The second part refers\n        to the specific area where the author needs to be scored. This can be\n        the category of the exploration, the language of the suggestion, or the\n        skill linked to the question.\n\n        Returns:\n            str. The second part of the score category.\n        \"\"\"\n        return self.score_category.split(\n            suggestion_models.SCORE_CATEGORY_DELIMITER)[1]\n\n    def set_suggestion_status_to_accepted(self) -> None:\n        \"\"\"Sets the status of the suggestion to accepted.\"\"\"\n        self.status = suggestion_models.STATUS_ACCEPTED\n\n    def set_suggestion_status_to_in_review(self) -> None:\n        \"\"\"Sets the status of the suggestion to in review.\"\"\"\n        self.status = suggestion_models.STATUS_IN_REVIEW\n\n    def set_suggestion_status_to_rejected(self) -> None:\n        \"\"\"Sets the status of the suggestion to rejected.\"\"\"\n        self.status = suggestion_models.STATUS_REJECTED\n\n    def set_final_reviewer_id(self, reviewer_id: str) -> None:\n        \"\"\"Sets the final reviewer id of the suggestion to be reviewer_id.\n\n        Args:\n            reviewer_id: str. The ID of the user who completed the review.\n        \"\"\"\n        self.final_reviewer_id = reviewer_id\n\n    def validate(self) -> None:\n        \"\"\"Validates the BaseSuggestion object. Each subclass must implement\n        this function.\n\n        The subclasses must validate the change and score_category fields.\n\n        Raises:\n            ValidationError. One or more attributes of the BaseSuggestion object\n                are invalid.\n        \"\"\"\n        if (\n                self.suggestion_type not in\n                feconf.SUGGESTION_TYPE_CHOICES):\n            raise utils.ValidationError(\n                'Expected suggestion_type to be among allowed choices, '\n                'received %s' % self.suggestion_type)\n\n        if self.target_type not in feconf.SUGGESTION_TARGET_TYPE_CHOICES:\n            raise utils.ValidationError(\n                'Expected target_type to be among allowed choices, '\n                'received %s' % self.target_type)\n\n        if not isinstance(self.target_id, str):\n            raise utils.ValidationError(\n                'Expected target_id to be a string, received %s' % type(\n                    self.target_id))\n\n        if not isinstance(self.target_version_at_submission, int):\n            raise utils.ValidationError(\n                'Expected target_version_at_submission to be an int, '\n                'received %s' % type(self.target_version_at_submission))\n\n        if self.status not in suggestion_models.STATUS_CHOICES:\n            raise utils.ValidationError(\n                'Expected status to be among allowed choices, '\n                'received %s' % self.status)\n\n        if not isinstance(self.author_id, str):\n            raise utils.ValidationError(\n                'Expected author_id to be a string, received %s' % type(\n                    self.author_id))\n\n        if not utils.is_user_id_valid(\n                self.author_id, allow_pseudonymous_id=True):\n            raise utils.ValidationError(\n                'Expected author_id to be in a valid user ID format, '\n                'received %s' % self.author_id)\n\n        if self.final_reviewer_id is not None:\n            if not isinstance(self.final_reviewer_id, str):\n                raise utils.ValidationError(\n                    'Expected final_reviewer_id to be a string, received %s' %\n                    type(self.final_reviewer_id))\n            if not utils.is_user_id_valid(\n                    self.final_reviewer_id,\n                    allow_system_user_id=True,\n                    allow_pseudonymous_id=True\n            ):\n                raise utils.ValidationError(\n                    'Expected final_reviewer_id to be in a valid user ID '\n                    'format, received %s' % self.final_reviewer_id)\n\n        if not isinstance(self.score_category, str):\n            raise utils.ValidationError(\n                'Expected score_category to be a string, received %s' % type(\n                    self.score_category))\n\n        if (\n                suggestion_models.SCORE_CATEGORY_DELIMITER not in\n                self.score_category):\n            raise utils.ValidationError(\n                'Expected score_category to be of the form'\n                ' score_type%sscore_sub_type, received %s' % (\n                    suggestion_models.SCORE_CATEGORY_DELIMITER,\n                    self.score_category))\n\n        if (\n                len(self.score_category.split(\n                    suggestion_models.SCORE_CATEGORY_DELIMITER))) != 2:\n            raise utils.ValidationError(\n                'Expected score_category to be of the form'\n                ' score_type%sscore_sub_type, received %s' % (\n                    suggestion_models.SCORE_CATEGORY_DELIMITER,\n                    self.score_category))\n\n        if self.get_score_type() not in suggestion_models.SCORE_TYPE_CHOICES:\n            raise utils.ValidationError(\n                'Expected the first part of score_category to be among allowed'\n                ' choices, received %s' % self.get_score_type())\n\n    def accept(self, commit_msg: str) -> None:\n        \"\"\"Accepts the suggestion. Each subclass must implement this\n        function.\n        \"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement accept.')\n\n    def pre_accept_validate(self) -> None:\n        \"\"\"Performs referential validation. This function needs to be called\n        before accepting the suggestion.\n        \"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'pre_accept_validate.')\n\n    def populate_old_value_of_change(self) -> None:\n        \"\"\"Populates the old_value field of the change.\"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'populate_old_value_of_change.')\n\n    # TODO(#16047): Here we use type Any because the method pre_update_validate\n    # is used inside sub-classes with different argument types, which according\n    # to MyPy violates the 'Liskov substitution principle' and throws an error\n    # in every sub-class where this pre_update_validate method is used. So, to\n    # avoid the error in every sub-class, we have used Any type here but once\n    # this BaseSuggestion class is refactored, we can remove type Any from here.\n    def pre_update_validate(self, change: Any) -> None:\n        \"\"\"Performs the pre update validation. This function needs to be called\n        before updating the suggestion.\n        \"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'pre_update_validate.')\n\n    def get_all_html_content_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings used in this suggestion.\"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'get_all_html_content_strings.')\n\n    def get_target_entity_html_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings from target entity used in the\n        suggestion.\n        \"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'get_target_entity_html_strings.')\n\n    def get_new_image_filenames_added_in_suggestion(self) -> List[str]:\n        \"\"\"Returns the list of newly added image filenames in the suggestion.\n\n        Returns:\n            list(str). A list of newly added image filenames in the suggestion.\n        \"\"\"\n        html_list = self.get_all_html_content_strings()\n        all_image_filenames = (\n            html_cleaner.get_image_filenames_from_html_strings(html_list))\n\n        target_entity_html_list = self.get_target_entity_html_strings()\n        target_image_filenames = (\n            html_cleaner.get_image_filenames_from_html_strings(\n                target_entity_html_list))\n\n        new_image_filenames = utils.compute_list_difference(\n            all_image_filenames, target_image_filenames)\n\n        return new_image_filenames\n\n    def _copy_new_images_to_target_entity_storage(self) -> None:\n        \"\"\"Copy newly added images in suggestion to the target entity\n        storage.\n        \"\"\"\n        new_image_filenames = self.get_new_image_filenames_added_in_suggestion()\n        fs_services.copy_images(\n            self.image_context, self.target_id, self.target_type,\n            self.target_id, new_image_filenames)\n\n    def convert_html_in_suggestion_change(\n        self, conversion_fn: Callable[[str], str]\n    ) -> None:\n        \"\"\"Checks for HTML fields in a suggestion change and converts it\n        according to the conversion function.\n        \"\"\"\n        raise NotImplementedError(\n            'Subclasses of BaseSuggestion should implement '\n            'convert_html_in_suggestion_change.')\n\n    @property\n    def is_handled(self) -> bool:\n        \"\"\"Returns if the suggestion has either been accepted or rejected.\n\n        Returns:\n            bool. Whether the suggestion has been handled or not.\n        \"\"\"\n        return self.status != suggestion_models.STATUS_IN_REVIEW\n\n\nclass SuggestionEditStateContent(BaseSuggestion):\n    \"\"\"Domain object for a suggestion of type\n    SUGGESTION_TYPE_EDIT_STATE_CONTENT.\n    \"\"\"\n\n    def __init__(\n        self,\n        suggestion_id: str,\n        target_id: str,\n        target_version_at_submission: int,\n        status: str,\n        author_id: str,\n        final_reviewer_id: Optional[str],\n        change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n        score_category: str,\n        language_code: Optional[str],\n        edited_by_reviewer: bool,\n        last_updated: Optional[datetime.datetime] = None\n    ) -> None:\n        \"\"\"Initializes an object of type SuggestionEditStateContent\n        corresponding to the SUGGESTION_TYPE_EDIT_STATE_CONTENT choice.\n        \"\"\"\n        super().__init__(\n            status, final_reviewer_id)\n        self.suggestion_id = suggestion_id\n        self.suggestion_type = (\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.target_type = feconf.ENTITY_TYPE_EXPLORATION\n        self.target_id = target_id\n        self.target_version_at_submission = target_version_at_submission\n        self.author_id = author_id\n        self.change: exp_domain.EditExpStatePropertyContentCmd = (\n            exp_domain.EditExpStatePropertyContentCmd(change)\n        )\n        self.score_category = score_category\n        # Here we use MyPy ignore because in BaseSuggestion, language_code\n        # is defined with only string type but here language_code is of\n        # Optional[str] type because language_code can accept None values as\n        # well. So, due to this conflict in types MyPy throws an `Incompatible\n        # types in assignment` error. Thus to avoid the error, we used ignore.\n        self.language_code = language_code  # type: ignore[assignment]\n        # TODO(#16048): Here we use MyPy ignore because in BaseSuggestion,\n        # last_updated is defined with only datetime type but here\n        # last_updated is of Optional[datetime] type because while creating\n        # 'SuggestionEditStateContent' through create_suggestion() method, we\n        # are not providing 'last_updated' and just using None default value.\n        # So, once this suggestion_services.create_suggestion() method is\n        # fixed, we can remove both todo and MyPy ignore from here.\n        self.last_updated = last_updated  # type: ignore[assignment]\n        self.edited_by_reviewer = edited_by_reviewer\n        # Here we use MyPy ignore because in BaseSuggestion, image_context\n        # is defined as string type attribute but currently, we don't\n        # allow adding images in the \"edit state content\" suggestion,\n        # so the image_context is None here and due to None MyPy throws\n        # an `Incompatible types in assignment` error. Thus to avoid the\n        # error, we used ignore here.\n        self.image_context = None  # type: ignore[assignment]\n\n    def validate(self) -> None:\n        \"\"\"Validates a suggestion object of type SuggestionEditStateContent.\n\n        Raises:\n            ValidationError. One or more attributes of the\n                SuggestionEditStateContent object are invalid.\n        \"\"\"\n        super().validate()\n\n        if not isinstance(self.change, exp_domain.ExplorationChange):\n            raise utils.ValidationError(\n                'Expected change to be an ExplorationChange, received %s'\n                % type(self.change))\n\n        if self.get_score_type() != suggestion_models.SCORE_TYPE_CONTENT:\n            raise utils.ValidationError(\n                'Expected the first part of score_category to be %s '\n                ', received %s' % (\n                    suggestion_models.SCORE_TYPE_CONTENT,\n                    self.get_score_type()))\n\n        if self.change.cmd != exp_domain.CMD_EDIT_STATE_PROPERTY:\n            raise utils.ValidationError(\n                'Expected cmd to be %s, received %s' % (\n                    exp_domain.CMD_EDIT_STATE_PROPERTY, self.change.cmd))\n\n        if (self.change.property_name !=\n                exp_domain.STATE_PROPERTY_CONTENT):\n            raise utils.ValidationError(\n                'Expected property_name to be %s, received %s' % (\n                    exp_domain.STATE_PROPERTY_CONTENT,\n                    self.change.property_name))\n\n        # Suggestions of this type do not have an associated language code,\n        # since they are not translation-related.\n        if self.language_code is not None:\n            raise utils.ValidationError(\n                'Expected language_code to be None, received %s' % (\n                    self.language_code))\n\n    def pre_accept_validate(self) -> None:\n        \"\"\"Performs referential validation. This function needs to be called\n        before accepting the suggestion.\n        \"\"\"\n        self.validate()\n        states = exp_fetchers.get_exploration_by_id(self.target_id).states\n        if self.change.state_name not in states:\n            raise utils.ValidationError(\n                'Expected %s to be a valid state name' %\n                self.change.state_name)\n\n    def _get_change_list_for_accepting_edit_state_content_suggestion(\n        self\n    ) -> List[exp_domain.ExplorationChange]:\n        \"\"\"Gets a complete change for the SuggestionEditStateContent.\n\n        Returns:\n            list(ExplorationChange). The change_list corresponding to the\n            suggestion.\n        \"\"\"\n        change = self.change\n        exploration = exp_fetchers.get_exploration_by_id(self.target_id)\n        old_content = (\n            exploration.states[self.change.state_name].content.to_dict())\n\n        change.old_value = old_content\n        change.new_value['content_id'] = old_content['content_id']\n\n        return [change]\n\n    def populate_old_value_of_change(self) -> None:\n        \"\"\"Populates old value of the change.\"\"\"\n        exploration = exp_fetchers.get_exploration_by_id(self.target_id)\n        if self.change.state_name not in exploration.states:\n            # As the state doesn't exist now, we cannot find the content of the\n            # state to populate the old_value field. So we set it as None.\n            old_content = None\n        else:\n            old_content = (\n                exploration.states[self.change.state_name].content.to_dict())\n\n        self.change.old_value = old_content\n\n    def accept(self, commit_message: str) -> None:\n        \"\"\"Accepts the suggestion.\n\n        Args:\n            commit_message: str. The commit message.\n        \"\"\"\n        change_list = (\n            self._get_change_list_for_accepting_edit_state_content_suggestion()\n        )\n        # Before calling this accept method we are already checking if user\n        # with 'final_reviewer_id' exists or not.\n        assert self.final_reviewer_id is not None\n        exp_services.update_exploration(\n            self.final_reviewer_id, self.target_id, change_list,\n            commit_message, is_suggestion=True)\n\n    def pre_update_validate(\n        self, change: exp_domain.EditExpStatePropertyContentCmd\n    ) -> None:\n        \"\"\"Performs the pre update validation. This function needs to be called\n        before updating the suggestion.\n\n        Args:\n            change: ExplorationChange. The new change.\n\n        Raises:\n            ValidationError. Invalid new change.\n        \"\"\"\n        if self.change.cmd != change.cmd:\n            raise utils.ValidationError(\n                'The new change cmd must be equal to %s' %\n                self.change.cmd)\n        if self.change.property_name != change.property_name:\n            raise utils.ValidationError(\n                'The new change property_name must be equal to %s' %\n                self.change.property_name)\n        if self.change.state_name != change.state_name:\n            raise utils.ValidationError(\n                'The new change state_name must be equal to %s' %\n                self.change.state_name)\n        if self.change.new_value['html'] == change.new_value['html']:\n            raise utils.ValidationError(\n                'The new html must not match the old html')\n\n    def get_all_html_content_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings used in this suggestion.\n\n        Returns:\n            list(str). The list of html content strings.\n        \"\"\"\n        html_string_list = [self.change.new_value['html']]\n        if self.change.old_value is not None:\n            html_string_list.append(self.change.old_value['html'])\n        return html_string_list\n\n    def get_target_entity_html_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings from target entity used in the\n        suggestion.\n\n        Returns:\n            list(str). The list of html content strings from target entity used\n            in the suggestion.\n        \"\"\"\n        if self.change.old_value is not None:\n            return [self.change.old_value['html']]\n\n        return []\n\n    def convert_html_in_suggestion_change(\n        self, conversion_fn: Callable[[str], str]\n    ) -> None:\n        \"\"\"Checks for HTML fields in a suggestion change and converts it\n        according to the conversion function.\n\n        Args:\n            conversion_fn: function. The function to be used for converting the\n                HTML.\n        \"\"\"\n        if self.change.old_value is not None:\n            self.change.old_value['html'] = (\n                conversion_fn(self.change.old_value['html']))\n        self.change.new_value['html'] = (\n            conversion_fn(self.change.new_value['html']))\n\n\nclass SuggestionTranslateContent(BaseSuggestion):\n    \"\"\"Domain object for a suggestion of type\n    SUGGESTION_TYPE_TRANSLATE_CONTENT.\n    \"\"\"\n\n    def __init__(\n        self,\n        suggestion_id: str,\n        target_id: str,\n        target_version_at_submission: int,\n        status: str,\n        author_id: str,\n        final_reviewer_id: Optional[str],\n        change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n        score_category: str,\n        language_code: str,\n        edited_by_reviewer: bool,\n        last_updated: Optional[datetime.datetime] = None\n    ) -> None:\n        \"\"\"Initializes an object of type SuggestionTranslateContent\n        corresponding to the SUGGESTION_TYPE_TRANSLATE_CONTENT choice.\n        \"\"\"\n        super().__init__(\n            status, final_reviewer_id)\n        self.suggestion_id = suggestion_id\n        self.suggestion_type = (\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.target_type = feconf.ENTITY_TYPE_EXPLORATION\n        self.target_id = target_id\n        self.target_version_at_submission = target_version_at_submission\n        self.author_id = author_id\n        self.change: exp_domain.AddWrittenTranslationCmd = (\n            exp_domain.AddWrittenTranslationCmd(change)\n        )\n        self.score_category = score_category\n        self.language_code = language_code\n        # TODO(#16048): Here we use MyPy ignore because in BaseSuggestion,\n        # last_updated is defined with only datetime type but here\n        # last_updated is of Optional[datetime] type because while creating\n        # 'SuggestionTranslateContent' through create_suggestion() method, we\n        # are not providing 'last_updated' and just using None default value.\n        # So, once this suggestion_services.create_suggestion() method is\n        # fixed, we can remove both todo and MyPy ignore from here.\n        self.last_updated = last_updated  # type: ignore[assignment]\n        self.edited_by_reviewer = edited_by_reviewer\n        self.image_context = feconf.IMAGE_CONTEXT_EXPLORATION_SUGGESTIONS\n\n    def validate(self) -> None:\n        \"\"\"Validates a suggestion object of type SuggestionTranslateContent.\n\n        Raises:\n            ValidationError. One or more attributes of the\n                SuggestionTranslateContent object are invalid.\n        \"\"\"\n        super().validate()\n\n        if not isinstance(self.change, exp_domain.ExplorationChange):\n            raise utils.ValidationError(\n                'Expected change to be an ExplorationChange, received %s'\n                % type(self.change))\n        # The score sub_type needs to match the validation for exploration\n        # category, i.e the second part of the score_category should match\n        # the target exploration's category and we have a prod validation\n        # for the same.\n        if self.get_score_type() != suggestion_models.SCORE_TYPE_TRANSLATION:\n            raise utils.ValidationError(\n                'Expected the first part of score_category to be %s '\n                ', received %s' % (\n                    suggestion_models.SCORE_TYPE_TRANSLATION,\n                    self.get_score_type()))\n\n        # TODO(#12981): Write a one-off job to modify all existing translation\n        # suggestions that use DEPRECATED_CMD_ADD_TRANSLATION to use\n        # CMD_ADD_WRITTEN_TRANSLATION instead. Suggestions in the future will\n        # only use CMD_ADD_WRITTEN_TRANSLATION. DEPRECATED_CMD_ADD_TRANSLATION\n        # is added in the following check to support older suggestions.\n        accepted_cmds = [\n            exp_domain.DEPRECATED_CMD_ADD_TRANSLATION,\n            exp_domain.CMD_ADD_WRITTEN_TRANSLATION\n        ]\n        if self.change.cmd not in accepted_cmds:\n            raise utils.ValidationError(\n                'Expected cmd to be %s, received %s' % (\n                    exp_domain.CMD_ADD_WRITTEN_TRANSLATION, self.change.cmd))\n\n        if not utils.is_supported_audio_language_code(\n                self.change.language_code):\n            raise utils.ValidationError(\n                'Invalid language_code: %s' % self.change.language_code)\n\n        if isinstance(self.change.translation_html, str):\n            html_cleaner.validate_rte_tags(self.change.translation_html)\n\n        if self.language_code is None:\n            raise utils.ValidationError('language_code cannot be None')\n\n        if self.language_code != self.change.language_code:\n            raise utils.ValidationError(\n                'Expected language_code to be %s, received %s' % (\n                    self.change.language_code, self.language_code))\n\n    def pre_update_validate(self, change: exp_domain.ExplorationChange) -> None:\n        \"\"\"Performs the pre update validation. This function needs to be called\n        before updating the suggestion.\n\n        Args:\n            change: ExplorationChange. The new change.\n\n        Raises:\n            ValidationError. Invalid new change.\n        \"\"\"\n        if self.change.cmd != change.cmd:\n            raise utils.ValidationError(\n                'The new change cmd must be equal to %s' %\n                self.change.cmd)\n        if self.change.state_name != change.state_name:\n            raise utils.ValidationError(\n                'The new change state_name must be equal to %s' %\n                self.change.state_name)\n        if self.change.content_html != change.content_html:\n            raise utils.ValidationError(\n                'The new change content_html must be equal to %s' %\n                self.change.content_html)\n        if self.change.language_code != change.language_code:\n            raise utils.ValidationError(\n                'The language code must be equal to %s' %\n                self.change.language_code)\n\n    def pre_accept_validate(self) -> None:\n        \"\"\"Performs referential validation. This function needs to be called\n        before accepting the suggestion.\n        \"\"\"\n        self.validate()\n        exploration = exp_fetchers.get_exploration_by_id(self.target_id)\n        if self.change.state_name not in exploration.states:\n            raise utils.ValidationError(\n                'Expected %s to be a valid state name' % self.change.state_name)\n\n    def accept(self, commit_message: str) -> None:\n        \"\"\"Accepts the suggestion.\n\n        Args:\n            commit_message: str. The commit message.\n        \"\"\"\n        # If the translation is for a set of strings, we don't want to process\n        # the HTML strings for images.\n        # Before calling this accept method we are already checking if user\n        # with 'final_reviewer_id' exists or not.\n        assert self.final_reviewer_id is not None\n        if (\n                hasattr(self.change, 'data_format') and\n                state_domain.WrittenTranslation.is_data_format_list(\n                    self.change.data_format)\n        ):\n            exp_services.update_exploration(\n                self.final_reviewer_id, self.target_id, [self.change],\n                commit_message, is_suggestion=True)\n            return\n\n        self._copy_new_images_to_target_entity_storage()\n        exp_services.update_exploration(\n            self.final_reviewer_id, self.target_id, [self.change],\n            commit_message, is_suggestion=True)\n\n    def get_all_html_content_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings used in this suggestion.\n\n        Returns:\n            list(str). The list of html content strings.\n        \"\"\"\n        content_strings = []\n        if isinstance(self.change.translation_html, list):\n            content_strings.extend(self.change.translation_html)\n        else:\n            content_strings.append(self.change.translation_html)\n        if isinstance(self.change.content_html, list):\n            content_strings.extend(self.change.content_html)\n        else:\n            content_strings.append(self.change.content_html)\n        return content_strings\n\n    def get_target_entity_html_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings from target entity used in the\n        suggestion.\n\n        Returns:\n            list(str). The list of html content strings from target entity used\n            in the suggestion.\n        \"\"\"\n        return [self.change.content_html]\n\n    def convert_html_in_suggestion_change(\n        self, conversion_fn: Callable[[str], str]\n    ) -> None:\n        \"\"\"Checks for HTML fields in a suggestion change and converts it\n        according to the conversion function.\n\n        Args:\n            conversion_fn: function. The function to be used for converting the\n                HTML.\n        \"\"\"\n        self.change.content_html = (\n            conversion_fn(self.change.content_html))\n        self.change.translation_html = (\n            conversion_fn(self.change.translation_html))\n\n\nclass SuggestionAddQuestion(BaseSuggestion):\n    \"\"\"Domain object for a suggestion of type SUGGESTION_TYPE_ADD_QUESTION.\n\n    Attributes:\n        suggestion_id: str. The ID of the suggestion.\n        suggestion_type: str. The type of the suggestion.\n        target_type: str. The type of target entity being edited, for this\n            subclass, target type is 'skill'.\n        target_id: str. The ID of the skill the question was submitted to.\n        target_version_at_submission: int. The version number of the target\n            topic at the time of creation of the suggestion.\n        status: str. The status of the suggestion.\n        author_id: str. The ID of the user who submitted the suggestion.\n        final_reviewer_id: str. The ID of the reviewer who has accepted/rejected\n            the suggestion.\n        change_cmd: QuestionChange. The change associated with the suggestion.\n        score_category: str. The scoring category for the suggestion.\n        last_updated: datetime.datetime. Date and time when the suggestion\n            was last updated.\n        language_code: str. The ISO 639-1 code used to query suggestions\n            by language. In this case it is the language code of the question.\n        edited_by_reviewer: bool. Whether the suggestion is edited by the\n            reviewer.\n    \"\"\"\n\n    def __init__(\n        self,\n        suggestion_id: str,\n        target_id: str,\n        target_version_at_submission: int,\n        status: str,\n        author_id: str,\n        final_reviewer_id: Optional[str],\n        change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n        score_category: str,\n        language_code: str,\n        edited_by_reviewer: bool,\n        last_updated: Optional[datetime.datetime] = None\n    ) -> None:\n        \"\"\"Initializes an object of type SuggestionAddQuestion\n        corresponding to the SUGGESTION_TYPE_ADD_QUESTION choice.\n        \"\"\"\n        super().__init__(status, final_reviewer_id)\n        self.suggestion_id = suggestion_id\n        self.suggestion_type = feconf.SUGGESTION_TYPE_ADD_QUESTION\n        self.target_type = feconf.ENTITY_TYPE_SKILL\n        self.target_id = target_id\n        self.target_version_at_submission = target_version_at_submission\n        self.author_id = author_id\n        self.change: question_domain.CreateNewFullySpecifiedQuestionSuggestionCmd = (  # pylint: disable=line-too-long\n            question_domain.CreateNewFullySpecifiedQuestionSuggestionCmd(change)\n        )\n        self.score_category = score_category\n        self.language_code = language_code\n        # TODO(#16048): Here we use MyPy ignore because in BaseSuggestion,\n        # last_updated is defined with only datetime type but here\n        # last_updated is of Optional[datetime] type because while creating\n        # 'SuggestionAddQuestion' through create_suggestion() method, we\n        # are not providing 'last_updated' and just using None default value.\n        # So, once this suggestion_services.create_suggestion() method is\n        # fixed, we can remove both todo and MyPy ignore from here.\n        self.last_updated = last_updated  # type: ignore[assignment]\n        self.image_context = feconf.IMAGE_CONTEXT_QUESTION_SUGGESTIONS\n        self._update_change_to_latest_state_schema_version()\n        self.edited_by_reviewer = edited_by_reviewer\n\n    def _update_change_to_latest_state_schema_version(self) -> None:\n        \"\"\"Holds the responsibility of performing a step-by-step, sequential\n        update of the state structure inside the change_cmd based on the schema\n        version of the current state dictionary.\n\n        Raises:\n            Exception. The state_schema_version of suggestion cannot be\n                processed.\n        \"\"\"\n        question_dict: question_domain.QuestionDict = self.change.question_dict\n\n        state_schema_version = question_dict[\n            'question_state_data_schema_version']\n\n        versioned_question_state: question_domain.VersionedQuestionStateDict = {\n            'state_schema_version': state_schema_version,\n            'state': copy.deepcopy(\n                question_dict['question_state_data'])\n        }\n\n        if not (25 <= state_schema_version\n                <= feconf.CURRENT_STATE_SCHEMA_VERSION):\n            raise utils.ValidationError(\n                'Expected state schema version to be in between 25 and %d, '\n                'received %s.' % (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION, state_schema_version))\n\n        while state_schema_version < feconf.CURRENT_STATE_SCHEMA_VERSION:\n            question_domain.Question.update_state_from_model(\n                versioned_question_state, state_schema_version)\n            state_schema_version += 1\n\n        self.change.question_dict['question_state_data'] = (\n            versioned_question_state['state'])\n        self.change.question_dict['question_state_data_schema_version'] = (\n            state_schema_version)\n\n    def validate(self) -> None:\n        \"\"\"Validates a suggestion object of type SuggestionAddQuestion.\n\n        Raises:\n            ValidationError. One or more attributes of the SuggestionAddQuestion\n                object are invalid.\n        \"\"\"\n        super().validate()\n\n        if self.get_score_type() != suggestion_models.SCORE_TYPE_QUESTION:\n            raise utils.ValidationError(\n                'Expected the first part of score_category to be \"%s\" '\n                ', received \"%s\"' % (\n                    suggestion_models.SCORE_TYPE_QUESTION,\n                    self.get_score_type()))\n        if not isinstance(\n                self.change, question_domain.QuestionSuggestionChange):\n            raise utils.ValidationError(\n                'Expected change to be an instance of QuestionSuggestionChange')\n\n        if not self.change.cmd:\n            raise utils.ValidationError('Expected change to contain cmd')\n\n        if (\n                self.change.cmd !=\n                question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION):\n            raise utils.ValidationError('Expected cmd to be %s, obtained %s' % (\n                question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n                self.change.cmd))\n\n        if not self.change.question_dict:\n            raise utils.ValidationError(\n                'Expected change to contain question_dict')\n\n        question_dict: question_domain.QuestionDict = self.change.question_dict\n\n        if self.language_code != constants.DEFAULT_LANGUAGE_CODE:\n            raise utils.ValidationError(\n                'Expected language_code to be %s, received %s' % (\n                    constants.DEFAULT_LANGUAGE_CODE, self.language_code))\n\n        if self.language_code != question_dict['language_code']:\n            raise utils.ValidationError(\n                'Expected question language_code(%s) to be same as suggestion '\n                'language_code(%s)' % (\n                    question_dict['language_code'],\n                    self.language_code))\n\n        if not self.change.skill_difficulty:\n            raise utils.ValidationError(\n                'Expected change to contain skill_difficulty')\n\n        skill_difficulties = list(\n            constants.SKILL_DIFFICULTY_LABEL_TO_FLOAT.values())\n        if self._get_skill_difficulty() not in skill_difficulties:\n            raise utils.ValidationError(\n                'Expected change skill_difficulty to be one of %s, found %s '\n                % (skill_difficulties, self._get_skill_difficulty()))\n\n        # Here we use MyPy ignore because here we are building Question\n        # domain object only for validation purpose, so 'question_id' is\n        # provided as None which causes MyPy to throw 'invalid argument\n        # type' error. Thus, to avoid the error, we used ignore here.\n        question = question_domain.Question(\n            None,  # type: ignore[arg-type]\n            state_domain.State.from_dict(\n                question_dict['question_state_data']\n            ),\n            question_dict['question_state_data_schema_version'],\n            question_dict['language_code'],\n            # Here we use MyPy ignore because here we are building Question\n            # domain object only for validation purpose, so 'version' is\n            # provided as None which causes MyPy to throw 'invalid argument\n            # type' error. Thus, to avoid the error, we use ignore here.\n            None,  # type: ignore[arg-type]\n            question_dict['linked_skill_ids'],\n            question_dict['inapplicable_skill_misconception_ids'])\n        question_state_data_schema_version = (\n            question_dict['question_state_data_schema_version'])\n        if question_state_data_schema_version != (\n                feconf.CURRENT_STATE_SCHEMA_VERSION):\n            raise utils.ValidationError(\n                'Expected question state schema version to be %s, received '\n                '%s' % (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION,\n                    question_state_data_schema_version))\n        question.partial_validate()\n\n    def pre_accept_validate(self) -> None:\n        \"\"\"Performs referential validation. This function needs to be called\n        before accepting the suggestion.\n        \"\"\"\n        if self.change.skill_id is None:\n            raise utils.ValidationError('Expected change to contain skill_id')\n        self.validate()\n\n        skill_domain.Skill.require_valid_skill_id(self.change.skill_id)\n        skill = skill_fetchers.get_skill_by_id(\n            self.change.skill_id, strict=False)\n        if skill is None:\n            raise utils.ValidationError(\n                'The skill with the given id doesn\\'t exist.')\n\n    def accept(self, unused_commit_message: str) -> None:\n        \"\"\"Accepts the suggestion.\n\n        Args:\n            unused_commit_message: str. This parameter is passed in for\n                consistency with the existing suggestions. As a default commit\n                message is used in the add_question function, the arg is unused.\n        \"\"\"\n        question_dict: question_domain.QuestionDict = self.change.question_dict\n        question_dict['version'] = 1\n        question_dict['id'] = (\n            question_services.get_new_question_id())\n        question_dict['linked_skill_ids'] = [self.change.skill_id]\n        question = question_domain.Question.from_dict(question_dict)\n        question.validate()\n\n        # Images need to be stored in the storage path corresponding to the\n        # question.\n        new_image_filenames = self.get_new_image_filenames_added_in_suggestion()\n\n        # Image for interaction with Image Region is not included as an html\n        # string. This image is included in the imagePath in customization args.\n        # Other interactions such as Item Selection, Multiple Choice, Drag and\n        # Drop Sort have ck editor that includes the images of the interactions\n        # so that references for those images are included as html strings.\n        if question.question_state_data.interaction.id == 'ImageClickInput':\n            # Here we use cast because we are narrowing down the type from\n            # various types of cust. arg values to ImageAndRegionDict, and\n            # here we are sure that the type is always going to be\n            # ImageAndRegionDict because imageAndRegions customization arg\n            # object always contain values of type ImageAndRegionDict.\n            customization_arg_image_dict = cast(\n                domain.ImageAndRegionDict,\n                question.question_state_data.interaction.customization_args[\n                    'imageAndRegions'].value\n            )\n            new_image_filenames.append(\n                customization_arg_image_dict['imagePath'])\n        fs_services.copy_images(\n            self.image_context, self.target_id, feconf.ENTITY_TYPE_QUESTION,\n            question_dict['id'], new_image_filenames)\n\n        question_services.add_question(self.author_id, question)\n\n        skill = skill_fetchers.get_skill_by_id(\n            self.change.skill_id, strict=False)\n        if skill is None:\n            raise utils.ValidationError(\n                'The skill with the given id doesn\\'t exist.')\n        question_services.create_new_question_skill_link(\n            self.author_id, question_dict['id'], self.change.skill_id,\n            self._get_skill_difficulty())\n\n    def populate_old_value_of_change(self) -> None:\n        \"\"\"Populates old value of the change.\"\"\"\n        pass\n\n    def pre_update_validate(\n        self,\n        change: Union[\n            question_domain.CreateNewFullySpecifiedQuestionSuggestionCmd,\n            question_domain.CreateNewFullySpecifiedQuestionCmd\n        ]\n    ) -> None:\n        \"\"\"Performs the pre update validation. This functions need to be called\n        before updating the suggestion.\n\n        Args:\n            change: QuestionChange. The new change.\n\n        Raises:\n            ValidationError. Invalid new change.\n        \"\"\"\n        if self.change.cmd != change.cmd:\n            raise utils.ValidationError(\n                'The new change cmd must be equal to %s' %\n                self.change.cmd)\n        if self.change.skill_id != change.skill_id:\n            raise utils.ValidationError(\n                'The new change skill_id must be equal to %s' %\n                self.change.skill_id)\n\n        if (self.change.skill_difficulty == change.skill_difficulty) and (\n                self.change.question_dict == change.question_dict):\n            raise utils.ValidationError(\n                'At least one of the new skill_difficulty or question_dict '\n                'should be changed.')\n\n    def _get_skill_difficulty(self) -> float:\n        \"\"\"Returns the suggestion's skill difficulty.\"\"\"\n        return self.change.skill_difficulty\n\n    def get_all_html_content_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings used in this suggestion.\n\n        Returns:\n            list(str). The list of html content strings.\n        \"\"\"\n        question_dict: question_domain.QuestionDict = self.change.question_dict\n        state_object = (\n            state_domain.State.from_dict(\n                question_dict['question_state_data']))\n        html_string_list = state_object.get_all_html_content_strings()\n        return html_string_list\n\n    def get_target_entity_html_strings(self) -> List[str]:\n        \"\"\"Gets all html content strings from target entity used in the\n        suggestion.\n        \"\"\"\n        return []\n\n    def convert_html_in_suggestion_change(\n        self, conversion_fn: Callable[[str], str]\n    ) -> None:\n        \"\"\"Checks for HTML fields in the suggestion change and converts it\n        according to the conversion function.\n\n        Args:\n            conversion_fn: function. The function to be used for converting the\n                HTML.\n        \"\"\"\n        question_dict: question_domain.QuestionDict = self.change.question_dict\n        question_dict['question_state_data'] = (\n            state_domain.State.convert_html_fields_in_state(\n                question_dict['question_state_data'],\n                conversion_fn,\n                state_uses_old_interaction_cust_args_schema=(\n                    question_dict[\n                        'question_state_data_schema_version'] < 38),\n                state_uses_old_rule_template_schema=(\n                    question_dict[\n                        'question_state_data_schema_version'] < 45)\n            )\n        )\n\n\nSUGGESTION_TYPES_TO_DOMAIN_CLASSES: Dict[\n    str,\n    Union[\n        Type[SuggestionEditStateContent],\n        Type[SuggestionTranslateContent],\n        Type[SuggestionAddQuestion]\n    ]\n] = {\n    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT: (\n        SuggestionEditStateContent),\n    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: (\n        SuggestionTranslateContent),\n    feconf.SUGGESTION_TYPE_ADD_QUESTION: SuggestionAddQuestion\n}\n\n\nclass CommunityContributionStats:\n    \"\"\"Domain object for the CommunityContributionStatsModel.\n\n    Attributes:\n        translation_reviewer_counts_by_lang_code: dict. A dictionary where the\n            keys represent the language codes that translation suggestions are\n            offered in and the values correspond to the total number of\n            reviewers who have permission to review translation suggestions in\n            that language.\n        translation_suggestion_counts_by_lang_code: dict. A dictionary where\n            the keys represent the language codes that translation suggestions\n            are offered in and the values correspond to the total number of\n            translation suggestions that are currently in review in that\n            language.\n        question_reviewer_count: int. The total number of reviewers who have\n            permission to review question suggestions.\n        question_suggestion_count: int. The total number of question\n            suggestions that are currently in review.\n    \"\"\"\n\n    def __init__(\n        self,\n        translation_reviewer_counts_by_lang_code: Dict[str, int],\n        translation_suggestion_counts_by_lang_code: Dict[str, int],\n        question_reviewer_count: int,\n        question_suggestion_count: int\n    ) -> None:\n        self.translation_reviewer_counts_by_lang_code = (\n            translation_reviewer_counts_by_lang_code\n        )\n        self.translation_suggestion_counts_by_lang_code = (\n            translation_suggestion_counts_by_lang_code\n        )\n        self.question_reviewer_count = question_reviewer_count\n        self.question_suggestion_count = question_suggestion_count\n\n    def validate(self) -> None:\n        \"\"\"Validates the CommunityContributionStats object.\n\n        Raises:\n            ValidationError. One or more attributes of the\n                CommunityContributionStats object is invalid.\n        \"\"\"\n        for language_code, reviewer_count in (\n                self.translation_reviewer_counts_by_lang_code.items()):\n            # Translation languages are a part of audio languages.\n            if not utils.is_supported_audio_language_code(language_code):\n                raise utils.ValidationError(\n                    'Invalid language code for the translation reviewer '\n                    'counts: %s.' % language_code\n                )\n            if not isinstance(reviewer_count, int):\n                raise utils.ValidationError(\n                    'Expected the translation reviewer count to be '\n                    'an integer for %s language code, received: %s.' % (\n                        language_code, reviewer_count)\n                )\n            if reviewer_count < 0:\n                raise utils.ValidationError(\n                    'Expected the translation reviewer count to be '\n                    'non-negative for %s language code, received: %s.' % (\n                        language_code, reviewer_count)\n                )\n\n        for language_code, suggestion_count in (\n                self.translation_suggestion_counts_by_lang_code.items()):\n            # Translation languages are a part of audio languages.\n            if not utils.is_supported_audio_language_code(language_code):\n                raise utils.ValidationError(\n                    'Invalid language code for the translation suggestion '\n                    'counts: %s.' % language_code\n                )\n            if not isinstance(suggestion_count, int):\n                raise utils.ValidationError(\n                    'Expected the translation suggestion count to be '\n                    'an integer for %s language code, received: %s.' % (\n                        language_code, suggestion_count)\n                )\n            if suggestion_count < 0:\n                raise utils.ValidationError(\n                    'Expected the translation suggestion count to be '\n                    'non-negative for %s language code, received: %s.' % (\n                        language_code, suggestion_count)\n                )\n\n        if not isinstance(self.question_reviewer_count, int):\n            raise utils.ValidationError(\n                'Expected the question reviewer count to be an integer, '\n                'received: %s.' % self.question_reviewer_count\n            )\n        if self.question_reviewer_count < 0:\n            raise utils.ValidationError(\n                'Expected the question reviewer count to be non-negative, '\n                'received: %s.' % (self.question_reviewer_count)\n            )\n\n        if not isinstance(self.question_suggestion_count, int):\n            raise utils.ValidationError(\n                'Expected the question suggestion count to be an integer, '\n                'received: %s.' % self.question_suggestion_count\n            )\n        if self.question_suggestion_count < 0:\n            raise utils.ValidationError(\n                'Expected the question suggestion count to be non-negative, '\n                'received: %s.' % (self.question_suggestion_count)\n            )\n\n    def set_translation_reviewer_count_for_language_code(\n        self, language_code: str, count: int\n    ) -> None:\n        \"\"\"Sets the translation reviewer count to be count, for the given\n        language code.\n\n        Args:\n            language_code: str. The translation suggestion language code that\n                reviewers have the rights to review.\n            count: int. The number of reviewers that have the rights to review\n                translation suggestions in language_code.\n        \"\"\"\n        self.translation_reviewer_counts_by_lang_code[language_code] = count\n\n    def set_translation_suggestion_count_for_language_code(\n        self, language_code: str, count: int\n    ) -> None:\n        \"\"\"Sets the translation suggestion count to be count, for the language\n        code given.\n\n        Args:\n            language_code: str. The translation suggestion language code.\n            count: int. The number of translation suggestions in language_code\n                that are currently in review.\n        \"\"\"\n        self.translation_suggestion_counts_by_lang_code[language_code] = count\n\n    def are_translation_reviewers_needed_for_lang_code(\n        self, lang_code: str\n    ) -> bool:\n        \"\"\"Returns whether or not more reviewers are needed to review\n        translation suggestions in the given language code. Translation\n        suggestions in a given language need more reviewers if the number of\n        translation suggestions in that language divided by the number of\n        translation reviewers in that language is greater than\n        config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n        Args:\n            lang_code: str. The language code of the translation\n                suggestions.\n\n        Returns:\n            bool. Whether or not more reviewers are needed to review\n            translation suggestions in the given language code.\n       \"\"\"\n        if lang_code not in self.translation_suggestion_counts_by_lang_code:\n            return False\n\n        if lang_code not in self.translation_reviewer_counts_by_lang_code:\n            return True\n\n        number_of_reviewers = (\n            self.translation_reviewer_counts_by_lang_code[lang_code])\n        number_of_suggestions = (\n            self.translation_suggestion_counts_by_lang_code[lang_code])\n        return bool(\n            number_of_suggestions > (\n                config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.value * (\n                    number_of_reviewers)))\n\n    def get_translation_language_codes_that_need_reviewers(self) -> Set[str]:\n        \"\"\"Returns the language codes where more reviewers are needed to review\n        translations in those language codes. Translation suggestions in a\n        given language need more reviewers if the number of translation\n        suggestions in that language divided by the number of translation\n        reviewers in that language is greater than\n        config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n        Returns:\n            set. A set of of the language codes where more translation reviewers\n            are needed.\n        \"\"\"\n        language_codes_that_need_reviewers = set()\n        for language_code in self.translation_suggestion_counts_by_lang_code:\n            if self.are_translation_reviewers_needed_for_lang_code(\n                    language_code):\n                language_codes_that_need_reviewers.add(language_code)\n        return language_codes_that_need_reviewers\n\n    def are_question_reviewers_needed(self) -> bool:\n        \"\"\"Returns whether or not more reviewers are needed to review question\n        suggestions. Question suggestions need more reviewers if the number of\n        question suggestions divided by the number of question reviewers is\n        greater than config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n        Returns:\n            bool. Whether or not more reviewers are needed to review\n            question suggestions.\n       \"\"\"\n        if self.question_suggestion_count == 0:\n            return False\n\n        if self.question_reviewer_count == 0:\n            return True\n\n        return bool(\n            self.question_suggestion_count > (\n                config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.value * (\n                    self.question_reviewer_count)))\n\n\nclass TranslationContributionStatsDict(TypedDict):\n    \"\"\"Dictionary representing the TranslationContributionStats object.\"\"\"\n\n    language_code: Optional[str]\n    contributor_user_id: Optional[str]\n    topic_id: Optional[str]\n    submitted_translations_count: int\n    submitted_translation_word_count: int\n    accepted_translations_count: int\n    accepted_translations_without_reviewer_edits_count: int\n    accepted_translation_word_count: int\n    rejected_translations_count: int\n    rejected_translation_word_count: int\n    contribution_dates: Set[datetime.date]\n\n\nclass TranslationContributionStatsFrontendDict(TypedDict):\n    \"\"\"Dictionary representing the TranslationContributionStats\n    object for frontend.\n    \"\"\"\n\n    language_code: Optional[str]\n    topic_id: Optional[str]\n    submitted_translations_count: int\n    submitted_translation_word_count: int\n    accepted_translations_count: int\n    accepted_translations_without_reviewer_edits_count: int\n    accepted_translation_word_count: int\n    rejected_translations_count: int\n    rejected_translation_word_count: int\n    first_contribution_date: str\n    last_contribution_date: str\n\n\nclass TranslationContributionStats:\n    \"\"\"Domain object for the TranslationContributionStatsModel.\"\"\"\n\n    def __init__(\n        self,\n        language_code: Optional[str],\n        contributor_user_id: Optional[str],\n        topic_id: Optional[str],\n        submitted_translations_count: int,\n        submitted_translation_word_count: int,\n        accepted_translations_count: int,\n        accepted_translations_without_reviewer_edits_count: int,\n        accepted_translation_word_count: int,\n        rejected_translations_count: int,\n        rejected_translation_word_count: int,\n        contribution_dates: Set[datetime.date]\n    ) -> None:\n        self.language_code = language_code\n        self.contributor_user_id = contributor_user_id\n        self.topic_id = topic_id\n        self.submitted_translations_count = submitted_translations_count\n        self.submitted_translation_word_count = submitted_translation_word_count\n        self.accepted_translations_count = accepted_translations_count\n        self.accepted_translations_without_reviewer_edits_count = (\n            accepted_translations_without_reviewer_edits_count\n        )\n        self.accepted_translation_word_count = accepted_translation_word_count\n        self.rejected_translations_count = rejected_translations_count\n        self.rejected_translation_word_count = rejected_translation_word_count\n        self.contribution_dates = contribution_dates\n\n    @classmethod\n    def create_default(\n        cls,\n        language_code: Optional[str] = None,\n        contributor_user_id: Optional[str] = None,\n        topic_id: Optional[str] = None\n    ) -> TranslationContributionStats:\n        \"\"\"Create default translation contribution stats.\n\n        Args:\n            language_code: str. The language code for which are these stats\n                generated.\n            contributor_user_id: str. User ID of the contributor to which\n                these stats belong.\n            topic_id: str. ID of the topic for which were\n                the translations created.\n\n        Returns:\n            TranslationContributionStats. Default translation contribution\n            stats.\n        \"\"\"\n        return cls(\n            language_code, contributor_user_id, topic_id,\n            0, 0, 0, 0, 0, 0, 0, set()\n        )\n\n    def to_dict(self) -> TranslationContributionStatsDict:\n        \"\"\"Returns a dict representation of a TranslationContributionStats\n        domain object.\n\n        Returns:\n            dict. A dict representation of a TranslationContributionStats\n            domain object.\n        \"\"\"\n        return {\n            'language_code': self.language_code,\n            'contributor_user_id': self.contributor_user_id,\n            'topic_id': self.topic_id,\n            'submitted_translations_count': self.submitted_translations_count,\n            'submitted_translation_word_count': (\n                self.submitted_translation_word_count),\n            'accepted_translations_count': self.accepted_translations_count,\n            'accepted_translations_without_reviewer_edits_count': (\n                self.accepted_translations_without_reviewer_edits_count),\n            'accepted_translation_word_count': (\n                self.accepted_translation_word_count),\n            'rejected_translations_count': self.rejected_translations_count,\n            'rejected_translation_word_count': (\n                self.rejected_translation_word_count),\n            'contribution_dates': self.contribution_dates\n        }\n\n    # TODO(#16051): TranslationContributionStats to use first_contribution_date\n    # and last_contribution_date.\n    def to_frontend_dict(self) -> TranslationContributionStatsFrontendDict:\n        \"\"\"Returns a dict representation of a TranslationContributionStats\n        domain object for frontend.\n\n        Returns:\n            dict. A dict representation of a TranslationContributionStats\n            domain object for frontend.\n        \"\"\"\n        sorted_contribution_dates = sorted(self.contribution_dates)\n        return {\n            'language_code': self.language_code,\n            'topic_id': self.topic_id,\n            'submitted_translations_count': self.submitted_translations_count,\n            'submitted_translation_word_count': (\n                self.submitted_translation_word_count),\n            'accepted_translations_count': self.accepted_translations_count,\n            'accepted_translations_without_reviewer_edits_count': (\n                self.accepted_translations_without_reviewer_edits_count),\n            'accepted_translation_word_count': (\n                self.accepted_translation_word_count),\n            'rejected_translations_count': self.rejected_translations_count,\n            'rejected_translation_word_count': (\n                self.rejected_translation_word_count),\n            'first_contribution_date': (\n                sorted_contribution_dates[0].strftime('%b %Y')),\n            'last_contribution_date': (\n                sorted_contribution_dates[-1].strftime('%b %Y'))\n        }\n\n\nclass TranslationReviewStatsDict(TypedDict):\n    \"\"\"Dictionary representing the TranslationReviewStats object.\"\"\"\n\n    language_code: str\n    contributor_user_id: str\n    topic_id: str\n    reviewed_translations_count: int\n    reviewed_translation_word_count: int\n    accepted_translations_count: int\n    accepted_translation_word_count: int\n    accepted_translations_with_reviewer_edits_count: int\n    first_contribution_date: datetime.date\n    last_contribution_date: datetime.date\n\n\nclass TranslationReviewStatsFrontendDict(TypedDict):\n    \"\"\"Dictionary representing the TranslationReviewStats\n    object for frontend.\n    \"\"\"\n\n    language_code: str\n    topic_id: str\n    reviewed_translations_count: int\n    reviewed_translation_word_count: int\n    accepted_translations_count: int\n    accepted_translation_word_count: int\n    accepted_translations_with_reviewer_edits_count: int\n    first_contribution_date: str\n    last_contribution_date: str\n\n\nclass TranslationReviewStats:\n    \"\"\"Domain object for the TranslationReviewStatsModel.\"\"\"\n\n    def __init__(\n        self,\n        language_code: str,\n        contributor_user_id: str,\n        topic_id: str,\n        reviewed_translations_count: int,\n        reviewed_translation_word_count: int,\n        accepted_translations_count: int,\n        accepted_translation_word_count: int,\n        accepted_translations_with_reviewer_edits_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> None:\n        self.language_code = language_code\n        self.contributor_user_id = contributor_user_id\n        self.topic_id = topic_id\n        self.reviewed_translations_count = reviewed_translations_count\n        self.reviewed_translation_word_count = reviewed_translation_word_count\n        self.accepted_translations_count = accepted_translations_count\n        self.accepted_translation_word_count = accepted_translation_word_count\n        self.accepted_translations_with_reviewer_edits_count = (\n            accepted_translations_with_reviewer_edits_count\n        )\n        self.first_contribution_date = first_contribution_date\n        self.last_contribution_date = last_contribution_date\n\n    def to_dict(self) -> TranslationReviewStatsDict:\n        \"\"\"Returns a dict representation of a TranslationReviewStats\n        domain object.\n\n        Returns:\n            dict. A dict representation of a TranslationReviewStats\n            domain object.\n        \"\"\"\n        return {\n            'language_code': self.language_code,\n            'contributor_user_id': self.contributor_user_id,\n            'topic_id': self.topic_id,\n            'reviewed_translations_count': self.reviewed_translations_count,\n            'reviewed_translation_word_count': (\n                self.reviewed_translation_word_count),\n            'accepted_translations_count': self.accepted_translations_count,\n            'accepted_translation_word_count': (\n                self.accepted_translation_word_count),\n            'accepted_translations_with_reviewer_edits_count': (\n                self.accepted_translations_with_reviewer_edits_count),\n            'first_contribution_date': self.first_contribution_date,\n            'last_contribution_date': self.last_contribution_date,\n        }\n\n    def to_frontend_dict(self) -> TranslationReviewStatsFrontendDict:\n        \"\"\"Returns a dict representation of a TranslationReviewStats\n        domain object for frontend.\n\n        Returns:\n            dict. A dict representation of a TranslationReviewStats\n            domain object for frontend.\n        \"\"\"\n        return {\n            'language_code': self.language_code,\n            'topic_id': self.topic_id,\n            'reviewed_translations_count': self.reviewed_translations_count,\n            'reviewed_translation_word_count': (\n                self.reviewed_translation_word_count),\n            'accepted_translations_count': self.accepted_translations_count,\n            'accepted_translation_word_count': (\n                self.accepted_translation_word_count),\n            'accepted_translations_with_reviewer_edits_count': (\n                self.accepted_translations_with_reviewer_edits_count),\n            'first_contribution_date': (\n                self.first_contribution_date.strftime('%b %Y')),\n            'last_contribution_date': (\n                self.last_contribution_date.strftime('%b %Y'))\n        }\n\n\nclass QuestionContributionStatsDict(TypedDict):\n    \"\"\"Dictionary representing the QuestionContributionStats object.\"\"\"\n\n    contributor_user_id: str\n    topic_id: str\n    submitted_questions_count: int\n    accepted_questions_count: int\n    accepted_questions_without_reviewer_edits_count: int\n    first_contribution_date: datetime.date\n    last_contribution_date: datetime.date\n\n\nclass QuestionContributionStatsFrontendDict(TypedDict):\n    \"\"\"Dictionary representing the QuestionContributionStats\n    object for frontend.\n    \"\"\"\n\n    topic_id: str\n    submitted_questions_count: int\n    accepted_questions_count: int\n    accepted_questions_without_reviewer_edits_count: int\n    first_contribution_date: str\n    last_contribution_date: str\n\n\nclass QuestionContributionStats:\n    \"\"\"Domain object for the QuestionContributionStatsModel.\"\"\"\n\n    def __init__(\n        self,\n        contributor_user_id: str,\n        topic_id: str,\n        submitted_questions_count: int,\n        accepted_questions_count: int,\n        accepted_questions_without_reviewer_edits_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> None:\n        self.contributor_user_id = contributor_user_id\n        self.topic_id = topic_id\n        self.submitted_questions_count = submitted_questions_count\n        self.accepted_questions_count = accepted_questions_count\n        self.accepted_questions_without_reviewer_edits_count = (\n            accepted_questions_without_reviewer_edits_count\n        )\n        self.first_contribution_date = first_contribution_date\n        self.last_contribution_date = last_contribution_date\n\n    def to_dict(self) -> QuestionContributionStatsDict:\n        \"\"\"Returns a dict representation of a QuestionContributionStats\n        domain object.\n\n        Returns:\n            dict. A dict representation of a QuestionContributionStats\n            domain object.\n        \"\"\"\n        return {\n            'contributor_user_id': self.contributor_user_id,\n            'topic_id': self.topic_id,\n            'submitted_questions_count': self.submitted_questions_count,\n            'accepted_questions_count': (\n                self.accepted_questions_count),\n            'accepted_questions_without_reviewer_edits_count': (\n                self.accepted_questions_without_reviewer_edits_count),\n            'first_contribution_date': (\n                self.first_contribution_date),\n            'last_contribution_date': self.last_contribution_date\n        }\n\n    def to_frontend_dict(self) -> QuestionContributionStatsFrontendDict:\n        \"\"\"Returns a dict representation of a QuestionContributionStats\n        domain object for frontend.\n\n        Returns:\n            dict. A dict representation of a QuestionContributionStats\n            domain object for frontend.\n        \"\"\"\n        return {\n            'topic_id': self.topic_id,\n            'submitted_questions_count': self.submitted_questions_count,\n            'accepted_questions_count': (\n                self.accepted_questions_count),\n            'accepted_questions_without_reviewer_edits_count': (\n                self.accepted_questions_without_reviewer_edits_count),\n            'first_contribution_date': (\n                self.first_contribution_date.strftime('%b %Y')),\n            'last_contribution_date': (\n                self.last_contribution_date.strftime('%b %Y'))\n        }\n\n\nclass QuestionReviewStatsDict(TypedDict):\n    \"\"\"Dictionary representing the QuestionReviewStats object.\"\"\"\n\n    contributor_user_id: str\n    topic_id: str\n    reviewed_questions_count: int\n    accepted_questions_count: int\n    accepted_questions_with_reviewer_edits_count: int\n    first_contribution_date: datetime.date\n    last_contribution_date: datetime.date\n\n\nclass QuestionReviewStatsFrontendDict(TypedDict):\n    \"\"\"Dictionary representing the QuestionReviewStats\n    object for frontend.\n    \"\"\"\n\n    topic_id: str\n    reviewed_questions_count: int\n    accepted_questions_count: int\n    accepted_questions_with_reviewer_edits_count: int\n    first_contribution_date: str\n    last_contribution_date: str\n\n\nclass QuestionReviewStats:\n    \"\"\"Domain object for the QuestionReviewStatsModel.\"\"\"\n\n    def __init__(\n        self,\n        contributor_user_id: str,\n        topic_id: str,\n        reviewed_questions_count: int,\n        accepted_questions_count: int,\n        accepted_questions_with_reviewer_edits_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> None:\n        self.contributor_user_id = contributor_user_id\n        self.topic_id = topic_id\n        self.reviewed_questions_count = reviewed_questions_count\n        self.accepted_questions_count = accepted_questions_count\n        self.accepted_questions_with_reviewer_edits_count = (\n            accepted_questions_with_reviewer_edits_count\n        )\n        self.first_contribution_date = first_contribution_date\n        self.last_contribution_date = last_contribution_date\n\n    def to_dict(self) -> QuestionReviewStatsDict:\n        \"\"\"Returns a dict representation of a QuestionContributionStats\n        domain object.\n\n        Returns:\n            dict. A dict representation of a QuestionContributionStats\n            domain object.\n        \"\"\"\n        return {\n            'contributor_user_id': self.contributor_user_id,\n            'topic_id': self.topic_id,\n            'reviewed_questions_count': self.reviewed_questions_count,\n            'accepted_questions_count': (\n                self.accepted_questions_count),\n            'accepted_questions_with_reviewer_edits_count': (\n                self.accepted_questions_with_reviewer_edits_count),\n            'first_contribution_date': (\n                self.first_contribution_date),\n            'last_contribution_date': self.last_contribution_date\n        }\n\n    def to_frontend_dict(self) -> QuestionReviewStatsFrontendDict:\n        \"\"\"Returns a dict representation of a QuestionContributionStats\n        domain object for frontend.\n\n        Returns:\n            dict. A dict representation of a QuestionContributionStats\n            domain object for frontend.\n        \"\"\"\n        return {\n            'topic_id': self.topic_id,\n            'reviewed_questions_count': self.reviewed_questions_count,\n            'accepted_questions_count': (\n                self.accepted_questions_count),\n            'accepted_questions_with_reviewer_edits_count': (\n                self.accepted_questions_with_reviewer_edits_count),\n            'first_contribution_date': (\n                self.first_contribution_date.strftime('%b %Y')),\n            'last_contribution_date': (\n                self.last_contribution_date.strftime('%b %Y'))\n        }\n\n\nclass ContributorCertificateInfoDict(TypedDict):\n    \"\"\"Dictionary representing the ContributorCertificateInfo object.\"\"\"\n\n    from_date: str\n    to_date: str\n    team_lead: str\n    contribution_hours: str\n    language: Optional[str]\n\n\nclass ContributorCertificateInfo:\n    \"\"\"Encapsulates key information that is used to generate contributor\n    certificate.\n    \"\"\"\n\n    def __init__(\n        self,\n        from_date: str,\n        to_date: str,\n        team_lead: str,\n        contribution_hours: str,\n        language: Optional[str]\n    ) -> None:\n        self.from_date = from_date\n        self.to_date = to_date\n        self.team_lead = team_lead\n        self.contribution_hours = contribution_hours\n        self.language = language\n\n    def to_dict(self) -> ContributorCertificateInfoDict:\n        \"\"\"Returns a dict representation of a ContributorCertificateInfo\n        domain object.\n\n        Returns:\n            dict. A dict representation of a ContributorCertificateInfo\n            domain object.\n        \"\"\"\n        return {\n            'from_date': self.from_date,\n            'to_date': self.to_date,\n            'team_lead': self.team_lead,\n            'contribution_hours': self.contribution_hours,\n            'language': self.language\n        }\n\n\nclass ContributorMilestoneEmailInfo:\n    \"\"\"Encapsulates key information that is used to create the email content for\n    notifying contributors about milestones they achieved.\n\n    Attributes:\n        contributor_user_id: str. The ID of the contributor.\n        language_code: str|None. The language code of the suggestion.\n        contribution_type: str. The type of the contribution i.e.\n            translation or question.\n        contribution_sub_type: str. The sub type of the contribution\n            i.e. submissions/acceptances/reviews/edits.\n        rank_name: str. The name of the rank that the contributor achieved.\n    \"\"\"\n\n    def __init__(\n        self,\n        contributor_user_id: str,\n        contribution_type: str,\n        contribution_subtype: str,\n        language_code: Optional[str],\n        rank_name: str\n    ) -> None:\n        self.contributor_user_id = contributor_user_id\n        self.contribution_type = contribution_type\n        self.contribution_subtype = contribution_subtype\n        self.language_code = language_code\n        self.rank_name = rank_name\n\n\nclass ContributorStatsSummaryDict(TypedDict):\n    \"\"\"Dictionary representing the ContributorStatsSummary object.\"\"\"\n\n    contributor_user_id: str\n    translation_contribution_stats: List[TranslationContributionStatsDict]\n    question_contribution_stats: List[QuestionContributionStatsDict]\n    translation_review_stats: List[TranslationReviewStatsDict]\n    question_review_stats: List[QuestionReviewStatsDict]\n\n\nclass ContributorStatsSummary:\n    \"\"\"Encapsulates key information that is used to send to the frontend\n    regarding contributor stats.\n\n    Attributes:\n        contributor_user_id: str. The ID of the contributor.\n        translation_contribution_stats: list(TranslationContributionStats). A\n            list of TranslationContributionStats corresponding to the user.\n        question_contribution_stats: list(QuestionContributionStats). A list of\n            QuestionContributionStats corresponding to the user.\n        translation_review_stats: list(TranslationReviewStats). A list of\n            TranslationReviewStats corresponding to the user.\n        question_review_stats: list(QuestionReviewStats). A list of\n            QuestionReviewStats  corresponding to the user.\n    \"\"\"\n\n    def __init__(\n        self,\n        contributor_user_id: str,\n        translation_contribution_stats: List[TranslationContributionStats],\n        question_contribution_stats: List[QuestionContributionStats],\n        translation_review_stats: List[TranslationReviewStats],\n        question_review_stats: List[QuestionReviewStats]\n    ) -> None:\n        self.contributor_user_id = contributor_user_id\n        self.translation_contribution_stats = translation_contribution_stats\n        self.question_contribution_stats = question_contribution_stats\n        self.translation_review_stats = translation_review_stats\n        self.question_review_stats = question_review_stats\n\n    def to_dict(self) -> ContributorStatsSummaryDict:\n        \"\"\"Returns a dict representation of a ContributorStatsSummary\n        domain object.\n\n        Returns:\n            dict. A dict representation of a ContributorStatsSummary\n            domain object.\n        \"\"\"\n        return {\n            'contributor_user_id': self.contributor_user_id,\n            'translation_contribution_stats': [\n                stats.to_dict() for stats in (\n                    self.translation_contribution_stats)],\n            'question_contribution_stats': [\n                stats.to_dict() for stats in self.question_contribution_stats],\n            'translation_review_stats': [\n                stats.to_dict() for stats in self.translation_review_stats],\n            'question_review_stats': [\n                stats.to_dict() for stats in self.question_review_stats]\n        }\n\n\nclass ReviewableSuggestionEmailInfo:\n    \"\"\"Encapsulates key information that is used to create the email content for\n    notifying admins and reviewers that there are suggestions that need to be\n    reviewed.\n\n    Attributes:\n        suggestion_type: str. The type of the suggestion.\n        language_code: str. The language code of the suggestion.\n        suggestion_content: str. The suggestion content that is emphasized for\n            a user when they are viewing a list of suggestions on the\n            Contributor Dashboard.\n        submission_datetime: datetime.datetime. Date and time when the\n            suggestion was submitted for review.\n    \"\"\"\n\n    def __init__(\n        self,\n        suggestion_type: str,\n        language_code: str,\n        suggestion_content: str,\n        submission_datetime: datetime.datetime\n    ) -> None:\n        self.suggestion_type = suggestion_type\n        self.language_code = language_code\n        self.suggestion_content = suggestion_content\n        self.submission_datetime = submission_datetime\n"
    },
    {
      "filename": "core/domain/suggestion_services.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Funtions to create, accept, reject, update and perform other operations on\nsuggestions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport heapq\nimport logging\nimport re\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.domain import email_manager\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import feedback_services\nfrom core.domain import html_cleaner\nfrom core.domain import html_validation_service\nfrom core.domain import opportunity_services\nfrom core.domain import question_domain\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import suggestion_registry\nfrom core.domain import taskqueue_services\nfrom core.domain import user_domain\nfrom core.domain import user_services\nfrom core.platform import models\n\nfrom typing import (\n    Callable, Dict, Final, List, Literal, Mapping, Match, Optional,\n    Sequence, Set, Tuple, Union, cast, overload\n)\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    # Here, change domain is imported only for type checking.\n    from core.domain import change_domain\n    from mypy_imports import feedback_models\n    from mypy_imports import suggestion_models\n    from mypy_imports import transaction_services\n    from mypy_imports import user_models\n\n    AllowedSuggestionClasses = Union[\n        suggestion_registry.SuggestionEditStateContent,\n        suggestion_registry.SuggestionTranslateContent,\n        suggestion_registry.SuggestionAddQuestion\n    ]\n\n(feedback_models, suggestion_models, user_models) = (\n    models.Registry.import_models([\n        models.Names.FEEDBACK, models.Names.SUGGESTION, models.Names.USER\n    ])\n)\n\ntransaction_services = models.Registry.import_transaction_services()\n\nDEFAULT_SUGGESTION_THREAD_SUBJECT: Final = 'Suggestion from a user'\nDEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE: Final = ''\n\n# The maximum number of suggestions to recommend to a reviewer to review in an\n# email.\nMAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER: Final = 5\n\nSUGGESTION_TRANSLATE_CONTENT_HTML: Callable[\n    [suggestion_registry.SuggestionTranslateContent], str\n] = lambda suggestion: suggestion.change.translation_html\n\nSUGGESTION_ADD_QUESTION_HTML: Callable[\n    [suggestion_registry.SuggestionAddQuestion], str\n] = lambda suggestion: suggestion.change.question_dict[\n    'question_state_data']['content']['html']\n\n# A dictionary that maps the suggestion type to a lambda function, which is\n# used to retrieve the html content that corresponds to the suggestion's\n# emphasized text on the Contributor Dashboard. From a UI perspective, the\n# emphasized content makes it easier for users to identify the different\n# suggestion opportunities. For instance, for translation suggestions the\n# emphasized text is the translation. Similarly, for question suggestions the\n# emphasized text is the question being asked.\nSUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS: Dict[str, Callable[..., str]] = {\n    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: SUGGESTION_TRANSLATE_CONTENT_HTML,\n    feconf.SUGGESTION_TYPE_ADD_QUESTION: SUGGESTION_ADD_QUESTION_HTML\n}\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['add_question'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionAddQuestion: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['translate_content'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionTranslateContent: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: Literal['edit_exploration_state_content'],\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.SuggestionEditStateContent: ...\n\n\n@overload\ndef create_suggestion(\n    suggestion_type: str,\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.BaseSuggestion: ...\n\n\ndef create_suggestion(\n    suggestion_type: str,\n    target_type: str,\n    target_id: str,\n    target_version_at_submission: int,\n    author_id: str,\n    change: Mapping[str, change_domain.AcceptableChangeDictTypes],\n    description: Optional[str]\n) -> suggestion_registry.BaseSuggestion:\n    \"\"\"Creates a new SuggestionModel and the corresponding FeedbackThread.\n\n    Args:\n        suggestion_type: str. The type of the suggestion. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_type: str. The target entity being edited. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_id: str. The ID of the target entity being suggested to.\n        target_version_at_submission: int. The version number of the target\n            entity at the time of creation of the suggestion.\n        author_id: str. The ID of the user who submitted the suggestion.\n        change: dict. The details of the suggestion.\n        description: str|None. The description of the changes provided by the\n            author or None, if no description is provided.\n\n    Returns:\n        Suggestion. The newly created suggestion domain object.\n\n    Raises:\n        Exception. Invalid suggestion type.\n    \"\"\"\n    if description is None:\n        description = DEFAULT_SUGGESTION_THREAD_SUBJECT\n    thread_id = feedback_services.create_thread(\n        target_type, target_id, author_id, description,\n        DEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE, has_suggestion=True)\n\n    status = suggestion_models.STATUS_IN_REVIEW\n\n    if target_type == feconf.ENTITY_TYPE_EXPLORATION:\n        exploration = exp_fetchers.get_exploration_by_id(target_id)\n    if suggestion_type == feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT:\n        score_category = (\n            suggestion_models.SCORE_TYPE_CONTENT +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + exploration.category)\n        # Suggestions of this type do not have an associated language code,\n        # since they are not queryable by language.\n        language_code = None\n        suggestion: AllowedSuggestionClasses = (\n            suggestion_registry.SuggestionEditStateContent(\n                thread_id, target_id, target_version_at_submission, status,\n                author_id, None, change, score_category, language_code, False\n            )\n        )\n    elif suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n        score_category = (\n            suggestion_models.SCORE_TYPE_TRANSLATION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + exploration.category)\n        # The language code of the translation, used for querying purposes.\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change['language_code'], str)\n        language_code = change['language_code']\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change['state_name'], str)\n        assert isinstance(change['content_id'], str)\n        content_html = exploration.get_content_html(\n            change['state_name'], change['content_id'])\n        if content_html != change['content_html']:\n            raise Exception(\n                'The Exploration content has changed since this translation '\n                'was submitted.')\n        suggestion = suggestion_registry.SuggestionTranslateContent(\n            thread_id, target_id, target_version_at_submission, status,\n            author_id, None, change, score_category, language_code, False\n        )\n    elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n        score_category = (\n            suggestion_models.SCORE_TYPE_QUESTION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + target_id)\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(change['question_dict'], dict)\n        # Here we use cast because we are narrowing down the type from\n        # various Dict types that are present in AcceptableChangeDictTypes\n        # to QuestionDict type.\n        question_dict = cast(\n            question_domain.QuestionDict,\n            change['question_dict']\n        )\n        question_dict['language_code'] = (\n            constants.DEFAULT_LANGUAGE_CODE)\n        question_dict['question_state_data_schema_version'] = (\n            feconf.CURRENT_STATE_SCHEMA_VERSION)\n        # The language code of the question, used for querying purposes.\n        add_question_language_code = constants.DEFAULT_LANGUAGE_CODE\n        suggestion = suggestion_registry.SuggestionAddQuestion(\n            thread_id, target_id, target_version_at_submission, status,\n            author_id, None, change, score_category, add_question_language_code,\n            False\n        )\n    else:\n        raise Exception('Invalid suggestion type %s' % suggestion_type)\n    suggestion.validate()\n\n    suggestion_models.GeneralSuggestionModel.create(\n        suggestion_type, target_type, target_id,\n        target_version_at_submission, status, author_id,\n        None, change, score_category, thread_id, suggestion.language_code)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    return get_suggestion_by_id(thread_id)\n\n\ndef get_suggestion_from_model(\n    suggestion_model: suggestion_models.GeneralSuggestionModel\n) -> suggestion_registry.BaseSuggestion:\n    \"\"\"Converts the given SuggestionModel to a Suggestion domain object\n\n    Args:\n        suggestion_model: SuggestionModel. SuggestionModel object to be\n            converted to Suggestion domain object.\n\n    Returns:\n        Suggestion. The corresponding Suggestion domain object.\n    \"\"\"\n    suggestion_domain_class = (\n        suggestion_registry.SUGGESTION_TYPES_TO_DOMAIN_CLASSES[\n            suggestion_model.suggestion_type])\n    return suggestion_domain_class(\n        suggestion_model.id, suggestion_model.target_id,\n        suggestion_model.target_version_at_submission,\n        suggestion_model.status, suggestion_model.author_id,\n        suggestion_model.final_reviewer_id, suggestion_model.change_cmd,\n        suggestion_model.score_category, suggestion_model.language_code,\n        suggestion_model.edited_by_reviewer, suggestion_model.last_updated)\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str\n) -> suggestion_registry.BaseSuggestion: ...\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str, *, strict: Literal[True]\n) -> suggestion_registry.BaseSuggestion: ...\n\n\n@overload\ndef get_suggestion_by_id(\n    suggestion_id: str, *, strict: Literal[False]\n) -> Optional[suggestion_registry.BaseSuggestion]: ...\n\n\ndef get_suggestion_by_id(\n    suggestion_id: str, strict: bool = True\n) -> Optional[suggestion_registry.BaseSuggestion]:\n    \"\"\"Finds a suggestion by the suggestion ID.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n        strict: bool. Whether to fail noisily if no suggestion with a given id\n            exists.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n\n    Raises:\n        Exception. The suggestion model does not exists for the given id.\n    \"\"\"\n    model = suggestion_models.GeneralSuggestionModel.get_by_id(suggestion_id)\n\n    if strict and model is None:\n        raise Exception(\n            'No suggestion model exists for the corresponding suggestion id: %s'\n            % suggestion_id\n        )\n\n    return get_suggestion_from_model(model) if model else None\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.TranslationContributionStatsModel]: ...\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.TranslationContributionStatsModel]: ...\n\n\n@overload\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.TranslationContributionStatsModel]]: ...\n\n\ndef get_translation_contribution_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.TranslationContributionStatsModel]]:\n    \"\"\"Finds translation contribution stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(TranslationContributionStatsModel|None). The corresponding\n        translation contribution stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.TranslationContributionStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.TranslationReviewStatsModel]: ...\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.TranslationReviewStatsModel]: ...\n\n\n@overload\ndef get_translation_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.TranslationReviewStatsModel]]: ...\n\n\ndef get_translation_review_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.TranslationReviewStatsModel]]:\n    \"\"\"Finds translation review stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(TranslationReviewStatsModel|None). The corresponding translation\n        review stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.TranslationReviewStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.QuestionContributionStatsModel]: ...\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.QuestionContributionStatsModel]: ...\n\n\n@overload\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.QuestionContributionStatsModel]]: ...\n\n\ndef get_question_contribution_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.QuestionContributionStatsModel]]:\n    \"\"\"Finds question contribution stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(QuestionContributionStatsModel|None). The corresponding question\n        contribution stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.QuestionContributionStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[True]\n) -> List[suggestion_models.QuestionReviewStatsModel]: ...\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str]\n) -> List[suggestion_models.QuestionReviewStatsModel]: ...\n\n\n@overload\ndef get_question_review_stats_models(\n    stats_ids: List[str], *, strict: Literal[False]\n) -> List[Optional[suggestion_models.QuestionReviewStatsModel]]: ...\n\n\ndef get_question_review_stats_models(\n    stats_ids: List[str], strict: bool = True\n) -> Sequence[Optional[suggestion_models.QuestionReviewStatsModel]]:\n    \"\"\"Finds question review stats by the IDs.\n\n    Args:\n        stats_ids: list(str). The IDs of the stats.\n        strict: bool. Whether to fail noisily if no stat with given ids exists.\n\n    Returns:\n        list(QuestionReviewStatsModel|None). The corresponding question review\n        stats for the given IDs.\n\n    Raises:\n        Exception. The stats models do not exist for the given IDs.\n    \"\"\"\n    stats_models = (\n        suggestion_models.QuestionReviewStatsModel.get_multi(\n            list(stats_ids)))\n\n    if not strict:\n        return stats_models\n\n    for index, model in enumerate(stats_models):\n        if model is None:\n            raise Exception(\n                'The stats models do not exist for the stats_id %s.' % (\n                    stats_ids[index])\n            )\n\n    return stats_models\n\n\ndef get_suggestions_by_ids(\n    suggestion_ids: List[str]\n) -> List[Optional[suggestion_registry.BaseSuggestion]]:\n    \"\"\"Finds suggestions using the given suggestion IDs.\n\n    Args:\n        suggestion_ids: list(str). The IDs of the suggestions.\n\n    Returns:\n        list(Suggestion|None). A list of the corresponding suggestions. The\n        list will contain None elements if no suggestion is found with the\n        corresponding suggestion id.\n    \"\"\"\n    general_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n\n    return [\n        get_suggestion_from_model(suggestion_model) if suggestion_model\n        else None for suggestion_model in general_suggestion_models\n    ]\n\n\ndef query_suggestions(\n    query_fields_and_values: List[Tuple[str, str]]\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Queries for suggestions.\n\n    Args:\n        query_fields_and_values: list(tuple(str, str)). A list of queries. The\n            first element in each tuple is the field to be queried, and the\n            second element is its value.\n\n    Returns:\n        list(Suggestion). A list of suggestions that match the given query\n        values, up to a maximum of feconf.DEFAULT_QUERY_LIMIT suggestions.\n    \"\"\"\n    return [\n        get_suggestion_from_model(s) for s in\n        suggestion_models.GeneralSuggestionModel.query_suggestions(\n            query_fields_and_values)\n    ]\n\n\ndef get_translation_suggestion_ids_with_exp_ids(\n    exp_ids: List[str]\n) -> List[str]:\n    \"\"\"Gets the ids of the translation suggestions corresponding to\n    explorations with the given exploration ids.\n\n    Args:\n        exp_ids: list(str). List of exploration ids to query for.\n\n    Returns:\n        list(str). A list of the ids of translation suggestions that\n        correspond to the given exploration ids. Note: it is not\n        guaranteed that the suggestion ids returned are ordered by the\n        exploration ids in exp_ids.\n    \"\"\"\n    if len(exp_ids) == 0:\n        return []\n\n    return (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestion_ids_with_exp_ids(exp_ids)\n    )\n\n\ndef get_all_stale_suggestion_ids() -> List[str]:\n    \"\"\"Gets a list of the suggestion ids corresponding to suggestions that have\n    not had any activity on them for THRESHOLD_TIME_BEFORE_ACCEPT time.\n\n    Returns:\n        list(str). A list of suggestion ids that correspond to stale\n        suggestions.\n    \"\"\"\n\n    return (\n        suggestion_models.GeneralSuggestionModel.get_all_stale_suggestion_ids()\n    )\n\n\ndef _update_suggestion(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Updates the given suggestion.\n\n    Args:\n        suggestion: Suggestion. The suggestion to be updated.\n    \"\"\"\n    _update_suggestions([suggestion])\n\n\ndef _update_suggestions(\n    suggestions: List[suggestion_registry.BaseSuggestion],\n    update_last_updated_time: bool = True\n) -> None:\n    \"\"\"Updates the given suggestions.\n\n    Args:\n        suggestions: list(Suggestion). The suggestions to be updated.\n        update_last_updated_time: bool. Whether to update the last_updated\n            field of the suggestions.\n    \"\"\"\n    suggestion_ids = []\n\n    for suggestion in suggestions:\n        suggestion.validate()\n        suggestion_ids.append(suggestion.suggestion_id)\n\n    suggestion_models_to_update_with_none = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n    suggestion_models_to_update = []\n\n    for index, suggestion_model in enumerate(\n        suggestion_models_to_update_with_none\n    ):\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestion_model is not None\n        suggestion = suggestions[index]\n        suggestion_models_to_update.append(suggestion_model)\n        suggestion_model.status = suggestion.status\n        suggestion_model.final_reviewer_id = suggestion.final_reviewer_id\n        suggestion_model.change_cmd = suggestion.change.to_dict()\n        suggestion_model.score_category = suggestion.score_category\n        suggestion_model.language_code = suggestion.language_code\n        suggestion_model.edited_by_reviewer = suggestion.edited_by_reviewer\n\n    suggestion_models.GeneralSuggestionModel.update_timestamps_multi(\n        suggestion_models_to_update,\n        update_last_updated_time=update_last_updated_time)\n    suggestion_models.GeneralSuggestionModel.put_multi(\n        suggestion_models_to_update)\n\n\ndef get_commit_message_for_suggestion(\n    author_username: str, commit_message: str\n) -> str:\n    \"\"\"Returns a modified commit message for an accepted suggestion.\n\n    Args:\n        author_username: str. Username of the suggestion author.\n        commit_message: str. The original commit message submitted by the\n            suggestion author.\n\n    Returns:\n        str. The modified commit message to be used in the exploration commit\n        logs.\n    \"\"\"\n    return '%s %s: %s' % (\n        feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX,\n        author_username, commit_message)\n\n\ndef accept_suggestion(\n    suggestion_id: str,\n    reviewer_id: str,\n    commit_message: str,\n    review_message: str\n) -> None:\n    \"\"\"Accepts the suggestion with the given suggestion_id after validating it.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be accepted.\n        reviewer_id: str. The ID of the reviewer accepting the suggestion.\n        commit_message: str. The commit message.\n        review_message: str. The message provided by the reviewer while\n            accepting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n        Exception. The suggestion is not valid.\n        Exception. The commit message is empty.\n    \"\"\"\n    if not commit_message or not commit_message.strip():\n        raise Exception('Commit message cannot be empty.')\n\n    suggestion = get_suggestion_by_id(suggestion_id, strict=False)\n\n    if suggestion is None:\n        raise Exception(\n            'You cannot accept the suggestion with id %s because it does '\n            'not exist.' % (suggestion_id)\n        )\n    if suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s has already been accepted/'\n            'rejected.' % (suggestion_id)\n        )\n    suggestion.pre_accept_validate()\n    html_string = ''.join(suggestion.get_all_html_content_strings())\n    error_list = (\n        html_validation_service.\n        validate_math_tags_in_html_with_attribute_math_content(\n            html_string))\n    if len(error_list) > 0:\n        raise Exception(\n            'Invalid math tags found in the suggestion with id %s.' % (\n                suggestion.suggestion_id)\n        )\n\n    if suggestion.edited_by_reviewer:\n        commit_message = '%s (with edits)' % commit_message\n\n    suggestion.set_suggestion_status_to_accepted()\n    suggestion.set_final_reviewer_id(reviewer_id)\n\n    author_name = user_services.get_username(suggestion.author_id)\n    commit_message = get_commit_message_for_suggestion(\n        author_name, commit_message)\n    suggestion.accept(commit_message)\n\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review decreases by one, since this\n    # suggestion is no longer in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], -1)\n\n    feedback_services.create_message(\n        suggestion_id, reviewer_id, feedback_models.STATUS_CHOICES_FIXED,\n        None, review_message, should_send_email=False)\n\n    # When recording of scores is enabled, the author of the suggestion gets an\n    # increase in their score for the suggestion category.\n    if feconf.ENABLE_RECORDING_OF_SCORES:\n        user_id = suggestion.author_id\n        score_category = suggestion.score_category\n\n        # Get user proficiency domain object.\n        user_proficiency = _get_user_proficiency(user_id, score_category)\n\n        # Increment the score of the author due to their suggestion being\n        # accepted.\n        user_proficiency.increment_score(\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY\n        )\n\n        # Emails are sent to onboard new reviewers. These new reviewers are\n        # created when the score of the user passes the minimum score required\n        # to review.\n        if feconf.SEND_SUGGESTION_REVIEW_RELATED_EMAILS:\n            if user_proficiency.can_user_review_category() and (\n                    not user_proficiency.onboarding_email_sent):\n                email_manager.send_mail_to_onboard_new_reviewers(\n                    user_id, score_category\n                )\n                user_proficiency.mark_onboarding_email_as_sent()\n\n        # Need to update the corresponding user proficiency model after we\n        # updated the domain object.\n        _update_user_proficiency(user_proficiency)\n\n\ndef reject_suggestion(\n    suggestion_id: str, reviewer_id: str, review_message: str\n) -> None:\n    \"\"\"Rejects the suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestion.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n    \"\"\"\n\n    reject_suggestions([suggestion_id], reviewer_id, review_message)\n\n\ndef reject_suggestions(\n    suggestion_ids: List[str], reviewer_id: str, review_message: str\n) -> None:\n    \"\"\"Rejects the suggestions with the given suggestion_ids.\n\n    Args:\n        suggestion_ids: list(str). The ids of the suggestions to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestions.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestions.\n\n    Raises:\n        Exception. One or more of the suggestions has already been handled.\n    \"\"\"\n    suggestions_with_none = get_suggestions_by_ids(suggestion_ids)\n    suggestions = []\n\n    for index, suggestion in enumerate(suggestions_with_none):\n        if suggestion is None:\n            raise Exception(\n                'You cannot reject the suggestion with id %s because it does '\n                'not exist.' % (suggestion_ids[index])\n            )\n        suggestions.append(suggestion)\n        if suggestion.is_handled:\n            raise Exception(\n                'The suggestion with id %s has already been accepted/'\n                'rejected.' % (suggestion.suggestion_id)\n            )\n    if not review_message:\n        raise Exception('Review message cannot be empty.')\n\n    for suggestion in suggestions:\n        suggestion.set_suggestion_status_to_rejected()\n        suggestion.set_final_reviewer_id(reviewer_id)\n\n    _update_suggestions(suggestions)\n\n    # Update the community contribution stats so that the number of suggestions\n    # that are in review decreases, since these suggestions are no longer in\n    # review.\n    _update_suggestion_counts_in_community_contribution_stats(suggestions, -1)\n\n    feedback_services.create_messages(\n        suggestion_ids, reviewer_id, feedback_models.STATUS_CHOICES_IGNORED,\n        None, review_message, should_send_email=False\n    )\n\n\ndef auto_reject_question_suggestions_for_skill_id(skill_id: str) -> None:\n    \"\"\"Rejects all SuggestionAddQuestions with target ID matching the supplied\n    skill ID. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        skill_id: str. The skill ID corresponding to the target ID of the\n            SuggestionAddQuestion.\n    \"\"\"\n    suggestions = query_suggestions(\n        [\n            (\n                'suggestion_type',\n                feconf.SUGGESTION_TYPE_ADD_QUESTION),\n            ('target_id', skill_id)\n        ]\n    )\n\n    suggestion_ids: List[str] = []\n    for suggestion in suggestions:\n        # Narrowing down the type from BaseSuggestion to SuggestionAddQuestion.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionAddQuestion\n        )\n        suggestion_ids.append(suggestion.suggestion_id)\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.DELETED_SKILL_REJECT_MESSAGE)\n\n\ndef auto_reject_translation_suggestions_for_exp_ids(exp_ids: List[str]) -> None:\n    \"\"\"Rejects all translation suggestions with target IDs matching the\n    supplied exploration IDs. These suggestions are being rejected because\n    their corresponding exploration was removed from a story or the story was\n    deleted. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        exp_ids: list(str). The exploration IDs corresponding to the target IDs\n            of the translation suggestions.\n    \"\"\"\n    suggestion_ids = get_translation_suggestion_ids_with_exp_ids(exp_ids)\n\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.INVALID_STORY_REJECT_TRANSLATION_SUGGESTIONS_MSG)\n\n\ndef resubmit_rejected_suggestion(\n    suggestion_id: str,\n    summary_message: str,\n    author_id: str,\n    change: change_domain.BaseChange\n) -> None:\n    \"\"\"Resubmit a rejected suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the rejected suggestion.\n        summary_message: str. The message provided by the author to\n            summarize new suggestion.\n        author_id: str. The ID of the author creating the suggestion.\n        change: BaseChange. The new change to apply to the suggestion.\n\n    Raises:\n        Exception. The summary message is empty.\n        Exception. The suggestion has not been handled yet.\n        Exception. The suggestion has already been accepted.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not summary_message:\n        raise Exception('Summary message cannot be empty.')\n    if not suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s is not yet handled.' % (suggestion_id)\n        )\n    if suggestion.status == suggestion_models.STATUS_ACCEPTED:\n        raise Exception(\n            'The suggestion with id %s was accepted. '\n            'Only rejected suggestions can be resubmitted.' % (suggestion_id)\n        )\n\n    suggestion.pre_update_validate(change)\n    suggestion.change = change\n    suggestion.set_suggestion_status_to_in_review()\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one, since this suggestion is\n    # now back in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    feedback_services.create_message(\n        suggestion_id, author_id, feedback_models.STATUS_CHOICES_OPEN,\n        None, summary_message)\n\n\ndef get_all_suggestions_that_can_be_reviewed_by_user(\n    user_id: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns a list of suggestions which need to be reviewed, in categories\n    where the user has crossed the minimum score to review.\n\n    Args:\n        user_id: str. The ID of the user.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user is allowed\n        to review.\n    \"\"\"\n    score_categories = (\n        user_models.UserContributionProficiencyModel\n        .get_all_categories_where_user_can_review(user_id))\n\n    if len(score_categories) == 0:\n        return []\n\n    return ([\n        get_suggestion_from_model(s)\n        for s in suggestion_models.GeneralSuggestionModel\n        .get_in_review_suggestions_in_score_categories(\n            score_categories, user_id)\n    ])\n\n\ndef get_reviewable_translation_suggestions_by_offset(\n    user_id: str,\n    opportunity_summary_exp_ids: Optional[List[str]],\n    limit: Optional[int],\n    offset: int,\n    sort_key: Optional[str],\n    language: Optional[str] = None\n) -> Tuple[List[suggestion_registry.SuggestionTranslateContent], int]:\n    \"\"\"Returns a list of translation suggestions matching the\n     passed opportunity IDs which the user can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        opportunity_summary_exp_ids: list(str) or None.\n            The list of exploration IDs for which suggestions\n            are fetched. If the list is empty, no suggestions are\n            fetched. If the value is None, all reviewable\n            suggestions are fetched. If the list consists of some\n            valid number of ids, suggestions corresponding to the\n            IDs are fetched.\n        limit: int|None. The maximum number of results to return. If None,\n            all available results are returned.\n        sort_key: str|None. The key to sort the suggestions by.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n        language: str. ISO 639-1 language code for which to filter. If it is\n            None, all available languages will be returned.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of translation suggestions\n            which the supplied user is permitted to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    contribution_rights = user_services.get_user_contribution_rights(\n        user_id)\n    language_codes = (\n        contribution_rights.can_review_translation_for_language_codes)\n\n    # No language means all languages.\n    if language is not None:\n        language_codes = [language] if language in language_codes else []\n\n    # The user cannot review any translations, so return early.\n    if len(language_codes) == 0:\n        return [], offset\n\n    in_review_translation_suggestions: Sequence[\n        suggestion_models.GeneralSuggestionModel\n    ] = []\n    next_offset = offset\n    if opportunity_summary_exp_ids is None:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit,\n                offset,\n                user_id,\n                sort_key,\n                language_codes))\n    elif len(opportunity_summary_exp_ids) > 0:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit,\n                offset,\n                user_id,\n                sort_key,\n                language_codes,\n                opportunity_summary_exp_ids))\n\n    translation_suggestions = []\n    for suggestion_model in in_review_translation_suggestions:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionTranslateContent.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionTranslateContent\n        )\n        translation_suggestions.append(suggestion)\n\n    return translation_suggestions, next_offset\n\n\ndef get_reviewable_question_suggestions_by_offset(\n    user_id: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[List[suggestion_registry.SuggestionAddQuestion], int]:\n    \"\"\"Returns a list of question suggestions which the user\n       can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n        sort_key: str|None. The key to sort the suggestions by.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of question suggestions which\n            the given user is allowed to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    suggestions, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_question_suggestions_by_offset(\n            limit, offset, user_id, sort_key))\n\n    question_suggestions = []\n    for suggestion_model in suggestions:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionAddQuestion.\n        assert isinstance(suggestion, suggestion_registry.SuggestionAddQuestion)\n        question_suggestions.append(suggestion)\n\n    return question_suggestions, next_offset\n\n\ndef get_question_suggestions_waiting_longest_for_review() -> List[\n    suggestion_registry.SuggestionAddQuestion\n]:\n    \"\"\"Returns MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS number\n    of question suggestions, sorted in descending order by review wait time.\n\n    Returns:\n        list(Suggestion). A list of question suggestions, sorted in descending\n        order based on how long the suggestions have been waiting for review.\n    \"\"\"\n    question_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_waiting_longest_for_review()\n    )\n\n    question_suggestion = []\n    for suggestion_model in question_suggestion_models:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion to\n        # SuggestionAddQuestion.\n        assert isinstance(suggestion, suggestion_registry.SuggestionAddQuestion)\n        question_suggestion.append(suggestion)\n    return question_suggestion\n\n\ndef get_translation_suggestions_waiting_longest_for_review(\n    language_code: str\n) -> List[suggestion_registry.SuggestionTranslateContent]:\n    \"\"\"Returns MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS\n    number of translation suggestions in the specified language code,\n    sorted in descending order by review wait time.\n\n    Args:\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions, sorted in\n        descending order based on how long the suggestions have been waiting\n        for review.\n    \"\"\"\n    translation_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                language_code)\n    )\n\n    translation_suggestions = []\n    for suggestion_model in translation_suggestion_models:\n        suggestion = get_suggestion_from_model(suggestion_model)\n        # Here, we are narrowing down the type from BaseSuggestion\n        # to SuggestionTranslateContent.\n        assert isinstance(\n            suggestion, suggestion_registry.SuggestionTranslateContent\n        )\n        translation_suggestions.append(suggestion)\n\n    return translation_suggestions\n\n\ndef get_translation_suggestions_in_review_by_exploration(\n    exp_id: str, language_code: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns translation suggestions in review by exploration ID.\n\n    Args:\n        exp_id: str. Exploration ID.\n        language_code: str. Language code.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id == exp_id.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestions_in_review_with_exp_id(\n            exp_id, language_code)\n    )\n    return [\n        get_suggestion_from_model(model)\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_translation_suggestions_in_review_by_exp_ids(\n    exp_ids: List[str], language_code: str\n) -> List[Optional[suggestion_registry.BaseSuggestion]]:\n    \"\"\"Returns translation suggestions in review by exploration ID and language\n    code.\n\n    Args:\n        exp_ids: list(str). Exploration IDs matching the target ID of the\n            translation suggestions.\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id in exp_ids and language_code == language_code, or None if\n        suggestion model does not exists.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_translation_suggestions_by_exp_ids(\n            exp_ids, language_code)\n    )\n    return [\n        get_suggestion_from_model(model) if model else None\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_suggestions_with_translatable_explorations(\n    suggestions: Sequence[suggestion_registry.SuggestionTranslateContent]\n) -> Sequence[suggestion_registry.SuggestionTranslateContent]:\n    \"\"\"Filters the supplied suggestions for those suggestions that have\n    translatable exploration content. That is, the following are true:\n    - The suggestion's change content corresponds to an existing exploration\n    content card.\n    - The suggestion's corresponding exploration allows edits.\n\n    Args:\n        suggestions: list(Suggestion). List of translation suggestions to\n            filter.\n\n    Returns:\n        list(Suggestion). List of filtered translation suggestions.\n    \"\"\"\n\n    def _has_translatable_exploration(\n        suggestion: suggestion_registry.SuggestionTranslateContent,\n        suggestion_exp_id_to_exp: Dict[str, exp_domain.Exploration]\n    ) -> bool:\n        \"\"\"Returns whether the supplied suggestion corresponds to a translatable\n        exploration content card.\n\n        Args:\n            suggestion: Suggestion. Translation suggestion domain object to\n                check.\n            suggestion_exp_id_to_exp: dict(str, Exploration). Dictionary mapping\n                suggestion target exploration IDs to their corresponding\n                Exploration domain objects.\n\n        Returns:\n            bool. Whether the supplied suggestion corresponds to a translatable\n            exploration content card.\n        \"\"\"\n        exploration = suggestion_exp_id_to_exp[suggestion.target_id]\n        content_id_exists = False\n\n        # Checks whether the suggestion's change content still exists in the\n        # corresponding exploration.\n        # For more details, see https://github.com/oppia/oppia/issues/14339.\n        if suggestion.change.state_name in exploration.states:\n            content_id_exists = exploration.states[\n                suggestion.change.state_name].has_content_id(\n                    suggestion.change.content_id)\n        return content_id_exists and exploration.edits_allowed\n\n    suggestion_exp_ids = {\n        suggestion.target_id for suggestion in suggestions}\n    suggestion_exp_id_to_exp = exp_fetchers.get_multiple_explorations_by_id(\n        list(suggestion_exp_ids))\n    return list(filter(\n        lambda suggestion: _has_translatable_exploration(\n            suggestion, suggestion_exp_id_to_exp),\n        suggestions))\n\n\ndef _get_plain_text_from_html_content_string(html_content_string: str) -> str:\n    \"\"\"Retrieves the plain text from the given html content string. RTE element\n    occurrences in the html are replaced by their corresponding rte component\n    name, capitalized in square brackets.\n    eg: <p>Sample1 <oppia-noninteractive-math></oppia-noninteractive-math>\n        Sample2 </p> will give as output: Sample1 [Math] Sample2.\n    Note: similar logic exists in the frontend in format-rte-preview.filter.ts.\n\n    Args:\n        html_content_string: str. The content html string to convert to plain\n            text.\n\n    Returns:\n        str. The plain text string from the given html content string.\n    \"\"\"\n\n    def _replace_rte_tag(rte_tag: Match[str]) -> str:\n        \"\"\"Replaces all of the <oppia-noninteractive-**> tags with their\n        corresponding rte component name in square brackets.\n\n        Args:\n            rte_tag: MatchObject. A matched object that contins the\n                oppia-noninteractive rte tags.\n\n        Returns:\n            str. The string to replace the rte tags with.\n        \"\"\"\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_string = rte_tag.group(0)\n        # Get the name of the rte tag. The hyphen is there as an optional\n        # matching character to cover the case where the name of the rte\n        # component is more than one word.\n        rte_tag_name = re.search(\n            r'oppia-noninteractive-(\\w|-)+', rte_tag_string)\n        # Here, rte_tag_name is always going to exists because the string\n        # that was passed in this function is always going to contain\n        # `<oppia-noninteractive>` substring. So, to just rule out the\n        # possibility of None for mypy type checking. we used assertion here.\n        assert rte_tag_name is not None\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_name_string = rte_tag_name.group(0)\n        # Get the name of the rte component.\n        rte_component_name_string_list = rte_tag_name_string.split('-')[2:]\n        # If the component name is more than word, connect the words with spaces\n        # to create a single string.\n        rte_component_name_string = ' '.join(rte_component_name_string_list)\n        # Captialize each word in the string.\n        capitalized_rte_component_name_string = (\n            rte_component_name_string.title())\n        formatted_rte_component_name_string = ' [%s] ' % (\n            capitalized_rte_component_name_string)\n        return formatted_rte_component_name_string\n\n    # Replace all the <oppia-noninteractive-**> tags with their rte component\n    # names capitalized in square brackets.\n    html_content_string_with_rte_tags_replaced = re.sub(\n        r'<oppia-noninteractive-[^>]+>(.*?)</oppia-noninteractive-[^>]+>',\n        _replace_rte_tag, html_content_string)\n    # Get rid of all of the other html tags.\n    plain_text = html_cleaner.strip_html_tags(\n        html_content_string_with_rte_tags_replaced)\n    # Remove trailing and leading whitespace and ensure that all words are\n    # separated by a single space.\n    plain_text_without_contiguous_whitespace = ' '.join(plain_text.split())\n    return plain_text_without_contiguous_whitespace\n\n\ndef create_reviewable_suggestion_email_info_from_suggestion(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> suggestion_registry.ReviewableSuggestionEmailInfo:\n    \"\"\"Creates an object with the key information needed to notify reviewers or\n    admins that the given suggestion needs review.\n\n    Args:\n        suggestion: Suggestion. The suggestion used to create the\n            ReviewableSuggestionEmailInfo object. Note that the suggestion's\n            status must be in review.\n\n    Returns:\n        ReviewableSuggestionEmailInfo. The corresponding reviewable suggestion\n        email info.\n\n    Raises:\n        Exception. The suggestion type must be offered on the Contributor\n            Dashboard.\n    \"\"\"\n    if suggestion.suggestion_type not in (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS):\n        raise Exception(\n            'Expected suggestion type to be offered on the Contributor '\n            'Dashboard, received: %s.' % suggestion.suggestion_type)\n\n    # Retrieve the html content that is emphasized on the Contributor Dashboard\n    # pages. This content is what stands out for each suggestion when a user\n    # views a list of suggestions.\n    get_html_representing_suggestion = (\n        SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n            suggestion.suggestion_type]\n    )\n    plain_text = _get_plain_text_from_html_content_string(\n        get_html_representing_suggestion(suggestion))\n    # Here, suggestion can only be of `translate_content` or `add_question`\n    # type and in both suggestions language_code cannot be None. So, to\n    # just narrow down type from Optional[str] to str we used assertion here.\n    assert suggestion.language_code is not None\n    return suggestion_registry.ReviewableSuggestionEmailInfo(\n        suggestion.suggestion_type, suggestion.language_code, plain_text,\n        suggestion.last_updated\n    )\n\n\ndef get_suggestions_waiting_for_review_info_to_notify_reviewers(\n    reviewer_ids: List[str]\n) -> List[List[suggestion_registry.ReviewableSuggestionEmailInfo]]:\n    \"\"\"For each user, returns information that will be used to notify reviewers\n    about the suggestions waiting longest for review, that the reviewer has\n    permissions to review.\n\n    Args:\n        reviewer_ids: list(str). A list of the reviewer user ids to notify.\n\n    Returns:\n        list(list(ReviewableSuggestionEmailInfo)). A list of suggestion\n        email content info objects for each reviewer. Each suggestion email\n        content info object contains the type of the suggestion, the language\n        of the suggestion, the suggestion content (question/translation) and\n        the date that the suggestion was submitted for review. For each user\n        the suggestion email content info objects are sorted in descending order\n        based on review wait time.\n    \"\"\"\n    # Get each reviewer's review permissions.\n    users_contribution_rights = user_services.get_users_contribution_rights(\n        reviewer_ids\n    )\n\n    # Get the question suggestions that have been waiting longest for review.\n    question_suggestions = (\n        get_question_suggestions_waiting_longest_for_review()\n    )\n\n    # Create a dictionary to keep track of the translation suggestions that\n    # have been waiting longest for review for each language code.\n    translation_suggestions_by_lang_code_dict = {}\n\n    reviewers_reviewable_suggestion_infos = []\n\n    for user_contribution_rights in users_contribution_rights:\n        # Use a min heap because then the suggestions that have been waiting the\n        # longest for review (earliest review submission date) are automatically\n        # efficiently sorted.\n        suggestions_waiting_longest_heap: List[\n            Tuple[datetime.datetime, suggestion_registry.BaseSuggestion]\n        ] = []\n        if user_contribution_rights.can_review_questions:\n            for question_suggestion in question_suggestions:\n                # Break early because we only want the top\n                # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER number of\n                # suggestions.\n                if len(suggestions_waiting_longest_heap) == (\n                        MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                    break\n                # We can't include suggestions that were authored by the\n                # reviewer because reviewers aren't allowed to review their own\n                # suggestions.\n                if question_suggestion.author_id != user_contribution_rights.id:\n                    heapq.heappush(suggestions_waiting_longest_heap, (\n                        question_suggestion.last_updated, question_suggestion))\n\n        if user_contribution_rights.can_review_translation_for_language_codes:\n            for language_code in (\n                    user_contribution_rights\n                    .can_review_translation_for_language_codes):\n                # Get a list of the translation suggestions in the language code\n                # from the datastore if we haven't already gotten them.\n                if language_code not in (\n                        translation_suggestions_by_lang_code_dict):\n                    translation_suggestions_by_lang_code_dict[language_code] = (\n                        get_translation_suggestions_waiting_longest_for_review(\n                            language_code\n                        )\n                    )\n\n                translation_suggestions = (\n                    translation_suggestions_by_lang_code_dict[language_code]\n                )\n                for translation_suggestion in translation_suggestions:\n                    if len(suggestions_waiting_longest_heap) == (\n                            MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                        # The shortest review wait time corresponds to the most\n                        # recent review submission date, which is the max of\n                        # the heap.\n                        most_recent_review_submission = max(\n                            suggestions_waiting_longest_heap)[0]\n                        # If the review submission date for the translation\n                        # suggestion is more recent than the most recent\n                        # submission date so far, we can exit early.\n                        if translation_suggestion.last_updated > (\n                                most_recent_review_submission):\n                            break\n                    # Reviewers can never review their own suggestions.\n                    if translation_suggestion.author_id != (\n                            user_contribution_rights.id):\n                        heapq.heappush(suggestions_waiting_longest_heap, (\n                            translation_suggestion.last_updated,\n                            translation_suggestion))\n\n        # Get the key information from each suggestion that will be used to\n        # email reviewers.\n        reviewer_reviewable_suggestion_infos = []\n        for _ in range(MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n            if len(suggestions_waiting_longest_heap) == 0:\n                break\n            _, suggestion = heapq.heappop(suggestions_waiting_longest_heap)\n            reviewer_reviewable_suggestion_infos.append(\n                create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            )\n        reviewers_reviewable_suggestion_infos.append(\n            reviewer_reviewable_suggestion_infos\n        )\n\n    return reviewers_reviewable_suggestion_infos\n\n\ndef get_submitted_suggestions(\n    user_id: str, suggestion_type: str\n) -> List[suggestion_registry.BaseSuggestion]:\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of the suggestion.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user has\n        submitted.\n    \"\"\"\n    return ([\n        get_suggestion_from_model(s) for s in (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_of_suggestion_type(\n                suggestion_type, user_id))\n    ])\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: Literal['add_question'],\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[\n    Sequence[suggestion_registry.SuggestionAddQuestion], int\n]: ...\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: Literal['translate_content'],\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[\n    Sequence[suggestion_registry.SuggestionTranslateContent], int\n]: ...\n\n\n@overload\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[Sequence[suggestion_registry.BaseSuggestion], int]: ...\n\n\ndef get_submitted_suggestions_by_offset(\n    user_id: str,\n    suggestion_type: str,\n    limit: int,\n    offset: int,\n    sort_key: Optional[str]\n) -> Tuple[Sequence[suggestion_registry.BaseSuggestion], int]:\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of suggestion.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning\n            of all results matching the query.\n        sort_key: str|None. The key to sort the suggestions by.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of suggestions of the supplied\n                type which the supplied user has submitted.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    submitted_suggestion_models, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit,\n                offset,\n                suggestion_type,\n                user_id,\n                sort_key))\n    suggestions = ([\n        get_suggestion_from_model(s) for s in submitted_suggestion_models\n    ])\n    return suggestions, next_offset\n\n\ndef get_info_about_suggestions_waiting_too_long_for_review() -> List[\n    suggestion_registry.ReviewableSuggestionEmailInfo\n]:\n    \"\"\"Gets the information about the suggestions that have been waiting longer\n    than suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days\n    for a review on the Contributor Dashboard. There can be information about at\n    most suggestion_models.MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN suggestions.\n    The information about the suggestions are returned in descending order by\n    the suggestion's review wait time.\n\n    Returns:\n        list(ReviewableSuggestionEmailContentInfo). A list of reviewable\n        suggestion email content info objects that represent suggestions that\n        have been waiting too long for a review. Each object contains the type\n        of the suggestion, the language of the suggestion, the suggestion\n        content (question/translation), and the date that the suggestion was\n        submitted for review. The objects are sorted in descending order based\n        on review wait time.\n    \"\"\"\n    suggestions_waiting_too_long_for_review = [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_suggestions_waiting_too_long_for_review())\n    ]\n    return [\n        create_reviewable_suggestion_email_info_from_suggestion(\n            suggestion) for suggestion in\n        suggestions_waiting_too_long_for_review\n    ]\n\n\ndef get_user_proficiency_from_model(\n    user_proficiency_model: user_models.UserContributionProficiencyModel\n) -> user_domain.UserContributionProficiency:\n    \"\"\"Converts the given UserContributionProficiencyModel to a\n    UserContributionProficiency domain object.\n\n    Args:\n        user_proficiency_model: UserContributionProficiencyModel.\n            UserContributionProficiencyModel to be converted to\n            a UserContributionProficiency domain object.\n\n    Returns:\n        UserContributionProficiency. The corresponding\n        UserContributionProficiency domain object.\n    \"\"\"\n    return user_domain.UserContributionProficiency(\n        user_proficiency_model.user_id, user_proficiency_model.score_category,\n        user_proficiency_model.score,\n        user_proficiency_model.onboarding_email_sent\n    )\n\n\ndef _update_user_proficiency(\n    user_proficiency: user_domain.UserContributionProficiency\n) -> None:\n    \"\"\"Updates the user_proficiency.\n\n    Args:\n        user_proficiency: UserContributionProficiency. The user proficiency to\n            be updated.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_proficiency.user_id, user_proficiency.score_category\n    )\n\n    if user_proficiency_model is not None:\n        user_proficiency_model.user_id = user_proficiency.user_id\n        user_proficiency_model.score_category = user_proficiency.score_category\n        user_proficiency_model.score = user_proficiency.score\n        user_proficiency_model.onboarding_email_sent = (\n            user_proficiency.onboarding_email_sent\n        )\n\n        user_proficiency_model.update_timestamps()\n        user_proficiency_model.put()\n\n    else:\n        user_models.UserContributionProficiencyModel.create(\n            user_proficiency.user_id, user_proficiency.score_category,\n            user_proficiency.score, user_proficiency.onboarding_email_sent)\n\n\ndef get_all_scores_of_user(user_id: str) -> Dict[str, int]:\n    \"\"\"Gets all scores for a given user.\n\n    Args:\n        user_id: str. The id of the user.\n\n    Returns:\n        dict. A dict containing all the scores of the user. The keys of the dict\n        are the score categories and the values are the scores.\n    \"\"\"\n    scores = {}\n    for model in (\n            user_models.UserContributionProficiencyModel.get_all_scores_of_user(\n                user_id)):\n        scores[model.score_category] = model.score\n\n    return scores\n\n\ndef can_user_review_category(\n    user_id: str, score_category: str\n) -> bool:\n    \"\"\"Checks if user can review suggestions in category score_category.\n    If the user has score above the minimum required score, then the user is\n    allowed to review.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category to check the user's score.\n\n    Returns:\n        bool. Whether the user can review suggestions under category\n        score_category.\n    \"\"\"\n    user_proficiency = _get_user_proficiency(user_id, score_category)\n    return user_proficiency.can_user_review_category()\n\n\ndef get_all_user_ids_who_are_allowed_to_review(\n    score_category: str\n) -> List[str]:\n    \"\"\"Gets all user_ids of users who are allowed to review (as per their\n    scores) suggestions to a particular category.\n\n    Args:\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        list(str). All user_ids of users who are allowed to review in the given\n        category.\n    \"\"\"\n    return [\n        model.user_id for model in user_models.UserContributionProficiencyModel\n        .get_all_users_with_score_above_minimum_for_category(score_category)\n    ]\n\n\ndef _get_user_proficiency(\n    user_id: str, score_category: str\n) -> user_domain.UserContributionProficiency:\n    \"\"\"Gets the user proficiency model from storage and creates the\n    corresponding user proficiency domain object if the model exists. If the\n    model does not exist a user proficiency domain object with the given\n    user_id and score category is created with the initial score and email\n    values.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        UserContributionProficiency. The user proficiency object.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_id, score_category)\n\n    if user_proficiency_model is not None:\n        return get_user_proficiency_from_model(user_proficiency_model)\n\n    return user_domain.UserContributionProficiency(\n        user_id, score_category, 0, False)\n\n\ndef check_can_resubmit_suggestion(suggestion_id: str, user_id: str) -> bool:\n    \"\"\"Checks whether the given user can resubmit the suggestion.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n        user_id: str. The ID of the user.\n\n    Returns:\n        bool. Whether the user can resubmit the suggestion.\n    \"\"\"\n\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    return suggestion.author_id == user_id\n\n\ndef create_community_contribution_stats_from_model(\n    community_contribution_stats_model: (\n        suggestion_models.CommunityContributionStatsModel\n    )\n) -> suggestion_registry.CommunityContributionStats:\n    \"\"\"Creates a domain object that represents the community contribution\n    stats from the model given. Note that each call to this function returns\n    a new domain object, but the data copied into the domain object comes from\n    a single, shared source.\n\n    Args:\n        community_contribution_stats_model: CommunityContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.CommunityContributionStats(\n        (\n            community_contribution_stats_model\n            .translation_reviewer_counts_by_lang_code\n        ),\n        (\n            community_contribution_stats_model\n            .translation_suggestion_counts_by_lang_code\n        ),\n        community_contribution_stats_model.question_reviewer_count,\n        community_contribution_stats_model.question_suggestion_count\n    )\n\n\ndef get_community_contribution_stats(\n) -> suggestion_registry.CommunityContributionStats:\n    \"\"\"Gets the CommunityContributionStatsModel and converts it into the\n    corresponding domain object that represents the community contribution\n    stats. Note that there is only ever one instance of this model and if the\n    model doesn't exist yet, it will be created.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    community_contribution_stats_model = (\n        suggestion_models.CommunityContributionStatsModel.get()\n    )\n\n    return create_community_contribution_stats_from_model(\n        community_contribution_stats_model)\n\n\ndef create_translation_contribution_stats_from_model(\n    translation_contribution_stats_model: (\n        suggestion_models.TranslationContributionStatsModel\n    )\n) -> suggestion_registry.TranslationContributionStats:\n    \"\"\"Creates a domain object representing the supplied\n    TranslationContributionStatsModel.\n\n    Args:\n        translation_contribution_stats_model: TranslationContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        TranslationContributionStats. The corresponding\n        TranslationContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.TranslationContributionStats(\n        translation_contribution_stats_model.language_code,\n        translation_contribution_stats_model.contributor_user_id,\n        translation_contribution_stats_model.topic_id,\n        translation_contribution_stats_model.submitted_translations_count,\n        translation_contribution_stats_model.submitted_translation_word_count,\n        translation_contribution_stats_model.accepted_translations_count,\n        (\n            translation_contribution_stats_model\n            .accepted_translations_without_reviewer_edits_count\n        ),\n        translation_contribution_stats_model.accepted_translation_word_count,\n        translation_contribution_stats_model.rejected_translations_count,\n        translation_contribution_stats_model.rejected_translation_word_count,\n        set(translation_contribution_stats_model.contribution_dates)\n    )\n\n\ndef get_all_translation_contribution_stats(\n    user_id: str\n) -> List[suggestion_registry.TranslationContributionStats]:\n    \"\"\"Gets all TranslationContributionStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(TranslationContributionStats). TranslationContributionStats domain\n        objects corresponding to the supplied user.\n    \"\"\"\n    translation_contribution_stats_models = (\n        suggestion_models.TranslationContributionStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        create_translation_contribution_stats_from_model(model)\n        for model in translation_contribution_stats_models\n    ]\n\n\ndef get_suggestion_types_that_need_reviewers() -> Dict[str, Set[str]]:\n    \"\"\"Uses the community contribution stats to determine which suggestion\n    types need more reviewers. Suggestion types need more reviewers if the\n    number of suggestions in that type divided by the number of reviewers is\n    greater than config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n    Returns:\n        dict. A dictionary that uses the presence of its keys to indicate which\n        suggestion types need more reviewers. The possible key values are the\n        suggestion types listed in\n        feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES. The dictionary\n        values for each suggestion type are the following:\n        - for question suggestions the value is an empty set\n        - for translation suggestions the value is a nonempty set containing the\n            language codes of the translation suggestions that need more\n            reviewers.\n    \"\"\"\n    suggestion_types_needing_reviewers: Dict[str, Set[str]] = {}\n    stats = get_community_contribution_stats()\n\n    language_codes_that_need_reviewers = (\n        stats.get_translation_language_codes_that_need_reviewers()\n    )\n    if len(language_codes_that_need_reviewers) != 0:\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT] = (\n                language_codes_that_need_reviewers\n            )\n\n    if stats.are_question_reviewers_needed():\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_ADD_QUESTION] = set()\n\n    return suggestion_types_needing_reviewers\n\n\n@transaction_services.run_in_transaction_wrapper\ndef _update_suggestion_counts_in_community_contribution_stats_transactional(\n    suggestions: List[suggestion_registry.BaseSuggestion], amount: int\n) -> None:\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. Note that this method should only ever be\n    called in a transaction.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    stats_model = suggestion_models.CommunityContributionStatsModel.get()\n    for suggestion in suggestions:\n        if suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT):\n            if suggestion.language_code not in (\n                    stats_model.translation_suggestion_counts_by_lang_code):\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] = amount\n            else:\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] += amount\n                # Remove the language code from the dict if the count reaches\n                # zero.\n                if stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code] == 0:\n                    del stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code]\n        elif suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_ADD_QUESTION):\n            stats_model.question_suggestion_count += amount\n\n    # Create a community contribution stats object to validate the updates.\n    stats = create_community_contribution_stats_from_model(stats_model)\n    stats.validate()\n\n    stats_model.update_timestamps()\n    stats_model.put()\n\n    logging.info('Updated translation_suggestion_counts_by_lang_code: %s' % (\n        stats_model.translation_suggestion_counts_by_lang_code))\n\n\ndef _update_suggestion_counts_in_community_contribution_stats(\n    suggestions: Sequence[suggestion_registry.BaseSuggestion], amount: int\n) -> None:\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. The GET and PUT is done in a single\n    transaction to avoid loss of updates that come in rapid succession.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    _update_suggestion_counts_in_community_contribution_stats_transactional(\n        suggestions, amount)\n\n\ndef update_translation_suggestion(\n    suggestion_id: str, translation_html: str\n) -> None:\n    \"\"\"Updates the translation_html of a suggestion with the given\n    suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        translation_html: str. The new translation_html string.\n\n    Raises:\n        Exception. Expected SuggestionTranslateContent suggestion but found\n            different suggestion.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not isinstance(\n        suggestion, suggestion_registry.SuggestionTranslateContent\n    ):\n        raise Exception(\n            'Expected SuggestionTranslateContent suggestion but found: %s.'\n            % type(suggestion).__name__\n        )\n    suggestion.change.translation_html = (\n        html_cleaner.clean(translation_html)\n        if isinstance(translation_html, str)\n        else translation_html\n    )\n    suggestion.edited_by_reviewer = True\n    suggestion.pre_update_validate(suggestion.change)\n    _update_suggestion(suggestion)\n\n\ndef update_question_suggestion(\n    suggestion_id: str,\n    skill_difficulty: float,\n    question_state_data: state_domain.StateDict\n) -> Optional[suggestion_registry.BaseSuggestion]:\n    \"\"\"Updates skill_difficulty and question_state_data of a suggestion with\n    the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        skill_difficulty: double. The difficulty level of the question.\n        question_state_data: obj. Details of the question.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n\n    Raises:\n        Exception. Expected SuggestionAddQuestion suggestion but found\n            different suggestion.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not isinstance(\n        suggestion, suggestion_registry.SuggestionAddQuestion\n    ):\n        raise Exception(\n            'Expected SuggestionAddQuestion suggestion but found: %s.'\n            % type(suggestion).__name__\n        )\n    question_dict = suggestion.change.question_dict\n    new_change_obj = (\n        question_domain.CreateNewFullySpecifiedQuestionSuggestionCmd(\n            {\n                'cmd': suggestion.change.cmd,\n                'question_dict': {\n                    'question_state_data': question_state_data,\n                    'language_code': question_dict['language_code'],\n                    'question_state_data_schema_version': (\n                        question_dict[\n                            'question_state_data_schema_version']),\n                    'linked_skill_ids': question_dict['linked_skill_ids'],\n                    'inapplicable_skill_misconception_ids': (\n                        question_dict[\n                            'inapplicable_skill_misconception_ids'])\n                },\n                'skill_id': suggestion.change.skill_id,\n                'skill_difficulty': skill_difficulty\n            }\n        )\n    )\n    suggestion.pre_update_validate(new_change_obj)\n    suggestion.edited_by_reviewer = True\n    suggestion.change = new_change_obj\n\n    _update_suggestion(suggestion)\n\n    return suggestion\n\n\ndef _create_translation_review_stats_from_model(\n    translation_review_stats_model: (\n        suggestion_models.TranslationReviewStatsModel\n    )\n) -> suggestion_registry.TranslationReviewStats:\n    \"\"\"Creates a domain object representing the supplied\n    TranslationReviewStatsModel.\n\n    Args:\n        translation_review_stats_model: TranslationReviewStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        TranslationReviewStats. The corresponding TranslationReviewStats domain\n        object.\n    \"\"\"\n    return suggestion_registry.TranslationReviewStats(\n        translation_review_stats_model.language_code,\n        translation_review_stats_model.reviewer_user_id,\n        translation_review_stats_model.topic_id,\n        translation_review_stats_model.reviewed_translations_count,\n        translation_review_stats_model.reviewed_translation_word_count,\n        translation_review_stats_model.accepted_translations_count,\n        translation_review_stats_model.accepted_translation_word_count,\n        (\n            translation_review_stats_model\n            .accepted_translations_with_reviewer_edits_count),\n        translation_review_stats_model.first_contribution_date,\n        translation_review_stats_model.last_contribution_date\n    )\n\n\ndef _create_question_contribution_stats_from_model(\n    question_contribution_stats_model: (\n        suggestion_models.QuestionContributionStatsModel\n    )\n) -> suggestion_registry.QuestionContributionStats:\n    \"\"\"Creates a domain object representing the supplied\n    QuestionContributionStatsModel.\n\n    Args:\n        question_contribution_stats_model: QuestionContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        QuestionContributionStats. The corresponding QuestionContributionStats\n        domain object.\n    \"\"\"\n    return suggestion_registry.QuestionContributionStats(\n        question_contribution_stats_model.contributor_user_id,\n        question_contribution_stats_model.topic_id,\n        question_contribution_stats_model.submitted_questions_count,\n        question_contribution_stats_model.accepted_questions_count,\n        (\n            question_contribution_stats_model\n            .accepted_questions_without_reviewer_edits_count),\n        question_contribution_stats_model.first_contribution_date,\n        question_contribution_stats_model.last_contribution_date\n    )\n\n\ndef _create_question_review_stats_from_model(\n    question_review_stats_model: (\n        suggestion_models.QuestionReviewStatsModel\n    )\n) -> suggestion_registry.QuestionReviewStats:\n    \"\"\"Creates a domain object representing the supplied\n    QuestionReviewStatsModel.\n\n    Args:\n        question_review_stats_model: QuestionReviewStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        QuestionReviewStats. The corresponding QuestionReviewStats domain\n        object.\n    \"\"\"\n    return suggestion_registry.QuestionReviewStats(\n        question_review_stats_model.reviewer_user_id,\n        question_review_stats_model.topic_id,\n        question_review_stats_model.reviewed_questions_count,\n        question_review_stats_model.accepted_questions_count,\n        (\n            question_review_stats_model\n            .accepted_questions_with_reviewer_edits_count),\n        question_review_stats_model.first_contribution_date,\n        question_review_stats_model.last_contribution_date\n    )\n\n\ndef get_all_translation_review_stats(\n    user_id: str\n) -> List[suggestion_registry.TranslationReviewStats]:\n    \"\"\"Gets all TranslationReviewStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(TranslationReviewStats). TranslationReviewStats domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    translation_review_stats_models = (\n        suggestion_models.TranslationReviewStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_translation_review_stats_from_model(model)\n        for model in translation_review_stats_models\n    ]\n\n\ndef get_all_question_contribution_stats(\n    user_id: str\n) -> List[suggestion_registry.QuestionContributionStats]:\n    \"\"\"Gets all QuestionContributionStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(QuestionContributionStats). QuestionContributionStats domain\n        objects corresponding to the supplied user.\n    \"\"\"\n    question_contribution_stats_models = (\n        suggestion_models.QuestionContributionStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_question_contribution_stats_from_model(model)\n        for model in question_contribution_stats_models\n    ]\n\n\ndef get_all_question_review_stats(\n    user_id: str\n) -> List[suggestion_registry.QuestionReviewStats]:\n    \"\"\"Gets all QuestionReviewStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(QuestionReviewStats). QuestionReviewStats domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    question_review_stats_models = (\n        suggestion_models.QuestionReviewStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        _create_question_review_stats_from_model(model)\n        for model in question_review_stats_models\n    ]\n\n\n# TODO(#16019): Pre-fetching and caching of stats data should be done.\ndef get_all_contributor_stats(\n    user_id: str\n) -> suggestion_registry.ContributorStatsSummary:\n    \"\"\"Gets ContributorStatsSummary corresponding to the supplied user.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        ContributorStatsSummary. ContributorStatsSummary domain objects\n        corresponding to the supplied user.\n    \"\"\"\n    translation_contribution_stats = get_all_translation_contribution_stats(\n        user_id)\n    translation_review_stats = get_all_translation_review_stats(user_id)\n    question_contribution_stats = get_all_question_contribution_stats(user_id)\n    question_review_stats = get_all_question_review_stats(user_id)\n\n    return suggestion_registry.ContributorStatsSummary(\n        user_id,\n        translation_contribution_stats,\n        question_contribution_stats,\n        translation_review_stats,\n        question_review_stats)\n\n\ndef _update_translation_contribution_stats_models(\n    translation_contribution_stats: List[\n        suggestion_registry.TranslationContributionStats\n    ]\n) -> None:\n    \"\"\"Updates TranslationContributionStatsModel models for given translation\n    contribution stats.\n\n    Args:\n        translation_contribution_stats: list(TranslationContributionStats).\n            A list of TranslationContributionStats domain objects.\n\n    Raises:\n        Exception. Language is None.\n        Exception. Contributor user ID is None.\n        Exception. Topic ID is None.\n    \"\"\"\n    stats_dict = {}\n    for stat in translation_contribution_stats:\n        if stat.language_code is None:\n            raise Exception('Language code should not be None.')\n        if stat.contributor_user_id is None:\n            raise Exception('Contributor user ID should not be None.')\n        if stat.topic_id is None:\n            raise Exception('Topic ID should not be None.')\n        stat_id = (\n            suggestion_models.TranslationContributionStatsModel.construct_id(\n                stat.language_code,\n                stat.contributor_user_id,\n                stat.topic_id)\n        )\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_translation_contribution_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.TranslationContributionStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.submitted_translations_count = (\n            stat.submitted_translations_count)\n        stats_model.submitted_translation_word_count = (\n            stat.submitted_translation_word_count)\n        stats_model.accepted_translations_count = (\n            stat.accepted_translations_count)\n        stats_model.accepted_translations_without_reviewer_edits_count = (\n            stat.accepted_translations_without_reviewer_edits_count)\n        stats_model.accepted_translation_word_count = (\n            stat.accepted_translation_word_count)\n        stats_model.rejected_translations_count = (\n            stat.rejected_translations_count)\n        stats_model.rejected_translation_word_count = (\n            stat.rejected_translation_word_count)\n        stats_model.contribution_dates = stat.contribution_dates\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.TranslationContributionStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.TranslationContributionStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_translation_review_stats_models(\n    translation_review_stats: List[\n        suggestion_registry.TranslationReviewStats\n    ]\n) -> None:\n    \"\"\"Updates TranslationReviewStatsModel models for given translation\n    review stats.\n\n    Args:\n        translation_review_stats: list(TranslationReviewStats). A list of\n            TranslationReviewStats domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in translation_review_stats:\n        stat_id = suggestion_models.TranslationReviewStatsModel.construct_id(\n            stat.language_code, stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_translation_review_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.TranslationReviewStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.reviewed_translations_count = (\n            stat.reviewed_translations_count)\n        stats_model.reviewed_translation_word_count = (\n            stat.reviewed_translation_word_count)\n        stats_model.accepted_translations_count = (\n            stat.accepted_translations_count)\n        stats_model.accepted_translation_word_count = (\n            stat.accepted_translation_word_count)\n        stats_model.accepted_translations_with_reviewer_edits_count = (\n            stat.accepted_translations_with_reviewer_edits_count)\n        stats_model.first_contribution_date = (\n            stat.first_contribution_date)\n        stats_model.last_contribution_date = (\n            stat.last_contribution_date)\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.TranslationReviewStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.TranslationReviewStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_question_contribution_stats_models(\n    question_contribution_stats: List[\n        suggestion_registry.QuestionContributionStats\n    ]\n) -> None:\n    \"\"\"Updates QuestionContributionStatsModel models for given question\n    contribution stats.\n\n    Args:\n        question_contribution_stats: list(QuestionContributionStats). A list of\n            QuestionContribution domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in question_contribution_stats:\n        stat_id = suggestion_models.QuestionContributionStatsModel.construct_id(\n            stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_question_contribution_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.QuestionContributionStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.submitted_questions_count = (\n            stat.submitted_questions_count)\n        stats_model.accepted_questions_count = (\n            stat.accepted_questions_count)\n        stats_model.accepted_questions_without_reviewer_edits_count = (\n            stat.accepted_questions_without_reviewer_edits_count)\n        stats_model.first_contribution_date = stat.first_contribution_date\n        stats_model.last_contribution_date = stat.last_contribution_date\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.QuestionContributionStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.QuestionContributionStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef _update_question_review_stats_models(\n    question_review_stats: List[\n        suggestion_registry.QuestionReviewStats\n    ]\n) -> None:\n    \"\"\"Updates QuestionReviewStatsModel models for given question\n    review stats.\n\n    Args:\n        question_review_stats: list(QuestionReviewStats). A list of\n            QuestionReviewStats domain objects.\n    \"\"\"\n    stats_dict = {}\n    for stat in question_review_stats:\n        stat_id = suggestion_models.QuestionReviewStatsModel.construct_id(\n            stat.contributor_user_id, stat.topic_id)\n        stats_dict[stat_id] = stat\n\n    stats_ids = stats_dict.keys()\n\n    stats_models = get_question_review_stats_models(list(stats_ids))\n    stats_models_to_update: List[\n        suggestion_models.QuestionReviewStatsModel] = []\n    for stats_model in stats_models:\n        stat = stats_dict[stats_model.id]\n        stats_model.reviewed_questions_count = (\n            stat.reviewed_questions_count)\n        stats_model.accepted_questions_count = (\n            stat.accepted_questions_count)\n        stats_model.accepted_questions_with_reviewer_edits_count = (\n            stat.accepted_questions_with_reviewer_edits_count)\n        stats_model.first_contribution_date = stat.first_contribution_date\n        stats_model.last_contribution_date = stat.last_contribution_date\n        stats_models_to_update.append(stats_model)\n\n    suggestion_models.QuestionReviewStatsModel.update_timestamps_multi(\n        stats_models_to_update,\n        update_last_updated_time=True)\n    suggestion_models.QuestionReviewStatsModel.put_multi(\n        stats_models_to_update)\n\n\ndef update_translation_contribution_stats_at_submission(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationContributionStatsModel model for\n    given translation submitter when a translation is submitted.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            submitted.\n    \"\"\"\n    content_word_count = 0\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n\n    if isinstance(suggestion.change.translation_html, list):\n        for content in suggestion.change.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    translation_contribution_stat_model = (\n        suggestion_models.TranslationContributionStatsModel.get(\n            suggestion.change.language_code, suggestion.author_id, topic_id\n        ))\n\n    if translation_contribution_stat_model is None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=suggestion.change.language_code,\n            contributor_user_id=suggestion.author_id,\n            topic_id=topic_id,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=0,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=0,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[suggestion.last_updated.date()]\n        )\n    else:\n        translation_contribution_stat = (\n            create_translation_contribution_stats_from_model(\n                translation_contribution_stat_model))\n\n        translation_contribution_stat.submitted_translations_count += 1\n        translation_contribution_stat.submitted_translation_word_count += (\n            content_word_count)\n        translation_contribution_stat.contribution_dates.add(\n            suggestion.last_updated.date())\n\n        _update_translation_contribution_stats_models(\n            [translation_contribution_stat])\n\n\ndef update_translation_contribution_stats_at_review(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationContributionStatsModel model for\n    given translation submitter when a translation is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n    \"\"\"\n    content_word_count = 0\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n\n    if isinstance(suggestion.change.translation_html, list):\n        for content in suggestion.change.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    translation_contribution_stat_model = (\n        suggestion_models.TranslationContributionStatsModel.get(\n            suggestion.change.language_code, suggestion.author_id, topic_id\n        ))\n\n    if translation_contribution_stat_model is None:\n        accepted_translations_count = 0\n        accepted_translation_word_count = 0\n        rejected_translations_count = 0\n        rejected_translation_word_count = 0\n        accepted_translations_without_reviewer_edits_count = 0\n\n        if suggestion_is_accepted:\n            accepted_translations_count += 1\n            accepted_translation_word_count += content_word_count\n        else:\n            rejected_translations_count += 1\n            rejected_translation_word_count += content_word_count\n        if suggestion_is_accepted and not suggestion.edited_by_reviewer:\n            accepted_translations_without_reviewer_edits_count += 1\n\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=suggestion.change.language_code,\n            contributor_user_id=suggestion.author_id,\n            topic_id=topic_id,\n            submitted_translations_count=1,\n            submitted_translation_word_count=content_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_without_reviewer_edits_count=(\n                accepted_translations_without_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translations_count,\n            rejected_translation_word_count=rejected_translation_word_count,\n            contribution_dates=[suggestion.last_updated.date()]\n        )\n    else:\n        translation_contribution_stat = (\n            create_translation_contribution_stats_from_model(\n                translation_contribution_stat_model))\n\n        increment_translation_contribution_stats_at_review(\n            translation_contribution_stat, content_word_count,\n            suggestion_is_accepted, suggestion.edited_by_reviewer)\n        _update_translation_contribution_stats_models(\n            [translation_contribution_stat])\n\n\ndef update_translation_review_stats(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates TranslationReviewStatsModel model for given translation\n    reviewer when a translation is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n\n    Raises:\n        Exception. The final_reviewer_id of the suggestion should not be None.\n    \"\"\"\n    content_word_count = 0\n    if suggestion.final_reviewer_id is None:\n        raise Exception(\n            'The final_reviewer_id in the suggestion should not be None.'\n        )\n    exp_opportunity = (\n        opportunity_services.get_exploration_opportunity_summary_by_id(\n            suggestion.target_id))\n    # We can confirm that exp_opportunity will not be None since there should\n    # be an assigned opportunity for a given translation. Hence we can rule out\n    # the possibility of None for mypy type checking.\n    assert exp_opportunity is not None\n    topic_id = exp_opportunity.topic_id\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    if isinstance(suggestion.change.translation_html, list):\n        for content in suggestion.change.translation_html:\n            content_plain_text = html_cleaner.strip_html_tags(content)\n            content_word_count += len(content_plain_text.split())\n    else:\n        content_plain_text = html_cleaner.strip_html_tags(\n            suggestion.change.translation_html)\n        content_word_count = len(content_plain_text.split())\n\n    translation_review_stat_model = (\n        # This function is called when reviewing a translation and hence\n        # final_reviewer_id should not be None when the suggestion is\n        # up-to-date.\n        suggestion_models.TranslationReviewStatsModel.get(\n            suggestion.change.language_code, suggestion.final_reviewer_id,\n            topic_id\n        ))\n\n    if translation_review_stat_model is None:\n        # This function is called when reviewing a translation and hence\n        # final_reviewer_id should not be None when the suggestion is\n        # up-to-date.\n        accepted_translations_count = 0\n        accepted_translations_with_reviewer_edits_count = 0\n        accepted_translation_word_count = 0\n        if suggestion_is_accepted:\n            accepted_translations_count += 1\n            accepted_translation_word_count = content_word_count\n        if suggestion_is_accepted and suggestion.edited_by_reviewer:\n            accepted_translations_with_reviewer_edits_count += 1\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code=suggestion.change.language_code,\n            reviewer_user_id=suggestion.final_reviewer_id,\n            topic_id=topic_id,\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=content_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_with_reviewer_edits_count=(\n                accepted_translations_with_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            first_contribution_date=suggestion.last_updated.date(),\n            last_contribution_date=suggestion.last_updated.date()\n        )\n    else:\n        translation_review_stat = (\n            _create_translation_review_stats_from_model(\n                translation_review_stat_model))\n\n        increment_translation_review_stats(\n            translation_review_stat, content_word_count,\n            suggestion.last_updated, suggestion_is_accepted,\n            suggestion.edited_by_reviewer\n        )\n        _update_translation_review_stats_models([translation_review_stat])\n\n    update_translation_contribution_stats_at_review(suggestion)\n\n\ndef update_question_contribution_stats_at_submission(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionContributionStatsModel model for given question\n    submitter when a question is submitted.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            submitted.\n    \"\"\"\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_contribution_stat_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                suggestion.author_id, topic.topic_id\n            ))\n\n        if question_contribution_stat_model is None:\n            suggestion_models.QuestionContributionStatsModel.create(\n                contributor_user_id=suggestion.author_id,\n                topic_id=topic.topic_id,\n                submitted_questions_count=1,\n                accepted_questions_count=0,\n                accepted_questions_without_reviewer_edits_count=0,\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_contribution_stat = (\n            _create_question_contribution_stats_from_model(\n                question_contribution_stat_model))\n\n        question_contribution_stat.submitted_questions_count += 1\n        question_contribution_stat.last_contribution_date = (\n            suggestion.last_updated.date())\n        _update_question_contribution_stats_models(\n            [question_contribution_stat])\n\n\ndef update_question_contribution_stats_at_review(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionContributionStatsModel model for given question\n    submitter when a question is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n    \"\"\"\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_contribution_stat_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                suggestion.author_id, topic.topic_id\n            ))\n\n        if question_contribution_stat_model is None:\n            accepted_questions_count = 0\n            accepted_questions_without_reviewer_edits_count = 0\n            if suggestion_is_accepted:\n                accepted_questions_count += 1\n            if suggestion_is_accepted and not suggestion.edited_by_reviewer:\n                accepted_questions_without_reviewer_edits_count += 1\n            suggestion_models.QuestionContributionStatsModel.create(\n                contributor_user_id=suggestion.author_id,\n                topic_id=topic.topic_id,\n                submitted_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_without_reviewer_edits_count=(\n                    accepted_questions_without_reviewer_edits_count),\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_contribution_stat = (\n            _create_question_contribution_stats_from_model(\n                question_contribution_stat_model))\n\n        if suggestion_is_accepted:\n            question_contribution_stat.accepted_questions_count += 1\n        if suggestion_is_accepted and not suggestion.edited_by_reviewer:\n            (\n                question_contribution_stat\n                .accepted_questions_without_reviewer_edits_count\n            ) += 1\n        _update_question_contribution_stats_models(\n            [question_contribution_stat])\n\n\ndef update_question_review_stats(\n    suggestion: suggestion_registry.BaseSuggestion\n) -> None:\n    \"\"\"Creates/updates QuestionReviewStatsModel model for given question\n    reviewer when a question is reviewed.\n\n    Args:\n        suggestion: Suggestion. The suggestion domain object that is being\n            reviewed.\n\n    Raises:\n        Exception. The final_reviewer_id of the suggestion should not be None.\n    \"\"\"\n    if suggestion.final_reviewer_id is None:\n        raise Exception(\n            'The final_reviewer_id in the suggestion should not be None.'\n        )\n    suggestion_is_accepted = (\n        suggestion.status == suggestion_models.STATUS_ACCEPTED\n    )\n\n    for topic in skill_services.get_all_topic_assignments_for_skill(\n        suggestion.target_id):\n        question_review_stat_model = (\n            # This function is called when reviewing a question suggestion and\n            # hence final_reviewer_id should not be None when the suggestion is\n            # up-to-date.\n            suggestion_models.QuestionReviewStatsModel.get(\n                suggestion.final_reviewer_id, topic.topic_id\n            ))\n\n        if question_review_stat_model is None:\n            # This function is called when reviewing a question suggestion and\n            # hence final_reviewer_id should not be None when the suggestion is\n            # up-to-date.\n            accepted_questions_count = 0\n            accepted_questions_with_reviewer_edits_count = 0\n            if suggestion_is_accepted:\n                accepted_questions_count += 1\n            if suggestion_is_accepted and suggestion.edited_by_reviewer:\n                accepted_questions_with_reviewer_edits_count += 1\n            suggestion_models.QuestionReviewStatsModel.create(\n                reviewer_user_id=suggestion.final_reviewer_id,\n                topic_id=topic.topic_id,\n                reviewed_questions_count=1,\n                accepted_questions_count=accepted_questions_count,\n                accepted_questions_with_reviewer_edits_count=(\n                    accepted_questions_with_reviewer_edits_count),\n                first_contribution_date=suggestion.last_updated.date(),\n                last_contribution_date=suggestion.last_updated.date()\n            )\n            continue\n\n        question_review_stat = (\n            _create_question_review_stats_from_model(\n                question_review_stat_model))\n\n        increment_question_review_stats(\n            question_review_stat, suggestion.last_updated,\n            suggestion_is_accepted,\n            suggestion.edited_by_reviewer)\n        _update_question_review_stats_models([question_review_stat])\n\n    update_question_contribution_stats_at_review(suggestion)\n\n\ndef increment_translation_contribution_stats_at_review(\n    translation_contribution_stat: (\n        suggestion_registry.TranslationContributionStats),\n    content_word_count: int,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationContributionStats object.\n\n    Args:\n        translation_contribution_stat: TranslationContributionStats. The stats\n            object to update.\n        content_word_count: int. The number of words in the translation.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    if suggestion_is_accepted:\n        translation_contribution_stat.accepted_translations_count += 1\n        translation_contribution_stat.accepted_translation_word_count += (\n            content_word_count)\n    else:\n        translation_contribution_stat.rejected_translations_count += 1\n        translation_contribution_stat.rejected_translation_word_count += (\n            content_word_count)\n    if suggestion_is_accepted and not edited_by_reviewer:\n        translation_contribution_stat.accepted_translations_without_reviewer_edits_count += 1 # pylint: disable=line-too-long\n\n\ndef increment_translation_review_stats(\n    translation_review_stat: suggestion_registry.TranslationReviewStats,\n    content_word_count: int,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates TranslationReviewStats object.\n\n    Args:\n        translation_review_stat: TranslationReviewStats. The stats\n            object to update.\n        content_word_count: int. The number of words in the translation.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    translation_review_stat.reviewed_translations_count += 1\n    translation_review_stat.reviewed_translation_word_count += (\n        content_word_count)\n    if suggestion_is_accepted:\n        translation_review_stat.accepted_translations_count += 1\n        translation_review_stat.accepted_translation_word_count += (\n            content_word_count)\n    if suggestion_is_accepted and edited_by_reviewer:\n        (\n            translation_review_stat\n            .accepted_translations_with_reviewer_edits_count\n        ) += 1\n    translation_review_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef increment_question_review_stats(\n    question_review_stat: suggestion_registry.QuestionReviewStats,\n    last_contribution_date: datetime.datetime,\n    suggestion_is_accepted: bool,\n    edited_by_reviewer: bool\n) -> None:\n    \"\"\"Updates QuestionReviewStats object.\n\n    Args:\n        question_review_stat: QuestionReviewStats. The stats object to update.\n        last_contribution_date: datetime.datetime. The last updated date.\n        suggestion_is_accepted: bool. A flag that indicates whether the\n            suggestion is accepted.\n        edited_by_reviewer: bool. A flag that indicates whether the suggestion\n            is edited by the reviewer.\n    \"\"\"\n    question_review_stat.reviewed_questions_count += 1\n    if suggestion_is_accepted:\n        question_review_stat.accepted_questions_count += 1\n    if suggestion_is_accepted and edited_by_reviewer:\n        question_review_stat.accepted_questions_with_reviewer_edits_count += 1\n    question_review_stat.last_contribution_date = (\n        last_contribution_date.date())\n\n\ndef enqueue_contributor_ranking_notification_email_task(\n    contributor_user_id: str, contribution_type: str,\n    contribution_sub_type: str, language_code: str, rank_name: str,\n) -> None:\n    \"\"\"Adds a 'send feedback email' (instant) task into the task queue.\n\n    Args:\n        contributor_user_id: str. The ID of the contributor.\n        contribution_type: str. The type of the contribution i.e.\n            translation or question.\n        contribution_sub_type: str. The sub type of the contribution\n            i.e. submissions/acceptances/reviews/edits.\n        language_code: str. The language code of the suggestion.\n        rank_name: str. The name of the rank that the contributor achieved.\n\n    Raises:\n        Exception. The contribution type must be offered on the Contributor\n            Dashboard.\n        Exception. The contribution subtype must be offered on the Contributor\n            Dashboard.\n    \"\"\"\n    # contributor_user_id is alrerady validated in the controller layer.\n    # TODO(#16062): Rank name should be valid to send notification emails.\n    if language_code not in [language['id'] for language in (\n            constants.SUPPORTED_AUDIO_LANGUAGES)]:\n        raise Exception(\n            'Not supported language code: %s' % language_code)\n    if contribution_type not in [\n        feconf.CONTRIBUTION_TYPE_TRANSLATION,\n        feconf.CONTRIBUTION_TYPE_QUESTION\n    ]:\n        raise Exception(\n            'Invalid contribution type: %s' % contribution_type)\n    if contribution_sub_type not in [\n        feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE,\n        feconf.CONTRIBUTION_SUBTYPE_REVIEW,\n        feconf.CONTRIBUTION_SUBTYPE_EDIT,\n    ]:\n        raise Exception(\n            'Invalid contribution subtype: %s' % contribution_sub_type)\n\n    payload = {\n        'contributor_user_id': contributor_user_id,\n        'contribution_type': contribution_type,\n        'contribution_sub_type': contribution_sub_type,\n        'language_code': language_code,\n        'rank_name': rank_name,\n    }\n\n    taskqueue_services.enqueue_task(\n        feconf.TASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS,\n        payload, 0)\n\n\ndef generate_contributor_certificate_data(\n    username: str,\n    suggestion_type: str,\n    language_code: Optional[str],\n    from_date: datetime.datetime,\n    to_date: datetime.datetime\n) -> suggestion_registry.ContributorCertificateInfoDict:\n    \"\"\"Returns data to generate the certificate.\n\n    Args:\n        username: str. The username of the contributor.\n        language_code: str|None. The language for which the contributions should\n            be considered.\n        suggestion_type: str. The type of suggestion that the certificate\n            needs to generate.\n        from_date: datetime.datetime. The start of the date range for which the\n            contributions were created.\n        to_date: datetime.datetime. The end of the date range for which the\n            contributions were created.\n\n    Returns:\n        ContributorCertificateInfoDict. Data to generate the certificate.\n\n    Raises:\n        Exception. The suggestion type is invalid.\n        Exception. There is no user for the given username.\n    \"\"\"\n    user_id = user_services.get_user_id_from_username(username)\n    if user_id is None:\n        raise Exception('There is no user for the given username.')\n\n    if suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n        # For the suggestion_type translate_content, there should be a\n        # corresponding language_code.\n        assert isinstance(language_code, str)\n        data = _generate_translation_contributor_certificate_data(\n            language_code, from_date, to_date, user_id)\n\n    elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n        data = _generate_question_contributor_certificate_data(\n            from_date, to_date, user_id)\n\n    else:\n        raise Exception('The suggestion type is invalid.')\n\n    return data.to_dict()\n\n\ndef _generate_translation_contributor_certificate_data(\n    language_code: str,\n    from_date: datetime.datetime,\n    to_date: datetime.datetime,\n    user_id: str\n) -> suggestion_registry.ContributorCertificateInfo:\n    \"\"\"Returns data to generate translation submitter certificate.\n\n    Args:\n        language_code: str. The language for which the contributions should\n            be considered.\n        from_date: datetime.datetime. The start of the date range for which\n            the contributions were created.\n        to_date: datetime.datetime. The end of the date range for which\n            the contributions were created.\n        user_id: str. The user ID of the contributor.\n\n    Returns:\n        ContributorCertificateInfo. Data to generate translation submitter\n        certificate.\n\n    Raises:\n        Exception. The language is invalid.\n    \"\"\"\n    signature = feconf.TRANSLATION_TEAM_LEAD\n\n    # Adds one date to the to_date to make sure the contributions within\n    # the to_date are also counted for the certificate.\n    to_date_to_fetch_contributions = to_date + datetime.timedelta(days=1)\n\n    language = next(filter(\n        lambda lang: lang['id'] == language_code,\n        constants.SUPPORTED_AUDIO_LANGUAGES), None)\n    if language is None:\n        raise Exception('The provided language is invalid.')\n    language_description = language['description']\n    if ' (' in language_description:\n        language_description = language_description[\n            language_description.find('(') + 1:language_description.find(')')]\n\n    suggestions = (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestions_submitted_within_given_dates(\n            from_date,\n            to_date_to_fetch_contributions,\n            user_id,\n            language_code\n        )\n    )\n\n    words_count = 0\n    for model in suggestions:\n        suggestion = get_suggestion_from_model(model)\n\n        # Retrieve the html content that is emphasized on the\n        # Contributor Dashboard pages. This content is what stands\n        # out for each suggestion when a user views a list of\n        # suggestions.\n        get_html_representing_suggestion = (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n                suggestion.suggestion_type]\n        )\n        plain_text = _get_plain_text_from_html_content_string(\n            get_html_representing_suggestion(suggestion))\n\n        words = plain_text.split(' ')\n        words_without_empty_strings = [\n            word for word in words if word != '']\n        words_count += len(words_without_empty_strings)\n    # Go to the below link for more information about how we count hours\n    # contributed.# Goto the below link for more information.\n    # https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit?usp=sharing\n    hours_contributed = round(words_count / 300, 2)\n\n    if words_count == 0:\n        raise Exception(\n            'There are no contributions for the given time range.')\n\n    return suggestion_registry.ContributorCertificateInfo(\n        from_date.strftime('%d %b %Y'), to_date.strftime('%d %b %Y'),\n        signature, str(hours_contributed), language_description\n    )\n\n\ndef _generate_question_contributor_certificate_data(\n    from_date: datetime.datetime,\n    to_date: datetime.datetime,\n    user_id: str\n) -> suggestion_registry.ContributorCertificateInfo:\n    \"\"\"Returns data to generate question submitter certificate.\n\n    Args:\n        from_date: datetime.datetime. The start of the date range for which\n            the contributions were created.\n        to_date: datetime.datetime. The end of the date range for which\n            the contributions were created.\n        user_id: str. The user ID of the contributor.\n\n    Returns:\n        ContributorCertificateInfo. Data to generate question submitter\n        certificate.\n\n    Raises:\n        Exception. The suggestion type given to generate the certificate is\n            invalid.\n    \"\"\"\n    signature = feconf.QUESTION_TEAM_LEAD\n\n    # Adds one date to the to_date to make sure the contributions within\n    # the to_date are also counted for the certificate.\n    to_date_to_fetch_contributions = to_date + datetime.timedelta(days=1)\n\n    suggestions = (\n        suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_submitted_within_given_dates(\n                from_date, to_date_to_fetch_contributions, user_id))\n\n    minutes_contributed = 0\n    for model in suggestions:\n        suggestion = get_suggestion_from_model(model)\n        # Retrieve the html content that is emphasized on the\n        # Contributor Dashboard pages. This content is what stands\n        # out for each suggestion when a user views a list of\n        # suggestions.\n        get_html_representing_suggestion = (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n                suggestion.suggestion_type]\n        )\n        html_content = get_html_representing_suggestion(suggestion)\n\n        if 'oppia-noninteractive-image' in html_content:\n            minutes_contributed += 20\n        else:\n            minutes_contributed += 12\n    # Go to the below link for more information about how we count hours\n    # contributed.\n    # https://docs.google.com/spreadsheets/d/1ykSNwPLZ5qTCkuO21VLdtm_2SjJ5QJ0z0PlVjjSB4ZQ/edit?usp=sharing\n    hours_contributed = round(minutes_contributed / 60, 2)\n\n    if minutes_contributed == 0:\n        raise Exception(\n            'There are no contributions for the given time range.')\n\n    return suggestion_registry.ContributorCertificateInfo(\n        from_date.strftime('%d %b %Y'), to_date.strftime('%d %b %Y'),\n        signature, str(hours_contributed), None\n    )\n"
    },
    {
      "filename": "core/domain/suggestion_services_test.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for suggestion related services.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import feedback_services\nfrom core.domain import question_domain\nfrom core.domain import rights_domain\nfrom core.domain import rights_manager\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_domain\nfrom core.domain import subtopic_page_services\nfrom core.domain import suggestion_registry\nfrom core.domain import suggestion_services\nfrom core.domain import taskqueue_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_fetchers\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\nfrom typing import Dict, Final, List, Mapping, Union\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from core.domain import change_domain\n    from mypy_imports import feedback_models\n    from mypy_imports import suggestion_models\n    from mypy_imports import user_models\n\n(suggestion_models, feedback_models, opportunity_models, user_models) = (\n    models.Registry.import_models(\n        [\n            models.Names.SUGGESTION,\n            models.Names.FEEDBACK,\n            models.Names.OPPORTUNITY,\n            models.Names.USER\n        ]\n    )\n)\n\n\nclass SuggestionServicesUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functions in suggestion_services.\"\"\"\n\n    score_category: str = (\n        suggestion_models.SCORE_TYPE_CONTENT +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'Algebra')\n\n    target_id: str = 'exp1'\n    target_id_2: str = 'exp2'\n    target_id_3: str = 'exp3'\n    target_version_at_submission: int = 1\n    change: Dict[str, Union[str, Dict[str, str]]] = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': {\n            'content_id': 'content',\n            'html': 'new suggestion content'\n        }\n    }\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@example.com'\n    NORMAL_USER_EMAIL: Final = 'normal@example.com'\n\n    THREAD_ID: Final = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE: Final = 'commit message'\n    EMPTY_COMMIT_MESSAGE: Final = ' '\n\n    suggestion_id: str = THREAD_ID\n    suggestion_id_2: str = 'exploration.exp2.thread_2'\n    suggestion_id_3: str = 'exploration.exp3.thread_3'\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.signup(self.NORMAL_USER_EMAIL, 'normaluser')\n        self.normal_user_id = self.get_user_id_from_email(\n            self.NORMAL_USER_EMAIL)\n        self.save_new_valid_exploration(\n            self.target_id, self.author_id, category='Algebra')\n\n    def assert_suggestion_status(self, suggestion_id: str, status: str) -> None:\n        \"\"\"Assert the status of the suggestion with suggestion_id.\"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, status)\n\n    def mock_accept_suggestion(\n        self,\n        suggestion_id: str,\n        reviewer_id: str,\n        commit_message: str,\n        review_message: str\n    ) -> None:\n        \"\"\"Sets up the appropriate mocks to successfully call\n        accept_suggestion.\n        \"\"\"\n        with self.swap(\n            exp_services, 'update_exploration', self.mock_update_exploration):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                with self.swap(\n                    suggestion_registry.SuggestionEditStateContent,\n                    'pre_accept_validate',\n                    self.mock_pre_accept_validate_does_nothing):\n                    with self.swap(\n                        suggestion_registry.SuggestionEditStateContent,\n                        '_get_change_list_for_accepting_edit_state_content_suggestion',  # pylint: disable=line-too-long\n                        self.mock_get_change_list_does_nothing\n                    ):\n                        suggestion_services.accept_suggestion(\n                            suggestion_id, reviewer_id,\n                            commit_message, review_message)\n\n    def mock_create_suggestion(self, target_id: str) -> None:\n        \"\"\"Sets up the appropriate mocks to successfully call\n        create_suggestion.\n        \"\"\"\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    target_id, self.target_version_at_submission,\n                    self.author_id, self.change, 'test description')\n\n    def mock_generate_new_thread_id(\n        self, entity_type: str, exp_id: str\n    ) -> str:\n        thread_id = 'thread_%s' % exp_id[-1]\n        return '.'.join([entity_type, exp_id, thread_id])\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(\n            self, exploration_id: str, states: Dict[str, Dict[str, str]]\n        ) -> None:\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}})\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id: str) -> MockExploration:\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                mock_exp = exp\n        return mock_exp\n\n    def mock_pre_accept_validate_does_nothing(self) -> None:\n        pass\n\n    def mock_get_change_list_does_nothing(self) -> None:\n        pass\n\n    def mock_accept_does_nothing(self, unused_arg: str) -> None:\n        pass\n\n    def edit_before_pre_accept_validate(\n        self, suggestion: suggestion_registry.BaseSuggestion\n    ) -> None:\n        \"\"\"Edits suggestion immediately before pre-accept validation.\"\"\"\n        suggestion.score_category = 'invalid_score_category'\n        suggestion.pre_accept_validate()\n\n    def test_create_new_suggestion_successfully(self) -> None:\n        expected_suggestion_dict = {\n            'suggestion_id': 'exploration.exp1.thread_1',\n            'suggestion_type': (\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT),\n            'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n            'target_id': self.target_id,\n            'target_version_at_submission': self.target_version_at_submission,\n            'status': suggestion_models.STATUS_IN_REVIEW,\n            'author_name': 'author',\n            'change': {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': {\n                    'content_id': 'content',\n                    'html': 'new suggestion content'\n                },\n                'old_value': None\n            },\n            'score_category': self.score_category,\n            'language_code': None\n        }\n        self.mock_create_suggestion(self.target_id)\n\n        observed_suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertDictContainsSubset(\n            expected_suggestion_dict, observed_suggestion.to_dict())\n\n    def test_cannot_create_suggestion_with_invalid_suggestion_type(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(Exception, 'Invalid suggestion type'):\n            suggestion_services.create_suggestion(\n                'invalid_suggestion_type',\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n    def test_cannot_create_suggestion_with_invalid_author_id(self) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'Expected author_id to be in a valid user ID format'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                'invalid author ID', self.change, 'test description')\n\n    def test_cannot_create_translation_suggestion_with_invalid_content_html_raise_error(  # pylint: disable=line-too-long\n        self\n    ) -> None:\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'Introduction',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>The invalid content html</p>',\n            'translation_html': '<p>Translation for invalid content.</p>',\n            'data_format': 'html'\n        }\n        with self.assertRaisesRegex(\n            Exception,\n            'The Exploration content has changed since this translation '\n            'was submitted.'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, add_translation_change_dict, 'test description')\n\n    def test_get_submitted_submissions(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, '')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test_description')\n        suggestions = suggestion_services.get_submitted_suggestions(\n            self.author_id, feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].author_id, self.author_id)\n        self.assertEqual(suggestions[1].author_id, self.author_id)\n\n    def test_get_all_stale_suggestion_ids(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test description')\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS', 0):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 1)\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS',\n            7 * 24 * 60 * 60 * 1000):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 0)\n\n    def mock_update_exploration(\n        self,\n        unused_user_id: str,\n        unused_exploration_id: str,\n        unused_change_list: str,\n        commit_message: str,\n        is_suggestion: bool\n    ) -> None:\n        self.assertTrue(is_suggestion)\n        self.assertEqual(\n            commit_message, 'Accepted suggestion by %s: %s' % (\n                'author', self.COMMIT_MESSAGE))\n\n    def test_cannot_reject_suggestion_with_empty_review_message(self) -> None:\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Review message cannot be empty.'):\n            suggestion_services.reject_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, '')\n\n        # Assert that the suggestion was not rejected.\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_accept_suggestion_and_send_email_to_author(self) -> None:\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_ADD_STATE,\n            'state_name': 'state 1',\n        })]\n        exp_services.update_exploration(\n            self.author_id, self.target_id, change_list, 'Add state.')\n\n        new_suggestion_content = state_domain.SubtitledHtml(\n            'content', '<p>new suggestion content html</p>').to_dict()\n        change_dict: Dict[str, Union[str, state_domain.SubtitledHtmlDict]] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': new_suggestion_content\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, change_dict, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create a user proficiency model to verify that the\n        # score and onboarding_email_sent fields have changed after the\n        # suggestion has been accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, suggestion.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. Therefore,\n        # by setting that increment to minimum score required to review, we can\n        # ensure that the email is sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                with self.swap(\n                    suggestion_models, 'INCREMENT_SCORE_OF_AUTHOR_BY',\n                    feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW):\n                    suggestion_services.accept_suggestion(\n                        suggestion.suggestion_id, self.reviewer_id,\n                        self.COMMIT_MESSAGE, 'review message')\n\n        # Assert that the suggestion is now accepted.\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        # Assert that the email was sent and that the score increased by the\n        # correct amount.\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, suggestion.score_category\n            )\n        )\n        # Ruling out the possibility of None for mypy type checking.\n        assert user_proficiency_model is not None\n        self.assertTrue(user_proficiency_model.onboarding_email_sent)\n        self.assertEqual(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n\n    def test_accept_suggestion_does_not_send_email_if_users_score_is_too_low(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create the user proficiency model to verify the score and\n        # that the onboarding_email_sent field does not change after the\n        # suggestion is accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, self.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. This is\n        # less than the minimum score required to review so an email should not\n        # be sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                self.mock_accept_suggestion(\n                    self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                    'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, self.score_category\n            )\n        )\n        # Assert that the users score was updated correctly.\n        # Ruling out the possibility of None for mypy type checking.\n        assert user_proficiency_model is not None\n        self.assertEqual(\n            user_proficiency_model.score,\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY)\n        # Assert that their score is not high enough to review the category.\n        self.assertLess(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        # Assert that the onboarding new reviewer email was not sent.\n        self.assertFalse(user_proficiency_model.onboarding_email_sent)\n\n    def test_accept_suggestion_creates_user_proficiency_model_if_it_is_none(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        # Verify that a user proficiency model does not exist.\n        self.assertIsNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Verify that a user proficiency model now exists.\n        self.assertIsNotNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n    def test_accept_suggestion_successfully(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'review message')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_does_not_exist(\n        self\n    ) -> None:\n        expected_exception_regexp = (\n            'You cannot accept the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n    def test_accept_suggestion_with_invalid_math_fails(self) -> None:\n        \"\"\"Test that the method for accepting suggestions raises error when\n        a suggestion with invalid math-tags is tried to be accepted.\n        \"\"\"\n        change_dict: Dict[str, Union[str, state_domain.SubtitledHtmlDict]] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state_1',\n            'new_value': {\n                'content_id': 'content',\n                'html': (\n                    '<oppia-noninteractive-math raw_latex-with-value=\"&am'\n                    'p;quot;(x - a_1)(x - a_2)(x - a_3)...(x - a_n)&amp;q'\n                    'uot;\"></oppia-noninteractive-math>')\n            }\n        }\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id, self.target_version_at_submission,\n                    self.author_id, change_dict, 'test description')\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        expected_exception_regexp = (\n            'Invalid math tags found in the suggestion with id %s.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Assert that the status of the suggestion hasn't changed.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_raises_exception_for_invalid_suggestion_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(Exception, 'No suggestion model exists'):\n            suggestion_services.get_suggestion_by_id('invalid_id')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_accepted(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_rejected(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message'\n        )\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n        # Assert that the suggestion is still rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n    def test_accept_suggestion_invalid_suggestion_failure(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n\n        with self.assertRaisesRegex(\n            utils.ValidationError, 'Expected score_category to be of the form '\n                                   'score_type.score_sub_type, received '\n                                   'invalid_score_category'):\n            self.edit_before_pre_accept_validate(suggestion)\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id,\n                self.COMMIT_MESSAGE, '')\n\n    def test_accept_suggestion_no_commit_message_failure(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Commit message cannot be empty.'):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id,\n                self.EMPTY_COMMIT_MESSAGE, '')\n\n        # Assert that the status of the suggestion didn't change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_reject_suggestion_successfully(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(last_message.text, 'reject review message')\n\n    def test_reject_suggestions_successfully(self) -> None:\n        # Create the first suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_2)\n        self.assert_suggestion_status(\n            self.suggestion_id_2, suggestion_models.STATUS_IN_REVIEW)\n        # Create another suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_3)\n        self.assert_suggestion_status(\n            self.suggestion_id_3, suggestion_models.STATUS_IN_REVIEW)\n        suggestion_ids = [self.suggestion_id_2, self.suggestion_id_3]\n\n        suggestion_services.reject_suggestions(\n            suggestion_ids, self.reviewer_id, 'reject review message')\n\n        for suggestion_id in suggestion_ids:\n            # Assert that the statuses changed to rejected.\n            self.assert_suggestion_status(\n                suggestion_id, suggestion_models.STATUS_REJECTED)\n            # Assert that the final reviewer id was updated.\n            suggestion = suggestion_services.get_suggestion_by_id(\n                suggestion_id)\n            self.assertEqual(\n                suggestion.final_reviewer_id, self.reviewer_id)\n            # Assert that the messages were updated.\n            thread_messages = feedback_services.get_messages(suggestion_id)\n            last_message = thread_messages[len(thread_messages) - 1]\n            self.assertEqual(\n                last_message.text, 'reject review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_does_not_exist(\n        self\n    ) -> None:\n        expected_exception_regexp = (\n            'You cannot reject the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_accepted(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion's status did not change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_rejected(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been rejected.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n    def test_resubmit_rejected_suggestion_success(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        # Create the new change for the resubmitted suggestion.\n        resubmit_change_content = state_domain.SubtitledHtml(\n            'content', '<p>resubmit change content html</p>').to_dict()\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': resubmit_change_content,\n                'old_value': self.change['new_value']\n            }\n        )\n\n        # Resubmit rejected suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            self.suggestion_id, 'resubmit summary message', self.author_id,\n            resubmit_change)\n\n        # The suggestion's status should now be in review instead of rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # The suggestion's change should be updated.\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        new_value = suggestion.change.new_value\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(new_value, dict)\n        self.assertEqual(new_value['html'], resubmit_change_content['html'])\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_empty_message(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n\n        # Can't resubmit a rejected suggestion if the summary message is empty.\n        with self.assertRaisesRegex(\n            Exception, 'Summary message cannot be empty.'):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, '', self.author_id, resubmit_change)\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_unhandled_input(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n\n        # Can't resubmit a rejected suggestion if the suggestion hasn't been\n        # rejected yet.\n        expected_exception_regexp = (\n            'The suggestion with id %s is not yet handled.' % (\n                self.suggestion_id)\n        )\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, resubmit_change\n            )\n\n    def test_resubmit_rejected_suggestion_raises_excep_for_accepted_suggestion(\n        self\n    ) -> None:\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n        # Verfiy that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Can't resubmit the suggestion if it's already accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s was accepted. Only rejected '\n            'suggestions can be resubmitted.' % (\n                self.suggestion_id)\n        )\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_RENAME_STATE,\n                'new_state_name': '',\n                'old_state_name': '',\n            }\n        )\n        with self.assertRaisesRegex(\n            Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, resubmit_change\n            )\n\n        # Verfiy that the suggestion is still accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_check_can_resubmit_suggestion(self) -> None:\n        self.mock_create_suggestion(self.target_id)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.author_id)\n        self.assertEqual(can_resubmit, True)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.normal_user_id)\n        self.assertEqual(can_resubmit, False)\n\n    def test_update_translation_suggestion_to_change_translation_html(\n        self\n    ) -> None:\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content',\n                'html': '<p>old content html</p>'\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, '<p>Updated translation</p>'\n        )\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change.translation_html,\n            '<p>Updated translation</p>')\n\n    def test_update_question_suggestion_to_change_question_state(self) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict: state_domain.SolutionDict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content'][\n            'html'] = '<p>Updated question</p>'\n        question_state_data['interaction'][\n            'solution'] = new_solution_dict\n\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion.change.skill_difficulty, float)\n        skill_difficulty = suggestion.change.skill_difficulty\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            skill_difficulty,\n            question_state_data)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(updated_suggestion.change.question_dict, dict)\n        question_dict: question_domain.QuestionDict = (\n            updated_suggestion.change.question_dict\n        )\n        new_question_state_data = question_dict[\n            'question_state_data']\n\n        self.assertEqual(\n            new_question_state_data['content'][\n                'html'],\n            '<p>Updated question</p>')\n        self.assertEqual(\n            new_question_state_data['interaction'][\n                'solution'],\n            new_solution_dict)\n\n    def test_wrong_suggestion_raise_error_while_updating_translation_suggestion(\n        self\n    ) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'Expected SuggestionTranslateContent suggestion'\n            ' but found: SuggestionAddQuestion.'\n        ):\n            suggestion_services.update_translation_suggestion(\n                suggestion.suggestion_id, 'test_translation'\n            )\n\n    def test_wrong_suggestion_raise_error_when_updating_add_question_suggestion(\n        self\n    ) -> None:\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content',\n                'html': '<p>old content html</p>'\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'Expected SuggestionAddQuestion suggestion but '\n            'found: SuggestionTranslateContent.'\n        ):\n            suggestion_services.update_question_suggestion(\n                suggestion.suggestion_id,\n                0.1,\n                exploration.states['state 1'].to_dict()\n            )\n\n    def test_update_question_suggestion_to_change_skill_difficulty(\n        self\n    ) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion.change.question_dict, dict)\n        change_question_dict = suggestion.change.question_dict\n        question_state_data = change_question_dict[\n            'question_state_data']\n\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            0.6,\n            question_state_data)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change.skill_difficulty,\n            0.6)\n\n    def test_accept_suggestion_commit_message_after_updating_a_suggestion(\n        self\n    ) -> None:\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': {\n                'content_id': 'content',\n                'html': '<p>old content html</p>'\n            }\n        })]\n        exp_services.update_exploration(\n            self.author_id, exploration.id, change_list, '')\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, '<p>Updated translation</p>'\n        )\n\n        suggestion_services.accept_suggestion(\n            suggestion.suggestion_id, self.reviewer_id, 'Accepted', 'Done'\n        )\n        snapshots_metadata = exp_services.get_exploration_snapshots_metadata(\n            'exploration1')\n\n        self.assertEqual(\n            snapshots_metadata[2]['commit_message'],\n            'Accepted suggestion by author: Accepted (with edits)')\n\n\nclass SuggestionGetServicesUnitTests(test_utils.GenericTestBase):\n    score_category: str = (\n        suggestion_models.SCORE_TYPE_TRANSLATION +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n\n    target_id_1: str = 'exp1'\n    target_id_2: str = 'exp2'\n    target_id_3: str = 'exp3'\n    target_version_at_submission: int = 1\n    change: Dict[str, str] = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': 'new suggestion content'\n    }\n\n    AUTHOR_EMAIL_1: Final = 'author1@example.com'\n    REVIEWER_EMAIL_1: Final = 'reviewer1@example.com'\n\n    AUTHOR_EMAIL_2: Final = 'author2@example.com'\n    REVIEWER_EMAIL_2: Final = 'reviewer2@example.com'\n\n    add_translation_change_dict: Dict[str, str] = {\n        'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n        'state_name': 'state_1',\n        'content_id': 'content',\n        'language_code': 'hi',\n        'content_html': '<p>State name: state_1, Content id: content</p>',\n        'translation_html': '<p>This is translated html.</p>',\n        'data_format': 'html'\n    }\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(\n            self, exploration_id: str, states: Dict[str, Dict[str, str]]\n        ) -> None:\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n        def get_content_html(self, state_name: str, content_id: str) -> str:\n            \"\"\"Used to mock the get_content_html method for explorations.\"\"\"\n            # state_name and content_id are used here to suppress the unused\n            # arguments warning. The main goal of this method is to just\n            # produce content html for the tests.\n            return '<p>State name: %s, Content id: %s</p>' % (\n                state_name, content_id\n            )\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}}),\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id: str) -> MockExploration:\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                mock_exp = exp\n        return mock_exp\n\n    def _create_question_suggestion_with_skill_id(\n        self, skill_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id_1, suggestion_change, 'test description'\n        )\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion with the language code given.\"\"\"\n        return self._create_translation_suggestion(\n            language_code, self.target_id_1)\n\n    def _create_translation_suggestion(\n        self, language_code: str, target_id: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion for the supplied language code and\n        target ID.\n        \"\"\"\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state_1',\n            'content_id': 'content',\n            'language_code': language_code,\n            'content_html': (\n                '<p>State name: state_1, Content id: content</p>'),\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html\n            ):\n                translation_suggestion = suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    target_id, 1, self.author_id_1,\n                    add_translation_change_dict, 'test description')\n\n        return translation_suggestion\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL_1, 'author1')\n        self.author_id_1 = self.get_user_id_from_email(self.AUTHOR_EMAIL_1)\n        self.signup(self.REVIEWER_EMAIL_1, 'reviewer1')\n        self.reviewer_id_1 = self.get_user_id_from_email(self.REVIEWER_EMAIL_1)\n\n        self.signup(self.AUTHOR_EMAIL_2, 'author2')\n        self.author_id_2 = self.get_user_id_from_email(self.AUTHOR_EMAIL_2)\n        self.signup(self.REVIEWER_EMAIL_2, 'reviewer2')\n        self.reviewer_id_2 = self.get_user_id_from_email(self.REVIEWER_EMAIL_2)\n        self.opportunity_summary_ids = [\n            self.explorations[0].id, self.explorations[1].id,\n            self.explorations[2].id]\n        self.topic_name = 'topic'\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_2, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_2, self.target_version_at_submission,\n                self.author_id_2, self.change, 'test description')\n\n    def test_get_by_author(self) -> None:\n        queries = [('author_id', self.author_id_1)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n        queries = [('author_id', self.author_id_2)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 2)\n\n    def test_get_translation_suggestions_in_review_by_exp_ids(self) -> None:\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [\n                    self.target_id_1,\n                    self.target_id_2,\n                    self.target_id_3\n                ],\n                'en'\n            )\n        )\n        self.assertEqual(len(suggestions), 0)\n        self._create_translation_suggestion_with_language_code('en')\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [self.target_id_1],\n                'en'\n            )\n        )\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[0] is not None\n        self.assertEqual(suggestions[0].author_id, self.author_id_1)\n        self.assertEqual(suggestions[0].language_code, 'en')\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n\n    def test_get_by_target_id(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 4)\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n    def test_get_by_status(self) -> None:\n        queries = [('status', suggestion_models.STATUS_IN_REVIEW)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_get_by_type(self) -> None:\n        queries = [(\n            'suggestion_type',\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_query_suggestions(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_1),\n            ('status', suggestion_models.STATUS_IN_REVIEW)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('invalid_field', 'value')\n        ]\n        with self.assertRaisesRegex(\n            Exception, 'Not allowed to query on field invalid_field'):\n            suggestion_services.query_suggestions(queries)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_one_exp(\n        self\n    ) -> None:\n        # Create the translation suggestion associated with exploration id\n        # target_id_1.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_1, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there is one translation suggestion with the given\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_1])), 1)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_multiple_exps(\n        self\n    ) -> None:\n        # Create the translation suggestion associated with exploration id\n        # target_id_2.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_2, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n        # Create the translation suggestion associated with exploration id\n        # target_id_3.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_3, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_2, self.target_id_3])), 2)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_invalid_exp(\n        self\n    ) -> None:\n        # Assert that there are no translation suggestions with an invalid\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    ['invalid_exp_id'])), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_empty_exp_list(\n        self\n    ) -> None:\n        # Assert that there are no translation suggestions found when we\n        # use an empty exp_ids list.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids([])), 0)\n\n    def test_get_submitted_suggestions_by_offset(self) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        question_1_skill_id = 'skill1'\n        question_2_skill_id = 'skill2'\n        self._create_question_suggestion_with_skill_id(question_1_skill_id)\n        self._create_question_suggestion_with_skill_id(question_2_skill_id)\n\n        # Fetch submitted translation suggestions.\n        translatable_suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n\n        self.assertEqual(len(translatable_suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(\n            translatable_suggestions[0].target_id, self.target_id_1\n        )\n        self.assertEqual(\n            translatable_suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            translatable_suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(\n            translatable_suggestions[1].target_id, self.target_id_1\n        )\n        self.assertEqual(\n            translatable_suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            translatable_suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n        # Fetch submitted question suggestions.\n        question_suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n\n        self.assertEqual(len(question_suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(\n            question_suggestions[0].target_id, question_2_skill_id\n        )\n        self.assertEqual(\n            question_suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            question_suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(\n            question_suggestions[1].target_id, question_1_skill_id\n        )\n        self.assertEqual(\n            question_suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            question_suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration(self) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'hi'))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[0] is not None\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        # Ruling out the possibility of None for mypy type checking.\n        assert suggestions[1] is not None\n        self.assertEqual(suggestions[1].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration_returns_only_suggestions_with_supplied_language_code(  # pylint: disable=line-too-long\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'pt'))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_reviewable_translation_suggestions_with_valid_exp_ids(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_translation_suggestions_with_empty_exp_ids( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = suggestion_services.get_reviewable_translation_suggestions_by_offset(\n            self.reviewer_id_1, [],\n            constants.OPPORTUNITIES_PAGE_SIZE, 0, None)\n\n        self.assertEqual(offset, 0)\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_reviewable_translation_suggestions_with_none_exp_ids(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, None,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_translation_suggestions_with_no_reviewable_languages( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, None,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None))\n\n        # The user does not have rights to review any languages, so expect an\n        # empty result.\n        self.assertEqual(len(suggestions), 0)\n        self.assertEqual(offset, 0)\n\n    def test_get_reviewable_translation_suggestions_with_language_filter(\n        self\n    ) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get reviewable translation suggestions in Hindi.\n        language_to_filter = 'hi'\n        suggestions, _ = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None, language_to_filter))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].change.language_code, 'hi')\n        self.assertEqual(suggestions[1].change.language_code, 'hi')\n\n        # Get reviewable translation suggestions in Spanish (there are none).\n        language_to_filter = 'es'\n        suggestions, _ = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0, None, language_to_filter))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 0)\n        actual_language_code_list = [\n            suggestion.change.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list: List[str] = []\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_question_suggestions(self) -> None:\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add a few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n        # Provide the user permission to review question suggestions.\n        user_services.allow_user_to_review_question(self.reviewer_id_1)\n\n        # Get all reviewable question suggestions.\n        suggestions, offset = (\n            suggestion_services.get_reviewable_question_suggestions_by_offset(\n                self.reviewer_id_1,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n\n        # Expect that the results correspond to question suggestions.\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(offset, 2)\n        expected_suggestion_type_list = ['skill2', 'skill1']\n        actual_suggestion_type_list = [\n            suggestion.change.skill_id\n            for suggestion in suggestions\n        ]\n        self.assertEqual(\n            actual_suggestion_type_list, expected_suggestion_type_list)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_per_lang(\n        self\n    ) -> None:\n        suggestion_1 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_2 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_3 = self._create_translation_suggestion_with_language_code(\n            'hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'hi'))\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_wrong_lang(\n        self\n    ) -> None:\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'wrong_language_code'))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_question_suggestions_waiting_longest_for_review_keeps_order(\n        self\n    ) -> None:\n        \"\"\"This test makes sure that if a suggestion is rejected and is then\n        resubmitted, we count the time that the suggestion has been waiting for\n        review from when it was resubmitted, not from when it was first\n        submitted.\n        \"\"\"\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        # Verify that both suggestions are returned and in the right order.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n        # Reject the suggestion that was created first since it is the one that\n        # has been waiting the longest for review.\n        suggestion_services.reject_suggestion(\n            suggestion_1.suggestion_id, self.reviewer_id_1, 'Reject message')\n\n        # Verify that only the suggestion that was created second is returned.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = suggestion_1.change\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_question_change.question_dict, dict)\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            suggestion_1.suggestion_id, 'resubmit summary message',\n            self.author_id_1, resubmit_question_change\n        )\n\n        # Verify that both suggestions are returned again and the suggestion\n        # that was created second is now the first suggestion in the returned\n        # list, since it has been waiting longer (due to it not being updated).\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_1.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n    def test_get_question_suggestions_waiting_longest_for_review(self) -> None:\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        suggestion_3 = self._create_question_suggestion_with_skill_id('skill3')\n\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_query_suggestions_that_can_be_reviewed_by_user(self) -> None:\n        # User proficiency models for user1.\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category1', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category2', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category3', 5)\n        # User proficiency models for user2.\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category1', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category2', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category3', 5)\n\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category1',\n            'exploration.exp1.thread_1', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category2',\n            'exploration.exp1.thread_2', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category3',\n            'exploration.exp1.thread_3', None)\n        # This suggestion does not count as a suggestion that can be reviewed\n        # by a user because it has already been rejected.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change, 'category1',\n            'exploration.exp1.thread_4', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category2',\n            'exploration.exp1.thread_5', None)\n\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user1')), 3)\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user2')), 0)\n\n\nclass SuggestionIntegrationTests(test_utils.GenericTestBase):\n\n    EXP_ID: Final = 'exp1'\n    TOPIC_ID: Final = 'topic1'\n    STORY_ID: Final = 'story1'\n    TRANSLATION_LANGUAGE_CODE: Final = 'en'\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n\n    score_category: str = (\n        suggestion_models.SCORE_TYPE_CONTENT +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'Algebra')\n\n    THREAD_ID: Final = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def mock_generate_new_thread_id(\n        self, unused_entity_type: str, unused_entity_id: str\n    ) -> str:\n        return self.THREAD_ID\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.editor_id\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        # Login and create exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n\n        # Create exploration.\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                self.EXP_ID, self.editor_id,\n                ['State 1', 'State 2', 'End State'],\n                ['TextInput'], category='Algebra',\n                correctness_feedback_enabled=True))\n\n        self.old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content</p>').to_dict()\n        recorded_voiceovers_dict: state_domain.RecordedVoiceoversDict = {\n            'voiceovers_mapping': {\n                'content': {\n                    self.TRANSLATION_LANGUAGE_CODE: {\n                        'filename': 'filename3.mp3',\n                        'file_size_bytes': 3000,\n                        'needs_update': False,\n                        'duration_secs': 42.43\n                    }\n                },\n                'default_outcome': {},\n                'ca_placeholder_0': {}\n            }\n        }\n        self.old_recorded_voiceovers = (\n            state_domain.RecordedVoiceovers.from_dict(recorded_voiceovers_dict))\n        # Create content in State A with a single audio subtitle.\n        content_change = exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.old_content,\n        })\n        recorded_voiceovers_change = exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_RECORDED_VOICEOVERS,\n            'state_name': 'State 1',\n            'new_value': recorded_voiceovers_dict,\n        })\n        exp_services.update_exploration(\n            self.editor_id, exploration.id,\n            [content_change, recorded_voiceovers_change], '')\n\n        rights_manager.publish_exploration(self.editor, self.EXP_ID)\n        rights_manager.assign_role_for_exploration(\n            self.editor, self.EXP_ID, self.owner_id,\n            rights_domain.ROLE_EDITOR)\n\n        self.new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content</p>').to_dict()\n\n        self.change: Dict[\n            str, Union[str, state_domain.SubtitledHtmlDict]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.new_content\n        }\n\n        self.target_version_at_submission = exploration.version\n\n        # Set up for testing translation suggestions. Translation suggestions\n        # correspond to a given topic, story and exploration.\n\n        self.save_new_topic(self.TOPIC_ID, self.owner_id)\n\n        self.save_new_story(\n            self.STORY_ID, self.owner_id, self.TOPIC_ID, title='A story',\n            description='Description', notes='Notes')\n\n        # Adds the story to the topic.\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n\n        # Adds the exploration to the story.\n        story_change_list_to_add_an_exp = [\n            story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': self.EXP_ID\n            })\n        ]\n        story_services.update_story(\n            self.owner_id, self.STORY_ID,\n            story_change_list_to_add_an_exp, 'Added exploration.')\n\n    def create_translation_suggestion_associated_with_exp(\n        self, exp_id: str, author_id: str\n    ) -> None:\n        \"\"\"Creates a translation suggestion that is associated with an\n        exploration with id exp_id. The author of the created suggestion is\n        author_id.\n        \"\"\"\n        # Gets the html content in the exploration to be translated.\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        content_html = exploration.states['State 1'].content.html\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'State 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': content_html,\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_id, 1, author_id, add_translation_change_dict,\n            'test description')\n\n    def assert_created_suggestion_is_valid(\n        self, target_id: str, author_id: str\n    ) -> None:\n        \"\"\"Assert that the created suggestion is in review and that only one\n        suggestion with the given target_id and author_id exists.\n        \"\"\"\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', author_id), ('target_id', target_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_create_and_accept_suggestion(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, '')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_create_translation_contribution_stats_from_model(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836),\n                datetime.date.fromtimestamp(1616173837)\n            ]\n        )\n        translation_suggestion = suggestion_services.get_all_translation_contribution_stats( # pylint: disable=line-too-long\n            'user_id')\n        self.assertEqual(len(translation_suggestion), 1)\n        self.assertEqual(translation_suggestion[0].language_code, 'es')\n        self.assertEqual(\n            translation_suggestion[0].contributor_user_id,\n            'user_id'\n        )\n\n    def test_fetch_all_contribution_stats(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836),\n                datetime.date.fromtimestamp(1616173837)\n            ]\n        )\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code='es',\n            reviewer_user_id='user_id',\n            topic_id='topic_id',\n            reviewed_translations_count=1,\n            reviewed_translation_word_count=1,\n            accepted_translations_count=1,\n            accepted_translations_with_reviewer_edits_count=0,\n            accepted_translation_word_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_without_reviewer_edits_count=0,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id='user_id',\n            topic_id='topic_id',\n            reviewed_questions_count=1,\n            accepted_questions_count=1,\n            accepted_questions_with_reviewer_edits_count=1,\n            first_contribution_date=datetime.date.fromtimestamp(1616173836),\n            last_contribution_date=datetime.date.fromtimestamp(1616173836)\n        )\n\n        stats = suggestion_services.get_all_contributor_stats( # pylint: disable=line-too-long\n            'user_id')\n\n        self.assertEqual(stats.contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.translation_contribution_stats), 1)\n        self.assertEqual(\n            stats.translation_contribution_stats[0].language_code, 'es')\n        self.assertEqual(len(stats.question_contribution_stats), 1)\n        self.assertEqual(\n            stats.question_contribution_stats[0].contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.translation_review_stats), 1)\n        self.assertEqual(\n            stats.translation_review_stats[0].contributor_user_id, 'user_id')\n        self.assertEqual(len(stats.question_review_stats), 1)\n        self.assertEqual(\n            stats.question_review_stats[0].contributor_user_id, 'user_id')\n\n    def _publish_valid_topic(\n        self, topic: topic_domain.Topic,\n        uncategorized_skill_ids: List[str]) -> None:\n        \"\"\"Saves and publishes a valid topic with linked skills and subtopic.\n\n        Args:\n            topic: Topic. The topic to be saved and published.\n            uncategorized_skill_ids: list(str). List of uncategorized skills IDs\n                to add to the supplied topic.\n        \"\"\"\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        subtopic_id = 1\n        subtopic_skill_id = 'subtopic_skill_id' + topic.id\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                subtopic_id, 'Title', [subtopic_skill_id], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic')]\n        topic.next_subtopic_id = 2\n        topic.skill_ids_for_diagnostic_test = [subtopic_skill_id]\n        subtopic_page = (\n            subtopic_page_domain.SubtopicPage.create_default_subtopic_page(\n                subtopic_id, topic.id))\n        subtopic_page_services.save_subtopic_page(\n            self.owner_id, subtopic_page, 'Added subtopic',\n            [topic_domain.TopicChange({\n                'cmd': topic_domain.CMD_ADD_SUBTOPIC,\n                'subtopic_id': 1,\n                'title': 'Sample',\n                'url_fragment': 'sample-fragment'\n            })]\n        )\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(topic.id, self.admin_id)\n\n        for skill_id in uncategorized_skill_ids:\n            self.save_new_skill(\n                skill_id, self.admin_id, description='skill_description')\n            topic_services.add_uncategorized_skill(\n                self.admin_id, topic.id, skill_id)\n\n    def _set_up_topics_and_stories_for_translations(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Sets up required topics and stories for translations. It does the\n        following.\n        1. Create 2 explorations and publish them.\n        2. Create a default topic.\n        3. Publish the topic with two story IDs.\n        4. Create 2 stories for translation opportunities.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change object for the translations.\n        \"\"\"\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category=constants.ALL_CATEGORIES[i],\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        ) for i in range(2)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n\n        topic_id = '0'\n        topic = topic_domain.Topic.create_default_topic(\n            topic_id, 'topic_name', 'abbrev', 'description', 'fragm')\n        skill_id_0 = 'skill_id_0'\n        skill_id_1 = 'skill_id_1'\n        self._publish_valid_topic(topic, [skill_id_0, skill_id_1])\n\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_01', topic_id, '0')\n        self.create_story_for_translation_opportunity(\n            self.owner_id, self.admin_id, 'story_id_02', topic_id, '1')\n\n        return {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>',\n            'data_format': 'html'\n        }\n\n    def _get_change_with_normalized_string(self) -> Mapping[\n        str, change_domain.AcceptableChangeDictTypes]:\n        \"\"\"Provides change dictionary with normalized translation html.\n\n        Returns:\n            Mapping[str, change_domain.AcceptableChangeDictTypes]. A dictionary\n            of the change object for the translations.\n        \"\"\"\n        return {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': ['translated text1', 'translated text2'],\n            'data_format': 'set_of_normalized_string'\n        }\n\n    def test_update_translation_contribution_stats_without_language_codes(\n        self\n    ) -> None:\n        translation_contribution_stats = (\n            suggestion_registry.TranslationContributionStats(\n                None, 'user1', 'topic1', 1, 1, 1, 0, 1, 0, 0,\n                {datetime.date.fromtimestamp(1616173836)}\n            )\n        )\n        with self.assertRaisesRegex(\n            Exception,\n            'Language code should not be None.'):\n            suggestion_services._update_translation_contribution_stats_models(  # pylint: disable=protected-access\n                [translation_contribution_stats])\n\n    def test_update_translation_contribution_stats_without_contributor_id(\n        self\n    ) -> None:\n        translation_contribution_stats = (\n            suggestion_registry.TranslationContributionStats(\n                'hi', None, 'topic1', 1, 1, 1, 0, 1, 0, 0,\n                {datetime.date.fromtimestamp(1616173836)}\n            )\n        )\n        with self.assertRaisesRegex(\n            Exception,\n            'Contributor user ID should not be None.'):\n            suggestion_services._update_translation_contribution_stats_models(  # pylint: disable=protected-access\n                [translation_contribution_stats])\n\n    def test_update_translation_contribution_stats_without_topic_id(\n        self\n    ) -> None:\n        translation_contribution_stats = (\n            suggestion_registry.TranslationContributionStats(\n                'hi', 'user1', None, 1, 1, 1, 0, 1, 0, 0,\n                {datetime.date.fromtimestamp(1616173836)}\n            )\n        )\n        with self.assertRaisesRegex(\n            Exception,\n            'Topic ID should not be None.'):\n            suggestion_services._update_translation_contribution_stats_models(  # pylint: disable=protected-access\n                [translation_contribution_stats])\n\n    def test_get_translation_contribution_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_translation_contribution_stats_models(\n                ['invalid_id'])\n\n    def test_get_translation_contribution_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services\n            .get_translation_contribution_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_translation_review_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services\n            .get_translation_review_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_question_contribution_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = (\n            suggestion_services.get_question_contribution_stats_models\n        )(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_question_review_stats_for_strict_false(\n        self\n    ) -> None:\n        stats_models = suggestion_services.get_question_review_stats_models(\n            ['invalid_id'], strict=False)\n\n        self.assertEqual(stats_models, [None])\n\n    def test_get_translation_review_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_translation_review_stats_models(\n                ['invalid_id'])\n\n    def test_get_question_contribution_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_question_contribution_stats_models(\n                ['invalid_id'])\n\n    def test_get_question_review_stats_for_invalid_id_with_strict_true(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'The stats models do not exist for the stats_id invalid_id.'):\n            suggestion_services.get_question_review_stats_models(\n                ['invalid_id'])\n\n    def test_update_translation_contribution_stats_when_submitting(\n        self) -> None:\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, new_change_dict, 'description')\n\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            latest_suggestion\n        )\n\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation contribution stats.\n        # At this point we can confirm that there should be an associated\n        # translation contribution stat object for the given IDs since we have\n        # called update_translation_contribution_stats_at_submission function\n        # to create/update translation contribution stats.\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            0\n        )\n\n    def test_update_translation_review_stats_when_suggestion_is_accepted(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is accepted.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        new_change_dict = self._get_change_with_normalized_string()\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, new_change_dict, 'description')\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            7\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translation_word_count\n            ),\n            7\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            2\n        )\n\n    def test_update_translation_review_stats_when_suggestion_is_rejected(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is rejected.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, change_dict, 'description')\n        suggestion_services.reject_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.reviewed_translations_count,\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            0\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translation_word_count,\n            0\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            6\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.rejected_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .rejected_translations_count\n            ),\n            2\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            0\n        )\n\n    def test_update_translation_review_stats_without_a_reviewer_id(\n        self) -> None:\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        translation_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n\n        with self.assertRaisesRegex(\n            Exception,\n            'The final_reviewer_id in the suggestion should not be None.'):\n            suggestion_services.update_translation_review_stats(\n                translation_suggestion)\n\n    def test_update_question_review_stats_without_a_reviewer_id(\n        self) -> None:\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        suggestion_services.update_question_contribution_stats_at_submission(\n            initial_suggestion\n        )\n\n        with self.assertRaisesRegex(\n            Exception,\n            'The final_reviewer_id in the suggestion should not be None.'):\n            suggestion_services.update_question_review_stats(\n                initial_suggestion\n            )\n\n    def test_update_translation_review_stats_when_suggestion_is_edited(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a translation suggestion is accepted with reviewer edits.\n        # Steps required in the setup phase before testing.\n        # 1. Create and publish explorations.\n        # 2. Create and publish topics.\n        # 3. Create stories for translation opportunities.\n        # 4. Save translation suggestions.\n        change_dict = self._set_up_topics_and_stories_for_translations()\n        initial_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '0', 1, self.author_id, change_dict, 'description')\n        latest_suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            '1', 1, self.author_id, change_dict, 'description')\n        # Contributor's stats are updated manually since contributor's stats are\n        # checked later.\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_translation_contribution_stats_at_submission(\n            latest_suggestion\n        )\n        suggestion_services.update_translation_suggestion(\n            initial_suggestion.suggestion_id, 'Edited')\n        suggestion_services.update_translation_suggestion(\n            latest_suggestion.suggestion_id, 'Edited')\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_translation_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                'hi', self.reviewer_id, '0'\n            )\n        )\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                'hi', self.author_id, '0'\n            )\n        )\n        # Assert translation review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # translation review stat object for the given IDs since we have\n        # called update_translation_review_stats function to create/update\n        # translation review stats.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translation_word_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            2\n        )\n        self.assertEqual(\n            translation_review_stats_model\n            .accepted_translations_with_reviewer_edits_count,\n            2\n        )\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            6\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            2\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translations_without_reviewer_edits_count\n            ),\n            0\n        )\n\n    def _create_question_suggestion(\n        self,\n        skill_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion corresponding to the supplied skill.\n\n        Args:\n            skill_id: str. ID of the skill.\n\n        Returns:\n            SuggestionAddQuestion. A new question suggestion.\n        \"\"\"\n        suggestion_change: Dict[\n            str,\n            Union[str, float, Dict[str, Union[\n                str, List[str], int, state_domain.StateDict]]]] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_2'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n    def _create_skill(self) -> str:\n        \"\"\"Creates a skill for a question.\n\n        Returns:\n            str. A skill ID.\n        \"\"\"\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        return skill_id\n\n    def _create_topic(self, first_skill_id: str, second_skill_id: str) -> str:\n        \"\"\"Creates a topic for a question.\n\n        Args:\n            first_skill_id: str. ID of the first skill.\n            second_skill_id: str. ID of the second skill.\n\n        Returns:\n            str. A topic ID.\n        \"\"\"\n        topic_id = topic_fetchers.get_new_topic_id()\n        self.save_new_topic(\n            topic_id, 'topic_admin', name='Topic1',\n            abbreviated_name='topic-three', url_fragment='topic-three',\n            description='Description',\n            canonical_story_ids=[],\n            additional_story_ids=[],\n            uncategorized_skill_ids=[first_skill_id, second_skill_id],\n            subtopics=[], next_subtopic_id=1)\n        return topic_id\n\n    def test_update_question_contribution_stats_when_submitting(self) -> None:\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n\n        # Action to update question contribution stats.\n        suggestion_services.update_question_contribution_stats_at_submission(\n            initial_suggestion\n        )\n        suggestion_services.update_question_contribution_stats_at_submission(\n            latest_suggestion\n        )\n\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question contribution stats before the review.\n        # At this point we can confirm that there should be an associated\n        # question contribution stat object for the given IDs since we have\n        # called update_question_contribution_stats_at_submission function to\n        # create/update question contribution stats.\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.submitted_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            0\n        )\n\n    def test_update_question_stats_when_suggestion_is_accepted(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is accepted.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n\n        # Action to update stats when reviewing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            2\n        )\n\n    def test_update_question_stats_when_suggestion_is_rejected(\n        self) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is rejected.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        suggestion_services.reject_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n        suggestion_services.reject_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Rejected')\n\n        # Action to update stats when revieweing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats after the review.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .reviewed_questions_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            0\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n\n    def test_update_question_stats_when_suggestion_is_edited(\n        self\n    ) -> None:\n        # This test case will check stats of the reviewer and the submitter\n        # when a question suggestion is accepted with reviewer edits.\n        # Steps required in the setup phase before testing.\n        # 1. Save new skills.\n        # 2. Save a topic assigning skills for it.\n        # 3. Create a question suggestion.\n        skill_id_1 = self._create_skill()\n        skill_id_2 = self._create_skill()\n        topic_id = self._create_topic(skill_id_1, skill_id_2)\n        initial_suggestion = self._create_question_suggestion(skill_id_1)\n        latest_suggestion = self._create_question_suggestion(skill_id_2)\n        question_state_data = self._create_valid_question_data(\n            'default_state').to_dict()\n        suggestion_services.accept_suggestion(\n            initial_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.accept_suggestion(\n            latest_suggestion.suggestion_id, self.reviewer_id, 'Accepted',\n            'Accepted')\n        suggestion_services.update_question_suggestion(\n            initial_suggestion.suggestion_id, 0.6, question_state_data)\n        suggestion_services.update_question_suggestion(\n            latest_suggestion.suggestion_id, 0.6, question_state_data)\n\n        # Actual action to update stats when reviewing.\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                initial_suggestion.suggestion_id)\n        )\n        suggestion_services.update_question_review_stats(\n            suggestion_services.get_suggestion_by_id(\n                latest_suggestion.suggestion_id)\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.reviewer_id, topic_id\n            )\n        )\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.author_id, topic_id\n            )\n        )\n        # Assert question review stats.\n        # At this point we can confirm that there should be an associated\n        # question review stat object for the given IDs since we have\n        # called update_question_review_stats function to create/update question\n        # review stats.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            2\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .accepted_questions_with_reviewer_edits_count\n            ),\n            2\n        )\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            2\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            0\n        )\n\n    def test_create_and_reject_suggestion(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.reject_suggestion(\n            suggestion_id, self.reviewer_id, 'Reject message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Reject message')\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>old content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_REJECTED)\n\n    def test_create_and_accept_suggestion_with_message(self) -> None:\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'Accept message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Accept message')\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_delete_skill_rejects_question_suggestion(self) -> None:\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        self.assert_created_suggestion_is_valid(skill_id, self.author_id)\n\n        skill_services.delete_skill(self.author_id, skill_id)\n\n        # Suggestion should be rejected after corresponding skill is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', skill_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_topic_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        topic_services.delete_topic(self.author_id, self.TOPIC_ID)\n\n        # Suggestion should be rejected after the topic is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_story_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        story_services.delete_story(self.author_id, self.STORY_ID)\n\n        # Suggestion should be rejected after the story is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_remove_exp_from_story_rejects_translation_suggestion(self) -> None:\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        # Removes the exploration from the story.\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': self.EXP_ID,\n                'new_value': None\n            })], 'Removed exploration.')\n\n        # Suggestion should be rejected after exploration is removed from the\n        # story.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_get_suggestions_with_translatable_explorations(self) -> None:\n        # Create a translation suggestion for (state_name, content_id) =\n        # (State 2, content).\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        state_name = 'State 2'\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': state_name,\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': exploration.states[state_name].content.html,\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.EXP_ID, 1, self.author_id, add_translation_change_dict,\n            'test description')\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n\n        translatable_suggestions = []\n        for suggestion in suggestions:\n            assert isinstance(\n                suggestion, suggestion_registry.SuggestionTranslateContent\n            )\n            translatable_suggestions.append(suggestion)\n\n        # Should return the created translation suggestion.\n        filtered_translatable_suggestions = (\n            suggestion_services.get_suggestions_with_translatable_explorations(\n                translatable_suggestions\n            )\n        )\n        self.assertEqual(len(filtered_translatable_suggestions), 1)\n\n        # Delete the exploration state corresponding to the translation\n        # suggestion.\n        init_state = exploration.states[exploration.init_state_name]\n        outcome_object = init_state.interaction.default_outcome\n        # Ruling out the possibility of None for mypy type checking.\n        assert outcome_object is not None\n        default_outcome_dict = outcome_object.to_dict()\n        default_outcome_dict['dest'] = 'End State'\n        exp_services.update_exploration(\n            self.owner_id, self.EXP_ID, [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME),\n                    'state_name': exploration.init_state_name,\n                    'new_value': default_outcome_dict\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_DELETE_STATE,\n                    'state_name': state_name,\n                }),\n            ], 'delete state')\n\n        # The suggestion no longer corresponds to an existing exploration state,\n        # so it should not be returned.\n        filtered_translatable_suggestions = (\n            suggestion_services.get_suggestions_with_translatable_explorations(\n                translatable_suggestions\n            )\n        )\n        self.assertEqual(len(filtered_translatable_suggestions), 0)\n\n\nclass UserContributionProficiencyUnitTests(test_utils.GenericTestBase):\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup('user1@example.com', 'user1')\n        self.signup('user2@example.com', 'user2')\n        self.user_1_id = self.get_user_id_from_email('user1@example.com')\n        self.user_2_id = self.get_user_id_from_email('user2@example.com')\n\n    def test_get_all_user_ids_who_are_allowed_to_review(self) -> None:\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2',\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category2', 0)\n\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category1'))\n        self.assertEqual(user_ids, [])\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category2'))\n        self.assertEqual(user_ids, [self.user_1_id])\n\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category1'))\n        self.assertTrue(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category2'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n\n    def test_get_all_scores_of_the_user_with_multiple_scores(self) -> None:\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 1)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2', 2)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category3', 3)\n\n        expected_scores_dict = {}\n        for index in range(1, 4):\n            key = 'category%s' % str(index)\n            expected_scores_dict[key] = index\n\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 3)\n        self.assertDictEqual(scores_dict, expected_scores_dict)\n\n    def test_get_all_scores_of_the_user_when_no_scores_exist(self) -> None:\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 0)\n        self.assertDictEqual(scores_dict, {})\n\n\nclass ReviewableSuggestionEmailInfoUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Tests the methods related to the ReviewableSuggestionEmailInfo class.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill1'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author1@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_translation_html(\n        self, translation_html: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion with the given translation_html.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': translation_html,\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_question_html_content(\n        self, question_html_content: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the html content used for the\n        question in the question suggestion.\n        \"\"\"\n        with self.swap(\n            feconf, 'DEFAULT_INIT_STATE_CONTENT_STR', question_html_content):\n            add_question_change_dict: Dict[\n                str, Union[str, float, question_domain.QuestionDict]\n            ] = {\n                'cmd': (\n                    question_domain\n                    .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                'question_dict': {\n                    'id': 'test_id',\n                    'version': 12,\n                    'question_state_data': self._create_valid_question_data(\n                        'default_state').to_dict(),\n                    'language_code': self.language_code,\n                    'question_state_data_schema_version': (\n                        feconf.CURRENT_STATE_SCHEMA_VERSION),\n                    'linked_skill_ids': ['skill_1'],\n                    'inapplicable_skill_misconception_ids': ['skillid12345-1']\n                },\n                'skill_id': self.skill_id,\n                'skill_difficulty': 0.3\n            }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionEditStateContent:\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict: Dict[\n            str, Union[str, Dict[str, str]]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            None)\n\n    def _assert_reviewable_suggestion_email_infos_are_equal(\n        self,\n        reviewable_suggestion_email_info: (\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ),\n        expected_reviewable_suggestion_email_info: (\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        )\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email info is equal to the\n        expected reviewable suggestion email info.\n        \"\"\"\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_type,\n            expected_reviewable_suggestion_email_info.suggestion_type)\n        self.assertEqual(\n            reviewable_suggestion_email_info.language_code,\n            expected_reviewable_suggestion_email_info.language_code)\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_content,\n            expected_reviewable_suggestion_email_info.suggestion_content)\n        self.assertEqual(\n            reviewable_suggestion_email_info.submission_datetime,\n            expected_reviewable_suggestion_email_info.submission_datetime)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n\n    def test_create_raises_for_suggestion_type_not_on_contributor_dashboard(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        # Mocking the SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS dict in\n        # suggestion services so that this test still passes if the\n        # \"edit state content\" suggestion type is added to the Contributor\n        # Dashboard in the future.\n        suggestion_emphasized_text_getter_functions_mock: Dict[str, str] = {}\n\n        with self.swap(\n            suggestion_services, 'SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS',\n            suggestion_emphasized_text_getter_functions_mock):\n            with self.assertRaisesRegex(\n                Exception,\n                'Expected suggestion type to be offered on the Contributor '\n                'Dashboard, received: %s.' % (\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)):\n                (\n                    suggestion_services\n                    .create_reviewable_suggestion_email_info_from_suggestion(\n                        edit_state_content_suggestion)\n                )\n\n    def test_contributor_suggestion_types_are_in_suggestion_text_getter_dict(\n        self\n    ) -> None:\n        # This test will fail if a new suggestion type is added to the\n        # Contributor Dashboard but hasn't been added to\n        # SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.\n        sorted_text_getter_dict_suggestion_types = sorted(\n            suggestion_services\n            .SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.keys())\n        sorted_contributor_dashboard_suggestion_types = sorted(\n            feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES)\n\n        self.assertListEqual(\n            sorted_text_getter_dict_suggestion_types,\n            sorted_contributor_dashboard_suggestion_types)\n\n    def test_create_from_suggestion_returns_info_for_question_suggestion(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p>default question content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'default question content',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_translation_suggestion(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p>default translation content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'default translation content',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_empty_html(self) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ''))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code, '',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_with_no_trailing_whitespace(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ' <p>          test whitespace     </p>    '))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'test whitespace',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_math_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_image_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-image alt-with-value=\\'&amp;quot;'\n                'test&amp;quot;\\' caption-with-value=\\'&amp;quot;&amp;'\n                'quot;\\' filepath-with-value=\\'&amp;quot;img.svg&amp;quot;'\n                '\\'></oppia-noninteractive-image></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Image]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_link_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_repeats(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_multi_rte(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_value(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                '[Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_math_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_image_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-image alt-with-value=\\'&amp;quot;'\n                'testing&amp;quot;\\' caption-with-value=\\'&amp;quot;&amp;'\n                'quot;\\' filepath-with-value=\\'&amp;quot;img.svg&amp;quot;'\n                '\\'></oppia-noninteractive-image></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Image]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info)\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_link_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_repeat_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_multi_rte(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link text-with-value=\\'&amp;quot;'\n                'codebase&amp;quot;\\' url-with-value=\\'&amp;quot;'\n                'https://github.com/oppia/oppia/&amp;quot;\\'>'\n                '</oppia-noninteractive-link></p>'\n                '<oppia-noninteractive-math math_content-with-value=\\''\n                '{&amp;quot;raw_latex&amp;quot;:&amp;quot;+,-,-,+&amp;'\n                'quot;, &amp;quot;svg_filename&amp;quot;: &amp;quot;'\n                'mathImg.svg&amp;quot;}\\'></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_rte_value(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_text(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\">text</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_html(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"><p>text</p></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_multi_word(\n        self\n    ) -> None:\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link-test text-with-value='\n                '\"&amp;quot;Test a tag&amp;quot;\" url-with-value=\"&amp;quot;'\n                'somelink&amp;quot;\"><p>text</p>'\n                '</oppia-noninteractive-link-test></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link Test]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n\nclass GetSuggestionsWaitingForReviewInfoToNotifyReviewersUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_suggestions_waitng_for_review_info_to_notify_reviewers method\n    in suggestion services, which is used to retrieve the information required\n    to notify reviewers that there are suggestions that need review.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author1@example.com'\n    REVIEWER_1_EMAIL: Final = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL: Final = 'reviewer2@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_language_code_and_author(\n        self, language_code: str, author_id: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code with the\n        given author id.\n        \"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_skill_id_and_author_id(\n        self, skill_id: str, author_id: str\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n        self, suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> List[suggestion_registry.ReviewableSuggestionEmailInfo]:\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n        self,\n        reviewable_suggestion_email_infos: (\n            List[suggestion_registry.ReviewableSuggestionEmailInfo]\n        ),\n        expected_reviewable_suggestion_email_infos: (\n            List[suggestion_registry.ReviewableSuggestionEmailInfo]\n        )\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n\n    def test_get_returns_empty_for_reviewers_who_authored_the_suggestions(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_question_reviewers_if_only_translation_exist(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_translation_reviewers_if_only_question_exist(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_accepted_suggestions(self) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_rejected_suggestions(self) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_a_translation_reviewer_same_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_empty_for_a_translation_reviewer_with_diff_lang_rights(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_translation_reviewer_multi_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_same_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create another translation suggestion so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit.\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_diff_lang(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        # Create another hindi and english translation suggestion so that we\n        # reach the MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit for each\n        # language code but continue to update which suggestions have been\n        # waiting the longest (since the top two suggestions waiting the\n        # longest are from different language codes).\n        self._create_translation_suggestion_with_language_code_and_author(\n            'en', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 2):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multiple_translation_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_suggestion_infos_for_reviewer_with_multi_review_rights(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_4 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_a_question_reviewer(self) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_question_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_question_reviewer_past_limit(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_2', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]\n                )\n            )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_reviewers_with_multi_rights(\n        self\n    ) -> None:\n        # Reviewer 1's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        # Reviewer 2's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'fr')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'fr', self.author_id))\n        suggestion_4 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_6 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_4, suggestion_5,\n                    suggestion_6]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_infos_for_reviewer_with_multi_rights_past_limit(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create additional suggestions so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit regardless of\n        # suggestion type.\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n\nclass CommunityContributionStatsUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functionality related to updating the community contribution\n    stats.\n\n    TODO(#10957): It is currently not possible to resubmit a rejected\n    translation suggestion for review. As a result, there isn't a test for\n    that case in this test class. If the functionality is added, a new test\n    should be added here to cover that case. If the functionality is not going\n    to be added then this can be removed. See issue #10957 for more context.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n    COMMIT_MESSAGE: Final = 'commit message'\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionEditStateContent:\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict: Dict[\n            str, Union[str, Dict[str, str]]\n        ] = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(self) -> None:\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats()\n        )\n\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_create_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        self._create_edit_state_content_suggestion()\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_accept_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.accept_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestions_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion_1 = (\n            self._create_edit_state_content_suggestion())\n        edit_state_content_suggestion_2 = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestions(\n            [\n                edit_state_content_suggestion_1.suggestion_id,\n                edit_state_content_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_edit_state_content_suggestion_does_not_change_the_counts(\n        self\n    ) -> None:\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the new_value of the html of the suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_suggestion_change = edit_state_content_suggestion.change\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_suggestion_change.new_value, dict)\n        resubmit_suggestion_change.new_value['html'] = 'new html to resubmit'\n\n        # Resubmit the rejected \"edit state content\" suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            edit_state_content_suggestion.suggestion_id,\n            'resubmit summary message', self.author_id,\n            resubmit_suggestion_change)\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_question_suggestion_increases_question_suggestion_count(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_multi_question_suggestions_increases_question_count(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_accept_question_suggestion_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.accept_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestion_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestions_decreases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion_1 = self._create_question_suggestion()\n        question_suggestion_2 = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestions(\n            [\n                question_suggestion_1.suggestion_id,\n                question_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_question_suggestion_increases_question_suggestion_count(\n        self\n    ) -> None:\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        # Assert that the question suggestion decreased because the suggestion\n        # was rejected.\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = question_suggestion.change\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(resubmit_question_change.question_dict, dict)\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            question_suggestion.suggestion_id, 'resubmit summary message',\n            self.author_id, resubmit_question_change\n        )\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_translation_suggestion_raises_translation_suggestion_count(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code(\n            self.language_code)\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n    def test_create_translation_suggestions_diff_lang_raises_translation_counts(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n    def test_create_translation_suggestions_eq_lang_increases_translation_count(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'hi': 2})\n\n    def test_accept_translation_suggestion_lowers_translation_suggestion_count(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestion_lowers_translation_suggestion_count(\n        self\n    ) -> None:\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_one_translation_suggestion_diff_lang_lowers_only_one_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        # Create a translation suggestion in a different language that won't be\n        # rejected.\n        self._create_translation_suggestion_with_language_code('en')\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion_1.suggestion_id, self.reviewer_id,\n            'review message')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'en': 1})\n\n    def test_reject_translation_suggestions_diff_lang_lowers_translation_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestions_same_lang_lowers_translation_count(\n        self\n    ) -> None:\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 2})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_suggestions_diff_type_decreases_suggestion_counts(\n        self\n    ) -> None:\n        suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        suggestion_3 = self._create_edit_state_content_suggestion()\n        suggestion_4 = self._create_question_suggestion()\n        # Assert that the suggestion counts increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                suggestion_1.suggestion_id, suggestion_2.suggestion_id,\n                suggestion_3.suggestion_id, suggestion_4.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_suggestions_diff_type_increases_suggestion_counts(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n\nclass GetSuggestionsWaitingTooLongForReviewInfoForAdminsUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_info_about_suggestions_waiting_too_long_for_review method in suggestion\n    services, which is used to retrieve the information required to notify\n    admins if there are suggestions that have waited longer than\n    suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days for a\n    review on the Contributor Dashboard.\n    \"\"\"\n\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: str = 'author@example.com'\n    REVIEWER_1_EMAIL: str = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL: str = 'reviewer2@community.org'\n    COMMIT_MESSAGE: str = 'commit message'\n    mocked_datetime_utcnow: datetime.datetime = (\n        datetime.datetime(2020, 6, 15, 5)\n    )\n\n    def _create_translation_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n        self, suggestions: List[suggestion_registry.BaseSuggestion]\n    ) -> List[suggestion_registry.ReviewableSuggestionEmailInfo]:\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n        self, reviewable_suggestion_email_infos: List[\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ],\n        expected_reviewable_suggestion_email_infos: List[\n            suggestion_registry.ReviewableSuggestionEmailInfo\n        ]\n    ) -> None:\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_get_returns_empty_for_suggestion_type_not_on_contributor_dashboard(\n        self\n    ) -> None:\n        self._create_translation_suggestion()\n        # This mocked list cannot be empty because then the storage query in the\n        # get_suggestions_waiting_too_long_for_review method will fail.\n        mocked_contributor_dashboard_suggestion_types = [\n            feconf.SUGGESTION_TYPE_ADD_QUESTION]\n\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES',\n            mocked_contributor_dashboard_suggestion_types):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestion_review_wait_time_diff_is_negative(\n        self\n    ) -> None:\n        self._create_translation_suggestion()\n\n        # Make sure the threshold is nonzero.\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 1):\n            info_about_suggestions_waiting_too_long_for_review = (\n                suggestion_services\n                .get_info_about_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestions_have_waited_less_than_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n            self._create_question_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_less_than_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=1))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_less_than_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestions_have_waited_threshold_review_time(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_eq_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(\n                days=mocked_threshold_review_wait_time_in_days))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_eq_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_suggestion_waited_long_if_their_wait_is_past_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        # Give the question suggestion a slightly different review submission\n        # time so that the suggestions are not indistinguishable, in terms of\n        # their review submission time.\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(minutes=5)):\n            question_suggestion = self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion, question_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 1\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n    def test_get_only_returns_suggestions_that_have_waited_past_wait_threshold(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2)):\n            self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 3\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=4))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        # The question suggestion was created 2 days after the translation\n        # suggestion, so it has only waited 1 day for a review, which is less\n        # than 3, the mocked review wait time threshold. Therefore, only the\n        # translation suggestion has waited too long for review.\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n\nclass GetSuggestionTypesThatNeedReviewersUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the get_suggestion_types_that_need_reviewers method.\"\"\"\n\n    sample_language_code: str = 'en'\n    target_id: str = 'exp1'\n    skill_id: str = 'skill_123456'\n    language_code: str = 'en'\n    AUTHOR_EMAIL: Final = 'author@example.com'\n    REVIEWER_EMAIL: Final = 'reviewer@community.org'\n\n    def _create_translation_suggestion_with_language_code(\n        self, language_code: str\n    ) -> suggestion_registry.SuggestionTranslateContent:\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(\n        self\n    ) -> suggestion_registry.SuggestionAddQuestion:\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': constants.DEFAULT_LANGUAGE_CODE,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(\n        self\n    ) -> None:\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats())\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n\n    def test_get_returns_no_reviewers_needed_if_no_suggestions_exist(\n        self\n    ) -> None:\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_question_reviewer_no_question(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_not_needed_if_translation_reviewers_but_no_translation(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_translation_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_question_reviewers(\n        self\n    ) -> None:\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_reviewers_needed_if_question_but_no_reviewers(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_ADD_QUESTION: set()})\n\n    def test_get_returns_reviewers_needed_if_translation_for_a_lang_no_reviewer(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code(\n            self.sample_language_code)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                self.sample_language_code: 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                self.sample_language_code}})\n\n    def test_get_returns_reviewers_needed_if_translation_for_langs_no_reviewers(\n        self\n    ) -> None:\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {'en', 'fr'}})\n\n    def test_get_returns_reviewers_needed_if_multi_suggestion_types_no_reviewer(\n        self\n    ) -> None:\n        self._create_question_suggestion()\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                    'en', 'fr'},\n                feconf.SUGGESTION_TYPE_ADD_QUESTION: set()\n            })\n\n\nclass EmailsTaskqueueTests(test_utils.GenericTestBase):\n    \"\"\"Tests for tasks in emails taskqueue.\"\"\"\n\n    def test_create_new_instant_task(self) -> None:\n        user_id = 'user'\n        (\n            suggestion_services\n            .enqueue_contributor_ranking_notification_email_task(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'hi',\n                'Initial Contributor'\n            ))\n\n        self.assertEqual(\n            self.count_jobs_in_taskqueue(\n                taskqueue_services.QUEUE_NAME_EMAILS),\n            1)\n\n        tasks = self.get_pending_tasks(\n            queue_name=taskqueue_services.QUEUE_NAME_EMAILS)\n        self.assertEqual(\n            tasks[0].url,\n            feconf\n            .TASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS)\n        # Ruling out the possibility of None for mypy type checking.\n        assert tasks[0].payload is not None\n        self.assertEqual(\n            tasks[0].payload['contributor_user_id'], user_id)\n        self.assertEqual(\n            tasks[0].payload['contribution_type'],\n            feconf.CONTRIBUTION_TYPE_TRANSLATION)\n        self.assertEqual(\n            tasks[0].payload['contribution_sub_type'],\n            feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE)\n        self.assertEqual(tasks[0].payload['language_code'], 'hi')\n        self.assertEqual(\n            tasks[0].payload['rank_name'], 'Initial Contributor')\n\n    def test_create_email_task_raises_exception_for_invalid_language_code(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Not supported language code: error'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'error',\n                'Initial Contributor'\n            )\n\n    def test_create_email_task_raises_exception_for_invalid_contribution_type(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Invalid contribution type: test'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, 'test',\n                feconf.CONTRIBUTION_SUBTYPE_ACCEPTANCE, 'hi',\n                'Initial Contributor'\n            )\n\n    def test_create_email_task_raises_exception_for_wrong_contribution_subtype(\n        self\n    ) -> None:\n        user_id = 'user'\n        with self.assertRaisesRegex(\n            Exception,\n            'Invalid contribution subtype: test'):\n            (\n                suggestion_services\n                .enqueue_contributor_ranking_notification_email_task\n            )(\n                user_id, feconf.CONTRIBUTION_TYPE_TRANSLATION,\n                'test', 'hi',\n                'Initial Contributor'\n            )\n\n\nclass ContributorCertificateTests(test_utils.GenericTestBase):\n    \"\"\"Tests for contributor certificate generation.\"\"\"\n\n    AUTHOR_EMAIL: Final = 'author@example.com'\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.username = user_services.get_username(self.author_id)\n        self.from_date = datetime.datetime.today() - datetime.timedelta(days=1)\n        self.to_date = datetime.datetime.today() + datetime.timedelta(days=1)\n\n    def test_create_translation_contributor_certificate(self) -> None:\n        score_category: str = (\n            suggestion_models.SCORE_TYPE_TRANSLATION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n        change_cmd = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_1', change_cmd, score_category,\n            'exploration.exp1.thread_6', 'hi')\n\n        response = suggestion_services.generate_contributor_certificate_data(\n            self.username,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            'hi',\n            self.from_date,\n            self.to_date,\n        )\n\n        self.assertIsNotNone(response)\n\n    def test_create_translation_contributor_certificate_for_english(\n        self\n    ) -> None:\n        score_category: str = (\n            suggestion_models.SCORE_TYPE_TRANSLATION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n        change_cmd = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'en',\n            'content_html': '',\n            'state_name': 'Introduction',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_1', change_cmd, score_category,\n            'exploration.exp1.thread_6', 'en')\n\n        response = suggestion_services.generate_contributor_certificate_data(\n            self.username,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            'en',\n            self.from_date,\n            self.to_date,\n        )\n\n        self.assertIsNotNone(response)\n\n    def test_create_question_contributor_certificate(self) -> None:\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': 1,\n            'skill_difficulty': 0.3\n        }\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content']['html'] = '<p>No image content</p>'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', 1,\n            suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_2', suggestion_change, 'category1',\n            'thread_1', 'en')\n\n        response = suggestion_services.generate_contributor_certificate_data(\n            self.username,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            None,\n            self.from_date,\n            self.to_date,\n        )\n\n        self.assertIsNotNone(response)\n\n    def test_create_question_contributor_certificate_with_image_content(\n        self\n    ) -> None:\n        suggestion_change: Dict[\n            str, Union[str, float, question_domain.QuestionDict]\n        ] = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'id': 'test_id',\n                'version': 12,\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': 1,\n            'skill_difficulty': 0.3\n        }\n        # Ruling out the possibility of any other type for mypy type checking.\n        assert isinstance(suggestion_change['question_dict'], dict)\n        test_question_dict: question_domain.QuestionDict = (\n            suggestion_change['question_dict']\n        )\n\n        question_state_data = test_question_dict['question_state_data']\n        question_state_data['content']['html'] = (\n            '<oppia-noninteractive-image></oppia-noninteractive-image>')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', 1,\n            suggestion_models.STATUS_ACCEPTED, self.author_id,\n            'reviewer_2', suggestion_change, 'category1',\n            'thread_1', 'en')\n\n        response = suggestion_services.generate_contributor_certificate_data(\n            self.username,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            None,\n            self.from_date,\n            self.to_date,\n        )\n\n        self.assertIsNotNone(response)\n\n    def test_create_contributor_certificate_raises_exception_for_no_suggestions(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'There are no contributions for the given time range.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_certificate_raises_exception_for_no_question_suggestions(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception,\n            'There are no contributions for the given time range.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                None,\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_language(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'The provided language is invalid.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'test',\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_username(\n        self\n    ) -> None:\n        username = 'wrong_user'\n\n        with self.assertRaisesRegex(\n            Exception, 'There is no user for the given username.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                username,\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                'hi',\n                self.from_date,\n                self.to_date,\n            )\n\n    def test_create_contributor_certificate_raises_exception_for_wrong_type(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'The suggestion type is invalid.'\n        ):\n            suggestion_services.generate_contributor_certificate_data(\n                self.username,\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                'test',\n                self.from_date,\n                self.to_date,\n            )\n"
    },
    {
      "filename": "core/feconf.py",
      "content": "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Stores various configuration options and constants for Oppia.\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport datetime\nimport enum\nimport os\n\nfrom core.constants import constants\n\nfrom typing import Callable, Dict, Final, List, TypedDict, Union\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    # Here, we are importing 'state_domain' only for type checking.\n    from core.domain import state_domain\n\n# The datastore model ID for the list of featured activity references. This\n# value should not be changed.\nACTIVITY_REFERENCE_LIST_FEATURED = 'featured'\nALL_ACTIVITY_REFERENCE_LIST_TYPES = [ACTIVITY_REFERENCE_LIST_FEATURED]\n\n# The values which a post_commit_status can have: public, private.\nPOST_COMMIT_STATUS_PUBLIC = 'public'\nPOST_COMMIT_STATUS_PRIVATE = 'private'\n\n\nclass ValidCmdDict(TypedDict):\n    \"\"\"Dictionary representing valid commands specs.\"\"\"\n\n    name: str\n    required_attribute_names: List[str]\n    optional_attribute_names: List[str]\n    user_id_attribute_names: List[str]\n    allowed_values: Dict[str, List[str]]\n    deprecated_values: Dict[str, List[str]]\n\n\nclass RteTypeTextAngularDict(TypedDict):\n    \"\"\"Dict representing RTE_TYPE_TEXTANGULAR Dictionary.\"\"\"\n\n    ALLOWED_PARENT_LIST: Dict[str, List[str]]\n    ALLOWED_TAG_LIST: List[str]\n\n\n# Supported object types for ParamSpec.\nSUPPORTED_OBJ_TYPES = {\n    'UnicodeString',\n}\n\n\n# Whether to unconditionally log info messages.\nDEBUG = False\n\n\ndef check_dev_mode_is_true() -> None:\n    \"\"\"When DEV_MODE is true check that we are running in development\n    environment. The SERVER_SOFTWARE environment variable does not exist\n    in Travis, hence the need for an explicit check.\n    \"\"\"\n    if constants.DEV_MODE and os.getenv('SERVER_SOFTWARE'):\n        server_software = os.getenv('SERVER_SOFTWARE')\n        if (\n                server_software and\n                not server_software.startswith(('Development', 'gunicorn'))\n        ):\n            raise Exception('DEV_MODE can\\'t be true on production.')\n\n\ncheck_dev_mode_is_true()\n\nCLASSIFIERS_DIR = os.path.join('extensions', 'classifiers')\nTESTS_DATA_DIR = os.path.join('core', 'tests', 'data')\nSAMPLE_EXPLORATIONS_DIR = os.path.join('data', 'explorations')\nSAMPLE_COLLECTIONS_DIR = os.path.join('data', 'collections')\nCONTENT_VALIDATION_DIR = os.path.join('core', 'domain')\n\nEXTENSIONS_DIR_PREFIX = ('build' if not constants.DEV_MODE else '')\nACTIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'actions'))\nISSUES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'issues'))\nINTERACTIONS_DIR = (\n    os.path.join('extensions', 'interactions'))\nINTERACTIONS_SPECS_FILE_PATH = (\n    os.path.join(INTERACTIONS_DIR, 'interaction_specs.json'))\nRTE_EXTENSIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'rich_text_components'))\nRTE_EXTENSIONS_DEFINITIONS_PATH = (\n    os.path.join('assets', 'rich_text_components_definitions.ts'))\n\nOBJECT_TEMPLATES_DIR = os.path.join('extensions', 'objects', 'templates')\n\n# Choose production templates folder when we are in production mode.\nFRONTEND_TEMPLATES_DIR = (\n    os.path.join('webpack_bundles') if constants.DEV_MODE else\n    os.path.join('build', 'webpack_bundles'))\n# To know more about AOT visit https://angular.io/guide/glossary#aot\nFRONTEND_AOT_DIR = (\n    os.path.join('dist', 'oppia-angular') if constants.DEV_MODE else\n    os.path.join('dist', 'oppia-angular-prod'))\nDEPENDENCIES_TEMPLATES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'dependencies'))\n\nVALUE_GENERATORS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'value_generators')\nVALUE_GENERATORS_DIR = os.path.join('extensions', 'value_generators')\n\nVISUALIZATIONS_DIR = os.path.join(\n    'extensions', 'visualizations')\nVISUALIZATIONS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'visualizations')\n\nOBJECT_DEFAULT_VALUES_EXTENSIONS_MODULE_PATH = os.path.join(\n    'objects', 'object_defaults.json')\nRULES_DESCRIPTIONS_EXTENSIONS_MODULE_PATH = os.path.join(\n    'interactions', 'rule_templates.json')\nHTML_FIELD_TYPES_TO_RULE_SPECS_EXTENSIONS_MODULE_PATH = os.path.join(\n    'interactions', 'html_field_types_to_rule_specs.json')\nLEGACY_HTML_FIELD_TYPES_TO_RULE_SPECS_EXTENSIONS_MODULE_DIR = os.path.join(\n    'interactions', 'legacy_html_field_types_to_rule_specs_by_state_version')\n\n\nclass ValidModelNames(enum.Enum):\n    \"\"\"Enum for valid model names.\"\"\"\n\n    ACTIVITY = 'activity'\n    APP_FEEDBACK_REPORT = 'app_feedback_report'\n    AUDIT = 'audit'\n    BASE_MODEL = 'base_model'\n    BEAM_JOB = 'beam_job'\n    BLOG = 'blog'\n    CLASSIFIER = 'classifier'\n    CLASSROOM = 'classroom'\n    COLLECTION = 'collection'\n    CONFIG = 'CONFIG'\n    EMAIL = 'email'\n    EXPLORATION = 'exploration'\n    FEEDBACK = 'feedback'\n    IMPROVEMENTS = 'improvements'\n    JOB = 'job'\n    LEARNER_GROUP = 'learner_group'\n    OPPORTUNITY = 'opportunity'\n    QUESTION = 'question'\n    RECOMMENDATIONS = 'recommendations'\n    SKILL = 'skill'\n    STATISTICS = 'statistics'\n    AUTH = 'auth'\n    STORY = 'story'\n    SUBTOPIC = 'subtopic'\n    SUGGESTION = 'suggestion'\n    TOPIC = 'topic'\n    TRANSLATION = 'translation'\n    USER = 'user'\n\n\n# A mapping of interaction ids to classifier properties.\n# TODO(#10217): As of now we support only one algorithm per interaction.\n# However, we do have the necessary storage infrastructure to support multiple\n# algorithms per interaction. Hence, whenever we find a secondary algorithm\n# candidate for any of the supported interactions, the logical functions to\n# support multiple algorithms need to be implemented.\n\n\nclass ClassifierDict(TypedDict):\n    \"\"\"Representing INTERACTION_CLASSIFIER_MAPPING dict values.\"\"\"\n\n    algorithm_id: str\n    algorithm_version: int\n\n\nINTERACTION_CLASSIFIER_MAPPING: Dict[str, ClassifierDict] = {\n    'TextInput': {\n        'algorithm_id': 'TextClassifier',\n        'algorithm_version': 1\n    },\n}\n\n# Classifier job time to live (in mins).\nCLASSIFIER_JOB_TTL_MINS = 5\nTRAINING_JOB_STATUS_COMPLETE = 'COMPLETE'\nTRAINING_JOB_STATUS_FAILED = 'FAILED'\nTRAINING_JOB_STATUS_NEW = 'NEW'\nTRAINING_JOB_STATUS_PENDING = 'PENDING'\n\nALLOWED_TRAINING_JOB_STATUSES: List[str] = [\n    TRAINING_JOB_STATUS_COMPLETE,\n    TRAINING_JOB_STATUS_FAILED,\n    TRAINING_JOB_STATUS_NEW,\n    TRAINING_JOB_STATUS_PENDING\n]\n\n# Allowed formats of how HTML is present in rule specs.\nHTML_RULE_VARIABLE_FORMAT_SET = 'set'\nHTML_RULE_VARIABLE_FORMAT_STRING = 'string'\nHTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS = 'listOfSets'\n\nALLOWED_HTML_RULE_VARIABLE_FORMATS = [\n    HTML_RULE_VARIABLE_FORMAT_SET,\n    HTML_RULE_VARIABLE_FORMAT_STRING,\n    HTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS\n]\n\nANSWER_TYPE_LIST_OF_SETS_OF_HTML = 'ListOfSetsOfHtmlStrings'\nANSWER_TYPE_SET_OF_HTML = 'SetOfHtmlString'\n\n# The maximum number of characters allowed for userbio length.\nMAX_BIO_LENGTH_IN_CHARS = 2000\n\nALLOWED_TRAINING_JOB_STATUS_CHANGES: Dict[str, List[str]] = {\n    TRAINING_JOB_STATUS_COMPLETE: [],\n    TRAINING_JOB_STATUS_NEW: [TRAINING_JOB_STATUS_PENDING],\n    TRAINING_JOB_STATUS_PENDING: [TRAINING_JOB_STATUS_COMPLETE,\n                                  TRAINING_JOB_STATUS_FAILED],\n    TRAINING_JOB_STATUS_FAILED: [TRAINING_JOB_STATUS_NEW]\n}\n\n# Allowed formats of how HTML is present in rule specs.\nHTML_RULE_VARIABLE_FORMAT_SET = 'set'\nHTML_RULE_VARIABLE_FORMAT_STRING = 'string'\nHTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS = 'listOfSets'\n\nALLOWED_HTML_RULE_VARIABLE_FORMATS = [\n    HTML_RULE_VARIABLE_FORMAT_SET,\n    HTML_RULE_VARIABLE_FORMAT_STRING,\n    HTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS\n]\n\nANSWER_TYPE_LIST_OF_SETS_OF_HTML = 'ListOfSetsOfHtmlStrings'\nANSWER_TYPE_SET_OF_HTML = 'SetOfHtmlString'\n\nENTITY_TYPE_BLOG_POST = 'blog_post'\nENTITY_TYPE_EXPLORATION = 'exploration'\nENTITY_TYPE_TOPIC = 'topic'\nENTITY_TYPE_SKILL = 'skill'\nENTITY_TYPE_STORY = 'story'\nENTITY_TYPE_QUESTION = 'question'\n\nDIAGNOSTIC_TEST_QUESTION_TYPE_MAIN = 'main_question'\nDIAGNOSTIC_TEST_QUESTION_TYPE_BACKUP = 'backup_question'\n\nIMAGE_CONTEXT_QUESTION_SUGGESTIONS = 'question_suggestions'\nIMAGE_CONTEXT_EXPLORATION_SUGGESTIONS = 'exploration_suggestions'\n\nMAX_TASK_MODELS_PER_FETCH = 25\nMAX_TASK_MODELS_PER_HISTORY_PAGE = 10\n\nPERIOD_TO_HARD_DELETE_MODELS_MARKED_AS_DELETED = datetime.timedelta(weeks=8)\n\n# The maximum number of activities allowed in the playlist of the learner. This\n# limit applies to both the explorations playlist and the collections playlist.\nMAX_LEARNER_PLAYLIST_ACTIVITY_COUNT = 10\n\n# The maximum number of goals allowed in the learner goals of the learner.\nMAX_CURRENT_GOALS_COUNT = 5\n\n# The minimum number of training samples required for training a classifier.\nMIN_TOTAL_TRAINING_EXAMPLES = 50\n\n# The minimum number of assigned labels required for training a classifier.\nMIN_ASSIGNED_LABELS = 2\n\n# Default label for classification algorithms.\nDEFAULT_CLASSIFIER_LABEL = '_default'\n\n# The maximum number of results to retrieve in a datastore query.\nDEFAULT_QUERY_LIMIT = 1000\n\n# The maximum number of results to retrieve in a datastore query\n# for suggestions.\nDEFAULT_SUGGESTION_QUERY_LIMIT = 1000\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library/top_rated page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FULL_PAGE = 20\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library/recently_published page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FULL_PAGE = 20\n\n# The maximum number of days a feedback report can be saved in storage before it\n# must be scrubbed.\nAPP_FEEDBACK_REPORT_MAXIMUM_LIFESPAN = datetime.timedelta(days=90)\n\n# The minimum version of the Android feedback report info blob schema.\nMINIMUM_ANDROID_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the Android feedback report info blob schema.\nCURRENT_ANDROID_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the web feedback report info blob schema.\nMINIMUM_WEB_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the web feedback report info blob schema.\nCURRENT_WEB_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the app feedback report daily stats blob schema.\nCURRENT_FEEDBACK_REPORT_STATS_SCHEMA_VERSION = 1\n\n# The minimum version of the app feedback report daily stats blob schema.\nMINIMUM_FEEDBACK_REPORT_STATS_SCHEMA_VERSION = 1\n\n# The current version of the dashboard stats blob schema. If any backward-\n# incompatible changes are made to the stats blob schema in the data store,\n# this version number must be changed.\nCURRENT_DASHBOARD_STATS_SCHEMA_VERSION = 1\n\n# The earliest supported version of the exploration states blob schema.\nEARLIEST_SUPPORTED_STATE_SCHEMA_VERSION = 41\n\n# The current version of the exploration states blob schema. If any backward-\n# incompatible changes are made to the states blob schema in the data store,\n# this version number must be changed and the exploration migration job\n# executed.\nCURRENT_STATE_SCHEMA_VERSION = 54\n\n# The current version of the all collection blob schemas (such as the nodes\n# structure within the Collection domain object). If any backward-incompatible\n# changes are made to any of the blob schemas in the data store, this version\n# number must be changed.\nCURRENT_COLLECTION_SCHEMA_VERSION = 6\n\n# The current version of story contents dict in the story schema.\nCURRENT_STORY_CONTENTS_SCHEMA_VERSION = 5\n\n# The current version of skill contents dict in the skill schema.\nCURRENT_SKILL_CONTENTS_SCHEMA_VERSION = 4\n\n# The current version of misconceptions dict in the skill schema.\nCURRENT_MISCONCEPTIONS_SCHEMA_VERSION = 5\n\n# The current version of rubric dict in the skill schema.\nCURRENT_RUBRIC_SCHEMA_VERSION = 5\n\n# The current version of subtopics dict in the topic schema.\nCURRENT_SUBTOPIC_SCHEMA_VERSION = 4\n\n# The current version of story reference dict in the topic schema.\nCURRENT_STORY_REFERENCE_SCHEMA_VERSION = 1\n\n# The current version of page_contents dict in the subtopic page schema.\nCURRENT_SUBTOPIC_PAGE_CONTENTS_SCHEMA_VERSION = 4\n\n# This value should be updated in the event of any\n# StateAnswersModel.submitted_answer_list schema change.\nCURRENT_STATE_ANSWERS_SCHEMA_VERSION = 1\n\n# This value should be updated if the schema of LearnerAnswerInfo\n# dict schema changes.\nCURRENT_LEARNER_ANSWER_INFO_SCHEMA_VERSION = 1\n\n# This value should be updated if the schema of PlatformParameterRule dict\n# schema changes.\nCURRENT_PLATFORM_PARAMETER_RULE_SCHEMA_VERSION = 1\n\n# The default number of exploration tiles to load at a time in the search\n# results page.\nSEARCH_RESULTS_PAGE_SIZE = 20\n\n# The default number of commits to show on a page in the exploration history\n# tab.\nCOMMIT_LIST_PAGE_SIZE = 50\n\n# The default number of items to show on a page in the exploration feedback\n# tab.\nFEEDBACK_TAB_PAGE_SIZE = 20\n\n# The maximum number of top unresolved answers which should be aggregated\n# from all of the submitted answers.\nTOP_UNRESOLVED_ANSWERS_LIMIT = 20\n\n# Default title for a newly-minted exploration.\nDEFAULT_EXPLORATION_TITLE = ''\n# Default category for a newly-minted exploration.\nDEFAULT_EXPLORATION_CATEGORY = ''\n# Default objective for a newly-minted exploration.\nDEFAULT_EXPLORATION_OBJECTIVE = ''\n\n# NOTE TO DEVELOPERS: If any of the 5 constants below are modified, the\n# corresponding field in NEW_STATE_TEMPLATE in constants.js also has to be\n# modified.\n\n# Default name for the initial state of an exploration.\nDEFAULT_INIT_STATE_NAME = 'Introduction'\n# Default content id for the state's content.\nDEFAULT_NEW_STATE_CONTENT_ID = 'content'\n# Default content id for the interaction's default outcome.\nDEFAULT_OUTCOME_CONTENT_ID = 'default_outcome'\n# Default content id for the explanation in the concept card of a skill.\nDEFAULT_EXPLANATION_CONTENT_ID = 'explanation'\n# Content id assigned to rule inputs that do not match any interaction\n# customization argument choices.\nINVALID_CONTENT_ID = 'invalid_content_id'\n# Default recorded_voiceovers dict for a default state template.\nDEFAULT_RECORDED_VOICEOVERS: state_domain.RecordedVoiceoversDict = {\n    'voiceovers_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# Default written_translations dict for a default state template.\nDEFAULT_WRITTEN_TRANSLATIONS: state_domain.WrittenTranslationsDict = {\n    'translations_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# The default content text for the initial state of an exploration.\nDEFAULT_INIT_STATE_CONTENT_STR = ''\n\n# Whether new explorations should have automatic text-to-speech enabled\n# by default.\nDEFAULT_AUTO_TTS_ENABLED = False\n# Whether new explorations should have correctness-feedback enabled\n# by default.\nDEFAULT_CORRECTNESS_FEEDBACK_ENABLED = True\n\n# Default title for a newly-minted collection.\nDEFAULT_COLLECTION_TITLE = ''\n# Default category for a newly-minted collection.\nDEFAULT_COLLECTION_CATEGORY = ''\n# Default objective for a newly-minted collection.\nDEFAULT_COLLECTION_OBJECTIVE = ''\n\n# Default description for a newly-minted story.\nDEFAULT_STORY_DESCRIPTION = ''\n# Default notes for a newly-minted story.\nDEFAULT_STORY_NOTES = ''\n\n# Default explanation for a newly-minted skill.\nDEFAULT_SKILL_EXPLANATION = ''\n# Default name for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NAME = ''\n# Default notes for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NOTES = ''\n# Default feedback for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_FEEDBACK = ''\n# Default content_id for explanation subtitled html.\nDEFAULT_SKILL_EXPLANATION_CONTENT_ID = 'explanation'\n\n# Default description for a newly-minted topic.\nDEFAULT_TOPIC_DESCRIPTION = ''\n# Default abbreviated name for a newly-minted topic.\nDEFAULT_ABBREVIATED_TOPIC_NAME = ''\n# Default content id for the subtopic page's content.\nDEFAULT_SUBTOPIC_PAGE_CONTENT_ID = 'content'\n\n# Default ID of VM which is used for training classifier.\nDEFAULT_VM_ID = 'vm_default'\n# Shared secret key for default VM.\nDEFAULT_VM_SHARED_SECRET = '1a2b3c4e'\n\nIMAGE_FORMAT_JPEG = 'jpeg'\nIMAGE_FORMAT_PNG = 'png'\nIMAGE_FORMAT_GIF = 'gif'\nIMAGE_FORMAT_SVG = 'svg'\n\n# An array containing the accepted image formats (as determined by the imghdr\n# module) and the corresponding allowed extensions in the filenames of uploaded\n# images.\nACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS = {\n    IMAGE_FORMAT_JPEG: ['jpg', 'jpeg'],\n    IMAGE_FORMAT_PNG: ['png'],\n    IMAGE_FORMAT_GIF: ['gif'],\n    IMAGE_FORMAT_SVG: ['svg']\n}\n\n# An array containing the image formats that can be compressed.\nCOMPRESSIBLE_IMAGE_FORMATS = [IMAGE_FORMAT_JPEG, IMAGE_FORMAT_PNG]\n\n# An array containing the accepted audio extensions for uploaded files and\n# the corresponding MIME types.\nACCEPTED_AUDIO_EXTENSIONS = {\n    'mp3': ['audio/mp3']\n}\n\n# Prefix for data sent from the server to the client via JSON.\nXSSI_PREFIX = b')]}\\'\\n'\n# A regular expression for alphanumeric characters.\nALPHANUMERIC_REGEX = r'^[A-Za-z0-9]+$'\n\n# These are here rather than in rating_services.py to avoid import\n# circularities with exp_services.\n# TODO(Jacob): Refactor exp_services to remove this problem.\n_EMPTY_RATINGS = {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}\n\n\ndef get_empty_ratings() -> Dict[str, int]:\n    \"\"\"Returns a copy of the empty ratings object.\n\n    Returns:\n        dict. Copy of the '_EMPTY_RATINGS' dict object which contains the empty\n        ratings.\n    \"\"\"\n    return copy.deepcopy(_EMPTY_RATINGS)\n\n\n# To use mailchimp email service.\nBULK_EMAIL_SERVICE_PROVIDER_MAILCHIMP = 'mailchimp_email_service'\n# Use GAE email service by default.\nBULK_EMAIL_SERVICE_PROVIDER = BULK_EMAIL_SERVICE_PROVIDER_MAILCHIMP\n\n# Empty scaled average rating as a float.\nEMPTY_SCALED_AVERAGE_RATING = 0.0\n\n# To use mailgun email service.\nEMAIL_SERVICE_PROVIDER_MAILGUN = 'mailgun_email_service'\n# Use GAE email service by default.\nEMAIL_SERVICE_PROVIDER = EMAIL_SERVICE_PROVIDER_MAILGUN\n# If the Mailgun email API is used, the \"None\" below should be replaced\n# with the Mailgun domain name (ending with mailgun.org).\nMAILGUN_DOMAIN_NAME = None\n\n# Audience ID of the mailing list for Oppia in Mailchimp.\nMAILCHIMP_AUDIENCE_ID = None\n# Mailchimp username.\nMAILCHIMP_USERNAME = None\n# Valid Mailchimp merge keys.\nVALID_MAILCHIMP_FIELD_KEYS = ['NAME']\n# Valid Mailchimp tags.\nVALID_MAILCHIMP_TAGS = ['Account', 'Android', 'Web']\n\nES_LOCALHOST_PORT = 9200\n# NOTE TO RELEASE COORDINATORS: Replace this with the correct ElasticSearch\n# auth information during deployment.\nES_CLOUD_ID = None\nES_USERNAME = None\n\n# NOTE TO RELEASE COORDINATORS: Replace this with the correct Redis Host and\n# Port when switching to prod server. Keep this in sync with redis.conf in the\n# root folder. Specifically, REDISPORT should always be the same as the port in\n# redis.conf.\nREDISHOST = 'localhost'\nREDISPORT = 6379\n\n# The DB numbers for various Redis instances that Oppia uses. Do not reuse these\n# if you're creating a new Redis client.\nOPPIA_REDIS_DB_INDEX = 0\nCLOUD_NDB_REDIS_DB_INDEX = 1\nSTORAGE_EMULATOR_REDIS_DB_INDEX = 2\n\n\n# NOTE TO RELEASE COORDINATORS: Replace this project id with the correct oppia\n# project id when switching to the prod server.\nOPPIA_PROJECT_ID = 'dev-project-id'\nGOOGLE_APP_ENGINE_REGION = 'us-central1'\n\n# NOTE TO RELEASE COORDINATORS: Replace these GCS bucket paths with real prod\n# buckets. It's OK for them to be the same.\nDATAFLOW_TEMP_LOCATION = 'gs://todo/todo'\nDATAFLOW_STAGING_LOCATION = 'gs://todo/todo'\n\nOPPIA_VERSION = '3.2.9'\nOPPIA_PYTHON_PACKAGE_PATH = './build/oppia-beam-job-%s.tar.gz' % OPPIA_VERSION\n\n# Committer id for system actions. The username for the system committer\n# (i.e. admin) is also 'admin'.\nSYSTEM_COMMITTER_ID = 'admin'\n# Domain name for email address.\nINCOMING_EMAILS_DOMAIN_NAME = 'example.com'\nSYSTEM_EMAIL_ADDRESS = 'system@example.com'\nSYSTEM_EMAIL_NAME = '.'\nADMIN_EMAIL_ADDRESS = 'testadmin@example.com'\nNOREPLY_EMAIL_ADDRESS = 'noreply@example.com'\n# Ensure that SYSTEM_EMAIL_ADDRESS and ADMIN_EMAIL_ADDRESS are both valid and\n# correspond to owners of the app before setting this to True. If\n# SYSTEM_EMAIL_ADDRESS is not that of an app owner, email messages from this\n# address cannot be sent. If True then emails can be sent to any user.\nCAN_SEND_EMAILS = False\n# If you want to turn on this facility please check the email templates in the\n# send_role_notification_email() function in email_manager.py and modify them\n# accordingly.\nCAN_SEND_EDITOR_ROLE_EMAILS = False\n# If enabled then emails will be sent to creators for feedback messages.\nCAN_SEND_FEEDBACK_MESSAGE_EMAILS = False\n# If enabled subscription emails will be sent to that user.\nCAN_SEND_SUBSCRIPTION_EMAILS = False\n# Time to wait before sending feedback message emails (currently set to 1\n# hour).\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_COUNTDOWN_SECS = 3600\n# Whether to send an email when new feedback message is received for\n# an exploration.\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_PREFERENCE = True\n# Whether to send an email to all the creator's subscribers when he/she\n# publishes an exploration.\nDEFAULT_SUBSCRIPTION_EMAIL_PREFERENCE = True\n# Whether exploration feedback emails are muted,\n# when the user has not specified a preference.\nDEFAULT_FEEDBACK_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether exploration suggestion emails are muted,\n# when the user has not specified a preference.\nDEFAULT_SUGGESTION_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether to send email updates to a user who has not specified a preference.\nDEFAULT_EMAIL_UPDATES_PREFERENCE = False\n# Whether to send an invitation email when the user is granted\n# new role permissions in an exploration.\nDEFAULT_EDITOR_ROLE_EMAIL_PREFERENCE = True\n# Whether to require an email to be sent, following a moderator action.\nREQUIRE_EMAIL_ON_MODERATOR_ACTION = False\n# Timespan in minutes before allowing duplicate emails.\nDUPLICATE_EMAIL_INTERVAL_MINS = 2\n# Number of digits after decimal to which the average ratings value in the\n# dashboard is rounded off to.\nAVERAGE_RATINGS_DASHBOARD_PRECISION = 2\n# Whether to enable maintenance mode on the site. For non-admins, this redirects\n# all HTTP requests to the maintenance page. This is the only check which\n# determines whether the site is in maintenance mode to avoid queries to the\n# database by non-admins.\nENABLE_MAINTENANCE_MODE = False\n\n# The interactions permissible for a question.\nALLOWED_QUESTION_INTERACTION_IDS = [\n    'TextInput', 'MultipleChoiceInput', 'NumericInput']\n\n# Flag to disable sending emails related to reviews for suggestions. To be\n# flipped after deciding (and implementing) whether a user should be scored\n# only for curated lessons.\nSEND_SUGGESTION_REVIEW_RELATED_EMAILS = False\n# To prevent recording scores for users until details like whether to score\n# users for only curated lessons is confirmed.\nENABLE_RECORDING_OF_SCORES = False\n\n# No. of pretest questions to display.\nNUM_PRETEST_QUESTIONS = 0\n\nEMAIL_INTENT_SIGNUP = 'signup'\nEMAIL_INTENT_DAILY_BATCH = 'daily_batch'\nEMAIL_INTENT_EDITOR_ROLE_NOTIFICATION = 'editor_role_notification'\nEMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION = 'feedback_message_notification'\nEMAIL_INTENT_SUBSCRIPTION_NOTIFICATION = 'subscription_notification'\nEMAIL_INTENT_SUGGESTION_NOTIFICATION = 'suggestion_notification'\nEMAIL_INTENT_REPORT_BAD_CONTENT = 'report_bad_content'\nEMAIL_INTENT_MARKETING = 'marketing'\nEMAIL_INTENT_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nEMAIL_INTENT_DELETE_EXPLORATION = 'delete_exploration'\nEMAIL_INTENT_QUERY_STATUS_NOTIFICATION = 'query_status_notification'\nEMAIL_INTENT_ONBOARD_REVIEWER = 'onboard_reviewer'\nEMAIL_INTENT_REMOVE_REVIEWER = 'remove_reviewer'\nEMAIL_INTENT_ADDRESS_CONTRIBUTOR_DASHBOARD_SUGGESTIONS = (\n    'address_contributor_dashboard_suggestions'\n)\nEMAIL_INTENT_REVIEW_CREATOR_DASHBOARD_SUGGESTIONS = (\n    'review_creator_dashboard_suggestions')\nEMAIL_INTENT_REVIEW_CONTRIBUTOR_DASHBOARD_SUGGESTIONS = (\n    'review_contributor_dashboard_suggestions'\n)\nEMAIL_INTENT_ADD_CONTRIBUTOR_DASHBOARD_REVIEWERS = (\n    'add_contributor_dashboard_reviewers'\n)\nEMAIL_INTENT_ACCOUNT_DELETED = 'account_deleted'\nEMAIL_INTENT_NOTIFY_CONTRIBUTOR_DASHBOARD_ACHIEVEMENTS = (\n    'notify_contributor_dashboard_achievements'\n)\n# Possible intents for email sent in bulk.\nBULK_EMAIL_INTENT_MARKETING = 'bulk_email_marketing'\nBULK_EMAIL_INTENT_IMPROVE_EXPLORATION = 'bulk_email_improve_exploration'\nBULK_EMAIL_INTENT_CREATE_EXPLORATION = 'bulk_email_create_exploration'\nBULK_EMAIL_INTENT_CREATOR_REENGAGEMENT = 'bulk_email_creator_reengagement'\nBULK_EMAIL_INTENT_LEARNER_REENGAGEMENT = 'bulk_email_learner_reengagement'\nBULK_EMAIL_INTENT_ML_JOB_FAILURE = 'bulk_email_ml_job_failure'\nBULK_EMAIL_INTENT_TEST = 'bulk_email_test'\n\nMESSAGE_TYPE_FEEDBACK = 'feedback'\nMESSAGE_TYPE_SUGGESTION = 'suggestion'\n\nMODERATOR_ACTION_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nDEFAULT_SALUTATION_HTML_FN: Callable[[str], str] = (\n    lambda recipient_username: 'Hi %s,' % recipient_username)\nDEFAULT_SIGNOFF_HTML_FN: Callable[[str], str] = (\n    lambda sender_username: (\n        'Thanks!<br>%s (Oppia moderator)' % sender_username))\nDEFAULT_EMAIL_SUBJECT_FN: Callable[[str], str] = (\n    lambda exp_title: (\n        'Your Oppia exploration \"%s\" has been unpublished' % exp_title))\n\nVALID_MODERATOR_ACTIONS: Dict[\n    str,\n    Dict[str, Union[str, Callable[[str], str]]]\n] = {\n    MODERATOR_ACTION_UNPUBLISH_EXPLORATION: {\n        'email_config': 'unpublish_exploration_email_html_body',\n        'email_subject_fn': DEFAULT_EMAIL_SUBJECT_FN,\n        'email_intent': 'unpublish_exploration',\n        'email_salutation_html_fn': DEFAULT_SALUTATION_HTML_FN,\n        'email_signoff_html_fn': DEFAULT_SIGNOFF_HTML_FN,\n    },\n}\n\n# When the site terms were last updated, in UTC.\nTERMS_PAGE_LAST_UPDATED_UTC = datetime.datetime(2020, 10, 19)\n\n# Format of string for dashboard statistics logs.\n# NOTE TO DEVELOPERS: This format should not be changed, since it is used in\n# the existing storage models for UserStatsModel.\nDASHBOARD_STATS_DATETIME_STRING_FORMAT = '%Y-%m-%d'\n\n# Timestamp in sec since epoch for Mar 1 2021 12:00:00 UTC for the earliest\n# datetime that a report could be received.\nEARLIEST_APP_FEEDBACK_REPORT_DATETIME = datetime.datetime.fromtimestamp(\n    1614556800)\n\n# The minimum and maximum package version codes for Oppia Android.\nMINIMUM_ANDROID_PACKAGE_VERSION_CODE = 1\n\n# We generate images for existing math rich text components in batches. This\n# gives the maximum size for a batch of Math SVGs in bytes.\nMAX_SIZE_OF_MATH_SVGS_BATCH_BYTES = 31 * 1024 * 1024\n\n# The maximum size of an uploaded file, in bytes.\nMAX_FILE_SIZE_BYTES = 1048576\n\n# The maximum playback length of an audio file, in seconds.\nMAX_AUDIO_FILE_LENGTH_SEC = 300\n\n# The maximum number of questions to be fetched at one time.\nMAX_QUESTIONS_FETCHABLE_AT_ONE_TIME = 20\n\n# The minimum score required for a user to review suggestions of a particular\n# category.\nMINIMUM_SCORE_REQUIRED_TO_REVIEW = 10\n\n# The maximum number of skills to be requested at one time when fetching\n# questions.\nMAX_NUMBER_OF_SKILL_IDS = 20\n\n# The maximum number of blog post cards to be visible on each page in blog\n# homepage.\nMAX_NUM_CARDS_TO_DISPLAY_ON_BLOG_HOMEPAGE = 10\n\n# The maximum number of blog post cards to be visible on each page in blog\n# search results homepage.\nMAX_NUM_CARDS_TO_DISPLAY_ON_BLOG_SEARCH_RESULTS_PAGE = 10\n\n# The maximum number of blog post cards to be visible on each page in author\n# specific blog post page.\nMAX_NUM_CARDS_TO_DISPLAY_ON_BLOG_AUTHOR_PROFILE_PAGE = 12\n\n# The maximum number of blog post cards to be visible as suggestions on the\n# blog post page.\nMAX_POSTS_TO_RECOMMEND_AT_END_OF_BLOG_POST = 2\n\n# The prefix for an 'accepted suggestion' commit message.\nCOMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX = 'Accepted suggestion by'\n\n# User id and username for exploration migration bot. Commits made by this bot\n# are not reflected in the exploration summary models, but are recorded in the\n# exploration commit log.\nMIGRATION_BOT_USER_ID = 'OppiaMigrationBot'\nMIGRATION_BOT_USERNAME = 'OppiaMigrationBot'\n\n# User id for scrubber bot. This bot is used to represent the cron job that\n# scrubs expired app feedback reports.\nAPP_FEEDBACK_REPORT_SCRUBBER_BOT_ID = 'AppFeedbackReportScrubberBot'\nAPP_FEEDBACK_REPORT_SCRUBBER_BOT_USERNAME = 'AppFeedbackReportScrubberBot'\n\n# User id and username for suggestion bot. This bot will be used to accept\n# suggestions automatically after a threshold time.\nSUGGESTION_BOT_USER_ID = 'OppiaSuggestionBot'\nSUGGESTION_BOT_USERNAME = 'OppiaSuggestionBot'\n\n# The system usernames are reserved usernames. Before adding new value to this\n# dict, make sure that there aren't any similar usernames in the datastore.\n# Note: All bot user IDs and usernames should start with \"Oppia\" and end with\n# \"Bot\".\nSYSTEM_USERS = {\n    SYSTEM_COMMITTER_ID: SYSTEM_COMMITTER_ID,\n    MIGRATION_BOT_USER_ID: MIGRATION_BOT_USERNAME,\n    SUGGESTION_BOT_USER_ID: SUGGESTION_BOT_USERNAME,\n    APP_FEEDBACK_REPORT_SCRUBBER_BOT_ID: (\n        APP_FEEDBACK_REPORT_SCRUBBER_BOT_USERNAME)\n}\n\n# Ids and locations of the permitted extensions.\nALLOWED_RTE_EXTENSIONS = {\n    'Collapsible': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Collapsible')\n    },\n    'Image': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Image')\n    },\n    'Link': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Link')\n    },\n    'Math': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Math')\n    },\n    'Tabs': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Tabs')\n    },\n    'Video': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Video')\n    },\n}\n\n# The list of interaction IDs which correspond to interactions that set their\n# is_linear property to true. Linear interactions do not support branching and\n# thus only allow for default answer classification. This value is guarded by a\n# test in extensions.interactions.base_test.\nLINEAR_INTERACTION_IDS = ['Continue']\n\n# Demo explorations to load through the admin panel. The id assigned to each\n# exploration is based on the key of the exploration in this dict, so ensure it\n# doesn't change once it's in the list. Only integer-based indices should be\n# used in this list, as it maintains backward compatibility with how demo\n# explorations used to be assigned IDs. The value of each entry in this dict is\n# either a YAML file or a directory (depending on whether it ends in .yaml).\n# These explorations can be found under data/explorations.\nDEMO_EXPLORATIONS = {\n    u'0': 'welcome',\n    u'1': 'multiples.yaml',\n    # Exploration with ID 2 was removed as it contained string values inside\n    # NumericInput interaction.\n    u'3': 'root_linear_coefficient_theorem',\n    u'4': 'three_balls',\n    # TODO(bhenning): Replace demo exploration '5' with a new exploration\n    # described in #1376.\n    u'6': 'boot_verbs.yaml',\n    u'7': 'hola.yaml',\n    # Exploration with ID 8 was removed as it contained string values inside\n    # NumericInput interaction.\n    u'9': 'pitch_perfect.yaml',\n    u'10': 'test_interactions',\n    u'11': 'modeling_graphs',\n    u'12': 'protractor_test_1.yaml',\n    u'13': 'solar_system',\n    u'14': 'about_oppia.yaml',\n    u'15': 'classifier_demo_exploration.yaml',\n    u'16': 'all_interactions',\n    u'17': 'audio_test',\n    # Exploration with ID 18 was used for testing CodeClassifier functionality\n    # which has been removed (#10060).\n    u'19': 'example_exploration_in_collection1.yaml',\n    u'20': 'example_exploration_in_collection2.yaml',\n    u'21': 'example_exploration_in_collection3.yaml',\n    u'22': 'protractor_mobile_test_exploration.yaml',\n    u'23': 'rating_test.yaml',\n    u'24': 'learner_flow_test.yaml',\n    u'25': 'exploration_player_test.yaml',\n    u'26': 'android_interactions',\n}\n\nDEMO_COLLECTIONS = {\n    u'0': 'welcome_to_collections.yaml',\n    u'1': 'learner_flow_test_collection.yaml'\n}\n\n# IDs of explorations which should not be displayable in either the learner or\n# editor views.\nDISABLED_EXPLORATION_IDS = ['5']\n\n# Oppia Google Group URL.\nGOOGLE_GROUP_URL = (\n    'https://groups.google.com/forum/?place=forum/oppia#!forum/oppia')\n\n# NOTE TO RELEASE COORDINATORS: External URL for the oppia production site.\n# Change to the correct url for internal testing in the testing production\n# environment.\n# Change to the production URL when deploying to production site.\nOPPIA_SITE_URL = 'http://localhost:8181'\n\n# Prefix for all taskqueue-related URLs.\nTASKQUEUE_URL_PREFIX = '/task'\nTASK_URL_FEEDBACK_MESSAGE_EMAILS = (\n    '%s/email/batchfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FEEDBACK_STATUS_EMAILS = (\n    '%s/email/feedbackthreadstatuschangeemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FLAG_EXPLORATION_EMAILS = (\n    '%s/email/flagexplorationemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_INSTANT_FEEDBACK_EMAILS = (\n    '%s/email/instantfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS = (\n    '%s/email/contributordashboardachievementnotificationemailhandler' % (\n        TASKQUEUE_URL_PREFIX))\nTASK_URL_DEFERRED = (\n    '%s/deferredtaskshandler' % TASKQUEUE_URL_PREFIX)\n\n# TODO(sll): Add all other URLs here.\nABOUT_FOUNDATION_PAGE_URL = '/about-foundation'\nADMIN_URL = '/admin'\nADMIN_ROLE_HANDLER_URL = '/adminrolehandler'\nBLOG_ADMIN_PAGE_URL = '/blog-admin'\nCLASSROOM_ADMIN_PAGE_URL = '/classroom-admin'\nBLOG_ADMIN_ROLE_HANDLER_URL = '/blogadminrolehandler'\nBLOG_DASHBOARD_DATA_URL = '/blogdashboardhandler/data'\nBLOG_DASHBOARD_URL = '/blog-dashboard'\nDIAGNOSTIC_TEST_PLAYER_PAGE_URL = '/diagnostic-test-player'\nBLOG_EDITOR_DATA_URL_PREFIX = '/blogeditorhandler/data'\nBULK_EMAIL_WEBHOOK_ENDPOINT = '/bulk_email_webhook_endpoint'\nBLOG_HOMEPAGE_DATA_URL = '/blogdatahandler/data'\nBLOG_HOMEPAGE_URL = '/blog'\nBLOG_SEARCH_DATA_URL = '/blog/searchhandler/data'\nBLOG_AUTHOR_PROFILE_PAGE_URL_PREFIX = '/blog/author'\nBLOG_AUTHOR_PROFILE_PAGE_DATA_URL_PREFIX = '/blog/author/data'\nCLASSROOM_DATA_HANDLER = '/classroom_data_handler'\nCOLLECTION_DATA_URL_PREFIX = '/collection_handler/data'\nCOLLECTION_EDITOR_DATA_URL_PREFIX = '/collection_editor_handler/data'\nCOLLECTION_SUMMARIES_DATA_URL = '/collectionsummarieshandler/data'\nCOLLECTION_RIGHTS_PREFIX = '/collection_editor_handler/rights'\nCOLLECTION_PUBLISH_PREFIX = '/collection_editor_handler/publish'\nCOLLECTION_UNPUBLISH_PREFIX = '/collection_editor_handler/unpublish'\nCOLLECTION_EDITOR_URL_PREFIX = '/collection_editor/create'\nCOLLECTION_URL_PREFIX = '/collection'\nCONCEPT_CARD_DATA_URL_PREFIX = '/concept_card_handler'\nCONTRIBUTOR_DASHBOARD_URL = '/contributor-dashboard'\nCONTRIBUTOR_STATS_SUMMARIES_URL = '/contributorstatssummaries'\nCONTRIBUTOR_ALL_STATS_SUMMARIES_URL = '/contributorallstatssummaries'\nCONTRIBUTOR_CERTIFICATE_URL = '/contributorcertificate'\nCONTRIBUTOR_DASHBOARD_ADMIN_URL = '/contributor-dashboard-admin'\nCONTRIBUTOR_OPPORTUNITIES_DATA_URL = '/opportunitiessummaryhandler'\nCREATOR_DASHBOARD_DATA_URL = '/creatordashboardhandler/data'\nCREATOR_DASHBOARD_URL = '/creator-dashboard'\nCSRF_HANDLER_URL = '/csrfhandler'\nCUSTOM_NONPROFITS_LANDING_PAGE_URL = '/nonprofits'\nCUSTOM_PARENTS_LANDING_PAGE_URL = '/parents'\nCUSTOM_PARTNERS_LANDING_PAGE_URL = '/partners'\nCUSTOM_TEACHERS_LANDING_PAGE_URL = '/teachers'\nCUSTOM_VOLUNTEERS_LANDING_PAGE_URL = '/volunteers'\nDASHBOARD_CREATE_MODE_URL = '%s?mode=create' % CREATOR_DASHBOARD_URL\nEDITOR_URL_PREFIX = '/create'\nEXPLORATION_DATA_PREFIX = '/createhandler/data'\nEXPLORATION_IMAGE_UPLOAD_PREFIX = '/createhandler/imageupload'\nEXPLORATION_FEATURES_PREFIX = '/explorehandler/features'\nEXPLORATION_INIT_URL_PREFIX = '/explorehandler/init'\nEXPLORATION_LEARNER_ANSWER_DETAILS = (\n    '/learneranswerinfohandler/learner_answer_details')\nEXPLORATION_METADATA_SEARCH_URL = '/exploration/metadata_search'\nEXPLORATION_PRETESTS_URL_PREFIX = '/pretest_handler'\nEXPLORATION_RIGHTS_PREFIX = '/createhandler/rights'\nEXPLORATION_STATE_ANSWER_STATS_PREFIX = '/createhandler/state_answer_stats'\nEXPLORATION_STATUS_PREFIX = '/createhandler/status'\nEXPLORATION_SUMMARIES_DATA_URL = '/explorationsummarieshandler/data'\nEXPLORATION_URL_PREFIX = '/explore'\nEXPLORATION_URL_EMBED_PREFIX = '/embed/exploration'\nFEEDBACK_STATS_URL_PREFIX = '/feedbackstatshandler'\nFEEDBACK_THREAD_URL_PREFIX = '/threadhandler'\nFEEDBACK_THREADLIST_URL_PREFIX = '/threadlisthandler'\nFEEDBACK_THREADLIST_URL_PREFIX_FOR_TOPICS = '/threadlisthandlerfortopic'\nFEEDBACK_THREAD_VIEW_EVENT_URL = '/feedbackhandler/thread_view_event'\nFETCH_SKILLS_URL_PREFIX = '/fetch_skills'\nFLAG_EXPLORATION_URL_PREFIX = '/flagexplorationhandler'\nFRACTIONS_LANDING_PAGE_URL = '/fractions'\nIMPROVEMENTS_URL_PREFIX = '/improvements'\nIMPROVEMENTS_HISTORY_URL_PREFIX = '/improvements/history'\nIMPROVEMENTS_CONFIG_URL_PREFIX = '/improvements/config'\nLEARNER_ANSWER_INFO_HANDLER_URL = (\n    '/learneranswerinfohandler/learner_answer_details')\nLEARNER_ANSWER_DETAILS_SUBMIT_URL = '/learneranswerdetailshandler'\nLEARNER_DASHBOARD_URL = '/learner-dashboard'\nLEARNER_DASHBOARD_TOPIC_AND_STORY_DATA_URL = (\n    '/learnerdashboardtopicsandstoriesprogresshandler/data')\nLEARNER_COMPLETED_CHAPTERS_COUNT_DATA_URL = (\n    '/learnercompletedchapterscounthandler/data')\nLEARNER_DASHBOARD_COLLECTION_DATA_URL = (\n    '/learnerdashboardcollectionsprogresshandler/data')\nLEARNER_DASHBOARD_EXPLORATION_DATA_URL = (\n    '/learnerdashboardexplorationsprogresshandler/data')\nLEARNER_DASHBOARD_FEEDBACK_UPDATES_DATA_URL = (\n    '/learnerdashboardfeedbackupdateshandler/data')\nLEARNER_DASHBOARD_IDS_DATA_URL = '/learnerdashboardidshandler/data'\nLEARNER_DASHBOARD_FEEDBACK_THREAD_DATA_URL = '/learnerdashboardthreadhandler'\nLEARNER_GOALS_DATA_URL = '/learnergoalshandler'\nLEARNER_PLAYLIST_DATA_URL = '/learnerplaylistactivityhandler'\nLEARNER_INCOMPLETE_ACTIVITY_DATA_URL = '/learnerincompleteactivityhandler'\nLIBRARY_GROUP_DATA_URL = '/librarygrouphandler'\nLIBRARY_INDEX_URL = '/community-library'\nLIBRARY_INDEX_DATA_URL = '/libraryindexhandler'\nLIBRARY_RECENTLY_PUBLISHED_URL = '/community-library/recently-published'\nLIBRARY_SEARCH_URL = '/search/find'\nLIBRARY_SEARCH_DATA_URL = '/searchhandler/data'\nLIBRARY_TOP_RATED_URL = '/community-library/top-rated'\nMACHINE_TRANSLATION_DATA_URL = '/machine_translated_state_texts_handler'\nMERGE_SKILLS_URL = '/merge_skills_handler'\nMETADATA_VERSION_HISTORY_URL_PREFIX = '/version_history_handler/metadata'\nNEW_COLLECTION_URL = '/collection_editor_handler/create_new'\nNEW_EXPLORATION_URL = '/contributehandler/create_new'\nNEW_QUESTION_URL = '/question_editor_handler/create_new'\nNEW_SKILL_URL = '/skill_editor_handler/create_new'\nTOPIC_EDITOR_STORY_URL = '/topic_editor_story_handler'\nTOPIC_EDITOR_QUESTION_URL = '/topic_editor_question_handler'\nNEW_TOPIC_URL = '/topic_editor_handler/create_new'\nPREFERENCES_URL = '/preferences'\nPRACTICE_SESSION_URL_PREFIX = '/practice_session'\nPRACTICE_SESSION_DATA_URL_PREFIX = '/practice_session/data'\nPREFERENCES_DATA_URL = '/preferenceshandler/data'\nQUESTION_EDITOR_DATA_URL_PREFIX = '/question_editor_handler/data'\nQUESTION_SKILL_LINK_URL_PREFIX = '/manage_question_skill_link'\nQUESTIONS_LIST_URL_PREFIX = '/questions_list_handler'\nQUESTION_COUNT_URL_PREFIX = '/question_count_handler'\nQUESTIONS_URL_PREFIX = '/question_player_handler'\nRECENT_COMMITS_DATA_URL = '/recentcommitshandler/recent_commits'\nRECENT_FEEDBACK_MESSAGES_DATA_URL = '/recent_feedback_messages'\nDELETE_ACCOUNT_URL = '/delete-account'\nDELETE_ACCOUNT_HANDLER_URL = '/delete-account-handler'\nEXPORT_ACCOUNT_HANDLER_URL = '/export-account-handler'\nPENDING_ACCOUNT_DELETION_URL = '/pending-account-deletion'\nREVIEW_TEST_DATA_URL_PREFIX = '/review_test_handler/data'\nREVIEW_TEST_URL_PREFIX = '/review_test'\nREVIEWABLE_OPPORTUNITIES_URL = '/getreviewableopportunitieshandler'\nROBOTS_TXT_URL = '/robots.txt'\nSITE_LANGUAGE_DATA_URL = '/save_site_language'\nSIGNUP_DATA_URL = '/signuphandler/data'\nSIGNUP_URL = '/signup'\nSKILL_DASHBOARD_DATA_URL = '/skills_dashboard/data'\nSKILL_DATA_URL_PREFIX = '/skill_data_handler'\nSKILL_EDITOR_DATA_URL_PREFIX = '/skill_editor_handler/data'\nSKILL_EDITOR_URL_PREFIX = '/skill_editor'\nSKILL_EDITOR_QUESTION_URL = '/skill_editor_question_handler'\nSKILL_MASTERY_DATA_URL = '/skill_mastery_handler/data'\nSKILL_RIGHTS_URL_PREFIX = '/skill_editor_handler/rights'\nSKILL_DESCRIPTION_HANDLER = '/skill_description_handler'\nDIAGNOSTIC_TEST_SKILL_ASSIGNMENT_HANDLER = (\n    '/diagnostic_test_skill_assignment_handler')\nDIAGNOSTIC_TEST_QUESTIONS_HANDLER_URL = '/diagnostic_test_questions_handler_url'\nSTATE_VERSION_HISTORY_URL_PREFIX = '/version_history_handler/state'\nSTORY_DATA_HANDLER = '/story_data_handler'\nSTORY_EDITOR_URL_PREFIX = '/story_editor'\nSTORY_EDITOR_DATA_URL_PREFIX = '/story_editor_handler/data'\nSTORY_PROGRESS_URL_PREFIX = '/story_progress_handler'\nSTORY_PUBLISH_HANDLER = '/story_publish_handler'\nSTORY_URL_FRAGMENT_HANDLER = '/story_url_fragment_handler'\nSTORY_VIEWER_URL_PREFIX = '/story'\nSUBTOPIC_DATA_HANDLER = '/subtopic_data_handler'\n# This should be synchronized with SUBTOPIC_MASTERY_DATA_URL_TEMPLATE\n# in app.constants.ts.\nSUBTOPIC_MASTERY_DATA_URL = '/subtopic_mastery_handler/data'\nSUBTOPIC_VIEWER_URL_PREFIX = '/subtopic'\nSUGGESTION_ACTION_URL_PREFIX = '/suggestionactionhandler'\nSUGGESTION_LIST_URL_PREFIX = '/suggestionlisthandler'\nSUGGESTION_URL_PREFIX = '/suggestionhandler'\nUPDATE_TRANSLATION_SUGGESTION_URL_PREFIX = (\n    '/updatetranslationsuggestionhandler')\nUPDATE_QUESTION_SUGGESTION_URL_PREFIX = (\n    '/updatequestionsuggestionhandler')\nSUBSCRIBE_URL_PREFIX = '/subscribehandler'\nSUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX = '/subtopic_page_editor_handler/data'\nTOPIC_VIEWER_URL_PREFIX = (\n    '/learn/<classroom_url_fragment>/<topic_url_fragment>')\nTOPIC_DATA_HANDLER = '/topic_data_handler'\nTOPIC_ID_TO_TOPIC_NAME = '/topic_id_to_topic_name_handler'\nTOPIC_EDITOR_DATA_URL_PREFIX = '/topic_editor_handler/data'\nTOPIC_EDITOR_URL_PREFIX = '/topic_editor'\nTOPIC_NAME_HANDLER = '/topic_name_handler'\nTOPIC_RIGHTS_URL_PREFIX = '/rightshandler/get_topic_rights'\nTOPIC_SEND_MAIL_URL_PREFIX = '/rightshandler/send_topic_publish_mail'\nTOPIC_STATUS_URL_PREFIX = '/rightshandler/change_topic_status'\nTOPIC_URL_FRAGMENT_HANDLER = '/topic_url_fragment_handler'\nTOPICS_AND_SKILLS_DASHBOARD_DATA_URL = '/topics_and_skills_dashboard/data'\nUNASSIGN_SKILL_DATA_HANDLER_URL = '/topics_and_skills_dashboard/unassign_skill'\nTOPIC_ID_TO_DIAGNOSTIC_TEST_SKILL_IDS_HANDLER = (\n    '/topic_id_to_diagnostic_test_skill_ids_handler')\nTOPICS_AND_SKILLS_DASHBOARD_URL = '/topics-and-skills-dashboard'\nUNSUBSCRIBE_URL_PREFIX = '/unsubscribehandler'\nUPLOAD_EXPLORATION_URL = '/contributehandler/upload'\nUSER_EXPLORATION_EMAILS_PREFIX = '/createhandler/notificationpreferences'\nUSER_PERMISSIONS_URL_PREFIX = '/createhandler/permissions'\nUSERNAME_CHECK_DATA_URL = '/usernamehandler/data'\nVALIDATE_STORY_EXPLORATIONS_URL_PREFIX = '/validate_story_explorations'\nFACILITATOR_DASHBOARD_HANDLER = '/facilitator_dashboard_handler'\nFACILITATOR_DASHBOARD_PAGE_URL = '/facilitator-dashboard'\nLEARNER_DASHBOARD_LEARNER_GROUPS_HANDLER = (\n    '/learner_dashboard_learner_groups_handler')\nCREATE_LEARNER_GROUP_PAGE_URL = '/create-learner-group'\nEDIT_LEARNER_GROUP_PAGE_URL = '/edit-learner-group'\nCLASSROOM_ADMIN_DATA_HANDLER_URL = '/classroom_admin_data_handler'\nNEW_CLASSROOM_ID_HANDLER_URL = '/new_classroom_id_handler'\nCLASSROOM_HANDLER_URL = '/classroom'\nCLASSROOM_URL_FRAGMENT_HANDLER = '/classroom_url_fragment_handler'\nCLASSROOM_ID_HANDLER_URL = '/classroom_id_handler'\n\n# Event types.\nEVENT_TYPE_ALL_STATS = 'all_stats'\nEVENT_TYPE_STATE_HIT = 'state_hit'\nEVENT_TYPE_STATE_COMPLETED = 'state_complete'\nEVENT_TYPE_ANSWER_SUBMITTED = 'answer_submitted'\nEVENT_TYPE_DEFAULT_ANSWER_RESOLVED = 'default_answer_resolved'\nEVENT_TYPE_NEW_THREAD_CREATED = 'feedback_thread_created'\nEVENT_TYPE_THREAD_STATUS_CHANGED = 'feedback_thread_status_changed'\nEVENT_TYPE_RATE_EXPLORATION = 'rate_exploration'\nEVENT_TYPE_SOLUTION_HIT = 'solution_hit'\nEVENT_TYPE_LEAVE_FOR_REFRESHER_EXP = 'leave_for_refresher_exp'\n# The values for these event types should be left as-is for backwards\n# compatibility.\nEVENT_TYPE_START_EXPLORATION = 'start'\nEVENT_TYPE_ACTUAL_START_EXPLORATION = 'actual_start'\nEVENT_TYPE_MAYBE_LEAVE_EXPLORATION = 'leave'\nEVENT_TYPE_COMPLETE_EXPLORATION = 'complete'\n\n# Play type constants.\nPLAY_TYPE_PLAYTEST = 'playtest'\nPLAY_TYPE_NORMAL = 'normal'\n\n# Predefined commit messages.\nCOMMIT_MESSAGE_EXPLORATION_DELETED = 'Exploration deleted.'\nCOMMIT_MESSAGE_COLLECTION_DELETED = 'Collection deleted.'\nCOMMIT_MESSAGE_QUESTION_DELETED = 'Question deleted.'\nCOMMIT_MESSAGE_SKILL_DELETED = 'Skill deleted.'\nCOMMIT_MESSAGE_STORY_DELETED = 'Story deleted.'\nCOMMIT_MESSAGE_SUBTOPIC_PAGE_DELETED = 'Subtopic page deleted.'\nCOMMIT_MESSAGE_TOPIC_DELETED = 'Topic deleted.'\n\n# Max number of playthroughs for an issue.\nMAX_PLAYTHROUGHS_FOR_ISSUE = 5\n\n# Number of unresolved answers to be displayed in the dashboard for each\n# exploration.\nTOP_UNRESOLVED_ANSWERS_COUNT_DASHBOARD = 3\n# Number of open feedback to be displayed in the dashboard for each exploration.\nOPEN_FEEDBACK_COUNT_DASHBOARD = 3\n# NOTE TO DEVELOPERS: This should be synchronized with app.constants.ts.\nENABLE_ML_CLASSIFIERS = False\n\n# The regular expression used to identify whether a string contains float value.\n# The regex must match with regex that is stored in vmconf.py file of Oppia-ml.\n# If this regex needs to be modified then first of all shutdown Oppia-ml VM.\n# Then update the regex constant in here and Oppia both.\n# Run any migration job that is required to migrate existing trained models\n# before starting Oppia-ml again.\nFLOAT_VERIFIER_REGEX = (\n    '^([-+]?\\\\d*\\\\.\\\\d+)$|^([-+]?(\\\\d*\\\\.?\\\\d+|\\\\d+\\\\.?\\\\d*)e[-+]?\\\\d*)$')\n\n# Current event models schema version. All event models with an\n# event_schema_version of 1 are the events collected before the rework of the\n# statistics framework which brought about the recording of new event models;\n# these models include all models recorded before Feb 2018.\nCURRENT_EVENT_MODELS_SCHEMA_VERSION = 2\n\n# Output formats of downloaded explorations.\nOUTPUT_FORMAT_JSON = 'json'\nOUTPUT_FORMAT_ZIP = 'zip'\n\n# Types of updates shown in the 'recent updates' table in the dashboard page.\nUPDATE_TYPE_EXPLORATION_COMMIT = 'exploration_commit'\nUPDATE_TYPE_COLLECTION_COMMIT = 'collection_commit'\nUPDATE_TYPE_FEEDBACK_MESSAGE = 'feedback_thread'\n\n# Possible values for user query status.\n# Valid status transitions are: processing --> completed --> archived\n# or processing --> failed.\nUSER_QUERY_STATUS_PROCESSING = 'processing'\nUSER_QUERY_STATUS_COMPLETED = 'completed'\nUSER_QUERY_STATUS_ARCHIVED = 'archived'\nUSER_QUERY_STATUS_FAILED = 'failed'\n\nALLOWED_USER_QUERY_STATUSES = (\n    USER_QUERY_STATUS_PROCESSING,\n    USER_QUERY_STATUS_COMPLETED,\n    USER_QUERY_STATUS_ARCHIVED,\n    USER_QUERY_STATUS_FAILED\n)\n\n# The time difference between which to consider two login events \"close\". This\n# is taken to be 12 hours.\nPROXIMAL_TIMEDELTA_SECS = 12 * 60 * 60\n\n# The i18n id for the header of the \"Featured Activities\" category in the\n# library index page.\nLIBRARY_CATEGORY_FEATURED_ACTIVITIES = 'I18N_LIBRARY_GROUPS_FEATURED_ACTIVITIES'\n# The i18n id for the header of the \"Top Rated Explorations\" category in the\n# library index page.\nLIBRARY_CATEGORY_TOP_RATED_EXPLORATIONS = (\n    'I18N_LIBRARY_GROUPS_TOP_RATED_EXPLORATIONS')\n# The i18n id for the header of the \"Recently Published\" category in the\n# library index page.\nLIBRARY_CATEGORY_RECENTLY_PUBLISHED = 'I18N_LIBRARY_GROUPS_RECENTLY_PUBLISHED'\n\n# The group name that appears at the end of the url for the recently published\n# page.\nLIBRARY_GROUP_RECENTLY_PUBLISHED = 'recently-published'\n# The group name that appears at the end of the url for the top rated page.\nLIBRARY_GROUP_TOP_RATED = 'top-rated'\n\n# Defaults for topic similarities.\nDEFAULT_TOPIC_SIMILARITY = 0.5\nSAME_TOPIC_SIMILARITY = 1.0\n\n# The type of the response returned by a handler when an exception is raised.\nHANDLER_TYPE_HTML = 'html'\nHANDLER_TYPE_JSON = 'json'\nHANDLER_TYPE_DOWNLOADABLE = 'downloadable'\n\n# Following are the constants for the role IDs.\n# TODO(#13388): The role id variable name doesn't match the string value,\n# write a one-off job to update the string value in the datastore.\nROLE_ID_CURRICULUM_ADMIN = 'ADMIN'\nROLE_ID_BLOG_ADMIN = 'BLOG_ADMIN'\nROLE_ID_BLOG_POST_EDITOR = 'BLOG_POST_EDITOR'\nROLE_ID_COLLECTION_EDITOR = 'COLLECTION_EDITOR'\nROLE_ID_FULL_USER = 'EXPLORATION_EDITOR'\nROLE_ID_GUEST = 'GUEST'\nROLE_ID_MOBILE_LEARNER = 'LEARNER'\nROLE_ID_MODERATOR = 'MODERATOR'\nROLE_ID_QUESTION_ADMIN = 'QUESTION_ADMIN'\nROLE_ID_RELEASE_COORDINATOR = 'RELEASE_COORDINATOR'\nROLE_ID_TOPIC_MANAGER = 'TOPIC_MANAGER'\nROLE_ID_TRANSLATION_ADMIN = 'TRANSLATION_ADMIN'\nROLE_ID_VOICEOVER_ADMIN = 'VOICEOVER_ADMIN'\n\nALLOWED_DEFAULT_USER_ROLES_ON_REGISTRATION = [\n    ROLE_ID_FULL_USER, ROLE_ID_MOBILE_LEARNER]\n\nALLOWED_USER_ROLES = [\n    ROLE_ID_CURRICULUM_ADMIN,\n    ROLE_ID_BLOG_ADMIN,\n    ROLE_ID_BLOG_POST_EDITOR,\n    ROLE_ID_COLLECTION_EDITOR,\n    ROLE_ID_FULL_USER,\n    ROLE_ID_GUEST,\n    ROLE_ID_MOBILE_LEARNER,\n    ROLE_ID_MODERATOR,\n    ROLE_ID_QUESTION_ADMIN,\n    ROLE_ID_RELEASE_COORDINATOR,\n    ROLE_ID_TOPIC_MANAGER,\n    ROLE_ID_TRANSLATION_ADMIN,\n    ROLE_ID_VOICEOVER_ADMIN\n]\n\n# Intent of the User making query to role structure via admin interface. Used\n# to store audit data regarding queries to role IDs.\nROLE_ACTION_ADD = 'add'\nROLE_ACTION_REMOVE = 'remove'\nDEPRECATED_ROLE_ACTION_UPDATE = 'update'\nROLE_ACTION_VIEW_BY_USERNAME = 'view_by_username'\nROLE_ACTION_VIEW_BY_ROLE = 'view_by_role'\n\nUSER_FILTER_CRITERION_ROLE: Final = 'role'\nUSER_FILTER_CRITERION_USERNAME: Final = 'username'\n\n# Max questions allowed in a session of practice questions.\nQUESTION_BATCH_SIZE = 10\n\nSTATE_ANSWER_STATS_MIN_FREQUENCY = 2\n\nRTE_FORMAT_TEXTANGULAR = 'text-angular'\n\nRTE_FORMAT_CKEDITOR = 'ck-editor'\n\n# RTE content specifications according to the type of the editor.\nRTE_CONTENT_SPEC: Dict[str, RteTypeTextAngularDict] = {\n    'RTE_TYPE_TEXTANGULAR': {\n        # Valid parent-child relation in TextAngular.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', 'div', 'pre', '[document]', 'ol', 'ul', 'li'],\n            'b': ['i', 'li', 'p', 'pre'],\n            'br': ['b', 'i', 'li', 'p'],\n            'i': ['b', 'li', 'p', 'pre'],\n            'li': ['ol', 'ul'],\n            'ol': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'ul': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-collapsible': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-video': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-tabs': ['b', 'i', 'li', 'p', 'pre']\n        },\n        # Valid html tags in TextAngular.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'b',\n            'br',\n            'i',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n    },\n    'RTE_TYPE_CKEDITOR': {\n        # Valid parent-child relation in CKEditor.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', '[document]', 'li'],\n            'strong': ['em', 'li', 'p', 'pre'],\n            'em': ['strong', 'li', 'p', 'pre'],\n            'br': ['strong', 'em', 'li', 'p'],\n            'li': ['ol', 'ul'],\n            'ol': ['li', 'blockquote', 'pre', '[document]'],\n            'ul': ['li', 'blockquote', 'pre', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', 'li', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-collapsible': [\n                'blockquote', 'li', '[document]'\n            ],\n            'oppia-noninteractive-video': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-tabs': ['blockquote', 'li', '[document]']\n        },\n        # Valid html tags in CKEditor.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'strong',\n            'br',\n            'em',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n\n    }\n}\n\n# Classroom page names for generating URLs. These need to be kept in sync with\n# CLASSROOM_PAGES_DATA property in config_domain.\nCLASSROOM_PAGES = ['math']\n\n# Authentication method using GAE ID (google sign in).\nGAE_AUTH_PROVIDER_ID = 'gae'\n# Authentication method using Firebase authentication. Firebase signs its ID\n# Tokens with iss='Firebase' (iss: issuer, public API refers to this as\n# \"provider id\"), so using this naming convention helps us stay consistent with\n# the status quo.\nFIREBASE_AUTH_PROVIDER_ID = 'Firebase'\n# Firebase-specific role specified for users with super admin privileges.\nFIREBASE_ROLE_SUPER_ADMIN = 'super_admin'\n\n# Firebase *explicitly* requires IDs to have at most 128 characters, and may\n# contain any valid ASCII character:\n# https://firebase.google.com/docs/auth/admin/manage-users#create_a_user\n#\n# After manually inspecting ~200 of them, however, we've found that they only\n# use alpha-numeric characters, hence the tighter restriction.\nFIREBASE_AUTH_ID_REGEX = '^[A-Za-z0-9]{1,128}$'\n\nCLOUD_DATASTORE_EMULATOR_HOST = 'localhost'\nCLOUD_DATASTORE_EMULATOR_PORT = 8089\n\nFIREBASE_EMULATOR_CONFIG_PATH = '.firebase.json'\nFIREBASE_EMULATOR_PORT = 9099\n\n# The duration a session cookie from Firebase should remain valid for. After the\n# duration expires, a new cookie will need to be generated. Generating a new\n# cookie requires the user to sign-in _explicitly_.\nFIREBASE_SESSION_COOKIE_MAX_AGE = datetime.timedelta(days=14)\n\n# TODO(#10501): Once domain objects can be imported by the storage layer, move\n# these back to appropriate places (rights_domain, topic_domain).\n# The reserved prefix for keys that are automatically inserted into a\n# commit_cmd dict by this model.\nAUTOGENERATED_PREFIX = 'AUTO'\n\n# The command string for a revert commit.\nCMD_REVERT_COMMIT = '%s_revert_version_number' % AUTOGENERATED_PREFIX\n\n# The command string for a delete commit.\nCMD_DELETE_COMMIT = '%s_mark_deleted' % AUTOGENERATED_PREFIX\n\n# IMPORTANT: Ensure that all changes to how these cmds are interpreted preserve\n# backward-compatibility with previous exploration snapshots in the datastore.\n# Do not modify the definitions of CMD keys that already exist.\nCMD_CREATE_NEW = 'create_new'\nCMD_CHANGE_ROLE = 'change_role'\nCMD_REMOVE_ROLE = 'remove_role'\nCMD_CHANGE_EXPLORATION_STATUS = 'change_exploration_status'\nCMD_CHANGE_COLLECTION_STATUS = 'change_collection_status'\nCMD_CHANGE_PRIVATE_VIEWABILITY = 'change_private_viewability'\nCMD_RELEASE_OWNERSHIP = 'release_ownership'\nCMD_UPDATE_FIRST_PUBLISHED_MSEC = 'update_first_published_msec'\n\n# Roles used in collections and explorations.\nROLE_OWNER = 'owner'\nROLE_EDITOR = 'editor'\nROLE_VOICE_ARTIST = 'voice artist'\nROLE_VIEWER = 'viewer'\nROLE_NONE = 'none'\n\n# The list of entity types that do not require entity specific access control\n# when viewing respective suggestions.\nENTITY_TYPES_WITH_UNRESTRICTED_VIEW_SUGGESTION_ACCESS = [ENTITY_TYPE_SKILL]\n\n# The allowed list of roles which can be used in change_role command.\nALLOWED_ACTIVITY_ROLES = [\n    ROLE_OWNER, ROLE_EDITOR, ROLE_VOICE_ARTIST, ROLE_VIEWER]\n\n# The allowed list of status which can be used in change_exploration_status\n# and change_collection_status commands.\nALLOWED_ACTIVITY_STATUS = [\n    constants.ACTIVITY_STATUS_PRIVATE, constants.ACTIVITY_STATUS_PUBLIC]\n\n# Commands allowed in CollectionRightsChange and ExplorationRightsChange.\nCOMMON_RIGHTS_ALLOWED_COMMANDS: List[ValidCmdDict] = [{\n    'name': CMD_CREATE_NEW,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_CHANGE_ROLE,\n    'required_attribute_names': ['assignee_id', 'old_role', 'new_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['assignee_id'],\n    'allowed_values': {\n        'new_role': ALLOWED_ACTIVITY_ROLES, 'old_role': ALLOWED_ACTIVITY_ROLES\n    },\n    'deprecated_values': {}\n}, {\n    'name': CMD_REMOVE_ROLE,\n    'required_attribute_names': ['removed_user_id', 'old_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['removed_user_id'],\n    'allowed_values': {'old_role': ALLOWED_ACTIVITY_ROLES},\n    'deprecated_values': {}\n}, {\n    'name': CMD_CHANGE_PRIVATE_VIEWABILITY,\n    'required_attribute_names': [\n        'old_viewable_if_private', 'new_viewable_if_private'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_RELEASE_OWNERSHIP,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_UPDATE_FIRST_PUBLISHED_MSEC,\n    'required_attribute_names': [\n        'old_first_published_msec', 'new_first_published_msec'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_DELETE_COMMIT,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}]\n\nCOLLECTION_RIGHTS_CHANGE_ALLOWED_COMMANDS: List[ValidCmdDict] = copy.deepcopy(\n    COMMON_RIGHTS_ALLOWED_COMMANDS\n)\nCOLLECTION_RIGHTS_CHANGE_ALLOWED_COMMANDS.append({\n    'name': CMD_CHANGE_COLLECTION_STATUS,\n    'required_attribute_names': ['old_status', 'new_status'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {\n        'old_status': ALLOWED_ACTIVITY_STATUS,\n        'new_status': ALLOWED_ACTIVITY_STATUS\n    },\n    'deprecated_values': {}\n})\n\nEXPLORATION_RIGHTS_CHANGE_ALLOWED_COMMANDS = copy.deepcopy(\n    COMMON_RIGHTS_ALLOWED_COMMANDS)\nEXPLORATION_RIGHTS_CHANGE_ALLOWED_COMMANDS.append({\n    'name': CMD_CHANGE_EXPLORATION_STATUS,\n    'required_attribute_names': ['old_status', 'new_status'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {\n        'old_status': ALLOWED_ACTIVITY_STATUS,\n        'new_status': ALLOWED_ACTIVITY_STATUS\n    },\n    # TODO(#12991): Remove this once once we use the migration jobs to remove\n    # the deprecated values from the server data.\n    'deprecated_values': {\n        'new_status': ['publicized']\n    }\n})\n\nCMD_REMOVE_MANAGER_ROLE = 'remove_manager_role'\nCMD_PUBLISH_TOPIC = 'publish_topic'\nCMD_UNPUBLISH_TOPIC = 'unpublish_topic'\n\nROLE_MANAGER = 'manager'\n\n# The allowed list of roles which can be used in TopicRightsChange change_role\n# command.\nALLOWED_TOPIC_ROLES = [ROLE_NONE, ROLE_MANAGER]\n\n# Commands allowed in TopicRightsChange.\nTOPIC_RIGHTS_CHANGE_ALLOWED_COMMANDS: List[ValidCmdDict] = [{\n    'name': CMD_CREATE_NEW,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_CHANGE_ROLE,\n    'required_attribute_names': ['assignee_id', 'new_role', 'old_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['assignee_id'],\n    'allowed_values': {\n        'new_role': ALLOWED_TOPIC_ROLES, 'old_role': ALLOWED_TOPIC_ROLES\n    },\n    'deprecated_values': {}\n}, {\n    'name': CMD_REMOVE_MANAGER_ROLE,\n    'required_attribute_names': ['removed_user_id'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['removed_user_id'],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_PUBLISH_TOPIC,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_UNPUBLISH_TOPIC,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}, {\n    'name': CMD_DELETE_COMMIT,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {},\n    'deprecated_values': {}\n}]\n\nUSER_ID_RANDOM_PART_LENGTH = 32\nUSER_ID_LENGTH = 36\nUSER_ID_REGEX = r'uid_[a-z]{%s}' % USER_ID_RANDOM_PART_LENGTH\nPSEUDONYMOUS_ID_REGEX = r'pid_[a-z]{%s}' % USER_ID_RANDOM_PART_LENGTH\n\n# Length of user PIN for different roles used on Android.\nFULL_USER_PIN_LENGTH = 5\nPROFILE_USER_PIN_LENGTH = 3\n\nMAX_NUMBER_OF_OPS_IN_TRANSACTION = 25\n\n# This is the maximum wait time for the task queue HTTP request. If the request\n# takes longer than this value, an exception is raised. The default value\n# of 5 seconds is too short and must be avoided because it can cause events\n# to go unrecorded.\n# https://cloud.google.com/appengine/docs/standard/python/outbound-requests#request_timeouts\nDEFAULT_TASKQUEUE_TIMEOUT_SECONDS = 30\n\n# Mapping from issue type to issue keyname in the issue customization dict. This\n# mapping is useful to uniquely identify issues by the combination of their\n# issue type and other type-specific information (such as the list of states\n# involved).\nCUSTOMIZATION_ARG_WHICH_IDENTIFIES_ISSUE = {\n    'EarlyQuit': 'state_name',\n    'MultipleIncorrectSubmissions': 'state_name',\n    'CyclicStateTransitions': 'state_names'\n}\n\n# Constants defining various suggestion types.\nSUGGESTION_TYPE_EDIT_STATE_CONTENT: Final = 'edit_exploration_state_content'\nSUGGESTION_TYPE_TRANSLATE_CONTENT: Final = 'translate_content'\nSUGGESTION_TYPE_ADD_QUESTION: Final = 'add_question'\n\nCONTRIBUTION_TYPE_TRANSLATION: Final = 'translation'\nCONTRIBUTION_TYPE_QUESTION: Final = 'question'\nCONTRIBUTION_SUBTYPE_ACCEPTANCE: Final = 'acceptance'\nCONTRIBUTION_SUBTYPE_REVIEW: Final = 'review'\nCONTRIBUTION_SUBTYPE_EDIT: Final = 'edit'\nCONTRIBUTION_SUBTYPE_SUBMISSION: Final = 'submission'\n\nTRANSLATION_TEAM_LEAD = 'Anubhuti Varshney'\nQUESTION_TEAM_LEAD = 'Jatin Kumar Jadoun'\n\n# Suggestion fields that can be queried.\nALLOWED_SUGGESTION_QUERY_FIELDS = [\n    'suggestion_type', 'target_type', 'target_id', 'status', 'author_id',\n    'final_reviewer_id', 'score_category', 'language_code'\n]\n\n# Possible targets that the suggestions can modify.\nSUGGESTION_TARGET_TYPE_CHOICES = [\n    ENTITY_TYPE_EXPLORATION,\n    ENTITY_TYPE_QUESTION,\n    ENTITY_TYPE_SKILL,\n    ENTITY_TYPE_TOPIC\n]\n\n# Possible suggestion types.\nSUGGESTION_TYPE_CHOICES = [\n    SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n    SUGGESTION_TYPE_TRANSLATE_CONTENT,\n    SUGGESTION_TYPE_ADD_QUESTION\n]\n\n# The types of suggestions that are offered on the Contributor Dashboard.\nCONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES = [\n    SUGGESTION_TYPE_TRANSLATE_CONTENT,\n    SUGGESTION_TYPE_ADD_QUESTION\n]\n\n# The sort keys of submitted questions shown on the Contributor Dashboard.\nSUGGESTIONS_SORT_KEYS = [constants.SUGGESTIONS_SORT_KEY_DATE]\n\n# Prefix for all access validation handlers.\n# The naming scheme for access validation handlers is\n# '/access_validation_handler/<handler_name>'\n# example '/access_validation_handler/validate_access_to_splash_page'.\nACCESS_VALIDATION_HANDLER_PREFIX = '/access_validation_handler'\n\n# The possible commit types.\nCOMMIT_TYPE_CREATE = 'create'\nCOMMIT_TYPE_REVERT = 'revert'\nCOMMIT_TYPE_EDIT = 'edit'\nCOMMIT_TYPE_DELETE = 'delete'\n\n# Interaction IDs of math related interactions.\nMATH_INTERACTION_IDS = [\n    'NumericExpressionInput', 'AlgebraicExpressionInput', 'MathEquationInput']\n\n# The task entry ID template used by the task entry model.\nTASK_ENTRY_ID_TEMPLATE = '%s.%s.%d.%s.%s.%s'\n\n# The composite entity ID template used by the task entry model.\nCOMPOSITE_ENTITY_ID_TEMPLATE = '%s.%s.%d'\n\n# The data type for the translated or translatable content in any\n# BaseTranslatableObject.\nContentValueType = Union[str, List[str]]\n\n\nclass TranslatableEntityType(enum.Enum):\n    \"\"\"Represents all possible entity types which support new translations\n    architecture.\n    \"\"\"\n\n    EXPLORATION = 'exploration'\n    QUESTION = 'question'\n\n\nclass TranslatedContentDict(TypedDict):\n    \"\"\"Dictionary representing TranslatedContent object.\"\"\"\n\n    content_value: ContentValueType\n    needs_update: bool\n"
    },
    {
      "filename": "core/storage/suggestion/gae_models.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Models for Oppia suggestions.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.platform import models\n\nfrom typing import (\n    Dict, Final, List, Literal, Mapping, Optional, Sequence, Tuple, TypedDict,\n    Union)\n\nMYPY = False\nif MYPY: # pragma: no cover\n    # Here, 'change_domain' is imported only for type checking.\n    from core.domain import change_domain  # pylint: disable=invalid-import # isort:skip\n    from mypy_imports import base_models\n    from mypy_imports import datastore_services\n\n(base_models, user_models) = models.Registry.import_models([\n    models.Names.BASE_MODEL, models.Names.USER\n])\n\ndatastore_services = models.Registry.import_datastore_services()\n\n# Constants defining the different possible statuses of a suggestion.\nSTATUS_ACCEPTED: Final = 'accepted'\nSTATUS_IN_REVIEW: Final = 'review'\nSTATUS_REJECTED: Final = 'rejected'\n\nSTATUS_CHOICES: Final = [\n    STATUS_ACCEPTED,\n    STATUS_IN_REVIEW,\n    STATUS_REJECTED\n]\n\n# Daily emails are sent to reviewers to notify them of suggestions on the\n# Contributor Dashboard to review. The constants below define the number of\n# question and translation suggestions to fetch to come up with these daily\n# suggestion recommendations.\nMAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS: Final = 30\nMAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS: Final = 30\n\n# Defines what is the minimum role required to review suggestions\n# of a particular type.\nSUGGESTION_MINIMUM_ROLE_FOR_REVIEW: Final = {\n    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT: feconf.ROLE_ID_FULL_USER\n}\n\n# Constants defining various contribution types.\nSCORE_TYPE_CONTENT: Final = 'content'\nSCORE_TYPE_TRANSLATION: Final = 'translation'\nSCORE_TYPE_QUESTION: Final = 'question'\n\nSCORE_TYPE_CHOICES: Final = [\n    SCORE_TYPE_CONTENT,\n    SCORE_TYPE_TRANSLATION,\n    SCORE_TYPE_QUESTION\n]\n\n# The delimiter to be used in score category field.\nSCORE_CATEGORY_DELIMITER: Final = '.'\n\n# Threshold number of days after which suggestion will be accepted.\nTHRESHOLD_DAYS_BEFORE_ACCEPT: Final = 7\n\n# Threshold time after which suggestion is considered stale and auto-accepted.\nTHRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS: Final = (\n    THRESHOLD_DAYS_BEFORE_ACCEPT * 24 * 60 * 60 * 1000\n)\n\n# Threshold number of days after which to notify the admin that the\n# suggestion has waited too long for a review. The admin will be notified of the\n# top MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN number of suggestions that have\n# waited for a review longer than the threshold number of days.\nSUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS: Final = 7\n\n# The maximum number of suggestions, that have been waiting too long for review,\n# to email admins about.\nMAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN: Final = 10\n\n# The default message to be shown when accepting stale suggestions.\nDEFAULT_SUGGESTION_ACCEPT_MESSAGE: Final = (\n    'Automatically accepting suggestion after'\n    ' %d days' % THRESHOLD_DAYS_BEFORE_ACCEPT\n)\n\n# The message to be shown when rejecting a suggestion with a target ID of a\n# deleted skill.\nDELETED_SKILL_REJECT_MESSAGE: Final = 'The associated skill no longer exists.'\n\n# The message to be shown when rejecting a translation suggestion that is\n# associated with an exploration that no longer corresponds to the story.\n# The story could have been deleted or the exploration could have been removed\n# from the story.\nINVALID_STORY_REJECT_TRANSLATION_SUGGESTIONS_MSG: Final = (\n    'This text snippet has been removed from the story, and no longer needs '\n    'translation. Sorry about that!'\n)\n\n# The amount to increase the score of the author by after successfuly getting an\n# accepted suggestion.\nINCREMENT_SCORE_OF_AUTHOR_BY: Final = 1\n\n# The unique ID for the CommunityContributionStatsModel.\nCOMMUNITY_CONTRIBUTION_STATS_MODEL_ID: Final = 'community_contribution_stats'\n\n\nclass GeneralSuggestionExportDataDict(TypedDict):\n    \"\"\"Type for the Dictionary of the data from GeneralSuggestionModel.\"\"\"\n\n    suggestion_type: str\n    target_type: str\n    target_id: str\n    target_version_at_submission: int\n    status: str\n    change_cmd: Dict[str, change_domain.AcceptableChangeDictTypes]\n    language_code: str\n    edited_by_reviewer: bool\n\n\nclass GeneralSuggestionModel(base_models.BaseModel):\n    \"\"\"Model to store suggestions made by Oppia users.\n\n    The ID of the suggestions created is the same as the ID of the thread\n    linked to the suggestion.\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY: Literal[True] = True\n\n    # The type of suggestion.\n    suggestion_type = datastore_services.StringProperty(\n        required=True, indexed=True, choices=feconf.SUGGESTION_TYPE_CHOICES)\n    # The type of the target entity which the suggestion is linked to.\n    target_type = datastore_services.StringProperty(\n        required=True,\n        indexed=True,\n        choices=feconf.SUGGESTION_TARGET_TYPE_CHOICES\n    )\n    # The ID of the target entity being suggested to.\n    target_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The version number of the target entity at the time of creation of the\n    # suggestion.\n    target_version_at_submission = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # Status of the suggestion.\n    status = datastore_services.StringProperty(\n        required=True, indexed=True, choices=STATUS_CHOICES)\n    # The ID of the author of the suggestion.\n    author_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The ID of the reviewer who accepted/rejected the suggestion.\n    final_reviewer_id = datastore_services.StringProperty(indexed=True)\n    # The change command linked to the suggestion. Contains the details of the\n    # change.\n    change_cmd = datastore_services.JsonProperty(required=True)\n    # The category to score the suggestor in. This field will contain 2 values\n    # separated by a ., the first will be a value from SCORE_TYPE_CHOICES and\n    # the second will be the subcategory of the suggestion.\n    score_category = (\n        datastore_services.StringProperty(required=True, indexed=True))\n    # The ISO 639-1 code used to query suggestions by language, or None if the\n    # suggestion type is not queryable by language.\n    language_code = datastore_services.StringProperty(indexed=True)\n    # A flag that indicates whether the suggestion is edited by the reviewer.\n    edited_by_reviewer = datastore_services.BooleanProperty(\n        default=False, indexed=True)\n\n    @staticmethod\n    def get_deletion_policy() -> base_models.DELETION_POLICY:\n        \"\"\"Model contains data to pseudonymize corresponding to a user:\n        author_id, and final_reviewer_id fields.\n        \"\"\"\n        return base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple unshared instance since there\n        are multiple suggestions per user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'suggestion_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_id': base_models.EXPORT_POLICY.EXPORTED,\n            'target_version_at_submission':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'status': base_models.EXPORT_POLICY.EXPORTED,\n            # The author_id and final_reviewer_id are not exported since\n            # we do not want to reveal internal user ids.\n            'author_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'final_reviewer_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'change_cmd': base_models.EXPORT_POLICY.EXPORTED,\n            'score_category': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'edited_by_reviewer': base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether GeneralSuggestionModel exists for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(datastore_services.any_of(\n            cls.author_id == user_id, cls.final_reviewer_id == user_id\n        )).get(keys_only=True) is not None\n\n    @classmethod\n    def create(\n            cls,\n            suggestion_type: str,\n            target_type: str,\n            target_id: str,\n            target_version_at_submission: int,\n            status: str,\n            author_id: str,\n            final_reviewer_id: Optional[str],\n            change_cmd: Mapping[\n                str, change_domain.AcceptableChangeDictTypes\n            ],\n            score_category: str,\n            thread_id: str,\n            language_code: Optional[str]\n    ) -> None:\n        \"\"\"Creates a new SuggestionModel entry.\n\n        Args:\n            suggestion_type: str. The type of the suggestion.\n            target_type: str. The type of target entity being edited.\n            target_id: str. The ID of the target entity being edited.\n            target_version_at_submission: int. The version number of the target\n                entity at the time of creation of the suggestion.\n            status: str. The status of the suggestion.\n            author_id: str. The ID of the user who submitted the suggestion.\n            final_reviewer_id: str|None. The ID of the reviewer who has\n                accepted/rejected the suggestion, or None if no reviewer is\n                assigned.\n            change_cmd: dict. The actual content of the suggestion.\n            score_category: str. The scoring category for the suggestion.\n            thread_id: str. The ID of the feedback thread linked to the\n                suggestion.\n            language_code: str|None. The ISO 639-1 code used to query\n                suggestions by language, or None if the suggestion type is not\n                queryable by language.\n\n        Raises:\n            Exception. There is already a suggestion with the given id.\n        \"\"\"\n        instance_id = thread_id\n\n        if cls.get_by_id(instance_id):\n            raise Exception(\n                'There is already a suggestion with the given'\n                ' id: %s' % instance_id)\n\n        cls(\n            id=instance_id, suggestion_type=suggestion_type,\n            target_type=target_type, target_id=target_id,\n            target_version_at_submission=target_version_at_submission,\n            status=status, author_id=author_id,\n            final_reviewer_id=final_reviewer_id, change_cmd=change_cmd,\n            score_category=score_category, language_code=language_code).put()\n\n    @classmethod\n    def query_suggestions(\n        cls, query_fields_and_values: List[Tuple[str, str]]\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Queries for suggestions.\n\n        Args:\n            query_fields_and_values: list(tuple(str, str)). A list of queries.\n                The first element in each tuple is the field to be queried, and\n                the second element is the corresponding value to query for.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that match the given\n            query values, up to a maximum of\n            feconf.DEFAULT_SUGGESTION_QUERY_LIMIT suggestions.\n\n        Raises:\n            Exception. The field cannot be queried.\n        \"\"\"\n        query = cls.query()\n        for (field, value) in query_fields_and_values:\n            if field not in feconf.ALLOWED_SUGGESTION_QUERY_FIELDS:\n                raise Exception('Not allowed to query on field %s' % field)\n            query = query.filter(getattr(cls, field) == value)\n        return query.fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_translation_suggestions_in_review_with_exp_id(\n        cls, exp_id: str, language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns translation suggestions which are in review with target_id\n        == exp_id.\n\n        Args:\n            exp_id: str. Exploration ID matching the target ID of the\n                translation suggestions.\n            language_code: str. Language code.\n\n        Returns:\n            list(SuggestionModel). A list of translation suggestions in review\n            with target_id of exp_id. The number of returned results is capped\n            by feconf.DEFAULT_SUGGESTION_QUERY_LIMIT.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.language_code == language_code,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id == exp_id\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_translation_suggestion_ids_with_exp_ids(\n        cls, exp_ids: List[str]\n    ) -> List[str]:\n        \"\"\"Gets the ids of translation suggestions corresponding to\n        explorations with the given exploration ids.\n\n        Args:\n            exp_ids: list(str). List of exploration ids to query for.\n\n        Returns:\n            list(str). A list of translation suggestion ids that\n            correspond to the given exploration ids. Note: it is not\n            guaranteed that the suggestion ids returned are ordered by the\n            exploration ids in exp_ids.\n        \"\"\"\n        query = cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id.IN(exp_ids)\n        ))\n        suggestion_models: List[GeneralSuggestionModel] = []\n        offset, more = (0, True)\n        while more:\n            results: Sequence[GeneralSuggestionModel] = (\n                query.fetch(\n                    feconf.DEFAULT_SUGGESTION_QUERY_LIMIT, offset=offset))\n            if len(results):\n                offset = offset + len(results)\n                suggestion_models.extend(results)\n            else:\n                more = False\n        return [suggestion_model.id for suggestion_model in suggestion_models]\n\n    @classmethod\n    def get_all_stale_suggestion_ids(cls) -> List[str]:\n        \"\"\"Gets the ids of the suggestions which were last updated before the\n        threshold time.\n\n        Returns:\n            list(str). A list of the ids of the suggestions that are stale.\n        \"\"\"\n        threshold_time = (\n            datetime.datetime.utcnow() - datetime.timedelta(\n                0, 0, 0, THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS))\n        suggestion_models: Sequence[GeneralSuggestionModel] = (\n            cls.get_all().filter(\n                cls.status == STATUS_IN_REVIEW\n            ).filter(cls.last_updated < threshold_time).fetch()\n        )\n        return [suggestion_model.id for suggestion_model in suggestion_models]\n\n    @classmethod\n    def get_suggestions_waiting_too_long_for_review(\n        cls\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns a list of suggestions that have been waiting for a review\n        longer than SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days on the\n        Contributor Dashboard. MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN\n        suggestions are returned, sorted in descending order by their review\n        wait time.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of suggestions, sorted in\n            descending order by their review wait time.\n\n        Raises:\n            Exception. If there are no suggestion types offered on the\n                Contributor Dashboard.\n        \"\"\"\n        if not feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES:\n            raise Exception(\n                'Expected the suggestion types offered on the Contributor '\n                'Dashboard to be nonempty.')\n        threshold_time = (\n            datetime.datetime.utcnow() - datetime.timedelta(\n                days=SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS))\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.last_updated < threshold_time,\n            cls.suggestion_type.IN(\n                feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES)\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN)\n\n    @classmethod\n    def get_translation_suggestions_submitted_within_given_dates(\n        cls,\n        from_date: datetime.datetime,\n        to_date: datetime.datetime,\n        user_id: str,\n        language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions which are are submitted within the given\n        date range.\n\n        Args:\n            from_date: Date. The date that suggestions are submitted on or\n                after.\n            to_date: Date. The date that suggestions are submitted on or before.\n            user_id: str. The id of the user who made the submissions.\n            language_code: str. The language that the contributions should be\n                fetched.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are submitted\n            within the given date range.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.created_on <= to_date,\n            cls.created_on >= from_date,\n            cls.author_id == user_id,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.language_code == language_code,\n            cls.status == STATUS_ACCEPTED\n        )).order(cls.created_on).fetch()\n\n    @classmethod\n    def get_question_suggestions_submitted_within_given_dates(\n        cls,\n        from_date: datetime.datetime,\n        to_date: datetime.datetime,\n        user_id: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions which are are submitted within the given\n        date range.\n\n        Args:\n            from_date: Date. The date that suggestions are submitted on or\n                after.\n            to_date: Date. The date that suggestions are submitted on or before.\n            user_id: str. The id of the user who made the submissions.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are submitted\n            before the given date range.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.created_on <= to_date,\n            cls.created_on >= from_date,\n            cls.author_id == user_id,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            cls.status == STATUS_ACCEPTED\n        )).order(cls.created_on).fetch()\n\n    @classmethod\n    def get_in_review_suggestions_in_score_categories(\n        cls, score_categories: List[str], user_id: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions which are in review in the given\n        score_categories.\n\n        Args:\n            score_categories: list(str). List of score categories to query for.\n            user_id: str. The id of the user trying to make this query.\n                As a user cannot review their own suggestions, suggestions\n                authored by the user will be excluded.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are in the given\n            score categories, which are in review, but not created by the\n            given user.\n\n        Raises:\n            Exception. Given list of score categories is empty.\n        \"\"\"\n        if len(score_categories) == 0:\n            raise Exception('Received empty list of score categories')\n\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.score_category.IN(score_categories),\n            cls.author_id != user_id\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_in_review_translation_suggestions(\n        cls,\n        user_id: str,\n        language_codes: List[str]\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Fetches all translation suggestions that are in-review where the\n        author_id != user_id and language_code matches one of the supplied\n        language_codes.\n\n        Args:\n            user_id: str. The id of the user trying to make this query. As a\n                user cannot review their own suggestions, suggestions authored\n                by the user will be excluded.\n            language_codes: list(str). List of language codes that the\n                suggestions should match.\n\n        Returns:\n            list(SuggestionModel). A list of the matching suggestions.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.author_id != user_id,\n            cls.language_code.IN(language_codes)\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_in_review_translation_suggestions_by_offset(\n        cls,\n        limit: Optional[int],\n        offset: int,\n        user_id: str,\n        sort_key: Optional[str],\n        language_codes: List[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches translation suggestions that are in-review where the\n        author_id != user_id and language_code matches one of the supplied\n        language_codes.\n\n        Args:\n            limit: int|None. Maximum number of entities to be returned. If None,\n                returns all matching entities.\n            offset: int. Number of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query. As a\n                user cannot review their own suggestions, suggestions authored\n                by the user will be excluded.\n            sort_key: str|None. The key to sort the suggestions by.\n            language_codes: list(str). List of language codes that the\n                suggestions should match.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, and that match\n                    one of the supplied language codes.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        if sort_key == constants.SUGGESTIONS_SORT_KEY_DATE:\n            # The first sort property must be the same as the property to which\n            # an inequality filter is applied. Thus, the inequality filter on\n            # author_id can not be used here.\n            suggestion_query = cls.get_all().filter(datastore_services.all_of(\n                cls.status == STATUS_IN_REVIEW,\n                cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                cls.language_code.IN(language_codes)\n            )).order(-cls.created_on)\n\n            sorted_results: List[GeneralSuggestionModel] = []\n\n            if limit is None:\n                suggestion_models: Sequence[GeneralSuggestionModel] = (\n                    suggestion_query.fetch(offset=offset))\n                for suggestion_model in suggestion_models:\n                    offset += 1\n                    if suggestion_model.author_id != user_id:\n                        sorted_results.append(suggestion_model)\n            else:\n                num_suggestions_per_fetch = 1000\n\n                while len(sorted_results) < limit:\n                    suggestion_models = suggestion_query.fetch(\n                        num_suggestions_per_fetch, offset=offset)\n                    if not suggestion_models:\n                        break\n                    for suggestion_model in suggestion_models:\n                        offset += 1\n                        if suggestion_model.author_id != user_id:\n                            sorted_results.append(suggestion_model)\n                            if len(sorted_results) == limit:\n                                break\n\n            return (\n                sorted_results,\n                offset\n            )\n\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.author_id != user_id,\n            cls.language_code.IN(language_codes)\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n            if limit is not None\n            else suggestion_query.fetch(offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_in_review_translation_suggestions_with_exp_ids_by_offset(\n        cls,\n        limit: Optional[int],\n        offset: int,\n        user_id: str,\n        sort_key: Optional[str],\n        language_codes: List[str],\n        exp_ids: List[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Gets all translation suggestions for the given language\n        codes which are in review and correspond to the\n        given exploration IDs.\n\n        Args:\n            limit: int|None. Maximum number of entities to be returned. If None,\n                returns all matching entities.\n            offset: int. Number of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query.\n                As a user cannot review their own suggestions, suggestions\n                authored by the user will be excluded.\n            sort_key: str|None. The key to sort the suggestions by.\n            language_codes: list(str). The list of language codes.\n            exp_ids: list(str). Exploration IDs matching the target ID of the\n                translation suggestions.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, match\n                    one of the supplied language codes and correspond to the\n                    given exploration IDs.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        if sort_key == constants.SUGGESTIONS_SORT_KEY_DATE:\n            # The first sort property must be the same as the property to which\n            # an inequality filter is applied. Thus, the inequality filter on\n            # author_id can not be used here.\n            suggestion_query = cls.get_all().filter(datastore_services.all_of(\n                cls.status == STATUS_IN_REVIEW,\n                cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                cls.language_code.IN(language_codes),\n                cls.target_id.IN(exp_ids)\n            )).order(-cls.created_on)\n\n            sorted_results: List[GeneralSuggestionModel] = []\n\n            if limit is None:\n                suggestion_models: Sequence[GeneralSuggestionModel] = (\n                    suggestion_query.fetch(offset=offset))\n                for suggestion_model in suggestion_models:\n                    offset += 1\n                    if suggestion_model.author_id != user_id:\n                        sorted_results.append(suggestion_model)\n            else:\n                num_suggestions_per_fetch = 1000\n\n                while len(sorted_results) < limit:\n                    suggestion_models = suggestion_query.fetch(\n                        num_suggestions_per_fetch, offset=offset)\n                    if not suggestion_models:\n                        break\n                    for suggestion_model in suggestion_models:\n                        offset += 1\n                        if suggestion_model.author_id != user_id:\n                            sorted_results.append(suggestion_model)\n                            if len(sorted_results) == limit:\n                                break\n\n            return (\n                sorted_results,\n                offset\n            )\n\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.author_id != user_id,\n            cls.language_code.IN(language_codes),\n            cls.target_id.IN(exp_ids)\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n            if limit is not None\n            else suggestion_query.fetch(offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_in_review_translation_suggestions_by_exp_ids(\n        cls, exp_ids: List[str], language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all in-review translation suggestions matching the supplied\n        exp_ids and language_code.\n\n        Args:\n            exp_ids: list(str). Exploration IDs matching the target ID of the\n                translation suggestions.\n            language_code: str. The ISO 639-1 language code of the translation\n                suggestions.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions matching the supplied\n            exp_ids and language_code.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id.IN(exp_ids),\n            cls.language_code == language_code\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_in_review_question_suggestions_by_offset(\n        cls,\n        limit: int,\n        offset: int,\n        user_id: str,\n        sort_key: Optional[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches question suggestions that are in-review and not authored by\n        the supplied user.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. Number of of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query. As a\n                user cannot review their own suggestions, suggestions authored\n                by the user will be excluded.\n            sort_key: str|None. The key to sort the suggestions by.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, and that match\n                    one of the supplied language codes.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n\n        if sort_key == constants.SUGGESTIONS_SORT_KEY_DATE:\n            # The first sort property must be the same as the property to which\n            # an inequality filter is applied. Thus, the inequality filter on\n            # author_id can not be used here.\n            suggestion_query = cls.get_all().filter(\n                datastore_services.all_of(\n                    cls.status == STATUS_IN_REVIEW,\n                    cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            )).order(-cls.created_on)\n\n            sorted_results: List[GeneralSuggestionModel] = []\n            num_suggestions_per_fetch = 1000\n\n            while len(sorted_results) < limit:\n                suggestion_models: Sequence[GeneralSuggestionModel] = (\n                    suggestion_query.fetch(\n                        num_suggestions_per_fetch, offset=offset))\n                if not suggestion_models:\n                    break\n                for suggestion_model in suggestion_models:\n                    offset += 1\n                    if suggestion_model.author_id != user_id:\n                        sorted_results.append(suggestion_model)\n                        if len(sorted_results) == limit:\n                            break\n\n            return (\n                sorted_results,\n                offset\n            )\n\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            cls.author_id != user_id\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_question_suggestions_waiting_longest_for_review(\n        cls\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS number\n        of question suggestions, sorted in descending order by review wait\n        time.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of question suggestions,\n            sorted in descending order based on how long the suggestions have\n            been waiting for review.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS)\n\n    @classmethod\n    def get_translation_suggestions_waiting_longest_for_review(\n        cls, language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS\n        number of translation suggestions in the specified language code,\n        sorted in descending order by review wait time.\n\n        Args:\n            language_code: str. The ISO 639-1 language code of the translation\n                suggestions.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of translation suggestions,\n            sorted in descending order based on how long the suggestions have\n            been waiting for review.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.language_code == language_code\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS)\n\n    @classmethod\n    def get_user_created_suggestions_of_suggestion_type(\n        cls, suggestion_type: str, user_id: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions of suggestion_type which the user has created.\n\n        Args:\n            suggestion_type: str. The type of suggestion to query for.\n            user_id: str. The id of the user trying to make this query.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are of the given\n            type, which the given user has created.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == suggestion_type,\n            cls.author_id == user_id\n        )).order(-cls.created_on).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_user_created_suggestions_by_offset(\n        cls,\n        limit: int,\n        offset: int,\n        suggestion_type: str,\n        user_id: str,\n        sort_key: Optional[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches suggestions of suggestion_type which the supplied user has\n        created.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. The number of results to skip from the beginning of all\n                results matching the query.\n            suggestion_type: str. The type of suggestion to query for.\n            user_id: str. The id of the user trying to make this query.\n            sort_key: str|None. The key to sort the suggestions by.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    of the supplied type which the supplied user has created.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == suggestion_type,\n            cls.author_id == user_id\n        ))\n\n        if sort_key == constants.SUGGESTIONS_SORT_KEY_DATE:\n            suggestion_query = suggestion_query.order(-cls.created_on)\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_all_score_categories(cls) -> List[str]:\n        \"\"\"Gets all the score categories for which suggestions have been\n        created.\n\n        Returns:\n            list(str). A list of all the score categories.\n        \"\"\"\n        query_set = cls.query(projection=['score_category'], distinct=True)\n        return [data.score_category for data in query_set]\n\n    @classmethod\n    def export_data(\n        cls, user_id: str\n    ) -> Dict[str, GeneralSuggestionExportDataDict]:\n        \"\"\"Exports the data from GeneralSuggestionModel\n        into dict format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from GeneralSuggestionModel.\n        \"\"\"\n\n        user_data: Dict[str, GeneralSuggestionExportDataDict] = {}\n        suggestion_models: Sequence[GeneralSuggestionModel] = (\n            cls.get_all().filter(cls.author_id == user_id).fetch())\n\n        for suggestion_model in suggestion_models:\n            user_data[suggestion_model.id] = {\n                'suggestion_type': suggestion_model.suggestion_type,\n                'target_type': suggestion_model.target_type,\n                'target_id': suggestion_model.target_id,\n                'target_version_at_submission': (\n                    suggestion_model\n                    .target_version_at_submission),\n                'status': suggestion_model.status,\n                'change_cmd': suggestion_model.change_cmd,\n                'language_code': suggestion_model.language_code,\n                'edited_by_reviewer': suggestion_model.edited_by_reviewer\n            }\n\n        return user_data\n\n\nclass CommunityContributionStatsModel(base_models.BaseModel):\n    \"\"\"Records the contributor dashboard contribution stats. This includes the\n    total number of reviewers for each suggestion type and the total number of\n    suggestions in review for each suggestion type. There is only ever one\n    instance of this model, and its ID is COMMUNITY_CONTRIBUTION_STATS_MODEL_ID.\n\n    Note: since this is a singleton model, the model GET and PUT must be done in\n    a transaction to avoid the loss of updates that come in rapid succession.\n    \"\"\"\n\n    # A dictionary where the keys represent the language codes that translation\n    # suggestions are offered in and the values correspond to the total number\n    # of reviewers who have permission to review translation suggestions in\n    # that language.\n    translation_reviewer_counts_by_lang_code = (\n        datastore_services.JsonProperty(required=True))\n    # A dictionary where the keys represent the language codes that translation\n    # suggestions are offered in and the values correspond to the total number\n    # of translation suggestions that are currently in review in that language.\n    translation_suggestion_counts_by_lang_code = (\n        datastore_services.JsonProperty(required=True))\n    # The total number of reviewers who have permission to review question\n    # suggestions.\n    question_reviewer_count = datastore_services.IntegerProperty(required=True)\n    # The total number of question suggestions that are currently in review.\n    question_suggestion_count = (\n        datastore_services.IntegerProperty(required=True))\n\n    # Here we use MyPy ignore because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get(cls) -> CommunityContributionStatsModel: # type: ignore[override]\n        \"\"\"Gets the CommunityContributionStatsModel instance. If the\n        CommunityContributionStatsModel does not exist yet, it is created.\n        This method helps enforce that there should only ever be one instance\n        of this model.\n\n        Returns:\n            CommunityContributionStatsModel. The single model instance.\n        \"\"\"\n        community_contribution_stats_model = cls.get_by_id(\n            COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n\n        if community_contribution_stats_model is None:\n            community_contribution_stats_model = cls(\n                id=COMMUNITY_CONTRIBUTION_STATS_MODEL_ID,\n                translation_reviewer_counts_by_lang_code={},\n                translation_suggestion_counts_by_lang_code={},\n                question_reviewer_count=0,\n                question_suggestion_count=0\n            )\n            community_contribution_stats_model.update_timestamps()\n            community_contribution_stats_model.put()\n            return community_contribution_stats_model\n\n        else:\n            return super(\n                CommunityContributionStatsModel, cls).get(\n                    COMMUNITY_CONTRIBUTION_STATS_MODEL_ID)\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model doesn't contain any data directly corresponding to a user.\"\"\"\n        return base_models.DELETION_POLICY.NOT_APPLICABLE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"This model only contains general statistical information about the\n        contributor dashboard and does not include any individual user\n        information.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model doesn't contain any data directly corresponding to a user\n        because the data is aggregated.\n        \"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'translation_reviewer_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'translation_suggestion_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_reviewer_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_suggestion_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE\n        })\n\n\nclass TranslationContributionStatsModel(base_models.BaseModel):\n    \"\"\"Records the contributor dashboard translation contribution stats. There\n    is one instance of this model per (language_code, contributor_user_id,\n    topic_id) tuple. See related design doc for more details:\n    https://docs.google.com/document/d/1JEDiy-f1vnBLwibu8hsfuo3JObBWiaFvDTTU9L18zpY/edit#\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY: Literal[True] = True\n\n    # The ISO 639-1 language code for which the translation contributions were\n    # made.\n    language_code = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The user ID of the translation contributor.\n    contributor_user_id = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The topic ID of the translation contribution.\n    topic_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The number of submitted translations.\n    submitted_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The total word count of submitted translations. Excludes HTML tags and\n    # attributes.\n    submitted_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations.\n    accepted_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations without reviewer edits.\n    accepted_translations_without_reviewer_edits_count = (\n        datastore_services.IntegerProperty(required=True, indexed=True))\n    # The total word count of accepted translations. Excludes HTML tags and\n    # attributes.\n    accepted_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of rejected translations.\n    rejected_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The total word count of rejected translations. Excludes HTML tags and\n    # attributes.\n    rejected_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The unique last_updated dates of the translation suggestions.\n    contribution_dates = datastore_services.DateProperty(\n        repeated=True, indexed=True)\n\n    @classmethod\n    def create(\n        cls,\n        language_code: str,\n        contributor_user_id: str,\n        topic_id: str,\n        submitted_translations_count: int,\n        submitted_translation_word_count: int,\n        accepted_translations_count: int,\n        accepted_translations_without_reviewer_edits_count: int,\n        accepted_translation_word_count: int,\n        rejected_translations_count: int,\n        rejected_translation_word_count: int,\n        contribution_dates: List[datetime.date]\n    ) -> str:\n        \"\"\"Creates a new TranslationContributionStatsModel instance and returns\n        its ID.\n        \"\"\"\n        entity_id = cls.construct_id(\n            language_code, contributor_user_id, topic_id)\n        entity = cls(\n            id=entity_id,\n            language_code=language_code,\n            contributor_user_id=contributor_user_id,\n            topic_id=topic_id,\n            submitted_translations_count=submitted_translations_count,\n            submitted_translation_word_count=submitted_translation_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_without_reviewer_edits_count=(\n                accepted_translations_without_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translations_count,\n            rejected_translation_word_count=rejected_translation_word_count,\n            contribution_dates=contribution_dates)\n        entity.update_timestamps()\n        entity.put()\n        return entity_id\n\n    @staticmethod\n    def construct_id(\n        language_code: str, contributor_user_id: str, topic_id: str\n    ) -> str:\n        \"\"\"Constructs a unique ID for a TranslationContributionStatsModel\n        instance.\n\n        Args:\n            language_code: str. ISO 639-1 language code.\n            contributor_user_id: str. User ID.\n            topic_id: str. Topic ID.\n\n        Returns:\n            str. An ID of the form:\n\n            [language_code].[contributor_user_id].[topic_id]\n        \"\"\"\n        return (\n            '%s.%s.%s' % (language_code, contributor_user_id, topic_id)\n        )\n\n    # Here we use MyPy ignore because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get( # type: ignore[override]\n        cls, language_code: str, contributor_user_id: str, topic_id: str\n    ) -> Optional[TranslationContributionStatsModel]:\n        \"\"\"Gets the TranslationContributionStatsModel matching the supplied\n        language_code, contributor_user_id, topic_id.\n\n        Returns:\n            TranslationContributionStatsModel|None. The matching\n            TranslationContributionStatsModel, or None if no such model\n            instance exists.\n        \"\"\"\n        entity_id = cls.construct_id(\n            language_code, contributor_user_id, topic_id)\n        return cls.get_by_id(entity_id)\n\n    @classmethod\n    def get_all_by_user_id(\n        cls, user_id: str\n    ) -> Sequence[TranslationContributionStatsModel]:\n        \"\"\"Gets all TranslationContributionStatsModels matching the supplied\n        user_id.\n\n        Returns:\n            list(TranslationContributionStatsModel). The matching\n            TranslationContributionStatsModels.\n        \"\"\"\n        return cls.get_all().filter(\n            cls.contributor_user_id == user_id\n        ).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether TranslationContributionStatsModel references the\n        supplied user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(\n            cls.contributor_user_id == user_id\n        ).get(keys_only=True) is not None\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model contains corresponding to a user: contributor_user_id.\"\"\"\n        return base_models.DELETION_POLICY.DELETE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple languages and topics relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'language_code':\n                base_models.EXPORT_POLICY.EXPORTED,\n            # User ID is not exported in order to keep internal ids private.\n            'contributor_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_without_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'contribution_dates':\n                base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def apply_deletion_policy(cls, user_id: str) -> None:\n        \"\"\"Delete instances of TranslationContributionStatsModel for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be deleted.\n        \"\"\"\n        datastore_services.delete_multi(\n            cls.query(cls.contributor_user_id == user_id).fetch(keys_only=True))\n\n    @classmethod\n    def export_data(\n        cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, List[str]]]]:\n        \"\"\"Exports the data from TranslationContributionStatsModel into dict\n        format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from TranslationContributionStatsModel.\n        \"\"\"\n        user_data = {}\n        stats_models: Sequence[TranslationContributionStatsModel] = (\n            cls.get_all().filter(cls.contributor_user_id == user_id).fetch())\n        for model in stats_models:\n            splitted_id = model.id.split('.')\n            id_without_user_id = '%s.%s' % (splitted_id[0], splitted_id[2])\n            user_data[id_without_user_id] = {\n                'language_code': model.language_code,\n                'topic_id': model.topic_id,\n                'submitted_translations_count': (\n                    model.submitted_translations_count),\n                'submitted_translation_word_count': (\n                    model.submitted_translation_word_count),\n                'accepted_translations_count': (\n                    model.accepted_translations_count),\n                'accepted_translations_without_reviewer_edits_count': (\n                    model.accepted_translations_without_reviewer_edits_count),\n                'accepted_translation_word_count': (\n                    model.accepted_translation_word_count),\n                'rejected_translations_count': (\n                    model.rejected_translations_count),\n                'rejected_translation_word_count': (\n                    model.rejected_translation_word_count),\n                'contribution_dates': [\n                    date.isoformat() for date in model.contribution_dates]\n            }\n        return user_data\n\n\nclass TranslationReviewStatsModel(base_models.BaseModel):\n    \"\"\"Records the translation review stats. There is one instance of this model\n    per (language_code, reviewer_user_id, topic_id) tuple. Its IDs are in the\n    following structure: [language_code].[reviewer_user_id].[topic_id]\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The ISO 639-1 language code for which the translation reviews were\n    # made.\n    language_code = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The user ID of the translation reviewer.\n    reviewer_user_id = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The topic ID of the translation reviews.\n    topic_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The number of reviewed translations.\n    reviewed_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The total word count of reviewed translations. Excludes HTML tags and\n    # attributes.\n    reviewed_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations.\n    accepted_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations with reviewer edits.\n    accepted_translations_with_reviewer_edits_count = (\n        datastore_services.IntegerProperty(required=True, indexed=True))\n    # The total word count of accepted translations. Excludes HTML tags and\n    # attributes.\n    accepted_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The first date that the reviewer made a translation review.\n    first_contribution_date = datastore_services.DateProperty(indexed=True)\n    # The last date that the reviewer made a translation review.\n    last_contribution_date = datastore_services.DateProperty(indexed=True)\n\n    @classmethod\n    def create(\n        cls,\n        language_code: str,\n        reviewer_user_id: str,\n        topic_id: str,\n        reviewed_translations_count: int,\n        reviewed_translation_word_count: int,\n        accepted_translations_count: int,\n        accepted_translations_with_reviewer_edits_count: int,\n        accepted_translation_word_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> str:\n        \"\"\"Creates a new TranslationReviewStatsModel instance and returns\n        its ID.\n        \"\"\"\n        entity_id = cls.construct_id(\n            language_code, reviewer_user_id, topic_id)\n        entity = cls(\n            id=entity_id,\n            language_code=language_code,\n            reviewer_user_id=reviewer_user_id,\n            topic_id=topic_id,\n            reviewed_translations_count=reviewed_translations_count,\n            reviewed_translation_word_count=reviewed_translation_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_with_reviewer_edits_count=(\n                accepted_translations_with_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            first_contribution_date=first_contribution_date,\n            last_contribution_date=last_contribution_date)\n        entity.update_timestamps()\n        entity.put()\n        return entity_id\n\n    @staticmethod\n    def construct_id(\n        language_code: str, reviewer_user_id: str, topic_id: str\n    ) -> str:\n        \"\"\"Constructs a unique ID for a TranslationReviewStatsModel\n        instance.\n\n        Args:\n            language_code: str. ISO 639-1 language code.\n            reviewer_user_id: str. User ID.\n            topic_id: str. Topic ID.\n\n        Returns:\n            str. An ID of the form:\n\n            [language_code].[reviewer_user_id].[topic_id]\n        \"\"\"\n        return (\n            '%s.%s.%s' % (language_code, reviewer_user_id, topic_id)\n        )\n\n    # Here we use MyPy ignore because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get( # type: ignore[override]\n        cls, language_code: str, reviewer_user_id: str, topic_id: str\n    ) -> Optional[TranslationReviewStatsModel]:\n        \"\"\"Gets the TranslationReviewStatsModel matching the supplied\n        language_code, reviewer_user_id, topic_id.\n\n        Returns:\n            TranslationReviewStatsModel|None. The matching\n            TranslationReviewStatsModel, or None if no such model\n            instance exists.\n        \"\"\"\n        entity_id = cls.construct_id(\n            language_code, reviewer_user_id, topic_id)\n        return cls.get_by_id(entity_id)\n\n    @classmethod\n    def get_all_by_user_id(\n        cls, user_id: str\n    ) -> Sequence[TranslationReviewStatsModel]:\n        \"\"\"Gets all TranslationReviewStatsModel matching the supplied\n        user_id.\n\n        Returns:\n            list(TranslationReviewStatsModel). The matching\n            TranslationReviewStatsModel.\n        \"\"\"\n        return cls.get_all().filter(\n            cls.reviewer_user_id == user_id\n        ).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether TranslationReviewStatsModel references the\n        supplied user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(\n            cls.reviewer_user_id == user_id\n        ).get(keys_only=True) is not None\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model contains corresponding to a user: reviewer_user_id.\"\"\"\n        return base_models.DELETION_POLICY.DELETE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple languages and topics relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'language_code':\n                base_models.EXPORT_POLICY.EXPORTED,\n            # User ID is not exported in order to keep internal ids private.\n            'reviewer_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_with_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def apply_deletion_policy(cls, user_id: str) -> None:\n        \"\"\"Delete instances of TranslationReviewStatsModel for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be deleted.\n        \"\"\"\n        datastore_services.delete_multi(\n            cls.query(cls.reviewer_user_id == user_id).fetch(keys_only=True))\n\n    @classmethod\n    def export_data(\n        cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, List[str]]]]:\n        \"\"\"Exports the data from TranslationReviewStatsModel into dict\n        format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from TranslationReviewStatsModel.\n        \"\"\"\n        user_data = {}\n        stats_models: Sequence[TranslationReviewStatsModel] = (\n            cls.get_all().filter(cls.reviewer_user_id == user_id).fetch())\n        for model in stats_models:\n            splitted_id = model.id.split('.')\n            id_without_user_id = '%s.%s' % (splitted_id[0], splitted_id[2])\n            user_data[id_without_user_id] = {\n                'language_code': model.language_code,\n                'topic_id': model.topic_id,\n                'reviewed_translations_count': (\n                    model.reviewed_translations_count),\n                'reviewed_translation_word_count': (\n                    model.reviewed_translation_word_count),\n                'accepted_translations_count': (\n                    model.accepted_translations_count),\n                'accepted_translations_with_reviewer_edits_count': (\n                    model.accepted_translations_with_reviewer_edits_count),\n                'accepted_translation_word_count': (\n                    model.accepted_translation_word_count),\n                'first_contribution_date': (\n                    model.first_contribution_date.isoformat()),\n                'last_contribution_date': (\n                    model.last_contribution_date.isoformat())\n            }\n        return user_data\n\n\nclass QuestionContributionStatsModel(base_models.BaseModel):\n    \"\"\"Records the question contribution stats. There is one instance of this\n    model per (contributor_user_id, topic_id) tuple. Its IDs are in the\n    following structure: [contributor_user_id].[topic_id]\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The user ID of the question contributor.\n    contributor_user_id = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The topic ID of the question contribution.\n    topic_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The number of submitted questions.\n    submitted_questions_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted questions.\n    accepted_questions_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted questions without reviewer edits.\n    accepted_questions_without_reviewer_edits_count = (\n        datastore_services.IntegerProperty(required=True, indexed=True))\n    # The first date that the submitter made a question submission.\n    first_contribution_date = datastore_services.DateProperty(indexed=True)\n    # The last date that the submitter made a question submission.\n    last_contribution_date = datastore_services.DateProperty(indexed=True)\n\n    @classmethod\n    def create(\n        cls,\n        contributor_user_id: str,\n        topic_id: str,\n        submitted_questions_count: int,\n        accepted_questions_count: int,\n        accepted_questions_without_reviewer_edits_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> str:\n        \"\"\"Creates a new QuestionContributionStatsModel instance and returns\n        its ID.\n        \"\"\"\n        entity_id = cls.construct_id(\n            contributor_user_id, topic_id)\n        entity = cls(\n            id=entity_id,\n            contributor_user_id=contributor_user_id,\n            topic_id=topic_id,\n            submitted_questions_count=submitted_questions_count,\n            accepted_questions_count=accepted_questions_count,\n            accepted_questions_without_reviewer_edits_count=(\n                accepted_questions_without_reviewer_edits_count),\n            first_contribution_date=first_contribution_date,\n            last_contribution_date=last_contribution_date)\n        entity.update_timestamps()\n        entity.put()\n        return entity_id\n\n    @staticmethod\n    def construct_id(\n        contributor_user_id: str, topic_id: str\n    ) -> str:\n        \"\"\"Constructs a unique ID for a QuestionContributionStatsModel\n        instance.\n\n        Args:\n            contributor_user_id: str. User ID.\n            topic_id: str. Topic ID.\n\n        Returns:\n            str. An ID of the form:\n\n            [contributor_user_id].[topic_id]\n        \"\"\"\n        return (\n            '%s.%s' % (contributor_user_id, topic_id)\n        )\n\n    # Here we use MyPy ignore because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get( # type: ignore[override]\n        cls, contributor_user_id: str, topic_id: str\n    ) -> Optional[QuestionContributionStatsModel]:\n        \"\"\"Gets the QuestionContributionStatsModel matching the supplied\n        contributor_user_id, topic_id.\n\n        Returns:\n            QuestionContributionStatsModel|None. The matching\n            QuestionContributionStatsModel, or None if no such model\n            instance exists.\n        \"\"\"\n        entity_id = cls.construct_id(\n            contributor_user_id, topic_id)\n        return cls.get_by_id(entity_id)\n\n    @classmethod\n    def get_all_by_user_id(\n        cls, user_id: str\n    ) -> Sequence[QuestionContributionStatsModel]:\n        \"\"\"Gets all QuestionContributionStatsModel matching the supplied\n        user_id.\n\n        Returns:\n            list(QuestionContributionStatsModel). The matching\n            QuestionContributionStatsModel.\n        \"\"\"\n        return cls.get_all().filter(\n            cls.contributor_user_id == user_id\n        ).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether QuestionContributionStatsModel references the\n        supplied user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(\n            cls.contributor_user_id == user_id\n        ).get(keys_only=True) is not None\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model contains corresponding to a user: contributor_user_id.\"\"\"\n        return base_models.DELETION_POLICY.DELETE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple languages and topics relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            # User ID is not exported in order to keep internal ids private.\n            'contributor_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_questions_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_without_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def apply_deletion_policy(cls, user_id: str) -> None:\n        \"\"\"Delete instances of QuestionContributionStatsModel for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be deleted.\n        \"\"\"\n        datastore_services.delete_multi(\n            cls.query(cls.contributor_user_id == user_id).fetch(keys_only=True))\n\n    @classmethod\n    def export_data(\n        cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, List[str]]]]:\n        \"\"\"Exports the data from QuestionContributionStatsModel into dict\n        format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from QuestionContributionStatsModel.\n        \"\"\"\n        user_data = {}\n        stats_models: Sequence[QuestionContributionStatsModel] = (\n            cls.get_all().filter(cls.contributor_user_id == user_id).fetch())\n        for model in stats_models:\n            splitted_id = model.id.split('.')\n            id_without_user_id = '%s' % (splitted_id[1])\n            user_data[id_without_user_id] = {\n                'topic_id': model.topic_id,\n                'submitted_questions_count': (\n                    model.submitted_questions_count),\n                'accepted_questions_count': (\n                    model.accepted_questions_count),\n                'accepted_questions_without_reviewer_edits_count': (\n                    model.accepted_questions_without_reviewer_edits_count),\n                'first_contribution_date': (\n                    model.first_contribution_date.isoformat()),\n                'last_contribution_date': (\n                    model.last_contribution_date.isoformat())\n            }\n        return user_data\n\n\nclass QuestionReviewStatsModel(base_models.BaseModel):\n    \"\"\"Records the question review stats. There is one instance of this model\n    per (reviewer_user_id, topic_id) tuple. Its IDs are in the following\n    structure: [reviewer_user_id].[topic_id]\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The user ID of the question reviewer.\n    reviewer_user_id = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The topic ID of the question.\n    topic_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The number of reviewed questions.\n    reviewed_questions_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted questions.\n    accepted_questions_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted questions with reviewer edits.\n    accepted_questions_with_reviewer_edits_count = (\n        datastore_services.IntegerProperty(required=True, indexed=True))\n    # The first date that the reviewer made a question review.\n    first_contribution_date = datastore_services.DateProperty(indexed=True)\n    # The last date that the reviewer made a question review.\n    last_contribution_date = datastore_services.DateProperty(indexed=True)\n\n    @classmethod\n    def create(\n        cls,\n        reviewer_user_id: str,\n        topic_id: str,\n        reviewed_questions_count: int,\n        accepted_questions_count: int,\n        accepted_questions_with_reviewer_edits_count: int,\n        first_contribution_date: datetime.date,\n        last_contribution_date: datetime.date\n    ) -> str:\n        \"\"\"Creates a new QuestionReviewStatsModel instance and returns\n        its ID.\n        \"\"\"\n        entity_id = cls.construct_id(\n            reviewer_user_id, topic_id)\n        entity = cls(\n            id=entity_id,\n            reviewer_user_id=reviewer_user_id,\n            topic_id=topic_id,\n            reviewed_questions_count=reviewed_questions_count,\n            accepted_questions_count=accepted_questions_count,\n            accepted_questions_with_reviewer_edits_count=(\n                accepted_questions_with_reviewer_edits_count),\n            first_contribution_date=first_contribution_date,\n            last_contribution_date=last_contribution_date)\n        entity.update_timestamps()\n        entity.put()\n        return entity_id\n\n    @staticmethod\n    def construct_id(\n        reviewer_user_id: str, topic_id: str\n    ) -> str:\n        \"\"\"Constructs a unique ID for a QuestionReviewStatsModel\n        instance.\n\n        Args:\n            reviewer_user_id: str. User ID.\n            topic_id: str. Topic ID.\n\n        Returns:\n            str. An ID of the form:\n\n            [reviewer_user_id].[topic_id]\n        \"\"\"\n        return (\n            '%s.%s' % (reviewer_user_id, topic_id)\n        )\n\n    # Here we use MyPy ignore because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get( # type: ignore[override]\n        cls, reviewer_user_id: str, topic_id: str\n    ) -> Optional[QuestionReviewStatsModel]:\n        \"\"\"Gets the QuestionReviewStatsModel matching the supplied\n        reviewer_user_id, topic_id.\n\n        Returns:\n            QuestionReviewStatsModel|None. The matching\n            QuestionReviewStatsModel, or None if no such model\n            instance exists.\n        \"\"\"\n        entity_id = cls.construct_id(\n            reviewer_user_id, topic_id)\n        return cls.get_by_id(entity_id)\n\n    @classmethod\n    def get_all_by_user_id(\n        cls, user_id: str\n    ) -> Sequence[QuestionReviewStatsModel]:\n        \"\"\"Gets all QuestionReviewStatsModel matching the supplied\n        user_id.\n\n        Returns:\n            list(QuestionReviewStatsModel). The matching\n            QuestionReviewStatsModel.\n        \"\"\"\n        return cls.get_all().filter(\n            cls.reviewer_user_id == user_id\n        ).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether QuestionReviewStatsModel references the\n        supplied user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(\n            cls.reviewer_user_id == user_id\n        ).get(keys_only=True) is not None\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model contains corresponding to a user: reviewer_user_id.\"\"\"\n        return base_models.DELETION_POLICY.DELETE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple languages and topics relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            # User ID is not exported in order to keep internal ids private.\n            'reviewer_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_questions_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_with_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date':\n                base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def apply_deletion_policy(cls, user_id: str) -> None:\n        \"\"\"Delete instances of QuestionReviewStatsModel for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be deleted.\n        \"\"\"\n        datastore_services.delete_multi(\n            cls.query(cls.reviewer_user_id == user_id).fetch(keys_only=True))\n\n    @classmethod\n    def export_data(\n        cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, List[str]]]]:\n        \"\"\"Exports the data from QuestionReviewStatsModel into dict\n        format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from QuestionReviewStatsModel.\n        \"\"\"\n        user_data = {}\n        stats_models: Sequence[QuestionReviewStatsModel] = (\n            cls.get_all().filter(cls.reviewer_user_id == user_id).fetch())\n        for model in stats_models:\n            splitted_id = model.id.split('.')\n            id_without_user_id = '%s' % (splitted_id[1])\n            user_data[id_without_user_id] = {\n                'topic_id': model.topic_id,\n                'reviewed_questions_count': (\n                    model.reviewed_questions_count),\n                'accepted_questions_count': (\n                    model.accepted_questions_count),\n                'accepted_questions_with_reviewer_edits_count': (\n                    model.accepted_questions_with_reviewer_edits_count),\n                'first_contribution_date': (\n                    model.first_contribution_date.isoformat()),\n                'last_contribution_date': (\n                    model.last_contribution_date.isoformat())\n            }\n        return user_data\n"
    },
    {
      "filename": "core/storage/suggestion/gae_models_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the suggestion gae_models.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.platform import models\nfrom core.tests import test_utils\n\nfrom typing import Dict, Final, Mapping\n\nMYPY = False\nif MYPY: # pragma: no cover\n    # Here, change domain is imported only for type checking.\n    from core.domain import change_domain  # pylint: disable=invalid-import # isort:skip\n    from mypy_imports import base_models\n    from mypy_imports import suggestion_models\n\n(base_models, suggestion_models, user_models) = models.Registry.import_models([\n    models.Names.BASE_MODEL, models.Names.SUGGESTION, models.Names.USER\n])\n\n\nclass SuggestionModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the suggestionModel class.\"\"\"\n\n    score_category: str = (\n        suggestion_models.SCORE_TYPE_TRANSLATION +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n\n    topic_name = 'topic'\n    target_id = 'exp1'\n    target_version_at_submission = 1\n    change_cmd: Mapping[\n        str, change_domain.AcceptableChangeDictTypes\n    ] = {}\n    # Language code that would normally be derived from the change_cmd.\n    translation_language_code = 'en'\n    # Language code that would normally be derived from the question_dict in\n    # the change_cmd.\n    question_language_code = 'en'\n    mocked_datetime_utcnow = datetime.datetime(2020, 6, 15, 5)\n\n    def setUp(self) -> None:\n        super().setUp()\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_1',\n            'reviewer_1', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_1', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_2',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_2', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_2',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_3', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_2',\n            'reviewer_3', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_4', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_5', None)\n\n    def test_get_all_in_review_translation_suggestions_by_exp_ids(\n            self) -> None:\n        model = suggestion_models.GeneralSuggestionModel\n        self.assertEqual(\n            model.get_in_review_translation_suggestions_by_exp_ids(\n                [self.target_id], 'en'),\n            []\n        )\n        suggestion_id = 'exploration.exp1.thread_6'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_1',\n            'reviewer_3', self.change_cmd, self.score_category,\n            suggestion_id, 'en')\n\n        created_suggestion_model = model.get_by_id(suggestion_id)\n        self.assertEqual(\n            model.get_in_review_translation_suggestions_by_exp_ids(\n                [self.target_id], 'en'),\n            [created_suggestion_model]\n        )\n\n    def test_get_all_user_created_suggestions_of_given_suggestion_type(\n            self) -> None:\n        model = suggestion_models.GeneralSuggestionModel\n        expected_suggestion_model = model.get_by_id(\n            'exploration.exp1.thread_1')\n        self.assertEqual(\n            model.get_user_created_suggestions_of_suggestion_type(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT, 'author_1'),\n            [expected_suggestion_model]\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            suggestion_models.GeneralSuggestionModel.get_deletion_policy(),\n            base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE)\n\n    def test_has_reference_to_user_id(self) -> None:\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_1')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_2')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_3')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_1')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_2')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_3')\n        )\n        self.assertFalse(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('id_x')\n        )\n\n    def test_score_type_contains_delimiter(self) -> None:\n        for score_type in suggestion_models.SCORE_TYPE_CHOICES:\n            self.assertTrue(\n                suggestion_models.SCORE_CATEGORY_DELIMITER not in score_type)\n\n    def test_get_translation_suggestions_submitted_for_given_date_range(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'test_author',\n            'reviewer_1', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', 'hi')\n        to_date = datetime.datetime.now()\n        from_date = to_date - datetime.timedelta(days=1)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n                .get_translation_suggestions_submitted_within_given_dates(\n                    from_date, to_date, 'test_author', 'hi'))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_question_suggestions_submitted_for_given_date_range(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'test_author',\n            'reviewer_1', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', 'hi')\n        to_date = datetime.datetime.now()\n        from_date = to_date - datetime.timedelta(days=1)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n                .get_question_suggestions_submitted_within_given_dates(\n                    from_date, to_date, 'test_author'))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_create_new_object_succesfully(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_3', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', None)\n\n        suggestion_id = 'exploration.exp1.thread_6'\n\n        observed_suggestion_model = (\n            suggestion_models.GeneralSuggestionModel.get_by_id(suggestion_id))\n\n        self.assertEqual(\n            observed_suggestion_model.suggestion_type,\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.assertEqual(\n            observed_suggestion_model.target_type,\n            feconf.ENTITY_TYPE_EXPLORATION)\n        self.assertEqual(\n            observed_suggestion_model.target_id, self.target_id)\n        self.assertEqual(\n            observed_suggestion_model.target_version_at_submission,\n            self.target_version_at_submission)\n        self.assertEqual(\n            observed_suggestion_model.status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(observed_suggestion_model.author_id, 'author_3')\n        self.assertEqual(\n            observed_suggestion_model.final_reviewer_id, 'reviewer_3')\n        self.assertEqual(\n            observed_suggestion_model.score_category, self.score_category)\n        self.assertEqual(observed_suggestion_model.change_cmd, self.change_cmd)\n\n    def test_create_suggestion_fails_if_id_collides_with_existing_one(\n        self\n    ) -> None:\n        with self.assertRaisesRegex(\n            Exception, 'There is already a suggestion with the given id: '\n                       'exploration.exp1.thread_1'):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_3', self.change_cmd,\n                self.score_category, 'exploration.exp1.thread_1', None)\n\n    def test_get_suggestions_by_type(self) -> None:\n        queries = [(\n            'suggestion_type',\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n        queries = [('suggestion_type', 'invalid_suggestion_type')]\n\n        with self.assertRaisesRegex(\n            Exception, 'Value \\'invalid_suggestion_type\\' for property'\n                       ' suggestion_type is not an allowed choice'):\n            suggestion_models.GeneralSuggestionModel.query_suggestions(queries)\n\n    def test_get_suggestion_by_author(self) -> None:\n        queries = [('author_id', 'author_1')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('author_id', 'author_2')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n        queries = [('author_id', 'author_3')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('author_id', 'author_invalid')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_get_suggestion_by_reviewer(self) -> None:\n        queries = [('final_reviewer_id', 'reviewer_1')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('final_reviewer_id', 'reviewer_2')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n        queries = [('final_reviewer_id', 'reviewer_3')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('final_reviewer_id', 'reviewer_invalid')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_get_suggestions_by_status(self) -> None:\n        queries = [('status', suggestion_models.STATUS_IN_REVIEW)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('status', suggestion_models.STATUS_REJECTED)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n        queries = [('status', suggestion_models.STATUS_ACCEPTED)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n\n    def test_get_suggestions_by_target_id(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', 'exp_invalid')\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_query_suggestions(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('author_id', 'author_2')\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('author_id', 'author_2'),\n            ('status', suggestion_models.STATUS_ACCEPTED)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('invalid_field', 'value')\n        ]\n        with self.assertRaisesRegex(\n            Exception, 'Not allowed to query on field invalid_field'):\n            suggestion_models.GeneralSuggestionModel.query_suggestions(queries)\n\n        queries = [\n            (\n                'suggestion_type',\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT),\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('status', suggestion_models.STATUS_IN_REVIEW),\n            ('author_id', 'author_1'),\n            ('final_reviewer_id', 'reviewer_1'),\n            ('score_category', self.score_category)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n\n    def test_query_suggestions_by_language(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n\n        queries = [('language_code', self.translation_language_code)]\n\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n\n    def test_get_in_review_translation_suggestions(self) -> None:\n        # Create two in-review translation suggestions.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n        # Create accepted and rejected suggestions that should not be returned.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_8', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_9', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions(\n                'exp1', [self.translation_language_code]))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, 'exp1')\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, 'exp1')\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_with_valid_exp(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, 'exp1')\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, 'exp1')\n\n    def test_get_translation_suggestions_in_review_with_exp_ids_by_offset(\n        self\n    ) -> None:\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions, offset_1 = (\n            suggestion_models\n                .GeneralSuggestionModel\n                .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                    limit, 0, 'author_4', None,\n                    [self.translation_language_code], ['exp1']))\n\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(suggestions[0].target_id, 'exp1')\n        self.assertEqual(offset_1, 1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_with_exp_ids_by_offset_sorted( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        suggestion_1_id = 'exploration.exp1.thread_6'\n        suggestion_2_id = 'exploration.exp1.thread_7'\n        suggestion_3_id = 'exploration.exp1.thread_8'\n        user_id = 'author1'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_1_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_2_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_3_id, self.translation_language_code)\n\n        sorted_results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit=1,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code],\n                exp_ids=['exp1']))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 1)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(offset_1, 2)\n\n        sorted_results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit=2,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code],\n                exp_ids=['exp1']))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_2, 3)\n\n        sorted_results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit=10,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code],\n                exp_ids=['exp1']))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_3, 3)\n\n        sorted_results, offset_4 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit=None,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code],\n                exp_ids=['exp1']))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_4, 3)\n\n    def test_get_in_review_translation_suggestions_by_offset(self) -> None:\n        suggestion_1_id = 'exploration.exp1.thread_6'\n        suggestion_2_id = 'exploration.exp1.thread_7'\n        user_id = 'author1'\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_1_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_2_id, self.translation_language_code)\n\n        results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                user_id=user_id,\n                sort_key=None,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_1_id)\n        self.assertEqual(offset_1, 1)\n\n        results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=offset_1,\n                user_id=user_id,\n                sort_key=None,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_2_id)\n        self.assertEqual(offset_2, 2)\n\n        results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=offset_2,\n                user_id=user_id,\n                sort_key=None,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), 0)\n        self.assertEqual(offset_3, 2)\n\n    def test_get_in_review_translation_suggestions_by_offset_no_limit(\n        self\n    ) -> None:\n        suggestion_1_id = 'exploration.exp1.thread_6'\n        suggestion_2_id = 'exploration.exp1.thread_7'\n        user_id = 'author1'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_1_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_2_id, self.translation_language_code)\n\n        results, offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=None,\n                offset=0,\n                user_id=user_id,\n                sort_key=None,\n                language_codes=[self.translation_language_code]))\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), 2)\n        self.assertEqual(results[0].id, suggestion_1_id)\n        self.assertEqual(results[1].id, suggestion_2_id)\n        self.assertEqual(offset, 2)\n\n    def test_get_in_review_translation_suggestions_by_offset_sorted(\n        self\n    ) -> None:\n        suggestion_1_id = 'exploration.exp1.thread_6'\n        suggestion_2_id = 'exploration.exp1.thread_7'\n        suggestion_3_id = 'exploration.exp1.thread_8'\n        user_id = 'author1'\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_1_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_2_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_3_id, self.translation_language_code)\n\n        sorted_results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=1,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 1)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(offset_1, 2)\n\n        sorted_results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=2,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_2, 3)\n\n        sorted_results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=10,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_3, 3)\n\n        sorted_results, offset_4 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=None,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_4, 3)\n\n    def test_get_in_review_question_suggestions_by_offset(self) -> None:\n        suggestion_1_id = 'skill1.thread1'\n        suggestion_2_id = 'skill1.thread2'\n        suggestion_3_id = 'skill2.thread3'\n        user_id = 'author1'\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            suggestion_1_id, self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, 'category1',\n            suggestion_2_id, self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author1',\n            'reviewer_2', self.change_cmd, 'category1',\n            suggestion_3_id, self.question_language_code)\n\n        results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                user_id=user_id,\n                sort_key=None))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_1_id)\n        self.assertEqual(offset_1, 1)\n\n        results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=offset_1,\n                user_id=user_id,\n                sort_key=None))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_2_id)\n        self.assertEqual(offset_2, 2)\n\n        results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=offset_2,\n                user_id=user_id,\n                sort_key=None))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), 0)\n        self.assertEqual(offset_3, 2)\n\n        sorted_results, offset_4 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=1,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 1)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(offset_4, 2)\n\n        sorted_results, offset_5 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=2,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_5, 3)\n\n        sorted_results, offset_6 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=10,\n                offset=0,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n        # Ruling out the possibility of None for mypy type checking.\n        assert sorted_results is not None\n        self.assertEqual(len(sorted_results), 2)\n        self.assertEqual(sorted_results[0].id, suggestion_2_id)\n        self.assertEqual(sorted_results[1].id, suggestion_1_id)\n        self.assertEqual(offset_6, 3)\n\n    def test_user_created_suggestions_by_offset(self) -> None:\n        authored_translation_suggestion_id = 'exploration.exp1.thread_6'\n        non_authored_translation_suggestion_id = 'exploration.exp1.thread_7'\n        authored_question_suggestion_id = 'skill1.thread1'\n        user_id = 'author1'\n        limit = 1\n        # User created translation suggestion.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, self.score_category,\n            authored_translation_suggestion_id, self.translation_language_code)\n        # Translation suggestion created by a different user.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            non_authored_translation_suggestion_id,\n            self.translation_language_code)\n        # User created question suggestion.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, 'category1',\n            authored_question_suggestion_id, self.question_language_code)\n\n        results, translation_suggestion_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                suggestion_type=feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                user_id=user_id,\n                sort_key=constants.SUGGESTIONS_SORT_KEY_DATE))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, authored_translation_suggestion_id)\n        self.assertEqual(translation_suggestion_offset, 1)\n\n        results, question_suggestion_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                suggestion_type=feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                user_id=user_id,\n                sort_key=None))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, authored_question_suggestion_id)\n        self.assertEqual(question_suggestion_offset, 1)\n\n    def test_get_translation_suggestions_in_review_with_exp_id_with_invalid_exp(\n            self\n    ) -> None:\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'invalid_exp', 'hi'))\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_one_exp(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n\n        # Assert that there is one translation suggestion with the given\n        # exploration id found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['exp1'])), 1)\n\n    def test_get_exp_translation_suggestions_in_review_returns_limited_values(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        with self.swap(feconf, 'DEFAULT_SUGGESTION_QUERY_LIMIT', 1):\n            suggestions = (\n                suggestion_models.GeneralSuggestionModel\n                .get_translation_suggestions_in_review_with_exp_id(\n                    'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_exp_translation_suggestions_in_review_for_resolved_suggestion_returns_no_items( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_exp_translation_suggestions_in_review_for_non_translation_suggestion_returns_no_items( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_exp_translation_suggestions_in_review_for_different_language_code_returns_no_items( # pylint: disable=line-too-long\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', 'hi')\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id('exp1', 'pt'))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_multiple_exps(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_8', self.translation_language_code)\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['exp2', 'exp3'])), 2)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_invalid_exp(\n        self\n    ) -> None:\n        # Assert that there are no translation suggestions with an invalid\n        # exploration id found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['invalid_exp'])), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_past_default_query(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp4', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_9', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp5', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_10', self.translation_language_code)\n\n        with self.swap(feconf, 'DEFAULT_SUGGESTION_QUERY_LIMIT', 1):\n            suggestion_model_results = (\n                suggestion_models\n                .GeneralSuggestionModel\n                .get_translation_suggestion_ids_with_exp_ids(\n                    ['exp4', 'exp5'])\n            )\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found. There should be two fetch_page calls.\n        self.assertEqual(len(suggestion_model_results), 2)\n\n    def test_get_all_stale_suggestion_ids(self) -> None:\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS', 0):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_all_stale_suggestion_ids()), 1)\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS',\n            7 * 24 * 60 * 60 * 1000):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_all_stale_suggestion_ids()), 0)\n\n    def test_get__suggestions_waiting_too_long_raises_if_suggestion_types_empty(\n        self\n    ) -> None:\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES', []):\n            with self.assertRaisesRegex(\n                Exception,\n                'Expected the suggestion types offered on the Contributor '\n                'Dashboard to be nonempty.'):\n                (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n    def test_get_suggestions_waiting_too_long_if_not_contributor_suggestion(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', None)\n        # This mocked list cannot be empty because then the query will fail.\n        mocked_contributor_dashboard_suggestion_types = [\n            feconf.SUGGESTION_TYPE_ADD_QUESTION]\n\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES',\n            mocked_contributor_dashboard_suggestion_types):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_returns_empty_if_neg_timedelta(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n\n        # Make sure the threshold is nonzero.\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 1):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestions_waited_less_limit(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_less_than_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=1))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_less_than_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestion_waited_limit(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_eq_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(\n                days=mocked_threshold_review_wait_time_in_days))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_eq_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestion_waited_past_limit(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 1)\n\n    def test_get_suggestions_waiting_too_long_with_diff_review_wait_times(\n        self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2)):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                feconf.ENTITY_TYPE_SKILL,\n                'skill_1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, 'category1',\n                'skill1.thread1', self.question_language_code)\n        mocked_threshold_review_wait_time_in_days = 3\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=4))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review())\n\n        # The question suggestion was created 2 days after the translation\n        # suggestion, so it has only waited 1 day for a review, which is less\n        # than 3, the mocked review wait time threshold. Therefore, only the\n        # translation suggestion has waited too long for a review.\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 1)\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[0].id,\n            'exploration.exp1.thread1')\n\n    def test_get_suggestions_waiting_too_long_returns_in_correct_wait_order(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', 'fr')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', 'en')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp3.thread1', 'hi')\n\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[0].id,\n            'exploration.exp1.thread1')\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[1].id,\n            'exploration.exp2.thread1')\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[2].id,\n            'exploration.exp3.thread1')\n\n    def test_get_in_review_suggestions_in_score_categories(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_6', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_2',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_7', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_2',\n            'reviewer_2', self.change_cmd, 'category3',\n            'exploration.exp1.thread_8', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_2',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_9', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_10', None)\n\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1'], 'author_3')), 0)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1'], 'author_2')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category2'], 'author_2')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category2'], 'author_3')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category2', 'category3'], 'author_1')), 4)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category_invalid'], 'author_2')), 1)\n        with self.assertRaisesRegex(\n            Exception, 'Received empty list of score categories'):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_in_review_suggestions_in_score_categories(\n                    [], 'author_1')), 0)\n\n    def test_get_all_score_categories(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_11', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_12', None)\n        score_categories = (\n            suggestion_models.GeneralSuggestionModel.get_all_score_categories())\n        self.assertIn(self.score_category, score_categories)\n        self.assertIn('category1', score_categories)\n        self.assertIn('category2', score_categories)\n\n    def test_get_question_suggestions_waiting_longest_for_review(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'skill1.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill2.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill3.thread1', self.question_language_code)\n\n        question_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n\n        self.assertEqual(len(question_suggestion_models), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(question_suggestion_models[0].id, 'skill1.thread1')\n        self.assertEqual(question_suggestion_models[1].id, 'skill2.thread1')\n        self.assertEqual(question_suggestion_models[2].id, 'skill3.thread1')\n\n    def test_get_translation_suggestions_waiting_longest_for_review_per_lang(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp3.thread1', self.translation_language_code)\n        # Create a translation suggestion that has a different language code.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp4', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp4.thread1', 'fr')\n\n        translation_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                self.translation_language_code\n            )\n        )\n\n        self.assertEqual(len(translation_suggestion_models), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(\n            translation_suggestion_models[0].id, 'exploration.exp1.thread1')\n        self.assertEqual(\n            translation_suggestion_models[1].id, 'exploration.exp2.thread1')\n        self.assertEqual(\n            translation_suggestion_models[2].id, 'exploration.exp3.thread1')\n\n        translation_suggestion_models_with_different_lang_code = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                'fr'\n            )\n        )\n\n        self.assertEqual(len(\n            translation_suggestion_models_with_different_lang_code), 1)\n        self.assertEqual(\n            translation_suggestion_models_with_different_lang_code[0].id,\n            'exploration.exp4.thread1')\n\n    def test_get_translation_suggestions_waiting_longest_for_review_wrong_lang(\n        self\n    ) -> None:\n        translation_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                'wrong_language_code'\n            )\n        )\n\n        self.assertEqual(len(translation_suggestion_models), 0)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_max_fetch(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', self.translation_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS', 1):\n            translation_suggestion_models = (\n                suggestion_models.GeneralSuggestionModel.\n                get_translation_suggestions_waiting_longest_for_review(\n                    self.translation_language_code)\n            )\n\n        # There should only be one translation suggestion returned since we\n        # changed the maximum translations to fetch to 1.\n        self.assertEqual(len(translation_suggestion_models), 1)\n        self.assertEqual(\n            translation_suggestion_models[0].id, 'exploration.exp1.thread1')\n\n    def test_get_question_suggestions_waiting_longest_for_review_max_fetch(\n        self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'skill1.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill2.thread1', self.question_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS', 1):\n            question_suggestion_models = (\n                suggestion_models.GeneralSuggestionModel\n                .get_question_suggestions_waiting_longest_for_review()\n            )\n\n        # There should only be one question suggestion returned since we\n        # changed the maximum questions to fetch to 1.\n        self.assertEqual(len(question_suggestion_models), 1)\n        self.assertEqual(question_suggestion_models[0].id, 'skill1.thread1')\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.GeneralSuggestionModel\n            .export_data('non_existent_user'))\n        test_data: Dict[str, str] = {}\n        self.assertEqual(user_data, test_data)\n\n    def test_export_data_nontrivial(self) -> None:\n        test_export_suggestion_type = (\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        test_export_target_type = feconf.ENTITY_TYPE_EXPLORATION\n        test_export_target_id = self.target_id\n        test_export_target_version = self.target_version_at_submission\n        test_export_status = suggestion_models.STATUS_IN_REVIEW\n        test_export_author = 'test_export_author'\n        test_export_reviewer = 'test_export_reveiwer'\n        test_export_change_cmd = self.change_cmd\n        test_export_score_category = 'category1'\n        test_export_thread_id = 'exploration.exp1.thread_export'\n        test_export_language_code = 'en'\n        test_export_edited_by_reviewer = False\n\n        suggestion_models.GeneralSuggestionModel.create(\n            test_export_suggestion_type,\n            test_export_target_type,\n            test_export_target_id,\n            test_export_target_version,\n            test_export_status,\n            test_export_author,\n            test_export_reviewer,\n            test_export_change_cmd,\n            test_export_score_category,\n            test_export_thread_id,\n            test_export_language_code\n        )\n\n        user_data = (\n            suggestion_models.GeneralSuggestionModel\n            .export_data('test_export_author'))\n\n        test_data = {\n            test_export_thread_id: {\n                'suggestion_type': test_export_suggestion_type,\n                'target_type': test_export_target_type,\n                'target_id': test_export_target_id,\n                'target_version_at_submission': test_export_target_version,\n                'status': test_export_status,\n                'change_cmd': test_export_change_cmd,\n                'language_code': test_export_language_code,\n                'edited_by_reviewer': test_export_edited_by_reviewer\n            },\n\n        }\n\n        self.assertEqual(user_data, test_data)\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'suggestion_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_id': base_models.EXPORT_POLICY.EXPORTED,\n            'target_version_at_submission':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'status': base_models.EXPORT_POLICY.EXPORTED,\n            'author_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'final_reviewer_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'change_cmd': base_models.EXPORT_POLICY.EXPORTED,\n            'score_category': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'edited_by_reviewer': base_models.EXPORT_POLICY.EXPORTED\n        }\n        model = suggestion_models.GeneralSuggestionModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.GeneralSuggestionModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER)\n\n\nclass CommunityContributionStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the CommunityContributionStatsModel class.\"\"\"\n\n    translation_reviewer_counts_by_lang_code: Dict[str, int] = {\n        'hi': 0,\n        'en': 1\n    }\n\n    translation_suggestion_counts_by_lang_code: Dict[str, int] = {\n        'fr': 6,\n        'en': 5\n    }\n\n    question_reviewer_count: int = 1\n    question_suggestion_count: int = 4\n\n    def test_get_returns_community_contribution_stats_model_when_it_exists(\n        self\n    ) -> None:\n        suggestion_models.CommunityContributionStatsModel(\n            id=suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID,\n            translation_reviewer_counts_by_lang_code=(\n                self.translation_reviewer_counts_by_lang_code),\n            translation_suggestion_counts_by_lang_code=(\n                self.translation_suggestion_counts_by_lang_code),\n            question_reviewer_count=self.question_reviewer_count,\n            question_suggestion_count=self.question_suggestion_count\n        ).put()\n\n        community_contribution_stats_model = (\n            suggestion_models.CommunityContributionStatsModel.get()\n        )\n\n        self.assertEqual(\n            community_contribution_stats_model.id,\n            suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_reviewer_counts_by_lang_code\n            ),\n            self.translation_reviewer_counts_by_lang_code\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_suggestion_counts_by_lang_code\n            ),\n            self.translation_suggestion_counts_by_lang_code\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_reviewer_count,\n            self.question_reviewer_count\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_suggestion_count,\n            self.question_suggestion_count\n        )\n\n    def test_get_returns_new_community_contribution_stats_model_if_not_found(\n        self\n    ) -> None:\n        \"\"\"If the model has not been created yet, get should create the model\n        with default values.\n        \"\"\"\n        community_contribution_stats_model = (\n            suggestion_models.CommunityContributionStatsModel.get()\n        )\n        self.assertEqual(\n            community_contribution_stats_model.id,\n            suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_reviewer_counts_by_lang_code\n            ), {}\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_suggestion_counts_by_lang_code\n            ), {}\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_reviewer_count, 0\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_suggestion_count, 0\n        )\n\n    def test_get_deletion_policy_returns_not_applicable(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.CommunityContributionStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.NOT_APPLICABLE\n        )\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'translation_reviewer_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'translation_suggestion_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_reviewer_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_suggestion_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE\n        }\n        model = suggestion_models.CommunityContributionStatsModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.CommunityContributionStatsModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER)\n\n\nclass TranslationContributionStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the TranslationContributionStatsModel class.\"\"\"\n\n    LANGUAGE_CODE: Final = 'es'\n    CONTRIBUTOR_USER_ID: Final = 'uid_01234567890123456789012345678912'\n    TOPIC_ID: Final = 'topic_id'\n    SUBMITTED_TRANSLATIONS_COUNT: Final = 2\n    SUBMITTED_TRANSLATION_WORD_COUNT: Final = 100\n    ACCEPTED_TRANSLATIONS_COUNT: Final = 1\n    ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT: Final = 0\n    ACCEPTED_TRANSLATION_WORD_COUNT: Final = 50\n    REJECTED_TRANSLATIONS_COUNT: Final = 0\n    REJECTED_TRANSLATION_WORD_COUNT: Final = 0\n    # Timestamp dates in sec since epoch for Mar 19 2021 UTC.\n    CONTRIBUTION_DATES: Final = [\n        datetime.date.fromtimestamp(1616173836),\n        datetime.date.fromtimestamp(1616173837)\n    ]\n\n    def test_get_all_model_instances_matching_the_given_user_id(self) -> None:\n        model = suggestion_models.TranslationContributionStatsModel\n        self.assertEqual(\n            model.get_all_by_user_id(self.CONTRIBUTOR_USER_ID), [])\n\n        model.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        translation_contribution_stats_model = (\n            model.get(\n                self.LANGUAGE_CODE, self.CONTRIBUTOR_USER_ID, self.TOPIC_ID\n            )\n        )\n        self.assertEqual(\n            model.get_all_by_user_id(self.CONTRIBUTOR_USER_ID),\n            [translation_contribution_stats_model]\n        )\n\n    def test_get_returns_model_when_it_exists(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                self.LANGUAGE_CODE, self.CONTRIBUTOR_USER_ID, self.TOPIC_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.language_code,\n            self.LANGUAGE_CODE\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.contributor_user_id,\n            self.CONTRIBUTOR_USER_ID\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            self.SUBMITTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            self.SUBMITTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            self.ACCEPTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translations_without_reviewer_edits_count\n            ),\n            self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translation_word_count\n            ),\n            self.ACCEPTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.rejected_translations_count,\n            self.REJECTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .rejected_translation_word_count\n            ),\n            self.REJECTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.contribution_dates,\n            self.CONTRIBUTION_DATES\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.TranslationContributionStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.DELETE)\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'contributor_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id': base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_without_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'contribution_dates': base_models.EXPORT_POLICY.EXPORTED\n        }\n        model = suggestion_models.TranslationContributionStatsModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.TranslationContributionStatsModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER)\n\n    def test_apply_deletion_policy(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        self.assertTrue(\n            suggestion_models.TranslationContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n        (\n            suggestion_models.TranslationContributionStatsModel\n            .apply_deletion_policy(self.CONTRIBUTOR_USER_ID)\n        )\n\n        self.assertFalse(\n            suggestion_models.TranslationContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.TranslationContributionStatsModel\n            .export_data('non_existent_user'))\n        self.assertEqual(user_data, {})\n\n    def test_export_data_nontrivial(self) -> None:\n        topic_id_2 = 'topic ID 2'\n        # Seed translation stats data for two different topics.\n        model_1_id = suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        model_2_id = suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=topic_id_2,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        dates_in_iso_format = [\n            date.isoformat() for date in self.CONTRIBUTION_DATES]\n        model_1_id_without_user_id = model_1_id.replace(\n            '.%s.' % self.CONTRIBUTOR_USER_ID, '.'\n        )\n        model_2_id_without_user_id = model_2_id.replace(\n            '.%s.' % self.CONTRIBUTOR_USER_ID, '.'\n        )\n        expected_data = {\n            model_1_id_without_user_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': self.TOPIC_ID,\n                'submitted_translations_count': (\n                    self.SUBMITTED_TRANSLATIONS_COUNT),\n                'submitted_translation_word_count': (\n                    self.SUBMITTED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_without_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'rejected_translations_count': (\n                    self.REJECTED_TRANSLATIONS_COUNT),\n                'rejected_translation_word_count': (\n                    self.REJECTED_TRANSLATION_WORD_COUNT),\n                'contribution_dates': dates_in_iso_format\n            },\n            model_2_id_without_user_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': topic_id_2,\n                'submitted_translations_count': (\n                    self.SUBMITTED_TRANSLATIONS_COUNT),\n                'submitted_translation_word_count': (\n                    self.SUBMITTED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_without_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'rejected_translations_count': (\n                    self.REJECTED_TRANSLATIONS_COUNT),\n                'rejected_translation_word_count': (\n                    self.REJECTED_TRANSLATION_WORD_COUNT),\n                'contribution_dates': dates_in_iso_format\n            }\n        }\n\n        user_data = (\n            suggestion_models.TranslationContributionStatsModel\n            .export_data(self.CONTRIBUTOR_USER_ID))\n\n        self.assertEqual(expected_data, user_data)\n\n\nclass TranslationReviewStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the TranslationContributionStatsModel class.\"\"\"\n\n    LANGUAGE_CODE = 'es'\n    REVIEWER_USER_ID = 'uid_01234567890123456789012345678912'\n    TOPIC_ID = 'topic_id'\n    REVIEWED_TRANSLATIONS_COUNT = 2\n    REVIEWED_TRANSLATION_WORD_COUNT = 100\n    ACCEPTED_TRANSLATIONS_COUNT = 1\n    ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT = 0\n    ACCEPTED_TRANSLATION_WORD_COUNT = 50\n    FIRST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n    LAST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n\n    def test_get_returns_model_when_it_exists(self) -> None:\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_translations_count=self.REVIEWED_TRANSLATIONS_COUNT,\n            reviewed_translation_word_count=(\n                self.REVIEWED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_with_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        translation_review_stats_model = (\n            suggestion_models.TranslationReviewStatsModel.get(\n                self.LANGUAGE_CODE, self.REVIEWER_USER_ID, self.TOPIC_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert translation_review_stats_model is not None\n        self.assertEqual(\n            translation_review_stats_model.language_code,\n            self.LANGUAGE_CODE\n        )\n        self.assertEqual(\n            translation_review_stats_model.reviewer_user_id,\n            self.REVIEWER_USER_ID\n        )\n        self.assertEqual(\n            translation_review_stats_model.reviewed_translations_count,\n            self.REVIEWED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            self.REVIEWED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            self.ACCEPTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .accepted_translations_with_reviewer_edits_count\n            ),\n            self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .accepted_translation_word_count\n            ),\n            self.ACCEPTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_review_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            translation_review_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.TranslationReviewStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.DELETE)\n\n    def test_get_all_by_user_id(self) -> None:\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_translations_count=self.REVIEWED_TRANSLATIONS_COUNT,\n            reviewed_translation_word_count=(\n                self.REVIEWED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_with_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        translation_review_stats_models = (\n            suggestion_models.TranslationReviewStatsModel.get_all_by_user_id(\n                self.REVIEWER_USER_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert translation_review_stats_models is not None\n\n        self.assertEqual(\n            len(translation_review_stats_models),\n            1\n        )\n\n        translation_review_stats_model = translation_review_stats_models[0]\n\n        self.assertEqual(\n            translation_review_stats_model.language_code,\n            self.LANGUAGE_CODE\n        )\n        self.assertEqual(\n            translation_review_stats_model.reviewer_user_id,\n            self.REVIEWER_USER_ID\n        )\n        self.assertEqual(\n            translation_review_stats_model.reviewed_translations_count,\n            self.REVIEWED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .reviewed_translation_word_count\n            ),\n            self.REVIEWED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_review_stats_model.accepted_translations_count,\n            self.ACCEPTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .accepted_translations_with_reviewer_edits_count\n            ),\n            self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_review_stats_model\n                .accepted_translation_word_count\n            ),\n            self.ACCEPTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_review_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            translation_review_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_apply_deletion_policy(self) -> None:\n        suggestion_models.TranslationReviewStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_translations_count=self.REVIEWED_TRANSLATIONS_COUNT,\n            reviewed_translation_word_count=(\n                self.REVIEWED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_with_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        self.assertTrue(\n            suggestion_models.TranslationReviewStatsModel\n            .has_reference_to_user_id(self.REVIEWER_USER_ID))\n\n        (\n            suggestion_models.TranslationReviewStatsModel\n            .apply_deletion_policy(self.REVIEWER_USER_ID)\n        )\n\n        self.assertFalse(\n            suggestion_models.TranslationReviewStatsModel\n            .has_reference_to_user_id(self.REVIEWER_USER_ID))\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.TranslationReviewStatsModel\n            .export_data('non_existent_user'))\n        self.assertEqual(user_data, {})\n\n    def test_export_data_nontrivial(self) -> None:\n        topic_id_2 = 'topic ID 2'\n        # Seed translation stats data for two different topics.\n        model_1_id = suggestion_models.TranslationReviewStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_translations_count=self.REVIEWED_TRANSLATIONS_COUNT,\n            reviewed_translation_word_count=(\n                self.REVIEWED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_with_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        model_2_id = suggestion_models.TranslationReviewStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=topic_id_2,\n            reviewed_translations_count=self.REVIEWED_TRANSLATIONS_COUNT,\n            reviewed_translation_word_count=(\n                self.REVIEWED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_with_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        model_1_id_without_user_id = model_1_id.replace(\n            '.%s.' % self.REVIEWER_USER_ID, '.'\n        )\n        model_2_id_without_user_id = model_2_id.replace(\n            '.%s.' % self.REVIEWER_USER_ID, '.'\n        )\n        expected_data = {\n            model_1_id_without_user_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': self.TOPIC_ID,\n                'reviewed_translations_count': (\n                    self.REVIEWED_TRANSLATIONS_COUNT),\n                'reviewed_translation_word_count': (\n                    self.REVIEWED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_with_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            },\n            model_2_id_without_user_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': topic_id_2,\n                'reviewed_translations_count': (\n                    self.REVIEWED_TRANSLATIONS_COUNT),\n                'reviewed_translation_word_count': (\n                    self.REVIEWED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_with_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITH_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            }\n        }\n\n        user_data = (\n            suggestion_models.TranslationReviewStatsModel\n            .export_data(self.REVIEWER_USER_ID))\n\n        self.assertEqual(expected_data, user_data)\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'reviewer_user_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id': base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_translations_count': base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_count': base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_with_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date': base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date': base_models.EXPORT_POLICY.EXPORTED\n        }\n        model = suggestion_models.TranslationReviewStatsModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.TranslationReviewStatsModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER)\n\n\nclass QuestionContributionStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the QuestionContributionStatsModel class.\"\"\"\n\n    CONTRIBUTOR_USER_ID = 'uid_01234567890123456789012345678912'\n    TOPIC_ID = 'topic_id'\n    SUBMITTED_QUESTION_COUNT = 2\n    ACCEPTED_QUESTIONS_COUNT = 1\n    ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT = 0\n    FIRST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n    LAST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n\n    def test_get_returns_model_when_it_exists(self) -> None:\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_questions_count=self.SUBMITTED_QUESTION_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_without_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        question_contribution_stats_model = (\n            suggestion_models.QuestionContributionStatsModel.get(\n                self.CONTRIBUTOR_USER_ID, self.TOPIC_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.contributor_user_id,\n            self.CONTRIBUTOR_USER_ID\n        )\n        self.assertEqual(\n            question_contribution_stats_model.submitted_questions_count,\n            self.SUBMITTED_QUESTION_COUNT\n        )\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            self.ACCEPTED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            question_contribution_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            question_contribution_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_get_all_by_user_id(self) -> None:\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_questions_count=self.SUBMITTED_QUESTION_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_without_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        question_contribution_stats_models = (\n            suggestion_models.QuestionContributionStatsModel.get_all_by_user_id(\n                self.CONTRIBUTOR_USER_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert question_contribution_stats_models is not None\n\n        self.assertEqual(\n            len(question_contribution_stats_models),\n            1\n        )\n\n        question_contribution_stats_model = question_contribution_stats_models[\n            0]\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert question_contribution_stats_model is not None\n        self.assertEqual(\n            question_contribution_stats_model.contributor_user_id,\n            self.CONTRIBUTOR_USER_ID\n        )\n        self.assertEqual(\n            question_contribution_stats_model.submitted_questions_count,\n            self.SUBMITTED_QUESTION_COUNT\n        )\n        self.assertEqual(\n            question_contribution_stats_model.accepted_questions_count,\n            self.ACCEPTED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                question_contribution_stats_model\n                .accepted_questions_without_reviewer_edits_count\n            ),\n            self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            question_contribution_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            question_contribution_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.QuestionContributionStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.DELETE)\n\n    def test_apply_deletion_policy(self) -> None:\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_questions_count=self.SUBMITTED_QUESTION_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_without_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        self.assertTrue(\n            suggestion_models.QuestionContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n        (\n            suggestion_models.QuestionContributionStatsModel\n            .apply_deletion_policy(self.CONTRIBUTOR_USER_ID)\n        )\n\n        self.assertFalse(\n            suggestion_models.QuestionContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.QuestionContributionStatsModel\n            .export_data('non_existent_user'))\n        self.assertEqual(user_data, {})\n\n    def test_export_data_nontrivial(self) -> None:\n        topic_id_2 = 'topic ID 2'\n        # Seed question stats data for two different topics.\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_questions_count=self.SUBMITTED_QUESTION_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_without_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        suggestion_models.QuestionContributionStatsModel.create(\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=topic_id_2,\n            submitted_questions_count=self.SUBMITTED_QUESTION_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_without_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        model_1_id_without_user_id = self.TOPIC_ID\n        model_2_id_without_user_id = topic_id_2\n        expected_data = {\n            model_1_id_without_user_id: {\n                'topic_id': self.TOPIC_ID,\n                'submitted_questions_count': (\n                    self.SUBMITTED_QUESTION_COUNT),\n                'accepted_questions_count': (\n                    self.ACCEPTED_QUESTIONS_COUNT),\n                'accepted_questions_without_reviewer_edits_count': (\n                    self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            },\n            model_2_id_without_user_id: {\n                'topic_id': topic_id_2,\n                'submitted_questions_count': (\n                    self.SUBMITTED_QUESTION_COUNT),\n                'accepted_questions_count': (\n                    self.ACCEPTED_QUESTIONS_COUNT),\n                'accepted_questions_without_reviewer_edits_count': (\n                    self.ACCEPTED_QUESTIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            }\n        }\n\n        user_data = (\n            suggestion_models.QuestionContributionStatsModel\n            .export_data(self.CONTRIBUTOR_USER_ID))\n\n        self.assertEqual(expected_data, user_data)\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'contributor_user_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id': base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_questions_count': base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_count': base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_without_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date': base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date': base_models.EXPORT_POLICY.EXPORTED\n        }\n        model = suggestion_models.QuestionContributionStatsModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.QuestionContributionStatsModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER)\n\n\nclass QuestionReviewStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the QuestionReviewStatsModel class.\"\"\"\n\n    REVIEWER_USER_ID = 'uid_01234567890123456789012345678912'\n    TOPIC_ID = 'topic_id'\n    REVIEWED_QUESTIONS_COUNT = 2\n    ACCEPTED_QUESTIONS_COUNT = 1\n    ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT = 0\n    FIRST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n    LAST_CONTRIBUTION_DATE = datetime.date.fromtimestamp(1616173836)\n\n    def test_get_returns_model_when_it_exists(self) -> None:\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_questions_count=self.REVIEWED_QUESTIONS_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_with_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        question_review_stats_model = (\n            suggestion_models.QuestionReviewStatsModel.get(\n                self.REVIEWER_USER_ID, self.TOPIC_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert question_review_stats_model is not None\n        self.assertEqual(\n            question_review_stats_model.reviewer_user_id,\n            self.REVIEWER_USER_ID\n        )\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            self.REVIEWED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            self.ACCEPTED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .accepted_questions_with_reviewer_edits_count\n            ),\n            self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            question_review_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            question_review_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_get_all_by_user_id(self) -> None:\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_questions_count=self.REVIEWED_QUESTIONS_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_with_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n\n        question_review_stats_models = (\n            suggestion_models.QuestionReviewStatsModel.get_all_by_user_id(\n                self.REVIEWER_USER_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert question_review_stats_models is not None\n\n        question_review_stats_model = question_review_stats_models[0]\n\n        self.assertEqual(\n            question_review_stats_model.reviewer_user_id,\n            self.REVIEWER_USER_ID\n        )\n        self.assertEqual(\n            question_review_stats_model.reviewed_questions_count,\n            self.REVIEWED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            question_review_stats_model.accepted_questions_count,\n            self.ACCEPTED_QUESTIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                question_review_stats_model\n                .accepted_questions_with_reviewer_edits_count\n            ),\n            self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            question_review_stats_model.first_contribution_date,\n            self.FIRST_CONTRIBUTION_DATE\n        )\n        self.assertEqual(\n            question_review_stats_model.last_contribution_date,\n            self.LAST_CONTRIBUTION_DATE\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.QuestionReviewStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.DELETE)\n\n    def test_apply_deletion_policy(self) -> None:\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_questions_count=self.REVIEWED_QUESTIONS_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_with_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        self.assertTrue(\n            suggestion_models.QuestionReviewStatsModel\n            .has_reference_to_user_id(self.REVIEWER_USER_ID))\n\n        (\n            suggestion_models.QuestionReviewStatsModel\n            .apply_deletion_policy(self.REVIEWER_USER_ID)\n        )\n\n        self.assertFalse(\n            suggestion_models.QuestionReviewStatsModel\n            .has_reference_to_user_id(self.REVIEWER_USER_ID))\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.QuestionReviewStatsModel\n            .export_data('non_existent_user'))\n        self.assertEqual(user_data, {})\n\n    def test_export_data_nontrivial(self) -> None:\n        topic_id_2 = 'topic ID 2'\n        # Seed question stats data for two different topics.\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=self.TOPIC_ID,\n            reviewed_questions_count=self.REVIEWED_QUESTIONS_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_with_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        suggestion_models.QuestionReviewStatsModel.create(\n            reviewer_user_id=self.REVIEWER_USER_ID,\n            topic_id=topic_id_2,\n            reviewed_questions_count=self.REVIEWED_QUESTIONS_COUNT,\n            accepted_questions_count=self.ACCEPTED_QUESTIONS_COUNT,\n            accepted_questions_with_reviewer_edits_count=(\n                self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n            first_contribution_date=self.FIRST_CONTRIBUTION_DATE,\n            last_contribution_date=self.LAST_CONTRIBUTION_DATE\n        )\n        model_1_id_without_user_id = self.TOPIC_ID\n        model_2_id_without_user_id = topic_id_2\n        expected_data = {\n            model_1_id_without_user_id: {\n                'topic_id': self.TOPIC_ID,\n                'reviewed_questions_count': (\n                    self.REVIEWED_QUESTIONS_COUNT),\n                'accepted_questions_count': (\n                    self.ACCEPTED_QUESTIONS_COUNT),\n                'accepted_questions_with_reviewer_edits_count': (\n                    self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            },\n            model_2_id_without_user_id: {\n                'topic_id': topic_id_2,\n                'reviewed_questions_count': (\n                    self.REVIEWED_QUESTIONS_COUNT),\n                'accepted_questions_count': (\n                    self.ACCEPTED_QUESTIONS_COUNT),\n                'accepted_questions_with_reviewer_edits_count': (\n                    self.ACCEPTED_QUESTIONS_WITH_REVIEWER_EDITS_COUNT),\n                'first_contribution_date': (\n                    self.FIRST_CONTRIBUTION_DATE.isoformat()),\n                'last_contribution_date': (\n                    self.LAST_CONTRIBUTION_DATE.isoformat())\n            }\n        }\n\n        user_data = (\n            suggestion_models.QuestionReviewStatsModel\n            .export_data(self.REVIEWER_USER_ID))\n\n        self.assertEqual(expected_data, user_data)\n\n    def test_get_export_policy(self) -> None:\n        expected_dict = {\n            'created_on': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'last_updated': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'deleted': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'reviewer_user_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id': base_models.EXPORT_POLICY.EXPORTED,\n            'reviewed_questions_count': base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_count': base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_questions_with_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'first_contribution_date': base_models.EXPORT_POLICY.EXPORTED,\n            'last_contribution_date': base_models.EXPORT_POLICY.EXPORTED\n        }\n        model = suggestion_models.QuestionReviewStatsModel\n        self.assertEqual(model.get_export_policy(), expected_dict)\n\n    def test_get_model_association_to_user(self) -> None:\n        model = suggestion_models.QuestionReviewStatsModel\n        self.assertEqual(\n            model.get_model_association_to_user(),\n            base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER)\n"
    },
    {
      "filename": "core/templates/app.constants.ts",
      "content": "// Copyright 2019 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Shared constants for the Oppia module.\n */\n\nimport commonConstants from 'assets/constants';\n\nexport const AppConstants = {\n  ...commonConstants,\n  DEFAULT_TRANSLATIONS: {\n    I18N_LIBRARY_PAGE_TITLE_FRAGMENT_FOR_WEB: 'Library',\n    I18N_LIBRARY_LOADING: 'Loading',\n    I18N_SIGNUP_PAGE_SUBTITLE: 'Registration',\n    I18N_SIGNUP_PAGE_TITLE_FRAGMENT_FOR_WEB: 'Oppia',\n    I18N_LIBRARY_SEARCH_PLACEHOLDER: 'What are you curious about?',\n    I18N_LIBRARY_ALL_LANGUAGES: 'All Languages',\n    I18N_LIBRARY_LANGUAGES_EN: 'English',\n    I18N_LIBRARY_ALL_CATEGORIES: 'All Categories',\n    I18N_TOPNAV_SIGN_IN: 'Sign in',\n    I18N_SPLASH_PAGE_TITLE_FRAGMENT_FOR_WEB:\n      'Oppia | Free, Online and Interactive Lessons for Anyone',\n    I18N_SIGNUP_REGISTRATION: 'Registration',\n    I18N_SIGNUP_LOADING: 'Loading',\n  },\n\n  ACTIVITY_STATUS_PRIVATE: 'private',\n  ACTIVITY_STATUS_PUBLIC: 'public',\n\n  RULE_SUMMARY_WRAP_CHARACTER_COUNT: 30,\n\n  /* Called when the learner moves to a new card that they haven't seen\n     before. */\n  EDITABLE_EXPLORATION_DATA_DRAFT_URL_TEMPLATE: (\n    '/createhandler/data/<exploration_id>?apply_draft=<apply_draft>'),\n  EDITABLE_EXPLORATION_DATA_URL_TEMPLATE: (\n    '/createhandler/data/<exploration_id>'),\n  EXPLORATION_DATA_URL_TEMPLATE: '/explorehandler/init/<exploration_id>',\n  EXPLORATION_VERSION_DATA_URL_TEMPLATE: (\n    '/explorehandler/init/<exploration_id>?v=<version>'),\n  EXPLORATION_PROGRESS_PID_URL_TEMPLATE: (\n    '/explorehandler/init/<exploration_id>?pid=<pid>'),\n\n  WARNING_TYPES: {\n    // These must be fixed before the exploration can be saved.\n    CRITICAL: 'critical',\n    // These must be fixed before publishing an exploration to the public\n    // library.\n    ERROR: 'error',\n  },\n\n  STATE_ERROR_MESSAGES: {\n    ADD_INTERACTION: 'Please add an interaction to this card.',\n    STATE_UNREACHABLE: 'This card is unreachable.',\n    UNABLE_TO_END_EXPLORATION:\n      \"There's no way to complete the exploration starting from this card. \" +\n      'To fix this, make sure that the last card in the chain starting from' +\n      \" this one has an 'End Exploration' question type.\",\n    INCORRECT_SOLUTION: 'The current solution does not lead to another card.',\n    UNRESOLVED_ANSWER:\n      'There is an answer among the top 10 which has no explicit feedback.',\n    INVALID_REDIRECTION: 'Learner should not be directed back by more than' +\n      ' 3 cards in the lesson.'\n  },\n\n  CHECKPOINT_ERROR_MESSAGES: {\n    INIT_CARD: 'The first card of the lesson must be a checkpoint.',\n    TERMINAL_CARD:\n      'Checkpoints are not allowed on the last card of the lesson.',\n    CHECKPOINT_COUNT: 'Only a maximum of 8 checkpoints are allowed per lesson.',\n    BYPASSABLE_CARD:\n      'Checkpoints must not be assigned to cards that can be bypassed.'\n  },\n\n  EXPLORATION_SUMMARY_DATA_URL_TEMPLATE: '/explorationsummarieshandler/data',\n\n  EXPLORATION_AND_SKILL_ID_PATTERN: /^[a-zA-Z0-9_-]+$/,\n\n  // We use a slash because this character is forbidden in a state name.\n  PLACEHOLDER_OUTCOME_DEST: '/',\n  PLACEHOLDER_OUTCOME_DEST_IF_STUCK: '/',\n  INTERACTION_DISPLAY_MODE_INLINE: 'inline',\n  LOADING_INDICATOR_URL: '/activity/loadingIndicator.gif',\n  OBJECT_EDITOR_URL_PREFIX: '/object_editor_template/',\n  // Feature still in development.\n  // NOTE TO DEVELOPERS: This should be synchronized with the value in feconf.\n  ENABLE_ML_CLASSIFIERS: false,\n  // Feature still in development.\n  INFO_MESSAGE_SOLUTION_IS_INVALID_FOR_EXPLORATION: (\n    'The current solution does not lead to another card.'),\n  PARAMETER_TYPES: {\n    REAL: 'Real',\n    UNICODE_STRING: 'UnicodeString',\n  },\n\n  // Flag to toggle the support for a new state to direct the learners\n  // to if they get stuck.\n  DEST_IF_REALLY_STUCK_FEAT_ENABLED: false,\n\n  INTERACTION_NAMES: {\n    TEXT_INPUT: 'TextInput'\n  },\n\n  // The maximum number of nodes to show in a row of the state graph.\n  MAX_NODES_PER_ROW: 4,\n  // The following variable must be at least 3. It represents the maximum\n  // length, in characters, for the name of each node label in the state graph.\n  MAX_NODE_LABEL_LENGTH: 15,\n\n  // If an $http request fails with the following error codes, a warning is\n  // displayed.\n  FATAL_ERROR_CODES: [400, 401, 404, 500],\n\n  // Maximum number of states the learner can be directed back from a state\n  // by an editor in an exploration.\n  MAX_CARD_COUNT_FOR_VALID_REDIRECTION: 3,\n\n  // Do not modify these, for backwards-compatibility reasons. These strings are\n  // used to identify components, to generate content ids, and to determine what\n  // type of content a given content id is associated with. If you wish to\n  // change one of these, a state migration of all existing content ids is\n  // required. The component content type should be sufficiently small such that\n  // the commit messages that use the content type strings do not exceed 375\n  // characters (which is the maximum length of a commit message).\n  COMPONENT_NAME_CONTENT: 'content',\n  COMPONENT_NAME_FEEDBACK: 'feedback',\n  COMPONENT_NAME_HINT: 'hint',\n  COMPONENT_NAME_INTERACTION_CUSTOMIZATION_ARGS: 'ca',\n  COMPONENT_NAME_RULE_INPUT: 'rule_input',\n  COMPONENT_NAME_SOLUTION: 'solution',\n  COMPONENT_NAME_EXPLANATION: 'explanation',\n  COMPONENT_NAME_WORKED_EXAMPLE: {\n    QUESTION: 'worked_example_question',\n    EXPLANATION: 'worked_example_explanation',\n  },\n\n  ACTION_TYPE_EXPLORATION_START: 'ExplorationStart',\n  ACTION_TYPE_ANSWER_SUBMIT: 'AnswerSubmit',\n  ACTION_TYPE_EXPLORATION_QUIT: 'ExplorationQuit',\n\n  ISSUE_TYPE_EARLY_QUIT: 'EarlyQuit',\n  ISSUE_TYPE_MULTIPLE_INCORRECT_SUBMISSIONS: 'MultipleIncorrectSubmissions',\n  ISSUE_TYPE_CYCLIC_STATE_TRANSITIONS: 'CyclicStateTransitions',\n\n  // A block refers to a set of learner actions displayed together so that\n  // they are part of the same context. If two consecutive learner actions are\n  // from different states, we consider them unrelated. This constant refers to\n  // the maximum number of such actions that can exist in one block. (Note that\n  // all related actions are shown together, regardless of how many there are.)\n  MAX_UNRELATED_ACTIONS_PER_BLOCK: 4,\n\n  SITE_NAME: 'Oppia.org',\n\n  DEFAULT_PROFILE_IMAGE_PATH: '/avatar/user_blue_72px.webp',\n\n  // TODO(vojtechjelinek): Move these to separate file later, after we establish\n  // process to follow for Angular constants (#6731).\n  SUBTOPIC_PAGE_EDITOR_DATA_URL_TEMPLATE: (\n    '/subtopic_page_editor_handler/data/<topic_id>/<subtopic_id>'),\n  // This should be synchronized with SUBTOPIC_MASTERY_DATA_URL\n  // in feconf.\n  SUBTOPIC_MASTERY_DATA_URL_TEMPLATE: (\n    '/subtopic_mastery_handler/data'),\n  EDITABLE_TOPIC_DATA_URL_TEMPLATE: '/topic_editor_handler/data/<topic_id>',\n\n  LABEL_FOR_CLEARING_FOCUS: 'labelForClearingFocus',\n\n  // TODO(bhenning): This constant should be provided by the backend.\n  COLLECTION_DATA_URL_TEMPLATE: '/collection_handler/data/<collection_id>',\n\n  ENTITY_TYPE: {\n    COLLECTION: 'collection',\n    EXPLORATION: 'exploration',\n    TOPIC: 'topic',\n    SKILL: 'skill',\n    STORY: 'story',\n    QUESTION: 'question',\n    BLOG_POST: 'blog_post',\n  },\n\n  AUDIO_UPLOAD_URL_TEMPLATE: '/createhandler/audioupload/<exploration_id>',\n  IMAGE_UPLOAD_URL_TEMPLATE: (\n    '/createhandler/imageupload/<entity_type>/<entity_id>'),\n\n  MAX_NUM_AUDIO_FILES_TO_DOWNLOAD_SIMULTANEOUSLY: 3,\n  MAX_NUM_IMAGE_FILES_TO_DOWNLOAD_SIMULTANEOUSLY: 3,\n\n  IMAGE_CONTEXT: {\n    EXPLORATION_SUGGESTIONS: 'exploration_suggestions',\n    QUESTION_SUGGESTIONS: 'question_suggestions'\n  },\n\n  IMAGE_SAVE_DESTINATION_SERVER: 'imageSaveDestinationServer',\n  IMAGE_SAVE_DESTINATION_LOCAL_STORAGE:\n    'imageSaveDestinationLocalStorage',\n  SVG_MIME_TYPE: 'data:image/svg+xml',\n\n  CONTRIBUTION_STATS_TYPE_TRANSLATION: 'translation',\n  CONTRIBUTION_STATS_TYPE_QUESTION: 'question',\n  CONTRIBUTION_STATS_SUBTYPE_SUBMISSION: 'submission',\n  CONTRIBUTION_STATS_SUBTYPE_REVIEW: 'review',\n  CONTRIBUTION_STATS_SUBTYPE_CORRECTION: 'correction',\n  CONTRIBUTION_STATS_TYPES: {\n    TRANSLATION_CONTRIBUTION: {\n      NAME: 'translationContribution',\n      DISPLAY_NAME: 'Translation Contributions'\n    },\n    TRANSLATION_REVIEW: {\n      NAME: 'translationReview',\n      DISPLAY_NAME: 'Translation Reviews'\n    },\n    QUESTION_CONTRIBUTION: {\n      NAME: 'questionContribution',\n      DISPLAY_NAME: 'Question Contributions'\n    },\n    QUESTION_REVIEW: {\n      NAME: 'questionReview',\n      DISPLAY_NAME: 'Question Reviews'\n    }\n  },\n  CONTRIBUTOR_BADGE_INITIAL_LEVELS: [1, 10, 20, 50, 100, 200, 300, 400, 500],\n  CONTRIBUTOR_CERTIFICATE_LOGO:\n    '/assets/images/contributor_dashboard/oppia-logo.jpg'\n} as const;\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/badge/badge.component.html",
      "content": "<div *ngIf=\"isUnlocked && contributionType === 'question'\" class=\"question-badge-container\">\n  <img class=\"question-badge\"\n       src=\"/assets/images/contributor_dashboard/question-{{contributionSubType}}-badge.component.svg\">\n  <div class=\"question-badge-value\">\n      {{contributionCount}}\n  </div>\n  <div class=\"question-badge-caption\">\n      {{contributionSubTypeText}}\n  </div>\n</div>\n<div *ngIf=\"isUnlocked && contributionType === 'translation'\"\n     class=\"translation-badge-container\">\n  <img class=\"translation-badge\"\n       src=\"/assets/images/contributor_dashboard/translation-{{contributionSubType}}-badge.component.svg\">\n  <div class=\"translation-badge-value\">\n    {{contributionCount}}\n  </div>\n  <div class=\"translation-badge-caption\">\n    {{contributionSubTypeText}}\n  </div>\n  <div class=\"translation-badge-language\"\n       [ngStyle]=\"{'font-size': fontSize, 'line-height': lineHeight}\">\n    {{language}}\n  </div>\n</div>\n<div *ngIf=\"!isUnlocked\"\n     ngbPopover=\"{{contributionCount}} more {{contributionSubTypeText.toLowerCase()}} to achieve this badge\"\n     class=\"locked-badge-container\"\n     container=\"body\"\n     placement=\"bottom\">\n  <img class=\"locked-badge\"\n       src=\"/assets/images/contributor_dashboard/locked-badge.svg\">\n</div>\n<style>\n  .locked-badge-container {\n    position: relative;\n    width: 90px;\n  }\n  .question-badge-container {\n    position: relative;\n    width: 100px;\n  }\n  .question-badge-value {\n    font-family: \"Capriola\", \"Roboto\", Arial, sans-serif;\n    position: absolute;\n    text-align: center;\n    top: 50%;\n    width: 100%;\n  }\n  .question-badge-caption {\n    font-family: \"Capriola\", \"Roboto\", Arial, sans-serif;\n    font-size: 7px;\n    position: absolute;\n    text-align: center;\n    top: 70%;\n    width: 100%;\n  }\n  .translation-badge-container {\n    position: relative;\n    width: 100px;\n  }\n  .translation-badge-value {\n    font-family: \"Capriola\", \"Roboto\", Arial, sans-serif;\n    position: absolute;\n    text-align: center;\n    top: 22%;\n    width: 100%;\n  }\n  .translation-badge-caption {\n    font-family: \"Capriola\", \"Roboto\", Arial, sans-serif;\n    font-size: 8px;\n    position: absolute;\n    text-align: center;\n    top: 46%;\n    width: 100%;\n  }\n  .translation-badge-language {\n    color: white;\n    height: 20px;\n    left: 0;\n    margin: auto;\n    position: absolute;\n    right: 0;\n    text-align: center;\n    top: 71%;\n    width: 70px;\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.module.ts",
      "content": "// Copyright 2019 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Module for the contributor dashboard page.\n */\n\nimport { APP_INITIALIZER, NgModule, StaticProvider } from '@angular/core';\nimport { BrowserModule, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { HttpClientModule } from '@angular/common/http';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { RequestInterceptor } from 'services/request-interceptor.service';\nimport { SharedComponentsModule } from 'components/shared-component.module';\nimport { OppiaAngularRootComponent } from\n  'components/oppia-angular-root.component';\nimport { RouterModule } from '@angular/router';\nimport { APP_BASE_HREF } from '@angular/common';\n\nimport { InteractionExtensionsModule } from 'interactions/interactions.module';\nimport { TranslationLanguageSelectorComponent } from\n  './translation-language-selector/translation-language-selector.component';\nimport { ReviewTranslationLanguageSelectorComponent } from './translation-language-selector/review-translation-language-selector.component';\nimport { TranslationTopicSelectorComponent } from\n  './translation-topic-selector/translation-topic-selector.component';\nimport { LoginRequiredMessageComponent } from './login-required-message/login-required-message.component';\nimport { LoginRequiredModalContent } from './modal-templates/login-required-modal.component';\nimport { SmartRouterModule } from 'hybrid-router-module-provider';\n\nimport { OpportunitiesListItemComponent } from './opportunities-list-item/opportunities-list-item.component';\nimport { OpportunitiesListComponent } from './opportunities-list/opportunities-list.component';\nimport { TranslationSuggestionReviewModalComponent } from './modal-templates/translation-suggestion-review-modal.component';\nimport { NgbModalModule } from '@ng-bootstrap/ng-bootstrap';\nimport { platformFeatureInitFactory, PlatformFeatureService } from\n  'services/platform-feature.service';\nimport { TranslationModalComponent } from './modal-templates/translation-modal.component';\nimport { TranslationOpportunitiesComponent } from './translation-opportunities/translation-opportunities.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { MyHammerConfig, toastrConfig } from 'pages/oppia-root/app.module';\nimport { ContributionsAndReview } from './contributions-and-review/contributions-and-review.component';\nimport { QuestionOpportunitiesComponent } from './question-opportunities/question-opportunities.component';\nimport { ContributorDashboardPageComponent } from './contributor-dashboard-page.component';\nimport { AppErrorHandlerProvider } from 'pages/oppia-root/app-error-handler';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    BrowserAnimationsModule,\n    HttpClientModule,\n    InteractionExtensionsModule,\n    // TODO(#13443): Remove smart router module provider once all pages are\n    // migrated to angular router.\n    SmartRouterModule,\n    RouterModule.forRoot([]),\n    SharedComponentsModule,\n    NgbModalModule,\n    SharedFormsModule,\n    OppiaCkEditorCopyToolBarModule,\n    ToastrModule.forRoot(toastrConfig)\n  ],\n  declarations: [\n    CertificateDownloadModalComponent,\n    ContributorBadgesComponent,\n    LoginRequiredMessageComponent,\n    LoginRequiredModalContent,\n    OpportunitiesListItemComponent,\n    OpportunitiesListComponent,\n    ReviewTranslationLanguageSelectorComponent,\n    ContributorStatsComponent,\n    BadgeComponent,\n    TranslationLanguageSelectorComponent,\n    TranslationOpportunitiesComponent,\n    TranslationSuggestionReviewModalComponent,\n    TranslationTopicSelectorComponent,\n    TranslationModalComponent,\n    ContributionsAndReview,\n    QuestionOpportunitiesComponent,\n    ContributorDashboardPageComponent,\n    ContributorBadgesComponent\n  ],\n  entryComponents: [\n    CertificateDownloadModalComponent,\n    ContributorBadgesComponent,\n    LoginRequiredMessageComponent,\n    LoginRequiredModalContent,\n    OpportunitiesListItemComponent,\n    OpportunitiesListComponent,\n    ReviewTranslationLanguageSelectorComponent,\n    ContributorStatsComponent,\n    BadgeComponent,\n    TranslationLanguageSelectorComponent,\n    TranslationOpportunitiesComponent,\n    TranslationSuggestionReviewModalComponent,\n    TranslationTopicSelectorComponent,\n    TranslationModalComponent,\n    ContributionsAndReview,\n    QuestionOpportunitiesComponent,\n    ContributorDashboardPageComponent\n  ],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: RequestInterceptor,\n      multi: true\n    },\n    {\n      provide: APP_INITIALIZER,\n      useFactory: platformFeatureInitFactory,\n      deps: [PlatformFeatureService],\n      multi: true\n    },\n    {\n      provide: HAMMER_GESTURE_CONFIG,\n      useClass: MyHammerConfig\n    },\n    AppErrorHandlerProvider,\n    {\n      provide: APP_BASE_HREF,\n      useValue: '/'\n    }\n  ]\n})\nclass ContributorDashboardPageModule {\n  // Empty placeholder method to satisfy the `Compiler`.\n  ngDoBootstrap() {}\n}\n\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { downgradeModule } from '@angular/upgrade/static';\nimport { SharedFormsModule } from 'components/forms/shared-forms.module';\nimport { ToastrModule } from 'ngx-toastr';\nimport { OppiaCkEditorCopyToolBarModule } from 'components/ck-editor-helpers/ck-editor-copy-toolbar/ck-editor-copy-toolbar.module';\nimport { ContributorStatsComponent } from './contributor-stats/contributor-stats.component';\nimport { CertificateDownloadModalComponent } from './modal-templates/certificate-download-modal.component';\nimport { ContributorBadgesComponent } from './contributor-badges/contributor-badges.component';\nimport { BadgeComponent } from './badge/badge.component';\n\nconst bootstrapFnAsync = async(extraProviders: StaticProvider[]) => {\n  const platformRef = platformBrowserDynamic(extraProviders);\n  return platformRef.bootstrapModule(ContributorDashboardPageModule);\n};\nconst downgradedModule = downgradeModule(bootstrapFnAsync);\n\ndeclare var angular: ng.IAngularStatic;\n\nangular.module('oppia').requires.push(downgradedModule);\n\nangular.module('oppia').directive(\n  // This directive is the downgraded version of the Angular component to\n  // bootstrap the Angular 8.\n  'oppiaAngularRoot',\n  downgradeComponent({\n    component: OppiaAngularRootComponent\n  }) as angular.IDirectiveFactory);\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/contributor-stats/contributor-stats.component.html",
      "content": "<div class=\"stats-container\">\n  <div class=\"stats-contribution-type-mobile-container\">\n    <div class=\"dropdown-label\">Type</div>\n    <div #mobileDropdown class=\"oppia-contribution-stats-type-selector-mobile-container e2e-test-topic-selector\">\n      <div class=\"oppia-stats-type-selector-inner-container e2e-test-topic-selector-selected\"\n           (click)=\"toggleMobileDropdown()\">\n        {{selectedContributionType}}\n        <span class=\"fas fa-sort-down oppia-contributions-dropdown-arrow\"\n              [ngStyle]=\"{ 'transform': mobileDropdownShown ? 'scaleY(-1)' : 'scaleY(1)' }\">\n        </span>\n      </div>\n\n      <div *ngIf=\"mobileDropdownShown\"\n           class=\"oppia-stats-type-selector-dropdown-container e2e-test-topic-selector-dropdown\">\n        <div class=\"oppia-stats-type-selector-dropdown-option e2e-test-topic-selector-option\"\n             (click)=\"selectOption(option.contributionType)\"\n             *ngFor=\"let option of options\"\n             [ngClass]=\"{'oppia-stats-type-selector-dropdown-option-selected' : option === activeTopicName}\">\n            {{option.displayName}}\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"stats-contribution-type-label\">\n    Contribution Type\n  </div>\n  <div class=\"stats-welcome-text-container\">\n    Explore the impact of your contributions!\n  </div>\n  <div class=\"stats-contribution-type-container\">\n    <div #dropdown class=\"oppia-stats-type-selector-container e2e-test-topic-selector\">\n      <div class=\"oppia-stats-type-selector-inner-container e2e-test-topic-selector-selected\"\n           (click)=\"toggleDropdown()\">\n        {{selectedContributionType}}\n        <span class=\"fas fa-caret-down oppia-stats-type-selector-inner-container-arrow\"\n              [ngStyle]=\"{ 'transform': dropdownShown ? 'scaleY(-1)' : 'scaleY(1)' }\">\n        </span>\n      </div>\n\n      <div *ngIf=\"dropdownShown\"\n           class=\"oppia-stats-type-selector-dropdown-container e2e-test-topic-selector-dropdown\">\n        <div class=\"oppia-stats-type-selector-dropdown-option e2e-test-topic-selector-option\"\n             *ngFor=\"let option of options\"\n             (click)=\"selectOption(option.contributionType)\"\n             [ngClass]=\"{'oppia-stats-type-selector-dropdown-option-selected' : option === activeTopicName}\">\n          {{option.displayName}}\n        </div>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"type == 'translationContribution' || type == 'translationReview'\" class=\"stats-cards-container\">\n    <mat-card *ngFor=\"let translationStatByLanguageAndTopic of statsData[type] | keyvalue\" layout=\"row\" class=\"list-view-item\">\n      <div>\n        {{selectedContributionType}} - {{languageUtilService.getAudioLanguageDescription(translationStatByLanguageAndTopic.key)}}\n      </div>\n      <table class=\"dashboard-table e2e-test-topics-table\">\n        <tr>\n          <th *ngFor=\"let column of COLUMNS[type] | keyvalue: provideOriginalOrder\"\n              class=\"dashboard-table-headings stats-data\">\n            <div class=\"stats-column-name-container\">\n              {{column.value}}\n            </div>\n          </th>\n        </tr>\n        <tr *ngFor=\"let translationStat of translationStatByLanguageAndTopic.value.data.slice(translationStatByLanguageAndTopic.value.currentPageStartIndex, translationStatByLanguageAndTopic.value.currentPageStartIndex + ITEMS_PER_PAGE)\" class=\"stats-row\">\n          <td class=\"stats-data\">\n            {{translationStat.firstContributionDate}} - {{translationStat.lastContributionDate}}\n          </td>\n          <td class=\"stats-data\">\n            {{translationStat.topicName}}\n          </td>\n          <td *ngIf=\"type == 'translationReview'\"\n              class=\"stats-data\">\n            {{translationStat.reviewedCards}}\n          </td>\n          <td *ngIf=\"type == 'translationReview'\"\n              class=\"stats-data\">\n            {{translationStat.reviewedWordCount}}\n          </td>\n          <td *ngIf=\"type == 'translationContribution' || type == 'translationReview'\"\n              class=\"stats-data\">\n            {{translationStat.acceptedCards}}\n          </td>\n          <td *ngIf=\"type == 'translationContribution' || type == 'translationReview'\"\n              class=\"stats-data\">\n            {{translationStat.acceptedWordCount}}\n          </td>\n        </tr>\n      </table>\n      <div *ngIf=\"type == 'translationContribution'\"\n           class=\"mobile-stats-page\">\n        <div class=\"mobile-stats-data-container\" *ngFor=\"let translationStat of translationStatByLanguageAndTopic.value.data.slice(translationStatByLanguageAndTopic.value.currentPageStartIndex, translationStatByLanguageAndTopic.value.currentPageStartIndex + ITEMS_PER_PAGE)\">\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].months}}</b>\n            </div>\n            <div>\n              {{translationStat.firstContributionDate}} - {{translationStat.lastContributionDate}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].topicNames}}</b>\n            </div>\n            <div>\n              {{translationStat.topicName}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedCards}}</b>\n            </div>\n            <div>\n              {{translationStat.acceptedCards}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedWordCount}}</b>\n            </div>\n            <div>\n              {{translationStat.acceptedWordCount}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div *ngIf=\"type == 'translationReview'\"\n           class=\"mobile-stats-page\">\n        <div class=\"mobile-stats-data-container\"\n             *ngFor=\"let translationStat of translationStatByLanguageAndTopic.value.data.slice(translationStatByLanguageAndTopic.value.currentPageStartIndex, translationStatByLanguageAndTopic.value.currentPageStartIndex + ITEMS_PER_PAGE)\">\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].months}}</b>\n            </div>\n            <div>\n              {{translationStat.firstContributionDate}} - {{translationStat.lastContributionDate}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].topicNames}}</b>\n            </div>\n            <div>\n              {{translationStat.topicName}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].reviewedCards}}</b>\n            </div>\n            <div>\n              {{translationStat.reviewedCards}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].reviewedWordCount}}</b>\n            </div>\n            <div>\n              {{translationStat.reviewedWordCount}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedCards}}</b>\n            </div>\n            <div>\n              {{translationStat.acceptedCards}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedWordCount}}</b>\n            </div>\n            <div>\n              {{translationStat.acceptedWordCount}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"oppia-pagination-container\">\n        <button type=\"button\"\n                class=\"oppia-pagination-button\"\n                (click)=\"goToPreviousPage(translationStatByLanguageAndTopic.value)\"\n                [disabled]=\"translationStatByLanguageAndTopic.value.currentPageStartIndex === 0\">\n          <span class=\"material-icons\">navigate_before</span>Previous\n        </button>\n        <button type=\"button\"\n                class=\"oppia-pagination-button\"\n                (click)=\"goToNextPage(translationStatByLanguageAndTopic.value)\"\n                [disabled]=\"translationStatByLanguageAndTopic.value.currentPageStartIndex + ITEMS_PER_PAGE >= translationStatByLanguageAndTopic.value.data.length\">\n          Next<span class=\"material-icons\">navigate_next</span>\n        </button>\n      </div>\n      <div class=\"certificate-download-button-container\"\n           *ngIf=\"type == 'translationContribution'\">\n        <button class=\"btn btn-success certificate-download-button\"\n                (click)=\"openCertificateDownloadModal('translate_content', translationStatByLanguageAndTopic.key)\">\n          <span>\n            Download Certificate\n          </span>\n          <i class=\"fa fa-download\"></i>\n        </button>\n      </div>\n    </mat-card>\n    <mat-card *ngIf=\"statsData[type].size === 0\"\n              layout=\"row\"\n              class=\"list-view-item oppia-contributions-required-message-container\">\n      <div class=\"oppia-contributions-required-message\">\n        Start contributing to see your stats!\n      </div>\n    </mat-card>\n  </div>\n\n  <div *ngIf=\"type == 'questionContribution' || type == 'questionReview'\"\n       class=\"stats-cards-container\">\n    <mat-card *ngIf=\"statsData[type]\"\n              layout=\"row\"\n              class=\"list-view-item\">\n      <div>\n        {{selectedContributionType}}\n      </div>\n      <table class=\"dashboard-table e2e-test-topics-table\">\n        <tr>\n          <th *ngFor=\"let column of COLUMNS[type] | keyvalue: provideOriginalOrder\"\n              class=\"dashboard-table-headings stats-data\">\n            <div class=\"stats-column-name-container\">\n              {{column.value}}\n            </div>\n          </th>\n        </tr>\n        <tr *ngFor=\"let questionStat of statsData[type].data.slice(statsData[type].currentPageStartIndex, statsData[type].currentPageStartIndex + ITEMS_PER_PAGE)\"\n            class=\"stats-row\">\n          <td class=\"stats-data\">\n            {{questionStat.firstContributionDate}} - {{questionStat.lastContributionDate}}\n          </td>\n          <td class=\"stats-data\">\n            {{questionStat.topicName}}\n          </td>\n          <td *ngIf=\"type == 'questionReview'\"\n              class=\"stats-data\">\n            {{questionStat.reviewedQuestions}}\n          </td>\n          <td class=\"stats-data\">\n            {{questionStat.acceptedQuestions}}\n          </td>\n          <td *ngIf=\"type == 'questionContribution'\"\n              class=\"stats-data\">\n            {{questionStat.acceptedQuestionsWithoutEdits}}\n          </td>\n        </tr>\n      </table>\n      <div *ngIf=\"type == 'questionContribution'\"\n           class=\"mobile-stats-page\">\n        <div class=\"mobile-stats-data-container\"\n             *ngFor=\"let questionStat of statsData[type].data.slice(statsData[type].currentPageStartIndex, statsData[type].currentPageStartIndex + ITEMS_PER_PAGE)\">\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].months}}</b>\n            </div>\n            <div>\n              {{questionStat.firstContributionDate}} - {{questionStat.lastContributionDate}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].topicNames}}</b>\n            </div>\n            <div>\n              {{questionStat.topicName}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedQuestions}}</b>\n            </div>\n            <div>\n              {{questionStat.acceptedQuestions}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedQuestionsWithoutEdits}}</b>\n            </div>\n            <div>\n              {{questionStat.acceptedQuestionsWithoutEdits}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div *ngIf=\"type == 'questionReview'\"\n           class=\"mobile-stats-page\">\n        <div class=\"mobile-stats-data-container\"\n             *ngFor=\"let questionStat of statsData[type].data.slice(statsData[type].currentPageStartIndex, statsData[type].currentPageStartIndex + ITEMS_PER_PAGE)\">\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].months}}</b>\n            </div>\n            <div>\n              {{questionStat.firstContributionDate}} - {{questionStat.lastContributionDate}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].topicNames}}</b>\n            </div>\n            <div>\n              {{questionStat.topicName}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].reviewedQuestions}}</b>\n            </div>\n            <div>\n              {{questionStat.reviewedQuestions}}\n            </div>\n          </div>\n          <div class=\"mobile-stats-row\">\n            <div class=\"mobile-stats-name\">\n              <b>{{COLUMNS[type].acceptedQuestions}}</b>\n            </div>\n            <div>\n              {{questionStat.acceptedQuestions}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"oppia-pagination-container\">\n        <button type=\"button\"\n                class=\"oppia-pagination-button\"\n                (click)=\"goToPreviousPage(statsData[type])\"\n                [disabled]=\"statsData[type].currentPageStartIndex === 0\">\n          <span class=\"material-icons\">navigate_before</span>Previous\n        </button>\n        <button type=\"button\"\n                class=\"oppia-pagination-button\"\n                (click)=\"goToNextPage(statsData[type])\"\n                [disabled]=\"statsData[type].currentPageStartIndex + ITEMS_PER_PAGE >= statsData[type].data.length\">\n          Next<span class=\"material-icons\">navigate_next</span>\n        </button>\n      </div>\n      <div class=\"certificate-download-button-container\"\n           *ngIf=\"type == 'questionContribution'\">\n        <button class=\"btn btn-success certificate-download-button\"\n                (click)=\"openCertificateDownloadModal('add_question', null)\">\n          <span>\n            Download Certificate\n          </span>\n          <i class=\"fa fa-download\"></i>\n        </button>\n      </div>\n    </mat-card>\n    <mat-card *ngIf=\"!statsData[type]\"\n              layout=\"row\"\n              class=\"list-view-item oppia-contributions-required-message-container\">\n      <div class=\"oppia-contributions-required-message\">\n        Start contributing to see your stats!\n      </div>\n    </mat-card>\n  </div>\n</div>\n\n<style>\n  .certificate-download-button-container {\n    overflow: hidden;\n  }\n  .certificate-download-button {\n    background-color: #00645c;\n    border-color: #00645c;\n    float: right;\n  }\n  .oppia-contributions-required-message-container {\n    height: 300px;\n  }\n  .oppia-contributions-required-message {\n    align-items: center;\n    color: #4a4a4a;\n    display: flex;\n    font-size: 28px;\n    height: 100%;\n    justify-content: center;\n    text-align: center;\n    vertical-align: middle;\n  }\n  .oppia-pagination-container {\n    display: flex;\n    justify-content: space-between;\n    margin: 10px 0;\n    width: 100%;\n  }\n  .oppia-pagination-button {\n    background-color: transparent;\n    border: none;\n    box-sizing: border-box;\n    color: #000;\n    font-size: 18px;\n    font-weight: bold;\n    min-height: 40px;\n    min-width: 100px;\n    text-align: center;\n  }\n  .oppia-pagination-button:hover {\n    border: 2px solid #000;\n    border-radius: 5px;\n  }\n  .oppia-pagination-button[disabled] {\n    color: #000;\n    opacity: 0.239;\n  }\n  .oppia-contributions-dropdown-arrow {\n    color: #009688;\n  }\n  .stats-contribution-type-mobile-container {\n    background-color: #fff;\n    display: none;\n    font-size: 20px;\n    margin-bottom: 3%;\n    padding: 0 20px;\n    width: 100%;\n  }\n  .mobile-stats-page {\n    margin-top: 30px;\n  }\n  .mobile-stats-data-container {\n    display: none;\n    font-size: 2.5vw;\n    padding-bottom: 10px;\n    padding-top: 10px;\n    width: 100%;\n  }\n  .mobile-stats-row {\n    display: flex;\n    margin-bottom: 5px;\n  }\n  .mobile-stats-name {\n    width: 50%;\n  }\n  .mobile-stats-data-container:not(:last-child) {\n    border-bottom: 1px solid #bbb;\n  }\n  .stats-column-name-container {\n    margin-left: auto;\n    margin-right: auto;\n    width: 75%;\n  }\n  .stats-data {\n    text-align: center;\n  }\n  .stats-cards-container {\n    margin-top: 30px;\n  }\n  .stats-welcome-text-container {\n    color: #00645c;\n    display: inline-block;\n    font-family: \"Roboto\", Arial, sans-serif;\n    font-size: 24px;\n    height: 30%;\n    vertical-align: middle;\n    width: 65%;\n  }\n  .stats-contribution-type-container {\n    display: inline-block;\n    vertical-align: top;\n    width: 35%;\n  }\n  .stats-contribution-type-label {\n    font-size: 14px;\n    font-weight: bold;\n    margin-left: 65%;\n  }\n  .list-view-item {\n    background: #fff;\n    border: 1px solid #000;\n    box-shadow: none;\n    margin-top: 10px;\n  }\n  .dashboard-table {\n    font-size: 1.2vw;\n    margin-top: 40px;\n    width: 100%;\n  }\n  .dashboard-table .dashboard-table-headings {\n    border-bottom: 2px solid black;\n    padding-bottom: 0.7em;\n    text-align: center;\n  }\n\n  .dashboard-table .dashboard-table-headings p {\n    display: inline;\n  }\n  .dashboard-table #dashboard-table-headings-details {\n    display: inline-block;\n    text-align: left;\n    width: 100%;\n  }\n  .stats-row {\n    height: 50px;\n    text-align: left;\n    vertical-align: baseline;\n  }\n  .stats-row td {\n    padding-top: 15px;\n  }\n  .stats-row:not(:last-child) {\n    border-bottom: 1px solid #bbb;\n  }\n  .oppia-stats-type-selector-container {\n    background-color: #fff;\n    border-radius: 4px;\n    box-shadow: 0 0 4px rgba(0, 0, 0, 0.25);\n    cursor: pointer;\n    justify-content: space-between;\n    padding: 10px 20px;\n    position: relative;\n    vertical-align: top;\n  }\n  .oppia-stats-type-selector-inner-container {\n    display: flex;\n    flex: 1;\n    font-size: 16px;\n    justify-content: space-between;\n  }\n\n  .oppia-stats-type-selector-inner-container-arrow {\n    color: #009688;\n    cursor: pointer;\n    padding-top: 3px;\n  }\n  .oppia-stats-type-selector-dropdown-container {\n    background-color: #fff;\n    border-radius: 4px;\n    box-shadow: 0 0 4px rgba(0, 0, 0, 0.25);\n    height: auto;\n    left: 0;\n    overflow-y: scroll;\n    padding: 8px 12px;\n    position: absolute;\n    right: 0;\n    top: 100%;\n    z-index: 1;\n  }\n  .oppia-stats-type-selector-dropdown-container::-webkit-scrollbar {\n    width: 7px;\n  }\n  .oppia-stats-type-selector-dropdown-container::-webkit-scrollbar-track {\n    border-radius: 5px;\n    box-shadow: inset 0 0 3px #808080;\n  }\n  .oppia-stats-type-selector-dropdown-container::-webkit-scrollbar-thumb {\n    background: #808080;\n    border-radius: 5px;\n    transition: background 0.5s ease;\n  }\n  .oppia-stats-type-selector-dropdown-container::-webkit-scrollbar-thumb:hover {\n    background: black;\n  }\n  .oppia-stats-type-selector-dropdown-option {\n    color: rgb(104, 104, 104);\n    display: flex;\n    flex: 1;\n    margin-left: 16px;\n    padding: 8px;\n  }\n  .oppia-stats-type-selector-dropdown-option-selected,\n  .oppia-stats-type-selector-dropdown-option:hover {\n    background-color: rgb(238, 238, 238);\n    border-radius: 4px;\n  }\n  @media (min-width: 700px) {\n    .stats-container {\n      margin-left: 50px;\n    }\n  }\n  @media only screen and (max-width: 700px) {\n    .list-view-item {\n      margin-bottom: 30px;\n    }\n    .stats-welcome-text-container {\n      width: 100%;\n    }\n    .stats-contribution-type-label {\n      display: none;\n    }\n    .stats-contribution-type-container {\n      display: none;\n    }\n    .dropdown-label {\n      color: #4a4a4a;\n      font-size: 18px;\n      margin-right: 10px;\n      width: 175px;\n    }\n    .stats-contribution-type-mobile-container {\n      align-items: center;\n      display: flex;\n      justify-content: space-between;\n      margin-bottom: 10px;\n      margin-left: calc(-50vw + 50% + 0px);\n      padding-bottom: 30px;\n      padding-top: 5px;\n      width: 100vw;\n    }\n    .dashboard-table {\n      display: none;\n    }\n    .mobile-stats-data-container {\n      display: table;\n    }\n    .oppia-contribution-stats-type-selector-mobile-container {\n      background-color: #fff;\n      border-radius: 4px;\n      box-shadow: 0 0 4px rgba(0, 0, 0, 0.25);\n      cursor: pointer;\n      display: inline-block;\n      justify-content: space-between;\n      padding: 10px 20px;\n      position: relative;\n      width: 100%;\n    }\n    .stats-column-name-container {\n      font-size: 12px;\n    }\n    .stats-data {\n      font-size: 12px;\n    }\n    .oppia-stats-type-selector-inner-container {\n      font-size: 20px;\n    }\n  }\n  @media only screen and (max-width: 420px) {\n    .dropdown-label {\n      font-size: 18px;\n      margin-right: 2vw;\n      width: 100px;\n    }\n    .oppia-contribution-stats-type-selector-mobile-container {\n      background-color: #fff;\n      border-radius: 4px;\n      box-shadow: 0 0 4px rgba(0, 0, 0, 0.25);\n      cursor: pointer;\n      display: inline-block;\n      justify-content: space-between;\n      padding: 10px 20px;\n      position: relative;\n      width: 100%;\n    }\n    .stats-column-name-container {\n      font-size: 10px;\n    }\n    .stats-data {\n      font-size: 10px;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/contributor-stats/contributor-stats.component.spec.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for ContributorStatsComponent.\n */\n\nimport { ComponentFixture, fakeAsync, flush, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { NO_ERRORS_SCHEMA } from '@angular/core';\nimport { UserService } from 'services/user.service';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { UserInfo } from 'domain/user/user-info.model';\nimport { ContributorStatsComponent } from './contributor-stats.component';\nimport { ContributionAndReviewStatsService } from '../services/contribution-and-review-stats.service';\nimport { LanguageUtilService } from 'domain/utilities/language-util.service';\nimport { NgbActiveModal, NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';\nimport { CertificateDownloadModalComponent } from '../modal-templates/certificate-download-modal.component';\n\ndescribe('Contributor stats component', () => {\n  let fetchAllContributionAndReviewStatsAsync: jasmine.Spy;\n  const userContributionRights = {\n    can_review_translation_for_language_codes: ['en', 'pt', 'hi'],\n    can_review_voiceover_for_language_codes: ['en', 'pt', 'hi'],\n    can_review_questions: true,\n    can_suggest_questions: true,\n  };\n  const translationContributionStatTopic1 = {\n    language_code: 'es',\n    topic_name: 'topic_1',\n    submitted_translations_count: 2,\n    submitted_translation_word_count: 100,\n    accepted_translations_count: 1,\n    accepted_translations_without_reviewer_edits_count: 0,\n    accepted_translation_word_count: 50,\n    rejected_translations_count: 0,\n    rejected_translation_word_count: 0,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n  const translationContributionStatTopic2 = {\n    language_code: 'es',\n    topic_name: 'topic_2',\n    submitted_translations_count: 2,\n    submitted_translation_word_count: 100,\n    accepted_translations_count: 1,\n    accepted_translations_without_reviewer_edits_count: 0,\n    accepted_translation_word_count: 50,\n    rejected_translations_count: 0,\n    rejected_translation_word_count: 0,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n  const translationReviewStatTopic1 = {\n    language_code: 'es',\n    topic_name: 'topic_2',\n    reviewed_translations_count: 1,\n    reviewed_translation_word_count: 1,\n    accepted_translations_count: 1,\n    accepted_translations_with_reviewer_edits_count: 0,\n    accepted_translation_word_count: 1,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n  const translationReviewStatTopic2 = {\n    language_code: 'es',\n    topic_name: 'topic_2',\n    reviewed_translations_count: 1,\n    reviewed_translation_word_count: 1,\n    accepted_translations_count: 1,\n    accepted_translations_with_reviewer_edits_count: 0,\n    accepted_translation_word_count: 1,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n  const questionContributionStat = {\n    topic_name: 'published_topic_name',\n    submitted_questions_count: 1,\n    accepted_questions_count: 1,\n    accepted_questions_without_reviewer_edits_count: 0,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n  const questionReviewStat = {\n    topic_name: 'published_topic_name',\n    reviewed_questions_count: 1,\n    accepted_questions_count: 1,\n    accepted_questions_with_reviewer_edits_count: 1,\n    first_contribution_date: 'Mar 2021',\n    last_contribution_date: 'Mar 2021'\n  };\n\n  const fetchAllStatsResponse = {\n    translation_contribution_stats: [\n      translationContributionStatTopic1, translationContributionStatTopic2],\n    translation_review_stats: [\n      translationReviewStatTopic1, translationReviewStatTopic2],\n    question_contribution_stats: [questionContributionStat],\n    question_review_stats: [questionReviewStat]\n  };\n  let component: ContributorStatsComponent;\n  let fixture: ComponentFixture<ContributorStatsComponent>;\n  let contributionAndReviewStatsService: ContributionAndReviewStatsService;\n  let languageUtilService: LanguageUtilService;\n  let userService: UserService;\n  let modalService: NgbModal;\n  let certificateModal: NgbModalRef;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      declarations: [\n        ContributorStatsComponent,\n        CertificateDownloadModalComponent\n      ],\n      providers: [\n        ContributionAndReviewStatsService,\n        LanguageUtilService,\n        UserService,\n        NgbModal,\n        NgbActiveModal\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n  }));\n\n  beforeEach(waitForAsync(() => {\n    fixture = TestBed.createComponent(ContributorStatsComponent);\n    component = fixture.componentInstance;\n\n    contributionAndReviewStatsService = TestBed.inject(\n      ContributionAndReviewStatsService);\n    certificateModal = TestBed.createComponent(\n      CertificateDownloadModalComponent) as unknown as NgbModalRef;\n    languageUtilService = TestBed.inject(LanguageUtilService);\n    userService = TestBed.inject(UserService);\n    modalService = TestBed.inject(NgbModal);\n    spyOn(modalService, 'open').and.returnValue(certificateModal);\n\n    fetchAllContributionAndReviewStatsAsync = spyOn(\n      contributionAndReviewStatsService,\n      'fetchAllStats');\n    fetchAllContributionAndReviewStatsAsync.and.returnValue(\n      Promise.resolve(fetchAllStatsResponse));\n    spyOn(\n      languageUtilService, 'getAudioLanguageDescription')\n      .and.returnValue('audio_language_description');\n\n    fixture.detectChanges();\n\n    component.type = 'translationContribution';\n  }));\n\n  afterEach(() => {\n    fixture.destroy();\n  });\n\n  describe('when user navigates to contributor stats page ', () => {\n    beforeEach(waitForAsync(() => {\n      spyOn(userService, 'getUserInfoAsync')\n        .and.returnValue(Promise.resolve({\n          isLoggedIn: () => true,\n          getUsername: () => 'user'\n        } as UserInfo));\n      spyOn(userService, 'getUserContributionRightsDataAsync')\n        .and.returnValue(Promise.resolve(userContributionRights));\n      component.ngOnInit();\n    }));\n\n    it('should show translation contribution stats', fakeAsync(() => {\n      component.selectOption('translationContribution');\n\n      expect(component.dropdownShown).toBeFalse;\n      expect(component.selectedContributionType).toEqual(\n        'Translation Contributions');\n    }));\n\n    it('should show translation review stats', fakeAsync(() => {\n      component.selectOption('translationReview');\n\n      expect(component.dropdownShown).toBeFalse;\n      expect(component.selectedContributionType).toEqual(\n        'Translation Reviews');\n    }));\n\n    it('should show question contribution stats', fakeAsync(() => {\n      component.selectOption('questionContribution');\n\n      expect(component.dropdownShown).toBeFalse;\n      expect(component.selectedContributionType).toEqual(\n        'Question Contributions');\n    }));\n\n    it('should show question review stats', fakeAsync(() => {\n      component.selectOption('questionReview');\n\n      expect(component.dropdownShown).toBeFalse;\n      expect(component.selectedContributionType).toEqual(\n        'Question Reviews');\n    }));\n\n    it('should open date range selecting model to generate certificate for' +\n      ' contributors',\n    fakeAsync(() => {\n      component.openCertificateDownloadModal('add_question', '');\n      tick();\n      expect(modalService.open).toHaveBeenCalled();\n    }));\n\n    it('should be able to page stats', fakeAsync(() => {\n      const pagedStats = {\n        currentPageStartIndex: 0,\n        data: [\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          },\n        ]\n      };\n\n      component.goToNextPage(pagedStats);\n      expect(pagedStats.currentPageStartIndex).toBe(5);\n\n      component.goToPreviousPage(pagedStats);\n      expect(pagedStats.currentPageStartIndex).toBe(0);\n    }));\n\n    it('should throw errors when there are no more pages', fakeAsync(() => {\n      const pagedStats = {\n        currentPageStartIndex: 0,\n        data: [\n          {\n            firstContributionDate: 'Mar 2020',\n            lastContributionDate: 'Mar 2022',\n            topicName: 'Dummy Topic',\n            acceptedCards: 1,\n            acceptedWordCount: 1\n          }\n        ]\n      };\n\n      expect(() => {\n        component.goToNextPage(pagedStats);\n      }).toThrowError('There are no more pages after this one.');\n      expect(() => {\n        component.goToPreviousPage(pagedStats);\n      }).toThrowError('There are no more pages before this one.');\n    }));\n\n    it('should provide 0 to get original order of keyvaluea', fakeAsync(() => {\n      expect(component.provideOriginalOrder()).toEqual(0);\n    }));\n  });\n\n  describe('when user navigates to contributor stats page without login',\n    () => {\n      it('should throw error if username is invalid',\n        fakeAsync(() => {\n          const defaultUserInfo = new UserInfo(\n            ['GUEST'], false, false, false, false, false,\n            null, null, null, false);\n          spyOn(userService, 'getUserInfoAsync').and\n            .returnValue(Promise.resolve(defaultUserInfo));\n\n          expect(() => {\n            component.ngOnInit();\n            tick();\n          }).toThrowError();\n          flush();\n        }));\n    });\n\n  describe('when user contribution rights can not be fetched',\n    () => {\n      it('should throw error to mention the error',\n        fakeAsync(() => {\n          spyOn(userService, 'getUserInfoAsync')\n            .and.returnValue(Promise.resolve({\n              isLoggedIn: () => true,\n              getUsername: () => 'user'\n            } as UserInfo));\n          spyOn(userService, 'getUserContributionRightsDataAsync')\n            .and.returnValue(Promise.resolve(null));\n\n          expect(() => {\n            component.ngOnInit();\n            tick();\n          }).toThrowError();\n          flush();\n        }));\n    });\n\n  describe('when user interacts with dropdown',\n    () => {\n      let getDropdownOptionsContainer: () => HTMLElement;\n\n      beforeEach(() => {\n        getDropdownOptionsContainer = () => {\n          return fixture.debugElement.nativeElement.querySelector(\n            '.oppia-stats-type-selector-dropdown-container');\n        };\n      });\n\n      it('should correctly show and hide when clicked away',\n        fakeAsync(() => {\n          let fakeClickAwayEvent = new MouseEvent('click');\n          Object.defineProperty(\n            fakeClickAwayEvent,\n            'target',\n            {value: document.createElement('div')});\n\n          component.onDocumentClick(fakeClickAwayEvent);\n          fixture.detectChanges();\n\n          expect(component.dropdownShown).toBe(false);\n          expect(getDropdownOptionsContainer()).toBeFalsy();\n        }));\n\n      it('should correctly show and hide correctly',\n        fakeAsync(() => {\n          expect(component.dropdownShown).toBe(false);\n          expect(component.mobileDropdownShown).toBe(false);\n\n          component.toggleDropdown();\n          expect(component.dropdownShown).toBe(true);\n\n          component.toggleDropdown();\n          expect(component.dropdownShown).toBe(false);\n\n          component.toggleMobileDropdown();\n          expect(component.mobileDropdownShown).toBe(true);\n\n          component.toggleMobileDropdown();\n          expect(component.mobileDropdownShown).toBe(false);\n        }));\n    });\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/contributor-stats/contributor-stats.component.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the contribution stats view.\n */\n\nimport { Component, ElementRef, HostListener, Injector, Input, ViewChild } from '@angular/core';\nimport { downgradeComponent } from '@angular/upgrade/static';\n\nimport { ContributionAndReviewStatsService, QuestionContributionBackendDict, QuestionReviewBackendDict, TranslationContributionBackendDict, TranslationReviewBackendDict } from '../services/contribution-and-review-stats.service';\nimport { UserService } from 'services/user.service';\nimport { LanguageUtilService } from 'domain/utilities/language-util.service';\nimport { AppConstants } from 'app.constants';\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\nimport { CertificateDownloadModalComponent } from '../modal-templates/certificate-download-modal.component';\n\ninterface Option {\n  contributionType: string;\n  displayName: string;\n}\n\nclass PageableStats {\n  currentPageStartIndex: number;\n  data: (\n    TranslationContributionStats | TranslationReviewStats |\n    QuestionContributionStats | QuestionReviewStats)[];\n\n  constructor(\n      data: (\n      TranslationContributionStats | TranslationReviewStats |\n      QuestionContributionStats | QuestionReviewStats)[]) {\n    this.data = data;\n    this.currentPageStartIndex = 0;\n  }\n}\n\ninterface Stat {\n  topicName: string;\n  firstContributionDate: string;\n  lastContributionDate: string;\n}\n\ninterface TranslationContributionStats extends Stat {\n  acceptedCards: number;\n  acceptedWordCount: number;\n}\n\ninterface TranslationReviewStats extends Stat {\n  acceptedCards: number;\n  acceptedWordCount: number;\n  reviewedCards: number;\n  reviewedWordCount: number;\n}\n\ninterface QuestionContributionStats extends Stat {\n  acceptedQuestions: number;\n  acceptedQuestionsWithoutEdits: number;\n}\n\ninterface QuestionReviewStats extends Stat {\n  reviewedQuestions: number;\n  acceptedQuestions: number;\n}\n\n@Component({\n  selector: 'contributor-stats',\n  templateUrl: './contributor-stats.component.html',\n  styleUrls: []\n})\nexport class ContributorStatsComponent {\n  @Input() type!: string;\n  @ViewChild('dropdown', {'static': false}) dropdownRef!: ElementRef;\n  @ViewChild('mobileDropdown', {'static': false}) mobileDropdownRef!:\n    ElementRef;\n\n  dropdownShown: boolean = false;\n  mobileDropdownShown: boolean = false;\n  selectedContributionType: string | undefined = '';\n  username: string = '';\n  ITEMS_PER_PAGE: number = 5;\n\n  userCanReviewTranslationSuggestions: boolean = false;\n  userCanReviewQuestionSuggestions: boolean = false;\n  userCanSuggestQuestions: boolean = false;\n\n  COLUMNS = {\n    translationContribution: {\n      months: 'Months',\n      topicNames: 'Topic Names',\n      acceptedCards: 'Accepted Cards',\n      acceptedWordCount: 'Accepted Word Count'\n    },\n    translationReview: {\n      months: 'Months',\n      topicNames: 'Topic Names',\n      reviewedCards: 'Reviewed Cards',\n      reviewedWordCount: 'Reviewed Word Count',\n      acceptedCards: 'Accepted Cards',\n      acceptedWordCount: 'Accepted Word Count'\n    },\n    questionContribution: {\n      months: 'Months',\n      topicNames: 'Topic Names',\n      acceptedQuestions: 'Accepted Questions',\n      acceptedQuestionsWithoutEdits: 'Accepted Questions Without Edits'\n    },\n    questionReview: {\n      months: 'Months',\n      topicNames: 'Topic Names',\n      reviewedQuestions: 'Reviewed Questions',\n      acceptedQuestions: 'Accepted Questions'\n    }\n  };\n\n  translationContributionOption: Option = {\n    displayName:\n      AppConstants.CONTRIBUTION_STATS_TYPES\n        .TRANSLATION_CONTRIBUTION.DISPLAY_NAME,\n    contributionType:\n     AppConstants.CONTRIBUTION_STATS_TYPES.TRANSLATION_CONTRIBUTION.NAME\n  };\n\n  translationReviewOption: Option = {\n    displayName:\n      AppConstants.CONTRIBUTION_STATS_TYPES.TRANSLATION_REVIEW.DISPLAY_NAME,\n    contributionType:\n     AppConstants.CONTRIBUTION_STATS_TYPES.TRANSLATION_REVIEW.NAME\n  };\n\n  questionContributionOption: Option = {\n    displayName:\n      AppConstants.CONTRIBUTION_STATS_TYPES.QUESTION_CONTRIBUTION.DISPLAY_NAME,\n    contributionType:\n     AppConstants.CONTRIBUTION_STATS_TYPES.QUESTION_CONTRIBUTION.NAME\n  };\n\n  questionReviewOption: Option = {\n    displayName:\n      AppConstants.CONTRIBUTION_STATS_TYPES.QUESTION_REVIEW.DISPLAY_NAME,\n    contributionType:\n     AppConstants.CONTRIBUTION_STATS_TYPES.QUESTION_REVIEW.NAME\n  };\n\n  options: Option[] = [\n    this.translationContributionOption\n  ];\n\n  statsData: {\n    translationContribution: Map<string, PageableStats>;\n    translationReview: Map<string, PageableStats>;\n    questionContribution?: PageableStats;\n    questionReview?: PageableStats;\n  } = {\n      translationContribution: new Map<string, PageableStats>(),\n      translationReview: new Map<string, PageableStats>()\n    };\n\n  constructor(\n    public readonly languageUtilService: LanguageUtilService,\n    private readonly contributionAndReviewStatsService:\n        ContributionAndReviewStatsService,\n    private readonly userService: UserService,\n    private readonly modalService: NgbModal,\n    private readonly injector: Injector) {\n  }\n\n  async ngOnInit(): Promise<void> {\n    const userInfo = await this.userService.getUserInfoAsync();\n    const username = userInfo.getUsername();\n\n    if (username === null) {\n      throw new Error('Cannot fetch username.');\n    }\n    this.username = username;\n    const currentOption = this.options.find(\n      (option) => option.contributionType === this.type);\n    this.selectedContributionType = currentOption?.displayName;\n\n    const userContributionRights =\n      await this.userService.getUserContributionRightsDataAsync();\n\n    if (userContributionRights === null) {\n      throw new Error('Cannot fetch user contribution rights.');\n    }\n    const reviewableLanguageCodes = (\n      userContributionRights.can_review_translation_for_language_codes);\n    this.userCanReviewTranslationSuggestions = (\n      reviewableLanguageCodes.length > 0);\n    this.userCanReviewQuestionSuggestions = (\n      userContributionRights.can_review_questions);\n    this.userCanSuggestQuestions = (\n      userContributionRights.can_suggest_questions);\n\n    if (this.userCanReviewTranslationSuggestions) {\n      this.options.push(this.translationReviewOption);\n    }\n    if (this.userCanSuggestQuestions) {\n      this.options.push(this.questionContributionOption);\n    }\n    if (this.userCanReviewQuestionSuggestions) {\n      this.options.push(this.questionReviewOption);\n    }\n\n    await this.fetchStats();\n  }\n\n  toggleDropdown(): void {\n    this.dropdownShown = !this.dropdownShown;\n  }\n\n  toggleMobileDropdown(): void {\n    this.mobileDropdownShown = !this.mobileDropdownShown;\n  }\n\n  async selectOption(contributionType: string): Promise<void> {\n    this.type = contributionType;\n    const currentOption = this.options.find(\n      (option) => option.contributionType === contributionType);\n    this.selectedContributionType = currentOption?.displayName;\n    this.dropdownShown = false;\n    this.mobileDropdownShown = false;\n  }\n\n  async fetchStats(): Promise<void> {\n    const response = await this.contributionAndReviewStatsService.fetchAllStats(\n      this.username);\n\n    if (response.translation_contribution_stats.length > 0) {\n      response.translation_contribution_stats.map((stat) => {\n        const translationContributionStatsData = this\n          .statsData.translationContribution.get(stat.language_code);\n        if (translationContributionStatsData === undefined) {\n          this.statsData?.translationContribution.set(\n            stat.language_code,\n            new PageableStats([this.createTranslationContributionStat(stat)]));\n        } else {\n          translationContributionStatsData.data?.push(\n            this.createTranslationContributionStat(stat));\n          this.statsData?.translationContribution.set(\n            stat.language_code,\n            translationContributionStatsData\n          );\n        }\n      });\n    }\n\n    if (response.translation_review_stats.length > 0) {\n      response.translation_review_stats.map((stat) => {\n        const translationReviewStatsData = this\n          .statsData.translationReview.get(stat.language_code);\n        if (translationReviewStatsData === undefined) {\n          this.statsData.translationReview.set(\n            stat.language_code,\n            new PageableStats([this.createTranslationReviewStat(stat)]));\n        } else {\n          translationReviewStatsData.data?.push(\n            this.createTranslationReviewStat(stat));\n          this.statsData?.translationReview.set(\n            stat.language_code,\n            translationReviewStatsData\n          );\n        }\n      });\n    }\n\n    if (response.question_contribution_stats.length > 0) {\n      this.statsData.questionContribution = new PageableStats(\n        response.question_contribution_stats.map((stat) => {\n          return this.createQuestionContributionStat(stat);\n        })\n      );\n    }\n\n    if (response.question_review_stats.length > 0) {\n      this.statsData.questionReview = new PageableStats(\n        response.question_review_stats.map((stat) => {\n          return this.createQuestionReviewStat(stat);\n        })\n      );\n    }\n  }\n\n  createTranslationContributionStat(\n      stat: TranslationContributionBackendDict\n  ): TranslationContributionStats {\n    return {\n      firstContributionDate: stat.first_contribution_date,\n      lastContributionDate: stat.last_contribution_date,\n      topicName: stat.topic_name,\n      acceptedCards: stat.accepted_translations_count,\n      acceptedWordCount: stat.accepted_translation_word_count\n    };\n  }\n\n  createTranslationReviewStat(\n      stat: TranslationReviewBackendDict\n  ): TranslationReviewStats {\n    return {\n      firstContributionDate: stat.first_contribution_date,\n      lastContributionDate: stat.last_contribution_date,\n      topicName: stat.topic_name,\n      acceptedCards: stat.accepted_translations_count,\n      acceptedWordCount: stat.accepted_translation_word_count,\n      reviewedCards: stat.reviewed_translations_count,\n      reviewedWordCount: stat.reviewed_translation_word_count\n    };\n  }\n\n  createQuestionContributionStat(\n      stat: QuestionContributionBackendDict\n  ): QuestionContributionStats {\n    return {\n      firstContributionDate: stat.first_contribution_date,\n      lastContributionDate: stat.last_contribution_date,\n      topicName: stat.topic_name,\n      acceptedQuestions: stat.accepted_questions_count,\n      acceptedQuestionsWithoutEdits: (\n        stat.accepted_questions_without_reviewer_edits_count)\n    };\n  }\n\n  createQuestionReviewStat(\n      stat: QuestionReviewBackendDict\n  ): QuestionReviewStats {\n    return {\n      firstContributionDate: stat.first_contribution_date,\n      lastContributionDate: stat.last_contribution_date,\n      topicName: stat.topic_name,\n      reviewedQuestions: stat.reviewed_questions_count,\n      acceptedQuestions: stat.accepted_questions_count\n    };\n  }\n\n  goToNextPage(page: PageableStats): void {\n    if (\n      page.currentPageStartIndex + this.ITEMS_PER_PAGE >=\n      page.data?.length) {\n      throw new Error('There are no more pages after this one.');\n    }\n    page.currentPageStartIndex += this.ITEMS_PER_PAGE;\n  }\n\n  goToPreviousPage(page: PageableStats): void {\n    if (page.currentPageStartIndex === 0) {\n      throw new Error('There are no more pages before this one.');\n    }\n    page.currentPageStartIndex -= this.ITEMS_PER_PAGE;\n  }\n\n  // This method gives the original order of the key value pairs that is\n  // displayed in the template. We could have used keyvalue: 0 instead of\n  // returning from this function, but it gives console errors.\n  // Reference: https://stackoverflow.com/a/52794221\n  // We need to return a non-negative constant number in order to preserve\n  // original column property order. There is no specific reason to return 0,\n  // since any other any other positive value should also give the preferred\n  // order.\n  provideOriginalOrder(): number {\n    return 0;\n  }\n\n  openCertificateDownloadModal(\n      suggestionType: string, languageCode: string | null\n  ): void {\n    const modalRef = this.modalService.open(\n      CertificateDownloadModalComponent, {\n        size: 'lg',\n        backdrop: 'static',\n        injector: this.injector\n      });\n    modalRef.componentInstance.suggestionType = suggestionType;\n    modalRef.componentInstance.username = this.username;\n    modalRef.componentInstance.languageCode = languageCode;\n  }\n\n  /**\n   * Close dropdown when outside elements are clicked\n   * @param event mouse click event\n   */\n  @HostListener('document:click', ['$event'])\n  onDocumentClick(event: MouseEvent): void {\n    const targetElement = event.target as HTMLElement;\n    if (\n      targetElement &&\n      !this.dropdownRef.nativeElement.contains(targetElement)\n    ) {\n      this.dropdownShown = false;\n    }\n    if (\n      targetElement &&\n      !this.mobileDropdownRef.nativeElement.contains(targetElement)\n    ) {\n      this.mobileDropdownShown = false;\n    }\n  }\n}\n\nangular.module('oppia').directive(\n  'oppiaOpportunitiesList', downgradeComponent(\n    {component: ContributorStatsComponent}));\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/certificate-download-modal.component.html",
      "content": "<div class=\"oppia-translate-text-header-container\">\n  <div class=\"oppia-translate-text-header\">\n    <div class=\"oppia-opportunities-details\">\n      <div class=\"oppia-opportunities-heading\">\n        Select the time range\n      </div>\n      <button type=\"button\"\n              class=\"close oppia-close-button-position\"\n              (click)=\"close()\"\n              attr.aria-label=\"Close\">\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  </div>\n</div>\n<div class=\"modal-body\">\n  <div *ngIf=\"!certificateDownloading\">\n    <div class=\"datepicker-container\">\n      <div class=\"date-label\">From:</div>\n      <input class=\"datepicker\" type=\"date\" [(ngModel)]=\"fromDate\">\n    </div>\n    <div class=\"datepicker-container\">\n      <div class=\"date-label\">To:</div>\n      <input class=\"datepicker\" type=\"date\"[(ngModel)]=\"toDate\">\n    </div>\n    <div class=\"datepicker-container\" *ngIf=\"errorsFound\">\n      <span class=\"date-range-error\">{{errorMessage}}</span>\n    </div>\n  </div>\n  <div *ngIf=\"certificateDownloading\" class=\"loader\"></div>\n  <div *ngIf=\"certificateDownloading\" class=\"certficate-generation-await\">\n    Generating certificate for time range {{fromDate}} to {{toDate}}. Please wait.\n  </div>\n</div>\n<div class=\"oppia-translate-modal-footer modal-footer\">\n  <button class=\"btn btn-default\" (click)=\"close()\">\n    Cancel\n  </button>\n  <button [disabled]=\"certificateDownloading || disableDownloadButton()\"\n          class=\"btn btn-success oppia-upload-translated-text-button\"\n          (click)=\"downloadCertificate()\">\n    <i [hidden]=\"!certificateDownloading\" class=\"fa fa-spinner\"></i>\n    <span>\n      Download\n    </span>\n  </button>\n</div>\n<style>\n  .certficate-generation-await {\n    font-size: 20px;\n    text-align: center;\n  }\n  .date-range-error {\n    color: red;\n  }\n  .datepicker-container {\n    margin: auto;\n    margin-bottom: 10px;\n    margin-top: 10px;\n    width: 60%\n  }\n  .date-label {\n    float: left;\n    width: 25%;\n  }\n  .datepicker {\n    width: 75%;\n  }\n  .oppia-collapse-content {\n    display: none;\n  }\n  .oppia-translate-modal-footer {\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-end;\n  }\n  .oppia-translate-text-header-container .oppia-opportunities-heading {\n    display: block;\n    font-size: 20px;\n  }\n  .oppia-translate-text-header-container .oppia-mobile-opportunities-heading {\n    display: none;\n  }\n  .oppia-translate-text-header-container .oppia-opportunities-subheading {\n    color: #009688;\n    display: block;\n    font-size: 14px;\n    height: 40%;\n    width: 100%;\n  }\n  .oppia-translate-text-header-container .oppia-mobile-opportunities-subheading {\n    color: #009688;\n    display: none;\n    font-size: 14px;\n    height: 40%;\n    width: 100%;\n  }\n  .oppia-translate-text-header-container .oppia-opportunities-details {\n    display: flex;\n    flex-direction: column;\n    margin: 1.8% 0;\n    width: 95%;\n  }\n  .oppia-translate-text-header-container {\n    border-bottom: 1px solid #e5e5e5;\n    padding-left: 15px;\n  }\n  .oppia-translate-text-header,\n  .oppia-translatable-text-section {\n    display: flex;\n    justify-content: space-between;\n  }\n  .oppia-translate-rule-list {\n    margin-bottom: 0;\n    margin-top: 10px;\n    padding-left: 20px;\n  }\n  .oppia-rules-translation-tip {\n    color: #757575;\n  }\n  .oppia-loading-text {\n    height: 40px;\n    width: 100%;\n  }\n  .oppia-loading-text1 {\n    height: 50%;\n    width: 60%;\n  }\n  .oppia-loading-text2 {\n    height: 50%;\n    width: 40%;\n  }\n  .oppia-translation-editor-section {\n    padding: 20px 0;\n    word-wrap: break-word;\n  }\n  .oppia-text-to-translate-container {\n    border: 1px solid #ccc;\n    margin: 15px 0;\n    margin-bottom: 0;\n    padding: 20px;\n  }\n  .oppia-rules-to-translate-container {\n    border: 1px solid #ccc;\n    border-radius: 5px;\n    margin: 0 15px 0 0;\n    padding: 20px;\n  }\n  .oppia-translation-tips-container {\n    background-color: #eee;\n    border: 1px solid #eee;\n    margin: 15px 0;\n    padding: 20px;\n  }\n  .oppia-skip-button {\n    color: #ababab;\n    margin-left: 5%;\n  }\n  .oppia-close-button-position {\n    font-size: 2.5rem;\n    position: absolute;\n    right: 20px;\n    top: 12px;\n  }\n  .oppia-rte-editor-focused:focus > p {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > ol {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > ul {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > pre {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > blockquote {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > oppia-noninteractive-tabs > div {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > oppia-noninteractive-collapsible > uib-accordion > div {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > oppia-noninteractive-image > figure {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused:focus > oppia-noninteractive-video > center {\n    outline: solid 2px #009688;\n  }\n  .oppia-rte-editor-focused *:hover {\n    background-color: rgba(233, 241, 242);\n  }\n  .oppia-translation-error-section {\n    color: red;\n  }\n  .loader {\n    animation: spinner 4s linear infinite;\n    border: 10px solid #e0e0e0;\n    border-radius: 50%;\n    border-top: 10px solid #00645c;\n    height: 100px;\n    margin: auto;\n    width: 100px;\n  }\n\n  @keyframes spinner {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n\n  @media screen and (max-width: 700px) {\n    .oppia-container-expanded {\n      height: fit-content;\n      max-height: none;\n      overflow-y: hidden;\n    }\n    .oppia-container-contracted {\n      max-height: 30vh;\n      overflow-y: scroll;\n    }\n    .oppia-collapse-content {\n      background-color: #016a5d;\n      color: white;\n      cursor: pointer;\n      display: block;\n      font-size: 12px;\n      font-weight: bold;\n      margin: auto;\n      padding: 5px 10px;\n      position: relative;\n      text-align: center;\n      text-transform: uppercase;\n      top: -13px;\n      width: 85px;\n    }\n    .oppia-translate-text-header-container {\n      display: none;\n    }\n    .oppia-translate-text-header-container .oppia-mobile-opportunities-heading {\n      display: block;\n      font-size: 18px;\n    }\n    .oppia-translatable-text-section {\n      font-size: 16px;\n    }\n    .oppia-text-to-translate-container {\n      font-size: 16px;\n    }\n  }\n\n  @media screen and (max-width: 370px) {\n    .oppia-translate-text-header-container .oppia-opportunities-subheading {\n      display: none;\n    }\n    .oppia-translate-text-header-container .oppia-mobile-opportunities-subheading {\n      display: block;\n    }\n  }\n\n  @media screen and (max-width: 330px) {\n    .oppia-translate-modal-footer {\n      align-items: flex-end;\n      flex-direction: column;\n    }\n    .oppia-translate-modal-footer button {\n      margin: 5px;\n    }\n  }\n</style>\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/certificate-download-modal.component.spec.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for CertificateDownloadModalComponent.\n*/\n\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { ChangeDetectorRef, NO_ERRORS_SCHEMA } from '@angular/core';\n\nimport { ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { OppiaAngularRootComponent } from 'components/oppia-angular-root.component';\nimport { ContextService } from 'services/context.service';\nimport { WrapTextWithEllipsisPipe } from 'filters/string-utility-filters/wrap-text-with-ellipsis.pipe';\nimport { CertificateDownloadModalComponent } from './certificate-download-modal.component';\nimport { ContributionAndReviewService } from '../services/contribution-and-review.service';\nimport { AlertsService } from 'services/alerts.service';\nimport { ContributorCertificateResponse } from '../services/contribution-and-review-backend-api.service';\n\nclass MockChangeDetectorRef {\n  detectChanges(): void {}\n}\n\ndescribe('Contributor Certificate Download Modal Component', () => {\n  let activeModal: NgbActiveModal;\n  let httpTestingController: HttpTestingController;\n  let fixture: ComponentFixture<CertificateDownloadModalComponent>;\n  let component: CertificateDownloadModalComponent;\n  let changeDetectorRef: MockChangeDetectorRef = new MockChangeDetectorRef();\n  let contributionAndReviewService: ContributionAndReviewService;\n  let alertsService: AlertsService;\n  const certificateDataResponse: ContributorCertificateResponse = {\n    from_date: '1 Jan 2022',\n    to_date: '31 Oct 2022',\n    team_lead: 'Test User',\n    contribution_hours: 1.0,\n    language: 'Hindi'\n  };\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule\n      ],\n      declarations: [\n        CertificateDownloadModalComponent,\n        WrapTextWithEllipsisPipe\n      ],\n      providers: [\n        NgbActiveModal,\n        AlertsService,\n        {\n          provide: ChangeDetectorRef,\n          useValue: changeDetectorRef\n        }\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    }).compileComponents();\n    OppiaAngularRootComponent.contextService = TestBed.inject(ContextService);\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(CertificateDownloadModalComponent);\n    component = fixture.componentInstance;\n    component.suggestionType = 'translate_content';\n    component.username = 'test_user';\n    component.languageCode = 'hi';\n    component.fromDate = '2022/01/01';\n    component.toDate = '2022/12/31';\n    component = fixture.componentInstance;\n    httpTestingController = TestBed.inject(HttpTestingController);\n    activeModal = TestBed.inject(NgbActiveModal);\n    contributionAndReviewService = TestBed.inject(ContributionAndReviewService);\n    alertsService = TestBed.inject(AlertsService);\n    fixture.detectChanges();\n  });\n\n  it('should download translation submitter certificate when available', () => {\n    component.fromDate = '2022/01/01';\n    component.toDate = '2022/10/31';\n    spyOn(\n      contributionAndReviewService,\n      'downloadContributorCertificateAsync')\n      .and.returnValue(Promise.resolve(certificateDataResponse));\n    spyOn(alertsService, 'addInfoMessage').and.stub();\n\n    component.downloadCertificate();\n\n    expect(component.errorsFound).toBeFalse();\n    expect(\n      contributionAndReviewService.downloadContributorCertificateAsync\n    ).toHaveBeenCalled();\n  });\n\n  it('should download question submitter certificate when available', () => {\n    component.fromDate = '2022/01/01';\n    component.toDate = '2022/10/31';\n    component.suggestionType = 'add_question';\n    spyOn(\n      contributionAndReviewService,\n      'downloadContributorCertificateAsync')\n      .and.returnValue(Promise.resolve(certificateDataResponse));\n    spyOn(alertsService, 'addInfoMessage').and.stub();\n\n    component.downloadCertificate();\n\n    expect(component.errorsFound).toBeFalse();\n    expect(\n      contributionAndReviewService.downloadContributorCertificateAsync\n    ).toHaveBeenCalled();\n  });\n\n  it('should show error when contributions not found', fakeAsync(() => {\n    component.fromDate = '2022/01/01';\n    component.toDate = '2022/10/31';\n    spyOn(\n      contributionAndReviewService,\n      'downloadContributorCertificateAsync')\n      .and.returnValue(Promise.reject());\n\n    component.downloadCertificate();\n    tick();\n\n    expect(\n      contributionAndReviewService.downloadContributorCertificateAsync\n    ).toHaveBeenCalled();\n    expect(component.errorsFound).toBeTrue();\n    expect(component.errorMessage).toEqual(\n      'Not able to download contributor certificate');\n  }));\n\n  it('should show error for invalid to date', () => {\n    const today = new Date();\n    let tomorrow = new Date();\n    tomorrow.setDate(today.getDate() + 1);\n    component.fromDate = today.toDateString();\n    component.toDate = tomorrow.toDateString();\n\n    component.downloadCertificate();\n\n    expect(component.errorsFound).toBeTrue();\n    expect(component.errorMessage).toEqual(\n      'Please select a \\'To\\' date that is earlier than ' +\n      'today\\'s date'\n    );\n  });\n\n  it('should show error for invalid date ranges', () => {\n    const today = new Date();\n    let tomorrow = new Date();\n    tomorrow.setDate(today.getDate() + 1);\n    component.fromDate = tomorrow.toDateString();\n    component.toDate = today.toDateString();\n\n    component.downloadCertificate();\n\n    expect(component.errorsFound).toBeTrue();\n    expect(component.errorMessage).toEqual('Invalid date range.');\n  });\n\n  it('should close', () => {\n    spyOn(activeModal, 'close');\n    component.close();\n    expect(activeModal.close).toHaveBeenCalled();\n  });\n\n  it('should throw error when canvas context is null', () => {\n    spyOn(document, 'createElement').and.callFake(\n      jasmine.createSpy('createElement').and.returnValue(\n        {\n          width: 0,\n          height: 0,\n          getContext: (txt: string) => {\n            return null;\n          },\n        }\n      )\n    );\n\n    expect(() => {\n      component.createCertificate(certificateDataResponse);\n      tick();\n    }).toThrowError();\n  });\n\n  afterEach(() => {\n    httpTestingController.verify();\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/modal-templates/certificate-download-modal.component.ts",
      "content": "// Copyright 2022 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Component for the certificate download modal.\n */\n\nimport { Component, Input } from '@angular/core';\nimport { downgradeComponent } from '@angular/upgrade/static';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\nimport { AppConstants } from 'app.constants';\nimport { ContributorCertificateResponse } from '../services/contribution-and-review-backend-api.service';\nimport { ContributionAndReviewService } from '../services/contribution-and-review.service';\n\ninterface CertificateContentData {\n  text: string;\n  linePosition: number;\n}\n\n@Component({\n  selector: 'certificate-download-modal',\n  templateUrl: './certificate-download-modal.component.html'\n})\nexport class CertificateDownloadModalComponent {\n  @Input() suggestionType!: string;\n  @Input() username!: string;\n  @Input() languageCode!: string | null;\n  fromDate!: string;\n  toDate!: string;\n  errorMessage!: string;\n  errorsFound = false;\n  certificateDownloading = false;\n  datesSelected = false;\n\n  CERTIFICATE_WIDTH: number = 1500;\n  CERTIFICATE_HEIGHT: number = 1300;\n  CERTIFICATE_MID_POINT: number = 750;\n  CERTIFICATE_INNER_BOX_WIDTH: number = 1300;\n  CERTIFICATE_INNER_BOX_HEIGHT: number = 1100;\n  CANVAS_ROOT_COORDINATE: number = 0;\n  INNER_BOX_COORDINATE: number = 100;\n  LOGO_X_COORDINATE: number = 650;\n  LOGO_Y_COORDINATE: number = 150;\n  LOGO_WIDTH: number = 200;\n  LOGO_HEIGHT: number = 80;\n  SIGNATURE_BASE_COORDINATE: number = 400;\n  DATE_BASE_COORDINATE: number = 1100;\n  SIGNATURE_LINE_STARTING_POSITION: number = 300;\n  SIGNATURE_LINE_ENDING_POSITION: number = 500;\n  DATE_LINE_STARTING_POSITION: number = 1000;\n  DATE_LINE_ENDING_POSITION: number = 1200;\n\n  constructor(\n    private readonly activeModal: NgbActiveModal,\n    private contributionAndReviewService: ContributionAndReviewService) {\n  }\n\n  close(): void {\n    this.activeModal.close();\n  }\n\n  downloadCertificate(): void {\n    this.errorsFound = false;\n    this.errorMessage = '';\n    if (\n      !this.fromDate ||\n      !this.toDate ||\n      new Date(this.fromDate) >= new Date(this.toDate)\n    ) {\n      this.errorsFound = true;\n      this.errorMessage = 'Invalid date range.';\n      return;\n    }\n    if (new Date() < new Date(this.toDate)) {\n      this.errorsFound = true;\n      this.errorMessage = 'Please select a \\'To\\' date that is earlier than ' +\n        'today\\'s date';\n      return;\n    }\n    this.certificateDownloading = true;\n    this.contributionAndReviewService.downloadContributorCertificateAsync(\n      this.username,\n      this.suggestionType,\n      this.languageCode,\n      this.fromDate,\n      this.toDate\n    ).then((response: ContributorCertificateResponse) => {\n      this.createCertificate(response);\n      this.certificateDownloading = false;\n    }).catch(() => {\n      this.errorsFound = true;\n      this.certificateDownloading = false;\n      this.errorMessage = (\n        'Not able to download contributor certificate');\n    });\n  }\n\n  disableDownloadButton(): boolean {\n    return this.fromDate === undefined || this.toDate === undefined;\n  }\n\n  createCertificate(response: ContributorCertificateResponse): void {\n    const canvas = document.createElement('canvas');\n    const currentDate = new Date();\n    // Intl.DateTimeFormatOptions is used to enable language sensitive date\n    // formatting.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\n    const dateOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    };\n    // Textual parts are starting when y coordinate is equals to 350.\n    let linePosition = 350;\n    const image = new Image(this.LOGO_WIDTH, this.LOGO_HEIGHT);\n    image.src = AppConstants.CONTRIBUTOR_CERTIFICATE_LOGO;\n    canvas.width = this.CERTIFICATE_WIDTH;\n    canvas.height = this.CERTIFICATE_HEIGHT;\n    const ctx = canvas.getContext('2d');\n\n    if (ctx === null) {\n      throw new Error('Canvas context not found.');\n    }\n\n    image.onload = () => {\n      ctx.fillStyle = '#D0E1F0';\n      ctx.fillRect(\n        this.CANVAS_ROOT_COORDINATE,\n        this.CANVAS_ROOT_COORDINATE,\n        this.CERTIFICATE_WIDTH,\n        this.CERTIFICATE_HEIGHT\n      );\n\n      ctx.fillStyle = '#F7FDFF';\n      ctx.fillRect(\n        this.INNER_BOX_COORDINATE,\n        this.INNER_BOX_COORDINATE,\n        this.CERTIFICATE_INNER_BOX_WIDTH,\n        this.CERTIFICATE_INNER_BOX_HEIGHT\n      );\n\n      ctx.drawImage(\n        image,\n        this.LOGO_X_COORDINATE,\n        this.LOGO_Y_COORDINATE,\n        this.LOGO_WIDTH,\n        this.LOGO_HEIGHT\n      );\n\n      ctx.font = '37px Capriola';\n      ctx.fillStyle = '#00645C';\n      ctx.textAlign = 'center';\n      ctx.fillText(\n        'CERTIFICATE OF APPRECIATION',\n        this.CERTIFICATE_MID_POINT,\n        linePosition\n      );\n\n      ctx.font = '30px Capriola';\n      ctx.fillStyle = '#8F9899';\n      linePosition += 150;\n      ctx.fillText(\n        'WE GRATEFULLY ACKNOWLEDGE',\n        this.CERTIFICATE_MID_POINT,\n        linePosition\n      );\n\n      ctx.font = '40px Capriola';\n      ctx.fillStyle = '#00645C';\n      linePosition += 100;\n      ctx.fillText(this.username, this.CERTIFICATE_MID_POINT, linePosition);\n\n      ctx.font = '28px Capriola';\n      ctx.fillStyle = '#8F9899';\n      linePosition += 100;\n\n      if (this.suggestionType === 'translate_content') {\n        const certificateContentData: CertificateContentData[] = [\n          {\n            text: 'for their dedication and time in translating Oppia\\'s ' +\n            'basic maths lessons to ' + response.language,\n            linePosition: linePosition\n          },\n          {\n            text: 'which will help our ' + response.language + '-speaking ' +\n            'learners better understand the lessons.',\n            linePosition: linePosition += 40\n          },\n          {\n            text: 'This certificate confirms that ' + this.username +\n            ' has contributed ' + response.contribution_hours + ' hours ' +\n            'worth of',\n            linePosition: linePosition += 80\n          },\n          {\n            text: 'translations from ' + response.from_date + ' to ' +\n            response.to_date + '.',\n            linePosition: linePosition += 40\n          }\n        ];\n        this.fillCertificateContent(\n          ctx, certificateContentData\n        );\n        linePosition += 100;\n      } else {\n        const certificateContentData: CertificateContentData[] = [\n          {\n            text: 'for their dedication and time in contributing practice ' +\n            'questions to Oppia\\'s',\n            linePosition: linePosition\n          },\n          {\n            text: 'Math Classroom, which supports our mission of improving',\n            linePosition: linePosition += 40\n          },\n          {\n            text: 'access to quality education.',\n            linePosition: linePosition += 40\n          },\n          {\n            text: 'This certificate confirms that ' + this.username +\n            ' has contributed ' + response.contribution_hours + ' hours',\n            linePosition: linePosition += 80\n          },\n          {\n            text: `to Oppia from ${response.from_date} to ${response.to_date}.`,\n            linePosition: linePosition += 40\n          }\n        ];\n        this.fillCertificateContent(\n          ctx, certificateContentData\n        );\n        linePosition += 40;\n      }\n\n      ctx.font = '24px Brush Script MT';\n      ctx.fillStyle = '#000000';\n      linePosition += 100;\n      ctx.fillText(\n        response.team_lead,\n        this.SIGNATURE_BASE_COORDINATE,\n        linePosition\n      );\n\n      ctx.font = '24px Roboto';\n      ctx.fillText(\n        currentDate.toLocaleDateString('en-us', dateOptions),\n        this.DATE_BASE_COORDINATE,\n        linePosition\n      );\n\n      linePosition += 20;\n      ctx.moveTo(this.SIGNATURE_LINE_STARTING_POSITION, linePosition);\n      ctx.lineTo(this.SIGNATURE_LINE_ENDING_POSITION, linePosition);\n      ctx.moveTo(this.DATE_LINE_STARTING_POSITION, linePosition);\n      ctx.lineTo(this.DATE_LINE_ENDING_POSITION, linePosition);\n      ctx.stroke();\n\n      linePosition += 40;\n      ctx.font = '24px Roboto';\n      ctx.fillStyle = '#8F9899';\n      ctx.fillText('SIGNATURE', this.SIGNATURE_BASE_COORDINATE, linePosition);\n      ctx.fillText('DATE', this.DATE_BASE_COORDINATE, linePosition);\n\n      // Create an HTML link and clicks on it to download.\n      const link = document.createElement('a');\n      link.download = 'certificate.jpeg';\n      link.href = canvas.toDataURL();\n      link.click();\n    };\n  }\n\n  fillCertificateContent(\n      ctx: CanvasRenderingContext2D,\n      data: CertificateContentData[]\n  ): void {\n    data.forEach((data: CertificateContentData) => {\n      ctx.fillText(\n        data.text,\n        this.CERTIFICATE_MID_POINT,\n        data.linePosition\n      );\n    });\n  }\n}\n\nangular.module('oppia').directive(\n  'certificateDownloadModal', downgradeComponent(\n    {component: CertificateDownloadModalComponent}));\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/services/contribution-and-review-backend-api.service.spec.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for contribution and review backend api service.\n */\n\nimport { HttpClientTestingModule, HttpTestingController }\n  from '@angular/common/http/testing';\nimport { TestBed, fakeAsync, flushMicrotasks } from '@angular/core/testing';\nimport { AppConstants } from 'app.constants';\nimport { ContributionAndReviewBackendApiService }\n  from './contribution-and-review-backend-api.service';\n\ndescribe('Contribution and review backend API service', () => {\n  let carbas: ContributionAndReviewBackendApiService;\n  let http: HttpTestingController;\n\n  const explorationId = 'exp1';\n  const suggestion1 = {\n    suggestion_id: 'suggestion_id_1',\n    target_id: 'skill_id_1',\n  };\n  const opportunityDict1 = {\n    skill_id: 'skill_id_1',\n    skill_description: 'skill_description_1',\n  };\n  const suggestionsBackendObject = {\n    suggestions: [\n      suggestion1\n    ],\n    target_id_to_opportunity_dict: {\n      skill_id_1: opportunityDict1,\n    },\n  };\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule]\n    });\n    carbas = TestBed.inject(ContributionAndReviewBackendApiService);\n    http = TestBed.inject(HttpTestingController);\n  });\n\n  afterEach(() => {\n    http.verify();\n  });\n\n  describe('fetching suggestions from the backend', () => {\n    let successHandler: jasmine.Spy<jasmine.Func>;\n    let failureHandler: jasmine.Spy<jasmine.Func>;\n\n    beforeEach(() => {\n      successHandler = jasmine.createSpy('success');\n      failureHandler = jasmine.createSpy('failure');\n    });\n\n    it('should fetch submitted question suggestions', fakeAsync(() => {\n      spyOn(carbas, 'fetchSubmittedSuggestionsAsync').and.callThrough();\n      const url = '/getsubmittedsuggestions/skill/add_question' +\n      '?limit=10&offset=0&sort_key=Date';\n\n      carbas.fetchSuggestionsAsync(\n        'SUBMITTED_QUESTION_SUGGESTIONS',\n        AppConstants.OPPORTUNITIES_PAGE_SIZE,\n        0,\n        AppConstants.SUGGESTIONS_SORT_KEY_DATE,\n        'All'\n      ).then(successHandler, failureHandler);\n      const req = http.expectOne(url);\n      expect(req.request.method).toEqual('GET');\n      req.flush(suggestionsBackendObject);\n      flushMicrotasks();\n\n      expect(carbas.fetchSubmittedSuggestionsAsync)\n        .toHaveBeenCalledWith(\n          'skill', 'add_question',\n          AppConstants.OPPORTUNITIES_PAGE_SIZE, 0,\n          AppConstants.SUGGESTIONS_SORT_KEY_DATE);\n      expect(successHandler).toHaveBeenCalled();\n      expect(failureHandler).not.toHaveBeenCalled();\n    }));\n\n    it('should fetch submitted translation suggestions', fakeAsync(() => {\n      spyOn(carbas, 'fetchSubmittedSuggestionsAsync').and.callThrough();\n      const url = '/getsubmittedsuggestions/exploration/translate_content' +\n      '?limit=10&offset=0&sort_key=Date';\n\n      carbas.fetchSuggestionsAsync(\n        'SUBMITTED_TRANSLATION_SUGGESTIONS',\n        AppConstants.OPPORTUNITIES_PAGE_SIZE,\n        0,\n        AppConstants.SUGGESTIONS_SORT_KEY_DATE,\n        'All'\n      ).then(successHandler, failureHandler);\n      const req = http.expectOne(url);\n      expect(req.request.method).toEqual('GET');\n      req.flush(suggestionsBackendObject);\n      flushMicrotasks();\n\n      expect(carbas.fetchSubmittedSuggestionsAsync)\n        .toHaveBeenCalledWith(\n          'exploration', 'translate_content',\n          AppConstants.OPPORTUNITIES_PAGE_SIZE, 0,\n          AppConstants.SUGGESTIONS_SORT_KEY_DATE);\n      expect(successHandler).toHaveBeenCalled();\n      expect(failureHandler).not.toHaveBeenCalled();\n    }));\n\n    it('should fetch reviewable question suggestions', fakeAsync(() => {\n      spyOn(carbas, 'fetchReviewableSuggestionsAsync').and.callThrough();\n      const url = '/getreviewablesuggestions/skill/add_question' +\n      '?limit=10&offset=0&sort_key=Date';\n\n      carbas.fetchSuggestionsAsync(\n        'REVIEWABLE_QUESTION_SUGGESTIONS',\n        AppConstants.OPPORTUNITIES_PAGE_SIZE,\n        0,\n        AppConstants.SUGGESTIONS_SORT_KEY_DATE\n      ).then(successHandler, failureHandler);\n      const req = http.expectOne(url);\n      expect(req.request.method).toEqual('GET');\n      req.flush(suggestionsBackendObject);\n      flushMicrotasks();\n\n      expect(carbas.fetchReviewableSuggestionsAsync)\n        .toHaveBeenCalledWith(\n          'skill',\n          'add_question',\n          AppConstants.OPPORTUNITIES_PAGE_SIZE,\n          0,\n          'Date'\n        );\n      expect(successHandler).toHaveBeenCalled();\n      expect(failureHandler).not.toHaveBeenCalled();\n    }));\n\n    it('should fetch reviewable suggestions from exp1', fakeAsync(() => {\n      spyOn(carbas, 'fetchReviewableSuggestionsAsync').and.callThrough();\n      const url = '/getreviewablesuggestions/exploration/translate_content' +\n      '?limit=10&offset=0&sort_key=Date&exploration_id=exp1';\n\n      carbas.fetchSuggestionsAsync(\n        'REVIEWABLE_TRANSLATION_SUGGESTIONS',\n        AppConstants.OPPORTUNITIES_PAGE_SIZE,\n        0,\n        AppConstants.SUGGESTIONS_SORT_KEY_DATE,\n        explorationId\n      ).then(successHandler, failureHandler);\n      const req = http.expectOne(url);\n      expect(req.request.method).toEqual('GET');\n      req.flush(suggestionsBackendObject);\n      flushMicrotasks();\n\n      expect(carbas.fetchReviewableSuggestionsAsync)\n        .toHaveBeenCalledWith(\n          'exploration',\n          'translate_content',\n          AppConstants.OPPORTUNITIES_PAGE_SIZE,\n          0,\n          'Date',\n          explorationId\n        );\n      expect(successHandler).toHaveBeenCalled();\n      expect(failureHandler).not.toHaveBeenCalled();\n    }));\n\n    it('should throw error if fetch type is invalid', fakeAsync(() => {\n      carbas.fetchSuggestionsAsync(\n        'INVALID_SUGGESTION_TYPE',\n        AppConstants.OPPORTUNITIES_PAGE_SIZE,\n        0,\n        AppConstants.SUGGESTIONS_SORT_KEY_DATE,\n        'All'\n      ).then(successHandler, failureHandler);\n      flushMicrotasks();\n\n      expect(successHandler).not.toHaveBeenCalled();\n      expect(failureHandler).toHaveBeenCalled();\n    }));\n  });\n\n  it('should correctly review exploration suggestion', fakeAsync(() => {\n    const successHandler = jasmine.createSpy('success');\n    const failureHandler = jasmine.createSpy('failure');\n    const url = '/suggestionactionhandler/exploration/abc/pqr';\n    const putBody = {\n      action: 'accept',\n      review_message: 'test review message',\n      commit_message: 'test commit message'\n    };\n\n    carbas.reviewExplorationSuggestionAsync('abc', 'pqr', putBody)\n      .then(successHandler, failureHandler);\n    const req = http.expectOne(url);\n    expect(req.request.method).toEqual('PUT');\n    req.flush({});\n    flushMicrotasks();\n\n    expect(successHandler).toHaveBeenCalled();\n    expect(failureHandler).not.toHaveBeenCalled();\n  }));\n\n  it('should correctly review skill suggestion', fakeAsync(() => {\n    const successHandler = jasmine.createSpy('success');\n    const failureHandler = jasmine.createSpy('failure');\n    const url = '/suggestionactionhandler/skill/abc/pqr';\n    const putBody = {\n      action: 'accept',\n      review_message: 'test review message',\n      skill_difficulty: 'easy'\n    };\n\n    carbas.reviewSkillSuggestionAsync('abc', 'pqr', putBody)\n      .then(successHandler, failureHandler);\n    const req = http.expectOne(url);\n    expect(req.request.method).toEqual('PUT');\n    req.flush({});\n    flushMicrotasks();\n\n    expect(successHandler).toHaveBeenCalled();\n    expect(failureHandler).not.toHaveBeenCalled();\n  }));\n\n  it('should correctly update translation suggestion', fakeAsync(() => {\n    const successHandler = jasmine.createSpy('success');\n    const failureHandler = jasmine.createSpy('failure');\n    const url = '/updatetranslationsuggestionhandler/abc';\n    const putBody = {\n      translation_html: '<p>In English</p>'\n    };\n\n    carbas.updateTranslationSuggestionAsync('abc', putBody)\n      .then(successHandler, failureHandler);\n    const req = http.expectOne(url);\n    expect(req.request.method).toEqual('PUT');\n    req.flush({});\n    flushMicrotasks();\n\n    expect(successHandler).toHaveBeenCalled();\n    expect(failureHandler).not.toHaveBeenCalled();\n  }));\n\n  it('should correctly update question suggestion', fakeAsync(() => {\n    const successHandler = jasmine.createSpy('success');\n    const failureHandler = jasmine.createSpy('failure');\n    const url = '/updatequestionsuggestionhandler/abc';\n    const questionStateData = {\n      classifier_model_id: null,\n      content: {\n        content_id: 'content',\n        html: ''\n      },\n      recorded_voiceovers: {\n        voiceovers_mapping: {\n          content: {},\n          default_outcome: {}\n        }\n      },\n      interaction: {\n        answer_groups: [],\n        confirmed_unclassified_answers: [],\n        customization_args: {\n          placeholder: {\n            value: {\n              content_id: 'ca_placeholder_0',\n              unicode_str: ''\n            }\n          },\n          rows: { value: 1 },\n          catchMisspellings: {\n            value: false\n          }\n        },\n        default_outcome: {\n          dest: 'new state',\n          dest_if_really_stuck: null,\n          feedback: {\n            content_id: 'default_outcome',\n            html: ''\n          },\n          labelled_as_correct: false,\n          param_changes: [],\n          refresher_exploration_id: null,\n          missing_prerequisite_skill_id: null,\n        },\n        hints: [],\n        solution: {\n          answer_is_exclusive: false,\n          correct_answer: 'answer',\n          explanation: {\n            content_id: 'solution',\n            html: '<p>This is an explanation.</p>'\n          }\n        },\n        id: 'TextInput'\n      },\n      linked_skill_id: null,\n      next_content_id_index: 0,\n      param_changes: [],\n      solicit_answer_details: false,\n      card_is_checkpoint: false,\n      written_translations: {\n        translations_mapping: {\n          content: {},\n          default_outcome: {}\n        }\n      }\n    };\n    const payload = {\n      skill_difficulty: 'easy',\n      question_state_data: questionStateData\n    };\n    const postBody = new FormData();\n    postBody.append('payload', JSON.stringify(payload));\n\n    carbas.updateQuestionSuggestionAsync('abc', postBody)\n      .then(successHandler, failureHandler);\n    const req = http.expectOne(url);\n    expect(req.request.method).toEqual('POST');\n    req.flush({});\n    flushMicrotasks();\n\n    expect(successHandler).toHaveBeenCalled();\n    expect(failureHandler).not.toHaveBeenCalled();\n  }));\n\n  it('should fetch contributor certificate', fakeAsync(() => {\n    spyOn(carbas, 'downloadContributorCertificateAsync').and.callThrough();\n    const successHandler = jasmine.createSpy('success');\n    const failureHandler = jasmine.createSpy('failure');\n    const url = (\n      '/contributorcertificate/user/translate_content?' +\n      'from_date=2022-01-01&to_date=2022-01-02&language=hi'\n    );\n    const response = {\n      from_date: '1 Nov 2022',\n      to_date: '1 Dec 2022',\n      contribution_hours: 1.0,\n      team_lead: 'Test User',\n      language: 'Hindi'\n    };\n\n    carbas.downloadContributorCertificateAsync(\n      'user', 'translate_content', 'hi', '2022-01-01', '2022-01-02'\n    ).then(successHandler, failureHandler);\n    const req = http.expectOne(url);\n    expect(req.request.method).toEqual('GET');\n    req.flush(response);\n    flushMicrotasks();\n\n    expect(carbas.downloadContributorCertificateAsync)\n      .toHaveBeenCalledWith(\n        'user', 'translate_content', 'hi', '2022-01-01', '2022-01-02');\n    expect(successHandler).toHaveBeenCalled();\n    expect(failureHandler).not.toHaveBeenCalled();\n  }));\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/services/contribution-and-review-backend-api.service.ts",
      "content": "// Copyright 2021 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Backend api service for fetching and resolving suggestions.\n */\n\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';\nimport { OpportunityDict } from './contribution-and-review.service';\nimport { SuggestionBackendDict } from 'domain/suggestion/suggestion.model';\n\ninterface FetchSuggestionsResponse {\n  'target_id_to_opportunity_dict': {\n    [targetId: string]: OpportunityDict;\n  };\n  suggestions: SuggestionBackendDict[];\n  next_offset: number;\n}\n\nexport interface ContributorCertificateResponse {\n  'from_date': string;\n  'to_date': string;\n  'contribution_hours': number;\n  'team_lead': string;\n  'language': string | null;\n}\n\ninterface ReviewExplorationSuggestionRequestBody {\n  action: string;\n  'review_message': string;\n  'commit_message': string | null;\n}\n\ninterface ReviewSkillSuggestionRequestBody {\n  action: string;\n  'review_message': string;\n  'skill_difficulty': string;\n}\n\ninterface UpdateTranslationRequestBody {\n  'translation_html': string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ContributionAndReviewBackendApiService {\n  private SUBMITTED_SUGGESTION_LIST_HANDLER_URL = (\n    '/getsubmittedsuggestions/<target_type>/<suggestion_type>');\n\n  private REVIEWABLE_SUGGESTIONS_HANDLER_URL = (\n    '/getreviewablesuggestions/<target_type>/<suggestion_type>');\n\n  private SUGGESTION_TO_EXPLORATION_ACTION_HANDLER_URL = (\n    '/suggestionactionhandler/exploration/<exp_id>/<suggestion_id>');\n\n  private SUGGESTION_TO_SKILL_ACTION_HANDLER_URL = (\n    '/suggestionactionhandler/skill/<skill_id>/<suggestion_id>');\n\n  private UPDATE_TRANSLATION_HANDLER_URL = (\n    '/updatetranslationsuggestionhandler/<suggestion_id>');\n\n  private UPDATE_QUESTION_HANDLER_URL = (\n    '/updatequestionsuggestionhandler/<suggestion_id>');\n\n  private CONTRIBUTOR_CERTIFICATE_HANDLER_URL = (\n    '/contributorcertificate/<username>/<suggestion_type>');\n\n  private SUBMITTED_QUESTION_SUGGESTIONS = (\n    'SUBMITTED_QUESTION_SUGGESTIONS');\n\n  private REVIEWABLE_QUESTION_SUGGESTIONS = (\n    'REVIEWABLE_QUESTION_SUGGESTIONS');\n\n  private SUBMITTED_TRANSLATION_SUGGESTIONS = (\n    'SUBMITTED_TRANSLATION_SUGGESTIONS');\n\n  private REVIEWABLE_TRANSLATION_SUGGESTIONS = (\n    'REVIEWABLE_TRANSLATION_SUGGESTIONS');\n\n  constructor(\n    private http: HttpClient,\n    private urlInterpolationService: UrlInterpolationService\n  ) {}\n\n  async fetchSuggestionsAsync(\n      fetchType: string,\n      limit: number,\n      offset: number,\n      sortKey: string,\n      explorationId?: string\n  ): Promise<FetchSuggestionsResponse> {\n    if (fetchType === this.SUBMITTED_QUESTION_SUGGESTIONS) {\n      return this.fetchSubmittedSuggestionsAsync(\n        'skill', 'add_question', limit, offset, sortKey);\n    }\n    if (fetchType === this.SUBMITTED_TRANSLATION_SUGGESTIONS) {\n      return this.fetchSubmittedSuggestionsAsync(\n        'exploration', 'translate_content', limit, offset, sortKey);\n    }\n    if (fetchType === this.REVIEWABLE_QUESTION_SUGGESTIONS) {\n      return this.fetchReviewableSuggestionsAsync(\n        'skill', 'add_question', limit, offset, sortKey);\n    }\n    if (fetchType === this.REVIEWABLE_TRANSLATION_SUGGESTIONS) {\n      return this.fetchReviewableSuggestionsAsync(\n        'exploration',\n        'translate_content',\n        limit,\n        offset,\n        sortKey,\n        explorationId);\n    }\n    throw new Error('Invalid fetch type');\n  }\n\n  async fetchSubmittedSuggestionsAsync(\n      targetType: string,\n      suggestionType: string,\n      limit: number,\n      offset: number,\n      sortKey: string\n  ): Promise<FetchSuggestionsResponse> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.SUBMITTED_SUGGESTION_LIST_HANDLER_URL, {\n        target_type: targetType,\n        suggestion_type: suggestionType\n      }\n    );\n    const params = {\n      limit: limit.toString(),\n      offset: offset.toString(),\n      sort_key: sortKey\n    };\n    return this.http.get<FetchSuggestionsResponse>(url, { params }).toPromise();\n  }\n\n  async fetchReviewableSuggestionsAsync(\n      targetType: string,\n      suggestionType: string,\n      limit: number,\n      offset: number,\n      sortKey: string,\n      explorationId?: string\n  ): Promise<FetchSuggestionsResponse> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.REVIEWABLE_SUGGESTIONS_HANDLER_URL, {\n        target_type: targetType,\n        suggestion_type: suggestionType\n      }\n    );\n    const params: {\n      limit: string;\n      offset: string;\n      sort_key: string;\n      exploration_id?: string;\n    } = {\n      limit: limit.toString(),\n      offset: offset.toString(),\n      sort_key: sortKey\n    };\n    if (explorationId !== undefined) {\n      params.exploration_id = explorationId;\n    }\n    return this.http.get<FetchSuggestionsResponse>(url, { params }).toPromise();\n  }\n\n  async reviewExplorationSuggestionAsync(\n      expId: string,\n      suggestionId: string,\n      requestBody: ReviewExplorationSuggestionRequestBody\n  ): Promise<void> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.SUGGESTION_TO_EXPLORATION_ACTION_HANDLER_URL, {\n        exp_id: expId,\n        suggestion_id: suggestionId\n      }\n    );\n    return this.http.put<void>(url, requestBody).toPromise();\n  }\n\n  async reviewSkillSuggestionAsync(\n      skillId: string,\n      suggestionId: string,\n      requestBody: ReviewSkillSuggestionRequestBody\n  ): Promise<void> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.SUGGESTION_TO_SKILL_ACTION_HANDLER_URL, {\n        skill_id: skillId,\n        suggestion_id: suggestionId\n      }\n    );\n    return this.http.put<void>(url, requestBody).toPromise();\n  }\n\n  async updateTranslationSuggestionAsync(\n      suggestionId: string, requestBody: UpdateTranslationRequestBody\n  ): Promise<void> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.UPDATE_TRANSLATION_HANDLER_URL, {\n        suggestion_id: suggestionId\n      }\n    );\n    return this.http.put<void>(url, requestBody).toPromise();\n  }\n\n  async updateQuestionSuggestionAsync(\n      suggestionId: string, requestBody: FormData\n  ): Promise<void> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.UPDATE_QUESTION_HANDLER_URL, {\n        suggestion_id: suggestionId\n      }\n    );\n    return this.http.post<void>(url, requestBody).toPromise();\n  }\n\n  async downloadContributorCertificateAsync(\n      username: string,\n      suggestionType: string,\n      language: string | null,\n      fromDate: string,\n      toDate: string\n  ): Promise<ContributorCertificateResponse> {\n    const url = this.urlInterpolationService.interpolateUrl(\n      this.CONTRIBUTOR_CERTIFICATE_HANDLER_URL, {\n        username: username,\n        suggestion_type: suggestionType\n      }\n    );\n    let params: {\n      from_date: string;\n      to_date: string;\n      language?: string;\n    } = {\n      from_date: fromDate,\n      to_date: toDate\n    };\n    if (language) {\n      params.language = language;\n    }\n    return this.http.get<ContributorCertificateResponse>(\n      url, { params }\n    ).toPromise();\n  }\n}\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/services/contribution-and-review.service.spec.ts",
      "content": "// Copyright 2018 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Unit tests for contribution and review service\n */\n\nimport { TestBed, fakeAsync, flushMicrotasks, tick } from '@angular/core/testing';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { AppConstants } from 'app.constants';\nimport { ContributionAndReviewService } from './contribution-and-review.service';\nimport { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';\nimport { ContributionAndReviewBackendApiService }\n  from './contribution-and-review-backend-api.service';\nimport { SuggestionBackendDict } from 'domain/suggestion/suggestion.model';\n\ndescribe('Contribution and review service', () => {\n  let cars: ContributionAndReviewService;\n  let carbas: ContributionAndReviewBackendApiService;\n  let fetchSuggestionsAsyncSpy: jasmine.Spy;\n  let downloadContributorCertificateAsyncSpy: jasmine.Spy;\n\n  const suggestion1 = {\n    suggestion_id: 'suggestion_id_1',\n    target_id: 'skill_id_1',\n  } as SuggestionBackendDict;\n  const suggestion2 = {\n    suggestion_id: 'suggestion_id_2',\n    target_id: 'skill_id_2',\n  } as SuggestionBackendDict;\n  const suggestion3 = {\n    suggestion_id: 'suggestion_id_3',\n    target_id: 'skill_id_3',\n  } as SuggestionBackendDict;\n\n  const opportunityDict1 = {\n    skill_id: 'skill_id_1',\n    skill_description: 'skill_description_1',\n  };\n  const opportunityDict2 = {\n    skill_id: 'skill_id_2',\n    skill_description: 'skill_description_2',\n  };\n  const opportunityDict3 = {\n    skill_id: 'skill_id_3',\n    skill_description: 'skill_description_3',\n  };\n\n  const backendFetchResponse = {\n    suggestions: [\n      suggestion1\n    ],\n    target_id_to_opportunity_dict: {\n      skill_id_1: opportunityDict1,\n    },\n    next_offset: 1\n  };\n\n  const multiplePageBackendFetchResponse = {\n    suggestions: [\n      suggestion1,\n      suggestion2,\n      suggestion3\n    ],\n    target_id_to_opportunity_dict: {\n      skill_id_1: opportunityDict1,\n      skill_id_2: opportunityDict2,\n      skill_id_3: opportunityDict3\n    },\n    next_offset: 3\n  };\n\n  const expectedSuggestionDict = {\n    suggestion: suggestion1,\n    details: backendFetchResponse.target_id_to_opportunity_dict.skill_id_1\n  };\n  const expectedSuggestion2Dict = {\n    suggestion: suggestion2,\n    details: multiplePageBackendFetchResponse\n      .target_id_to_opportunity_dict.skill_id_2\n  };\n  const expectedSuggestion3Dict = {\n    suggestion: suggestion3,\n    details: multiplePageBackendFetchResponse\n      .target_id_to_opportunity_dict.skill_id_3\n  };\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        UrlInterpolationService,\n        ContributionAndReviewBackendApiService\n      ]\n    });\n    cars = TestBed.inject(ContributionAndReviewService);\n    carbas = TestBed.inject(ContributionAndReviewBackendApiService);\n    fetchSuggestionsAsyncSpy = spyOn(carbas, 'fetchSuggestionsAsync');\n    downloadContributorCertificateAsyncSpy = spyOn(\n      carbas, 'downloadContributorCertificateAsync');\n  });\n\n  describe('getUserCreatedQuestionSuggestionsAsync', () => {\n    const defaultOpportunitiesPageSize = AppConstants.OPPORTUNITIES_PAGE_SIZE;\n    afterAll(() => {\n      // This throws \"Cannot assign to 'OPPORTUNITIES_PAGE_SIZE' because it\n      // is a read-only property.\". We need to suppress this error because\n      // we need to change the value of 'OPPORTUNITIES_PAGE_SIZE' for testing\n      // purposes.\n      // @ts-expect-error\n      AppConstants.OPPORTUNITIES_PAGE_SIZE = defaultOpportunitiesPageSize;\n    });\n\n    it('should return available question suggestions and opportunity details',\n      () => {\n        fetchSuggestionsAsyncSpy.and.returnValue(\n          Promise.resolve(backendFetchResponse));\n\n        cars.getUserCreatedQuestionSuggestionsAsync(true, 'sort_key')\n          .then((response) => {\n            expect(response.suggestionIdToDetails.suggestion_id_1)\n              .toEqual(expectedSuggestionDict);\n          });\n\n        expect(fetchSuggestionsAsyncSpy).toHaveBeenCalled();\n      });\n\n    it('should fetch one page ahead and cache extra results', fakeAsync(() => {\n      // This throws \"Cannot assign to 'OPPORTUNITIES_PAGE_SIZE' because it\n      // is a read-only property.\". We need to suppress this error because\n      // we need to change the value of 'OPPORTUNITIES_PAGE_SIZE' for testing\n      // purposes.\n      // @ts-expect-error\n      AppConstants.OPPORTUNITIES_PAGE_SIZE = 2;\n\n      // Return more than a page's worth of results (3 results for a page size\n      // of 2).\n      fetchSuggestionsAsyncSpy.and.returnValue(\n        Promise.resolve(multiplePageBackendFetchResponse));\n\n      // Only the first 2 results should be returned and the extra result\n      // should be cached.\n      cars.getUserCreatedQuestionSuggestionsAsync(true, 'sort_key')\n        .then((response) => {\n          expect(response.suggestionIdToDetails.suggestion_id_1)\n            .toEqual(expectedSuggestionDict);\n          expect(response.suggestionIdToDetails.suggestion_id_2)\n            .toEqual(expectedSuggestion2Dict);\n          expect(Object.keys(response.suggestionIdToDetails).length)\n            .toEqual(2);\n          expect(response.more).toBeTrue();\n        });\n\n      flushMicrotasks();\n\n      const suggestion4 = {\n        suggestion_id: 'suggestion_id_4',\n        target_id: 'skill_id_4',\n      } as SuggestionBackendDict;\n      const opportunityDict4 = {\n        skill_id: 'skill_id_4',\n        skill_description: 'skill_description_4',\n      };\n      const suggestion4BackendFetchResponse = {\n        suggestions: [\n          suggestion4\n        ],\n        target_id_to_opportunity_dict: {\n          skill_id_4: opportunityDict4,\n        },\n        next_offset: 4\n      };\n      const expectedSuggestion4Dict = {\n        suggestion: suggestion4,\n        details: suggestion4BackendFetchResponse\n          .target_id_to_opportunity_dict.skill_id_4\n      };\n\n      // Return a 4th suggestion from the backend that was not available in the\n      // first fetch.\n      fetchSuggestionsAsyncSpy.and.returnValue(\n        Promise.resolve(suggestion4BackendFetchResponse));\n\n      // Return both the cached 3rd suggestion and the new 4th suggestion to the\n      // caller.\n      cars.getUserCreatedQuestionSuggestionsAsync(false, 'sort_key')\n        .then((response) => {\n          expect(response.suggestionIdToDetails.suggestion_id_3)\n            .toEqual(expectedSuggestion3Dict);\n          expect(response.suggestionIdToDetails.suggestion_id_4)\n            .toEqual(expectedSuggestion4Dict);\n          expect(Object.keys(response.suggestionIdToDetails).length)\n            .toEqual(2);\n          expect(response.more).toBeFalse();\n        });\n    }));\n\n    it('should reset offset', fakeAsync(() => {\n      // This throws \"Cannot assign to 'OPPORTUNITIES_PAGE_SIZE' because it\n      // is a read-only property.\". We need to suppress this error because\n      // we need to change the value of 'OPPORTUNITIES_PAGE_SIZE' for testing\n      // purposes.\n      // @ts-expect-error\n      AppConstants.OPPORTUNITIES_PAGE_SIZE = 2;\n\n      // Return more than a page's worth of results (3 results for a page size\n      // of 2).\n      fetchSuggestionsAsyncSpy.and.returnValue(\n        Promise.resolve(multiplePageBackendFetchResponse));\n\n      // Only the first 2 results should be returned and the extra result\n      // should be cached.\n      cars.getUserCreatedQuestionSuggestionsAsync(true, 'sort_key')\n        .then((response) => {\n          expect(response.suggestionIdToDetails.suggestion_id_1)\n            .toEqual(expectedSuggestionDict);\n          expect(response.suggestionIdToDetails.suggestion_id_2)\n            .toEqual(expectedSuggestion2Dict);\n          expect(Object.keys(response.suggestionIdToDetails).length)\n            .toEqual(2);\n          expect(response.more).toBeTrue();\n        });\n\n      flushMicrotasks();\n\n      // Fetch again from offset 0.\n      fetchSuggestionsAsyncSpy.and.returnValue(\n        Promise.resolve(multiplePageBackendFetchResponse));\n\n      // Return the first 2 results from offset 0 again.\n      cars.getUserCreatedQuestionSuggestionsAsync(true, 'sort_key')\n        .then((response) => {\n          expect(response.suggestionIdToDetails.suggestion_id_1)\n            .toEqual(expectedSuggestionDict);\n          expect(response.suggestionIdToDetails.suggestion_id_2)\n            .toEqual(expectedSuggestion2Dict);\n          expect(Object.keys(response.suggestionIdToDetails).length)\n            .toEqual(2);\n          expect(response.more).toBeTrue();\n        });\n    }));\n  });\n\n  describe('downloadContributorCertificateAsync', () => {\n    it('should download the contributor certificate',\n      () => {\n        downloadContributorCertificateAsyncSpy.and.returnValue(\n          Promise.resolve({\n            from_date: '1 Nov 2022',\n            to_date: '1 Dec 2022',\n            contribution_hours: 1.0,\n            team_lead: 'Test User',\n            language: 'Hindi'\n          }));\n\n        cars.downloadContributorCertificateAsync(\n          'user', 'translate_content', 'hi', '2022-01-01', '2022-01-02'\n        ).then((response) => {\n          expect(response.from_date).toEqual('1 Nov 2022');\n          expect(response.to_date).toEqual('1 Dec 2022');\n          expect(response.contribution_hours).toEqual(1.0);\n          expect(response.team_lead).toEqual('Test User');\n          expect(response.language).toEqual('Hindi');\n        });\n\n        expect(downloadContributorCertificateAsyncSpy).toHaveBeenCalled();\n      });\n  });\n\n  describe('getReviewableQuestionSuggestionsAsync', () => {\n    it('should return available question suggestions and opportunity details',\n      () => {\n        fetchSuggestionsAsyncSpy.and.returnValue(\n          Promise.resolve(backendFetchResponse));\n\n        cars.getReviewableQuestionSuggestionsAsync(true, 'sort_key')\n          .then((response) => {\n            expect(response.suggestionIdToDetails.suggestion_id_1)\n              .toEqual(expectedSuggestionDict);\n          });\n\n        expect(fetchSuggestionsAsyncSpy).toHaveBeenCalled();\n      });\n  });\n\n  describe('getUserCreatedTranslationSuggestionsAsync', () => {\n    it('should return translation suggestions and opportunity details',\n      () => {\n        fetchSuggestionsAsyncSpy.and.returnValue(\n          Promise.resolve(backendFetchResponse));\n\n        cars.getUserCreatedTranslationSuggestionsAsync(true, 'sort_key')\n          .then((response) => {\n            expect(response.suggestionIdToDetails.suggestion_id_1)\n              .toEqual(expectedSuggestionDict);\n          });\n\n        expect(fetchSuggestionsAsyncSpy).toHaveBeenCalled();\n      });\n  });\n\n  describe('getReviewableTranslationSuggestionsAsync', () => {\n    it('should return translation suggestions and opportunity details',\n      () => {\n        fetchSuggestionsAsyncSpy.and.returnValue(\n          Promise.resolve(backendFetchResponse));\n\n        cars.getReviewableTranslationSuggestionsAsync(\n          /* ShouldResetOffset= */ true, 'skill_id_1')\n          .then((response) => {\n            expect(response.suggestionIdToDetails.suggestion_id_1)\n              .toEqual(expectedSuggestionDict);\n          });\n\n        expect(fetchSuggestionsAsyncSpy).toHaveBeenCalled();\n      });\n  });\n\n  describe('reviewExplorationSuggestion', () => {\n    const requestBody = {\n      action: 'accept',\n      review_message: 'review message',\n      commit_message: 'commit message'\n    };\n\n    let onSuccess: jasmine.Spy<(suggestionId: string) => void>;\n    let onFailure: jasmine.Spy<(errorMessage: string) => void>;\n\n    beforeEach(() => {\n      onSuccess = jasmine.createSpy(\n        'onSuccess', (suggestionId: string) => {});\n      onFailure = jasmine.createSpy('onFailure', (errorMessage: string) => {});\n    });\n\n    it('should call onSuccess function on' +\n    'resolving suggestion to exploration correctly', fakeAsync(() => {\n      spyOn(carbas, 'reviewExplorationSuggestionAsync')\n        .and.returnValue(Promise.resolve());\n\n      cars.reviewExplorationSuggestion(\n        'abc', 'pqr', 'accept', 'review message', 'commit message',\n        onSuccess, onFailure\n      );\n      tick();\n\n      expect(carbas.reviewExplorationSuggestionAsync).toHaveBeenCalledWith(\n        'abc', 'pqr', requestBody);\n      expect(onSuccess).toHaveBeenCalledWith('pqr');\n      expect(onFailure).not.toHaveBeenCalled();\n    }));\n\n    it('should call onFailure function when' +\n    'resolving suggestion to exploration fails', fakeAsync(() => {\n      spyOn(carbas, 'reviewExplorationSuggestionAsync').and\n        .returnValue(Promise.reject({\n          error: {error: 'Backend error'}\n        }));\n\n      cars.reviewExplorationSuggestion(\n        'abc', 'pqr', 'accept', 'review message', 'commit message',\n        onSuccess, onFailure\n      );\n      tick();\n\n      expect(carbas.reviewExplorationSuggestionAsync).toHaveBeenCalledWith(\n        'abc', 'pqr', requestBody);\n      expect(onSuccess).not.toHaveBeenCalled();\n      expect(onFailure).toHaveBeenCalled();\n    }));\n  });\n\n  describe('reviewSkillSuggestion', () => {\n    const requestBody = {\n      action: 'accept',\n      review_message: 'review message',\n      skill_difficulty: 'easy'\n    };\n\n    let onSuccess: jasmine.Spy<(suggestionId: string) => void>;\n    let onFailure: jasmine.Spy<() => void>;\n\n    beforeEach(() => {\n      onSuccess = jasmine.createSpy(\n        'onSuccess', (suggestionId: string) => {});\n      onFailure = jasmine.createSpy('onFailure', () => {});\n    });\n\n    it('should call onSuccess function on' +\n    'resolving suggestion to skill correctly', fakeAsync(() => {\n      spyOn(\n        carbas, 'reviewSkillSuggestionAsync'\n      ).and.returnValue(Promise.resolve());\n\n      cars.reviewSkillSuggestion(\n        'abc', 'pqr', 'accept', 'review message', 'easy', onSuccess, onFailure);\n      tick();\n\n      expect(carbas.reviewSkillSuggestionAsync)\n        .toHaveBeenCalledWith('abc', 'pqr', requestBody);\n      expect(onSuccess).toHaveBeenCalledWith('pqr');\n      expect(onFailure).not.toHaveBeenCalled();\n    }));\n\n    it('should call onFailure function when' +\n    'resolving suggestion to skill fails', fakeAsync(() => {\n      spyOn(\n        carbas, 'reviewSkillSuggestionAsync'\n      ).and.returnValue(Promise.reject());\n\n      cars.reviewSkillSuggestion(\n        'abc', 'pqr', 'accept', 'review message', 'easy', onSuccess, onFailure);\n      tick();\n\n      expect(carbas.reviewSkillSuggestionAsync)\n        .toHaveBeenCalledWith('abc', 'pqr', requestBody);\n      expect(onSuccess).not.toHaveBeenCalled();\n      expect(onFailure).toHaveBeenCalled();\n    }));\n  });\n\n  describe('updateTranslationSuggestionAsync', () => {\n    const requestBody = {\n      translation_html: '<p>In English</p>'\n    };\n\n    let onSuccess: jasmine.Spy<() => void>;\n    let onFailure: jasmine.Spy<(error: unknown) => void>;\n\n    beforeEach(() => {\n      onSuccess = jasmine.createSpy(\n        'onSuccess', () => {});\n      onFailure = jasmine.createSpy('onFailure', (error) => {});\n    });\n\n    it('should call onSuccess function when' +\n    'updateTranslationSuggestionAsync succeeds', fakeAsync(() => {\n      spyOn(carbas, 'updateTranslationSuggestionAsync').and\n        .returnValue(Promise.resolve());\n\n      cars.updateTranslationSuggestionAsync(\n        'pqr', '<p>In English</p>', onSuccess, onFailure);\n      tick();\n\n      expect(carbas.updateTranslationSuggestionAsync)\n        .toHaveBeenCalledWith('pqr', requestBody);\n      expect(onSuccess).toHaveBeenCalled();\n      expect(onFailure).not.toHaveBeenCalled();\n    }));\n\n    it('should call onFailure function when' +\n    'updateTranslationSuggestionAsync fails', fakeAsync(() => {\n      spyOn(carbas, 'updateTranslationSuggestionAsync').and\n        .returnValue(Promise.reject());\n\n      cars.updateTranslationSuggestionAsync(\n        'pqr', '<p>In English</p>', onSuccess, onFailure);\n      tick();\n\n      expect(carbas.updateTranslationSuggestionAsync)\n        .toHaveBeenCalledWith('pqr', requestBody);\n      expect(onSuccess).not.toHaveBeenCalled();\n      expect(onFailure).toHaveBeenCalled();\n    }));\n  });\n\n  describe('updateQuestionSuggestionAsync', () => {\n    const questionStateData = {\n      classifier_model_id: null,\n      content: {\n        content_id: 'content',\n        html: ''\n      },\n      recorded_voiceovers: {\n        voiceovers_mapping: {\n          content: {},\n          default_outcome: {}\n        }\n      },\n      interaction: {\n        answer_groups: [],\n        confirmed_unclassified_answers: [],\n        customization_args: {\n          placeholder: {\n            value: {\n              content_id: 'ca_placeholder_0',\n              unicode_str: ''\n            }\n          },\n          rows: { value: 1 },\n          catchMisspellings: {\n            value: false\n          }\n        },\n        default_outcome: {\n          dest: 'new state',\n          dest_if_really_stuck: null,\n          feedback: {\n            content_id: 'default_outcome',\n            html: ''\n          },\n          labelled_as_correct: false,\n          param_changes: [],\n          refresher_exploration_id: null,\n          missing_prerequisite_skill_id: null,\n        },\n        hints: [],\n        solution: {\n          answer_is_exclusive: false,\n          correct_answer: 'answer',\n          explanation: {\n            content_id: 'solution',\n            html: '<p>This is an explanation.</p>'\n          }\n        },\n        id: 'TextInput'\n      },\n      linked_skill_id: null,\n      next_content_id_index: 0,\n      param_changes: [],\n      solicit_answer_details: false,\n      card_is_checkpoint: false,\n      written_translations: {\n        translations_mapping: {\n          content: {},\n          default_outcome: {}\n        }\n      }\n    };\n\n    const payload = {\n      skill_difficulty: 'easy',\n      question_state_data: questionStateData\n    };\n\n    const imagesData = [{\n      filename: 'image1.png',\n      imageBlob: new Blob()\n    }];\n\n    const requestBody = new FormData();\n    requestBody.append('payload', JSON.stringify(payload));\n    imagesData.forEach(obj => {\n      if (obj.imageBlob !== null) {\n        requestBody.append(obj.filename, obj.imageBlob);\n      }\n    });\n\n    let onSuccess: jasmine.Spy<(suggestionId: string) => void>;\n    let onFailure: jasmine.Spy<(suggestionId: string) => void>;\n\n    beforeEach(() => {\n      onSuccess = jasmine.createSpy(\n        'onSuccess', (suggestionId: string) => {});\n      onFailure = jasmine.createSpy(\n        'onFailure', (suggestionId: string) => {});\n    });\n\n    it('should call onSuccess function when' +\n    'updateQuestionSuggestionAsync succeeds', fakeAsync(() =>{\n      spyOn(carbas, 'updateQuestionSuggestionAsync').and\n        .returnValue(Promise.resolve());\n\n      cars.updateQuestionSuggestionAsync(\n        'pqr', 2, questionStateData,\n        imagesData, onSuccess, onFailure);\n      tick();\n\n      expect(carbas.updateQuestionSuggestionAsync)\n        .toHaveBeenCalledWith('pqr', requestBody);\n      expect(onSuccess).toHaveBeenCalledWith('pqr');\n      expect(onFailure).not.toHaveBeenCalled();\n    }));\n\n    it('should call onFailure function when' +\n    'updateQuestionSuggestionAsync fails', fakeAsync(() =>{\n      spyOn(carbas, 'updateQuestionSuggestionAsync').and\n        .returnValue(Promise.reject());\n\n      cars.updateQuestionSuggestionAsync(\n        'pqr', 2, questionStateData,\n        imagesData, onSuccess, onFailure);\n      tick();\n\n      expect(carbas.updateQuestionSuggestionAsync)\n        .toHaveBeenCalledWith('pqr', requestBody);\n      expect(onSuccess).not.toHaveBeenCalled();\n      expect(onFailure).toHaveBeenCalledWith('pqr');\n    }));\n  });\n});\n"
    },
    {
      "filename": "core/templates/pages/contributor-dashboard-page/services/contribution-and-review.service.ts",
      "content": "// Copyright 2014 The Oppia Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Service for fetching and resolving suggestions.\n */\n\nimport { downgradeInjectable } from '@angular/upgrade/static';\nimport { Injectable } from '@angular/core';\nimport { AppConstants } from 'app.constants';\nimport { ContributionAndReviewBackendApiService, ContributorCertificateResponse }\n  from './contribution-and-review-backend-api.service';\nimport { SuggestionBackendDict } from 'domain/suggestion/suggestion.model';\nimport { StateBackendDict } from 'domain/state/StateObjectFactory';\nimport { ImagesData } from 'services/image-local-storage.service';\n\nexport interface OpportunityDict {\n  'skill_id': string;\n  'skill_description': string;\n}\n\n// Encapsulates the state necessary to fetch a particular suggestion from the\n// backend.\nclass SuggestionFetcher {\n  // Type of suggestion to fetch.\n  type: string;\n  // The current offset, i.e. the number of items to skip (from the beginning of\n  // all matching results) in the next fetch.\n  offset: number;\n  sortKey: string;\n  // Cache of suggestions.\n  suggestionIdToDetails: SuggestionDetailsDict;\n\n  constructor(type: string) {\n    this.type = type;\n    this.offset = 0;\n    this.sortKey = '';\n    this.suggestionIdToDetails = {};\n  }\n}\n\ninterface SuggestionDetailsDict {\n  [targetId: string]: {\n    suggestion: SuggestionBackendDict;\n    details: OpportunityDict;\n  };\n}\n\n// Represents a client-facing response to a fetch suggestion query.\nexport interface FetchSuggestionsResponse {\n  // A dict mapping suggestion ID to suggestion metadata.\n  suggestionIdToDetails: SuggestionDetailsDict;\n  // Whether there are more results to return after the last query.\n  more: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ContributionAndReviewService {\n  // This property is initialized using async methods\n  // and we need to do non-null assertion. For more information, see\n  // https://github.com/oppia/oppia/wiki/Guide-on-defining-types#ts-7-1\n  private activeTabType!: string;\n  private activeSuggestionType!: string;\n\n  constructor(\n    private contributionAndReviewBackendApiService:\n      ContributionAndReviewBackendApiService\n  ) {}\n\n  getActiveTabType(): string {\n    return this.activeTabType;\n  }\n\n  setActiveTabType(activeTabType: string): void {\n    this.activeTabType = activeTabType;\n  }\n\n  getActiveSuggestionType(): string {\n    return this.activeSuggestionType;\n  }\n\n  setActiveSuggestionType(activeSuggestionType: string): void {\n    this.activeSuggestionType = activeSuggestionType;\n  }\n\n  private userCreatedQuestionFetcher: SuggestionFetcher = (\n    new SuggestionFetcher('SUBMITTED_QUESTION_SUGGESTIONS'));\n\n  private reviewableQuestionFetcher: SuggestionFetcher = (\n    new SuggestionFetcher('REVIEWABLE_QUESTION_SUGGESTIONS'));\n\n  private userCreatedTranslationFetcher: SuggestionFetcher = (\n    new SuggestionFetcher('SUBMITTED_TRANSLATION_SUGGESTIONS'));\n\n  private reviewableTranslationFetcher: SuggestionFetcher = (\n    new SuggestionFetcher('REVIEWABLE_TRANSLATION_SUGGESTIONS'));\n\n  /**\n   * Fetches suggestions from the backend.\n   *\n   * @param {SuggestionFetcher} fetcher - The fetcher for a particular\n   *   suggestion type.\n   * @param {boolean} shouldResetOffset - Whether to reset the input fetcher's\n   *   offset to 0 and clear the fetcher's cache. Set this to true to fetch\n   *   results starting from the beginning of all results matching the query.\n   * @returns {Promise<FetchSuggestionsResponse>}\n   */\n  private async fetchSuggestionsAsync(\n      fetcher: SuggestionFetcher,\n      shouldResetOffset: boolean,\n      explorationId?: string\n  ): Promise<FetchSuggestionsResponse> {\n    if (shouldResetOffset) {\n      // Handle the case where we need to fetch starting from the beginning.\n      fetcher.offset = 0;\n      fetcher.suggestionIdToDetails = {};\n    }\n    const currentCacheSize: number = Object.keys(\n      fetcher.suggestionIdToDetails).length;\n    return (\n      this.contributionAndReviewBackendApiService.fetchSuggestionsAsync(\n        fetcher.type,\n        // Fetch up to two pages at a time to compute if we have more results.\n        // The first page of results is returned to the caller and the second\n        // page is cached.\n        (AppConstants.OPPORTUNITIES_PAGE_SIZE * 2) - currentCacheSize,\n        fetcher.offset,\n        fetcher.sortKey,\n        explorationId\n      ).then((responseBody) => {\n        const responseSuggestionIdToDetails = fetcher.suggestionIdToDetails;\n        fetcher.suggestionIdToDetails = {};\n        const targetIdToDetails = responseBody.target_id_to_opportunity_dict;\n        responseBody.suggestions.forEach((suggestion) => {\n          const suggestionDetails = {\n            suggestion: suggestion,\n            details: targetIdToDetails[suggestion.target_id]\n          };\n          const responseSize: number = Object.keys(\n            responseSuggestionIdToDetails).length;\n          if (responseSize < AppConstants.OPPORTUNITIES_PAGE_SIZE) {\n            // Populate the response with up to a page's worth of results.\n            responseSuggestionIdToDetails[\n              suggestion.suggestion_id] = suggestionDetails;\n          } else {\n            // Cache the 2nd page.\n            fetcher.suggestionIdToDetails[\n              suggestion.suggestion_id] = suggestionDetails;\n          }\n        });\n        fetcher.offset = responseBody.next_offset;\n        return {\n          suggestionIdToDetails: responseSuggestionIdToDetails,\n          more: Object.keys(fetcher.suggestionIdToDetails).length > 0\n        };\n      })\n    );\n  }\n\n  async getUserCreatedQuestionSuggestionsAsync(\n      shouldResetOffset: boolean = true,\n      sortKey: string\n  ): Promise<FetchSuggestionsResponse> {\n    this.userCreatedQuestionFetcher.sortKey = sortKey;\n    return this.fetchSuggestionsAsync(\n      this.userCreatedQuestionFetcher,\n      shouldResetOffset);\n  }\n\n  async getReviewableQuestionSuggestionsAsync(\n      shouldResetOffset: boolean = true,\n      sortKey: string\n  ): Promise<FetchSuggestionsResponse> {\n    this.reviewableQuestionFetcher.sortKey = sortKey;\n    return this.fetchSuggestionsAsync(\n      this.reviewableQuestionFetcher,\n      shouldResetOffset);\n  }\n\n  async getUserCreatedTranslationSuggestionsAsync(\n      shouldResetOffset: boolean = true,\n      sortKey: string\n  ): Promise<FetchSuggestionsResponse> {\n    this.userCreatedTranslationFetcher.sortKey = sortKey;\n    return this.fetchSuggestionsAsync(\n      this.userCreatedTranslationFetcher,\n      shouldResetOffset);\n  }\n\n  async getReviewableTranslationSuggestionsAsync(\n      shouldResetOffset: boolean = true,\n      sortKey: string,\n      explorationId?: string\n  ): Promise<FetchSuggestionsResponse> {\n    this.reviewableTranslationFetcher.sortKey = sortKey;\n    return this.fetchSuggestionsAsync(\n      this.reviewableTranslationFetcher,\n      shouldResetOffset,\n      explorationId);\n  }\n\n  reviewExplorationSuggestion(\n      targetId: string, suggestionId: string, action: string,\n      reviewMessage: string, commitMessage: string | null,\n      onSuccess: (suggestionId: string) => void,\n      onFailure: (errorMessage: string) => void\n  ): Promise<void> {\n    const requestBody = {\n      action: action,\n      review_message: reviewMessage,\n      commit_message: commitMessage\n    };\n\n    return this.contributionAndReviewBackendApiService\n      .reviewExplorationSuggestionAsync(\n        targetId, suggestionId, requestBody\n      ).then(() => {\n        onSuccess(suggestionId);\n      }, (errorResponse) => {\n        onFailure && onFailure(errorResponse.error.error);\n      });\n  }\n\n  reviewSkillSuggestion(\n      targetId: string, suggestionId: string, action: string,\n      reviewMessage: string, skillDifficulty: string,\n      onSuccess: (suggestionId: string) => void,\n      onFailure: () => void\n  ): Promise<void> {\n    const requestBody = {\n      action: action,\n      review_message: reviewMessage,\n      skill_difficulty: skillDifficulty\n    };\n\n    return this.contributionAndReviewBackendApiService\n      .reviewSkillSuggestionAsync(\n        targetId, suggestionId, requestBody\n      ).then(() => {\n        onSuccess(suggestionId);\n      }, () => {\n        onFailure && onFailure();\n      });\n  }\n\n  async updateTranslationSuggestionAsync(\n      suggestionId: string, translationHtml: string,\n      onSuccess: () => void,\n      onFailure: (error: Error) => void\n  ): Promise<void> {\n    const requestBody = {\n      translation_html: translationHtml\n    };\n\n    return this.contributionAndReviewBackendApiService\n      .updateTranslationSuggestionAsync(\n        suggestionId, requestBody\n      ).then(() => {\n        onSuccess();\n      }, (error) => onFailure && onFailure(error));\n  }\n\n  async updateQuestionSuggestionAsync(\n      suggestionId: string, skillDifficulty: number,\n      questionStateData: StateBackendDict, imagesData: ImagesData[],\n      onSuccess: (suggestionId: string) => void,\n      onFailure: (suggestionId: string) => void\n  ): Promise<void> {\n    const payload = {\n      skill_difficulty: skillDifficulty,\n      question_state_data: questionStateData\n    };\n    const requestBody = new FormData();\n    requestBody.append('payload', JSON.stringify(payload));\n    imagesData.forEach(obj => {\n      if (obj.imageBlob !== null) {\n        requestBody.append(obj.filename, obj.imageBlob);\n      }\n    });\n\n    return this.contributionAndReviewBackendApiService\n      .updateQuestionSuggestionAsync(\n        suggestionId, requestBody\n      ).then(() => {\n        onSuccess(suggestionId);\n      }, () => onFailure && onFailure(suggestionId));\n  }\n\n  async downloadContributorCertificateAsync(\n      username: string,\n      suggestionType: string,\n      languageCode: string | null,\n      fromDate: string,\n      toDate: string\n  ): Promise<ContributorCertificateResponse> {\n    return this.contributionAndReviewBackendApiService\n      .downloadContributorCertificateAsync(\n        username, suggestionType, languageCode, fromDate, toDate);\n  }\n}\n\nangular.module('oppia').factory('ContributionAndReviewService',\n  downgradeInjectable(ContributionAndReviewService));\n"
    },
    {
      "filename": "main.py",
      "content": "# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"URL routing definitions, and some basic error/warmup handlers.\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\n\nfrom core import android_validation_constants\nfrom core import feconf\nfrom core.constants import constants\nfrom core.controllers import access_validators\nfrom core.controllers import acl_decorators\nfrom core.controllers import admin\nfrom core.controllers import android_e2e_config\nfrom core.controllers import base\nfrom core.controllers import beam_jobs\nfrom core.controllers import blog_admin\nfrom core.controllers import blog_dashboard\nfrom core.controllers import blog_homepage\nfrom core.controllers import classifier\nfrom core.controllers import classroom\nfrom core.controllers import collection_editor\nfrom core.controllers import collection_viewer\nfrom core.controllers import concept_card_viewer\nfrom core.controllers import contributor_dashboard\nfrom core.controllers import contributor_dashboard_admin\nfrom core.controllers import creator_dashboard\nfrom core.controllers import cron\nfrom core.controllers import custom_landing_pages\nfrom core.controllers import diagnostic_test_player\nfrom core.controllers import editor\nfrom core.controllers import email_dashboard\nfrom core.controllers import features\nfrom core.controllers import feedback\nfrom core.controllers import improvements\nfrom core.controllers import incoming_app_feedback_report\nfrom core.controllers import learner_dashboard\nfrom core.controllers import learner_goals\nfrom core.controllers import learner_group\nfrom core.controllers import learner_playlist\nfrom core.controllers import library\nfrom core.controllers import moderator\nfrom core.controllers import oppia_root\nfrom core.controllers import pages\nfrom core.controllers import platform_feature\nfrom core.controllers import practice_sessions\nfrom core.controllers import profile\nfrom core.controllers import question_editor\nfrom core.controllers import questions_list\nfrom core.controllers import reader\nfrom core.controllers import recent_commits\nfrom core.controllers import release_coordinator\nfrom core.controllers import resources\nfrom core.controllers import review_tests\nfrom core.controllers import skill_editor\nfrom core.controllers import skill_mastery\nfrom core.controllers import story_editor\nfrom core.controllers import story_viewer\nfrom core.controllers import subscriptions\nfrom core.controllers import subtopic_viewer\nfrom core.controllers import suggestion\nfrom core.controllers import tasks\nfrom core.controllers import topic_editor\nfrom core.controllers import topic_viewer\nfrom core.controllers import topics_and_skills_dashboard\nfrom core.controllers import voice_artist\nfrom core.platform import models\nfrom core.platform.auth import firebase_auth_services\n\nimport google.cloud.logging\nfrom typing import Dict, Optional, Type, TypeVar\nimport webapp2\nfrom webapp2_extras import routes\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from mypy_imports import datastore_services\n    from mypy_imports import memory_cache_services as cache_services\n\nT = TypeVar('T')  # pylint: disable=invalid-name\n\ncache_services = models.Registry.import_cache_services()\ndatastore_services = models.Registry.import_datastore_services()\n\n# Cloud Logging is disabled in emulator mode, since it is unnecessary and\n# creates a lot of noise.\nif not constants.EMULATOR_MODE:\n    # Instantiates a client and rtrieves a Cloud Logging handler based on the\n    # environment you're running in and integrates the handler with the Python\n    # logging module.\n    client = google.cloud.logging.Client()\n    client.setup_logging()\n\n# Suppress debug logging for chardet. See https://stackoverflow.com/a/48581323.\n# Without this, a lot of unnecessary debug logs are printed in error logs,\n# which makes it tiresome to identify the actual error.\nlogging.getLogger(name='chardet.charsetprober').setLevel(logging.INFO)\n\n\nclass InternetConnectivityHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Handles the get request to the server from the\n    frontend to check for internet connection.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET requests.\"\"\"\n        self.render_json({'is_internet_connected': True})\n\n\nclass FrontendErrorHandler(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Handles errors arising from the frontend.\"\"\"\n\n    REQUIRE_PAYLOAD_CSRF_CHECK = False\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'POST': {\n            'error': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n    }\n\n    @acl_decorators.open_access\n    def post(self) -> None:\n        \"\"\"Records errors reported by the frontend.\"\"\"\n        assert self.normalized_payload is not None\n        logging.error(\n            'Frontend error: %s' % self.normalized_payload.get('error')\n        )\n        self.render_json(self.values)\n\n\nclass WarmupPage(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Handles warmup requests.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_HTML\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        \"\"\"Handles GET warmup requests.\"\"\"\n        pass\n\n\nclass SplashRedirectPage(\n    base.BaseHandler[Dict[str, str], Dict[str, str]]\n):\n    \"\"\"Redirect the old splash URL, '/splash' to the new one, '/'.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_HTML\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    @acl_decorators.open_access\n    def get(self) -> None:\n        self.redirect('/')\n\n\n# Type for `defaults` is set to Dict[str, str] based on the usage in our\n# backend. Should be changed in future as per the requirements.\ndef get_redirect_route(\n        regex_route: str,\n        handler: Type[webapp2.RequestHandler],\n        defaults: Optional[Dict[str, str]] = None\n) -> routes.RedirectRoute:\n    \"\"\"Returns a route that redirects /foo/ to /foo.\n\n    Warning: this method strips off parameters after the trailing slash. URLs\n    with parameters should be formulated without the trailing slash.\n\n    Args:\n        regex_route: unicode. A raw string representing a route.\n        handler: RequestHandler. A callable to handle the route.\n        defaults: dict. Optional defaults parameter to be passed\n            into the RedirectRoute object.\n\n    Returns:\n        RedirectRoute. A RedirectRoute object for redirects.\n    \"\"\"\n    if defaults is None:\n        defaults = {}\n    name = regex_route.replace('/', '_')\n    return routes.RedirectRoute(\n        regex_route, handler, name, strict_slash=True, defaults=defaults)\n\n\n# Register the URLs with the classes responsible for handling them.\nURLS = [\n    get_redirect_route(r'/_ah/warmup', WarmupPage),\n    get_redirect_route(r'/splash', SplashRedirectPage),\n    get_redirect_route(\n        r'/internetconnectivityhandler', InternetConnectivityHandler),\n    get_redirect_route(r'/foundation', pages.FoundationRedirectPage),\n    get_redirect_route(r'/credits', pages.AboutRedirectPage),\n    get_redirect_route(r'/participate', pages.TeachRedirectPage),\n    get_redirect_route(r'/site_guidelines', pages.TeachRedirectPage),\n    get_redirect_route(r'/console_errors', pages.ConsoleErrorPage),\n\n    get_redirect_route(r'/forum', pages.ForumRedirectPage),\n\n    # Access Validators.\n    get_redirect_route(\n        r'%s/can_access_classroom_page' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.ClassroomAccessValidationHandler),\n\n    get_redirect_route(\n        r'%s/can_access_blog_home_page' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.BlogHomePageAccessValidationHandler),\n\n    get_redirect_route(\n        r'%s/can_access_blog_post_page' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.BlogPostPageAccessValidationHandler),\n\n    get_redirect_route(\n        r'%s/can_access_blog_author_profile_page/<author_username>' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.BlogAuthorProfilePageAccessValidationHandler),\n\n    get_redirect_route(\n        r'%s/can_manage_own_account' % feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.ManageOwnAccountValidationHandler),\n\n    get_redirect_route(\n        r'%s/does_profile_exist/<username>' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.ProfileExistsValidationHandler),\n\n    get_redirect_route(\n        r'%s/can_access_release_coordinator_page' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.ReleaseCoordinatorAccessValidationHandler\n    ),\n\n    get_redirect_route(\n        r'%s/does_learner_group_exist/<learner_group_id>' %\n        feconf.ACCESS_VALIDATION_HANDLER_PREFIX,\n        access_validators.ViewLearnerGroupPageAccessValidationHandler),\n\n    get_redirect_route(r'%s' % feconf.ADMIN_URL, admin.AdminPage),\n    get_redirect_route(r'/adminhandler', admin.AdminHandler),\n    get_redirect_route(r'/adminrolehandler', admin.AdminRoleHandler),\n    get_redirect_route(r'/bannedusershandler', admin.BannedUsersHandler),\n    get_redirect_route(\n        r'/topicmanagerrolehandler', admin.TopicManagerRoleHandler),\n    get_redirect_route(\n        r'/adminsuperadminhandler', admin.AdminSuperAdminPrivilegesHandler),\n    get_redirect_route(\n        r'/admintopicscsvdownloadhandler',\n        admin.AdminTopicsCsvFileDownloader),\n    get_redirect_route(\n        r'/updateblogpostdatahandler', admin.UpdateBlogPostHandler),\n    get_redirect_route(\n        r'/contributionrightshandler/<category>',\n        contributor_dashboard_admin.ContributionRightsHandler),\n    get_redirect_route(\n        r'/getcontributorusershandler/<category>',\n        contributor_dashboard_admin.ContributorUsersListHandler),\n    get_redirect_route(\n        r'/contributionrightsdatahandler',\n        contributor_dashboard_admin.ContributionRightsDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.CONTRIBUTOR_DASHBOARD_ADMIN_URL,\n        contributor_dashboard_admin.ContributorDashboardAdminPage),\n    get_redirect_route(\n        r'/translationcontributionstatshandler',\n        contributor_dashboard_admin.TranslationContributionStatsHandler),\n    get_redirect_route(\n        r'%s' % feconf.CONTRIBUTOR_DASHBOARD_URL,\n        contributor_dashboard.ContributorDashboardPage),\n    get_redirect_route(\n        r'%s/<contribution_type>/<contribution_subtype>/<username>' % (\n            feconf.CONTRIBUTOR_STATS_SUMMARIES_URL),\n        contributor_dashboard.ContributorStatsSummariesHandler),\n    get_redirect_route(\n        r'%s/<username>' % feconf.CONTRIBUTOR_ALL_STATS_SUMMARIES_URL,\n        contributor_dashboard.ContributorAllStatsSummariesHandler),\n    get_redirect_route(\n        r'%s/<username>/<suggestion_type>' % (\n            feconf.CONTRIBUTOR_CERTIFICATE_URL),\n        contributor_dashboard.ContributorCertificateHandler),\n    get_redirect_route(\n        '/contributor_dashboard',\n        creator_dashboard.OldContributorDashboardRedirectPage),\n    get_redirect_route(\n        '/creator_dashboard',\n        creator_dashboard.OldCreatorDashboardRedirectPage),\n    get_redirect_route(\n        r'%s' % feconf.CREATOR_DASHBOARD_URL,\n        creator_dashboard.CreatorDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.CREATOR_DASHBOARD_DATA_URL,\n        creator_dashboard.CreatorDashboardHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_EXPLORATION_URL,\n        creator_dashboard.NewExplorationHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_COLLECTION_URL,\n        creator_dashboard.NewCollectionHandler),\n    get_redirect_route(\n        r'%s' % feconf.FRACTIONS_LANDING_PAGE_URL,\n        custom_landing_pages.FractionLandingRedirectPage),\n    get_redirect_route(\n        r'/learn/maths/<topic>', custom_landing_pages.TopicLandingRedirectPage),\n    get_redirect_route(\n        r'%s/<opportunity_type>' % feconf.CONTRIBUTOR_OPPORTUNITIES_DATA_URL,\n        contributor_dashboard.ContributionOpportunitiesHandler),\n    get_redirect_route(\n        r'/preferredtranslationlanguage',\n        contributor_dashboard.TranslationPreferenceHandler),\n    get_redirect_route(\n        r'%s' % feconf.REVIEWABLE_OPPORTUNITIES_URL,\n        contributor_dashboard.ReviewableOpportunitiesHandler),\n    get_redirect_route(\n        r'/gettranslatabletexthandler',\n        contributor_dashboard.TranslatableTextHandler),\n    get_redirect_route(\n        r'%s' % feconf.MACHINE_TRANSLATION_DATA_URL,\n        contributor_dashboard.MachineTranslationStateTextsHandler),\n    get_redirect_route(\n        r'/usercontributionrightsdatahandler',\n        contributor_dashboard.UserContributionRightsDataHandler),\n    get_redirect_route(\n        r'/retrivefeaturedtranslationlanguages',\n        contributor_dashboard.FeaturedTranslationLanguagesHandler),\n    get_redirect_route(\n        r'/gettranslatabletopicnames',\n        contributor_dashboard.TranslatableTopicNamesHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_SKILL_URL,\n        topics_and_skills_dashboard.NewSkillHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_QUESTION_URL,\n        question_editor.QuestionCreationHandler),\n    get_redirect_route(\n        r'%s/<comma_separated_skill_ids>' % feconf.QUESTIONS_LIST_URL_PREFIX,\n        questions_list.QuestionsListHandler),\n    get_redirect_route(\n        r'%s/<comma_separated_skill_ids>' % feconf.QUESTION_COUNT_URL_PREFIX,\n        questions_list.QuestionCountDataHandler),\n    get_redirect_route(\n        r'%s/practice/session' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        practice_sessions.PracticeSessionsPage),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>' %\n        feconf.PRACTICE_SESSION_DATA_URL_PREFIX,\n        practice_sessions.PracticeSessionsPageDataHandler),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>'\n        r'/<story_url_fragment>' % feconf.REVIEW_TEST_DATA_URL_PREFIX,\n        review_tests.ReviewTestsPageDataHandler),\n    get_redirect_route(\n        r'%s/review-test/<story_url_fragment>'\n        % feconf.TOPIC_VIEWER_URL_PREFIX,\n        review_tests.ReviewTestsPage),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>'\n        r'/<story_url_fragment>' % feconf.STORY_DATA_HANDLER,\n        story_viewer.StoryPageDataHandler),\n    get_redirect_route(\n        r'%s/<story_url_fragment>' % feconf.STORY_URL_FRAGMENT_HANDLER,\n        story_editor.StoryUrlFragmentHandler),\n    get_redirect_route(\n        r'%s/<topic_name>' % feconf.TOPIC_NAME_HANDLER,\n        topic_editor.TopicNameHandler),\n    get_redirect_route(\n        r'%s/<topic_url_fragment>' % feconf.TOPIC_URL_FRAGMENT_HANDLER,\n        topic_editor.TopicUrlFragmentHandler),\n    get_redirect_route(\n        r'%s/<skill_description>' % feconf.SKILL_DESCRIPTION_HANDLER,\n        skill_editor.SkillDescriptionHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.DIAGNOSTIC_TEST_SKILL_ASSIGNMENT_HANDLER,\n        skill_editor.DiagnosticTestSkillAssignmentHandler),\n    get_redirect_route(\n        r'%s/' %\n        feconf.TOPIC_ID_TO_DIAGNOSTIC_TEST_SKILL_IDS_HANDLER,\n        topics_and_skills_dashboard.TopicIdToDiagnosticTestSkillIdsHandler),\n    get_redirect_route(\n        r'%s/story' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        topic_viewer.TopicViewerPage),\n    get_redirect_route(\n        r'%s' % feconf.DIAGNOSTIC_TEST_PLAYER_PAGE_URL,\n        diagnostic_test_player.DiagnosticTestPlayerPage\n    ),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.DIAGNOSTIC_TEST_QUESTIONS_HANDLER_URL,\n        diagnostic_test_player.DiagnosticTestQuestionsHandler\n    ),\n    get_redirect_route(\n        r'%s' % feconf.CLASSROOM_ADMIN_PAGE_URL,\n        classroom.ClassroomAdminPage),\n    get_redirect_route(\n        r'%s' % feconf.CLASSROOM_ADMIN_DATA_HANDLER_URL,\n        classroom.ClassroomAdminDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_CLASSROOM_ID_HANDLER_URL,\n        classroom.NewClassroomIdHandler),\n    get_redirect_route(\n        r'%s/<classroom_id>' % feconf.CLASSROOM_HANDLER_URL,\n        classroom.ClassroomHandler),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>' % feconf.CLASSROOM_URL_FRAGMENT_HANDLER,\n        classroom.ClassroomUrlFragmentHandler),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>' % feconf.CLASSROOM_ID_HANDLER_URL,\n        classroom.ClassroomIdHandler\n    ),\n\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>'\n        r'/<story_url_fragment>/<node_id>' % feconf.STORY_PROGRESS_URL_PREFIX,\n        story_viewer.StoryProgressHandler),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>'\n        r'/<subtopic_url_fragment>' % feconf.SUBTOPIC_DATA_HANDLER,\n        subtopic_viewer.SubtopicPageDataHandler),\n    get_redirect_route(\n        r'%s/revision' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        topic_viewer.TopicViewerPage),\n    get_redirect_route(\n        r'%s/revision/<subtopic_url_fragment>' %\n        feconf.TOPIC_VIEWER_URL_PREFIX, subtopic_viewer.SubtopicViewerPage),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_STORY_URL,\n        topic_editor.TopicEditorStoryHandler),\n    get_redirect_route(\n        r'%s' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        topic_viewer.TopicViewerPage),\n    get_redirect_route(\n        r'%s/practice' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        topic_viewer.TopicViewerPage),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>/<topic_url_fragment>'\n        % feconf.TOPIC_DATA_HANDLER,\n        topic_viewer.TopicPageDataHandler),\n    get_redirect_route(\n        r'%s/<classroom_url_fragment>' % feconf.CLASSROOM_DATA_HANDLER,\n        classroom.ClassroomDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.NEW_TOPIC_URL,\n        topics_and_skills_dashboard.NewTopicHandler),\n    get_redirect_route(\n        r'%s' % feconf.UPLOAD_EXPLORATION_URL,\n        creator_dashboard.UploadExplorationHandler),\n    get_redirect_route(\n        '/learner_dashboard',\n        learner_dashboard.OldLearnerDashboardRedirectPage),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_URL,\n        learner_dashboard.LearnerDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_TOPIC_AND_STORY_DATA_URL,\n        learner_dashboard.LearnerDashboardTopicsAndStoriesProgressHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_COMPLETED_CHAPTERS_COUNT_DATA_URL,\n        learner_dashboard.LearnerCompletedChaptersCountHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_COLLECTION_DATA_URL,\n        learner_dashboard.LearnerDashboardCollectionsProgressHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_EXPLORATION_DATA_URL,\n        learner_dashboard.LearnerDashboardExplorationsProgressHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_FEEDBACK_UPDATES_DATA_URL,\n        learner_dashboard.LearnerDashboardFeedbackUpdatesHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_IDS_DATA_URL,\n        learner_dashboard.LearnerDashboardIdsHandler),\n    get_redirect_route(\n        r'%s/<thread_id>' %\n        feconf.LEARNER_DASHBOARD_FEEDBACK_THREAD_DATA_URL,\n        learner_dashboard.LearnerDashboardFeedbackThreadHandler),\n    get_redirect_route(\n        r'%s' % feconf.TOPICS_AND_SKILLS_DASHBOARD_URL,\n        topics_and_skills_dashboard.TopicsAndSkillsDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.MERGE_SKILLS_URL,\n        topics_and_skills_dashboard.MergeSkillHandler),\n    get_redirect_route(\n        r'%s' % feconf.TOPICS_AND_SKILLS_DASHBOARD_DATA_URL,\n        topics_and_skills_dashboard.TopicsAndSkillsDashboardPageDataHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.UNASSIGN_SKILL_DATA_HANDLER_URL,\n        topics_and_skills_dashboard.TopicAssignmentsHandler),\n    get_redirect_route(\n        r'%s' % feconf.SKILL_DASHBOARD_DATA_URL,\n        topics_and_skills_dashboard.SkillsDashboardPageDataHandler),\n\n    get_redirect_route(\n        r'%s/<activity_type>/<activity_id>' %\n        feconf.LEARNER_INCOMPLETE_ACTIVITY_DATA_URL,\n        reader.LearnerIncompleteActivityHandler),\n\n    get_redirect_route(\n        r'%s/<activity_type>/<topic_id>' % feconf.LEARNER_GOALS_DATA_URL,\n        learner_goals.LearnerGoalsHandler),\n\n    get_redirect_route(\n        r'%s/<activity_type>/<activity_id>' % feconf.LEARNER_PLAYLIST_DATA_URL,\n        learner_playlist.LearnerPlaylistHandler),\n\n    get_redirect_route(\n        r'%s/<blog_post_url>' % feconf.BLOG_HOMEPAGE_DATA_URL,\n        blog_homepage.BlogPostDataHandler),\n    get_redirect_route(\n        r'%s/<author_username>' %\n        feconf.BLOG_AUTHOR_PROFILE_PAGE_DATA_URL_PREFIX,\n        blog_homepage.AuthorsPageHandler),\n    get_redirect_route(\n        r'%s' % feconf.BLOG_HOMEPAGE_DATA_URL,\n        blog_homepage.BlogHomepageDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.BLOG_SEARCH_DATA_URL,\n        blog_homepage.BlogPostSearchHandler),\n\n    get_redirect_route(\n        r'/assetsdevhandler/<page_context>/<page_identifier>/'\n        'assets/<asset_type:(image|audio|thumbnail)>/<encoded_filename>',\n        resources.AssetDevHandler),\n    get_redirect_route(\n        r'/value_generator_handler/<generator_id>',\n        resources.ValueGeneratorHandler),\n    get_redirect_route(r'/promo_bar_handler', resources.PromoBarHandler),\n    get_redirect_route('/library', library.OldLibraryRedirectPage),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_INDEX_DATA_URL, library.LibraryIndexHandler),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_GROUP_DATA_URL,\n        library.LibraryGroupIndexHandler),\n    get_redirect_route(\n        r'%s' % feconf.LIBRARY_SEARCH_DATA_URL, library.SearchHandler),\n    get_redirect_route(r'/gallery', library.LibraryRedirectPage),\n    get_redirect_route(r'/contribute', library.LibraryRedirectPage),\n    get_redirect_route(r'/learn', classroom.DefaultClassroomRedirectPage),\n    get_redirect_route(r'/playtest', library.LibraryRedirectPage),\n    get_redirect_route(\n        feconf.EXPLORATION_SUMMARIES_DATA_URL,\n        library.ExplorationSummariesHandler),\n    get_redirect_route(\n        feconf.COLLECTION_SUMMARIES_DATA_URL,\n        library.CollectionSummariesHandler),\n\n    get_redirect_route(\n        r'/profilehandler/data/<username>', profile.ProfileHandler),\n    get_redirect_route(\n        r'/mailinglistsubscriptionhandler',\n        profile.MailingListSubscriptionHandler),\n    get_redirect_route(\n        r'%s/<secret>' % feconf.BULK_EMAIL_WEBHOOK_ENDPOINT,\n        profile.BulkEmailWebhookEndpoint),\n    get_redirect_route(\n        feconf.PREFERENCES_DATA_URL, profile.PreferencesHandler),\n    get_redirect_route(\n        r'/preferenceshandler/profile_picture', profile.ProfilePictureHandler),\n    get_redirect_route(\n        r'/preferenceshandler/profile_picture_by_username/<username>',\n        profile.ProfilePictureHandlerByUsernameHandler),\n    get_redirect_route(r'%s' % feconf.SIGNUP_URL, profile.SignupPage),\n    get_redirect_route(r'%s' % feconf.SIGNUP_DATA_URL, profile.SignupHandler),\n    get_redirect_route(\n        feconf.DELETE_ACCOUNT_HANDLER_URL, profile.DeleteAccountHandler),\n    get_redirect_route(\n        feconf.EXPORT_ACCOUNT_HANDLER_URL, profile.ExportAccountHandler),\n    get_redirect_route(\n        r'%s' % feconf.USERNAME_CHECK_DATA_URL, profile.UsernameCheckHandler),\n    get_redirect_route(\n        r'%s' % feconf.SITE_LANGUAGE_DATA_URL, profile.SiteLanguageHandler),\n    get_redirect_route(r'/userinfohandler', profile.UserInfoHandler),\n    get_redirect_route(r'/userinfohandler/data', profile.UserInfoHandler),\n    get_redirect_route(r'/url_handler', profile.UrlHandler),\n    get_redirect_route(r'/moderator', moderator.ModeratorPage),\n    get_redirect_route(\n        r'/moderatorhandler/featured', moderator.FeaturedActivitiesHandler),\n    get_redirect_route(\n        r'/moderatorhandler/email_draft', moderator.EmailDraftHandler),\n\n    get_redirect_route(\n        r'/memorycachehandler', release_coordinator.MemoryCacheHandler),\n\n    get_redirect_route(\n        '/checkpoints_feature_status_handler',\n        reader.CheckpointsFeatureStatusHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_URL_PREFIX,\n        reader.ExplorationPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_URL_EMBED_PREFIX,\n        reader.ExplorationEmbedPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_INIT_URL_PREFIX,\n        reader.ExplorationHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_PRETESTS_URL_PREFIX,\n        reader.PretestHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_FEATURES_PREFIX,\n        features.ExplorationFeaturesHandler),\n    get_redirect_route(\n        '/explorehandler/exploration_start_event/<exploration_id>',\n        reader.ExplorationStartEventHandler),\n    get_redirect_route(\n        '/explorehandler/exploration_actual_start_event/<exploration_id>',\n        reader.ExplorationActualStartEventHandler),\n    get_redirect_route(\n        '/explorehandler/solution_hit_event/<exploration_id>',\n        reader.SolutionHitEventHandler),\n    get_redirect_route(\n        '/sync_logged_out_and_logged_in_progress/<exploration_id>',\n        reader.SyncLoggedOutLearnerProgressHandler),\n    get_redirect_route(\n        r'/explorehandler/state_hit_event/<exploration_id>',\n        reader.StateHitEventHandler),\n    get_redirect_route(\n        r'/explorehandler/state_complete_event/<exploration_id>',\n        reader.StateCompleteEventHandler),\n    get_redirect_route(\n        r'/explorehandler/checkpoint_reached_by_logged_out_user/<exploration_id>', # pylint: disable=line-too-long\n        reader.SaveTransientCheckpointProgressHandler),\n    get_redirect_route(\n        '/progress/<unique_progress_url_id>',\n        reader.TransientCheckpointUrlPage),\n    get_redirect_route(\n        r'/explorehandler/leave_for_refresher_exp_event/<exploration_id>',\n        reader.LeaveForRefresherExpEventHandler),\n    get_redirect_route(\n        r'/explorehandler/answer_submitted_event/<exploration_id>',\n        reader.AnswerSubmittedEventHandler),\n    get_redirect_route(\n        r'/explorehandler/checkpoint_reached/<exploration_id>',\n        reader.CheckpointReachedEventHandler),\n    get_redirect_route(\n        r'/explorehandler/restart/<exploration_id>',\n        reader.ExplorationRestartEventHandler),\n    get_redirect_route(\n        r'/explorehandler/give_feedback/<exploration_id>',\n        reader.ReaderFeedbackHandler),\n    get_redirect_route(\n        r'/explorehandler/exploration_complete_event/<exploration_id>',\n        reader.ExplorationCompleteEventHandler),\n    get_redirect_route(\n        r'/explorehandler/exploration_maybe_leave_event/<exploration_id>',\n        reader.ExplorationMaybeLeaveHandler),\n    get_redirect_route(\n        r'/explorehandler/stats_events/<exploration_id>',\n        reader.StatsEventsHandler),\n    get_redirect_route(\n        r'/explorehandler/store_playthrough/<exploration_id>',\n        reader.StorePlaythroughHandler),\n    get_redirect_route(\n        r'/explorehandler/rating/<exploration_id>', reader.RatingHandler),\n    get_redirect_route(\n        r'/explorehandler/recommendations/<exploration_id>',\n        reader.RecommendationsHandler),\n    get_redirect_route(\n        r'%s/<entity_type>/<entity_id>' % (\n            feconf.LEARNER_ANSWER_DETAILS_SUBMIT_URL),\n        reader.LearnerAnswerDetailsSubmissionHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>/<state_name>/<version>' % (\n            feconf.STATE_VERSION_HISTORY_URL_PREFIX\n        ), reader.StateVersionHistoryHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>/<version>' % (\n            feconf.METADATA_VERSION_HISTORY_URL_PREFIX\n        ), reader.MetadataVersionHistoryHandler),\n\n    get_redirect_route(\n        r'%s/<question_id>' % feconf.QUESTION_EDITOR_DATA_URL_PREFIX,\n        question_editor.EditableQuestionDataHandler),\n\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EDITOR_URL_PREFIX,\n        editor.ExplorationPage),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_DATA_PREFIX,\n        editor.ExplorationHandler),\n    get_redirect_route(\n        r'/editsallowedhandler/<exploration_id>',\n        editor.ExplorationEditsAllowedHandler),\n    get_redirect_route(\n        r'/createhandler/download/<exploration_id>',\n        editor.ExplorationFileDownloader),\n    get_redirect_route(\n        r'%s/<entity_type>/<entity_id>' % (\n            feconf.EXPLORATION_IMAGE_UPLOAD_PREFIX),\n        editor.ImageUploadHandler),\n    get_redirect_route(\n        r'/createhandler/audioupload/<exploration_id>',\n        voice_artist.AudioUploadHandler),\n    get_redirect_route(\n        r'/createhandler/state_yaml/<exploration_id>',\n        editor.StateYamlHandler),\n    get_redirect_route(\n        r'/createhandler/check_revert_valid/<exploration_id>/<version>',\n        editor.ExplorationCheckRevertValidHandler),\n    get_redirect_route(\n        r'/createhandler/revert/<exploration_id>',\n        editor.ExplorationRevertHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_RIGHTS_PREFIX,\n        editor.ExplorationRightsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.USER_PERMISSIONS_URL_PREFIX,\n        editor.UserExplorationPermissionsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_STATUS_PREFIX,\n        editor.ExplorationStatusHandler),\n    get_redirect_route(\n        r'/createhandler/moderatorrights/<exploration_id>',\n        editor.ExplorationModeratorRightsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.USER_EXPLORATION_EMAILS_PREFIX,\n        editor.UserExplorationEmailsHandler),\n    get_redirect_route(\n        r'/createhandler/snapshots/<exploration_id>',\n        editor.ExplorationSnapshotsHandler),\n    get_redirect_route(\n        r'/createhandler/statistics/<exploration_id>',\n        editor.ExplorationStatisticsHandler),\n    get_redirect_route(\n        r'/createhandler/state_interaction_stats/<exploration_id>/<state_name>',\n        editor.StateInteractionStatsHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.EXPLORATION_STATE_ANSWER_STATS_PREFIX,\n        editor.StateAnswerStatisticsHandler),\n    get_redirect_route(\n        r'/createhandler/started_tutorial_event/<exploration_id>',\n        editor.StartedTutorialEventHandler),\n    get_redirect_route(\n        r'/createhandler/started_translation_tutorial_event/<exploration_id>',\n        voice_artist.StartedTranslationTutorialEventHandler),\n    get_redirect_route(\n        r'/createhandler/autosave_draft/<exploration_id>',\n        editor.EditorAutosaveHandler),\n    get_redirect_route(\n        r'/createhandler/get_top_unresolved_answers/<exploration_id>',\n        editor.TopUnresolvedAnswersHandler),\n    get_redirect_route(\n        r'%s/<entity_type>/<entity_id>' %\n        feconf.LEARNER_ANSWER_INFO_HANDLER_URL,\n        editor.LearnerAnswerInfoHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.RECENT_COMMITS_DATA_URL,\n        recent_commits.RecentCommitsHandler),\n    get_redirect_route(\n        r'%s' % feconf.RECENT_FEEDBACK_MESSAGES_DATA_URL,\n        feedback.RecentFeedbackMessagesHandler),\n\n    get_redirect_route(\n        r'%s/<thread_id>' % feconf.FEEDBACK_THREAD_VIEW_EVENT_URL,\n        feedback.FeedbackThreadViewEventHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FEEDBACK_THREADLIST_URL_PREFIX,\n        feedback.ThreadListHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.FEEDBACK_THREADLIST_URL_PREFIX_FOR_TOPICS,\n        feedback.ThreadListHandlerForTopicsHandler),\n    get_redirect_route(\n        r'%s/<thread_id>' % feconf.FEEDBACK_THREAD_URL_PREFIX,\n        feedback.ThreadHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FEEDBACK_STATS_URL_PREFIX,\n        feedback.FeedbackStatsHandler),\n    get_redirect_route(\n        r'%s/' % feconf.SUGGESTION_URL_PREFIX,\n        suggestion.SuggestionHandler),\n    get_redirect_route(\n        r'%s/<suggestion_id>' % feconf.UPDATE_TRANSLATION_SUGGESTION_URL_PREFIX,\n        suggestion.UpdateTranslationSuggestionHandler),\n    get_redirect_route(\n        r'%s/<suggestion_id>' % feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n        suggestion.UpdateQuestionSuggestionHandler),\n    get_redirect_route(\n        r'%s' % feconf.QUESTIONS_URL_PREFIX,\n        reader.QuestionPlayerHandler),\n    get_redirect_route(\n        r'%s/exploration/<target_id>/<suggestion_id>' %\n        feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.SuggestionToExplorationActionHandler),\n    get_redirect_route(\n        r'%s/resubmit/<suggestion_id>' % feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.ResubmitSuggestionHandler),\n    get_redirect_route(\n        r'%s/skill/<target_id>/<suggestion_id>' %\n        feconf.SUGGESTION_ACTION_URL_PREFIX,\n        suggestion.SuggestionToSkillActionHandler),\n    get_redirect_route(\n        r'%s' % feconf.SUGGESTION_LIST_URL_PREFIX,\n        suggestion.SuggestionListHandler),\n    get_redirect_route(\n        r'/getreviewablesuggestions/<target_type>/<suggestion_type>',\n        suggestion.ReviewableSuggestionsHandler),\n    get_redirect_route(\n        r'/getsubmittedsuggestions/<target_type>/<suggestion_type>',\n        suggestion.UserSubmittedSuggestionsHandler),\n    get_redirect_route(\n        r'%s' % feconf.SUBSCRIBE_URL_PREFIX,\n        subscriptions.SubscribeHandler),\n    get_redirect_route(\n        r'%s' % feconf.UNSUBSCRIBE_URL_PREFIX,\n        subscriptions.UnsubscribeHandler),\n    get_redirect_route(\n        r'%s/<exploration_id>' % feconf.FLAG_EXPLORATION_URL_PREFIX,\n        reader.FlagExplorationHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_URL_PREFIX,\n        collection_viewer.CollectionPage),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_DATA_URL_PREFIX,\n        collection_viewer.CollectionDataHandler),\n\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_EDITOR_URL_PREFIX,\n        collection_editor.CollectionEditorPage),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_EDITOR_DATA_URL_PREFIX,\n        collection_editor.EditableCollectionDataHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_RIGHTS_PREFIX,\n        collection_editor.CollectionRightsHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_PUBLISH_PREFIX,\n        collection_editor.CollectionPublishHandler),\n    get_redirect_route(\n        r'%s/<collection_id>' % feconf.COLLECTION_UNPUBLISH_PREFIX,\n        collection_editor.CollectionUnpublishHandler),\n\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_URL_PREFIX,\n        topic_editor.TopicEditorPage),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_EDITOR_DATA_URL_PREFIX,\n        topic_editor.EditableTopicDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>/<subtopic_id>' %\n        feconf.SUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX,\n        topic_editor.EditableSubtopicPageDataHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_RIGHTS_URL_PREFIX,\n        topic_editor.TopicRightsHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_STATUS_URL_PREFIX,\n        topic_editor.TopicPublishHandler),\n    get_redirect_route(\n        r'%s/<topic_id>' % feconf.TOPIC_SEND_MAIL_URL_PREFIX,\n        topic_editor.TopicPublishSendMailHandler),\n    get_redirect_route(\n        r'%s/' % feconf.TOPIC_ID_TO_TOPIC_NAME,\n        topic_editor.TopicIdToTopicNameHandler),\n\n    get_redirect_route(\n        r'%s/<selected_skill_ids>' % feconf.CONCEPT_CARD_DATA_URL_PREFIX,\n        concept_card_viewer.ConceptCardDataHandler),\n    get_redirect_route(\n        r'%s/<question_id>' % feconf.QUESTION_SKILL_LINK_URL_PREFIX,\n        question_editor.QuestionSkillLinkHandler),\n    get_redirect_route(\n        r'%s/<comma_separated_skill_ids>' % feconf.SKILL_DATA_URL_PREFIX,\n        skill_editor.SkillDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.FETCH_SKILLS_URL_PREFIX,\n        skill_editor.FetchSkillsHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_EDITOR_URL_PREFIX,\n        skill_editor.SkillEditorPage),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_EDITOR_DATA_URL_PREFIX,\n        skill_editor.EditableSkillDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.SKILL_MASTERY_DATA_URL,\n        skill_mastery.SkillMasteryDataHandler),\n    get_redirect_route(\n        r'%s/<skill_id>' % feconf.SKILL_RIGHTS_URL_PREFIX,\n        skill_editor.SkillRightsHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.SUBTOPIC_MASTERY_DATA_URL,\n        skill_mastery.SubtopicMasteryDataHandler),\n\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.STORY_EDITOR_URL_PREFIX,\n        story_editor.StoryEditorPage),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.STORY_EDITOR_DATA_URL_PREFIX,\n        story_editor.EditableStoryDataHandler),\n    get_redirect_route(\n        r'%s/<story_id>' % feconf.STORY_PUBLISH_HANDLER,\n        story_editor.StoryPublishHandler),\n    get_redirect_route(\n        r'%s/<story_id>' %\n        feconf.VALIDATE_STORY_EXPLORATIONS_URL_PREFIX,\n        story_editor.ValidateExplorationsHandler),\n\n    get_redirect_route(\n        '/classroom_promos_status_handler',\n        classroom.ClassroomPromosStatusHandler),\n\n    get_redirect_route(r'/emaildashboard', email_dashboard.EmailDashboardPage),\n    get_redirect_route(\n        r'/emaildashboarddatahandler',\n        email_dashboard.EmailDashboardDataHandler),\n    get_redirect_route(\n        r'/querystatuscheck', email_dashboard.QueryStatusCheckHandler),\n    get_redirect_route(\n        r'/emaildashboardresult/<query_id>',\n        email_dashboard.EmailDashboardResultPage),\n    get_redirect_route(\n        r'/emaildashboardcancelresult/<query_id>',\n        email_dashboard.EmailDashboardCancelEmailHandler),\n    get_redirect_route(\n        r'/emaildashboardtestbulkemailhandler/<query_id>',\n        email_dashboard.EmailDashboardTestBulkEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.EXPLORATION_METADATA_SEARCH_URL,\n        collection_editor.ExplorationMetadataSearchHandler),\n    get_redirect_route(\n        r'/explorationdataextractionhandler', admin.DataExtractionQueryHandler),\n    get_redirect_route(\n        r'/senddummymailtoadminhandler', admin.SendDummyMailToAdminHandler),\n    get_redirect_route(r'/updateusernamehandler', admin.UpdateUsernameHandler),\n    get_redirect_route(\n        r'/numberofdeletionrequestshandler',\n        admin.NumberOfDeletionRequestsHandler),\n    get_redirect_route(\n        r'/verifyusermodelsdeletedhandler',\n        admin.VerifyUserModelsDeletedHandler),\n    get_redirect_route(r'/deleteuserhandler', admin.DeleteUserHandler),\n    get_redirect_route(r'/frontend_errors', FrontendErrorHandler),\n\n    get_redirect_route(r'/session_begin', base.SessionBeginHandler),\n    get_redirect_route(r'/session_end', base.SessionEndHandler),\n\n    get_redirect_route(\n        r'%s/%s/<exploration_id>' % (\n            feconf.IMPROVEMENTS_URL_PREFIX,\n            constants.TASK_ENTITY_TYPE_EXPLORATION),\n        improvements.ExplorationImprovementsHandler),\n    get_redirect_route(\n        r'%s/%s/<exploration_id>' % (\n            feconf.IMPROVEMENTS_HISTORY_URL_PREFIX,\n            constants.TASK_ENTITY_TYPE_EXPLORATION),\n        improvements.ExplorationImprovementsHistoryHandler),\n    get_redirect_route(\n        r'%s/%s/<exploration_id>' % (\n            feconf.IMPROVEMENTS_CONFIG_URL_PREFIX,\n            constants.TASK_ENTITY_TYPE_EXPLORATION),\n        improvements.ExplorationImprovementsConfigHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.BLOG_ADMIN_PAGE_URL, blog_admin.BlogAdminPage),\n    get_redirect_route(\n        r'%s' % feconf.BLOG_ADMIN_ROLE_HANDLER_URL,\n        blog_admin.BlogAdminRolesHandler),\n    get_redirect_route(\n        r'/blogadminhandler', blog_admin.BlogAdminHandler),\n\n    get_redirect_route('/beam_job', beam_jobs.BeamJobHandler),\n    get_redirect_route('/beam_job_run', beam_jobs.BeamJobRunHandler),\n    get_redirect_route(\n        '/beam_job_run_result', beam_jobs.BeamJobRunResultHandler),\n\n    get_redirect_route(\n        r'%s/<blog_post_id>' % feconf.BLOG_EDITOR_DATA_URL_PREFIX,\n        blog_dashboard.BlogPostHandler),\n    get_redirect_route(\n        r'%s' % feconf.BLOG_DASHBOARD_DATA_URL,\n        blog_dashboard.BlogDashboardDataHandler),\n    get_redirect_route(\n        r'%s' % feconf.BLOG_DASHBOARD_URL, blog_dashboard.BlogDashboardPage),\n\n    get_redirect_route(\n        r'/issuesdatahandler/<exploration_id>', editor.FetchIssuesHandler),\n\n    get_redirect_route(\n        r'/ml/trainedclassifierhandler', classifier.TrainedClassifierHandler),\n    get_redirect_route(\n        r'/ml/nextjobhandler', classifier.NextJobHandler),\n\n    get_redirect_route(\n        r'/playthroughdatahandler/<exploration_id>/<playthrough_id>',\n        editor.FetchPlaythroughHandler),\n\n    get_redirect_route(\n        r'/resolveissuehandler/<exploration_id>', editor.ResolveIssueHandler),\n\n    get_redirect_route(\n        r'%s' % feconf.CSRF_HANDLER_URL, base.CsrfTokenHandler),\n\n    get_redirect_route(\n        r'/platform_features_evaluation_handler',\n        platform_feature.PlatformFeaturesEvaluationHandler),\n    get_redirect_route(\n        r'/platform_feature_dummy_handler',\n        platform_feature.PlatformFeatureDummyHandler),\n\n    get_redirect_route(\n        r'%s' % (\n            android_validation_constants.INCOMING_ANDROID_FEEDBACK_REPORT_URL),\n        incoming_app_feedback_report.IncomingAndroidFeedbackReportHandler),\n\n    get_redirect_route(\n        r'/voice_artist_management_handler/<entity_type>/<entity_id>',\n        voice_artist.VoiceArtistManagementHandler),\n\n    get_redirect_route(\n        r'/topics_and_skills_dashboard/categorized_and_untriaged_skills_data',\n        topics_and_skills_dashboard\n            .CategorizedAndUntriagedSkillsDataHandler),\n\n    get_redirect_route(\n        r'/create_learner_group_handler',\n        learner_group.CreateLearnerGroupHandler),\n    get_redirect_route(\n        r'/update_learner_group_handler/<learner_group_id>',\n        learner_group.LearnerGroupHandler),\n    get_redirect_route(\n        r'/delete_learner_group_handler/<learner_group_id>',\n        learner_group.LearnerGroupHandler),\n    get_redirect_route(\n        r'%s' % feconf.FACILITATOR_DASHBOARD_HANDLER,\n        learner_group.FacilitatorDashboardHandler),\n    get_redirect_route(\n        r'%s' % feconf.LEARNER_DASHBOARD_LEARNER_GROUPS_HANDLER,\n        learner_group.LearnerDashboardLearnerGroupsHandler),\n    get_redirect_route(\n        r'/view_learner_group_info_handler/<learner_group_id>',\n        learner_group.ViewLearnerGroupInfoHandler),\n    get_redirect_route(\n        r'/learner_group_search_syllabus_handler',\n        learner_group.LearnerGroupSearchSyllabusHandler),\n    get_redirect_route(\n        r'/learner_group_syllabus_handler/<learner_group_id>',\n        learner_group.LearnerGroupSyllabusHandler),\n    get_redirect_route(\n        r'/learner_group_user_progress_handler/<learner_group_id>',\n        learner_group.LearnerGroupLearnerProgressHandler),\n    get_redirect_route(\n        r'/learner_group_learner_specific_progress_handler/<learner_group_id>',\n        learner_group.LearnerGroupLearnerSpecificProgressHandler\n    ),\n    get_redirect_route(\n        r'%s' % feconf.FACILITATOR_DASHBOARD_PAGE_URL,\n        learner_group.FacilitatorDashboardPage),\n    get_redirect_route(\n        r'%s' % feconf.CREATE_LEARNER_GROUP_PAGE_URL,\n        learner_group.CreateLearnerGroupPage),\n    get_redirect_route(\n        r'/learner_group_search_learner_handler',\n        learner_group.LearnerGroupSearchLearnerHandler),\n    get_redirect_route(\n        r'/learner_group_learners_info_handler/<learner_group_id>',\n        learner_group.LearnerGroupLearnersInfoHandler),\n    get_redirect_route(\n        r'/learner_group_learner_invitation_handler/<learner_group_id>',\n        learner_group.LearnerGroupLearnerInvitationHandler),\n    get_redirect_route(\n        r'/learner_group_progress_sharing_permission_handler/<learner_group_id>', # pylint: disable=line-too-long\n        learner_group.LearnerGroupProgressSharingPermissionHandler),\n    get_redirect_route(\n        r'/exit_learner_group_handler/<learner_group_id>',\n        learner_group.ExitLearnerGroupHandler),\n    get_redirect_route(\n        r'/edit-learner-group/<group_id>', learner_group.EditLearnerGroupPage),\n    get_redirect_route(\n        r'/user_progress_in_stories_chapters_handler/<username>',\n        learner_group.LearnerStoriesChaptersProgressHandler),\n    get_redirect_route(\n        '/learner_groups_feature_status_handler',\n        learner_group.LearnerGroupsFeatureStatusHandler)\n]\n\n# Adding redirects for topic landing pages.\nfor subject, topics in constants.AVAILABLE_LANDING_PAGES.items():\n    for topic in topics:\n        URLS.append(\n            get_redirect_route(\n                r'/%s/%s' % (subject, topic),\n                oppia_root.OppiaRootPage))\n\nif constants.DEV_MODE:\n    URLS.append(\n        get_redirect_route(\n            r'/initialize_android_test_data',\n            android_e2e_config.InitializeAndroidTestDataHandler))\n\n# Adding redirects for all stewards landing pages.\nfor stewards_route in constants.STEWARDS_LANDING_PAGE['ROUTES']:\n    URLS.append(\n        get_redirect_route(\n            r'/%s' % stewards_route, oppia_root.OppiaRootPage))\n\n# Redirect all routes handled using angular router to the oppia root page.\nfor page in constants.PAGES_REGISTERED_WITH_FRONTEND.values():\n    if not 'MANUALLY_REGISTERED_WITH_BACKEND' in page:\n        if 'LIGHTWEIGHT' in page:\n            URLS.append(\n                get_redirect_route(\n                    r'/%s' % page['ROUTE'],\n                    oppia_root.OppiaLightweightRootPage\n                )\n            )\n        else:\n            URLS.append(\n                get_redirect_route(\n                    r'/%s' % page['ROUTE'], oppia_root.OppiaRootPage))\n\n# Manually redirect routes with url fragments to the oppia root page.\nURLS.extend((\n    get_redirect_route(r'/profile/<username>', oppia_root.OppiaRootPage),\n    get_redirect_route(\n        r'%s/story/<story_url_fragment>' % feconf.TOPIC_VIEWER_URL_PREFIX,\n        oppia_root.OppiaRootPage),\n    get_redirect_route(\n        r'/learn/<classroom_url_fragment>',\n        oppia_root.OppiaLightweightRootPage\n    ),\n    get_redirect_route(\n        r'%s/<blog_post_url>' % feconf.BLOG_HOMEPAGE_URL,\n        oppia_root.OppiaRootPage\n    ),\n    get_redirect_route(\n        r'%s/<author_username>' % feconf.BLOG_AUTHOR_PROFILE_PAGE_URL_PREFIX,\n        oppia_root.OppiaRootPage\n    )\n))\n\n# Add cron urls. Note that cron URLs MUST start with /cron for them to work\n# in production (see dispatch() in base.py).\nURLS.extend((\n    get_redirect_route(\n        r'/cron/models/cleanup', cron.CronModelsCleanupHandler),\n    get_redirect_route(\n        r'/cron/users/user_deletion', cron.CronUserDeletionHandler),\n    get_redirect_route(\n        r'/cron/users/fully_complete_user_deletion',\n        cron.CronFullyCompleteUserDeletionHandler),\n    get_redirect_route(\n        r'/cron/mail/admins/contributor_dashboard_bottlenecks',\n        cron.CronMailAdminContributorDashboardBottlenecksHandler),\n    get_redirect_route(\n        r'/cron/mail/reviewers/contributor_dashboard_suggestions',\n        cron.CronMailReviewersContributorDashboardSuggestionsHandler),\n    get_redirect_route(\n        r'/cron/app_feedback_report/scrub_expiring_reports',\n        cron.CronAppFeedbackReportsScrubberHandlerPage),\n    get_redirect_route(\n        r'/cron/explorations/recommendations',\n        cron.CronExplorationRecommendationsHandler),\n    get_redirect_route(\n        r'/cron/explorations/search_rank', cron.CronActivitySearchRankHandler),\n    get_redirect_route(\n        r'/cron/blog_posts/search_rank', cron.CronBlogPostSearchRankHandler),\n    get_redirect_route(\n        r'/cron/users/dashboard_stats', cron.CronDashboardStatsHandler),\n    get_redirect_route(\n        r'/cron/suggestions/translation_contribution_stats',\n        cron.CronTranslationContributionStatsHandler),\n))\n\n# Add tasks urls.\nURLS.extend((\n    get_redirect_route(\n        r'%s' % feconf.TASK_URL_FEEDBACK_MESSAGE_EMAILS,\n        tasks.UnsentFeedbackEmailHandler),\n    get_redirect_route(\n        r'%s' % (\n            feconf\n            .TASK_URL_CONTRIBUTOR_DASHBOARD_ACHIEVEMENT_NOTIFICATION_EMAILS),\n        tasks.ContributorDashboardAchievementEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.TASK_URL_FLAG_EXPLORATION_EMAILS,\n        tasks.FlagExplorationEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.TASK_URL_INSTANT_FEEDBACK_EMAILS,\n        tasks.InstantFeedbackMessageEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.TASK_URL_FEEDBACK_STATUS_EMAILS,\n        tasks.FeedbackThreadStatusChangeEmailHandler),\n    get_redirect_route(\n        r'%s' % feconf.TASK_URL_DEFERRED, tasks.DeferredTasksHandler),\n))\n\n# 404 error handler (Needs to be at the end of the URLS list).\nURLS.append(get_redirect_route(r'/<:.*>', base.Error404Handler))\n\n\nclass NdbWsgiMiddleware:\n    \"\"\"Wraps the WSGI application into the NDB client context.\"\"\"\n\n    def __init__(self, wsgi_app: webapp2.WSGIApplication) -> None:\n        self.wsgi_app = wsgi_app\n\n    def __call__(\n        self,\n        environ: Dict[str, str],\n        start_response: webapp2.Response\n    ) -> webapp2.Response:\n        global_cache = datastore_services.RedisCache(\n            cache_services.CLOUD_NDB_REDIS_CLIENT)\n        with datastore_services.get_ndb_context(global_cache=global_cache):\n            return self.wsgi_app(environ, start_response)\n\n\napp_without_context = webapp2.WSGIApplication(URLS, debug=feconf.DEBUG)\napp = NdbWsgiMiddleware(app_without_context)\nfirebase_auth_services.establish_firebase_connection()\n"
    }
  ],
  "questions": [],
  "golden_answers": [],
  "questions_generated": [
    "What are the main components involved in the collapsing animation of the contributor dashboard header, and where can they be found in the codebase?",
    "How might the current jumpy animation be affecting user experience on the contributor dashboard?",
    "What steps are recommended for new contributors who want to work on the contributor dashboard page?",
    "How can a developer test changes made to the contributor dashboard header locally?",
    "What might be the purpose of the animation for the contributor dashboard header, despite its small size difference when collapsed?",
    "Which file might contain the style definitions affecting the animation of the contributor dashboard header?",
    "What are some potential solutions to address the jumpy animation problem in the contributor dashboard header?",
    "Why might the animation issue be particularly noticeable on a MacOS desktop using Chrome?",
    "What are some technical challenges a developer might face when fixing this animation issue?"
  ],
  "golden_answers_generated": [
    "The main components involved in the collapsing animation of the contributor dashboard header are likely defined in the HTML and CSS files related to the contributor dashboard. Specifically, the header code can be found in 'core/templates/pages/contributor-dashboard-page/contributor-dashboard-page.component.html'.",
    "The jumpy animation can be distracting and disrupt the user's focus, especially if the collapsed version of the header is not significantly smaller. This inconsistency can lead to a poor user experience by creating unnecessary visual noise and distraction.",
    "New contributors are advised to read the user documentation for contributing translations/questions on the contributor dashboard. They should also refer to the provided Google Doc for instructions on populating contributor dashboard data during local development testing.",
    "A developer can test changes locally by following the instructions in the documentation for populating contributor dashboard data. This involves setting up a local development environment and using the guide to simulate the dashboard's behavior.",
    "The animation might be intended to save space and give more room for content as the user scrolls down. However, if the collapsed header is not significantly smaller, the utility of this animation is questionable and might need redesign.",
    "The style definitions for the animation might be located in a CSS or SCSS file that is linked to the 'contributor-dashboard-page.component.html'. Developers should check any accompanying style files in the same directory or referenced in the HTML file.",
    "Solutions could include adjusting the animation's timing or easing properties, simplifying the animation to reduce jumpiness, or redesigning the header to make the collapsed version significantly smaller and thus more functional.",
    "The issue might be more noticeable due to specific rendering behaviors or optimizations in Chrome on MacOS that expose the jumpiness more than other environments. Differences in hardware acceleration or browser rendering engines can affect animation smoothness.",
    "Challenges include ensuring cross-browser compatibility, maintaining accessibility standards, and making sure the animation performs well on different devices and screen sizes. Developers must also ensure that any changes fit within existing design patterns and user interface guidelines."
  ]
}