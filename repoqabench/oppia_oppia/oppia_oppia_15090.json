{
  "repo_name": "oppia_oppia",
  "issue_id": "15090",
  "issue_description": "# Lint Check for Indentation\n\n## Introduction\r\n\r\nWe would like to have a pylint check for indentation in Python code. This will likely require a custom lint check. Here are some of the cases we want to handle:\r\n\r\n### Indent By 4 Spaces\r\n\r\nGood:\r\n\r\n```python\r\ndef func():\r\n    pass\r\n```\r\n\r\n```python\r\nmy_list = [\r\n    'a',\r\n    'b',\r\n]\r\n```\r\n\r\nBad:\r\n\r\n```python\r\ndef func():\r\n  pass\r\n```\r\n\r\n```python\r\nmy_list = ['a',\r\n           'b',\r\n]\r\n```\r\n\r\n### Indent by 8 Spaces for Clarity\r\n\r\nSometimes indenting by 4 spaces is confusing:\r\n\r\n```python\r\nif (\r\n    some_var == 1):\r\n    pass\r\n```\r\n\r\nIn these cases, we should indent by 8 spaces instead:\r\n\r\n```python\r\nif (\r\n        some_var == 1):\r\n    pass\r\n```\r\n\r\n### Closing Braces/Brackets/Parentheses at End of Line or Same Indentation as Opening Brace/Bracket/Parenthesis\r\n\r\nGood:\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n    ],\r\n    'b': True,\r\n}\r\n```\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2],\r\n    'b': True,\r\n}\r\n```\r\n\r\nBad:\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n        ],\r\n}\r\n```\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n],\r\n}\r\n```\r\n\r\n### Sometimes It's Okay to Not Indent\r\n\r\nIn some cases, putting a pair of parentheses/braces/brackets on a new line and indenting is unnecessary:\r\n\r\n```python\r\nsome_function(\r\n    {\r\n        'a': True,\r\n    }\r\n)\r\n```\r\n\r\nThis is fine instead:\r\n\r\n```python\r\nsome_function({\r\n    'a': True,\r\n})\r\n```\r\n\r\nNote that here we treat the `({` as a single opening character, so the `'a': True` line is only indented by 4 spaces (not 8).\r\n\r\nContact: @seanlip ",
  "issue_comments": [
    {
      "id": 1066919176,
      "user": "devarsh10",
      "body": "Is this issue resolved?\r\nIf not, please assign it to me.\r\nThanks and Regards.\r\n"
    },
    {
      "id": 1067724794,
      "user": "Hatilar420",
      "body": "@U8NWXD can i work on this issue ?\r\nThanks."
    },
    {
      "id": 1068787192,
      "user": "U8NWXD",
      "body": "@devarsh10 I've assigned you. See more discussion here: https://github.com/oppia/oppia/pull/15070#discussion_r820423355"
    },
    {
      "id": 1072033626,
      "user": "devarsh10",
      "body": "Hey @U8NWXD ,\r\nCan I get the files link in which I have to indent?\r\n\r\nAnd Thank You for assingning this issue to me.\r\nRegards."
    },
    {
      "id": 1072781814,
      "user": "U8NWXD",
      "body": "@devarsh10 there might not be any files currently where this rule is violated. The goal here is to write a lint check so that we can catch these issues automatically. Right now, reviewers have to manually check indentations"
    },
    {
      "id": 1072955352,
      "user": "devarsh10",
      "body": "Okay, I'll look into it."
    },
    {
      "id": 1124472646,
      "user": "Sumanth077",
      "body": "Hello @devarsh10 are you working on it currently?"
    },
    {
      "id": 1124494769,
      "user": "devarsh10",
      "body": "Sorry, I've been working on it.\nBut due to lack of time and knowledge about programming, I'm stuck.\nIf anyone is there waiting, please assign it to them.\n\nAnd sorry again, I'll get back to oppia in a while after working on my\nprograming knowledge.\n\nSincerely,\nDevarsh.\n\nOn Thu, 12 May 2022, 8:13 am Sumanth, ***@***.***> wrote:\n\n> Hello @devarsh10 <https://github.com/devarsh10> are you working on it\n> currently?\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/oppia/oppia/issues/15090#issuecomment-1124472646>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT4MQN3OVP2SMV6N72TH3YLVJRV6HANCNFSM5QCLUHOQ>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n"
    },
    {
      "id": 1136780752,
      "user": "RobertMeissner",
      "body": "Hy, why do you need a custom linter and not, e.g., for python \"black\" or for AngularJS \"prettier\"? If you want to use these - opinionated but state-of-the-art - tools, then please assign me to this issue :) "
    },
    {
      "id": 1137865415,
      "user": "U8NWXD",
      "body": "@RMeissnerCC we don't use tools like black or prettier because they enforce a different coding style than our [style guide](https://github.com/oppia/oppia/wiki/Coding-style-guide), and as far as I know, no one has been able to configure them to enforce our style guide"
    },
    {
      "id": 1141172730,
      "user": "RobertMeissner",
      "body": "Thank you for the feedback. So basically, right now there is no automatic formatting and everyone has to do this manually? "
    },
    {
      "id": 1145338185,
      "user": "U8NWXD",
      "body": "@RMeissnerCC that's correct. I think it'd be great to have an automatic formatter that works with Oppia's code style, but we haven't prioritized developing one because once someone gets used to Oppia's code style, our experience has been that it's pretty easy to do the formatting manually"
    },
    {
      "id": 1145601841,
      "user": "RobertMeissner",
      "body": "So you can basically close this ticket? "
    },
    {
      "id": 1146152554,
      "user": "U8NWXD",
      "body": "@RMeissnerCC no, even though we aren't planning on adding an automatic formatter, we still need a lint check to make sure we're indenting correctly"
    },
    {
      "id": 1153263030,
      "user": "udyanojha",
      "body": "@U8NWXD Hi! \r\nCould you please refer some resources for the issue. I would like to learn and resolve this. \r\nThanks "
    },
    {
      "id": 1153439456,
      "user": "U8NWXD",
      "body": "Take a look at https://github.com/oppia/oppia/wiki/Custom-Pylint-checks to learn how to write lint checks for Python files"
    },
    {
      "id": 1153439584,
      "user": "U8NWXD",
      "body": "~@devarsh10 are you still working on this?~\r\n\r\nEDIT: see https://github.com/oppia/oppia/issues/15090#issuecomment-1124494769"
    },
    {
      "id": 1184462135,
      "user": "FaazAbidi",
      "body": "Is anyone working on it? If not, I can do it. @U8NWXD "
    },
    {
      "id": 1185116456,
      "user": "U8NWXD",
      "body": "All yours @FaazAbidi!"
    },
    {
      "id": 1199742329,
      "user": "FaazAbidi",
      "body": "Hello @U8NWXD, I am unable to register my IndentationChecker class. Whenever I am registering my custom check class in the register function, it is throwing UnboundLocalError on tests run. If I remove `linter.register_checker(IndentationChecker(linter))` from register function, it works fine. Can you guide me on this? I am stuck on this for hours. I closely followed the documentation. It is no help at this stage.\r\n\r\nmy custom linter rule class (not fully-completed yet):\r\n![image](https://user-images.githubusercontent.com/57310134/181806422-2983b40c-d21b-4e71-ae25-44e8b7e6231d.png)\r\n\r\n\r\nregister func in pylint_extensions.py:\r\n![image](https://user-images.githubusercontent.com/57310134/181805418-72e001d0-e2ac-4ec2-85d4-d6061a72a41a.png)\r\n\r\n\r\nHere's the error:\r\n![image](https://user-images.githubusercontent.com/57310134/181805232-e20d2fef-f7be-4b08-b2af-fea909e3d4e2.png)\r\n\r\n\r\ncommand used for running tests:\r\n`python -m scripts.run_backend_tests --test_target=scripts.linters.pylint_extensions_test --verbose`"
    },
    {
      "id": 1200063810,
      "user": "U8NWXD",
      "body": "@FaazAbidi can you paste the logs you see from before the `WARNING: FAILED TO RUN...` message? The `AttributeError: 'NoneType' object has no attribute 'group'` error usually arises because the test failed to output a coverage message because of an earlier error. Also, have you merged in the latest `develop`? We recently changed the code throwing `UnboundLocalError` to fix a bug"
    },
    {
      "id": 1200248731,
      "user": "FaazAbidi",
      "body": "Thank you @U8NWXD. After merging the latest `develop`, the logs were really helpful (nice improvement), I found the cause of error. It was message id. I was using the message id `C0040`  and it was already taken by some other custom rule. So, I changed it and it's working fine now. Thank you!"
    },
    {
      "id": 1334522506,
      "user": "Vedant1",
      "body": "Hi, I am currently in a software engineering class and as my final project I was tasked with fixing bugs on open source code. Oppia peaked my interest, and I would love to contribute to fixing this issue. Would find any tips helpful from people who worked on this prior. @ketakiG101 is my partner on this project, so any advice for the both of us would be great. Thanks!"
    },
    {
      "id": 1334633903,
      "user": "U8NWXD",
      "body": "I'm assuming that @FaazAbidi isn't working on this anymore, so assigning to @Vedant1"
    },
    {
      "id": 1343263543,
      "user": "ketakig101",
      "body": "Hello working on this with @Vedant1 and as we are writing the different pylint check for indentation we are wondering if there are any other examples than the ones provided above? "
    },
    {
      "id": 1343339873,
      "user": "U8NWXD",
      "body": "@ketakig101 I can't think of any other situations, but there might be some edge cases I'm not coming up with right now. My suggestion would be to run it your linter on the code base (or parts of it) and see if it behaves reasonably. You can also refer to our style guide: https://github.com/oppia/oppia/wiki/Coding-style-guide"
    },
    {
      "id": 1343361307,
      "user": "ketakig101",
      "body": "@U8NWXD sounds good will try it out. Also, we were checking out the style guide and wondering if functions with multiple parameters should be styled differently than a list because the above example is different from the function example on the style guide. "
    },
    {
      "id": 1345138406,
      "user": "U8NWXD",
      "body": "```\r\nmy_function_with_a_really_long_name(\r\n    'abc', 'def', None)\r\n```\r\n\r\nAre you referring to the above code from the style guide? It's validly formatted, but this would also be valid:\r\n\r\n```\r\nmy_function_with_a_really_long_name(\r\n    'abc',\r\n    'def',\r\n    None,\r\n)\r\n```\r\n\r\nDoes that help?"
    },
    {
      "id": 1379773320,
      "user": "U8NWXD",
      "body": "Deassigning due to inactivity. @Vedant1 please let me know if you're still working on this and I can re-assign you"
    },
    {
      "id": 1386598757,
      "user": "SAGARGAUD01",
      "body": "I am also going to start working on this."
    }
  ],
  "text_context": "# Lint Check for Indentation\n\n## Introduction\r\n\r\nWe would like to have a pylint check for indentation in Python code. This will likely require a custom lint check. Here are some of the cases we want to handle:\r\n\r\n### Indent By 4 Spaces\r\n\r\nGood:\r\n\r\n```python\r\ndef func():\r\n    pass\r\n```\r\n\r\n```python\r\nmy_list = [\r\n    'a',\r\n    'b',\r\n]\r\n```\r\n\r\nBad:\r\n\r\n```python\r\ndef func():\r\n  pass\r\n```\r\n\r\n```python\r\nmy_list = ['a',\r\n           'b',\r\n]\r\n```\r\n\r\n### Indent by 8 Spaces for Clarity\r\n\r\nSometimes indenting by 4 spaces is confusing:\r\n\r\n```python\r\nif (\r\n    some_var == 1):\r\n    pass\r\n```\r\n\r\nIn these cases, we should indent by 8 spaces instead:\r\n\r\n```python\r\nif (\r\n        some_var == 1):\r\n    pass\r\n```\r\n\r\n### Closing Braces/Brackets/Parentheses at End of Line or Same Indentation as Opening Brace/Bracket/Parenthesis\r\n\r\nGood:\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n    ],\r\n    'b': True,\r\n}\r\n```\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2],\r\n    'b': True,\r\n}\r\n```\r\n\r\nBad:\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n        ],\r\n}\r\n```\r\n\r\n```python\r\nmy_list = {\r\n    'a': [\r\n        1,\r\n        2,\r\n],\r\n}\r\n```\r\n\r\n### Sometimes It's Okay to Not Indent\r\n\r\nIn some cases, putting a pair of parentheses/braces/brackets on a new line and indenting is unnecessary:\r\n\r\n```python\r\nsome_function(\r\n    {\r\n        'a': True,\r\n    }\r\n)\r\n```\r\n\r\nThis is fine instead:\r\n\r\n```python\r\nsome_function({\r\n    'a': True,\r\n})\r\n```\r\n\r\nNote that here we treat the `({` as a single opening character, so the `'a': True` line is only indented by 4 spaces (not 8).\r\n\r\nContact: @seanlip \n\nIs this issue resolved?\r\nIf not, please assign it to me.\r\nThanks and Regards.\r\n\n\n@U8NWXD can i work on this issue ?\r\nThanks.\n\n@devarsh10 I've assigned you. See more discussion here: https://github.com/oppia/oppia/pull/15070#discussion_r820423355\n\nHey @U8NWXD ,\r\nCan I get the files link in which I have to indent?\r\n\r\nAnd Thank You for assingning this issue to me.\r\nRegards.\n\n@devarsh10 there might not be any files currently where this rule is violated. The goal here is to write a lint check so that we can catch these issues automatically. Right now, reviewers have to manually check indentations\n\nOkay, I'll look into it.\n\nHello @devarsh10 are you working on it currently?\n\nSorry, I've been working on it.\nBut due to lack of time and knowledge about programming, I'm stuck.\nIf anyone is there waiting, please assign it to them.\n\nAnd sorry again, I'll get back to oppia in a while after working on my\nprograming knowledge.\n\nSincerely,\nDevarsh.\n\nOn Thu, 12 May 2022, 8:13 am Sumanth, ***@***.***> wrote:\n\n> Hello @devarsh10 <https://github.com/devarsh10> are you working on it\n> currently?\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/oppia/oppia/issues/15090#issuecomment-1124472646>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT4MQN3OVP2SMV6N72TH3YLVJRV6HANCNFSM5QCLUHOQ>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n\n\nHy, why do you need a custom linter and not, e.g., for python \"black\" or for AngularJS \"prettier\"? If you want to use these - opinionated but state-of-the-art - tools, then please assign me to this issue :) \n\n@RMeissnerCC we don't use tools like black or prettier because they enforce a different coding style than our [style guide](https://github.com/oppia/oppia/wiki/Coding-style-guide), and as far as I know, no one has been able to configure them to enforce our style guide\n\nThank you for the feedback. So basically, right now there is no automatic formatting and everyone has to do this manually? \n\n@RMeissnerCC that's correct. I think it'd be great to have an automatic formatter that works with Oppia's code style, but we haven't prioritized developing one because once someone gets used to Oppia's code style, our experience has been that it's pretty easy to do the formatting manually\n\nSo you can basically close this ticket? \n\n@RMeissnerCC no, even though we aren't planning on adding an automatic formatter, we still need a lint check to make sure we're indenting correctly\n\n@U8NWXD Hi! \r\nCould you please refer some resources for the issue. I would like to learn and resolve this. \r\nThanks \n\nTake a look at https://github.com/oppia/oppia/wiki/Custom-Pylint-checks to learn how to write lint checks for Python files\n\n~@devarsh10 are you still working on this?~\r\n\r\nEDIT: see https://github.com/oppia/oppia/issues/15090#issuecomment-1124494769\n\nIs anyone working on it? If not, I can do it. @U8NWXD \n\nAll yours @FaazAbidi!\n\nHello @U8NWXD, I am unable to register my IndentationChecker class. Whenever I am registering my custom check class in the register function, it is throwing UnboundLocalError on tests run. If I remove `linter.register_checker(IndentationChecker(linter))` from register function, it works fine. Can you guide me on this? I am stuck on this for hours. I closely followed the documentation. It is no help at this stage.\r\n\r\nmy custom linter rule class (not fully-completed yet):\r\n![image](https://user-images.githubusercontent.com/57310134/181806422-2983b40c-d21b-4e71-ae25-44e8b7e6231d.png)\r\n\r\n\r\nregister func in pylint_extensions.py:\r\n![image](https://user-images.githubusercontent.com/57310134/181805418-72e001d0-e2ac-4ec2-85d4-d6061a72a41a.png)\r\n\r\n\r\nHere's the error:\r\n![image](https://user-images.githubusercontent.com/57310134/181805232-e20d2fef-f7be-4b08-b2af-fea909e3d4e2.png)\r\n\r\n\r\ncommand used for running tests:\r\n`python -m scripts.run_backend_tests --test_target=scripts.linters.pylint_extensions_test --verbose`\n\n@FaazAbidi can you paste the logs you see from before the `WARNING: FAILED TO RUN...` message? The `AttributeError: 'NoneType' object has no attribute 'group'` error usually arises because the test failed to output a coverage message because of an earlier error. Also, have you merged in the latest `develop`? We recently changed the code throwing `UnboundLocalError` to fix a bug\n\nThank you @U8NWXD. After merging the latest `develop`, the logs were really helpful (nice improvement), I found the cause of error. It was message id. I was using the message id `C0040`  and it was already taken by some other custom rule. So, I changed it and it's working fine now. Thank you!\n\nHi, I am currently in a software engineering class and as my final project I was tasked with fixing bugs on open source code. Oppia peaked my interest, and I would love to contribute to fixing this issue. Would find any tips helpful from people who worked on this prior. @ketakiG101 is my partner on this project, so any advice for the both of us would be great. Thanks!\n\nI'm assuming that @FaazAbidi isn't working on this anymore, so assigning to @Vedant1\n\nHello working on this with @Vedant1 and as we are writing the different pylint check for indentation we are wondering if there are any other examples than the ones provided above? \n\n@ketakig101 I can't think of any other situations, but there might be some edge cases I'm not coming up with right now. My suggestion would be to run it your linter on the code base (or parts of it) and see if it behaves reasonably. You can also refer to our style guide: https://github.com/oppia/oppia/wiki/Coding-style-guide\n\n@U8NWXD sounds good will try it out. Also, we were checking out the style guide and wondering if functions with multiple parameters should be styled differently than a list because the above example is different from the function example on the style guide. \n\n```\r\nmy_function_with_a_really_long_name(\r\n    'abc', 'def', None)\r\n```\r\n\r\nAre you referring to the above code from the style guide? It's validly formatted, but this would also be valid:\r\n\r\n```\r\nmy_function_with_a_really_long_name(\r\n    'abc',\r\n    'def',\r\n    None,\r\n)\r\n```\r\n\r\nDoes that help?\n\nDeassigning due to inactivity. @Vedant1 please let me know if you're still working on this and I can re-assign you\n\nI am also going to start working on this.",
  "pr_link": "https://github.com/oppia/oppia/pull/15070",
  "code_context": [
    {
      "filename": "core/controllers/suggestion.py",
      "content": "# coding: utf-8\n#\n# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Controllers for suggestions.\"\"\"\n\nfrom __future__ import annotations\n\nimport base64\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.controllers import domain_objects_validator\nfrom core.domain import exp_fetchers\nfrom core.domain import fs_services\nfrom core.domain import html_cleaner\nfrom core.domain import image_validation_services\nfrom core.domain import opportunity_services\nfrom core.domain import skill_fetchers\nfrom core.domain import state_domain\nfrom core.domain import suggestion_services\nfrom core.domain import topic_fetchers\n\n\nclass SuggestionHandler(base.BaseHandler):\n    \"\"\"\"Handles operations relating to suggestions.\"\"\"\n\n    URL_PATH_ARGS_SCHEMAS = {}\n    HANDLER_ARGS_SCHEMAS = {\n        'POST': {\n            'suggestion_type': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': feconf.SUGGESTION_TYPE_CHOICES\n                }\n            },\n            'target_type': {\n                'schema': {\n                    'type': 'basestring',\n                    'choices': feconf.SUGGESTION_TARGET_TYPE_CHOICES\n                }\n            },\n            'target_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'target_version_at_submission': {\n                'schema': {\n                    'type': 'int',\n                    'validators': [{\n                        'id': 'is_at_least',\n                        'min_value': 1\n                    }]\n                }\n            },\n            'change': {\n                'schema': {\n                    'type': 'object_dict',\n                    'validation_method': (\n                        domain_objects_validator.validate_suggestion_change\n                    )\n                }\n            },\n            'description': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'files': {\n                'schema': {\n                    'type': 'object_dict',\n                    'validation_method': (\n                        domain_objects_validator.\n                        validate_suggestion_images\n                    )\n                },\n                'default_value': None\n            }\n        }\n    }\n\n    @acl_decorators.can_suggest_changes\n    def post(self):\n        \"\"\"Handles POST requests.\"\"\"\n        if (self.normalized_payload.get('suggestion_type') ==\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT):\n            raise self.InvalidInputException(\n                'Content suggestion submissions are no longer supported.')\n\n        suggestion = suggestion_services.create_suggestion(\n            self.normalized_payload.get('suggestion_type'),\n            self.normalized_payload.get('target_type'),\n            self.normalized_payload.get('target_id'),\n            self.normalized_payload.get('target_version_at_submission'),\n            self.user_id,\n            self.normalized_payload.get('change'),\n            self.normalized_payload.get('description'))\n\n        suggestion_change = suggestion.change\n        if (\n                suggestion_change.cmd == 'add_written_translation' and\n                suggestion_change.data_format in\n                (\n                    state_domain.WrittenTranslation\n                    .DATA_FORMAT_SET_OF_NORMALIZED_STRING,\n                    state_domain.WrittenTranslation\n                    .DATA_FORMAT_SET_OF_UNICODE_STRING\n                )\n        ):\n            self.render_json(self.values)\n            return\n\n        # Images for question suggestions are already stored in the server\n        # before actually the question is submitted. Therefore no need of\n        # uploading images when the suggestion type is 'add_question'. But this\n        # is not good, since when the user cancels a question suggestion after\n        # adding an image, there is no method to remove the uploaded image.\n        # See more - https://github.com/oppia/oppia/issues/14298\n        if self.normalized_payload.get(\n            'suggestion_type') != (feconf.SUGGESTION_TYPE_ADD_QUESTION):\n            _upload_suggestion_images(\n                self.normalized_payload.get('files'),\n                suggestion,\n                suggestion.get_new_image_filenames_added_in_suggestion())\n\n        self.render_json(self.values)\n\n\nclass SuggestionToExplorationActionHandler(base.BaseHandler):\n    \"\"\"Handles actions performed on suggestions to explorations.\"\"\"\n\n    @acl_decorators.get_decorator_for_accepting_suggestion(\n        acl_decorators.can_edit_exploration)\n    def put(self, target_id, suggestion_id):\n        \"\"\"Handles PUT requests.\n\n        Args:\n            target_id: str. The ID of the suggestion target.\n            suggestion_id: str. The ID of the suggestion.\n        \"\"\"\n        if (\n                suggestion_id.split('.')[0] !=\n                feconf.ENTITY_TYPE_EXPLORATION):\n            raise self.InvalidInputException(\n                'This handler allows actions only'\n                ' on suggestions to explorations.')\n\n        if suggestion_id.split('.')[1] != target_id:\n            raise self.InvalidInputException(\n                'The exploration id provided does not match the exploration id '\n                'present as part of the suggestion_id')\n\n        action = self.payload.get('action')\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n\n        if suggestion.author_id == self.user_id:\n            raise self.UnauthorizedUserException(\n                'You cannot accept/reject your own suggestion.')\n\n        if action == constants.ACTION_ACCEPT_SUGGESTION:\n            commit_message = self.payload.get('commit_message')\n            if (commit_message is not None and\n                    len(commit_message) > constants.MAX_COMMIT_MESSAGE_LENGTH):\n                raise self.InvalidInputException(\n                    'Commit messages must be at most %s characters long.'\n                    % constants.MAX_COMMIT_MESSAGE_LENGTH)\n            suggestion_services.accept_suggestion(\n                suggestion_id, self.user_id, self.payload.get('commit_message'),\n                self.payload.get('review_message'))\n        elif action == constants.ACTION_REJECT_SUGGESTION:\n            suggestion_services.reject_suggestion(\n                suggestion_id, self.user_id, self.payload.get('review_message'))\n        else:\n            raise self.InvalidInputException('Invalid action.')\n\n        self.render_json(self.values)\n\n\nclass ResubmitSuggestionHandler(base.BaseHandler):\n    \"\"\"Handler to reopen a rejected suggestion.\"\"\"\n\n    @acl_decorators.can_resubmit_suggestion\n    def put(self, suggestion_id):\n        \"\"\"Handles PUT requests.\n\n        Args:\n            suggestion_id: str. The ID of the suggestion.\n        \"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        new_change = self.payload.get('change')\n        change_cls = type(suggestion.change)\n        change_object = change_cls(new_change)\n        summary_message = self.payload.get('summary_message')\n        suggestion_services.resubmit_rejected_suggestion(\n            suggestion_id, summary_message, self.user_id, change_object)\n        self.render_json(self.values)\n\n\nclass SuggestionToSkillActionHandler(base.BaseHandler):\n    \"\"\"Handles actions performed on suggestions to skills.\"\"\"\n\n    @acl_decorators.get_decorator_for_accepting_suggestion(\n        acl_decorators.can_edit_skill)\n    def put(self, target_id, suggestion_id):\n        \"\"\"Handles PUT requests.\n\n        Args:\n            target_id: str. The ID of the suggestion target.\n            suggestion_id: str. The ID of the suggestion.\n        \"\"\"\n        if suggestion_id.split('.')[0] != feconf.ENTITY_TYPE_SKILL:\n            raise self.InvalidInputException(\n                'This handler allows actions only on suggestions to skills.')\n\n        if suggestion_id.split('.')[1] != target_id:\n            raise self.InvalidInputException(\n                'The skill id provided does not match the skill id present as '\n                'part of the suggestion_id')\n\n        action = self.payload.get('action')\n\n        if action == constants.ACTION_ACCEPT_SUGGESTION:\n            # Question suggestions do not use commit messages.\n            suggestion_services.accept_suggestion(\n                suggestion_id, self.user_id, 'UNUSED_COMMIT_MESSAGE',\n                self.payload.get('review_message'))\n\n            suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n            target_entity_html_list = (\n                suggestion.get_target_entity_html_strings())\n            target_image_filenames = (\n                html_cleaner.get_image_filenames_from_html_strings(\n                    target_entity_html_list))\n\n            fs_services.copy_images(\n                suggestion.target_type, suggestion.target_id,\n                feconf.IMAGE_CONTEXT_QUESTION_SUGGESTIONS, suggestion.target_id,\n                target_image_filenames)\n        elif action == constants.ACTION_REJECT_SUGGESTION:\n            suggestion_services.reject_suggestion(\n                suggestion_id, self.user_id, self.payload.get('review_message'))\n        else:\n            raise self.InvalidInputException('Invalid action.')\n\n        self.render_json(self.values)\n\n\nclass SuggestionsProviderHandler(base.BaseHandler):\n    \"\"\"Provides suggestions for a user and given suggestion type.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    def _require_valid_suggestion_and_target_types(\n            self, target_type, suggestion_type):\n        \"\"\"Checks whether the given target_type and suggestion_type are valid.\n\n        Args:\n            target_type: str. The type of the suggestion target.\n            suggestion_type: str. The type of the suggestion.\n\n        Raises:\n            InvalidInputException. If the given target_type of suggestion_type\n                are invalid.\n        \"\"\"\n        if target_type not in feconf.SUGGESTION_TARGET_TYPE_CHOICES:\n            raise self.InvalidInputException(\n                'Invalid target_type: %s' % target_type)\n\n        if suggestion_type not in feconf.SUGGESTION_TYPE_CHOICES:\n            raise self.InvalidInputException(\n                'Invalid suggestion_type: %s' % suggestion_type)\n\n    def _render_suggestions(self, target_type, suggestions, next_offset):\n        \"\"\"Renders retrieved suggestions.\n\n        Args:\n            target_type: str. The suggestion type.\n            suggestions: list(BaseSuggestion). A list of suggestions to render.\n            next_offset: int. The number of results to skip from the beginning\n                of all results matching the original query.\n        \"\"\"\n        if target_type == feconf.ENTITY_TYPE_EXPLORATION:\n            target_id_to_opportunity_dict = (\n                _get_target_id_to_exploration_opportunity_dict(suggestions))\n            self.render_json({\n                'suggestions': _construct_exploration_suggestions(suggestions),\n                'target_id_to_opportunity_dict':\n                    target_id_to_opportunity_dict,\n                'next_offset': next_offset\n            })\n        elif target_type == feconf.ENTITY_TYPE_SKILL:\n            target_id_to_opportunity_dict = (\n                _get_target_id_to_skill_opportunity_dict(suggestions))\n            self.render_json({\n                'suggestions': [s.to_dict() for s in suggestions],\n                'target_id_to_opportunity_dict':\n                    target_id_to_opportunity_dict,\n                'next_offset': next_offset\n            })\n        else:\n            self.render_json({})\n\n\nclass ReviewableSuggestionsHandler(SuggestionsProviderHandler):\n    \"\"\"Provides all suggestions which can be reviewed by the user for a given\n    suggestion type.\n    \"\"\"\n\n    URL_PATH_ARGS_SCHEMAS = {\n        'target_type': {\n            'schema': {\n                'type': 'basestring',\n            },\n            'choices': feconf.SUGGESTION_TARGET_TYPE_CHOICES\n        },\n        'suggestion_type': {\n            'schema': {\n                'type': 'basestring',\n            },\n            'choices': feconf.SUGGESTION_TYPE_CHOICES\n        }\n    }\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'limit': {\n                'schema': {\n                    'type': 'int',\n                    'validators': [{\n                        'id': 'is_at_least',\n                        'min_value': 1\n                    }]\n                }\n            },\n            'offset': {\n                'schema': {\n                    'type': 'int',\n                    'validators': [{\n                        'id': 'is_at_least',\n                        'min_value': 0\n                    }]\n                }\n            },\n            'topic_name': {\n                'schema': {\n                    'type': 'basestring'\n                },\n                'default_value': None\n            }\n        }\n    }\n\n    @acl_decorators.can_view_reviewable_suggestions\n    def get(self, target_type, suggestion_type):\n        \"\"\"Handles GET requests.\n\n        Args:\n            target_type: str. The type of the suggestion target.\n            suggestion_type: str. The type of the suggestion.\n        \"\"\"\n        self._require_valid_suggestion_and_target_types(\n            target_type, suggestion_type)\n        limit = self.normalized_request.get('limit')\n        offset = self.normalized_request.get('offset')\n        topic_name = self.request.get('topic_name', None)\n\n        opportunity_summary_exp_ids_specific_to_topic = None\n        if (topic_name is not None) and (\n                topic_name != feconf.ALL_LITERAL_CONSTANT):\n            topic = topic_fetchers.get_topic_by_name(topic_name)\n            if topic is None:\n                raise self.InvalidInputException(\n                    'The supplied input topic: %s is not valid' % topic_name)\n\n            exploration_opportunity_summaries = (\n                opportunity_services.\n                get_exploration_opportunity_summaries_by_topic_id(\n                    topic.id))\n\n            opportunity_summary_exp_ids_specific_to_topic = [\n                opportunity.id for opportunity\n                in exploration_opportunity_summaries]\n\n        suggestions = []\n        next_offset = 0\n        if suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n            suggestions, next_offset = (\n                suggestion_services.\n                get_reviewable_translation_suggestions_by_offset(\n                    self.user_id,\n                    opportunity_summary_exp_ids_specific_to_topic,\n                    limit, offset))\n        elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n            suggestions, next_offset = (\n                suggestion_services.\n                get_reviewable_question_suggestions_by_offset(\n                    self.user_id, limit, offset))\n        self._render_suggestions(target_type, suggestions, next_offset)\n\n\nclass UserSubmittedSuggestionsHandler(SuggestionsProviderHandler):\n    \"\"\"Provides all suggestions which are submitted by the user for a given\n    suggestion type.\n    \"\"\"\n\n    URL_PATH_ARGS_SCHEMAS = {\n        'target_type': {\n            'schema': {\n                'type': 'basestring',\n            },\n            'choices': feconf.SUGGESTION_TARGET_TYPE_CHOICES\n        },\n        'suggestion_type': {\n            'schema': {\n                'type': 'basestring',\n            },\n            'choices': feconf.SUGGESTION_TYPE_CHOICES\n        }\n    }\n\n    HANDLER_ARGS_SCHEMAS = {\n        'GET': {\n            'limit': {\n                'schema': {\n                    'type': 'int',\n                    'validators': [{\n                        'id': 'is_at_least',\n                        'min_value': 1\n                    }]\n                }\n            },\n            'offset': {\n                'schema': {\n                    'type': 'int',\n                    'validators': [{\n                        'id': 'is_at_least',\n                        'min_value': 0\n                    }]\n                }\n            }\n        }\n    }\n\n    @acl_decorators.can_suggest_changes\n    def get(self, target_type, suggestion_type):\n        \"\"\"Handles GET requests.\n\n        Args:\n            target_type: str. The type of the suggestion target.\n            suggestion_type: str. The type of the suggestion.\n        \"\"\"\n        self._require_valid_suggestion_and_target_types(\n            target_type, suggestion_type)\n        limit = self.normalized_request.get('limit')\n        offset = self.normalized_request.get('offset')\n        suggestions, next_offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n            self.user_id, suggestion_type, limit, offset))\n        self._render_suggestions(target_type, suggestions, next_offset)\n\n\nclass SuggestionListHandler(base.BaseHandler):\n    \"\"\"Handles list operations on suggestions.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    @acl_decorators.open_access\n    def get(self):\n        \"\"\"Handles GET requests.\"\"\"\n        # The query_fields_and_values variable is a list of tuples. The first\n        # element in each tuple is the field being queried and the second\n        # element is the value of the field being queried.\n        # request.GET.items() parses the params from the url into the above\n        # format. So in the url, the query should be passed as:\n        # ?field1=value1&field2=value2...fieldN=valueN.\n        query_fields_and_values = list(self.request.GET.items())\n\n        for query in query_fields_and_values:\n            if query[0] not in feconf.ALLOWED_SUGGESTION_QUERY_FIELDS:\n                raise self.InvalidInputException(\n                    'Not allowed to query on field %s' % query[0])\n\n        suggestions = suggestion_services.query_suggestions(\n            query_fields_and_values)\n\n        self.values.update({'suggestions': [s.to_dict() for s in suggestions]})\n        self.render_json(self.values)\n\n\nclass UpdateTranslationSuggestionHandler(base.BaseHandler):\n    \"\"\"Handles update operations relating to translation suggestions.\"\"\"\n\n    @acl_decorators.can_update_suggestion\n    def put(self, suggestion_id):\n        \"\"\"Handles PUT requests.\n\n        Raises:\n            InvalidInputException. The suggestion is already handled.\n            InvalidInputException. The 'translation_html' parameter is missing.\n            InvalidInputException. The 'translation_html' parameter is not a\n                string.\n        \"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        if suggestion.is_handled:\n            raise self.InvalidInputException(\n                'The suggestion with id %s has been accepted or rejected'\n                % (suggestion_id)\n            )\n\n        if self.payload.get('translation_html') is None:\n            raise self.InvalidInputException(\n                'The parameter \\'translation_html\\' is missing.'\n            )\n\n        if (\n                not isinstance(self.payload.get('translation_html'), str)\n                and not isinstance(self.payload.get('translation_html'), list)\n        ):\n            raise self.InvalidInputException(\n                'The parameter \\'translation_html\\' should be a string or a' +\n                ' list.'\n            )\n\n        suggestion_services.update_translation_suggestion(\n            suggestion_id, self.payload.get('translation_html'))\n\n        self.render_json(self.values)\n\n\nclass UpdateQuestionSuggestionHandler(base.BaseHandler):\n    \"\"\"Handles update operations relating to question suggestions.\"\"\"\n\n    @acl_decorators.can_update_suggestion\n    def post(self, suggestion_id):\n        \"\"\"Handles PUT requests.\n\n        Raises:\n            InvalidInputException. The suggestion is already handled.\n            InvalidInputException. The 'skill_difficulty' parameter is missing.\n            InvalidInputException. The 'skill_difficulty' is not a decimal.\n            InvalidInputException. The 'question_state_data' parameter is\n                missing.\n            InvalidInputException. The 'question_state_data' parameter is\n                invalid.\n        \"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        if suggestion.is_handled:\n            raise self.InvalidInputException(\n                'The suggestion with id %s has been accepted or rejected'\n                % suggestion_id\n            )\n\n        if self.payload.get('skill_difficulty') is None:\n            raise self.InvalidInputException(\n                'The parameter \\'skill_difficulty\\' is missing.'\n            )\n\n        if not isinstance(self.payload.get('skill_difficulty'), (float, int)):\n            raise self.InvalidInputException(\n                'The parameter \\'skill_difficulty\\' should be a decimal.'\n            )\n\n        if self.payload.get('question_state_data') is None:\n            raise self.InvalidInputException(\n                'The parameter \\'question_state_data\\' is missing.'\n            )\n\n        question_state_data_obj = state_domain.State.from_dict(\n            self.payload.get('question_state_data'))\n        question_state_data_obj.validate(None, False)\n\n        suggestion_services.update_question_suggestion(\n            suggestion_id,\n            self.payload.get('skill_difficulty'),\n            self.payload.get('question_state_data'))\n\n        self.render_json(self.values)\n\n\ndef _get_target_id_to_exploration_opportunity_dict(suggestions):\n    \"\"\"Returns a dict of target_id to exploration opportunity summary dict.\n\n    Args:\n        suggestions: list(BaseSuggestion). A list of suggestions to retrieve\n            opportunity dicts.\n\n    Returns:\n        dict. Dict mapping target_id to corresponding exploration opportunity\n        summary dict.\n    \"\"\"\n    target_ids = set(s.target_id for s in suggestions)\n    opportunity_id_to_opportunity_dict = {\n        opp_id: (opp.to_dict() if opp is not None else None)\n        for opp_id, opp in (\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                list(target_ids)).items())\n    }\n    return opportunity_id_to_opportunity_dict\n\n\ndef _get_target_id_to_skill_opportunity_dict(suggestions):\n    \"\"\"Returns a dict of target_id to skill opportunity summary dict.\n\n    Args:\n        suggestions: list(BaseSuggestion). A list of suggestions to retrieve\n            opportunity dicts.\n\n    Returns:\n        dict. Dict mapping target_id to corresponding skill opportunity dict.\n    \"\"\"\n    target_ids = set(s.target_id for s in suggestions)\n    opportunity_id_to_opportunity_dict = {\n        opp_id: (opp.to_dict() if opp is not None else None)\n        for opp_id, opp in opportunity_services.get_skill_opportunities_by_ids(\n            list(target_ids)).items()\n    }\n    opportunity_id_to_skill = {\n        skill.id: skill\n        for skill in skill_fetchers.get_multi_skills([\n            opp['id']\n            for opp in opportunity_id_to_opportunity_dict.values()\n            if opp is not None])\n    }\n\n    for opp_id, skill in opportunity_id_to_skill.items():\n        if skill is not None:\n            opportunity_id_to_opportunity_dict[opp_id]['skill_rubrics'] = [\n                rubric.to_dict() for rubric in skill.rubrics]\n\n    return opportunity_id_to_opportunity_dict\n\n\ndef _construct_exploration_suggestions(suggestions):\n    \"\"\"Returns exploration suggestions with current exploration content.\n\n    Args:\n        suggestions: list(BaseSuggestion). A list of suggestions.\n\n    Returns:\n        list(dict). List of suggestion dicts with an additional\n        exploration_content_html field representing the target\n        exploration's current content. If the given suggestion refers to an\n        invalid content ID in the current exploration (this can happen if that\n        content was deleted after the suggestion was made), the corresponding\n        suggestion dict will be omitted from the return value.\n    \"\"\"\n    exp_ids = {suggestion.target_id for suggestion in suggestions}\n    exp_id_to_exp = exp_fetchers.get_multiple_explorations_by_id(list(exp_ids))\n\n    suggestion_dicts = []\n    for suggestion in suggestions:\n        available_states = exp_id_to_exp[suggestion.target_id].states\n        content_id_exists = False\n\n        # Checks whether the state name within change object of the suggestion\n        # is actually available in the target entity being suggested to and\n        # then find the availability of the content ID in the translatable\n        # content. See more - https://github.com/oppia/oppia/issues/14339\n        if suggestion.change.state_name in available_states:\n            content_id_exists = available_states[\n                suggestion.change.state_name].has_content_id(\n                    suggestion.change.content_id)\n\n        if content_id_exists:\n            content_html = exp_id_to_exp[suggestion.target_id].get_content_html(\n                suggestion.change.state_name, suggestion.change.content_id)\n            suggestion_dict = suggestion.to_dict()\n            suggestion_dict['exploration_content_html'] = content_html\n            suggestion_dicts.append(suggestion_dict)\n    return suggestion_dicts\n\n\ndef _upload_suggestion_images(files, suggestion, filenames):\n    \"\"\"Saves a suggestion's images to storage.\n\n    Args:\n        files: dict. Files containing a mapping of image\n            filename to image blob.\n        suggestion: BaseSuggestion. The suggestion for which images are being\n            uploaded.\n        filenames: list(str). The image filenames.\n    \"\"\"\n    suggestion_image_context = suggestion.image_context\n    # TODO(#10513): Find a way to save the images before the suggestion is\n    # created.\n    for filename in filenames:\n        image = files.get(filename)\n        image = base64.decodebytes(image.encode('utf-8'))\n        file_format = (\n            image_validation_services.validate_image_and_filename(\n                image, filename))\n        image_is_compressible = (\n            file_format in feconf.COMPRESSIBLE_IMAGE_FORMATS)\n        fs_services.save_original_and_compressed_versions_of_image(\n            filename, suggestion_image_context, suggestion.target_id,\n            image, 'image', image_is_compressible)\n\n    target_entity_html_list = suggestion.get_target_entity_html_strings()\n    target_image_filenames = (\n        html_cleaner.get_image_filenames_from_html_strings(\n            target_entity_html_list))\n\n    fs_services.copy_images(\n        suggestion.target_type, suggestion.target_id,\n        suggestion_image_context, suggestion.target_id,\n        target_image_filenames)\n"
    },
    {
      "filename": "core/controllers/suggestion_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for suggestion controllers.\"\"\"\n\nfrom __future__ import annotations\n\nimport base64\nimport os\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import feedback_services\nfrom core.domain import fs_domain\nfrom core.domain import fs_services\nfrom core.domain import opportunity_services\nfrom core.domain import question_domain\nfrom core.domain import question_services\nfrom core.domain import rights_domain\nfrom core.domain import rights_manager\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import suggestion_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\n(suggestion_models, feedback_models) = models.Registry.import_models([\n    models.NAMES.suggestion, models.NAMES.feedback])\n\n\nclass SuggestionUnitTests(test_utils.GenericTestBase):\n\n    ASSET_HANDLER_URL_PREFIX = '/assetsdevhandler'\n    EXP_ID = 'exp1'\n    TRANSLATION_LANGUAGE_CODE = 'en'\n\n    AUTHOR_EMAIL = 'author@example.com'\n    AUTHOR_EMAIL_2 = 'author2@example.com'\n    REVIEWER_EMAIL = 'reviewer@example.com'\n    TRANSLATOR_EMAIL = 'translator@example.com'\n    NORMAL_USER_EMAIL = 'user@example.com'\n\n    def setUp(self):\n        super(SuggestionUnitTests, self).setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.signup(self.AUTHOR_EMAIL_2, 'author2')\n        self.signup(self.NORMAL_USER_EMAIL, 'normalUser')\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.signup(self.TRANSLATOR_EMAIL, 'translator')\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.author_id_2 = self.get_user_id_from_email(self.AUTHOR_EMAIL_2)\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.translator_id = self.get_user_id_from_email(self.TRANSLATOR_EMAIL)\n        self.normal_useer_id = self.get_user_id_from_email(\n            self.NORMAL_USER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'hi')\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        # Login and create exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n        self.exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                self.EXP_ID, self.editor_id, ['State 1', 'State 2', 'State 3'],\n                ['TextInput'], category='Algebra'))\n\n        self.old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        self.exploration.states['State 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(self.old_content))\n        self.exploration.states['State 2'].update_content(\n            state_domain.SubtitledHtml.from_dict(self.old_content))\n        self.exploration.states['State 3'].update_content(\n            state_domain.SubtitledHtml.from_dict(self.old_content))\n        exp_services._save_exploration(self.editor_id, self.exploration, '', [])  # pylint: disable=protected-access\n\n        rights_manager.publish_exploration(self.editor, self.EXP_ID)\n        rights_manager.assign_role_for_exploration(\n            self.editor, self.EXP_ID, self.owner_id, rights_domain.ROLE_EDITOR)\n\n        self.new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content html</p>').to_dict()\n        self.resubmit_change_content = state_domain.SubtitledHtml(\n            'content', '<p>resubmit change content html</p>').to_dict()\n        self.update_change_content = state_domain.SubtitledHtml(\n            'content', '<p>update change content html</p>').to_dict()\n\n        self.logout()\n\n        # Create some suggestions in the backend.\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, self.EXP_ID,\n            self.exploration.version,\n            self.author_id, {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 1',\n                'old_value': self.old_content,\n                'new_value': self.new_content\n            },\n            'change to state 1')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, self.EXP_ID,\n            self.exploration.version,\n            self.author_id_2, {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 2',\n                'old_value': self.old_content,\n                'new_value': self.new_content\n            },\n            'change to state 2')\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, self.EXP_ID,\n            self.exploration.version,\n            self.author_id_2, {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 3',\n                'old_value': self.old_content,\n                'new_value': self.new_content\n            },\n            'change to state 3')\n\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': self.EXP_ID,\n                'target_version_at_submission': self.exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'State 3',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': '<p>old content html</p>',\n                    'translation_html': '<p>In हिन्दी (Hindi)</p>',\n                    'data_format': 'html'\n                },\n                'description': 'change to state 3',\n            }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_edit_state_content_suggestion_is_not_allowed(self):\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': 'exp1',\n                'target_version_at_submission': 2,\n                'change': {\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'State 1',\n                    'old_value': self.old_content,\n                    'new_value': self.new_content\n                },\n                'description': 'change to state 1',\n            }, csrf_token=csrf_token, expected_status_int=400)\n        self.logout()\n\n    def test_suggestion_to_exploration_handler_with_invalid_suggestion_id(self):\n        self.login(self.EDITOR_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n\n        # Invalid format of suggestion id.\n        response = self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'], 'invalid_suggestion_id'), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Invalid format for suggestion_id. It must contain 3 parts '\n            'separated by \\'.\\'')\n\n        csrf_token = self.get_new_csrf_token()\n\n        # Suggestion does not exist.\n        self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                'exploration.target_id.id'), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token,\n            expected_status_int=404)\n\n        self.logout()\n\n    def test_suggestion_to_exploration_handler_with_invalid_target_type(self):\n        self.login(self.EDITOR_EMAIL)\n\n        question_dict = {\n            'question_state_data': self._create_valid_question_data(\n                'default_state').to_dict(),\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': ['skill_id'],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n\n        exp_id = 'new_exp_id'\n        self.save_new_default_exploration(exp_id, self.editor_id)\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_TOPIC, exp_id, 1,\n            self.author_id, {\n                'cmd': (\n                    question_domain\n                    .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                'question_dict': question_dict,\n                'skill_id': None,\n                'skill_difficulty': 0.3\n            }, None)\n\n        suggestion_id = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', exp_id)])[0].suggestion_id\n\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX, exp_id,\n                suggestion_id), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'This handler allows actions only on suggestions to explorations.')\n\n        self.logout()\n\n    def test_suggestion_to_exploration_handler_with_invalid_target_id(self):\n        self.login(self.EDITOR_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        self.save_new_default_exploration('exp_id', self.editor_id)\n\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX, 'exp_id',\n                suggestion_to_accept['suggestion_id']), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'The exploration id provided does not match the exploration id '\n            'present as part of the suggestion_id')\n\n        self.logout()\n\n    def test_owner_of_exploration_cannot_repond_to_own_suggestion(self):\n        self.login(self.EDITOR_EMAIL)\n\n        exp_id = 'new_exp_id'\n        self.save_new_default_exploration(exp_id, self.editor_id)\n\n        new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content html</p>').to_dict()\n        change_cmd = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': new_content\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, exp_id, 1,\n            self.editor_id, change_cmd, 'sample description')\n\n        suggestion_id = suggestion_services.query_suggestions(\n            [('author_id', self.editor_id), (\n                'target_id', exp_id)])[0].suggestion_id\n\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                exp_id, suggestion_id), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=401)\n\n        self.assertEqual(\n            response['error'], 'You cannot accept/reject your own suggestion.')\n\n        self.logout()\n\n    def test_suggestion_to_exploration_handler_with_invalid_action(self):\n        self.login(self.EDITOR_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                suggestion_to_accept['suggestion_id']),\n            {'action': 'invalid_action'}, csrf_token=csrf_token,\n            expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'Invalid action.')\n\n        self.logout()\n\n    def test_reject_suggestion_to_exploration(self):\n        self.login(self.EDITOR_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_reject = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_reject['suggestion_id'])\n\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_reject['target_id'],\n            suggestion_to_reject['suggestion_id']), {\n                'action': u'reject',\n                'review_message': u'Rejected!'\n            }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_reject['suggestion_id'])\n\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_REJECTED)\n\n        self.logout()\n\n    def test_suggestion_to_exploration_handler_with_long_commit_mesage(self):\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message':\n                    u'a' * (constants.MAX_COMMIT_MESSAGE_LENGTH + 1),\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token, expected_status_int=400)\n        self.assertEqual(\n            response['error'],\n            'Commit messages must be at most 375 characters long.'\n        )\n\n    def test_accept_suggestion(self):\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n\n        # Test editor can accept successfully.\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        # By default, when a suggestion is accepted and the recording of scores\n        # is enabled, the score of the author of that suggestion is increased\n        # by 1. Therefore, by setting that increment to the minimum score\n        # required to review, we can ensure that the author of this suggestion\n        # has a high enough score to review suggestions in this category. This\n        # will be used to test whether the author can review a suggestion in\n        # the same category because of the author's high score in a later test.\n        enable_recording_of_scores_swap = self.swap(\n            feconf, 'ENABLE_RECORDING_OF_SCORES', True)\n        increment_score_of_author_swap = self.swap(\n            suggestion_models, 'INCREMENT_SCORE_OF_AUTHOR_BY',\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n\n        with enable_recording_of_scores_swap, increment_score_of_author_swap:\n            csrf_token = self.get_new_csrf_token()\n            self.put_json('%s/exploration/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                suggestion_to_accept['suggestion_id']), {\n                    'action': u'accept',\n                    'commit_message': u'commit message',\n                    'review_message': u'Accepted'\n                }, csrf_token=csrf_token)\n        suggestion_post_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n        self.assertEqual(\n            suggestion_post_accept['status'],\n            suggestion_models.STATUS_ACCEPTED)\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        self.assertEqual(\n            exploration.states[suggestion_to_accept[\n                'change']['state_name']].content.html,\n            suggestion_to_accept['change']['new_value']['html'])\n        self.logout()\n\n        # Testing user without permissions cannot accept.\n        self.login(self.NORMAL_USER_EMAIL)\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id_2))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'commit message',\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token, expected_status_int=401)\n        self.logout()\n\n        # Testing that author cannot accept own suggestion.\n        self.login(self.AUTHOR_EMAIL_2)\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id_2))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'commit message',\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token, expected_status_int=401)\n\n        # Testing users with scores above threshold can accept.\n        # The score of this author was increased to the review threshold amount\n        # when the editor accepted a suggestion that was authored by this user.\n        self.login(self.AUTHOR_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'commit message',\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token)\n\n        suggestion_post_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id_2))['suggestions'][0]\n        self.assertEqual(\n            suggestion_post_accept['status'],\n            suggestion_models.STATUS_ACCEPTED)\n        self.logout()\n\n        # Testing admins can accept suggestions.\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id_2))['suggestions'][1]\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'commit message',\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token)\n        suggestion_post_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id_2))['suggestions'][1]\n        self.assertEqual(\n            suggestion_post_accept['status'],\n            suggestion_models.STATUS_ACCEPTED)\n        self.logout()\n\n    def test_suggestion_list_handler_with_invalid_query_field(self):\n        response = self.get_json(\n            '%s?invalid_query_field=value' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX), expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'Not allowed to query on field invalid_query_field')\n\n    def test_suggestion_list_handler(self):\n        suggestions = self.get_json(\n            '%s?author_id=%s&target_type=%s&target_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX, self.author_id_2,\n                feconf.ENTITY_TYPE_EXPLORATION, self.EXP_ID)\n            )['suggestions']\n        self.assertEqual(len(suggestions), 2)\n\n    def test_cannot_resubmit_suggestion_with_invalid_suggestion_id(self):\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.put_json(\n            '%s/resubmit/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX, 'invalid_suggestion_id'), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'No suggestion found with given suggestion id')\n\n    def test_resubmit_rejected_suggestion(self):\n\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])[0]\n        suggestion_services.reject_suggestion(\n            suggestion.suggestion_id, self.reviewer_id, 'reject message')\n        self.logout()\n\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json('%s/resubmit/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX, suggestion.suggestion_id), {\n                'summary_message': 'summary message',\n                'action': u'resubmit',\n                'change': {\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'State 1',\n                    'new_value': self.resubmit_change_content,\n                    'old_value': self.old_content\n                }\n            }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])[0]\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(\n            suggestion.change.new_value['html'],\n            self.resubmit_change_content['html'])\n        self.assertEqual(\n            suggestion.change.cmd, exp_domain.CMD_EDIT_STATE_PROPERTY)\n        self.assertEqual(\n            suggestion.change.property_name, exp_domain.STATE_PROPERTY_CONTENT)\n        self.assertEqual(\n            suggestion.change.state_name, 'State 1')\n        self.logout()\n\n    def test_translation_accept_suggestion_by_reviewer(self):\n        # Test reviewer can accept successfully.\n        self.login(self.REVIEWER_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.translator_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'commit message',\n                'review_message': u'Accepted'\n            }, csrf_token=csrf_token)\n        suggestion_post_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.translator_id))['suggestions'][0]\n        self.assertEqual(\n            suggestion_post_accept['status'],\n            suggestion_models.STATUS_ACCEPTED)\n        self.logout()\n\n    def test_translation_suggestion_creation_with_new_images(self):\n        exp_id = '12345678exp1'\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                exp_id, self.editor_id, ['State 1'],\n                ['EndExploration'], category='Algebra'))\n\n        state_content_dict = {\n            'content_id': 'content',\n            'html': (\n                '<oppia-noninteractive-image filepath-with-value='\n                '\"&quot;img.png&quot;\" caption-with-value=\"&quot;&quot;\" '\n                'alt-with-value=\"&quot;Image&quot;\">'\n                '</oppia-noninteractive-image>')\n        }\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n        self.post_json(\n            '%s/exploration/%s' % (\n                feconf.EXPLORATION_IMAGE_UPLOAD_PREFIX, exp_id),\n            {'filename': 'img.png'},\n            csrf_token=csrf_token,\n            upload_files=(('image', 'unused_filename', raw_image),))\n        exp_services.update_exploration(\n            self.editor_id, exp_id, [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 1',\n                'new_value': state_content_dict\n            })], 'Changes content.')\n        rights_manager.publish_exploration(self.editor, exp_id)\n\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        text_to_translate = exploration.states['State 1'].content.html\n        self.logout()\n\n        fs = fs_domain.AbstractFileSystem(\n            fs_domain.GcsFileSystem(feconf.ENTITY_TYPE_EXPLORATION, exp_id))\n\n        self.assertTrue(fs.isfile('image/img.png'))\n\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': exp_id,\n                'target_version_at_submission': exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'State 1',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': text_to_translate,\n                    'translation_html': (\n                        '<oppia-noninteractive-image filepath-with-value='\n                        '\"&quot;translation_image.png&quot;\" '\n                        'caption-with-value=\"&quot;&quot;\" '\n                        'alt-with-value=\"&quot;Image&quot;\">'\n                        '</oppia-noninteractive-image>'),\n                    'data_format': 'html'\n                },\n                'description': 'test',\n                'files': {\n                    'translation_image.png': (\n                        base64.b64encode(raw_image).decode('utf-8'))\n                 },\n            },\n            csrf_token=csrf_token\n        )\n\n        fs = fs_domain.AbstractFileSystem(\n            fs_domain.GcsFileSystem(\n                feconf.IMAGE_CONTEXT_EXPLORATION_SUGGESTIONS, exp_id))\n\n        self.assertTrue(fs.isfile('image/img.png'))\n        self.assertTrue(fs.isfile('image/img_compressed.png'))\n        self.assertTrue(fs.isfile('image/translation_image.png'))\n        self.assertTrue(fs.isfile('image/img_compressed.png'))\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.translator_id))['suggestions'][0]\n        self.logout()\n\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json('%s/exploration/%s/%s' % (\n            feconf.SUGGESTION_ACTION_URL_PREFIX,\n            suggestion_to_accept['target_id'],\n            suggestion_to_accept['suggestion_id']), {\n                'action': u'accept',\n                'commit_message': u'Translated content of State 1',\n                'review_message': u'This looks good!',\n            }, csrf_token=csrf_token)\n\n        fs = fs_domain.AbstractFileSystem(\n            fs_domain.GcsFileSystem(feconf.ENTITY_TYPE_EXPLORATION, exp_id))\n        self.assertTrue(fs.isfile('image/img.png'))\n        self.assertTrue(fs.isfile('image/translation_image.png'))\n        self.assertTrue(fs.isfile('image/img_compressed.png'))\n\n    def test_set_of_strings_translation_suggestion_creation(self):\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': self.EXP_ID,\n                'target_version_at_submission': self.exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'State 1',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': '<p>old content html</p>',\n                    'translation_html': ['test1', 'test2'],\n                    'data_format': (\n                        state_domain.WrittenTranslation\n                        .DATA_FORMAT_SET_OF_NORMALIZED_STRING\n                    ),\n                },\n                'description': 'description',\n            }, csrf_token=csrf_token)\n        self.logout()\n\n        suggestions = self.get_json(\n            '%s?author_id=%s&target_type=%s&target_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX, self.translator_id,\n                feconf.ENTITY_TYPE_EXPLORATION, self.EXP_ID)\n            )['suggestions']\n        self.assertEqual(len(suggestions), 2)\n\n    def test_update_suggestion_updates_translation_html(self):\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.translator_id), ('target_id', self.EXP_ID)])[0]\n        self.logout()\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json('%s/%s' % (\n            feconf.UPDATE_TRANSLATION_SUGGESTION_URL_PREFIX,\n            suggestion.suggestion_id), {\n                'translation_html': '<p>Updated In Hindi</p>'\n            }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.translator_id), ('target_id', self.EXP_ID)])[0]\n        self.assertEqual(\n            suggestion.change.translation_html, '<p>Updated In Hindi</p>')\n        self.logout()\n\n    def test_cannot_update_already_handled_translation(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'state_name': 'State 1',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, self.translator_id, change_dict, 'description')\n        suggestion_services.accept_suggestion(\n            suggestion.suggestion_id, self.reviewer_id, 'Accepted', 'Done'\n        )\n\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json('%s/%s' % (\n            feconf.UPDATE_TRANSLATION_SUGGESTION_URL_PREFIX,\n            suggestion.suggestion_id), {\n                'translation_html': '<p>Updated In Hindi</p>'\n            }, csrf_token=csrf_token, expected_status_int=400)\n        self.assertEqual(\n            response['error'],\n            'The suggestion with id %s has been accepted or rejected' % (\n                suggestion.suggestion_id))\n        self.logout()\n\n    def test_cannot_update_translations_without_translation_html(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'state_name': 'State 1',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, self.translator_id, change_dict, 'description')\n\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json(\n            '%s/%s' % (\n                feconf.UPDATE_TRANSLATION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id), {},\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(\n            response['error'],\n            'The parameter \\'translation_html\\' is missing.')\n        self.logout()\n\n    def test_cannot_update_translation_with_invalid_translation_html(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        change_dict = {\n            'cmd': 'add_translation',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'state_name': 'State 1',\n            'translation_html': '<p>Translation for content.</p>'\n        }\n\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, self.translator_id, change_dict, 'description')\n\n        csrf_token = self.get_new_csrf_token()\n        response = self.put_json(\n            '%s/%s' % (\n                feconf.UPDATE_TRANSLATION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id), {\n                    'translation_html': 12\n                },\n            csrf_token=csrf_token,\n            expected_status_int=400)\n        self.assertEqual(\n            response['error'],\n            'The parameter \\'translation_html\\' should be a string or a list.')\n        self.logout()\n\n    def test_update_suggestion_updates_question_suggestion_content(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n        question_state_data['content']['html'] = (\n            '<p>Updated question</p>'\n            '<oppia-noninteractive-image filepath-with-value='\n            '\"&quot;img.png&quot;\" caption-with-value=\"&quot;&quot;\" '\n            'alt-with-value=\"&quot;Image&quot;\">'\n            '</oppia-noninteractive-image>')\n        question_state_data['interaction']['solution'] = new_solution_dict\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb',\n            encoding=None\n        ) as f:\n            raw_image = f.read()\n\n        self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ), {\n                'question_state_data': question_state_data,\n                'skill_difficulty': 0.6\n            },\n            csrf_token=csrf_token,\n            upload_files=(('img.png', 'img.png', raw_image),)\n        )\n\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n        new_question_state_data = updated_suggestion.change.question_dict[\n            'question_state_data']\n\n        self.assertEqual(\n            new_question_state_data['content']['html'],\n            '<p>Updated question</p>'\n            '<oppia-noninteractive-image filepath-with-value='\n            '\"&quot;img.png&quot;\" caption-with-value=\"&quot;&quot;\" '\n            'alt-with-value=\"&quot;Image&quot;\">'\n            '</oppia-noninteractive-image>'\n        )\n        self.assertEqual(\n            new_question_state_data['interaction']['solution'],\n            new_solution_dict)\n        self.logout()\n\n    def test_cannot_update_question_with_invalid_skill_difficulty(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n        question_state_data['content']['html'] = '<p>Updated question</p>'\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        question_state_data['interaction']['solution'] = new_solution_dict\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ),\n            {\n                'question_state_data': question_state_data,\n                'skill_difficulty': '0.6'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n\n        self.assertEqual(\n            response['error'],\n            'The parameter \\'skill_difficulty\\' should be a decimal.')\n        self.logout()\n\n    def test_cannot_update_question_without_state_data(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n        question_state_data['content']['html'] = '<p>Updated question</p>'\n        question_state_data['interaction']['solution'] = new_solution_dict\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ),\n            {\n                'skill_difficulty': 0.6\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n\n        self.assertEqual(\n            response['error'],\n            'The parameter \\'question_state_data\\' is missing.')\n        self.logout()\n\n    def test_cannot_update_question_without_skill_difficulty(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n        question_state_data['content']['html'] = '<p>Updated question</p>'\n        question_state_data['interaction']['solution'] = new_solution_dict\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ),\n            {\n                'question_state_data': question_state_data\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n\n        self.assertEqual(\n            response['error'], 'The parameter \\'skill_difficulty\\' is missing.')\n        self.logout()\n\n    def test_cannot_update_already_handled_question(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        suggestion_services.accept_suggestion(\n            suggestion.suggestion_id, self.reviewer_id, 'Accepted', 'Done'\n        )\n\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n        question_state_data['content']['html'] = '<p>Updated question</p>'\n        question_state_data['interaction']['solution'] = new_solution_dict\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ),\n            {\n                'question_state_data': question_state_data,\n                'skill_difficulty': '0.6'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n\n        self.assertEqual(\n            response['error'],\n            'The suggestion with id %s has been accepted or rejected' % (\n                suggestion.suggestion_id\n            )\n        )\n        self.logout()\n\n    def test_cannot_update_question_when_provided_state_data_is_invalid(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        invalid_question_state_data = {}\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/%s' % (\n                feconf.UPDATE_QUESTION_SUGGESTION_URL_PREFIX,\n                suggestion.suggestion_id\n            ),\n            {\n                'question_state_data': invalid_question_state_data,\n                'skill_difficulty': '0.6'\n            },\n            csrf_token=csrf_token,\n            expected_status_int=400\n        )\n        self.logout()\n\n    def test_suggestion_creation_when_images_are_not_provided(self):\n        exp_id = '12345678exp1'\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                exp_id, self.editor_id, ['State 1'],\n                ['EndExploration'], category='Algebra'))\n\n        state_content_dict = {\n            'content_id': 'content',\n            'html': (\n                '<oppia-noninteractive-image filepath-with-value='\n                '\"&quot;img.png&quot;\" caption-with-value=\"&quot;&quot;\" '\n                'alt-with-value=\"&quot;Image&quot;\">'\n                '</oppia-noninteractive-image>')\n        }\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n        self.post_json(\n            '%s/exploration/%s' % (\n                feconf.EXPLORATION_IMAGE_UPLOAD_PREFIX, exp_id),\n            {'filename': 'img.png'},\n            csrf_token=csrf_token,\n            upload_files=(('image', 'unused_filename', raw_image),))\n        exp_services.update_exploration(\n            self.editor_id, exp_id, [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 1',\n                'new_value': state_content_dict\n            })], 'Changes content.')\n        rights_manager.publish_exploration(self.editor, exp_id)\n\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        text_to_translate = exploration.states['State 1'].content.html\n        self.logout()\n\n        valid_html = (\n            '<oppia-noninteractive-math math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)(x - a'\n            '_3)...(x - a_n-1)(x - a_n)&amp;quot;, &amp;quot;svg_filenam'\n            'e&amp;quot;: &amp;quot;file.svg&amp;quot;}\"></oppia-noninte'\n            'ractive-math>'\n        )\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': exp_id,\n                'target_version_at_submission': exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'State 1',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': text_to_translate,\n                    'translation_html': valid_html,\n                    'data_format': 'html'\n                },\n                'files': {'file.svg': None},\n                'description': 'test'\n            }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertIn('No image supplied', response_dict['error'])\n        self.logout()\n\n    def test_suggestion_creation_when_images_are_not_valid(self):\n        exp_id = '12345678exp1'\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                exp_id, self.editor_id, ['State 1'],\n                ['EndExploration'], category='Algebra'))\n\n        state_content_dict = {\n            'content_id': 'content',\n            'html': (\n                '<oppia-noninteractive-image filepath-with-value='\n                '\"&quot;img.png&quot;\" caption-with-value=\"&quot;&quot;\" '\n                'alt-with-value=\"&quot;Image&quot;\">'\n                '</oppia-noninteractive-image>')\n        }\n        self.login(self.EDITOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n        self.post_json(\n            '%s/exploration/%s' % (\n                feconf.EXPLORATION_IMAGE_UPLOAD_PREFIX, exp_id),\n            {'filename': 'img.png'},\n            csrf_token=csrf_token,\n            upload_files=(('image', 'unused_filename', raw_image),))\n        exp_services.update_exploration(\n            self.editor_id, exp_id, [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'State 1',\n                'new_value': state_content_dict\n            })], 'Changes content.')\n        rights_manager.publish_exploration(self.editor, exp_id)\n\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        text_to_translate = exploration.states['State 1'].content.html\n        self.logout()\n\n        valid_html = (\n            '<oppia-noninteractive-math math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)(x - a'\n            '_3)...(x - a_n-1)(x - a_n)&amp;quot;, &amp;quot;svg_filenam'\n            'e&amp;quot;: &amp;quot;file.svg&amp;quot;}\"></oppia-noninte'\n            'ractive-math>'\n        )\n        large_image = '<svg><path d=\"%s\" /></svg>' % (\n             'M150 0 L75 200 L225 200 Z ' * 4000)\n        self.login(self.TRANSLATOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        response_dict = self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': exp_id,\n                'target_version_at_submission': exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'State 1',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': text_to_translate,\n                    'translation_html': valid_html,\n                    'data_format': 'html'\n                },\n                'description': 'test',\n                'files': {'file.svg': large_image},\n            }, csrf_token=csrf_token, expected_status_int=400,\n        )\n\n        self.assertIn(\n            'Image exceeds file size limit of 100 KB.',\n            response_dict['error'])\n        self.logout()\n\n\nclass QuestionSuggestionTests(test_utils.GenericTestBase):\n\n    AUTHOR_EMAIL = 'author@example.com'\n\n    # Needs to be 12 characters long.\n    SKILL_ID = 'skill1234567'\n\n    SKILL_DESCRIPTION = 'skill to link question to'\n\n    def setUp(self):\n        super(QuestionSuggestionTests, self).setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.save_new_skill(\n            self.SKILL_ID, self.admin_id, description=self.SKILL_DESCRIPTION)\n        self.question_dict = {\n            'question_state_data': self._create_valid_question_data(\n                'default_state').to_dict(),\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': [self.SKILL_ID],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.SKILL_ID,\n                'target_version_at_submission': 1,\n                'change': {\n                    'cmd': (\n                        question_domain\n                        .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                    'question_dict': self.question_dict,\n                    'skill_id': self.SKILL_ID,\n                    'skill_difficulty': 0.3\n                },\n                'description': 'Add new question to skill'\n            }, csrf_token=csrf_token)\n        self.logout()\n\n    def test_create_question_suggestion(self):\n        self.login(self.AUTHOR_EMAIL)\n        suggestions = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions']\n        self.assertEqual(len(suggestions), 1)\n        self.logout()\n\n    def test_query_question_suggestions(self):\n        suggestions = self.get_json(\n            '%s?suggestion_type=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION)\n            )['suggestions']\n        self.assertEqual(len(suggestions), 1)\n        suggestion = suggestions[0]\n        self.assertEqual(\n            suggestion['suggestion_type'],\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(suggestion['target_id'], self.SKILL_ID)\n        self.assertEqual(\n            suggestion['target_type'], feconf.ENTITY_TYPE_SKILL)\n        self.assertEqual(\n            suggestion['change']['cmd'],\n            question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION)\n\n    def test_accept_question_suggestion(self):\n        suggestion_to_accept = self.get_json(\n            '%s?suggestion_type=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION)\n            )['suggestions'][0]\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            self.put_json('%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                suggestion_to_accept['suggestion_id']), {\n                    'action': u'accept',\n                    'commit_message': u'commit message',\n                    'review_message': u'This looks good!',\n                    'skill_id': self.SKILL_ID\n                }, csrf_token=csrf_token)\n\n        suggestion_post_accept = self.get_json(\n            '%s?suggestion_type=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                feconf.SUGGESTION_TYPE_ADD_QUESTION)\n            )['suggestions'][0]\n        self.assertEqual(\n            suggestion_post_accept['status'],\n            suggestion_models.STATUS_ACCEPTED)\n        (\n            questions, merged_question_skill_links) = (\n                question_services.get_displayable_question_skill_link_details(\n                    1, [self.SKILL_ID], 0))\n        self.assertEqual(len(questions), 1)\n        self.assertEqual(\n            merged_question_skill_links[0].skill_descriptions,\n            [self.SKILL_DESCRIPTION])\n        self.assertEqual(\n            merged_question_skill_links[0].skill_difficulties, [0.3])\n        self.assertEqual(\n            questions[0].question_content,\n            self.question_dict['question_state_data']['content']['html']\n        )\n        thread_messages = feedback_services.get_messages(\n            suggestion_to_accept['suggestion_id'])\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(last_message.text, 'This looks good!')\n        self.logout()\n\n    def test_accept_question_suggestion_with_image_region_interactions(self):\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'), 'rb',\n            encoding=None) as f:\n            original_image_content = f.read()\n\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.admin_id, description='Description')\n\n        fs_services.save_original_and_compressed_versions_of_image(\n            'image.png', 'question_suggestions', skill_id,\n            original_image_content, 'image', True)\n        question_state_dict = {\n            'content': {\n                'html': '<p>Text</p>',\n                'content_id': 'content'\n            },\n            'classifier_model_id': None,\n            'linked_skill_id': None,\n            'interaction': {\n                'answer_groups': [\n                    {\n                        'rule_specs': [\n                            {\n                                'rule_type': 'IsInRegion',\n                                'inputs': {'x': 'Region1'}\n                            }\n                        ],\n                        'outcome': {\n                            'dest': None,\n                            'feedback': {\n                                'html': '<p>assas</p>',\n                                'content_id': 'feedback_0'\n                            },\n                            'labelled_as_correct': True,\n                            'param_changes': [],\n                            'refresher_exploration_id': None,\n                            'missing_prerequisite_skill_id': None\n                        },\n                        'training_data': [],\n                        'tagged_skill_misconception_id': None\n                    }\n                ],\n                'confirmed_unclassified_answers': [],\n                'customization_args': {\n                    'imageAndRegions': {\n                        'value': {\n                            'imagePath': 'image.png',\n                            'labeledRegions': [\n                                {\n                                    'label': 'Region1',\n                                    'region': {\n                                        'regionType': 'Rectangle',\n                                        'area': [\n                                            [\n                                                0.2644628099173554,\n                                                0.21807065217391305\n                                            ],\n                                            [\n                                                0.9201101928374655,\n                                                0.8847373188405797\n                                            ]\n                                        ]\n                                    }\n                                }\n                            ]\n                        }\n                    },\n                    'highlightRegionsOnHover': {\n                        'value': False\n                    }\n                },\n                'default_outcome': {\n                    'dest': None,\n                    'feedback': {\n                        'html': '<p>wer</p>',\n                        'content_id': 'default_outcome'\n                    },\n                    'labelled_as_correct': False,\n                    'param_changes': [],\n                    'refresher_exploration_id': None,\n                    'missing_prerequisite_skill_id': None\n                },\n                'hints': [\n                    {\n                        'hint_content': {\n                            'html': '<p>assaas</p>',\n                            'content_id': 'hint_1'\n                        }\n                    }\n                ],\n                'id': 'ImageClickInput', 'solution': None\n            },\n            'param_changes': [],\n            'recorded_voiceovers': {\n                'voiceovers_mapping': {\n                    'content': {},\n                    'default_outcome': {},\n                    'feedback_0': {},\n                    'hint_1': {}\n                }\n            },\n            'solicit_answer_details': False,\n            'card_is_checkpoint': False,\n            'written_translations': {\n                'translations_mapping': {\n                    'content': {},\n                    'default_outcome': {},\n                    'feedback_0': {},\n                    'hint_1': {}\n                }\n            },\n            'next_content_id_index': 2\n        }\n        question_dict = {\n            'question_state_data': question_state_dict,\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': [skill_id],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n        suggestion_change = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': question_dict,\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        self.assertEqual(\n            suggestion.status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            self.put_json('%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion.target_id,\n                suggestion.suggestion_id), {\n                    'action': u'accept',\n                    'commit_message': u'commit message',\n                    'review_message': u'This looks good!',\n                    'skill_id': skill_id\n                }, csrf_token=csrf_token)\n\n        self.logout()\n\n        suggestion_post_accept = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n        question = question_services.get_questions_by_skill_ids(\n            1, [skill_id], False)[0]\n        self.assertEqual(\n            suggestion_post_accept.status,\n            suggestion_models.STATUS_ACCEPTED)\n        # Checks whether image of the Image Region interaction is accessible\n        # from the question player. Pre checks can not be added to check there\n        # are no images in the given directory before accepting the question\n        # suggestion since the directory is created only after the suggestion\n        # is accepted.\n        destination_fs = fs_domain.AbstractFileSystem(\n            fs_domain.GcsFileSystem(\n                feconf.ENTITY_TYPE_QUESTION, question.id))\n        self.assertTrue(destination_fs.isfile('image/%s' % 'image.png'))\n\n    def test_create_suggestion_invalid_target_version_input(self):\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.SKILL_ID,\n                'target_version_at_submission': 'invalid_target_version',\n                'change': {\n                    'cmd': (\n                        question_domain\n                        .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                    'question_dict': self.question_dict,\n                    'skill_id': self.SKILL_ID,\n                    'skill_difficulty': 0.3\n                },\n                'description': 'Add new question to skill'\n            }, csrf_token=csrf_token, expected_status_int=400)\n        suggestions = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions']\n\n        self.assertEqual(\n            response['error'],\n            'Schema validation for \\'target_version_at_submission\\' failed: '\n            'Could not convert str to int: invalid_target_version'\n        )\n        self.assertEqual(len(suggestions), 1)\n        self.logout()\n\n    def test_suggestion_creation_with_valid_images(self):\n        self.save_new_skill(\n            'skill_id2', self.admin_id, description='description')\n        question_state_data_dict = self._create_valid_question_data(\n            'default_state').to_dict()\n        valid_html = (\n            '<oppia-noninteractive-math math_content-with-value=\"{&amp;q'\n            'uot;raw_latex&amp;quot;: &amp;quot;(x - a_1)(x - a_2)(x - a'\n            '_3)...(x - a_n-1)(x - a_n)&amp;quot;, &amp;quot;svg_filenam'\n            'e&amp;quot;: &amp;quot;file.svg&amp;quot;}\"></oppia-noninte'\n            'ractive-math>'\n        )\n        question_state_data_dict['content']['html'] = valid_html\n        self.question_dict = {\n            'question_state_data': question_state_data_dict,\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': ['skill_id2'],\n            'inapplicable_skill_misconception_ids': []\n        }\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'test_svg.svg'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.SKILL_ID,\n                'target_version_at_submission': 1,\n                'change': {\n                    'cmd': (\n                        question_domain\n                        .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                    'question_dict': self.question_dict,\n                    'skill_id': self.SKILL_ID,\n                    'skill_difficulty': 0.3\n                },\n                'description': 'Add new question to skill',\n                'files': {\n                    'file.svg': (\n                        base64.b64encode(raw_image).decode('utf-8'))\n                }\n            }, csrf_token=csrf_token,)\n        self.logout()\n\n\nclass SkillSuggestionTests(test_utils.GenericTestBase):\n\n    AUTHOR_EMAIL = 'author@example.com'\n    REVIEWER_EMAIL = 'reviewer@example.com'\n\n    def setUp(self):\n        super(SkillSuggestionTests, self).setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        user_services.allow_user_to_review_question(self.reviewer_id)\n\n        self.skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            self.skill_id, self.admin_id, description='Description')\n\n        self.question_dict = {\n            'question_state_data': self._create_valid_question_data(\n                'default_state').to_dict(),\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': [self.skill_id],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.skill_id,\n                'target_version_at_submission': 1,\n                'change': {\n                    'cmd': (\n                        question_domain\n                        .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                    'question_dict': self.question_dict,\n                    'skill_id': self.skill_id,\n                    'skill_difficulty': 0.3\n                },\n                'description': 'Add new question to skill'\n            }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_cannot_access_suggestion_to_skill_handler(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        thread_id = feedback_services.create_thread(\n            feconf.ENTITY_TYPE_QUESTION, self.skill_id,\n            self.author_id, 'description', '', has_suggestion=True)\n\n        csrf_token = self.get_new_csrf_token()\n\n        self.put_json(\n            '%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX, self.skill_id,\n                thread_id), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.logout()\n\n    def test_suggestion_to_skill_handler_with_invalid_target_type(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        exp_id = 'new_exp_id'\n        self.save_new_default_exploration(exp_id, self.admin_id)\n\n        new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content html</p>').to_dict()\n        change_cmd = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': new_content\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, exp_id, 1,\n            self.author_id, change_cmd, 'sample description')\n\n        suggestion_id = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', exp_id)])[0].suggestion_id\n\n        csrf_token = self.get_new_csrf_token()\n\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            response = self.put_json(\n                '%s/skill/%s/%s' % (\n                    feconf.SUGGESTION_ACTION_URL_PREFIX,\n                    self.skill_id, suggestion_id), {\n                        'action': u'reject',\n                        'review_message': u'Rejected!'\n                    }, csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'This handler allows actions only on suggestions to skills.')\n\n        self.logout()\n\n    def test_suggestion_to_skill_handler_with_invalid_target_id(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n\n        csrf_token = self.get_new_csrf_token()\n\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            response = self.put_json(\n                '%s/skill/%s/%s' % (\n                    feconf.SUGGESTION_ACTION_URL_PREFIX,\n                    'skill_id', suggestion_to_accept['suggestion_id']),\n                {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                },\n                csrf_token=csrf_token, expected_status_int=400)\n\n        self.assertEqual(\n            response['error'],\n            'The skill id provided does not match the skill id '\n            'present as part of the suggestion_id')\n\n        self.logout()\n\n    def test_suggestion_to_skill_handler_with_invalid_action(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            response = self.put_json(\n                '%s/skill/%s/%s' % (\n                    feconf.SUGGESTION_ACTION_URL_PREFIX,\n                    suggestion_to_accept['target_id'],\n                    suggestion_to_accept['suggestion_id']),\n                {'action': 'invalid_action'}, csrf_token=csrf_token,\n                expected_status_int=400)\n\n        self.assertEqual(\n            response['error'], 'Invalid action.')\n        self.logout()\n\n    def test_reject_suggestion_to_skill(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        suggestion_to_reject = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_reject['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            self.put_json('%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_reject['target_id'],\n                suggestion_to_reject['suggestion_id']), {\n                    'action': u'reject',\n                    'review_message': u'Rejected!'\n                }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_reject['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_REJECTED)\n        self.logout()\n\n    def test_accept_suggestion_to_skill(self):\n        self.login(self.CURRICULUM_ADMIN_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_accept['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            self.put_json('%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                suggestion_to_accept['suggestion_id']), {\n                    'action': u'accept',\n                    'commit_message': u'commit message',\n                    'review_message': u'Accepted!',\n                    'skill_id': self.skill_id\n                }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_accept['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n        self.logout()\n\n    def test_reviewer_accept_suggestion_to_skill(self):\n        self.login(self.REVIEWER_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n        suggestion_to_accept = self.get_json(\n            '%s?author_id=%s' % (\n                feconf.SUGGESTION_LIST_URL_PREFIX,\n                self.author_id))['suggestions'][0]\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_accept['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(constants, 'ENABLE_NEW_STRUCTURE_VIEWER_UPDATES', True):\n            self.put_json('%s/skill/%s/%s' % (\n                feconf.SUGGESTION_ACTION_URL_PREFIX,\n                suggestion_to_accept['target_id'],\n                suggestion_to_accept['suggestion_id']), {\n                    'action': u'accept',\n                    'commit_message': u'commit message',\n                    'review_message': u'Accepted!',\n                    'skill_id': self.skill_id\n                }, csrf_token=csrf_token)\n\n        suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion_to_accept['suggestion_id'])\n        self.assertEqual(\n            suggestion.status, suggestion_models.STATUS_ACCEPTED)\n        self.logout()\n\n\nclass UserSubmittedSuggestionsHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Unit test for the UserSubmittedSuggestionsHandler.\"\"\"\n\n    AUTHOR_EMAIL = 'author@example.com'\n\n    def setUp(self):\n        super(UserSubmittedSuggestionsHandlerTest, self).setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        self.TOPIC_ID = 'topic'\n        self.STORY_ID = 'story'\n        self.EXP_ID = 'exp1'\n        # Needs to be 12 characters long.\n        self.SKILL_ID = 'skill1234567'\n        self.SKILL_DESCRIPTION = 'skill to link question to'\n        exploration = self.save_new_valid_exploration(\n            self.EXP_ID, self.owner_id, title='Exploration title',\n            category='Algebra', end_state_name='End State',\n            correctness_feedback_enabled=True)\n        self.publish_exploration(self.owner_id, self.EXP_ID)\n\n        topic = topic_domain.Topic.create_default_topic(\n            self.TOPIC_ID, 'topic', 'abbrev', 'description')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_333'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(self.TOPIC_ID, self.admin_id)\n\n        story = story_domain.Story.create_default_story(\n            self.STORY_ID, 'A story', 'Description', self.TOPIC_ID, 'story-a')\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': self.EXP_ID\n            })], 'Changes.')\n\n        self.save_new_skill(\n            self.SKILL_ID, self.owner_id, description=self.SKILL_DESCRIPTION)\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.editor_id\n\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        # Login and create exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n\n        exp_services.update_exploration(\n            self.owner_id, self.EXP_ID, [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'content_id': 'content',\n                        'html': '<p>new content html</p>'\n                    }\n                })], 'Add content')\n\n        self.logout()\n\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': (feconf.ENTITY_TYPE_EXPLORATION),\n                'target_id': self.EXP_ID,\n                'target_version_at_submission': exploration.version,\n                'change': {\n                    'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                    'state_name': 'Introduction',\n                    'content_id': 'content',\n                    'language_code': 'hi',\n                    'content_html': '<p>new content html</p>',\n                    'translation_html': '<p>new content html in Hindi</p>',\n                    'data_format': 'html'\n                },\n                'description': 'Adds translation',\n            }, csrf_token=csrf_token)\n\n        self.question_dict = {\n            'question_state_data': self._create_valid_question_data(\n                'default_state').to_dict(),\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': [self.SKILL_ID],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.SKILL_ID,\n                'target_version_at_submission': 1,\n                'change': {\n                    'cmd': (\n                        question_domain\n                        .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                    'question_dict': self.question_dict,\n                    'skill_id': None,\n                    'skill_difficulty': 0.3\n                },\n                'description': 'Add new question to skill'\n            }, csrf_token=csrf_token)\n\n        self.logout()\n\n    def test_exploration_handler_returns_data(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(len(response['target_id_to_opportunity_dict']), 1)\n        self.assertEqual(response['next_offset'], 1)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/topic/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(response, {})\n\n    def test_skill_handler_returns_data(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/skill/add_question', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(len(response['target_id_to_opportunity_dict']), 1)\n        self.assertEqual(response['next_offset'], 1)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/topic/add_question', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(response, {})\n\n    def test_question_suggestions_data_for_deleted_opportunities(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        opportunity_services.delete_skill_opportunity(self.SKILL_ID)\n        response = self.get_json(\n            '/getsubmittedsuggestions/skill/add_question', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(len(response['target_id_to_opportunity_dict']), 1)\n        self.assertEqual(response['next_offset'], 1)\n        self.assertEqual(\n            response['target_id_to_opportunity_dict'][self.SKILL_ID], None)\n\n    def test_translation_suggestions_data_for_deleted_opportunities(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        opportunity_services.delete_exploration_opportunities([self.EXP_ID])\n        response = self.get_json(\n            '/getsubmittedsuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(len(response['target_id_to_opportunity_dict']), 1)\n        self.assertEqual(response['next_offset'], 1)\n        self.assertEqual(\n            response['target_id_to_opportunity_dict'][self.EXP_ID], None)\n\n    def test_handler_with_invalid_suggestion_type_raise_error(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n\n        self.get_json(\n            '/getsubmittedsuggestions/exploration/invalid_suggestion_type', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            },\n            expected_status_int=400)\n\n    def test_handler_with_invalid_target_type_raise_error(self):\n        self.login(self.AUTHOR_EMAIL)\n\n        response = self.get_json(\n            '/getsubmittedsuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n\n        self.get_json(\n            '/getsubmittedsuggestions/invalid_target_type/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            }, expected_status_int=400)\n\n\nclass ReviewableSuggestionsHandlerTest(test_utils.GenericTestBase):\n    \"\"\"Unit test for the ReviewableSuggestionsHandler.\"\"\"\n\n    def setUp(self):\n        super(ReviewableSuggestionsHandlerTest, self).setUp()\n        self.AUTHOR_EMAIL = 'author@example.com'\n        self.REVIEWER_EMAIL = 'reviewer@example.com'\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.TOPIC_ID = 'topic'\n        self.STORY_ID = 'story'\n        self.EXP_ID = 'exp1'\n        # Needs to be 12 characters long.\n        self.SKILL_ID = 'skill1234567'\n        self.SKILL_DESCRIPTION = 'skill to link question to'\n        exploration = self.save_new_valid_exploration(\n            self.EXP_ID, self.owner_id, title='Exploration title',\n            category='Algebra', end_state_name='End State',\n            correctness_feedback_enabled=True)\n        self.publish_exploration(self.owner_id, self.EXP_ID)\n\n        topic = topic_domain.Topic.create_default_topic(\n            self.TOPIC_ID, 'topic', 'abbrev', 'description')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_333'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-three')]\n        topic.next_subtopic_id = 2\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(self.TOPIC_ID, self.admin_id)\n\n        story = story_domain.Story.create_default_story(\n            self.STORY_ID, 'A story', 'Description', self.TOPIC_ID, 'story-b')\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': self.EXP_ID\n            })], 'Changes.')\n\n        self.save_new_skill(\n            self.SKILL_ID, self.owner_id, description=self.SKILL_DESCRIPTION)\n\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'hi')\n        # Login and update exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n\n        exp_services.update_exploration(\n            self.owner_id, self.EXP_ID, [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'content_id': 'content',\n                        'html': '<p>new content html</p>'\n                    }\n                })], 'Add content')\n\n        self.logout()\n\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        self.translate_suggestion_change = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'Introduction',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>new content html</p>',\n            'translation_html': '<p>new content html in Hindi</p>',\n            'data_format': 'html'\n        }\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': self.EXP_ID,\n                'target_version_at_submission': exploration.version,\n                'change': self.translate_suggestion_change,\n                'description': 'Adds translation',\n            }, csrf_token=csrf_token\n        )\n\n        self.question_dict = {\n            'question_state_data': self._create_valid_question_data(\n                'default_state').to_dict(),\n            'language_code': 'en',\n            'question_state_data_schema_version': (\n                feconf.CURRENT_STATE_SCHEMA_VERSION),\n            'linked_skill_ids': [self.SKILL_ID],\n            'inapplicable_skill_misconception_ids': ['skillid12345-1']\n        }\n        self.translate_question_change = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': self.question_dict,\n            'skill_id': None,\n            'skill_difficulty': 0.3\n        }\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_ADD_QUESTION),\n                'target_type': feconf.ENTITY_TYPE_SKILL,\n                'target_id': self.SKILL_ID,\n                'target_version_at_submission': 1,\n                'change': self.translate_question_change,\n                'description': 'Add new question to skill'\n            }, csrf_token=csrf_token)\n\n        self.logout()\n        self.login(self.REVIEWER_EMAIL)\n\n    def test_exploration_handler_returns_data_with_no_topic(self):\n        # If no topic name is provided, we fetch all available\n        # translation suggestions.\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(response['next_offset'], 1)\n        suggestion = response['suggestions'][0]\n        self.assertDictEqual(\n            suggestion['change'], self.translate_suggestion_change)\n        self.assertEqual(\n            suggestion['suggestion_type'],\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT\n        )\n        self.assertEqual(\n            suggestion['target_type'], feconf.ENTITY_TYPE_EXPLORATION)\n        self.assertEqual(suggestion['language_code'], 'hi')\n        self.assertEqual(suggestion['author_name'], 'author')\n        self.assertEqual(suggestion['status'], 'review')\n        self.assertDictEqual(\n            response['target_id_to_opportunity_dict'],\n            {\n                'exp1': {\n                    'chapter_title': 'Node1',\n                    'content_count': 2,\n                    'id': 'exp1',\n                    'story_title': 'A story',\n                    'topic_name': 'topic',\n                    'translation_counts': {},\n                    'translation_in_review_counts': {}\n                }\n            }\n        )\n\n    def test_exploration_handler_returns_data_with_topic_value_all(self):\n        # If the passed topic name value is All, we fetch all available\n        # translation suggestions.\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', params={\n                'topic_name': feconf.ALL_LITERAL_CONSTANT,\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(response['next_offset'], 1)\n        suggestion = response['suggestions'][0]\n        self.assertDictEqual(\n            suggestion['change'], self.translate_suggestion_change)\n        self.assertEqual(\n            suggestion['suggestion_type'],\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT\n        )\n        self.assertEqual(\n            suggestion['target_type'], feconf.ENTITY_TYPE_EXPLORATION)\n        self.assertEqual(suggestion['language_code'], 'hi')\n        self.assertEqual(suggestion['author_name'], 'author')\n        self.assertEqual(suggestion['status'], 'review')\n        self.assertDictEqual(\n            response['target_id_to_opportunity_dict'],\n            {\n                'exp1': {\n                    'chapter_title': 'Node1',\n                    'content_count': 2,\n                    'id': 'exp1',\n                    'story_title': 'A story',\n                    'topic_name': 'topic',\n                    'translation_counts': {},\n                    'translation_in_review_counts': {}\n                }\n            }\n        )\n\n    def test_exploration_handler_returns_data_with_valid_topic_and_exp_ids( # pylint: disable=line-too-long\n            self):\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', params={\n                'topic_name': 'topic',\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        self.assertEqual(response['next_offset'], 1)\n        suggestion = response['suggestions'][0]\n        self.assertDictEqual(\n            suggestion['change'], self.translate_suggestion_change)\n        self.assertEqual(\n            suggestion['suggestion_type'],\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT\n        )\n        self.assertEqual(\n            suggestion['target_type'], feconf.ENTITY_TYPE_EXPLORATION)\n        self.assertEqual(suggestion['target_id'], self.EXP_ID)\n        self.assertEqual(suggestion['language_code'], 'hi')\n        self.assertEqual(suggestion['author_name'], 'author')\n        self.assertEqual(suggestion['status'], 'review')\n        self.assertDictEqual(\n            response['target_id_to_opportunity_dict'],\n            {\n                'exp1': {\n                    'chapter_title': 'Node1',\n                    'content_count': 2,\n                    'id': 'exp1',\n                    'story_title': 'A story',\n                    'topic_name': 'topic',\n                    'translation_counts': {},\n                    'translation_in_review_counts': {}\n                }\n            }\n        )\n        self.assertEqual(response['next_offset'], 1)\n\n    def test_exploration_handler_raises_exception_with_invalid_topic_and_no_exp_id( # pylint: disable=line-too-long\n            self):\n        with self.assertRaisesRegex(\n              Exception,\n                'The supplied input topic: invalid_topic is not valid'):\n            self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', params={\n                'topic_name': 'invalid_topic',\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n\n    def test_get_reviewable_suggestions_when_state_of_a_target_is_removed(\n        self):\n        exploration = self.save_new_valid_exploration(\n            'exp2', self.owner_id, objective='The objective')\n        init_state = exploration.states[exploration.init_state_name]\n        default_outcome_dict = init_state.interaction.default_outcome.to_dict()\n        default_outcome_dict['dest'] = exploration.init_state_name\n        exp_services.update_exploration(\n            self.owner_id, 'exp2', [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME),\n                    'state_name': exploration.init_state_name,\n                    'new_value': default_outcome_dict\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_ADD_STATE,\n                    'state_name': 'New state',\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_INTERACTION_ID,\n                    'state_name': 'New state',\n                    'new_value': 'MultipleChoiceInput'\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS,\n                    'state_name': 'New state',\n                    'new_value': {\n                        'choices': {\n                            'value': [{\n                                'content_id': 'ca_choices_0',\n                                'html': '<p>Option A</p>'\n                            }, {\n                                'content_id': 'ca_choices_1',\n                                'html': '<p>Option B</p>'\n                            }]\n                        },\n                        'showChoicesInShuffledOrder': {'value': False}\n                    }\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_NEXT_CONTENT_ID_INDEX,\n                    'state_name': 'New state',\n                    'new_value': 1\n                })], 'Add state name')\n\n        self.logout()\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        updated_exploration = exp_fetchers.get_exploration_by_id('exp2')\n        self.translate_suggestion_change = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'New state',\n            'content_id': 'ca_choices_0',\n            'language_code': 'hi',\n            'content_html': '<p>Option A</p>',\n            'translation_html': '<p>new content html in Hindi</p>',\n            'data_format': 'html'\n        }\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': 'exp2',\n                'target_version_at_submission': updated_exploration.version,\n                'change': self.translate_suggestion_change,\n                'description': 'Adds translation',\n            }, csrf_token=csrf_token\n        )\n\n        self.logout()\n\n        self.login(self.REVIEWER_EMAIL)\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n\n        # Since there is a properly created translation in the setup and another\n        # one in this test case, there should be 2 suggestions when it is\n        # requested for available translations.\n        self.assertEqual(len(response['suggestions']), 2)\n        self.assertEqual(response['next_offset'], 2)\n\n        self.logout()\n\n        exp_services.update_exploration(\n            self.owner_id, 'exp2', [exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_DELETE_STATE,\n                'state_name': 'New state',\n            })], 'delete state')\n\n        self.login(self.REVIEWER_EMAIL)\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n\n        # Now the state of the exploration created in this case is deleted.\n        # Therefore only one translation should be retrieved.\n        self.assertEqual(len(response['suggestions']), 1)\n        # The suggestion with the deleted exploration state was filtered out\n        # after the storage query, so the next offset skips the filtered\n        # suggestion.\n        self.assertEqual(response['next_offset'], 2)\n\n        self.logout()\n\n    def test_get_reviewable_suggestions_when_original_content_is_removed(self):\n        exploration = self.save_new_valid_exploration(\n            'exp2', self.owner_id, objective='The objective')\n        init_state = exploration.states[exploration.init_state_name]\n        init_state.update_next_content_id_index(3)\n        default_outcome_dict = init_state.interaction.default_outcome.to_dict()\n        default_outcome_dict['dest'] = exploration.init_state_name\n        exp_services.update_exploration(\n            self.owner_id, 'exp2', [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_DEFAULT_OUTCOME),\n                    'state_name': exploration.init_state_name,\n                    'new_value': default_outcome_dict\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_ADD_STATE,\n                    'state_name': 'New state',\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_INTERACTION_ID,\n                    'state_name': 'New state',\n                    'new_value': 'MultipleChoiceInput'\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS,\n                    'state_name': 'New state',\n                    'new_value': {\n                        'choices': {\n                            'value': [{\n                                'content_id': 'ca_choices_0',\n                                'html': '<p>Option A</p>'\n                            }, {\n                                'content_id': 'ca_choices_1',\n                                'html': '<p>Option B</p>'\n                            }]\n                        },\n                        'showChoicesInShuffledOrder': {'value': False}\n                    }\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_NEXT_CONTENT_ID_INDEX,\n                    'state_name': 'New state',\n                    'new_value': 1\n                })], 'Add state name')\n\n        self.logout()\n        self.login(self.AUTHOR_EMAIL)\n        csrf_token = self.get_new_csrf_token()\n\n        updated_exploration = exp_fetchers.get_exploration_by_id('exp2')\n        self.translate_suggestion_change = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'New state',\n            'content_id': 'ca_choices_1',\n            'language_code': 'hi',\n            'content_html': '<p>Option B</p>',\n            'translation_html': '<p>new content html in Hindi</p>',\n            'data_format': 'html'\n        }\n        self.post_json(\n            '%s/' % feconf.SUGGESTION_URL_PREFIX, {\n                'suggestion_type': (\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT),\n                'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n                'target_id': 'exp2',\n                'target_version_at_submission': updated_exploration.version,\n                'change': self.translate_suggestion_change,\n                'description': 'Adds translation',\n            }, csrf_token=csrf_token\n        )\n\n        self.logout()\n\n        # Since there is a properly created translation in the setup and another\n        # one in this test case, there should be 2 suggestions when it is\n        # requested for available translations.\n        self.login(self.REVIEWER_EMAIL)\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n\n        self.assertEqual(len(response['suggestions']), 2)\n\n        self.logout()\n\n        exp_services.update_exploration(\n            self.owner_id, 'exp2', [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS,\n                    'state_name': 'New state',\n                    'new_value': {\n                        'choices': {\n                            'value': [{\n                                'content_id': 'ca_choices_0',\n                                'html': '<p>Option A</p>'\n                            }]\n                        },\n                        'showChoicesInShuffledOrder': {'value': False}\n                    }\n                })], 'Add state name')\n\n        # Now the original content that the translation was made does not exist.\n        # Therefore only one translation should be retrieved.\n        self.login(self.REVIEWER_EMAIL)\n        response = self.get_json(\n            '/getreviewablesuggestions/exploration/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n\n        self.assertEqual(len(response['suggestions']), 1)\n\n        self.logout()\n\n    def test_topic_translate_handler_returns_no_data(self):\n        response = self.get_json(\n            '/getreviewablesuggestions/topic/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(response, {})\n\n    def test_skill_handler_returns_data(self):\n        response = self.get_json(\n            '/getreviewablesuggestions/skill/add_question', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(len(response['suggestions']), 1)\n        suggestion = response['suggestions'][0]\n        self.assertDictEqual(\n            suggestion['change'], self.translate_question_change)\n        self.assertEqual(\n            suggestion['suggestion_type'], feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            suggestion['target_type'], feconf.ENTITY_TYPE_SKILL)\n        self.assertEqual(suggestion['target_id'], self.SKILL_ID)\n        self.assertEqual(suggestion['language_code'], 'en')\n        self.assertEqual(suggestion['author_name'], 'author')\n        self.assertEqual(suggestion['status'], 'review')\n        self.assertDictEqual(\n            response['target_id_to_opportunity_dict'],\n            {\n                'skill1234567': {\n                    'id': 'skill1234567',\n                    'question_count': 0,\n                    'skill_description': 'skill to link question to',\n                    'skill_rubrics': [\n                        {\n                            'difficulty': 'Easy',\n                            'explanations': ['Explanation 1']\n                        }, {\n                            'difficulty': 'Medium',\n                            'explanations': ['Explanation 2']\n                        }, {\n                            'difficulty': 'Hard',\n                            'explanations': ['Explanation 3']\n                        }\n                    ]\n                }\n            }\n        )\n\n    def test_topic_question_handler_returns_no_data(self):\n        response = self.get_json(\n            '/getreviewablesuggestions/topic/add_question', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            })\n        self.assertEqual(response, {})\n\n    def test_handler_with_invalid_suggestion_type_raise_error(self):\n        self.get_json(\n            '/getreviewablesuggestions/exploration/invalid_suggestion_type', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            },\n            expected_status_int=404\n        )\n\n    def test_handler_with_invalid_target_type_raise_error(self):\n        self.get_json(\n            '/getreviewablesuggestions/invalid_target_type/translate_content', {\n                'limit': constants.OPPORTUNITIES_PAGE_SIZE,\n                'offset': 0\n            },\n            expected_status_int=400\n        )\n"
    },
    {
      "filename": "core/domain/opportunity_services.py",
      "content": "# coding: utf-8\n#\n# Copyright 2019 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Commands that can be used to operate on opportunity models.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport logging\n\nfrom core.constants import constants\nfrom core.domain import exp_fetchers\nfrom core.domain import opportunity_domain\nfrom core.domain import question_fetchers\nfrom core.domain import story_fetchers\nfrom core.domain import suggestion_services\nfrom core.domain import topic_fetchers\nfrom core.platform import models\n\n(opportunity_models, suggestion_models) = models.Registry.import_models(\n    [models.NAMES.opportunity, models.NAMES.suggestion])\n\n# NOTE TO DEVELOPERS: The functions:\n#   - delete_all_exploration_opportunity_summary_models()\n#   - delete_all_skill_opportunity_models()\n# were removed in #13021 as part of the migration to Apache Beam. Please refer\n# to that PR if you need to reinstate them.\n\n\ndef is_exploration_available_for_contribution(exp_id):\n    \"\"\"Checks whether a given exploration id belongs to a curated list of\n    exploration i.e, whether it's used as the chapter of any story.\n\n    Args:\n        exp_id: str. The id of the exploration which is needed to be checked.\n\n    Returns:\n        bool. Whether the given exp_id belongs to the curated explorations.\n    \"\"\"\n    model = opportunity_models.ExplorationOpportunitySummaryModel.get(\n        exp_id, strict=False)\n\n    return model is not None\n\n\ndef get_exploration_opportunity_summary_from_model(model):\n    \"\"\"Returns the ExplorationOpportunitySummary object out of the model.\n\n    Args:\n        model: ExplorationOpportunitySummaryModel. The exploration opportunity\n            summary model.\n\n    Returns:\n        ExplorationOpportunitySummary. The corresponding\n        ExplorationOpportunitySummary object.\n    \"\"\"\n    # We're making sure that the audio language codes in any exploration\n    # opportunity domain object match the ones in\n    # constants.SUPPORTED_AUDIO_LANGUAGES.\n    set_of_all_languages = set(\n        model.incomplete_translation_language_codes +\n        model.language_codes_needing_voice_artists +\n        model.language_codes_with_assigned_voice_artists)\n    supported_language_codes = set(\n        language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES)\n    missing_language_codes = list(\n        supported_language_codes - set_of_all_languages)\n    if missing_language_codes:\n        logging.info(\n            'Missing language codes %s in exploration opportunity model with '\n            'id %s' % (missing_language_codes, model.id))\n\n    new_incomplete_translation_language_codes = (\n        model.incomplete_translation_language_codes + missing_language_codes)\n\n    return opportunity_domain.ExplorationOpportunitySummary(\n        model.id, model.topic_id, model.topic_name, model.story_id,\n        model.story_title, model.chapter_title, model.content_count,\n        new_incomplete_translation_language_codes, model.translation_counts,\n        model.language_codes_needing_voice_artists,\n        model.language_codes_with_assigned_voice_artists,\n        {})\n\n\ndef _save_multi_exploration_opportunity_summary(\n        exploration_opportunity_summary_list):\n    \"\"\"Stores multiple ExplorationOpportunitySummary into datastore as a\n    ExplorationOpportunitySummaryModel.\n\n    Args:\n        exploration_opportunity_summary_list: list(\n            ExplorationOpportunitySummary). A list of exploration opportunity\n            summary object.\n    \"\"\"\n    exploration_opportunity_summary_model_list = []\n    for opportunity_summary in exploration_opportunity_summary_list:\n        model = opportunity_models.ExplorationOpportunitySummaryModel(\n            id=opportunity_summary.id,\n            topic_id=opportunity_summary.topic_id,\n            topic_name=opportunity_summary.topic_name,\n            story_id=opportunity_summary.story_id,\n            story_title=opportunity_summary.story_title,\n            chapter_title=opportunity_summary.chapter_title,\n            content_count=opportunity_summary.content_count,\n            incomplete_translation_language_codes=(\n                opportunity_summary.incomplete_translation_language_codes),\n            translation_counts=opportunity_summary.translation_counts,\n            language_codes_needing_voice_artists=(\n                opportunity_summary.language_codes_needing_voice_artists),\n            language_codes_with_assigned_voice_artists=(\n                opportunity_summary.language_codes_with_assigned_voice_artists)\n        )\n\n        exploration_opportunity_summary_model_list.append(model)\n\n    (\n        opportunity_models.ExplorationOpportunitySummaryModel\n        .update_timestamps_multi(exploration_opportunity_summary_model_list))\n    opportunity_models.ExplorationOpportunitySummaryModel.put_multi(\n        exploration_opportunity_summary_model_list)\n\n\ndef create_exp_opportunity_summary(topic, story, exploration):\n    \"\"\"Create an ExplorationOpportunitySummary object with the given topic,\n    story and exploration object.\n\n    Args:\n        topic: Topic. The topic object to which the opportunity belongs.\n        story: Story. The story object to which the opportunity belongs.\n        exploration: Exploration. The exploration object to which the\n            opportunity belongs.\n\n    Returns:\n        ExplorationOpportunitySummary. The exploration opportunity summary\n        object.\n    \"\"\"\n    # TODO(#13903): Find a way to reduce runtime of computing the complete\n    # languages.\n    complete_translation_language_list = (\n        exploration.get_languages_with_complete_translation())\n    # TODO(#13912): Revisit voiceover language logic.\n    language_codes_needing_voice_artists = set(\n        complete_translation_language_list)\n    incomplete_translation_language_codes = (\n        _compute_exploration_incomplete_translation_languages(\n            complete_translation_language_list))\n    if exploration.language_code in incomplete_translation_language_codes:\n        # Remove exploration language from incomplete translation languages list\n        # as an exploration does not need a translation in its own language.\n        incomplete_translation_language_codes.remove(exploration.language_code)\n        # Add exploration language to voiceover required languages list as an\n        # exploration can be voiceovered in its own language.\n        language_codes_needing_voice_artists.add(exploration.language_code)\n\n    content_count = exploration.get_content_count()\n    translation_counts = exploration.get_translation_counts()\n\n    story_node = story.story_contents.get_node_with_corresponding_exp_id(\n        exploration.id)\n\n    # TODO(#7376): Once the voiceover application functionality is\n    # implemented change this method such that it also populates the\n    # language_codes_with_assigned_voice_artists with the required data.\n\n    exploration_opportunity_summary = (\n        opportunity_domain.ExplorationOpportunitySummary(\n            exploration.id, topic.id, topic.name, story.id, story.title,\n            story_node.title, content_count,\n            incomplete_translation_language_codes,\n            translation_counts, list(language_codes_needing_voice_artists), [],\n            {}))\n\n    return exploration_opportunity_summary\n\n\ndef _compute_exploration_incomplete_translation_languages(\n        complete_translation_languages):\n    \"\"\"Computes all languages that are not 100% translated in an exploration.\n\n    Args:\n        complete_translation_languages: list(str). List of complete translation\n            language codes in the exploration.\n\n    Returns:\n        list(str). List of incomplete translation language codes sorted\n        alphabetically.\n    \"\"\"\n    audio_language_codes = set(\n        language['id'] for language in constants.SUPPORTED_AUDIO_LANGUAGES)\n    incomplete_translation_language_codes = (\n        audio_language_codes - set(complete_translation_languages))\n    return sorted(list(incomplete_translation_language_codes))\n\n\ndef add_new_exploration_opportunities(story_id, exp_ids):\n    \"\"\"Adds new exploration opportunity into the model.\n\n    Args:\n        story_id: str. ID of the story.\n        exp_ids: list(str). A list of exploration ids for which new\n            opportunities are to be created. All exp_ids must be part of the\n            given story.\n    \"\"\"\n    story = story_fetchers.get_story_by_id(story_id)\n    topic = topic_fetchers.get_topic_by_id(story.corresponding_topic_id)\n    _create_exploration_opportunities(story, topic, exp_ids)\n\n\ndef _create_exploration_opportunities(story, topic, exp_ids):\n    \"\"\"Creates new exploration opportunities corresponding to the supplied\n    story, topic, and exploration IDs.\n\n    Args:\n        story: Story. The story domain object corresponding to the exploration\n            opportunities.\n        topic: Topic. The topic domain object corresponding to the exploration\n            opportunities.\n        exp_ids: list(str). A list of exploration ids for which new\n            opportunities are to be created. All exp_ids must be part of the\n            given story.\n    \"\"\"\n    explorations = exp_fetchers.get_multiple_explorations_by_id(exp_ids)\n    exploration_opportunity_summary_list = []\n    for exploration in explorations.values():\n        exploration_opportunity_summary_list.append(\n            create_exp_opportunity_summary(\n                topic, story, exploration))\n    _save_multi_exploration_opportunity_summary(\n        exploration_opportunity_summary_list)\n\n\ndef update_opportunity_with_updated_exploration(exp_id):\n    \"\"\"Updates the opportunities models with the changes made in the\n    exploration.\n\n    Args:\n        exp_id: str. The exploration id which is also the id of the opportunity\n            model.\n    \"\"\"\n    updated_exploration = exp_fetchers.get_exploration_by_id(exp_id)\n    content_count = updated_exploration.get_content_count()\n    translation_counts = updated_exploration.get_translation_counts()\n    # TODO(#13903): Find a way to reduce runtime of computing the complete\n    # languages.\n    complete_translation_language_list = (\n        updated_exploration.get_languages_with_complete_translation())\n    model = opportunity_models.ExplorationOpportunitySummaryModel.get(exp_id)\n    exploration_opportunity_summary = (\n        get_exploration_opportunity_summary_from_model(model))\n    exploration_opportunity_summary.content_count = content_count\n    exploration_opportunity_summary.translation_counts = translation_counts\n    incomplete_translation_language_codes = (\n        _compute_exploration_incomplete_translation_languages(\n            complete_translation_language_list))\n    if (\n            updated_exploration.language_code\n            in incomplete_translation_language_codes):\n        # Remove exploration language from incomplete translation languages list\n        # as an exploration does not need a translation in its own language.\n        incomplete_translation_language_codes.remove(\n            updated_exploration.language_code)\n    exploration_opportunity_summary.incomplete_translation_language_codes = (\n        incomplete_translation_language_codes)\n\n    new_languages_for_voiceover = set(complete_translation_language_list) - set(\n        exploration_opportunity_summary.\n        language_codes_with_assigned_voice_artists)\n\n    # We only append new languages to language_codes_needing_voice_artists(\n    # instead of adding all of the complete_translation_language_list), as the\n    # complete translation languages list will be dynamic based on some\n    # content text are changed, where as the voiceover is a long term work and\n    # we can allow a voice_artist to work for an exploration which needs a\n    # little bit update in text translation.\n    language_codes_needing_voice_artists_set = set(\n        exploration_opportunity_summary.language_codes_needing_voice_artists)\n    language_codes_needing_voice_artists_set |= set(new_languages_for_voiceover)\n\n    exploration_opportunity_summary.language_codes_needing_voice_artists = list(\n        language_codes_needing_voice_artists_set)\n\n    exploration_opportunity_summary.validate()\n\n    _save_multi_exploration_opportunity_summary(\n        [exploration_opportunity_summary])\n\n\ndef update_exploration_opportunities_with_story_changes(story, exp_ids):\n    \"\"\"Updates the opportunities models with the story changes.\n\n    Args:\n        story: Story. The new story object.\n        exp_ids: list(str). A list of exploration IDs whose exploration\n            opportunity summary models need to be updated.\n    \"\"\"\n    exp_opportunity_models = (\n        opportunity_models.ExplorationOpportunitySummaryModel.get_multi(\n            exp_ids))\n\n    exploration_opportunity_summary_list = []\n\n    for exp_opportunity_model in exp_opportunity_models:\n        exploration_opportunity_summary = (\n            get_exploration_opportunity_summary_from_model(\n                exp_opportunity_model))\n        exploration_opportunity_summary.story_title = story.title\n        node = story.story_contents.get_node_with_corresponding_exp_id(\n            exploration_opportunity_summary.id)\n        exploration_opportunity_summary.chapter_title = node.title\n        exploration_opportunity_summary.validate()\n\n        exploration_opportunity_summary_list.append(\n            exploration_opportunity_summary)\n\n    _save_multi_exploration_opportunity_summary(\n        exploration_opportunity_summary_list)\n\n\ndef update_exploration_voiceover_opportunities(\n        exp_id, assigned_voice_artist_in_language_code):\n    \"\"\"Updates the language_codes_with_assigned_voice_artists of exploration\n    opportunity model.\n\n    Args:\n        exp_id: str. The ID of the exploration.\n        assigned_voice_artist_in_language_code: str. The language code in which\n            a voice artist is assigned to the exploration.\n    \"\"\"\n    model = opportunity_models.ExplorationOpportunitySummaryModel.get(exp_id)\n    exploration_opportunity_summary = (\n        get_exploration_opportunity_summary_from_model(model))\n\n    exploration_opportunity_summary.language_codes_needing_voice_artists.remove(\n        assigned_voice_artist_in_language_code)\n    (\n        exploration_opportunity_summary\n        .language_codes_with_assigned_voice_artists.append(\n            assigned_voice_artist_in_language_code))\n    exploration_opportunity_summary.validate()\n    _save_multi_exploration_opportunity_summary(\n        [exploration_opportunity_summary])\n\n\ndef delete_exploration_opportunities(exp_ids):\n    \"\"\"Deletes the ExplorationOpportunitySummaryModel models corresponding to\n    the given exp_ids.\n\n    Args:\n        exp_ids: list(str). A list of exploration IDs whose opportunity summary\n            models are to be deleted.\n    \"\"\"\n    exp_opportunity_models = (\n        opportunity_models.ExplorationOpportunitySummaryModel.get_multi(\n            exp_ids))\n    exp_opportunity_models_to_be_deleted = [\n        model for model in exp_opportunity_models\n        if model is not None]\n    opportunity_models.ExplorationOpportunitySummaryModel.delete_multi(\n        exp_opportunity_models_to_be_deleted)\n\n\ndef delete_exploration_opportunities_corresponding_to_topic(topic_id):\n    \"\"\"Deletes the ExplorationOpportunitySummaryModel models which corresponds\n    to the given topic_id.\n\n    Args:\n        topic_id: str. The ID of the topic.\n    \"\"\"\n    exp_opportunity_models = (\n        opportunity_models.ExplorationOpportunitySummaryModel.get_by_topic(\n            topic_id))\n    opportunity_models.ExplorationOpportunitySummaryModel.delete_multi(\n        exp_opportunity_models)\n\n\ndef update_exploration_opportunities(old_story, new_story):\n    \"\"\"Updates the opportunities models according to the changes made in the\n    story.\n\n    Args:\n        old_story: Story. The old story object which is now updated.\n        new_story: Story. The new story object.\n    \"\"\"\n    model_ids_need_update = set([])\n    exp_ids_in_old_story = old_story.story_contents.get_all_linked_exp_ids()\n    exp_ids_in_new_story = new_story.story_contents.get_all_linked_exp_ids()\n    new_added_exp_ids = set(exp_ids_in_new_story) - set(exp_ids_in_old_story)\n    deleted_exp_ids = set(exp_ids_in_old_story) - set(exp_ids_in_new_story)\n    unchanged_exp_ids = set(exp_ids_in_new_story) - new_added_exp_ids\n    if old_story.title != new_story.title:\n        model_ids_need_update |= set(unchanged_exp_ids)\n    else:\n        for exp_id in unchanged_exp_ids:\n            new_node = (\n                new_story.story_contents.get_node_with_corresponding_exp_id(\n                    exp_id))\n            old_node = (\n                old_story.story_contents.get_node_with_corresponding_exp_id(\n                    exp_id))\n            if old_node.title != new_node.title:\n                model_ids_need_update.add(exp_id)\n\n    update_exploration_opportunities_with_story_changes(\n        new_story, list(model_ids_need_update))\n    add_new_exploration_opportunities(new_story.id, new_added_exp_ids)\n    delete_exploration_opportunities(list(deleted_exp_ids))\n\n\ndef delete_exp_opportunities_corresponding_to_story(story_id):\n    \"\"\"Deletes the ExplorationOpportunitySummaryModel models which corresponds\n    to the given story_id.\n\n    Args:\n        story_id: str. The ID of the story.\n    \"\"\"\n    exp_opprtunity_model_class = (\n        opportunity_models.ExplorationOpportunitySummaryModel)\n    exp_opportunity_models = exp_opprtunity_model_class.get_all().filter(\n        exp_opprtunity_model_class.story_id == story_id\n    )\n    exp_opprtunity_model_class.delete_multi(exp_opportunity_models)\n\n\ndef get_translation_opportunities(language_code, topic_name, cursor):\n    \"\"\"Returns a list of opportunities available for translation in a specific\n    language.\n\n    Args:\n        cursor: str or None. If provided, the list of returned entities\n            starts from this datastore cursor. Otherwise, the returned\n            entities start from the beginning of the full list of entities.\n        language_code: str. The language for which translation opportunities\n            should be fetched.\n        topic_name: str or None. The topic for which translation opportunities\n            should be fetched. If topic_name is None or empty, fetch\n            translation opportunities from all topics.\n\n    Returns:\n        3-tuple(opportunities, cursor, more). where:\n            opportunities: list(ExplorationOpportunitySummary). A list of\n                ExplorationOpportunitySummary domain objects.\n            cursor: str or None. A query cursor pointing to the next batch of\n                results. If there are no more results, this might be None.\n            more: bool. If True, there are (probably) more results after this\n                batch. If False, there are no further results after this batch.\n    \"\"\"\n    page_size = constants.OPPORTUNITIES_PAGE_SIZE\n    exp_opportunity_summary_models, cursor, more = (\n        opportunity_models\n        .ExplorationOpportunitySummaryModel.get_all_translation_opportunities(\n            page_size, cursor, language_code, topic_name))\n    opportunity_summaries = []\n    opportunity_summary_exp_ids = [\n        opportunity.id for opportunity in exp_opportunity_summary_models]\n    exp_id_to_in_review_count = {}\n    if len(opportunity_summary_exp_ids) > 0:\n        exp_id_to_in_review_count = (\n            _build_exp_id_to_translation_suggestion_in_review_count(\n                opportunity_summary_exp_ids, language_code))\n    for exp_opportunity_summary_model in exp_opportunity_summary_models:\n        opportunity_summary = (\n            get_exploration_opportunity_summary_from_model(\n                exp_opportunity_summary_model))\n        if opportunity_summary.id in exp_id_to_in_review_count:\n            # Compute the translation_in_review_counts domain object field\n            # adhoc. Note that this field is not persisted and is only used in\n            # the frontend.\n            # TODO(#14833): Compute this value in the backend controller\n            # instead.\n            opportunity_summary.translation_in_review_counts = {\n                language_code: exp_id_to_in_review_count[opportunity_summary.id]\n            }\n        opportunity_summaries.append(opportunity_summary)\n    return opportunity_summaries, cursor, more\n\n\ndef _build_exp_id_to_translation_suggestion_in_review_count(\n        exp_ids, language_code):\n    \"\"\"Returns a dict mapping exploration ID to the count of corresponding\n    translation suggestions that are currently in review.\n\n    Args:\n        exp_ids: list(str). List of exploration IDs for which to count\n            corresponding translations suggestions.\n        language_code: str. The language for which translation suggestions\n            should be fetched.\n\n    Returns:\n        dict(str, int). Dict of exploration IDs to counts of corresponding\n        translation suggestions currently in review.\n    \"\"\"\n    exp_id_to_in_review_count = collections.defaultdict(int)\n    suggestions_in_review = (\n        suggestion_services\n        .get_translation_suggestions_in_review_by_exp_ids(\n            exp_ids, language_code))\n    for suggestion in suggestions_in_review:\n        if suggestion is not None:\n            exp_id_to_in_review_count[suggestion.target_id] += 1\n    return exp_id_to_in_review_count\n\n\ndef get_voiceover_opportunities(language_code, cursor):\n    \"\"\"Returns a list of opportunities available for voiceover in a specific\n    language.\n\n    Args:\n        cursor: str or None. If provided, the list of returned entities\n            starts from this datastore cursor. Otherwise, the returned\n            entities start from the beginning of the full list of entities.\n        language_code: str. The language for which voiceover opportunities\n            to be fetched.\n\n    Returns:\n        3-tuple(opportunities, cursor, more). where:\n            opportunities: list(ExplorationOpportunitySummary). A list of\n                ExplorationOpportunitySummary domain objects.\n            cursor: str or None. A query cursor pointing to the next\n                batch of results. If there are no more results, this might\n                be None.\n            more: bool. If True, there are (probably) more results after\n                this batch. If False, there are no further results after\n                this batch.\n    \"\"\"\n    page_size = constants.OPPORTUNITIES_PAGE_SIZE\n    exp_opportunity_summary_models, new_cursor, more = (\n        opportunity_models.ExplorationOpportunitySummaryModel\n        .get_all_voiceover_opportunities(page_size, cursor, language_code))\n\n    opportunities = []\n    for exp_opportunity_summary_model in exp_opportunity_summary_models:\n        exp_opportunity_summary = (\n            get_exploration_opportunity_summary_from_model(\n                exp_opportunity_summary_model))\n        opportunities.append(exp_opportunity_summary)\n    return opportunities, new_cursor, more\n\n\ndef get_exploration_opportunity_summaries_by_ids(ids):\n    \"\"\"Returns a dict with key as id and value representing\n    ExplorationOpportunitySummary objects corresponding to the opportunity id.\n\n    Args:\n        ids: list(str). A list of opportunity ids.\n\n    Returns:\n        dict(str, ExplorationOpportunitySummary|None). A dict with key as the\n        opportunity id and values representing the ExplorationOpportunitySummary\n        domain objects corresponding to the opportunity id if exist else None.\n    \"\"\"\n    opportunities = {opportunity_id: None for opportunity_id in ids}\n    exp_opportunity_summary_models = (\n        opportunity_models.ExplorationOpportunitySummaryModel.get_multi(ids))\n    for exp_opportunity_summary_model in exp_opportunity_summary_models:\n        if exp_opportunity_summary_model is not None:\n            opportunities[exp_opportunity_summary_model.id] = (\n                get_exploration_opportunity_summary_from_model(\n                    exp_opportunity_summary_model))\n    return opportunities\n\n\ndef get_exploration_opportunity_summaries_by_topic_id(topic_id):\n    \"\"\"Returns a list of all exploration opportunity summaries\n    with the given topic ID.\n\n    Args:\n        topic_id: str. The topic for which opportunity summaries\n            are fetched.\n\n    Returns:\n        list(ExplorationOpportunitySummary). A list of all\n        exploration opportunity summaries with the given topic ID.\n    \"\"\"\n    opportunity_summaries = []\n    exp_opportunity_summary_models = (\n        opportunity_models.\n            ExplorationOpportunitySummaryModel.get_by_topic(topic_id)\n    )\n    for exp_opportunity_summary_model in exp_opportunity_summary_models:\n        opportunity_summary = (\n            get_exploration_opportunity_summary_from_model(\n                exp_opportunity_summary_model))\n        opportunity_summaries.append(opportunity_summary)\n    return opportunity_summaries\n\n\ndef update_opportunities_with_new_topic_name(topic_id, topic_name):\n    \"\"\"Updates the exploration opportunity summary models with new topic name.\n\n    Args:\n        topic_id: str. The corresponding topic id of the opportunity.\n        topic_name: str. The new topic name.\n    \"\"\"\n    exp_opportunity_models = (\n        opportunity_models.ExplorationOpportunitySummaryModel.get_by_topic(\n            topic_id))\n\n    exploration_opportunity_summary_list = []\n    for exp_opportunity_model in exp_opportunity_models:\n        exploration_opportunity_summary = (\n            get_exploration_opportunity_summary_from_model(\n                exp_opportunity_model))\n        exploration_opportunity_summary.topic_name = topic_name\n        exploration_opportunity_summary.validate()\n\n        exploration_opportunity_summary_list.append(\n            exploration_opportunity_summary)\n\n    _save_multi_exploration_opportunity_summary(\n        exploration_opportunity_summary_list)\n\n\ndef get_skill_opportunity_from_model(model):\n    \"\"\"Returns a SkillOpportunity domain object from a SkillOpportunityModel.\n\n    Args:\n        model: SkillOpportunityModel. The skill opportunity model.\n\n    Returns:\n        SkillOpportunity. The corresponding SkillOpportunity object.\n    \"\"\"\n    return opportunity_domain.SkillOpportunity(\n        model.id, model.skill_description, model.question_count)\n\n\ndef get_skill_opportunities(cursor):\n    \"\"\"Returns a list of skill opportunities available for questions.\n\n    Args:\n        cursor: str or None. If provided, the list of returned entities\n            starts from this datastore cursor. Otherwise, the returned\n            entities start from the beginning of the full list of entities.\n\n    Returns:\n        3-tuple(opportunities, cursor, more). where:\n            opportunities: list(SkillOpportunity). A list of SkillOpportunity\n                domain objects.\n            cursor: str or None. A query cursor pointing to the next\n                batch of results. If there are no more results, this might\n                be None.\n            more: bool. If True, there are (probably) more results after\n                this batch. If False, there are no further results after\n                this batch.\n    \"\"\"\n    skill_opportunity_models, cursor, more = (\n        opportunity_models.SkillOpportunityModel\n        .get_skill_opportunities(constants.OPPORTUNITIES_PAGE_SIZE, cursor))\n    opportunities = []\n    for skill_opportunity_model in skill_opportunity_models:\n        skill_opportunity = (\n            get_skill_opportunity_from_model(skill_opportunity_model))\n        opportunities.append(skill_opportunity)\n    return opportunities, cursor, more\n\n\ndef get_skill_opportunities_by_ids(ids):\n    \"\"\"Returns a list of SkillOpportunity domain objects corresponding to the\n    given list of ids.\n\n    Args:\n        ids: list(str). A list of the opportunity ids.\n\n    Returns:\n        dict(str, SkillOpportunity|None). A dict with key as the\n        opportunity id and values representing the SkillOpportunity\n        domain objects corresponding to the opportunity id if exist else None.\n    \"\"\"\n    opportunities = {opportunity_id: None for opportunity_id in ids}\n    skill_opportunity_models = (\n        opportunity_models.SkillOpportunityModel.get_multi(ids))\n\n    for skill_opportunity_model in skill_opportunity_models:\n        if skill_opportunity_model is not None:\n            opportunities[skill_opportunity_model.id] = (\n                get_skill_opportunity_from_model(skill_opportunity_model))\n    return opportunities\n\n\ndef create_skill_opportunity(skill_id, skill_description):\n    \"\"\"Creates a SkillOpportunityModel entity in the datastore.\n\n    Args:\n        skill_id: str. The skill_id of the opportunity.\n        skill_description: str. The skill_description of the opportunity.\n\n    Raises:\n        Exception. If a SkillOpportunityModel corresponding to the supplied\n            skill_id already exists.\n    \"\"\"\n    skill_opportunity_model = (\n        opportunity_models.SkillOpportunityModel.get_by_id(skill_id))\n    if skill_opportunity_model is not None:\n        raise Exception(\n            'SkillOpportunity corresponding to skill ID %s already exists.' % (\n                skill_id))\n\n    questions, _ = (\n        question_fetchers.get_questions_and_skill_descriptions_by_skill_ids(\n            constants.MAX_QUESTIONS_PER_SKILL, [skill_id], 0))\n    skill_opportunity = opportunity_domain.SkillOpportunity(\n        skill_id=skill_id,\n        skill_description=skill_description,\n        question_count=len(questions)\n    )\n    _save_skill_opportunities([skill_opportunity])\n\n\ndef _save_skill_opportunities(skill_opportunities):\n    \"\"\"Saves SkillOpportunity domain objects into datastore as\n    SkillOpportunityModel objects.\n\n    Args:\n        skill_opportunities: list(SkillOpportunity). A list of SkillOpportunity\n            domain objects.\n    \"\"\"\n    skill_opportunity_models = []\n    for skill_opportunity in skill_opportunities:\n        skill_opportunity.validate()\n        model = opportunity_models.SkillOpportunityModel(\n            id=skill_opportunity.id,\n            skill_description=skill_opportunity.skill_description,\n            question_count=skill_opportunity.question_count,\n        )\n        skill_opportunity_models.append(model)\n    opportunity_models.SkillOpportunityModel.update_timestamps_multi(\n        skill_opportunity_models)\n    opportunity_models.SkillOpportunityModel.put_multi(skill_opportunity_models)\n\n\ndef update_skill_opportunity_skill_description(skill_id, new_description):\n    \"\"\"Updates the skill_description of the SkillOpportunityModel with\n    new_description.\n\n    Args:\n        skill_id: str. The corresponding skill_id of the opportunity.\n        new_description: str. The new skill_description.\n    \"\"\"\n    skill_opportunity = _get_skill_opportunity(skill_id)\n    if skill_opportunity is not None:\n        skill_opportunity.skill_description = new_description\n        _save_skill_opportunities([skill_opportunity])\n\n\ndef _get_skill_opportunity(skill_id):\n    \"\"\"Returns the SkillOpportunity domain object representing a\n    SkillOpportunityModel with the supplied skill_id in the datastore.\n\n    Args:\n        skill_id: str. The corresponding skill_id of the opportunity.\n\n    Returns:\n        SkillOpportunity or None. The domain object representing a\n        SkillOpportunity with the supplied skill_id, or None if it does not\n        exist.\n    \"\"\"\n    skill_opportunity_model = (\n        opportunity_models.SkillOpportunityModel.get_by_id(skill_id))\n    if skill_opportunity_model is not None:\n        return get_skill_opportunity_from_model(skill_opportunity_model)\n    return None\n\n\ndef delete_skill_opportunity(skill_id):\n    \"\"\"Deletes the SkillOpportunityModel corresponding to the supplied skill_id.\n\n    Args:\n        skill_id: str. The skill_id corresponding to the to-be-deleted\n            SkillOpportunityModel.\n    \"\"\"\n    skill_opportunity_model = (\n        opportunity_models.SkillOpportunityModel.get_by_id(skill_id))\n    if skill_opportunity_model is not None:\n        opportunity_models.SkillOpportunityModel.delete(skill_opportunity_model)\n\n\ndef increment_question_counts(skill_ids, delta):\n    \"\"\"Increments question_count(s) of SkillOpportunityModel(s) with\n    corresponding skill_ids.\n\n    Args:\n        skill_ids: list(str). A list of skill_ids corresponding to\n            SkillOpportunityModel(s).\n        delta: int. The delta for which to increment each question_count.\n    \"\"\"\n    updated_skill_opportunities = (\n        _get_skill_opportunities_with_updated_question_counts(skill_ids, delta))\n    _save_skill_opportunities(updated_skill_opportunities)\n\n\ndef update_skill_opportunities_on_question_linked_skills_change(\n        old_skill_ids, new_skill_ids):\n    \"\"\"Updates question_count(s) of SkillOpportunityModel(s) corresponding to\n    the change in linked skill IDs for a question from old_skill_ids to\n    new_skill_ids, e.g. if skill_id1 is in old_skill_ids, but not in\n    new_skill_ids, the question_count of the SkillOpportunityModel for skill_id1\n    would be decremented.\n\n    NOTE: Since this method is updating the question_counts based on the change\n    of skill_ids from old_skill_ids to new_skill_ids, the input skill_id lists\n    must be related.\n\n    Args:\n        old_skill_ids: list(str). A list of old skill_id(s).\n        new_skill_ids: list(str). A list of new skill_id(s).\n    \"\"\"\n    old_skill_ids_set = set(old_skill_ids)\n    new_skill_ids_set = set(new_skill_ids)\n    new_skill_ids_added_to_question = new_skill_ids_set - old_skill_ids_set\n    skill_ids_removed_from_question = old_skill_ids_set - new_skill_ids_set\n    updated_skill_opportunities = []\n    updated_skill_opportunities.extend(\n        _get_skill_opportunities_with_updated_question_counts(\n            new_skill_ids_added_to_question, 1))\n    updated_skill_opportunities.extend(\n        _get_skill_opportunities_with_updated_question_counts(\n            skill_ids_removed_from_question, -1))\n    _save_skill_opportunities(updated_skill_opportunities)\n\n\ndef _get_skill_opportunities_with_updated_question_counts(skill_ids, delta):\n    \"\"\"Returns a list of SkillOpportunities with corresponding skill_ids\n    with question_count(s) updated by delta.\n\n    Args:\n        skill_ids: iterable(str). The IDs of the matching SkillOpportunityModels\n            in the datastore.\n        delta: int. The delta by which to update each question_count (can be\n            negative).\n\n    Returns:\n        list(SkillOpportunity). The updated SkillOpportunities.\n    \"\"\"\n    updated_skill_opportunities = []\n    skill_opportunity_models = (\n        opportunity_models.SkillOpportunityModel.get_multi(skill_ids))\n    for skill_opportunity_model in skill_opportunity_models:\n        if skill_opportunity_model is not None:\n            skill_opportunity = get_skill_opportunity_from_model(\n                skill_opportunity_model)\n            skill_opportunity.question_count += delta\n            updated_skill_opportunities.append(skill_opportunity)\n    return updated_skill_opportunities\n\n\ndef regenerate_opportunities_related_to_topic(\n        topic_id, delete_existing_opportunities=False):\n    \"\"\"Regenerates opportunity models which belongs to a given topic.\n\n    Args:\n        topic_id: str. The ID of the topic.\n        delete_existing_opportunities: bool. Whether to delete all the existing\n            opportunities related to the given topic.\n\n    Returns:\n        int. The number of opportunity models created.\n\n    Raises:\n        Exception. Failure to regenerate opportunities for given topic.\n    \"\"\"\n    if delete_existing_opportunities:\n        exp_opportunity_models = (\n            opportunity_models.ExplorationOpportunitySummaryModel.get_by_topic(\n                topic_id))\n        opportunity_models.ExplorationOpportunitySummaryModel.delete_multi(\n            exp_opportunity_models)\n\n    topic = topic_fetchers.get_topic_by_id(topic_id)\n    story_ids = topic.get_canonical_story_ids()\n    stories = story_fetchers.get_stories_by_ids(story_ids)\n    exp_ids = []\n    non_existing_story_ids = []\n\n    for index, story in enumerate(stories):\n        if story is None:\n            non_existing_story_ids.append(story_ids[index])\n        else:\n            exp_ids += story.story_contents.get_all_linked_exp_ids()\n\n    exp_ids_to_exp = exp_fetchers.get_multiple_explorations_by_id(\n        exp_ids, strict=False)\n    non_existing_exp_ids = set(exp_ids) - set(exp_ids_to_exp.keys())\n\n    if len(non_existing_exp_ids) > 0 or len(non_existing_story_ids) > 0:\n        raise Exception(\n            'Failed to regenerate opportunities for topic id: %s, '\n            'missing_exp_with_ids: %s, missing_story_with_ids: %s' % (\n                topic_id, list(non_existing_exp_ids), non_existing_story_ids))\n\n    exploration_opportunity_summary_list = []\n    for story in stories:\n        for exp_id in story.story_contents.get_all_linked_exp_ids():\n            exploration_opportunity_summary_list.append(\n                create_exp_opportunity_summary(\n                    topic, story, exp_ids_to_exp[exp_id]))\n\n    _save_multi_exploration_opportunity_summary(\n        exploration_opportunity_summary_list)\n    return len(exploration_opportunity_summary_list)\n"
    },
    {
      "filename": "core/domain/opportunity_services_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Unit tests for core.domain.opportunity_services.\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.domain import exp_domain\nfrom core.domain import exp_services\nfrom core.domain import opportunity_domain\nfrom core.domain import opportunity_services\nfrom core.domain import question_services\nfrom core.domain import skill_domain\nfrom core.domain import skill_services\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import subtopic_page_domain\nfrom core.domain import subtopic_page_services\nfrom core.domain import suggestion_services\nfrom core.domain import topic_domain\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\n(\n    feedback_models, opportunity_models, story_models, suggestion_models\n) = models.Registry.import_models([\n    models.NAMES.feedback, models.NAMES.opportunity, models.NAMES.story,\n    models.NAMES.suggestion\n])\n\n\nclass OpportunityServicesIntegrationTest(test_utils.GenericTestBase):\n    \"\"\"Test the opportunity services module.\"\"\"\n\n    suggestion_target_id = '0'\n    suggestion_target_version_at_submission = 1\n    suggestion_change = {\n        'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n        'state_name': 'End State',\n        'content_id': 'content',\n        'language_code': 'hi',\n        'content_html': '',\n        'translation_html': '<p>This is translated html.</p>',\n        'data_format': 'html'\n    }\n\n    def setUp(self):\n        super(OpportunityServicesIntegrationTest, self).setUp()\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n        self.admin = user_services.get_user_actions_info(self.admin_id)\n\n        self.TOPIC_ID = 'topic'\n        self.STORY_ID = 'story'\n        self.USER_ID = 'user'\n        self.SKILL_ID = 'skill'\n        self.QUESTION_ID = question_services.get_new_question_id()\n        self.THREAD_ID = 'exploration.exp1.thread_1'\n\n        # Since a valid exploration is created here, it has EndExploration\n        # state as well, so the content in that has to be taken into account as\n        # well when checking content_count in the tests.\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category='category%d' % i,\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        ) for i in range(5)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n\n        topic = topic_domain.Topic.create_default_topic(\n            self.TOPIC_ID, 'topic', 'abbrev', 'description')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_1'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-url')]\n        topic.next_subtopic_id = 2\n        subtopic_page = (\n            subtopic_page_domain.SubtopicPage.create_default_subtopic_page(\n                1, self.TOPIC_ID))\n        subtopic_page_services.save_subtopic_page(\n            self.owner_id, subtopic_page, 'Added subtopic',\n            [topic_domain.TopicChange({\n                'cmd': topic_domain.CMD_ADD_SUBTOPIC,\n                'subtopic_id': 1,\n                'title': 'Sample'\n            })]\n        )\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(self.TOPIC_ID, self.admin_id)\n\n        story = story_domain.Story.create_default_story(\n            self.STORY_ID, 'A story', 'description', self.TOPIC_ID,\n            'story-one')\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n    def mock_generate_new_thread_id_for_suggestion(\n            self, unused_entity_type, unused_entity_id):\n        \"\"\"Mock generate_new_thread_id function when creating suggestions.\"\"\"\n        return self.THREAD_ID\n\n    def create_translation_suggestion_for_exploration_0_and_verify(self):\n        \"\"\"Creates a translation suggestion for exploration 0 and performs basic\n        assertions.\n        \"\"\"\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id',\n            self.mock_generate_new_thread_id_for_suggestion):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.suggestion_target_id,\n                self.suggestion_target_version_at_submission, self.owner_id,\n                self.suggestion_change, 'test description')\n\n        suggestion = suggestion_services.get_suggestion_by_id(self.THREAD_ID)\n\n        self.assertIsNotNone(suggestion)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_IN_REVIEW)\n\n    def add_exploration_0_to_story(self):\n        \"\"\"Adds exploration 0 as a node to the test story.\"\"\"\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': '0'\n            })], 'Changes.')\n\n    def test_new_opportunity_with_adding_exploration_in_story_node(self):\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.topic_name, 'topic')\n        self.assertEqual(opportunity.story_title, 'A story')\n\n    def test_get_translation_opportunities_with_translations_in_review(\n        self):\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n        self.add_exploration_0_to_story()\n        self.create_translation_suggestion_for_exploration_0_and_verify()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n\n        self.assertEqual(len(translation_opportunities), 1)\n        opportunity = translation_opportunities[0]\n        self.assertEqual(\n            opportunity.translation_in_review_counts,\n            {'hi': 1})\n\n    def test_get_translation_opportunities_with_no_translations_in_review(self):\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n\n        self.assertEqual(len(translation_opportunities), 1)\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.translation_in_review_counts, {})\n\n    def test_opportunity_get_deleted_with_removing_exploration_from_story_node(\n            self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'delete_story_node',\n                'node_id': 'node_1',\n            })], 'Deleted one node.')\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n    def test_opportunity_get_deleted_with_deleting_story(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        story_services.delete_story(self.owner_id, self.STORY_ID)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n    def test_opportunity_get_deleted_with_deleting_topic(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        topic_services.delete_topic(self.owner_id, self.TOPIC_ID)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n    def test_opportunities_updates_with_updating_topic_name(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.story_title, 'A story')\n        self.assertEqual(opportunity.topic_name, 'topic')\n\n        topic_services.update_topic_and_subtopic_pages(\n            self.owner_id, self.TOPIC_ID, [topic_domain.TopicChange({\n                'cmd': 'update_topic_property',\n                'property_name': 'name',\n                'old_value': 'topic',\n                'new_value': 'A new topic'\n            })], 'Change topic title.')\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'A new topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.story_title, 'A story')\n        self.assertEqual(opportunity.topic_name, 'A new topic')\n\n    def test_opportunities_updates_with_updating_story_title(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.story_title, 'A story')\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'update_story_property',\n                'property_name': 'title',\n                'old_value': 'A story',\n                'new_value': 'A new story'\n            })], 'Change story title.')\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.story_title, 'A new story')\n\n    def test_opportunity_updates_with_updating_story_node_title(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.chapter_title, 'Node1')\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'title',\n                'node_id': 'node_1',\n                'old_value': 'Node1',\n                'new_value': 'A new Node1'\n            })], 'Change node title.')\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        opportunity = translation_opportunities[0]\n        self.assertEqual(opportunity.chapter_title, 'A new Node1')\n\n    def test_opportunity_updates_with_updating_exploration(self):\n        self.add_exploration_0_to_story()\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n        self.assertEqual(translation_opportunities[0].content_count, 2)\n\n        answer_group_dict = {\n            'outcome': {\n                'dest': 'Introduction',\n                'feedback': {\n                    'content_id': 'feedback_1',\n                    'html': '<p>Feedback</p>'\n                },\n                'labelled_as_correct': False,\n                'param_changes': [],\n                'refresher_exploration_id': None,\n                'missing_prerequisite_skill_id': None\n            },\n            'rule_specs': [{\n                'inputs': {\n                    'x': {\n                        'contentId': 'rule_input_4',\n                        'normalizedStrSet': ['Test']\n                    }\n                },\n                'rule_type': 'Contains'\n            }],\n            'training_data': [],\n            'tagged_skill_misconception_id': None\n        }\n\n        hints_list = []\n        hints_list.append({\n            'hint_content': {\n                'content_id': 'hint_1',\n                'html': '<p>hint one</p>'\n            },\n        })\n\n        solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'helloworld!',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>hello_world is a string</p>'\n            },\n        }\n        exp_services.update_exploration(\n            self.owner_id, '0', [\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': exp_domain.STATE_PROPERTY_INTERACTION_ID,\n                    'state_name': 'Introduction',\n                    'new_value': 'TextInput'\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name':\n                        exp_domain.STATE_PROPERTY_INTERACTION_CUST_ARGS,\n                    'state_name': 'Introduction',\n                    'new_value': {\n                        'placeholder': {\n                            'value': {\n                                'content_id': 'ca_placeholder_0',\n                                'unicode_str': ''\n                            }\n                        },\n                        'rows': {'value': 1}\n                    }\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_ANSWER_GROUPS),\n                    'state_name': 'Introduction',\n                    'new_value': [answer_group_dict]\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'state_name': 'Introduction',\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_NEXT_CONTENT_ID_INDEX),\n                    'new_value': 4\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_HINTS),\n                    'state_name': 'Introduction',\n                    'new_value': hints_list\n                }),\n                exp_domain.ExplorationChange({\n                    'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                    'property_name': (\n                        exp_domain.STATE_PROPERTY_INTERACTION_SOLUTION),\n                    'state_name': 'Introduction',\n                    'new_value': solution_dict\n                })], 'Add state name')\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n        self.assertEqual(translation_opportunities[0].content_count, 6)\n\n    def test_completing_translation_removes_language_from_incomplete_language_codes( # pylint: disable=line-too-long\n            self):\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': '0'\n            })], 'Changes.')\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        change_list = [\n            exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'state_name': 'Introduction',\n                'property_name': 'content',\n                'new_value': {\n                    'html': '<p><strong>Test content</strong></p>',\n                    'content_id': 'content',\n                }\n            }),\n            exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                'state_name': 'Introduction',\n                'content_id': 'content',\n                'language_code': 'hi',\n                'content_html': '<p><strong>Test content</strong></p>',\n                'translation_html': '<p>Translated text</p>',\n                'data_format': 'html'\n            }),\n            exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'state_name': 'End State',\n                'property_name': 'content',\n                'new_value': {\n                    'html': '<p><strong>Test content</strong></p>',\n                    'content_id': 'content',\n                }\n            }),\n            exp_domain.ExplorationChange({\n                'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n                'state_name': 'End State',\n                'content_id': 'content',\n                'language_code': 'hi',\n                'content_html': '<p><strong>Test content</strong></p>',\n                'translation_html': '<p>Translated text</p>',\n                'data_format': 'html'\n            }),\n        ]\n        exp_services.update_exploration(\n            self.owner_id, '0', change_list, 'commit message')\n\n        # get_translation_opportunities should no longer return the opportunity\n        # after translation completion.\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n        # The translation opportunity should be returned after marking a\n        # translation as stale.\n        translation_needs_update_change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_MARK_WRITTEN_TRANSLATION_AS_NEEDING_UPDATE,\n            'state_name': 'Introduction',\n            'content_id': 'content',\n            'language_code': 'hi'\n        })]\n        exp_services.update_exploration(\n            self.owner_id, '0', translation_needs_update_change_list,\n            'commit message')\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n    def test_create_new_skill_creates_new_skill_opportunity(self):\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 0)\n\n        self.save_new_skill(\n            self.SKILL_ID, self.USER_ID, description='skill_description')\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 1)\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.id, self.SKILL_ID)\n        self.assertEqual(opportunity.skill_description, 'skill_description')\n\n    def test_create_skill_opportunity_counts_existing_linked_questions(self):\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), [self.SKILL_ID])\n        question_services.create_new_question_skill_link(\n            self.USER_ID, self.QUESTION_ID, self.SKILL_ID, 0.3)\n\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 1)\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.id, self.SKILL_ID)\n        self.assertEqual(opportunity.skill_description, 'description')\n        self.assertEqual(opportunity.question_count, 1)\n\n    def test_create_skill_opportunity_for_existing_opportunity_raises_exception(\n            self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n        with self.assertRaisesRegex(\n            Exception,\n            'SkillOpportunity corresponding to skill ID %s already exists.'\n            % self.SKILL_ID):\n            opportunity_services.create_skill_opportunity(\n                self.SKILL_ID, 'description')\n\n    def test_update_skill_description_updates_skill_opportunity(self):\n        self.save_new_skill(\n            self.SKILL_ID, self.USER_ID, description='skill_description')\n        changelist = [\n            skill_domain.SkillChange({\n                'cmd': skill_domain.CMD_UPDATE_SKILL_PROPERTY,\n                'property_name': (\n                    skill_domain.SKILL_PROPERTY_DESCRIPTION),\n                'old_value': 'skill_description',\n                'new_value': 'new_description'\n            })\n        ]\n\n        skill_services.update_skill(\n            self.admin_id, self.SKILL_ID, changelist,\n            'Updated misconception name.')\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.id, self.SKILL_ID)\n        self.assertEqual(opportunity.skill_description, 'new_description')\n\n    def test_update_skill_opportunity_skill_description_invalid_skill_id(self):\n        opportunity_services.update_skill_opportunity_skill_description(\n            'bad_skill_id', 'bad_description')\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 0)\n\n    def test_delete_skill_deletes_skill_opportunity(self):\n        self.save_new_skill(\n            self.SKILL_ID, self.USER_ID, description='skill_description')\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 1)\n\n        skill_services.delete_skill(self.USER_ID, self.SKILL_ID)\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        self.assertEqual(len(skill_opportunities), 0)\n\n    def test_publish_story_creates_exploration_opportunity(self):\n        self.add_exploration_0_to_story()\n        # Story is already published, so unpublish first.\n        topic_services.unpublish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n    def test_publish_story_creates_exploration_opportunity_if_topic_is_not_published( # pylint: disable=line-too-long\n            self):\n        self.add_exploration_0_to_story()\n        # Story and topic are already published, so unpublish first.\n        topic_services.unpublish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n        topic_services.unpublish_topic(self.TOPIC_ID, self.admin_id)\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities('hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n    def test_unpublish_story_deletes_exploration_opportunity(self):\n        self.add_exploration_0_to_story()\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 1)\n\n        topic_services.unpublish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        translation_opportunities, _, _ = (\n            opportunity_services.get_translation_opportunities(\n                'hi', 'topic', None))\n        self.assertEqual(len(translation_opportunities), 0)\n\n    def test_unpublish_story_rejects_translation_suggestions(self):\n        self.add_exploration_0_to_story()\n        self.create_translation_suggestion_for_exploration_0_and_verify()\n\n        topic_services.unpublish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        suggestion = suggestion_services.get_suggestion_by_id(self.THREAD_ID)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_REJECTED)\n\n    def test_add_question_increments_skill_opportunity_question_count(self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), [self.SKILL_ID])\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(len(skill_opportunities), 1)\n        self.assertEqual(opportunity.question_count, 1)\n\n    def test_create_question_skill_link_increments_question_count(self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), [self.SKILL_ID])\n\n        question_services.create_new_question_skill_link(\n            self.USER_ID, self.QUESTION_ID, self.SKILL_ID, 0.3)\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.question_count, 1)\n\n    def test_link_multiple_skills_for_question_increments_question_count(self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), ['skill_2'])\n\n        question_services.link_multiple_skills_for_question(\n            self.USER_ID, self.QUESTION_ID, [self.SKILL_ID], [0.3])\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.question_count, 1)\n\n    def test_delete_question_decrements_question_count(self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), [self.SKILL_ID])\n\n        question_services.delete_question(self.USER_ID, self.QUESTION_ID)\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(len(skill_opportunities), 1)\n        self.assertEqual(opportunity.question_count, 0)\n\n    def test_delete_question_skill_link_decrements_question_count(self):\n        opportunity_services.create_skill_opportunity(\n            self.SKILL_ID, 'description')\n        self.save_new_question(\n            self.QUESTION_ID, self.USER_ID,\n            self._create_valid_question_data('ABC'), ['skill_2'])\n        question_services.create_new_question_skill_link(\n            self.USER_ID, self.QUESTION_ID, self.SKILL_ID, 0.3)\n\n        question_services.delete_question_skill_link(\n            self.USER_ID, self.QUESTION_ID, self.SKILL_ID)\n\n        skill_opportunities, _, _ = (\n            opportunity_services.get_skill_opportunities(None))\n        opportunity = skill_opportunities[0]\n        self.assertEqual(opportunity.question_count, 0)\n\n\nclass OpportunityServicesUnitTest(test_utils.GenericTestBase):\n    \"\"\"Test the opportunity services methods.\"\"\"\n\n    def setUp(self):\n        super(OpportunityServicesUnitTest, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n\n        self.admin_id = self.get_user_id_from_email(self.CURRICULUM_ADMIN_EMAIL)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n\n        self.set_curriculum_admins([self.CURRICULUM_ADMIN_USERNAME])\n\n        self.TOPIC_ID = 'topic'\n        self.STORY_ID = 'story'\n        explorations = [self.save_new_valid_exploration(\n            '%s' % i,\n            self.owner_id,\n            title='title %d' % i,\n            category='category%d' % i,\n            end_state_name='End State',\n            correctness_feedback_enabled=True\n        ) for i in range(5)]\n\n        for exp in explorations:\n            self.publish_exploration(self.owner_id, exp.id)\n\n        topic = topic_domain.Topic.create_default_topic(\n            self.TOPIC_ID, 'topic', 'abbrev', 'description')\n        topic.thumbnail_filename = 'thumbnail.svg'\n        topic.thumbnail_bg_color = '#C6DCDA'\n        topic.subtopics = [\n            topic_domain.Subtopic(\n                1, 'Title', ['skill_id_1'], 'image.svg',\n                constants.ALLOWED_THUMBNAIL_BG_COLORS['subtopic'][0], 21131,\n                'dummy-subtopic-url')]\n        topic.next_subtopic_id = 2\n        topic_services.save_new_topic(self.owner_id, topic)\n        topic_services.publish_topic(self.TOPIC_ID, self.admin_id)\n\n        story = story_domain.Story.create_default_story(\n            self.STORY_ID, 'A story', 'Description', self.TOPIC_ID,\n            'story-two')\n        story_services.save_new_story(self.owner_id, story)\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n        topic_services.publish_story(\n            self.TOPIC_ID, self.STORY_ID, self.admin_id)\n\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': '0'\n            })], 'Changes.')\n\n    def test_get_exploration_opportunity_summaries_by_ids(self):\n        output = (\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                []))\n\n        self.assertEqual(output, {})\n\n        opportunities = (\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                ['0']))\n\n        self.assertEqual(len(opportunities), 1)\n        self.assertIsInstance(\n            opportunities['0'],\n            opportunity_domain.ExplorationOpportunitySummary)\n        self.assertEqual(opportunities['0'].id, '0')\n\n    def test_get_exploration_opportunity_summaries_by_no_topic_id(self):\n        opportunity_summaries = (\n            opportunity_services\n                .get_exploration_opportunity_summaries_by_topic_id(\n                'None'))\n\n        self.assertEqual(opportunity_summaries, [])\n\n    def test_get_exploration_opportunity_summaries_by_valid_topic_id(self):\n        opportunity_summaries = (\n            opportunity_services\n                .get_exploration_opportunity_summaries_by_topic_id(\n                'topic'))\n\n        self.assertEqual(len(opportunity_summaries), 1)\n        self.assertIsInstance(\n            opportunity_summaries[0],\n            opportunity_domain.ExplorationOpportunitySummary)\n        self.assertEqual(opportunity_summaries[0].topic_id, 'topic')\n\n    def test_get_exploration_opportunity_summaries_by_ids_for_invalid_id(self):\n        opportunities = (\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                ['badID']))\n\n        self.assertEqual(len(opportunities), 1)\n        self.assertEqual(opportunities['badID'], None)\n\n    def test_get_exploration_opportunity_summary_from_model_populates_new_lang(\n            self):\n        observed_log_messages = []\n\n        def _mock_logging_function(msg, *args):\n            \"\"\"Mocks logging.info().\"\"\"\n            observed_log_messages.append(msg % args)\n\n        opportunities = (\n            opportunity_services.get_exploration_opportunity_summaries_by_ids(\n                ['0']))\n        self.assertEqual(len(opportunities), 1)\n\n        opportunity = opportunities['0']\n\n        self.assertFalse(\n            'new_lang' in opportunity.incomplete_translation_language_codes)\n\n        mock_supported_languages = constants.SUPPORTED_AUDIO_LANGUAGES + [{\n            'id': 'new_lang',\n            'description': 'New language',\n            'relatedLanguages': ['new_lang']\n        }]\n\n        self.assertEqual(len(observed_log_messages), 0)\n\n        with self.swap(logging, 'info', _mock_logging_function), self.swap(\n            constants, 'SUPPORTED_AUDIO_LANGUAGES', mock_supported_languages):\n            opportunities = (\n                opportunity_services\n                .get_exploration_opportunity_summaries_by_ids(['0']))\n            self.assertEqual(len(opportunities), 1)\n\n            opportunity = opportunities['0']\n\n            self.assertTrue(\n                'new_lang' in opportunity.incomplete_translation_language_codes)\n            self.assertEqual(len(observed_log_messages), 1)\n            self.assertEqual(\n                observed_log_messages[0],\n                'Missing language codes [\\'new_lang\\'] in exploration '\n                'opportunity model with id 0'\n            )\n\n    def test_delete_exp_opportunities_corresponding_to_story_when_story_deleted(\n            self):\n        opportunity_models.ExplorationOpportunitySummaryModel(\n            id='exp_1',\n            topic_id='topic_id',\n            topic_name='topic_name',\n            story_id='story_id',\n            story_title='story_title',\n            chapter_title='chapter_title',\n            content_count=1,\n        ).put()\n        opportunity_models.ExplorationOpportunitySummaryModel(\n            id='exp_2',\n            topic_id='topic_id',\n            topic_name='topic_name',\n            story_id='story_id',\n            story_title='story_title',\n            chapter_title='chapter_title',\n            content_count=1,\n        ).put()\n\n        opportunity_services.delete_exp_opportunities_corresponding_to_story(\n            'story_id'\n        )\n\n        self.assertIsNone(\n            opportunity_models.ExplorationOpportunitySummaryModel.get(\n                'exp_1', strict=False\n            )\n        )\n        self.assertIsNone(\n            opportunity_models.ExplorationOpportunitySummaryModel.get(\n                'exp_2', strict=False\n            )\n        )\n\n    def test_regenerate_opportunities_related_to_topic_when_story_deleted(self):\n        story_models.StoryModel.delete_by_id(self.STORY_ID)\n\n        self.assertRaisesRegex(\n            Exception, 'Failed to regenerate opportunities',\n            lambda: (\n                opportunity_services.regenerate_opportunities_related_to_topic(\n                    self.TOPIC_ID)))\n"
    },
    {
      "filename": "core/domain/suggestion_services.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Funtions to create, accept, reject, update and perform other operations on\nsuggestions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport heapq\nimport logging\nimport re\n\nfrom core import feconf\nfrom core.constants import constants\nfrom core.domain import email_manager\nfrom core.domain import exp_fetchers\nfrom core.domain import feedback_services\nfrom core.domain import html_cleaner\nfrom core.domain import html_validation_service\nfrom core.domain import question_domain\nfrom core.domain import suggestion_registry\nfrom core.domain import user_domain\nfrom core.domain import user_services\nfrom core.platform import models\n\n(feedback_models, suggestion_models, user_models) = (\n    models.Registry.import_models(\n        [models.NAMES.feedback, models.NAMES.suggestion, models.NAMES.user]))\ntransaction_services = models.Registry.import_transaction_services()\n\nDEFAULT_SUGGESTION_THREAD_SUBJECT = 'Suggestion from a user'\nDEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE = ''\n\n# The maximum number of suggestions to recommend to a reviewer to review in an\n# email.\nMAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER = 5\n\n# A dictionary that maps the suggestion type to a lambda function, which is\n# used to retrieve the html content that corresponds to the suggestion's\n# emphasized text on the Contributor Dashboard. From a UI perspective, the\n# emphasized content makes it easier for users to identify the different\n# suggestion opportunities. For instance, for translation suggestions the\n# emphasized text is the translation. Similarly, for question suggestions the\n# emphasized text is the question being asked.\nSUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS = {\n    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: (\n        lambda suggestion: suggestion.change.translation_html),\n    feconf.SUGGESTION_TYPE_ADD_QUESTION: (\n        lambda suggestion: suggestion.change.question_dict[\n            'question_state_data']['content']['html'])\n}\n\n\ndef create_suggestion(\n        suggestion_type, target_type, target_id, target_version_at_submission,\n        author_id, change, description):\n    \"\"\"Creates a new SuggestionModel and the corresponding FeedbackThread.\n\n    Args:\n        suggestion_type: str. The type of the suggestion. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_type: str. The target entity being edited. This parameter should\n            be one of the constants defined in storage/suggestion/gae_models.py.\n        target_id: str. The ID of the target entity being suggested to.\n        target_version_at_submission: int. The version number of the target\n            entity at the time of creation of the suggestion.\n        author_id: str. The ID of the user who submitted the suggestion.\n        change: dict. The details of the suggestion.\n        description: str. The description of the changes provided by the author.\n\n    Returns:\n        Suggestion. The newly created suggestion domain object.\n\n    Raises:\n        Exception. Invalid suggestion type.\n    \"\"\"\n    if description is None:\n        description = DEFAULT_SUGGESTION_THREAD_SUBJECT\n    thread_id = feedback_services.create_thread(\n        target_type, target_id, author_id, description,\n        DEFAULT_SUGGESTION_THREAD_INITIAL_MESSAGE, has_suggestion=True)\n\n    status = suggestion_models.STATUS_IN_REVIEW\n\n    if target_type == feconf.ENTITY_TYPE_EXPLORATION:\n        exploration = exp_fetchers.get_exploration_by_id(target_id)\n    if suggestion_type == feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT:\n        score_category = (\n            suggestion_models.SCORE_TYPE_CONTENT +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + exploration.category)\n        # Suggestions of this type do not have an associated language code,\n        # since they are not queryable by language.\n        language_code = None\n    elif suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT:\n        score_category = (\n            suggestion_models.SCORE_TYPE_TRANSLATION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + exploration.category)\n        # The language code of the translation, used for querying purposes.\n        language_code = change['language_code']\n        content_html = exploration.get_content_html(\n            change['state_name'], change['content_id'])\n        if content_html != change['content_html']:\n            raise Exception(\n                'The Exploration content has changed since this translation '\n                'was submitted.')\n    elif suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION:\n        score_category = (\n            suggestion_models.SCORE_TYPE_QUESTION +\n            suggestion_models.SCORE_CATEGORY_DELIMITER + target_id)\n        change['question_dict']['language_code'] = (\n            constants.DEFAULT_LANGUAGE_CODE)\n        change['question_dict']['question_state_data_schema_version'] = (\n            feconf.CURRENT_STATE_SCHEMA_VERSION)\n        # The language code of the question, used for querying purposes.\n        language_code = constants.DEFAULT_LANGUAGE_CODE\n    else:\n        raise Exception('Invalid suggestion type %s' % suggestion_type)\n\n    suggestion_domain_class = (\n        suggestion_registry.SUGGESTION_TYPES_TO_DOMAIN_CLASSES[\n            suggestion_type])\n    suggestion = suggestion_domain_class(\n        thread_id, target_id, target_version_at_submission, status, author_id,\n        None, change, score_category, language_code, False)\n    suggestion.validate()\n\n    suggestion_models.GeneralSuggestionModel.create(\n        suggestion_type, target_type, target_id,\n        target_version_at_submission, status, author_id,\n        None, change, score_category, thread_id, suggestion.language_code)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    return get_suggestion_by_id(thread_id)\n\n\ndef get_suggestion_from_model(suggestion_model):\n    \"\"\"Converts the given SuggestionModel to a Suggestion domain object\n\n    Args:\n        suggestion_model: SuggestionModel. SuggestionModel object to be\n            converted to Suggestion domain object.\n\n    Returns:\n        Suggestion. The corresponding Suggestion domain object.\n    \"\"\"\n    suggestion_domain_class = (\n        suggestion_registry.SUGGESTION_TYPES_TO_DOMAIN_CLASSES[\n            suggestion_model.suggestion_type])\n    return suggestion_domain_class(\n        suggestion_model.id, suggestion_model.target_id,\n        suggestion_model.target_version_at_submission,\n        suggestion_model.status, suggestion_model.author_id,\n        suggestion_model.final_reviewer_id, suggestion_model.change_cmd,\n        suggestion_model.score_category, suggestion_model.language_code,\n        suggestion_model.edited_by_reviewer, suggestion_model.last_updated)\n\n\ndef get_suggestion_by_id(suggestion_id):\n    \"\"\"Finds a suggestion by the suggestion ID.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n    \"\"\"\n    model = suggestion_models.GeneralSuggestionModel.get_by_id(suggestion_id)\n\n    return get_suggestion_from_model(model) if model else None\n\n\ndef get_suggestions_by_ids(suggestion_ids):\n    \"\"\"Finds suggestions using the given suggestion IDs.\n\n    Args:\n        suggestion_ids: list(str). The IDs of the suggestions.\n\n    Returns:\n        list(Suggestion|None). A list of the corresponding suggestions. The\n        list will contain None elements if no suggestion is found with the\n        corresponding suggestion id.\n    \"\"\"\n    general_suggestion_models = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n\n    return [\n        get_suggestion_from_model(suggestion_model) if suggestion_model\n        else None for suggestion_model in general_suggestion_models\n    ]\n\n\ndef query_suggestions(query_fields_and_values):\n    \"\"\"Queries for suggestions.\n\n    Args:\n        query_fields_and_values: list(tuple(str, str)). A list of queries. The\n            first element in each tuple is the field to be queried, and the\n            second element is its value.\n\n    Returns:\n        list(Suggestion). A list of suggestions that match the given query\n        values, up to a maximum of feconf.DEFAULT_QUERY_LIMIT suggestions.\n    \"\"\"\n    return [\n        get_suggestion_from_model(s) for s in\n        suggestion_models.GeneralSuggestionModel.query_suggestions(\n            query_fields_and_values)\n    ]\n\n\ndef get_translation_suggestion_ids_with_exp_ids(exp_ids):\n    \"\"\"Gets the ids of the translation suggestions corresponding to\n    explorations with the given exploration ids.\n\n    Args:\n        exp_ids: list(str). List of exploration ids to query for.\n\n    Returns:\n        list(str). A list of the ids of translation suggestions that\n        correspond to the given exploration ids. Note: it is not\n        guaranteed that the suggestion ids returned are ordered by the\n        exploration ids in exp_ids.\n    \"\"\"\n    if len(exp_ids) == 0:\n        return []\n\n    return (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestion_ids_with_exp_ids(exp_ids)\n    )\n\n\ndef get_all_stale_suggestion_ids():\n    \"\"\"Gets a list of the suggestion ids corresponding to suggestions that have\n    not had any activity on them for THRESHOLD_TIME_BEFORE_ACCEPT time.\n\n    Returns:\n        list(str). A list of suggestion ids that correspond to stale\n        suggestions.\n    \"\"\"\n\n    return (\n        suggestion_models.GeneralSuggestionModel.get_all_stale_suggestion_ids()\n    )\n\n\ndef _update_suggestion(suggestion):\n    \"\"\"Updates the given suggestion.\n\n    Args:\n        suggestion: Suggestion. The suggestion to be updated.\n    \"\"\"\n    _update_suggestions([suggestion])\n\n\ndef _update_suggestions(suggestions, update_last_updated_time=True):\n    \"\"\"Updates the given suggestions.\n\n    Args:\n        suggestions: list(Suggestion). The suggestions to be updated.\n        update_last_updated_time: bool. Whether to update the last_updated\n            field of the suggestions.\n    \"\"\"\n    suggestion_ids = []\n\n    for suggestion in suggestions:\n        suggestion.validate()\n        suggestion_ids.append(suggestion.suggestion_id)\n\n    suggestion_models_to_update = (\n        suggestion_models.GeneralSuggestionModel.get_multi(suggestion_ids)\n    )\n\n    for index, suggestion_model in enumerate(suggestion_models_to_update):\n        suggestion = suggestions[index]\n        suggestion_model.status = suggestion.status\n        suggestion_model.final_reviewer_id = suggestion.final_reviewer_id\n        suggestion_model.change_cmd = suggestion.change.to_dict()\n        suggestion_model.score_category = suggestion.score_category\n        suggestion_model.language_code = suggestion.language_code\n        suggestion_model.edited_by_reviewer = suggestion.edited_by_reviewer\n\n    suggestion_models.GeneralSuggestionModel.update_timestamps_multi(\n        suggestion_models_to_update,\n        update_last_updated_time=update_last_updated_time)\n    suggestion_models.GeneralSuggestionModel.put_multi(\n        suggestion_models_to_update)\n\n\ndef get_commit_message_for_suggestion(author_username, commit_message):\n    \"\"\"Returns a modified commit message for an accepted suggestion.\n\n    Args:\n        author_username: str. Username of the suggestion author.\n        commit_message: str. The original commit message submitted by the\n            suggestion author.\n\n    Returns:\n        str. The modified commit message to be used in the exploration commit\n        logs.\n    \"\"\"\n    return '%s %s: %s' % (\n        feconf.COMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX,\n        author_username, commit_message)\n\n\ndef accept_suggestion(\n        suggestion_id, reviewer_id, commit_message, review_message):\n    \"\"\"Accepts the suggestion with the given suggestion_id after validating it.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be accepted.\n        reviewer_id: str. The ID of the reviewer accepting the suggestion.\n        commit_message: str. The commit message.\n        review_message: str. The message provided by the reviewer while\n            accepting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n        Exception. The suggestion is not valid.\n        Exception. The commit message is empty.\n    \"\"\"\n    if not commit_message or not commit_message.strip():\n        raise Exception('Commit message cannot be empty.')\n\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    if suggestion is None:\n        raise Exception(\n            'You cannot accept the suggestion with id %s because it does '\n            'not exist.' % (suggestion_id)\n        )\n    if suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s has already been accepted/'\n            'rejected.' % (suggestion_id)\n        )\n    suggestion.pre_accept_validate()\n    html_string = ''.join(suggestion.get_all_html_content_strings())\n    error_list = (\n        html_validation_service.\n        validate_math_tags_in_html_with_attribute_math_content(\n            html_string))\n    if len(error_list) > 0:\n        raise Exception(\n            'Invalid math tags found in the suggestion with id %s.' % (\n                suggestion.suggestion_id)\n        )\n\n    if suggestion.edited_by_reviewer:\n        commit_message = '%s (with edits)' % commit_message\n\n    suggestion.set_suggestion_status_to_accepted()\n    suggestion.set_final_reviewer_id(reviewer_id)\n\n    author_name = user_services.get_username(suggestion.author_id)\n    commit_message = get_commit_message_for_suggestion(\n        author_name, commit_message)\n    suggestion.accept(commit_message)\n\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review decreases by one, since this\n    # suggestion is no longer in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], -1)\n\n    feedback_services.create_message(\n        suggestion_id, reviewer_id, feedback_models.STATUS_CHOICES_FIXED,\n        None, review_message, should_send_email=False)\n\n    # When recording of scores is enabled, the author of the suggestion gets an\n    # increase in their score for the suggestion category.\n    if feconf.ENABLE_RECORDING_OF_SCORES:\n        user_id = suggestion.author_id\n        score_category = suggestion.score_category\n\n        # Get user proficiency domain object.\n        user_proficiency = _get_user_proficiency(user_id, score_category)\n\n        # Increment the score of the author due to their suggestion being\n        # accepted.\n        user_proficiency.increment_score(\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY\n        )\n\n        # Emails are sent to onboard new reviewers. These new reviewers are\n        # created when the score of the user passes the minimum score required\n        # to review.\n        if feconf.SEND_SUGGESTION_REVIEW_RELATED_EMAILS:\n            if user_proficiency.can_user_review_category() and (\n                    not user_proficiency.onboarding_email_sent):\n                email_manager.send_mail_to_onboard_new_reviewers(\n                    user_id, score_category\n                )\n                user_proficiency.mark_onboarding_email_as_sent()\n\n        # Need to update the corresponding user proficiency model after we\n        # updated the domain object.\n        _update_user_proficiency(user_proficiency)\n\n\ndef reject_suggestion(suggestion_id, reviewer_id, review_message):\n    \"\"\"Rejects the suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestion.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestion.\n\n    Raises:\n        Exception. The suggestion is already handled.\n    \"\"\"\n\n    reject_suggestions([suggestion_id], reviewer_id, review_message)\n\n\ndef reject_suggestions(suggestion_ids, reviewer_id, review_message):\n    \"\"\"Rejects the suggestions with the given suggestion_ids.\n\n    Args:\n        suggestion_ids: list(str). The ids of the suggestions to be rejected.\n        reviewer_id: str. The ID of the reviewer rejecting the suggestions.\n        review_message: str. The message provided by the reviewer while\n            rejecting the suggestions.\n\n    Raises:\n        Exception. One or more of the suggestions has already been handled.\n    \"\"\"\n    suggestions = get_suggestions_by_ids(suggestion_ids)\n\n    for index, suggestion in enumerate(suggestions):\n        if suggestion is None:\n            raise Exception(\n                'You cannot reject the suggestion with id %s because it does '\n                'not exist.' % (suggestion_ids[index])\n            )\n        if suggestion.is_handled:\n            raise Exception(\n                'The suggestion with id %s has already been accepted/'\n                'rejected.' % (suggestion.suggestion_id)\n            )\n    if not review_message:\n        raise Exception('Review message cannot be empty.')\n\n    for suggestion in suggestions:\n        suggestion.set_suggestion_status_to_rejected()\n        suggestion.set_final_reviewer_id(reviewer_id)\n\n    _update_suggestions(suggestions)\n\n    # Update the community contribution stats so that the number of suggestions\n    # that are in review decreases, since these suggestions are no longer in\n    # review.\n    _update_suggestion_counts_in_community_contribution_stats(suggestions, -1)\n\n    feedback_services.create_messages(\n        suggestion_ids, reviewer_id, feedback_models.STATUS_CHOICES_IGNORED,\n        None, review_message, should_send_email=False\n    )\n\n\ndef auto_reject_question_suggestions_for_skill_id(skill_id):\n    \"\"\"Rejects all SuggestionAddQuestions with target ID matching the supplied\n    skill ID. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        skill_id: str. The skill ID corresponding to the target ID of the\n            SuggestionAddQuestion.\n    \"\"\"\n    suggestions = query_suggestions(\n        [\n            (\n                'suggestion_type',\n                feconf.SUGGESTION_TYPE_ADD_QUESTION),\n            ('target_id', skill_id)\n        ]\n    )\n\n    suggestion_ids = [suggestion.suggestion_id for suggestion in suggestions]\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.DELETED_SKILL_REJECT_MESSAGE)\n\n\ndef auto_reject_translation_suggestions_for_exp_ids(exp_ids):\n    \"\"\"Rejects all translation suggestions with target IDs matching the\n    supplied exploration IDs. These suggestions are being rejected because\n    their corresponding exploration was removed from a story or the story was\n    deleted. Reviewer ID is set to SUGGESTION_BOT_USER_ID.\n\n    Args:\n        exp_ids: list(str). The exploration IDs corresponding to the target IDs\n            of the translation suggestions.\n    \"\"\"\n    suggestion_ids = get_translation_suggestion_ids_with_exp_ids(exp_ids)\n\n    reject_suggestions(\n        suggestion_ids, feconf.SUGGESTION_BOT_USER_ID,\n        suggestion_models.INVALID_STORY_REJECT_TRANSLATION_SUGGESTIONS_MSG)\n\n\ndef resubmit_rejected_suggestion(\n        suggestion_id, summary_message, author_id, change):\n    \"\"\"Resubmit a rejected suggestion with the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the rejected suggestion.\n        summary_message: str. The message provided by the author to\n            summarize new suggestion.\n        author_id: str. The ID of the author creating the suggestion.\n        change: ExplorationChange. The new change to apply to the suggestion.\n\n    Raises:\n        Exception. The summary message is empty.\n        Exception. The suggestion has not been handled yet.\n        Exception. The suggestion has already been accepted.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    if not summary_message:\n        raise Exception('Summary message cannot be empty.')\n    if not suggestion.is_handled:\n        raise Exception(\n            'The suggestion with id %s is not yet handled.' % (suggestion_id)\n        )\n    if suggestion.status == suggestion_models.STATUS_ACCEPTED:\n        raise Exception(\n            'The suggestion with id %s was accepted. '\n            'Only rejected suggestions can be resubmitted.' % (suggestion_id)\n        )\n\n    suggestion.pre_update_validate(change)\n    suggestion.change = change\n    suggestion.set_suggestion_status_to_in_review()\n    _update_suggestion(suggestion)\n\n    # Update the community contribution stats so that the number of suggestions\n    # of this type that are in review increases by one, since this suggestion is\n    # now back in review.\n    _update_suggestion_counts_in_community_contribution_stats([suggestion], 1)\n\n    feedback_services.create_message(\n        suggestion_id, author_id, feedback_models.STATUS_CHOICES_OPEN,\n        None, summary_message)\n\n\ndef get_all_suggestions_that_can_be_reviewed_by_user(user_id):\n    \"\"\"Returns a list of suggestions which need to be reviewed, in categories\n    where the user has crossed the minimum score to review.\n\n    Args:\n        user_id: str. The ID of the user.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user is allowed\n        to review.\n    \"\"\"\n    score_categories = (\n        user_models.UserContributionProficiencyModel\n        .get_all_categories_where_user_can_review(user_id))\n\n    if len(score_categories) == 0:\n        return []\n\n    return ([\n        get_suggestion_from_model(s)\n        for s in suggestion_models.GeneralSuggestionModel\n        .get_in_review_suggestions_in_score_categories(\n            score_categories, user_id)\n    ])\n\n\ndef get_reviewable_translation_suggestions_by_offset(\n        user_id, opportunity_summary_exp_ids, limit, offset):\n    \"\"\"Returns a list of translation suggestions matching the\n     passed opportunity IDs which the user can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        opportunity_summary_exp_ids: list(str) or None.\n            The list of exploration IDs for which suggestions\n            are fetched. If the list is empty, no suggestions are\n            fetched. If the value is None, all reviewable\n            suggestions are fetched. If the list consists of some\n            valid number of ids, suggestions corresponding to the\n            IDs are fetched.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of translation suggestions\n            which the supplied user is permitted to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    contribution_rights = user_services.get_user_contribution_rights(\n        user_id)\n    language_codes = (\n        contribution_rights.can_review_translation_for_language_codes)\n\n    in_review_translation_suggestions = []\n    next_offset = 0\n    if opportunity_summary_exp_ids is None:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit, offset,\n                user_id, language_codes))\n    elif len(opportunity_summary_exp_ids) > 0:\n        in_review_translation_suggestions, next_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                limit, offset,\n                user_id, language_codes,\n                opportunity_summary_exp_ids))\n\n    translation_suggestions = ([\n        get_suggestion_from_model(s)\n        for s in in_review_translation_suggestions\n    ])\n    return translation_suggestions, next_offset\n\n\ndef get_reviewable_question_suggestions_by_offset(\n        user_id, limit, offset):\n    \"\"\"Returns a list of question suggestions which the user\n       can review.\n\n    Args:\n        user_id: str. The ID of the user.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning of all\n            results matching the query.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of question suggestions which\n            the given user is allowed to review.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    suggestions, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_question_suggestions_by_offset(limit, offset, user_id))\n\n    question_suggestions = ([\n        get_suggestion_from_model(s) for s in suggestions\n    ])\n    return question_suggestions, next_offset\n\n\ndef get_question_suggestions_waiting_longest_for_review():\n    \"\"\"Returns MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS number\n    of question suggestions, sorted in descending order by review wait time.\n\n    Returns:\n        list(Suggestion). A list of question suggestions, sorted in descending\n        order based on how long the suggestions have been waiting for review.\n    \"\"\"\n    return [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n    ]\n\n\ndef get_translation_suggestions_waiting_longest_for_review(language_code):\n    \"\"\"Returns MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS\n    number of translation suggestions in the specified language code,\n    sorted in descending order by review wait time.\n\n    Args:\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions, sorted in\n        descending order based on how long the suggestions have been waiting\n        for review.\n    \"\"\"\n    return [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                language_code)\n        )\n    ]\n\n\ndef get_translation_suggestions_in_review_by_exploration(exp_id, language_code):\n    \"\"\"Returns translation suggestions in review by exploration ID.\n\n    Args:\n        exp_id: str. Exploration ID.\n        language_code: str. Language code.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id == exp_id.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_translation_suggestions_in_review_with_exp_id(\n            exp_id, language_code)\n    )\n    return [\n        get_suggestion_from_model(model) if model else None\n        for model in suggestion_models_in_review\n    ]\n\n\ndef get_translation_suggestions_in_review_by_exp_ids(exp_ids, language_code):\n    \"\"\"Returns translation suggestions in review by exploration ID and language\n    code.\n\n    Args:\n        exp_ids: list(str). Exploration IDs matching the target ID of the\n            translation suggestions.\n        language_code: str. The ISO 639-1 language code of the translation\n            suggestions.\n\n    Returns:\n        list(Suggestion). A list of translation suggestions in review with\n        target_id in exp_ids and language_code == language_code.\n    \"\"\"\n    suggestion_models_in_review = (\n        suggestion_models.GeneralSuggestionModel\n        .get_in_review_translation_suggestions_by_exp_ids(\n            exp_ids, language_code)\n    )\n    return [\n        get_suggestion_from_model(model) if model else None\n        for model in suggestion_models_in_review\n    ]\n\n\ndef _get_plain_text_from_html_content_string(html_content_string):\n    \"\"\"Retrieves the plain text from the given html content string. RTE element\n    occurrences in the html are replaced by their corresponding rte component\n    name, capitalized in square brackets.\n    eg: <p>Sample1 <oppia-noninteractive-math></oppia-noninteractive-math>\n        Sample2 </p> will give as output: Sample1 [Math] Sample2.\n    Note: similar logic exists in the frontend in format-rte-preview.filter.ts.\n\n    Args:\n        html_content_string: str. The content html string to convert to plain\n            text.\n\n    Returns:\n        str. The plain text string from the given html content string.\n    \"\"\"\n\n    def _replace_rte_tag(rte_tag):\n        \"\"\"Replaces all of the <oppia-noninteractive-**> tags with their\n        corresponding rte component name in square brackets.\n\n        Args:\n            rte_tag: MatchObject. A matched object that contins the\n                oppia-noninteractive rte tags.\n\n        Returns:\n            str. The string to replace the rte tags with.\n        \"\"\"\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_string = rte_tag.group(0)\n        # Get the name of the rte tag. The hyphen is there as an optional\n        # matching character to cover the case where the name of the rte\n        # component is more than one word.\n        rte_tag_name = re.search(\n            r'oppia-noninteractive-(\\w|-)+', rte_tag_string)\n        # Retrieve the matched string from the MatchObject.\n        rte_tag_name_string = rte_tag_name.group(0)\n        # Get the name of the rte component.\n        rte_component_name_string = rte_tag_name_string.split('-')[2:]\n        # If the component name is more than word, connect the words with spaces\n        # to create a single string.\n        rte_component_name_string = ' '.join(rte_component_name_string)\n        # Captialize each word in the string.\n        capitalized_rte_component_name_string = (\n            rte_component_name_string.title())\n        formatted_rte_component_name_string = ' [%s] ' % (\n            capitalized_rte_component_name_string)\n        return formatted_rte_component_name_string\n\n    # Replace all the <oppia-noninteractive-**> tags with their rte component\n    # names capitalized in square brackets.\n    html_content_string_with_rte_tags_replaced = re.sub(\n        r'<oppia-noninteractive-[^>]+>(.*?)</oppia-noninteractive-[^>]+>',\n        _replace_rte_tag, html_content_string)\n    # Get rid of all of the other html tags.\n    plain_text = html_cleaner.strip_html_tags(\n        html_content_string_with_rte_tags_replaced)\n    # Remove trailing and leading whitespace and ensure that all words are\n    # separated by a single space.\n    plain_text_without_contiguous_whitespace = ' '.join(plain_text.split())\n    return plain_text_without_contiguous_whitespace\n\n\ndef create_reviewable_suggestion_email_info_from_suggestion(suggestion):\n    \"\"\"Creates an object with the key information needed to notify reviewers or\n    admins that the given suggestion needs review.\n\n    Args:\n        suggestion: Suggestion. The suggestion used to create the\n            ReviewableSuggestionEmailInfo object. Note that the suggestion's\n            status must be in review.\n\n    Returns:\n        ReviewableSuggestionEmailInfo. The corresponding reviewable suggestion\n        email info.\n\n    Raises:\n        Exception. The suggestion type must be offered on the Contributor\n            Dashboard.\n    \"\"\"\n    if suggestion.suggestion_type not in (\n            SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS):\n        raise Exception(\n            'Expected suggestion type to be offered on the Contributor '\n            'Dashboard, received: %s.' % suggestion.suggestion_type)\n\n    # Retrieve the html content that is emphasized on the Contributor Dashboard\n    # pages. This content is what stands out for each suggestion when a user\n    # views a list of suggestions.\n    get_html_representing_suggestion = (\n        SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS[\n            suggestion.suggestion_type]\n    )\n    plain_text = _get_plain_text_from_html_content_string(\n        get_html_representing_suggestion(suggestion))\n    return suggestion_registry.ReviewableSuggestionEmailInfo(\n        suggestion.suggestion_type, suggestion.language_code, plain_text,\n        suggestion.last_updated\n    )\n\n\ndef get_suggestions_waiting_for_review_info_to_notify_reviewers(reviewer_ids):\n    \"\"\"For each user, returns information that will be used to notify reviewers\n    about the suggestions waiting longest for review, that the reviewer has\n    permissions to review.\n\n    Args:\n        reviewer_ids: list(str). A list of the reviewer user ids to notify.\n\n    Returns:\n        list(list(ReviewableSuggestionEmailInfo)). A list of suggestion\n        email content info objects for each reviewer. Each suggestion email\n        content info object contains the type of the suggestion, the language\n        of the suggestion, the suggestion content (question/translation) and\n        the date that the suggestion was submitted for review. For each user\n        the suggestion email content info objects are sorted in descending order\n        based on review wait time.\n    \"\"\"\n    # Get each reviewer's review permissions.\n    users_contribution_rights = user_services.get_users_contribution_rights(\n        reviewer_ids\n    )\n\n    # Get the question suggestions that have been waiting longest for review.\n    question_suggestions = (\n        get_question_suggestions_waiting_longest_for_review()\n    )\n\n    # Create a dictionary to keep track of the translation suggestions that\n    # have been waiting longest for review for each language code.\n    translation_suggestions_by_lang_code_dict = {}\n\n    reviewers_reviewable_suggestion_infos = []\n\n    for user_contribution_rights in users_contribution_rights:\n        # Use a min heap because then the suggestions that have been waiting the\n        # longest for review (earliest review submission date) are automatically\n        # efficiently sorted.\n        suggestions_waiting_longest_heap = []\n        if user_contribution_rights.can_review_questions:\n            for question_suggestion in question_suggestions:\n                # Break early because we only want the top\n                # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER number of\n                # suggestions.\n                if len(suggestions_waiting_longest_heap) == (\n                        MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                    break\n                # We can't include suggestions that were authored by the\n                # reviewer because reviewers aren't allowed to review their own\n                # suggestions.\n                if question_suggestion.author_id != user_contribution_rights.id:\n                    heapq.heappush(suggestions_waiting_longest_heap, (\n                        question_suggestion.last_updated, question_suggestion))\n\n        if user_contribution_rights.can_review_translation_for_language_codes:\n            for language_code in (\n                    user_contribution_rights\n                    .can_review_translation_for_language_codes):\n                # Get a list of the translation suggestions in the language code\n                # from the datastore if we haven't already gotten them.\n                if language_code not in (\n                        translation_suggestions_by_lang_code_dict):\n                    translation_suggestions_by_lang_code_dict[language_code] = (\n                        get_translation_suggestions_waiting_longest_for_review(\n                            language_code\n                        )\n                    )\n\n                translation_suggestions = (\n                    translation_suggestions_by_lang_code_dict[language_code]\n                )\n                for translation_suggestion in translation_suggestions:\n                    if len(suggestions_waiting_longest_heap) == (\n                            MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n                        # The shortest review wait time corresponds to the most\n                        # recent review submission date, which is the max of\n                        # the heap.\n                        most_recent_review_submission = max(\n                            suggestions_waiting_longest_heap)[0]\n                        # If the review submission date for the translation\n                        # suggestion is more recent than the most recent\n                        # submission date so far, we can exit early.\n                        if translation_suggestion.last_updated > (\n                                most_recent_review_submission):\n                            break\n                    # Reviewers can never review their own suggestions.\n                    if translation_suggestion.author_id != (\n                            user_contribution_rights.id):\n                        heapq.heappush(suggestions_waiting_longest_heap, (\n                            translation_suggestion.last_updated,\n                            translation_suggestion))\n\n        # Get the key information from each suggestion that will be used to\n        # email reviewers.\n        reviewer_reviewable_suggestion_infos = []\n        for _ in range(MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER):\n            if len(suggestions_waiting_longest_heap) == 0:\n                break\n            _, suggestion = heapq.heappop(suggestions_waiting_longest_heap)\n            reviewer_reviewable_suggestion_infos.append(\n                create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            )\n        reviewers_reviewable_suggestion_infos.append(\n            reviewer_reviewable_suggestion_infos\n        )\n\n    return reviewers_reviewable_suggestion_infos\n\n\ndef get_submitted_suggestions(user_id, suggestion_type):\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of the suggestion.\n\n    Returns:\n        list(Suggestion). A list of suggestions which the given user has\n        submitted.\n    \"\"\"\n    return ([\n        get_suggestion_from_model(s) for s in (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_of_suggestion_type(\n                suggestion_type, user_id))\n    ])\n\n\ndef get_submitted_suggestions_by_offset(\n        user_id, suggestion_type, limit, offset):\n    \"\"\"Returns a list of suggestions of given suggestion_type which the user\n    has submitted.\n\n    Args:\n        user_id: str. The ID of the user.\n        suggestion_type: str. The type of suggestion.\n        limit: int. The maximum number of results to return.\n        offset: int. The number of results to skip from the beginning\n            of all results matching the query.\n\n    Returns:\n        Tuple of (results, next_offset). Where:\n            results: list(Suggestion). A list of suggestions of the supplied\n                type which the supplied user has submitted.\n            next_offset: int. The input offset + the number of results returned\n                by the current query.\n    \"\"\"\n    submitted_suggestion_models, next_offset = (\n        suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit,\n                offset,\n                suggestion_type,\n                user_id))\n    suggestions = ([\n        get_suggestion_from_model(s) for s in submitted_suggestion_models\n    ])\n    return suggestions, next_offset\n\n\ndef get_info_about_suggestions_waiting_too_long_for_review():\n    \"\"\"Gets the information about the suggestions that have been waiting longer\n    than suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days\n    for a review on the Contributor Dashboard. There can be information about at\n    most suggestion_models.MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN suggestions.\n    The information about the suggestions are returned in descending order by\n    the suggestion's review wait time.\n\n    Returns:\n        list(ReviewableSuggestionEmailContentInfo). A list of reviewable\n        suggestion email content info objects that represent suggestions that\n        have been waiting too long for a review. Each object contains the type\n        of the suggestion, the language of the suggestion, the suggestion\n        content (question/translation), and the date that the suggestion was\n        submitted for review. The objects are sorted in descending order based\n        on review wait time.\n    \"\"\"\n    suggestions_waiting_too_long_for_review = [\n        get_suggestion_from_model(suggestion_model) for suggestion_model in (\n            suggestion_models.GeneralSuggestionModel\n            .get_suggestions_waiting_too_long_for_review())\n    ]\n    return [\n        create_reviewable_suggestion_email_info_from_suggestion(\n            suggestion) for suggestion in\n        suggestions_waiting_too_long_for_review\n    ]\n\n\ndef get_user_proficiency_from_model(user_proficiency_model):\n    \"\"\"Converts the given UserContributionProficiencyModel to a\n    UserContributionProficiency domain object.\n\n    Args:\n        user_proficiency_model: UserContributionProficiencyModel.\n            UserContributionProficiencyModel to be converted to\n            a UserContributionProficiency domain object.\n\n    Returns:\n        UserContributionProficiency. The corresponding\n        UserContributionProficiency domain object.\n    \"\"\"\n    return user_domain.UserContributionProficiency(\n        user_proficiency_model.user_id, user_proficiency_model.score_category,\n        user_proficiency_model.score,\n        user_proficiency_model.onboarding_email_sent\n    )\n\n\ndef _update_user_proficiency(user_proficiency):\n    \"\"\"Updates the user_proficiency.\n\n    Args:\n        user_proficiency: UserContributionProficiency. The user proficiency to\n            be updated.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_proficiency.user_id, user_proficiency.score_category\n    )\n\n    if user_proficiency_model is not None:\n        user_proficiency_model.user_id = user_proficiency.user_id\n        user_proficiency_model.score_category = user_proficiency.score_category\n        user_proficiency_model.score = user_proficiency.score\n        user_proficiency_model.onboarding_email_sent = (\n            user_proficiency.onboarding_email_sent\n        )\n\n        user_proficiency_model.update_timestamps()\n        user_proficiency_model.put()\n\n    else:\n        user_models.UserContributionProficiencyModel.create(\n            user_proficiency.user_id, user_proficiency.score_category,\n            user_proficiency.score, user_proficiency.onboarding_email_sent)\n\n\ndef get_all_scores_of_user(user_id):\n    \"\"\"Gets all scores for a given user.\n\n    Args:\n        user_id: str. The id of the user.\n\n    Returns:\n        dict. A dict containing all the scores of the user. The keys of the dict\n        are the score categories and the values are the scores.\n    \"\"\"\n    scores = {}\n    for model in (\n            user_models.UserContributionProficiencyModel.get_all_scores_of_user(\n                user_id)):\n        scores[model.score_category] = model.score\n\n    return scores\n\n\ndef can_user_review_category(user_id, score_category):\n    \"\"\"Checks if user can review suggestions in category score_category.\n    If the user has score above the minimum required score, then the user is\n    allowed to review.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category to check the user's score.\n\n    Returns:\n        bool. Whether the user can review suggestions under category\n        score_category.\n    \"\"\"\n    user_proficiency = _get_user_proficiency(user_id, score_category)\n    return user_proficiency.can_user_review_category()\n\n\ndef get_all_user_ids_who_are_allowed_to_review(score_category):\n    \"\"\"Gets all user_ids of users who are allowed to review (as per their\n    scores) suggestions to a particular category.\n\n    Args:\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        list(str). All user_ids of users who are allowed to review in the given\n        category.\n    \"\"\"\n    return [\n        model.user_id for model in user_models.UserContributionProficiencyModel\n        .get_all_users_with_score_above_minimum_for_category(score_category)\n    ]\n\n\ndef _get_user_proficiency(user_id, score_category):\n    \"\"\"Gets the user proficiency model from storage and creates the\n    corresponding user proficiency domain object if the model exists. If the\n    model does not exist a user proficiency domain object with the given\n    user_id and score category is created with the initial score and email\n    values.\n\n    Args:\n        user_id: str. The id of the user.\n        score_category: str. The category of the suggestion.\n\n    Returns:\n        UserContributionProficiency. The user proficiency object.\n    \"\"\"\n    user_proficiency_model = user_models.UserContributionProficiencyModel.get(\n        user_id, score_category)\n\n    if user_proficiency_model is not None:\n        return get_user_proficiency_from_model(user_proficiency_model)\n\n    return user_domain.UserContributionProficiency(\n        user_id, score_category, 0, False)\n\n\ndef check_can_resubmit_suggestion(suggestion_id, user_id):\n    \"\"\"Checks whether the given user can resubmit the suggestion.\n\n    Args:\n        suggestion_id: str. The ID of the suggestion.\n        user_id: str. The ID of the user.\n\n    Returns:\n        bool. Whether the user can resubmit the suggestion.\n    \"\"\"\n\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    return suggestion.author_id == user_id\n\n\ndef _get_voiceover_application_class(target_type):\n    \"\"\"Returns the voiceover application class for a given target type.\n\n    Args:\n        target_type: str. The target type of the voiceover application.\n\n    Returns:\n        class. The voiceover application class for the given target type.\n\n    Raises:\n        Exception. The voiceover application target type is invalid.\n    \"\"\"\n    target_type_to_classes = (\n        suggestion_registry.VOICEOVER_APPLICATION_TARGET_TYPE_TO_DOMAIN_CLASSES)\n    if target_type in target_type_to_classes:\n        return target_type_to_classes[target_type]\n    else:\n        raise Exception(\n            'Invalid target type for voiceover application: %s' % target_type)\n\n\ndef get_voiceover_application(voiceover_application_id):\n    \"\"\"Returns the BaseVoiceoverApplication object for the give\n    voiceover application model object.\n\n    Args:\n        voiceover_application_id: str. The ID of the voiceover application.\n\n    Returns:\n        BaseVoiceoverApplication. The domain object out of the given voiceover\n        application model object.\n    \"\"\"\n    voiceover_application_model = (\n        suggestion_models.GeneralVoiceoverApplicationModel.get_by_id(\n            voiceover_application_id))\n    voiceover_application_class = _get_voiceover_application_class(\n        voiceover_application_model.target_type)\n    return voiceover_application_class(\n        voiceover_application_model.id,\n        voiceover_application_model.target_id,\n        voiceover_application_model.status,\n        voiceover_application_model.author_id,\n        voiceover_application_model.final_reviewer_id,\n        voiceover_application_model.language_code,\n        voiceover_application_model.filename,\n        voiceover_application_model.content,\n        voiceover_application_model.rejection_message)\n\n\ndef create_community_contribution_stats_from_model(\n        community_contribution_stats_model):\n    \"\"\"Creates a domain object that represents the community contribution\n    stats from the model given. Note that each call to this function returns\n    a new domain object, but the data copied into the domain object comes from\n    a single, shared source.\n\n    Args:\n        community_contribution_stats_model: CommunityContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.CommunityContributionStats(\n        (\n            community_contribution_stats_model\n            .translation_reviewer_counts_by_lang_code\n        ),\n        (\n            community_contribution_stats_model\n            .translation_suggestion_counts_by_lang_code\n        ),\n        community_contribution_stats_model.question_reviewer_count,\n        community_contribution_stats_model.question_suggestion_count\n    )\n\n\ndef get_community_contribution_stats():\n    \"\"\"Gets the CommunityContributionStatsModel and converts it into the\n    corresponding domain object that represents the community contribution\n    stats. Note that there is only ever one instance of this model and if the\n    model doesn't exist yet, it will be created.\n\n    Returns:\n        CommunityContributionStats. The corresponding\n        CommunityContributionStats domain object.\n    \"\"\"\n    community_contribution_stats_model = (\n        suggestion_models.CommunityContributionStatsModel.get()\n    )\n\n    return create_community_contribution_stats_from_model(\n        community_contribution_stats_model)\n\n\ndef create_translation_contribution_stats_from_model(\n        translation_contribution_stats_model):\n    \"\"\"Creates a domain object representing the supplied\n    TranslationContributionStatsModel.\n\n    Args:\n        translation_contribution_stats_model: TranslationContributionStatsModel.\n            The model to convert to a domain object.\n\n    Returns:\n        TranslationContributionStats. The corresponding\n        TranslationContributionStats domain object.\n    \"\"\"\n    return suggestion_registry.TranslationContributionStats(\n        translation_contribution_stats_model.language_code,\n        translation_contribution_stats_model.contributor_user_id,\n        translation_contribution_stats_model.topic_id,\n        translation_contribution_stats_model.submitted_translations_count,\n        translation_contribution_stats_model.submitted_translation_word_count,\n        translation_contribution_stats_model.accepted_translations_count,\n        (\n            translation_contribution_stats_model\n            .accepted_translations_without_reviewer_edits_count\n        ),\n        translation_contribution_stats_model.accepted_translation_word_count,\n        translation_contribution_stats_model.rejected_translations_count,\n        translation_contribution_stats_model.rejected_translation_word_count,\n        translation_contribution_stats_model.contribution_dates\n    )\n\n\ndef get_all_translation_contribution_stats(user_id):\n    \"\"\"Gets all TranslationContributionStatsModels corresponding to the supplied\n    user and converts them to their corresponding domain objects.\n\n    Args:\n        user_id: str. User ID.\n\n    Returns:\n        list(TranslationContributionStats). TranslationContributionStats domain\n        objects corresponding to the supplied user.\n    \"\"\"\n    translation_contribution_stats_models = (\n        suggestion_models.TranslationContributionStatsModel.get_all_by_user_id(\n            user_id\n        )\n    )\n    return [\n        create_translation_contribution_stats_from_model(model)\n        for model in translation_contribution_stats_models\n    ]\n\n\ndef get_suggestion_types_that_need_reviewers():\n    \"\"\"Uses the community contribution stats to determine which suggestion\n    types need more reviewers. Suggestion types need more reviewers if the\n    number of suggestions in that type divided by the number of reviewers is\n    greater than config_domain.MAX_NUMBER_OF_SUGGESTIONS_PER_REVIEWER.\n\n    Returns:\n        dict. A dictionary that uses the presence of its keys to indicate which\n        suggestion types need more reviewers. The possible key values are the\n        suggestion types listed in\n        feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES. The dictionary\n        values for each suggestion type are the following:\n        - for question suggestions the value is an empty set\n        - for translation suggestions the value is a nonempty set containing the\n            language codes of the translation suggestions that need more\n            reviewers.\n    \"\"\"\n    suggestion_types_needing_reviewers = {}\n    stats = get_community_contribution_stats()\n\n    language_codes_that_need_reviewers = (\n        stats.get_translation_language_codes_that_need_reviewers()\n    )\n    if len(language_codes_that_need_reviewers) != 0:\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT] = (\n                language_codes_that_need_reviewers\n            )\n\n    if stats.are_question_reviewers_needed():\n        suggestion_types_needing_reviewers[\n            feconf.SUGGESTION_TYPE_ADD_QUESTION] = {}\n\n    return suggestion_types_needing_reviewers\n\n\n@transaction_services.run_in_transaction_wrapper\ndef _update_suggestion_counts_in_community_contribution_stats_transactional(\n        suggestions, amount):\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. Note that this method should only ever be\n    called in a transaction.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    stats_model = suggestion_models.CommunityContributionStatsModel.get()\n    for suggestion in suggestions:\n        if suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT):\n            if suggestion.language_code not in (\n                    stats_model.translation_suggestion_counts_by_lang_code):\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] = amount\n            else:\n                stats_model.translation_suggestion_counts_by_lang_code[\n                    suggestion.language_code] += amount\n                # Remove the language code from the dict if the count reaches\n                # zero.\n                if stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code] == 0:\n                    del stats_model.translation_suggestion_counts_by_lang_code[\n                        suggestion.language_code]\n        elif suggestion.suggestion_type == (\n                feconf.SUGGESTION_TYPE_ADD_QUESTION):\n            stats_model.question_suggestion_count += amount\n\n    # Create a community contribution stats object to validate the updates.\n    stats = create_community_contribution_stats_from_model(stats_model)\n    stats.validate()\n\n    stats_model.update_timestamps()\n    stats_model.put()\n\n    logging.info('Updated translation_suggestion_counts_by_lang_code: %s' % (\n        stats_model.translation_suggestion_counts_by_lang_code))\n\n\ndef _update_suggestion_counts_in_community_contribution_stats(\n        suggestions, amount):\n    \"\"\"Updates the community contribution stats counts associated with the given\n    suggestions by the given amount. The GET and PUT is done in a single\n    transaction to avoid loss of updates that come in rapid succession.\n\n    Args:\n        suggestions: list(Suggestion). Suggestions that may update the counts\n            stored in the community contribution stats model. Only suggestion\n            types that are tracked in the community contribution stats model\n            trigger count updates.\n        amount: int. The amount to adjust the counts by.\n    \"\"\"\n    _update_suggestion_counts_in_community_contribution_stats_transactional(\n        suggestions, amount)\n\n\ndef update_translation_suggestion(suggestion_id, translation_html):\n    \"\"\"Updates the translation_html of a suggestion with the given\n    suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        translation_html: str. The new translation_html string.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n\n    # Clean the translation HTML if not a list of strings.\n    suggestion.change.translation_html = (\n        html_cleaner.clean(translation_html)\n        if isinstance(translation_html, str)\n        else translation_html\n    )\n    suggestion.edited_by_reviewer = True\n    suggestion.pre_update_validate(suggestion.change)\n    _update_suggestion(suggestion)\n\n\ndef update_question_suggestion(\n        suggestion_id, skill_difficulty, question_state_data):\n    \"\"\"Updates skill_difficulty and question_state_data of a suggestion with\n    the given suggestion_id.\n\n    Args:\n        suggestion_id: str. The id of the suggestion to be updated.\n        skill_difficulty: double. The difficulty level of the question.\n        question_state_data: obj. Details of the question.\n\n    Returns:\n        Suggestion|None. The corresponding suggestion, or None if no suggestion\n        is found.\n    \"\"\"\n    suggestion = get_suggestion_by_id(suggestion_id)\n    new_change_obj = question_domain.QuestionSuggestionChange(\n        {\n            'cmd': suggestion.change.cmd,\n            'question_dict': {\n                'question_state_data': question_state_data,\n                'language_code': suggestion.change.question_dict[\n                    'language_code'],\n                'question_state_data_schema_version': (\n                    suggestion.change.question_dict[\n                        'question_state_data_schema_version']),\n                'linked_skill_ids': suggestion.change.question_dict[\n                    'linked_skill_ids'],\n                'inapplicable_skill_misconception_ids': (\n                    suggestion.change.question_dict[\n                        'inapplicable_skill_misconception_ids'])\n            },\n            'skill_id': suggestion.change.skill_id,\n            'skill_difficulty': skill_difficulty\n        })\n    suggestion.pre_update_validate(new_change_obj)\n    suggestion.edited_by_reviewer = True\n    suggestion.change = new_change_obj\n\n    _update_suggestion(suggestion)\n\n    return suggestion\n"
    },
    {
      "filename": "core/domain/suggestion_services_test.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for suggestion related services.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core import utils\nfrom core.constants import constants\nfrom core.domain import exp_domain\nfrom core.domain import exp_fetchers\nfrom core.domain import exp_services\nfrom core.domain import feedback_services\nfrom core.domain import question_domain\nfrom core.domain import rights_domain\nfrom core.domain import rights_manager\nfrom core.domain import skill_services\nfrom core.domain import state_domain\nfrom core.domain import story_domain\nfrom core.domain import story_services\nfrom core.domain import suggestion_registry\nfrom core.domain import suggestion_services\nfrom core.domain import topic_services\nfrom core.domain import user_services\nfrom core.platform import models\nfrom core.tests import test_utils\n\n(suggestion_models, feedback_models, user_models) = (\n    models.Registry.import_models(\n        [models.NAMES.suggestion, models.NAMES.feedback, models.NAMES.user]\n    )\n)\n\n\nclass SuggestionServicesUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functions in suggestion_services.\"\"\"\n\n    score_category = (\n        suggestion_models.SCORE_TYPE_CONTENT +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'Algebra')\n\n    target_id = 'exp1'\n    target_id_2 = 'exp2'\n    target_id_3 = 'exp3'\n    target_version_at_submission = 1\n    change = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': {\n            'content_id': 'content',\n            'html': 'new suggestion content'\n        }\n    }\n\n    AUTHOR_EMAIL = 'author@example.com'\n    REVIEWER_EMAIL = 'reviewer@example.com'\n    NORMAL_USER_EMAIL = 'normal@example.com'\n\n    THREAD_ID = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE = 'commit message'\n    EMPTY_COMMIT_MESSAGE = ' '\n\n    suggestion_id = THREAD_ID\n    suggestion_id_2 = 'exploration.exp2.thread_2'\n    suggestion_id_3 = 'exploration.exp3.thread_3'\n\n    def setUp(self):\n        super(SuggestionServicesUnitTests, self).setUp()\n\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(self.REVIEWER_EMAIL)\n        self.signup(self.NORMAL_USER_EMAIL, 'normaluser')\n        self.normal_user_id = self.get_user_id_from_email(\n            self.NORMAL_USER_EMAIL)\n        self.save_new_valid_exploration(\n            self.target_id, self.author_id, category='Algebra')\n\n    def assert_suggestion_status(self, suggestion_id, status):\n        \"\"\"Assert the status of the suggestion with suggestion_id.\"\"\"\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, status)\n\n    def mock_accept_suggestion(\n            self, suggestion_id, reviewer_id, commit_message, review_message):\n        \"\"\"Sets up the appropriate mocks to successfully call\n        accept_suggestion.\n        \"\"\"\n        with self.swap(\n            exp_services, 'update_exploration', self.mock_update_exploration):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                with self.swap(\n                    suggestion_registry.SuggestionEditStateContent,\n                    'pre_accept_validate',\n                    self.mock_pre_accept_validate_does_nothing):\n                    with self.swap(\n                        suggestion_registry.SuggestionEditStateContent,\n                        'get_change_list_for_accepting_suggestion',\n                        self.mock_get_change_list_does_nothing):\n                        suggestion_services.accept_suggestion(\n                            suggestion_id, reviewer_id,\n                            commit_message, review_message)\n\n    def mock_create_suggestion(self, target_id):\n        \"\"\"Sets up the appropriate mocks to successfully call\n        create_suggestion.\n        \"\"\"\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    target_id, self.target_version_at_submission,\n                    self.author_id, self.change, 'test description')\n\n    def mock_generate_new_thread_id(self, entity_type, exp_id):\n        thread_id = 'thread_%s' % exp_id[-1]\n        return '.'.join([entity_type, exp_id, thread_id])\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(self, exploration_id, states):\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}})\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id):\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                return exp\n\n    def mock_pre_accept_validate_does_nothing(self):\n        pass\n\n    def mock_get_change_list_does_nothing(self):\n        pass\n\n    def mock_accept_does_nothing(self, unused_arg):\n        pass\n\n    def edit_before_pre_accept_validate(self, suggestion):\n        \"\"\"Edits suggestion immediately before pre-accept validation.\"\"\"\n        suggestion.score_category = 'invalid_score_category'\n        suggestion.pre_accept_validate()\n\n    def test_create_new_suggestion_successfully(self):\n        expected_suggestion_dict = {\n            'suggestion_id': 'exploration.exp1.thread_1',\n            'suggestion_type': (\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT),\n            'target_type': feconf.ENTITY_TYPE_EXPLORATION,\n            'target_id': self.target_id,\n            'target_version_at_submission': self.target_version_at_submission,\n            'status': suggestion_models.STATUS_IN_REVIEW,\n            'author_name': 'author',\n            'change': {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': {\n                    'content_id': 'content',\n                    'html': 'new suggestion content'\n                },\n                'old_value': None\n            },\n            'score_category': self.score_category,\n            'language_code': None\n        }\n        self.mock_create_suggestion(self.target_id)\n\n        observed_suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertDictContainsSubset(\n            expected_suggestion_dict, observed_suggestion.to_dict())\n\n    def test_cannot_create_suggestion_with_invalid_suggestion_type(self):\n        with self.assertRaisesRegex(Exception, 'Invalid suggestion type'):\n            suggestion_services.create_suggestion(\n                'invalid_suggestion_type',\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n    def test_cannot_create_suggestion_with_invalid_author_id(self):\n        with self.assertRaisesRegex(\n            Exception, 'Expected author_id to be in a valid user ID format'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                'invalid author ID', self.change, 'test description')\n\n    def test_cannot_create_translation_suggestion_with_invalid_content_html_raise_error(self): # pylint: disable=line-too-long\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'Introduction',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>The invalid content html</p>',\n            'translation_html': '<p>Translation for invalid content.</p>',\n            'data_format': 'html'\n        }\n        with self.assertRaisesRegex(\n            Exception,\n            'The Exploration content has changed since this translation '\n            'was submitted.'):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                self.author_id, add_translation_change_dict, 'test description')\n\n    def test_get_submitted_submissions(self):\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, None)\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test_description')\n        suggestions = suggestion_services.get_submitted_suggestions(\n            self.author_id, feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].author_id, self.author_id)\n        self.assertEqual(suggestions[1].author_id, self.author_id)\n\n    def test_get_all_stale_suggestion_ids(self):\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test description')\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS', 0):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 1)\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS',\n            7 * 24 * 60 * 60 * 1000):\n            self.assertEqual(\n                len(suggestion_services.get_all_stale_suggestion_ids()), 0)\n\n    def mock_update_exploration(\n            self, unused_user_id, unused_exploration_id, unused_change_list,\n            commit_message, is_suggestion):\n        self.assertTrue(is_suggestion)\n        self.assertEqual(\n            commit_message, 'Accepted suggestion by %s: %s' % (\n                'author', self.COMMIT_MESSAGE))\n\n    def test_cannot_reject_suggestion_with_empty_review_message(self):\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, self.change, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Review message cannot be empty.'):\n            suggestion_services.reject_suggestion(\n                suggestion.suggestion_id, self.reviewer_id, '')\n\n        # Assert that the suggestion was not rejected.\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_accept_suggestion_and_send_email_to_author(self):\n        change_list = [exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_ADD_STATE,\n            'state_name': 'state 1',\n        })]\n        exp_services.update_exploration(\n            self.author_id, self.target_id, change_list, 'Add state.')\n\n        new_suggestion_content = state_domain.SubtitledHtml(\n            'content', '<p>new suggestion content html</p>').to_dict()\n        change_dict = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state 1',\n            'new_value': new_suggestion_content\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            self.author_id, change_dict, 'test description')\n\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create a user proficiency model to verify that the\n        # score and onboarding_email_sent fields have changed after the\n        # suggestion has been accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, suggestion.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. Therefore,\n        # by setting that increment to minimum score required to review, we can\n        # ensure that the email is sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                with self.swap(\n                    suggestion_models, 'INCREMENT_SCORE_OF_AUTHOR_BY',\n                    feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW):\n                    suggestion_services.accept_suggestion(\n                        suggestion.suggestion_id, self.reviewer_id,\n                        self.COMMIT_MESSAGE, 'review message')\n\n        # Assert that the suggestion is now accepted.\n        suggestion = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), (\n                'target_id', self.target_id)])[0]\n        self.assert_suggestion_status(\n            suggestion.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        # Assert that the email was sent and that the score increased by the\n        # correct amount.\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, suggestion.score_category\n            )\n        )\n        self.assertTrue(user_proficiency_model.onboarding_email_sent)\n        self.assertEqual(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n\n    def test_accept_suggestion_does_not_send_email_if_users_score_is_too_low(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # Create the user proficiency model to verify the score and\n        # that the onboarding_email_sent field does not change after the\n        # suggestion is accepted.\n        user_models.UserContributionProficiencyModel.create(\n            self.author_id, self.score_category, 0)\n\n        # An email is sent to users the first time that they pass the score\n        # required to review a suggestion category. By default, when a\n        # suggestion is accepted and the recording of scores is enabled, the\n        # score of the author of that suggestion is increased by 1. This is\n        # less than the minimum score required to review so an email should not\n        # be sent.\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            with self.swap(\n                feconf, 'SEND_SUGGESTION_REVIEW_RELATED_EMAILS', True):\n                self.mock_accept_suggestion(\n                    self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                    'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        user_proficiency_model = (\n            user_models.UserContributionProficiencyModel.get(\n                self.author_id, self.score_category\n            )\n        )\n        # Assert that the users score was updated correctly.\n        self.assertEqual(\n            user_proficiency_model.score,\n            suggestion_models.INCREMENT_SCORE_OF_AUTHOR_BY)\n        # Assert that their score is not high enough to review the category.\n        self.assertLess(\n            user_proficiency_model.score,\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        # Assert that the onboarding new reviewer email was not sent.\n        self.assertFalse(user_proficiency_model.onboarding_email_sent)\n\n    def test_accept_suggestion_creates_user_proficiency_model_if_it_is_none(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        # Verify that a user proficiency model does not exist.\n        self.assertIsNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n        with self.swap(feconf, 'ENABLE_RECORDING_OF_SCORES', True):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Verify that a user proficiency model now exists.\n        self.assertIsNotNone(user_models.UserContributionProficiencyModel.get(\n            self.author_id, self.score_category))\n\n    def test_accept_suggestion_successfully(self):\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n\n        # Assert that the suggestion is now accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'review message')\n\n    def test_accept_suggestion_raises_exception_if_suggestion_does_not_exist(\n            self):\n        expected_exception_regexp = (\n            'You cannot accept the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n    def test_accept_suggestion_with_invalid_math_fails(self):\n        \"\"\"Test that the method for accepting suggestions raises error when\n        a suggestion with invalid math-tags is tried to be accepted.\n        \"\"\"\n        change_dict = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'state_1',\n            'new_value': {\n                'content_id': 'content',\n                'html': (\n                    '<oppia-noninteractive-math raw_latex-with-value=\"&am'\n                    'p;quot;(x - a_1)(x - a_2)(x - a_3)...(x - a_n)&amp;q'\n                    'uot;\"></oppia-noninteractive-math>')\n            }\n        }\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            with self.swap(\n                exp_fetchers, 'get_exploration_by_id',\n                self.mock_get_exploration_by_id):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id, self.target_version_at_submission,\n                    self.author_id, change_dict, 'test description')\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        expected_exception_regexp = (\n            'Invalid math tags found in the suggestion with id %s.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            self.mock_accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n                'review message')\n\n        # Assert that the status of the suggestion hasn't changed.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_accepted(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, None)\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, None)\n\n    def test_accept_suggestion_raises_exception_if_suggestion_already_rejected(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message'\n        )\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, None)\n\n        # Assert that the suggestion is still rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n    def test_accept_suggestion_invalid_suggestion_failure(self):\n        self.mock_create_suggestion(self.target_id)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n\n        with self.assertRaisesRegex(\n            utils.ValidationError, 'Expected score_category to be of the form '\n                                   'score_type.score_sub_type, received '\n                                   'invalid_score_category'):\n            with self.swap(\n                suggestion_registry.SuggestionEditStateContent,\n                'pre_accept_validate',\n                self.edit_before_pre_accept_validate(suggestion)):\n                suggestion_services.accept_suggestion(\n                    self.suggestion_id, self.reviewer_id,\n                    self.COMMIT_MESSAGE, None)\n\n    def test_accept_suggestion_no_commit_message_failure(self):\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        with self.assertRaisesRegex(\n            Exception, 'Commit message cannot be empty.'):\n            suggestion_services.accept_suggestion(\n                self.suggestion_id, self.reviewer_id,\n                self.EMPTY_COMMIT_MESSAGE, None)\n\n        # Assert that the status of the suggestion didn't change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_reject_suggestion_successfully(self):\n        self.mock_create_suggestion(self.target_id)\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.final_reviewer_id, self.reviewer_id)\n\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(last_message.text, 'reject review message')\n\n    def test_reject_suggestions_successfully(self):\n        # Create the first suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_2)\n        self.assert_suggestion_status(\n            self.suggestion_id_2, suggestion_models.STATUS_IN_REVIEW)\n        # Create another suggestion to be rejected.\n        self.mock_create_suggestion(self.target_id_3)\n        self.assert_suggestion_status(\n            self.suggestion_id_3, suggestion_models.STATUS_IN_REVIEW)\n        suggestion_ids = [self.suggestion_id_2, self.suggestion_id_3]\n\n        suggestion_services.reject_suggestions(\n            suggestion_ids, self.reviewer_id, 'reject review message')\n\n        for suggestion_id in suggestion_ids:\n            # Assert that the statuses changed to rejected.\n            self.assert_suggestion_status(\n                suggestion_id, suggestion_models.STATUS_REJECTED)\n            # Assert that the final reviewer id was updated.\n            suggestion = suggestion_services.get_suggestion_by_id(\n                suggestion_id)\n            self.assertEqual(\n                suggestion.final_reviewer_id, self.reviewer_id)\n            # Assert that the messages were updated.\n            thread_messages = feedback_services.get_messages(suggestion_id)\n            last_message = thread_messages[len(thread_messages) - 1]\n            self.assertEqual(\n                last_message.text, 'reject review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_does_not_exist(\n            self):\n        expected_exception_regexp = (\n            'You cannot reject the suggestion with id %s because it does not '\n            'exist.' % (self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'review message')\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_accepted(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, None)\n        # Assert that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n        # Assert that the suggestion's status did not change.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_reject_suggestion_raises_exception_if_suggestion_already_rejected(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n\n        # Rejecting the suggestion should not work because the suggestion has\n        # already been rejected.\n        expected_exception_regexp = (\n            'The suggestion with id %s has already been accepted/rejected.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.reject_suggestion(\n                self.suggestion_id, self.reviewer_id, 'reject review message')\n\n    def test_resubmit_rejected_suggestion_success(self):\n        self.mock_create_suggestion(self.target_id)\n        # Reject the suggestion.\n        suggestion_services.reject_suggestion(\n            self.suggestion_id, self.reviewer_id, 'reject review message')\n        # Assert that the suggestion has been rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_REJECTED)\n        # Create the new change for the resubmitted suggestion.\n        resubmit_change_content = state_domain.SubtitledHtml(\n            'content', '<p>resubmit change content html</p>').to_dict()\n        resubmit_change = exp_domain.ExplorationChange(\n            {\n                'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n                'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n                'state_name': 'state_1',\n                'new_value': resubmit_change_content,\n                'old_value': self.change['new_value']\n            }\n        )\n\n        # Resubmit rejected suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            self.suggestion_id, 'resubmit summary message', self.author_id,\n            resubmit_change)\n\n        # The suggestion's status should now be in review instead of rejected.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_IN_REVIEW)\n        # The suggestion's change should be updated.\n        suggestion = suggestion_services.get_suggestion_by_id(\n            self.suggestion_id)\n        self.assertEqual(\n            suggestion.change.new_value['html'],\n            resubmit_change_content['html'])\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_empty_message(\n            self):\n        self.mock_create_suggestion(self.target_id)\n\n        # Can't resubmit a rejected suggestion if the summary message is empty.\n        with self.assertRaisesRegex(\n            Exception, 'Summary message cannot be empty.'):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, '', self.author_id, {})\n\n    def test_resubmit_rejected_suggestion_raises_exception_for_unhandled_input(\n            self):\n        self.mock_create_suggestion(self.target_id)\n\n        # Can't resubmit a rejected suggestion if the suggestion hasn't been\n        # rejected yet.\n        expected_exception_regexp = (\n            'The suggestion with id %s is not yet handled.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, {}\n            )\n\n    def test_resubmit_rejected_suggestion_raises_excep_for_accepted_suggestion(\n            self):\n        self.mock_create_suggestion(self.target_id)\n        # Accept the suggestion.\n        self.mock_accept_suggestion(\n            self.suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'review message')\n        # Verfiy that the suggestion has been accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n        # Can't resubmit the suggestion if it's already accepted.\n        expected_exception_regexp = (\n            'The suggestion with id %s was accepted. Only rejected '\n            'suggestions can be resubmitted.' % (\n                self.suggestion_id)\n        )\n        with self.assertRaisesRegex(\n            Exception, expected_exception_regexp):\n            suggestion_services.resubmit_rejected_suggestion(\n                self.suggestion_id, 'resubmit summary message',\n                self.author_id, {}\n            )\n\n        # Verfiy that the suggestion is still accepted.\n        self.assert_suggestion_status(\n            self.suggestion_id, suggestion_models.STATUS_ACCEPTED)\n\n    def test_check_can_resubmit_suggestion(self):\n        self.mock_create_suggestion(self.target_id)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.author_id)\n        self.assertEqual(can_resubmit, True)\n        can_resubmit = suggestion_services.check_can_resubmit_suggestion(\n            self.suggestion_id, self.normal_user_id)\n        self.assertEqual(can_resubmit, False)\n\n    def test_update_translation_suggestion_to_change_translation_html(self):\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        exp_services._save_exploration(self.author_id, exploration, '', [])  # pylint: disable=protected-access\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, '<p>Updated translation</p>'\n        )\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change.translation_html,\n            '<p>Updated translation</p>')\n\n    def test_update_question_suggestion_to_change_question_state(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        new_solution_dict = {\n            'answer_is_exclusive': False,\n            'correct_answer': 'Solution',\n            'explanation': {\n                'content_id': 'solution',\n                'html': '<p>This is the updated solution.</p>',\n            },\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n\n        question_state_data = suggestion_change['question_dict'][\n            'question_state_data']\n        question_state_data['content'][\n            'html'] = '<p>Updated question</p>'\n        question_state_data['interaction'][\n            'solution'] = new_solution_dict\n\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            suggestion.change.skill_difficulty,\n            question_state_data)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n        new_question_state_data = updated_suggestion.change.question_dict[\n            'question_state_data']\n\n        self.assertEqual(\n            new_question_state_data['content'][\n                'html'],\n            '<p>Updated question</p>')\n        self.assertEqual(\n            new_question_state_data['interaction'][\n                'solution'],\n            new_solution_dict)\n\n    def test_update_question_suggestion_to_change_skill_difficulty(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(\n            skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        question_state_data = suggestion.change.question_dict[\n            'question_state_data']\n\n        suggestion_services.update_question_suggestion(\n            suggestion.suggestion_id,\n            0.6,\n            question_state_data)\n        updated_suggestion = suggestion_services.get_suggestion_by_id(\n            suggestion.suggestion_id)\n\n        self.assertEqual(\n            updated_suggestion.change.skill_difficulty,\n            0.6)\n\n    def test_accept_suggestion_commit_message_after_updating_a_suggestion(self):\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                'exploration1', self.author_id, ['state 1'], ['TextInput'],\n                category='Algebra'))\n        old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content html</p>').to_dict()\n        exploration.states['state 1'].update_content(\n            state_domain.SubtitledHtml.from_dict(old_content))\n        exp_services._save_exploration(self.author_id, exploration, '', [])  # pylint: disable=protected-access\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': '<p>old content html</p>',\n            'translation_html': '<p>Translation for original content.</p>',\n            'data_format': 'html'\n        }\n        suggestion = suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exploration1', self.target_version_at_submission,\n            self.author_id, add_translation_change_dict, 'test description')\n\n        suggestion_services.update_translation_suggestion(\n            suggestion.suggestion_id, '<p>Updated translation</p>'\n        )\n\n        suggestion_services.accept_suggestion(\n            suggestion.suggestion_id, self.reviewer_id, 'Accepted', 'Done'\n        )\n        snapshots_metadata = exp_services.get_exploration_snapshots_metadata(\n            'exploration1')\n\n        self.assertEqual(\n            snapshots_metadata[2]['commit_message'],\n            'Accepted suggestion by author: Accepted (with edits)')\n\n\nclass SuggestionGetServicesUnitTests(test_utils.GenericTestBase):\n    score_category = (\n        suggestion_models.SCORE_TYPE_TRANSLATION +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n\n    target_id_1 = 'exp1'\n    target_id_2 = 'exp2'\n    target_id_3 = 'exp3'\n    target_version_at_submission = 1\n    change = {\n        'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n        'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n        'state_name': 'state_1',\n        'new_value': 'new suggestion content'\n    }\n\n    AUTHOR_EMAIL_1 = 'author1@example.com'\n    REVIEWER_EMAIL_1 = 'reviewer1@example.com'\n\n    AUTHOR_EMAIL_2 = 'author2@example.com'\n    REVIEWER_EMAIL_2 = 'reviewer2@example.com'\n\n    add_translation_change_dict = {\n        'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n        'state_name': 'state_1',\n        'content_id': 'content',\n        'language_code': 'hi',\n        'content_html': '<p>State name: state_1, Content id: content</p>',\n        'translation_html': '<p>This is translated html.</p>',\n        'data_format': 'html'\n    }\n\n    class MockExploration:\n        \"\"\"Mocks an exploration. To be used only for testing.\"\"\"\n\n        def __init__(self, exploration_id, states):\n            self.id = exploration_id\n            self.states = states\n            self.category = 'Algebra'\n\n        def get_content_html(self, state_name, content_id):\n            \"\"\"Used to mock the get_content_html method for explorations.\"\"\"\n            # state_name and content_id are used here to suppress the unused\n            # arguments warning. The main goal of this method is to just\n            # produce content html for the tests.\n            return '<p>State name: %s, Content id: %s</p>' % (\n                state_name, content_id\n            )\n\n    # All mock explorations created for testing.\n    explorations = [\n        MockExploration('exp1', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp2', {'state_1': {}, 'state_2': {}}),\n        MockExploration('exp3', {'state_1': {}, 'state_2': {}}),\n    ]\n\n    def mock_get_exploration_by_id(self, exp_id):\n        for exp in self.explorations:\n            if exp.id == exp_id:\n                return exp\n\n    def _create_question_suggestion_with_skill_id(self, skill_id):\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        suggestion_change = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id_1, suggestion_change, 'test description'\n        )\n\n    def _create_translation_suggestion_with_language_code(self, language_code):\n        \"\"\"Creates a translation suggestion with the language code given.\"\"\"\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'state_1',\n            'content_id': 'content',\n            'language_code': language_code,\n            'content_html': (\n                '<p>State name: state_1, Content id: content</p>'),\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html\n            ):\n                translation_suggestion = suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_1, 1, self.author_id_1,\n                    add_translation_change_dict, 'test description')\n\n        return translation_suggestion\n\n    def setUp(self):\n        super(SuggestionGetServicesUnitTests, self).setUp()\n\n        self.signup(self.AUTHOR_EMAIL_1, 'author1')\n        self.author_id_1 = self.get_user_id_from_email(self.AUTHOR_EMAIL_1)\n        self.signup(self.REVIEWER_EMAIL_1, 'reviewer1')\n        self.reviewer_id_1 = self.get_user_id_from_email(self.REVIEWER_EMAIL_1)\n\n        self.signup(self.AUTHOR_EMAIL_2, 'author2')\n        self.author_id_2 = self.get_user_id_from_email(self.AUTHOR_EMAIL_2)\n        self.signup(self.REVIEWER_EMAIL_2, 'reviewer2')\n        self.reviewer_id_2 = self.get_user_id_from_email(self.REVIEWER_EMAIL_2)\n        self.opportunity_summary_ids = [\n            self.explorations[0].id, self.explorations[1].id,\n            self.explorations[2].id]\n        self.topic_name = 'topic'\n\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_1, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_1, self.target_version_at_submission,\n                self.author_id_2, self.change, 'test description')\n\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id_2, self.target_version_at_submission,\n                self.author_id_2, self.change, 'test description')\n\n    def test_get_by_author(self):\n        queries = [('author_id', self.author_id_1)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n        queries = [('author_id', self.author_id_2)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 2)\n\n    def test_get_translation_suggestions_in_review_by_exp_ids(self):\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [\n                    self.target_id_1,\n                    self.target_id_2,\n                    self.target_id_3\n                ],\n                'en'\n            )\n        )\n        self.assertEqual(len(suggestions), 0)\n        self._create_translation_suggestion_with_language_code('en')\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exp_ids(\n                [self.target_id_1],\n                'en'\n            )\n        )\n        self.assertEqual(suggestions[0].author_id, self.author_id_1)\n        self.assertEqual(suggestions[0].language_code, 'en')\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n\n    def test_get_by_target_id(self):\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 4)\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n    def test_get_by_status(self):\n        queries = [('status', suggestion_models.STATUS_IN_REVIEW)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_get_by_type(self):\n        queries = [(\n            'suggestion_type',\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 5)\n\n    def test_query_suggestions(self):\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_2)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 1)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('author_id', self.author_id_1),\n            ('status', suggestion_models.STATUS_IN_REVIEW)\n        ]\n        self.assertEqual(len(suggestion_services.query_suggestions(queries)), 3)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id_1),\n            ('invalid_field', 'value')\n        ]\n        with self.assertRaisesRegex(\n            Exception, 'Not allowed to query on field invalid_field'):\n            suggestion_services.query_suggestions(queries)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_one_exp(self):\n        # Create the translation suggestion associated with exploration id\n        # target_id_1.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_1, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there is one translation suggestion with the given\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_1])), 1)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_multiple_exps(\n            self):\n        # Create the translation suggestion associated with exploration id\n        # target_id_2.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_2, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n        # Create the translation suggestion associated with exploration id\n        # target_id_3.\n        with self.swap(\n            exp_fetchers, 'get_exploration_by_id',\n            self.mock_get_exploration_by_id):\n            with self.swap(\n                exp_domain.Exploration, 'get_content_html',\n                self.MockExploration.get_content_html):\n                suggestion_services.create_suggestion(\n                    feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                    feconf.ENTITY_TYPE_EXPLORATION,\n                    self.target_id_3, 1, self.author_id_1,\n                    self.add_translation_change_dict, 'test description')\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    [self.target_id_2, self.target_id_3])), 2)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_invalid_exp(\n            self):\n        # Assert that there are no translation suggestions with an invalid\n        # exploration id found.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids(\n                    ['invalid_exp_id'])), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_empty_exp_list(\n            self):\n        # Assert that there are no translation suggestions found when we\n        # use an empty exp_ids list.\n        self.assertEqual(\n            len(\n                suggestion_services\n                .get_translation_suggestion_ids_with_exp_ids([])), 0)\n\n    def test_get_submitted_suggestions_by_offset(self):\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        question_1_skill_id = 'skill1'\n        question_2_skill_id = 'skill2'\n        self._create_question_suggestion_with_skill_id(question_1_skill_id)\n        self._create_question_suggestion_with_skill_id(question_2_skill_id)\n\n        # Fetch submitted translation suggestions.\n        suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n        # Fetch submitted question suggestions.\n        suggestions, offset = (\n            suggestion_services.get_submitted_suggestions_by_offset(\n                user_id=self.author_id_1,\n                suggestion_type=feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(offset, 2)\n        self.assertEqual(suggestions[0].target_id, question_2_skill_id)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, question_1_skill_id)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_ADD_QUESTION)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration(self):\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'hi'))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, self.target_id_1)\n        self.assertEqual(\n            suggestions[1].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[1].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_translation_suggestions_in_review_by_exploration_returns_only_suggestions_with_supplied_language_code(self): # pylint: disable=line-too-long\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_in_review_by_exploration(\n                self.target_id_1, 'pt'))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_reviewable_translation_suggestions_with_valid_exp_ids(\n            self):\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, self.opportunity_summary_ids,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0))\n\n        # Expect that the results correspond to translation suggestions that the\n        # user has rights to review.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_translation_suggestions_with_empty_exp_ids( # pylint: disable=line-too-long\n            self):\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = suggestion_services.get_reviewable_translation_suggestions_by_offset(\n            self.reviewer_id_1, [],\n            constants.OPPORTUNITIES_PAGE_SIZE, 0)\n\n        self.assertEqual(offset, 0)\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_reviewable_translation_suggestions_with_none_exp_ids(\n            self):\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n\n        # Get all reviewable translation suggestions.\n        suggestions, offset = (\n            suggestion_services.\n            get_reviewable_translation_suggestions_by_offset(\n                self.reviewer_id_1, None,\n                constants.OPPORTUNITIES_PAGE_SIZE, 0))\n\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(offset, 3)\n        actual_language_code_list = [\n            suggestion.change.language_code\n            for suggestion in suggestions\n        ]\n        expected_language_code_list = ['hi', 'hi', 'pt']\n        self.assertEqual(actual_language_code_list, expected_language_code_list)\n\n    def test_get_reviewable_question_suggestions(self):\n        # Add a few translation suggestions in different languages.\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('pt')\n        self._create_translation_suggestion_with_language_code('bn')\n        self._create_translation_suggestion_with_language_code('bn')\n        # Add a few question suggestions.\n        self._create_question_suggestion_with_skill_id('skill1')\n        self._create_question_suggestion_with_skill_id('skill2')\n        # Provide the user permission to review suggestions in particular\n        # languages.\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id_1, 'pt')\n        # Provide the user permission to review question suggestions.\n        user_services.allow_user_to_review_question(self.reviewer_id_1)\n\n        # Get all reviewable question suggestions.\n        suggestions, offset = (\n            suggestion_services.get_reviewable_question_suggestions_by_offset(\n                self.reviewer_id_1,\n                limit=constants.OPPORTUNITIES_PAGE_SIZE,\n                offset=0))\n\n        # Expect that the results correspond to question suggestions.\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(offset, 2)\n        expected_suggestion_type_list = ['skill1', 'skill2']\n        actual_suggestion_type_list = [\n            suggestion.change.skill_id\n            for suggestion in suggestions\n        ]\n        self.assertEqual(\n            actual_suggestion_type_list, expected_suggestion_type_list)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_per_lang(\n            self):\n        suggestion_1 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_2 = self._create_translation_suggestion_with_language_code(\n            'hi')\n        suggestion_3 = self._create_translation_suggestion_with_language_code(\n            'hi')\n\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'hi'))\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_wrong_lang(\n            self):\n        suggestions = (\n            suggestion_services\n            .get_translation_suggestions_waiting_longest_for_review(\n                'wrong_language_code'))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_question_suggestions_waiting_longest_for_review_keeps_order(\n            self):\n        \"\"\"This test makes sure that if a suggestion is rejected and is then\n        resubmitted, we count the time that the suggestion has been waiting for\n        review from when it was resubmitted, not from when it was first\n        submitted.\n        \"\"\"\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        # Verify that both suggestions are returned and in the right order.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n        # Reject the suggestion that was created first since it is the one that\n        # has been waiting the longest for review.\n        suggestion_services.reject_suggestion(\n            suggestion_1.suggestion_id, self.reviewer_id_1, 'Reject message')\n\n        # Verify that only the suggestion that was created second is returned.\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = suggestion_1.change\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            suggestion_1.suggestion_id, 'resubmit summary message',\n            self.author_id_1, resubmit_question_change\n        )\n\n        # Verify that both suggestions are returned again and the suggestion\n        # that was created second is now the first suggestion in the returned\n        # list, since it has been waiting longer (due to it not being updated).\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_1.suggestion_id)\n        self.assertLessEqual(\n            suggestions[0].last_updated, suggestions[1].last_updated)\n\n    def test_get_question_suggestions_waiting_longest_for_review(self):\n        suggestion_1 = self._create_question_suggestion_with_skill_id('skill1')\n        suggestion_2 = self._create_question_suggestion_with_skill_id('skill2')\n        suggestion_3 = self._create_question_suggestion_with_skill_id('skill3')\n\n        suggestions = (\n            suggestion_services\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n\n        # Assert that the suggestions are in the order that they were created.\n        self.assertEqual(len(suggestions), 3)\n        self.assertEqual(\n            suggestions[0].suggestion_id, suggestion_1.suggestion_id)\n        self.assertEqual(\n            suggestions[1].suggestion_id, suggestion_2.suggestion_id)\n        self.assertEqual(\n            suggestions[2].suggestion_id, suggestion_3.suggestion_id)\n        for i in range(len(suggestions) - 1):\n            self.assertLessEqual(\n                suggestions[i].last_updated, suggestions[i + 1].last_updated)\n\n    def test_query_suggestions_that_can_be_reviewed_by_user(self):\n        # User proficiency models for user1.\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category1', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category2', 15)\n        user_models.UserContributionProficiencyModel.create(\n            'user1', 'category3', 5)\n        # User proficiency models for user2.\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category1', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category2', 5)\n        user_models.UserContributionProficiencyModel.create(\n            'user2', 'category3', 5)\n\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', 1, suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category1',\n            'exploration.exp1.thread_1', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category2',\n            'exploration.exp1.thread_2', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category3',\n            'exploration.exp1.thread_3', None)\n        # This suggestion does not count as a suggestion that can be reviewed\n        # by a user because it has already been rejected.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change, 'category1',\n            'exploration.exp1.thread_4', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION, 'exp1', 1,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change, 'category2',\n            'exploration.exp1.thread_5', None)\n\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user1')), 3)\n        self.assertEqual(len(\n            suggestion_services\n            .get_all_suggestions_that_can_be_reviewed_by_user('user2')), 0)\n\n\nclass SuggestionIntegrationTests(test_utils.GenericTestBase):\n\n    EXP_ID = 'exp1'\n    TOPIC_ID = 'topic1'\n    STORY_ID = 'story1'\n    TRANSLATION_LANGUAGE_CODE = 'en'\n\n    AUTHOR_EMAIL = 'author@example.com'\n\n    score_category = (\n        suggestion_models.SCORE_TYPE_CONTENT +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'Algebra')\n\n    THREAD_ID = 'exploration.exp1.thread_1'\n\n    COMMIT_MESSAGE = 'commit message'\n\n    def mock_generate_new_thread_id(self, unused_entity_type, unused_entity_id):\n        return self.THREAD_ID\n\n    def setUp(self):\n        super(SuggestionIntegrationTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.signup(self.EDITOR_EMAIL, self.EDITOR_USERNAME)\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.editor_id = self.get_user_id_from_email(self.EDITOR_EMAIL)\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.reviewer_id = self.editor_id\n\n        self.editor = user_services.get_user_actions_info(self.editor_id)\n\n        # Login and create exploration and suggestions.\n        self.login(self.EDITOR_EMAIL)\n\n        # Create exploration.\n        exploration = (\n            self.save_new_linear_exp_with_state_names_and_interactions(\n                self.EXP_ID, self.editor_id, ['State 1', 'State 2'],\n                ['TextInput'], category='Algebra',\n                correctness_feedback_enabled=True))\n\n        self.old_content = state_domain.SubtitledHtml(\n            'content', '<p>old content</p>').to_dict()\n        recorded_voiceovers_dict = {\n            'voiceovers_mapping': {\n                'content': {\n                    self.TRANSLATION_LANGUAGE_CODE: {\n                        'filename': 'filename3.mp3',\n                        'file_size_bytes': 3000,\n                        'needs_update': False,\n                        'duration_secs': 42.43\n                    }\n                },\n                'default_outcome': {},\n                'ca_placeholder_0': {}\n            }\n        }\n        self.old_recorded_voiceovers = (\n            state_domain.RecordedVoiceovers.from_dict(recorded_voiceovers_dict))\n        # Create content in State A with a single audio subtitle.\n        content_change = exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.old_content,\n        })\n        recorded_voiceovers_change = exp_domain.ExplorationChange({\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_RECORDED_VOICEOVERS,\n            'state_name': 'State 1',\n            'new_value': recorded_voiceovers_dict,\n        })\n        exp_services.update_exploration(\n            self.editor_id, exploration.id,\n            [content_change, recorded_voiceovers_change], '')\n\n        rights_manager.publish_exploration(self.editor, self.EXP_ID)\n        rights_manager.assign_role_for_exploration(\n            self.editor, self.EXP_ID, self.owner_id,\n            rights_domain.ROLE_EDITOR)\n\n        self.new_content = state_domain.SubtitledHtml(\n            'content', '<p>new content</p>').to_dict()\n\n        self.change = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'State 1',\n            'new_value': self.new_content\n        }\n\n        self.target_version_at_submission = exploration.version\n\n        # Set up for testing translation suggestions. Translation suggestions\n        # correspond to a given topic, story and exploration.\n\n        self.save_new_topic(self.TOPIC_ID, self.owner_id)\n\n        self.save_new_story(\n            self.STORY_ID, self.owner_id, self.TOPIC_ID, title='A story',\n            description='Description', notes='Notes')\n\n        # Adds the story to the topic.\n        topic_services.add_canonical_story(\n            self.owner_id, self.TOPIC_ID, self.STORY_ID)\n\n        # Adds the exploration to the story.\n        story_change_list_to_add_an_exp = [\n            story_domain.StoryChange({\n                'cmd': 'add_story_node',\n                'node_id': 'node_1',\n                'title': 'Node1',\n            }), story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': None,\n                'new_value': self.EXP_ID\n            })\n        ]\n        story_services.update_story(\n            self.owner_id, self.STORY_ID,\n            story_change_list_to_add_an_exp, 'Added exploration.')\n\n    def create_translation_suggestion_associated_with_exp(\n            self, exp_id, author_id):\n        \"\"\"Creates a translation suggestion that is associated with an\n        exploration with id exp_id. The author of the created suggestion is\n        author_id.\n        \"\"\"\n        # Gets the html content in the exploration to be translated.\n        exploration = exp_fetchers.get_exploration_by_id(exp_id)\n        content_html = exploration.states['State 1'].content.html\n\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': 'State 1',\n            'content_id': 'content',\n            'language_code': 'hi',\n            'content_html': content_html,\n            'translation_html': '<p>This is translated html.</p>',\n            'data_format': 'html'\n        }\n\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            exp_id, 1, author_id, add_translation_change_dict,\n            'test description')\n\n    def assert_created_suggestion_is_valid(self, target_id, author_id):\n        \"\"\"Assert that the created suggestion is in review and that only one\n        suggestion with the given target_id and author_id exists.\n        \"\"\"\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', author_id), ('target_id', target_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_IN_REVIEW)\n\n    def test_create_and_accept_suggestion(self):\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE, None)\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_create_translation_contribution_stats_from_model(self):\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code='es',\n            contributor_user_id='user_id',\n            topic_id='topic_id',\n            submitted_translations_count=2,\n            submitted_translation_word_count=100,\n            accepted_translations_count=1,\n            accepted_translations_without_reviewer_edits_count=0,\n            accepted_translation_word_count=50,\n            rejected_translations_count=0,\n            rejected_translation_word_count=0,\n            contribution_dates=[\n                datetime.date.fromtimestamp(1616173836),\n                datetime.date.fromtimestamp(1616173837)\n            ]\n        )\n        translation_suggestion = suggestion_services.get_all_translation_contribution_stats( # pylint: disable=line-too-long\n            'user_id')\n        self.assertEqual(len(translation_suggestion), 1)\n        self.assertEqual(translation_suggestion[0].language_code, 'es')\n        self.assertEqual(\n            translation_suggestion[0].contributor_user_id,\n            'user_id'\n        )\n\n    def test_create_and_reject_suggestion(self):\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.reject_suggestion(\n            suggestion_id, self.reviewer_id, 'Reject message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Reject message')\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>old content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_REJECTED)\n\n    def test_create_and_accept_suggestion_with_message(self):\n        with self.swap(\n            feedback_models.GeneralFeedbackThreadModel,\n            'generate_new_thread_id', self.mock_generate_new_thread_id):\n            suggestion_services.create_suggestion(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.EXP_ID, self.target_version_at_submission,\n                self.author_id, self.change, 'test description')\n\n        suggestion_id = self.THREAD_ID\n\n        suggestion_services.accept_suggestion(\n            suggestion_id, self.reviewer_id, self.COMMIT_MESSAGE,\n            'Accept message')\n\n        exploration = exp_fetchers.get_exploration_by_id(self.EXP_ID)\n        thread_messages = feedback_services.get_messages(self.THREAD_ID)\n        last_message = thread_messages[len(thread_messages) - 1]\n        self.assertEqual(\n            last_message.text, 'Accept message')\n\n        self.assertEqual(\n            exploration.states['State 1'].content.html,\n            '<p>new content</p>')\n\n        suggestion = suggestion_services.get_suggestion_by_id(suggestion_id)\n        self.assertEqual(suggestion.status, suggestion_models.STATUS_ACCEPTED)\n\n    def test_delete_skill_rejects_question_suggestion(self):\n        skill_id = skill_services.get_new_skill_id()\n        self.save_new_skill(skill_id, self.author_id, description='description')\n        suggestion_change = {\n            'cmd': (\n                question_domain\n                .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': 'en',\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n        suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL, skill_id, 1,\n            self.author_id, suggestion_change, 'test description')\n        self.assert_created_suggestion_is_valid(skill_id, self.author_id)\n\n        skill_services.delete_skill(self.author_id, skill_id)\n\n        # Suggestion should be rejected after corresponding skill is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', skill_id)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_topic_rejects_translation_suggestion(self):\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        topic_services.delete_topic(self.author_id, self.TOPIC_ID)\n\n        # Suggestion should be rejected after the topic is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_delete_story_rejects_translation_suggestion(self):\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        story_services.delete_story(self.author_id, self.STORY_ID)\n\n        # Suggestion should be rejected after the story is deleted.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n    def test_remove_exp_from_story_rejects_translation_suggestion(self):\n        self.create_translation_suggestion_associated_with_exp(\n            self.EXP_ID, self.author_id)\n        self.assert_created_suggestion_is_valid(self.EXP_ID, self.author_id)\n\n        # Removes the exploration from the story.\n        story_services.update_story(\n            self.owner_id, self.STORY_ID, [story_domain.StoryChange({\n                'cmd': 'update_story_node_property',\n                'property_name': 'exploration_id',\n                'node_id': 'node_1',\n                'old_value': self.EXP_ID,\n                'new_value': None\n            })], 'Removed exploration.')\n\n        # Suggestion should be rejected after exploration is removed from the\n        # story.\n        suggestions = suggestion_services.query_suggestions(\n            [('author_id', self.author_id), ('target_id', self.EXP_ID)])\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(\n            suggestions[0].status, suggestion_models.STATUS_REJECTED)\n\n\nclass UserContributionProficiencyUnitTests(test_utils.GenericTestBase):\n\n    def setUp(self):\n        super(UserContributionProficiencyUnitTests, self).setUp()\n        self.signup('user1@example.com', 'user1')\n        self.signup('user2@example.com', 'user2')\n        self.user_1_id = self.get_user_id_from_email('user1@example.com')\n        self.user_2_id = self.get_user_id_from_email('user2@example.com')\n\n    def test_get_all_user_ids_who_are_allowed_to_review(self):\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2',\n            feconf.MINIMUM_SCORE_REQUIRED_TO_REVIEW)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category1', 0)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_2_id, 'category2', 0)\n\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category1'))\n        self.assertEqual(user_ids, [])\n        user_ids = (\n            suggestion_services.get_all_user_ids_who_are_allowed_to_review(\n                'category2'))\n        self.assertEqual(user_ids, [self.user_1_id])\n\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category1'))\n        self.assertTrue(suggestion_services.can_user_review_category(\n            self.user_1_id, 'category2'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n        self.assertFalse(suggestion_services.can_user_review_category(\n            self.user_2_id, 'category1'))\n\n    def test_get_all_scores_of_the_user_with_multiple_scores(self):\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category1', 1)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category2', 2)\n        user_models.UserContributionProficiencyModel.create(\n            self.user_1_id, 'category3', 3)\n\n        expected_scores_dict = {}\n        for index in range(1, 4):\n            key = 'category%s' % str(index)\n            expected_scores_dict[key] = index\n\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 3)\n        self.assertDictEqual(scores_dict, expected_scores_dict)\n\n    def test_get_all_scores_of_the_user_when_no_scores_exist(self):\n        scores_dict = suggestion_services.get_all_scores_of_user(\n            self.user_1_id)\n\n        self.assertEqual(len(scores_dict), 0)\n        self.assertDictEqual(scores_dict, {})\n\n\nclass VoiceoverApplicationServiceUnitTest(test_utils.GenericTestBase):\n    \"\"\"Tests for the ExplorationVoiceoverApplication class.\"\"\"\n\n    def setUp(self):\n        super(VoiceoverApplicationServiceUnitTest, self).setUp()\n        self.signup('author@example.com', 'author')\n        self.author_id = self.get_user_id_from_email('author@example.com')\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='0',\n            status='review',\n            author_id=self.author_id,\n            final_reviewer_id=None,\n            language_code='en',\n            filename='filename.mp3',\n            content='<p>content</p>',\n            rejection_message=None).put()\n        self.voiceover_application_model = (\n            suggestion_models.GeneralVoiceoverApplicationModel.get_by_id(\n                'application_id'))\n\n    def test_get_voiceover_application_from_model_with_invalid_type_raise_error(\n            self):\n        suggestion_services.get_voiceover_application(\n            self.voiceover_application_model.id)\n\n        self.voiceover_application_model.target_type = 'invalid_type'\n        with self.assertRaisesRegex(\n            Exception,\n            'Invalid target type for voiceover application: invalid_type'):\n            suggestion_services.get_voiceover_application(\n                self.voiceover_application_model.id)\n\n\nclass ReviewableSuggestionEmailInfoUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Tests the methods related to the ReviewableSuggestionEmailInfo class.\n    \"\"\"\n\n    target_id = 'exp1'\n    skill_id = 'skill1'\n    language_code = 'en'\n    AUTHOR_EMAIL = 'author1@example.com'\n    REVIEWER_EMAIL = 'reviewer@community.org'\n    COMMIT_MESSAGE = 'commit message'\n\n    def _create_translation_suggestion_with_translation_html(\n            self, translation_html):\n        \"\"\"Creates a translation suggestion with the given translation_html.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': translation_html,\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_question_html_content(\n            self, question_html_content):\n        \"\"\"Creates a question suggestion with the html content used for the\n        question in the question suggestion.\n        \"\"\"\n        with self.swap(\n            feconf, 'DEFAULT_INIT_STATE_CONTENT_STR', question_html_content):\n            add_question_change_dict = {\n                'cmd': (\n                    question_domain\n                    .CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION),\n                'question_dict': {\n                    'question_state_data': self._create_valid_question_data(\n                        'default_state').to_dict(),\n                    'language_code': self.language_code,\n                    'question_state_data_schema_version': (\n                        feconf.CURRENT_STATE_SCHEMA_VERSION),\n                    'linked_skill_ids': ['skill_1'],\n                    'inapplicable_skill_misconception_ids': ['skillid12345-1']\n                },\n                'skill_id': self.skill_id,\n                'skill_difficulty': 0.3\n            }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(self):\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            'test description')\n\n    def _assert_reviewable_suggestion_email_infos_are_equal(\n            self, reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info):\n        \"\"\"Asserts that the reviewable suggestion email info is equal to the\n        expected reviewable suggestion email info.\n        \"\"\"\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_type,\n            expected_reviewable_suggestion_email_info.suggestion_type)\n        self.assertEqual(\n            reviewable_suggestion_email_info.language_code,\n            expected_reviewable_suggestion_email_info.language_code)\n        self.assertEqual(\n            reviewable_suggestion_email_info.suggestion_content,\n            expected_reviewable_suggestion_email_info.suggestion_content)\n        self.assertEqual(\n            reviewable_suggestion_email_info.submission_datetime,\n            expected_reviewable_suggestion_email_info.submission_datetime)\n\n    def setUp(self):\n        super(\n            ReviewableSuggestionEmailInfoUnitTests, self).setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n\n    def test_create_raises_for_suggestion_type_not_on_contributor_dashboard(\n            self):\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        # Mocking the SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS dict in\n        # suggestion services so that this test still passes if the\n        # \"edit state content\" suggestion type is added to the Contributor\n        # Dashboard in the future.\n        suggestion_emphasized_text_getter_functions_mock = {}\n\n        with self.swap(\n            suggestion_services, 'SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS',\n            suggestion_emphasized_text_getter_functions_mock):\n            with self.assertRaisesRegex(\n                Exception,\n                'Expected suggestion type to be offered on the Contributor '\n                'Dashboard, received: %s.' % (\n                    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)):\n                (\n                    suggestion_services\n                    .create_reviewable_suggestion_email_info_from_suggestion(\n                        edit_state_content_suggestion)\n                )\n\n    def test_contributor_suggestion_types_are_in_suggestion_text_getter_dict(\n            self):\n        # This test will fail if a new suggestion type is added to the\n        # Contributor Dashboard but hasn't been added to\n        # SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.\n        sorted_text_getter_dict_suggestion_types = sorted(\n            suggestion_services\n            .SUGGESTION_EMPHASIZED_TEXT_GETTER_FUNCTIONS.keys())\n        sorted_contributor_dashboard_suggestion_types = sorted(\n            feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES)\n\n        self.assertListEqual(\n            sorted_text_getter_dict_suggestion_types,\n            sorted_contributor_dashboard_suggestion_types)\n\n    def test_create_from_suggestion_returns_info_for_question_suggestion(self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p>default question content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'default question content',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_translation_suggestion(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p>default translation content</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'default translation content',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_for_empty_html(self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ''))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code, '',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_from_suggestion_returns_info_with_no_trailing_whitespace(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                ' <p>          test whitespace     </p>    '))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'test whitespace',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_math_rte(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p>translation with rte'\n                '<oppia-noninteractive-math></oppia-noninteractive-math></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_image_rte(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p>translation with rte'\n                '<oppia-noninteractive-image></oppia-noninteractive-image>'\n                '</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Image]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_link_rte(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link> </p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_repeats(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link>'\n                '</p><oppia-noninteractive-link></oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_multi_rte(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p> translation with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link>'\n                '</p><oppia-noninteractive-math></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                'translation with rte [Link] [Math]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_translation_suggestion_if_html_rte_value(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_translation_html(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                translation_suggestion.suggestion_type,\n                translation_suggestion.language_code,\n                '[Link]',\n                translation_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                translation_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_math_rte(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-math></oppia-noninteractive-math> </p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_image_rte(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-image></oppia-noninteractive-image>'\n                '</p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Image]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info)\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_link_rte(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link> </p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_repeat_rte(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link>'\n                '</p><oppia-noninteractive-link></oppia-noninteractive-link>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_multi_rte(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p> question with rte'\n                '<oppia-noninteractive-link></oppia-noninteractive-link>'\n                '</p><oppia-noninteractive-math></oppia-noninteractive-math>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                'question with rte [Link] [Math]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_question_suggestion_if_html_has_rte_value(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_text(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\">text</oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_html(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link text-with-value=\"&amp;quot;Test '\n                'a tag&amp;quot;\" url-with-value=\"&amp;quot;somelink&amp;'\n                'quot;\"><p>text</p></oppia-noninteractive-link></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n    def test_create_returns_info_for_suggestion_if_html_has_rte_with_multi_word(\n            self):\n        question_suggestion = (\n            self._create_question_suggestion_with_question_html_content(\n                '<p><oppia-noninteractive-link-test text-with-value='\n                '\"&amp;quot;Test a tag&amp;quot;\" url-with-value=\"&amp;quot;'\n                'somelink&amp;quot;\"><p>text</p>'\n                '</oppia-noninteractive-link-test></p>'))\n        expected_reviewable_suggestion_email_info = (\n            suggestion_registry.ReviewableSuggestionEmailInfo(\n                question_suggestion.suggestion_type,\n                question_suggestion.language_code,\n                '[Link Test]',\n                question_suggestion.last_updated\n            ))\n\n        reviewable_suggestion_email_info = (\n            suggestion_services\n            .create_reviewable_suggestion_email_info_from_suggestion(\n                question_suggestion)\n        )\n\n        self._assert_reviewable_suggestion_email_infos_are_equal(\n            reviewable_suggestion_email_info,\n            expected_reviewable_suggestion_email_info\n        )\n\n\nclass GetSuggestionsWaitingForReviewInfoToNotifyReviewersUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_suggestions_waitng_for_review_info_to_notify_reviewers method\n    in suggestion services, which is used to retrieve the information required\n    to notify reviewers that there are suggestions that need review.\n    \"\"\"\n\n    target_id = 'exp1'\n    language_code = 'en'\n    AUTHOR_EMAIL = 'author1@example.com'\n    REVIEWER_1_EMAIL = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL = 'reviewer2@community.org'\n    COMMIT_MESSAGE = 'commit message'\n\n    def _create_translation_suggestion_with_language_code_and_author(\n            self, language_code, author_id):\n        \"\"\"Creates a translation suggestion in the given language_code with the\n        given author id.\n        \"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion_with_skill_id_and_author_id(\n            self, skill_id, author_id):\n        \"\"\"Creates a question suggestion with the given skill_id.\"\"\"\n        add_question_change_dict = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n            self, suggestions):\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            self, reviewable_suggestion_email_infos,\n            expected_reviewable_suggestion_email_infos):\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self):\n        super(\n            GetSuggestionsWaitingForReviewInfoToNotifyReviewersUnitTests,\n            self).setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n\n    def test_get_returns_empty_for_reviewers_who_authored_the_suggestions(self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_question_reviewers_if_only_translation_exist(\n            self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_translation_reviewers_if_only_question_exist(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.reviewer_1_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_accepted_suggestions(self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_empty_for_rejected_suggestions(self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_1_id,\n            'review message')\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_a_translation_reviewer_same_lang(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_empty_for_a_translation_reviewer_with_diff_lang_rights(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self.assertEqual(reviewable_suggestion_email_infos, [[]])\n\n    def test_get_returns_suggestion_infos_for_translation_reviewer_multi_lang(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_same_lang(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create another translation suggestion so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit.\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_infos_for_translation_reviewer_past_limit_diff_lang(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        # Create another hindi and english translation suggestion so that we\n        # reach the MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit for each\n        # language code but continue to update which suggestions have been\n        # waiting the longest (since the top two suggestions waiting the\n        # longest are from different language codes).\n        self._create_translation_suggestion_with_language_code_and_author(\n            'en', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_2]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 2):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multiple_translation_reviewers(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        translation_suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    translation_suggestion_1, translation_suggestion_2,\n                    translation_suggestion_3]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1, translation_suggestion_3]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_suggestion_infos_for_reviewer_with_multi_review_rights(\n            self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_4 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_a_question_reviewer(self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_question_reviewers(self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        question_suggestion_2 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1, question_suggestion_2]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_question_reviewer_past_limit(\n            self):\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        question_suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_2', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [question_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]\n                )\n            )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n    def test_get_returns_suggestion_infos_for_multi_reviewers_with_multi_rights(\n            self):\n        # Reviewer 1's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'en')\n        # Reviewer 2's permissions.\n        user_services.allow_user_to_review_question(self.reviewer_2_id)\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'hi')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_2_id, 'fr')\n        suggestion_1 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_1', self.author_id))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_3 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'fr', self.author_id))\n        suggestion_4 = (\n            self._create_question_suggestion_with_skill_id_and_author_id(\n                'skill_2', self.author_id))\n        suggestion_5 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        suggestion_6 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'en', self.author_id))\n        expected_reviewable_suggestion_email_infos_reviewer_1 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_4, suggestion_5,\n                    suggestion_6]))\n        expected_reviewable_suggestion_email_infos_reviewer_2 = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [\n                    suggestion_1, suggestion_2, suggestion_3, suggestion_4,\n                    suggestion_5]))\n\n        reviewable_suggestion_email_infos = (\n            suggestion_services\n            .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                [self.reviewer_1_id, self.reviewer_2_id]\n            )\n        )\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos_reviewer_1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[1],\n            expected_reviewable_suggestion_email_infos_reviewer_2)\n\n    def test_get_returns_infos_for_reviewer_with_multi_rights_past_limit(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_1_id, 'hi')\n        user_services.allow_user_to_review_question(self.reviewer_1_id)\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code_and_author(\n                'hi', self.author_id))\n        # Create additional suggestions so that we pass the\n        # MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER limit regardless of\n        # suggestion type.\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        self._create_translation_suggestion_with_language_code_and_author(\n            'hi', self.author_id)\n        self._create_question_suggestion_with_skill_id_and_author_id(\n            'skill_1', self.author_id)\n        expected_reviewable_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion_1]))\n\n        with self.swap(\n            suggestion_services,\n            'MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_REVIEWER', 1):\n            reviewable_suggestion_email_infos = (\n                suggestion_services\n                .get_suggestions_waiting_for_review_info_to_notify_reviewers(\n                    [self.reviewer_1_id]))\n\n        self.assertEqual(len(reviewable_suggestion_email_infos), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            reviewable_suggestion_email_infos[0],\n            expected_reviewable_suggestion_email_infos)\n\n\nclass CommunityContributionStatsUnitTests(test_utils.GenericTestBase):\n    \"\"\"Test the functionality related to updating the community contribution\n    stats.\n\n    TODO(#10957): It is currently not possible to resubmit a rejected\n    translation suggestion for review. As a result, there isn't a test for\n    that case in this test class. If the functionality is added, a new test\n    should be added here to cover that case. If the functionality is not going\n    to be added then this can be removed. See issue #10957 for more context.\n    \"\"\"\n\n    target_id = 'exp1'\n    skill_id = 'skill_123456'\n    language_code = 'en'\n    AUTHOR_EMAIL = 'author@example.com'\n    REVIEWER_EMAIL = 'reviewer@community.org'\n    COMMIT_MESSAGE = 'commit message'\n\n    def _create_translation_suggestion_with_language_code(self, language_code):\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(self):\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_edit_state_content_suggestion(self):\n        \"\"\"Creates an \"edit state content\" suggestion.\"\"\"\n\n        edit_state_content_change_dict = {\n            'cmd': exp_domain.CMD_EDIT_STATE_PROPERTY,\n            'property_name': exp_domain.STATE_PROPERTY_CONTENT,\n            'state_name': 'Introduction',\n            'new_value': {\n                'content_id': 'content',\n                'html': 'new html content'\n            },\n            'old_value': {\n                'content_id': 'content',\n                'html': 'old html content'\n            }\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, edit_state_content_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(self):\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats()\n        )\n\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self):\n        super(\n            CommunityContributionStatsUnitTests, self).setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(\n            self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_create_edit_state_content_suggestion_does_not_change_the_counts(\n            self):\n        self._create_edit_state_content_suggestion()\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_accept_edit_state_content_suggestion_does_not_change_the_counts(\n            self):\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.accept_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestion_does_not_change_the_counts(\n            self):\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_edit_state_content_suggestions_does_not_change_the_counts(\n            self):\n        edit_state_content_suggestion_1 = (\n            self._create_edit_state_content_suggestion())\n        edit_state_content_suggestion_2 = (\n            self._create_edit_state_content_suggestion())\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_services.reject_suggestions(\n            [\n                edit_state_content_suggestion_1.suggestion_id,\n                edit_state_content_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_edit_state_content_suggestion_does_not_change_the_counts(\n            self):\n        edit_state_content_suggestion = (\n            self._create_edit_state_content_suggestion())\n        suggestion_services.reject_suggestion(\n            edit_state_content_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the new_value of the html of the suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_suggestion_change = edit_state_content_suggestion.change\n        resubmit_suggestion_change.new_value['html'] = 'new html to resubmit'\n\n        # Resubmit the rejected \"edit state content\" suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            edit_state_content_suggestion.suggestion_id,\n            'resubmit summary message', self.author_id,\n            resubmit_suggestion_change)\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_question_suggestion_increases_question_suggestion_count(\n            self):\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_multi_question_suggestions_increases_question_count(self):\n        self._create_question_suggestion()\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_accept_question_suggestion_decreases_question_suggestion_count(\n            self):\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.accept_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestion_decreases_question_suggestion_count(\n            self):\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_question_suggestions_decreases_question_suggestion_count(\n            self):\n        question_suggestion_1 = self._create_question_suggestion()\n        question_suggestion_2 = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 2)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_services.reject_suggestions(\n            [\n                question_suggestion_1.suggestion_id,\n                question_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_resubmit_question_suggestion_increases_question_suggestion_count(\n            self):\n        question_suggestion = self._create_question_suggestion()\n        # Assert that the question suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n        suggestion_services.reject_suggestion(\n            question_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n        # Assert that the question suggestion decreased because the suggestion\n        # was rejected.\n        self._assert_community_contribution_stats_is_in_default_state()\n        # Change the question_dict of the question suggestion that got rejected\n        # so we can resubmit the suggestion for review.\n        resubmit_question_change = question_suggestion.change\n        resubmit_question_change.question_dict['linked_skill_ids'] = ['skill1']\n\n        # Resubmit the rejected question suggestion.\n        suggestion_services.resubmit_rejected_suggestion(\n            question_suggestion.suggestion_id, 'resubmit summary message',\n            self.author_id, resubmit_question_change\n        )\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n    def test_create_translation_suggestion_raises_translation_suggestion_count(\n            self):\n        self._create_translation_suggestion_with_language_code(\n            self.language_code)\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n    def test_create_translation_suggestions_diff_lang_raises_translation_counts(\n            self):\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n    def test_create_translation_suggestions_eq_lang_increases_translation_count(\n            self):\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('hi')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'hi': 2})\n\n    def test_accept_translation_suggestion_lowers_translation_suggestion_count(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.accept_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n            self.COMMIT_MESSAGE, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestion_lowers_translation_suggestion_count(\n            self):\n        translation_suggestion = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion.suggestion_id, self.reviewer_id,\n            'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_one_translation_suggestion_diff_lang_lowers_only_one_count(\n            self):\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        # Create a translation suggestion in a different language that won't be\n        # rejected.\n        self._create_translation_suggestion_with_language_code('en')\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestion(\n            translation_suggestion_1.suggestion_id, self.reviewer_id,\n            'review message')\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {'en': 1})\n\n    def test_reject_translation_suggestions_diff_lang_lowers_translation_count(\n            self):\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_translation_suggestions_same_lang_lowers_translation_count(\n            self):\n        translation_suggestion_1 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        translation_suggestion_2 = (\n            self._create_translation_suggestion_with_language_code(\n                self.language_code))\n        # Assert that the translation suggestion count increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {self.language_code: 2})\n\n        suggestion_services.reject_suggestions(\n            [\n                translation_suggestion_1.suggestion_id,\n                translation_suggestion_2.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_reject_suggestions_diff_type_decreases_suggestion_counts(self):\n        suggestion_1 = (\n            self._create_translation_suggestion_with_language_code('hi'))\n        suggestion_2 = (\n            self._create_translation_suggestion_with_language_code('en'))\n        suggestion_3 = self._create_edit_state_content_suggestion()\n        suggestion_4 = self._create_question_suggestion()\n        # Assert that the suggestion counts increased.\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n        suggestion_services.reject_suggestions(\n            [\n                suggestion_1.suggestion_id, suggestion_2.suggestion_id,\n                suggestion_3.suggestion_id, suggestion_4.suggestion_id\n            ], self.reviewer_id, 'review message')\n\n        self._assert_community_contribution_stats_is_in_default_state()\n\n    def test_create_suggestions_diff_type_increases_suggestion_counts(self):\n        self._create_translation_suggestion_with_language_code('hi')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_question_suggestion()\n\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'hi': 1, 'en': 1})\n\n\nclass GetSuggestionsWaitingTooLongForReviewInfoForAdminsUnitTests(\n        test_utils.GenericTestBase):\n    \"\"\"Test the ability of the\n    get_info_about_suggestions_waiting_too_long_for_review method in suggestion\n    services, which is used to retrieve the information required to notify\n    admins if there are suggestions that have waited longer than\n    suggestion_models.SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days for a\n    review on the Contributor Dashboard.\n    \"\"\"\n\n    target_id = 'exp1'\n    skill_id = 'skill_123456'\n    language_code = 'en'\n    AUTHOR_EMAIL = 'author@example.com'\n    REVIEWER_1_EMAIL = 'reviewer1@community.org'\n    REVIEWER_2_EMAIL = 'reviewer2@community.org'\n    COMMIT_MESSAGE = 'commit message'\n    mocked_datetime_utcnow = datetime.datetime(2020, 6, 15, 5)\n\n    def _create_translation_suggestion(self):\n        \"\"\"Creates a translation suggestion.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': self.language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(self):\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': self.language_code,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _create_reviewable_suggestion_email_infos_from_suggestions(\n            self, suggestions):\n        \"\"\"Creates a list of ReviewableSuggestionEmailInfo objects from\n        the given suggestions.\n        \"\"\"\n\n        return [\n            (\n                suggestion_services\n                .create_reviewable_suggestion_email_info_from_suggestion(\n                    suggestion)\n            ) for suggestion in suggestions\n        ]\n\n    def _assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            self, reviewable_suggestion_email_infos,\n            expected_reviewable_suggestion_email_infos):\n        \"\"\"Asserts that the reviewable suggestion email infos are equal to the\n        expected reviewable suggestion email infos and that the reviewable\n        suggestion email infos are sorted in descending order according to\n        review wait time.\n        \"\"\"\n        self.assertEqual(\n            len(reviewable_suggestion_email_infos),\n            len(expected_reviewable_suggestion_email_infos)\n        )\n        for index, reviewable_suggestion_email_info in enumerate(\n                reviewable_suggestion_email_infos):\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_type,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_type)\n            self.assertEqual(\n                reviewable_suggestion_email_info.language_code,\n                expected_reviewable_suggestion_email_infos[\n                    index].language_code)\n            self.assertEqual(\n                reviewable_suggestion_email_info.suggestion_content,\n                expected_reviewable_suggestion_email_infos[\n                    index].suggestion_content)\n            self.assertEqual(\n                reviewable_suggestion_email_info.submission_datetime,\n                expected_reviewable_suggestion_email_infos[\n                    index].submission_datetime)\n        for index in range(len(reviewable_suggestion_email_infos) - 1):\n            self.assertLessEqual(\n                reviewable_suggestion_email_infos[index].submission_datetime,\n                reviewable_suggestion_email_infos[\n                    index + 1].submission_datetime\n            )\n\n    def setUp(self):\n        super(\n            GetSuggestionsWaitingTooLongForReviewInfoForAdminsUnitTests,\n            self).setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.signup(self.REVIEWER_1_EMAIL, 'reviewer1')\n        self.reviewer_1_id = self.get_user_id_from_email(\n            self.REVIEWER_1_EMAIL)\n        self.signup(self.REVIEWER_2_EMAIL, 'reviewer2')\n        self.reviewer_2_id = self.get_user_id_from_email(\n            self.REVIEWER_2_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n\n    def test_get_returns_empty_for_suggestion_type_not_on_contributor_dashboard(\n            self):\n        self._create_translation_suggestion()\n        # This mocked list cannot be empty because then the storage query in the\n        # get_suggestions_waiting_too_long_for_review method will fail.\n        mocked_contributor_dashboard_suggestion_types = [\n            feconf.SUGGESTION_TYPE_ADD_QUESTION]\n\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES',\n            mocked_contributor_dashboard_suggestion_types):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestion_review_wait_time_diff_is_negative(\n            self):\n        self._create_translation_suggestion()\n\n        # Make sure the threshold is nonzero.\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 1):\n            info_about_suggestions_waiting_too_long_for_review = (\n                suggestion_services\n                .get_info_about_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestions_have_waited_less_than_threshold(\n            self):\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n            self._create_question_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_less_than_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=1))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_less_than_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_empty_if_suggestions_have_waited_threshold_review_time(\n            self):\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            self._create_translation_suggestion()\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_eq_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(\n                days=mocked_threshold_review_wait_time_in_days))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_eq_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_returns_suggestion_waited_long_if_their_wait_is_past_threshold(\n            self):\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        # Give the question suggestion a slightly different review submission\n        # time so that the suggestions are not indistinguishable, in terms of\n        # their review submission time.\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(minutes=5)):\n            question_suggestion = self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion, question_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 1\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 2)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n    def test_get_only_returns_suggestions_that_have_waited_past_wait_threshold(\n            self):\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            translation_suggestion = self._create_translation_suggestion()\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2)):\n            self._create_question_suggestion()\n        expected_suggestion_email_infos = (\n            self._create_reviewable_suggestion_email_infos_from_suggestions(\n                [translation_suggestion]))\n        mocked_threshold_review_wait_time_in_days = 3\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=4))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                info_about_suggestions_waiting_too_long_for_review = (\n                    suggestion_services\n                    .get_info_about_suggestions_waiting_too_long_for_review()\n                )\n\n        # The question suggestion was created 2 days after the translation\n        # suggestion, so it has only waited 1 day for a review, which is less\n        # than 3, the mocked review wait time threshold. Therefore, only the\n        # translation suggestion has waited too long for review.\n        self.assertEqual(\n            len(info_about_suggestions_waiting_too_long_for_review), 1)\n        self._assert_reviewable_suggestion_email_infos_are_in_correct_order(\n            info_about_suggestions_waiting_too_long_for_review,\n            expected_suggestion_email_infos\n        )\n\n\nclass GetSuggestionTypesThatNeedReviewersUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the get_suggestion_types_that_need_reviewers method.\"\"\"\n\n    sample_language_code = 'en'\n    target_id = 'exp1'\n    skill_id = 'skill_123456'\n    language_code = 'en'\n    AUTHOR_EMAIL = 'author@example.com'\n    REVIEWER_EMAIL = 'reviewer@community.org'\n\n    def _create_translation_suggestion_with_language_code(self, language_code):\n        \"\"\"Creates a translation suggestion in the given language_code.\"\"\"\n        add_translation_change_dict = {\n            'cmd': exp_domain.CMD_ADD_WRITTEN_TRANSLATION,\n            'state_name': feconf.DEFAULT_INIT_STATE_NAME,\n            'content_id': feconf.DEFAULT_NEW_STATE_CONTENT_ID,\n            'language_code': language_code,\n            'content_html': feconf.DEFAULT_INIT_STATE_CONTENT_STR,\n            'translation_html': '<p>This is the translated content.</p>',\n            'data_format': 'html'\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_translation_change_dict,\n            'test description'\n        )\n\n    def _create_question_suggestion(self):\n        \"\"\"Creates a question suggestion.\"\"\"\n        add_question_change_dict = {\n            'cmd': question_domain.CMD_CREATE_NEW_FULLY_SPECIFIED_QUESTION,\n            'question_dict': {\n                'question_state_data': self._create_valid_question_data(\n                    'default_state').to_dict(),\n                'language_code': constants.DEFAULT_LANGUAGE_CODE,\n                'question_state_data_schema_version': (\n                    feconf.CURRENT_STATE_SCHEMA_VERSION),\n                'linked_skill_ids': ['skill_1'],\n                'inapplicable_skill_misconception_ids': ['skillid12345-1']\n            },\n            'skill_id': self.skill_id,\n            'skill_difficulty': 0.3\n        }\n\n        return suggestion_services.create_suggestion(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            self.skill_id, feconf.CURRENT_STATE_SCHEMA_VERSION,\n            self.author_id, add_question_change_dict,\n            'test description'\n        )\n\n    def _assert_community_contribution_stats_is_in_default_state(self):\n        \"\"\"Checks if the community contribution stats is in its default\n        state.\n        \"\"\"\n        community_contribution_stats = (\n            suggestion_services.get_community_contribution_stats())\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_reviewer_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            (\n                community_contribution_stats\n                .translation_suggestion_counts_by_lang_code\n            ), {})\n        self.assertEqual(\n            community_contribution_stats.question_reviewer_count, 0)\n        self.assertEqual(\n            community_contribution_stats.question_suggestion_count, 0)\n\n    def setUp(self):\n        super(\n            GetSuggestionTypesThatNeedReviewersUnitTests,\n            self).setUp()\n        self.signup(self.AUTHOR_EMAIL, 'author')\n        self.author_id = self.get_user_id_from_email(self.AUTHOR_EMAIL)\n        self.save_new_valid_exploration(self.target_id, self.author_id)\n        self.save_new_skill(self.skill_id, self.author_id)\n        self.signup(self.REVIEWER_EMAIL, 'reviewer')\n        self.reviewer_id = self.get_user_id_from_email(\n            self.REVIEWER_EMAIL)\n\n    def test_get_returns_no_reviewers_needed_if_no_suggestions_exist(self):\n        self._assert_community_contribution_stats_is_in_default_state()\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_question_reviewer_no_question(\n            self):\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_not_needed_if_translation_reviewers_but_no_translation(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_translation_reviewers(\n            self):\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'en')\n        user_services.allow_user_to_review_translation_in_language(\n            self.reviewer_id, 'fr')\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {'en': 1, 'fr': 1})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_no_reviewers_needed_if_enough_question_reviewers(\n            self):\n        user_services.allow_user_to_review_question(self.reviewer_id)\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 1)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(suggestion_types_needing_reviewers, {})\n\n    def test_get_returns_reviewers_needed_if_question_but_no_reviewers(\n            self):\n        self._create_question_suggestion()\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_ADD_QUESTION: {}})\n\n    def test_get_returns_reviewers_needed_if_translation_for_a_lang_no_reviewer(\n            self):\n        self._create_translation_suggestion_with_language_code(\n            self.sample_language_code)\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                self.sample_language_code: 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                self.sample_language_code}})\n\n    def test_get_returns_reviewers_needed_if_translation_for_langs_no_reviewers(\n            self):\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 0)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code, {\n                'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {'en', 'fr'}})\n\n    def test_get_returns_reviewers_needed_if_multi_suggestion_types_no_reviewer(\n            self):\n        self._create_question_suggestion()\n        self._create_translation_suggestion_with_language_code('en')\n        self._create_translation_suggestion_with_language_code('fr')\n        stats = suggestion_services.get_community_contribution_stats()\n        self.assertEqual(stats.question_reviewer_count, 0)\n        self.assertEqual(stats.question_suggestion_count, 1)\n        self.assertDictEqual(\n            stats.translation_reviewer_counts_by_lang_code, {})\n        self.assertDictEqual(\n            stats.translation_suggestion_counts_by_lang_code,\n            {'en': 1, 'fr': 1})\n\n        suggestion_types_needing_reviewers = (\n            suggestion_services.get_suggestion_types_that_need_reviewers())\n\n        self.assertDictEqual(\n            suggestion_types_needing_reviewers,\n            {\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT: {\n                    'en', 'fr'},\n                feconf.SUGGESTION_TYPE_ADD_QUESTION: {}\n            })\n"
    },
    {
      "filename": "core/feconf.py",
      "content": "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Stores various configuration options and constants for Oppia.\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport datetime\nimport enum\nimport os\n\nfrom core.constants import constants\n\nfrom typing import Dict, List, Union\nfrom typing_extensions import TypedDict\n\nCommandType = (\n    Dict[str, Union[str, List[str], Dict[str, Union[str, List[str]]]]])\n\n# The datastore model ID for the list of featured activity references. This\n# value should not be changed.\nACTIVITY_REFERENCE_LIST_FEATURED = 'featured'\nALL_ACTIVITY_REFERENCE_LIST_TYPES = [ACTIVITY_REFERENCE_LIST_FEATURED]\n\n# The values which a post_commit_status can have: public, private.\nPOST_COMMIT_STATUS_PUBLIC = 'public'\nPOST_COMMIT_STATUS_PRIVATE = 'private'\n\n# Whether to unconditionally log info messages.\nDEBUG = False\n\n# When DEV_MODE is true check that we are running in development environment.\n# The SERVER_SOFTWARE environment variable does not exist in Travis, hence the\n# need for an explicit check.\nif constants.DEV_MODE and os.getenv('SERVER_SOFTWARE'):\n    server_software = os.getenv('SERVER_SOFTWARE')\n    if (\n            server_software and\n            not server_software.startswith(('Development', 'gunicorn'))\n    ):\n        raise Exception('DEV_MODE can\\'t be true on production.')\n\nCLASSIFIERS_DIR = os.path.join('extensions', 'classifiers')\nTESTS_DATA_DIR = os.path.join('core', 'tests', 'data')\nSAMPLE_EXPLORATIONS_DIR = os.path.join('data', 'explorations')\nSAMPLE_COLLECTIONS_DIR = os.path.join('data', 'collections')\nCONTENT_VALIDATION_DIR = os.path.join('core', 'domain')\n\n# backend_prod_files contain processed JS and HTML files that are served by\n# Jinja, we are moving away from Jinja so this folder might not be needed later\n# (#6964)\nEXTENSIONS_DIR_PREFIX = (\n    'backend_prod_files' if not constants.DEV_MODE else '')\nACTIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'actions'))\nISSUES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'issues'))\nINTERACTIONS_DIR = (\n    os.path.join('extensions', 'interactions'))\nINTERACTIONS_LEGACY_SPECS_FILE_DIR = (\n    os.path.join(INTERACTIONS_DIR, 'legacy_interaction_specs_by_state_version'))\nINTERACTIONS_SPECS_FILE_PATH = (\n    os.path.join(INTERACTIONS_DIR, 'interaction_specs.json'))\nRTE_EXTENSIONS_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'rich_text_components'))\nRTE_EXTENSIONS_DEFINITIONS_PATH = (\n    os.path.join('assets', 'rich_text_components_definitions.ts'))\n\nOBJECT_TEMPLATES_DIR = os.path.join('extensions', 'objects', 'templates')\n\n# Choose production templates folder when we are in production mode.\nFRONTEND_TEMPLATES_DIR = (\n    os.path.join('webpack_bundles') if constants.DEV_MODE else\n    os.path.join('backend_prod_files', 'webpack_bundles'))\nDEPENDENCIES_TEMPLATES_DIR = (\n    os.path.join(EXTENSIONS_DIR_PREFIX, 'extensions', 'dependencies'))\n\nVALUE_GENERATORS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'value_generators')\nVALUE_GENERATORS_DIR = os.path.join('extensions', 'value_generators')\n\nVISUALIZATIONS_DIR = os.path.join(\n    'extensions', 'visualizations')\nVISUALIZATIONS_DIR_FOR_JS = os.path.join(\n    'local_compiled_js', 'extensions', 'visualizations')\n\nOBJECT_DEFAULT_VALUES_EXTENSIONS_MODULE_PATH = os.path.join(\n    'objects', 'object_defaults.json')\nRULES_DESCRIPTIONS_EXTENSIONS_MODULE_PATH = os.path.join(\n    'interactions', 'rule_templates.json')\nHTML_FIELD_TYPES_TO_RULE_SPECS_EXTENSIONS_MODULE_PATH = os.path.join(\n    'interactions', 'html_field_types_to_rule_specs.json')\nLEGACY_HTML_FIELD_TYPES_TO_RULE_SPECS_EXTENSIONS_MODULE_DIR = os.path.join(\n    'interactions', 'legacy_html_field_types_to_rule_specs_by_state_version')\n\n\n# Valid model names.\n# TODO(#14419): Change naming style of Enum class from SCREAMING_SNAKE_CASE\n# to PascalCase and its values to UPPER_CASE. Because we want to be consistent\n# throughout the codebase according to the coding style guide.\n# https://github.com/oppia/oppia/wiki/Coding-style-guide\nclass VALID_MODEL_NAMES(enum.Enum): # pylint: disable=invalid-name\n    \"\"\"Enum for valid model names.\"\"\"\n\n    activity = 'activity' # pylint: disable=invalid-name\n    app_feedback_report = 'app_feedback_report' # pylint: disable=invalid-name\n    audit = 'audit' # pylint: disable=invalid-name\n    base_model = 'base_model' # pylint: disable=invalid-name\n    beam_job = 'beam_job' # pylint: disable=invalid-name\n    blog = 'blog' # pylint: disable=invalid-name\n    classifier = 'classifier' # pylint: disable=invalid-name\n    collection = 'collection' # pylint: disable=invalid-name\n    config = 'config' # pylint: disable=invalid-name\n    email = 'email' # pylint: disable=invalid-name\n    exploration = 'exploration' # pylint: disable=invalid-name\n    feedback = 'feedback' # pylint: disable=invalid-name\n    improvements = 'improvements' # pylint: disable=invalid-name\n    job = 'job' # pylint: disable=invalid-name\n    opportunity = 'opportunity' # pylint: disable=invalid-name\n    question = 'question' # pylint: disable=invalid-name\n    recommendations = 'recommendations' # pylint: disable=invalid-name\n    skill = 'skill' # pylint: disable=invalid-name\n    statistics = 'statistics' # pylint: disable=invalid-name\n    auth = 'auth' # pylint: disable=invalid-name\n    story = 'story' # pylint: disable=invalid-name\n    subtopic = 'subtopic' # pylint: disable=invalid-name\n    suggestion = 'suggestion' # pylint: disable=invalid-name\n    topic = 'topic' # pylint: disable=invalid-name\n    translation = 'translation' # pylint: disable=invalid-name\n    user = 'user' # pylint: disable=invalid-name\n\n\n# A mapping of interaction ids to classifier properties.\n# TODO(#10217): As of now we support only one algorithm per interaction.\n# However, we do have the necessary storage infrastructure to support multiple\n# algorithms per interaction. Hence, whenever we find a secondary algorithm\n# candidate for any of the supported interactions, the logical functions to\n# support multiple algorithms need to be implemented.\n\n\nclass ClassifierDict(TypedDict):\n    \"\"\"Representing INTERACTION_CLASSIFIER_MAPPING dict values.\"\"\"\n\n    algorithm_id: str\n    algorithm_version: int\n\n\nINTERACTION_CLASSIFIER_MAPPING: Dict[str, ClassifierDict] = {\n    'TextInput': {\n        'algorithm_id': 'TextClassifier',\n        'algorithm_version': 1\n    },\n}\n\n# Classifier job time to live (in mins).\nCLASSIFIER_JOB_TTL_MINS = 5\nTRAINING_JOB_STATUS_COMPLETE = 'COMPLETE'\nTRAINING_JOB_STATUS_FAILED = 'FAILED'\nTRAINING_JOB_STATUS_NEW = 'NEW'\nTRAINING_JOB_STATUS_PENDING = 'PENDING'\n\nALLOWED_TRAINING_JOB_STATUSES: List[str] = [\n    TRAINING_JOB_STATUS_COMPLETE,\n    TRAINING_JOB_STATUS_FAILED,\n    TRAINING_JOB_STATUS_NEW,\n    TRAINING_JOB_STATUS_PENDING\n]\n\n# Allowed formats of how HTML is present in rule specs.\nHTML_RULE_VARIABLE_FORMAT_SET = 'set'\nHTML_RULE_VARIABLE_FORMAT_STRING = 'string'\nHTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS = 'listOfSets'\n\nALLOWED_HTML_RULE_VARIABLE_FORMATS = [\n    HTML_RULE_VARIABLE_FORMAT_SET,\n    HTML_RULE_VARIABLE_FORMAT_STRING,\n    HTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS\n]\n\nANSWER_TYPE_LIST_OF_SETS_OF_HTML = 'ListOfSetsOfHtmlStrings'\nANSWER_TYPE_SET_OF_HTML = 'SetOfHtmlString'\n\n# The maximum number of characters allowed for userbio length.\nMAX_BIO_LENGTH_IN_CHARS = 2000\n\nALLOWED_TRAINING_JOB_STATUS_CHANGES: Dict[str, List[str]] = {\n    TRAINING_JOB_STATUS_COMPLETE: [],\n    TRAINING_JOB_STATUS_NEW: [TRAINING_JOB_STATUS_PENDING],\n    TRAINING_JOB_STATUS_PENDING: [TRAINING_JOB_STATUS_COMPLETE,\n                                  TRAINING_JOB_STATUS_FAILED],\n    TRAINING_JOB_STATUS_FAILED: [TRAINING_JOB_STATUS_NEW]\n}\n\n# Allowed formats of how HTML is present in rule specs.\nHTML_RULE_VARIABLE_FORMAT_SET = 'set'\nHTML_RULE_VARIABLE_FORMAT_STRING = 'string'\nHTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS = 'listOfSets'\n\nALLOWED_HTML_RULE_VARIABLE_FORMATS = [\n    HTML_RULE_VARIABLE_FORMAT_SET,\n    HTML_RULE_VARIABLE_FORMAT_STRING,\n    HTML_RULE_VARIABLE_FORMAT_LIST_OF_SETS\n]\n\nANSWER_TYPE_LIST_OF_SETS_OF_HTML = 'ListOfSetsOfHtmlStrings'\nANSWER_TYPE_SET_OF_HTML = 'SetOfHtmlString'\n\nENTITY_TYPE_BLOG_POST = 'blog_post'\nENTITY_TYPE_EXPLORATION = 'exploration'\nENTITY_TYPE_TOPIC = 'topic'\nENTITY_TYPE_SKILL = 'skill'\nENTITY_TYPE_STORY = 'story'\nENTITY_TYPE_QUESTION = 'question'\nENTITY_TYPE_VOICEOVER_APPLICATION = 'voiceover_application'\n\nIMAGE_CONTEXT_QUESTION_SUGGESTIONS = 'question_suggestions'\nIMAGE_CONTEXT_EXPLORATION_SUGGESTIONS = 'exploration_suggestions'\n\nMAX_TASK_MODELS_PER_FETCH = 25\nMAX_TASK_MODELS_PER_HISTORY_PAGE = 10\n\nPERIOD_TO_HARD_DELETE_MODELS_MARKED_AS_DELETED = datetime.timedelta(weeks=8)\nPERIOD_TO_MARK_MODELS_AS_DELETED = datetime.timedelta(weeks=4)\n\n# The maximum number of activities allowed in the playlist of the learner. This\n# limit applies to both the explorations playlist and the collections playlist.\nMAX_LEARNER_PLAYLIST_ACTIVITY_COUNT = 10\n\n# The maximum number of goals allowed in the learner goals of the learner.\nMAX_CURRENT_GOALS_COUNT = 5\n\n# The minimum number of training samples required for training a classifier.\nMIN_TOTAL_TRAINING_EXAMPLES = 50\n\n# The minimum number of assigned labels required for training a classifier.\nMIN_ASSIGNED_LABELS = 2\n\n# Default label for classification algorithms.\nDEFAULT_CLASSIFIER_LABEL = '_default'\n\n# The maximum number of results to retrieve in a datastore query.\nDEFAULT_QUERY_LIMIT = 1000\n\n# The maximum number of results to retrieve in a datastore query\n# for suggestions.\nDEFAULT_SUGGESTION_QUERY_LIMIT = 1000\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FOR_LIBRARY_PAGE = 8\n\n# The maximum number of results to retrieve in a datastore query\n# for top rated published explorations in /library/top_rated page.\nNUMBER_OF_TOP_RATED_EXPLORATIONS_FULL_PAGE = 20\n\n# The maximum number of results to retrieve in a datastore query\n# for recently published explorations in /library/recently_published page.\nRECENTLY_PUBLISHED_QUERY_LIMIT_FULL_PAGE = 20\n\n# The maximum number of days a feedback report can be saved in storage before it\n# must be scrubbed.\nAPP_FEEDBACK_REPORT_MAXIMUM_LIFESPAN = datetime.timedelta(days=90)\n\n# The minimum version of the Android feedback report info blob schema.\nMINIMUM_ANDROID_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the Android feedback report info blob schema.\nCURRENT_ANDROID_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the web feedback report info blob schema.\nMINIMUM_WEB_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the web feedback report info blob schema.\nCURRENT_WEB_REPORT_SCHEMA_VERSION = 1\n\n# The current version of the app feedback report daily stats blob schema.\nCURRENT_FEEDBACK_REPORT_STATS_SCHEMA_VERSION = 1\n\n# The minimum version of the app feedback report daily stats blob schema.\nMINIMUM_FEEDBACK_REPORT_STATS_SCHEMA_VERSION = 1\n\n# The current version of the dashboard stats blob schema. If any backward-\n# incompatible changes are made to the stats blob schema in the data store,\n# this version number must be changed.\nCURRENT_DASHBOARD_STATS_SCHEMA_VERSION = 1\n\n# The earliest supported version of the exploration states blob schema.\nEARLIEST_SUPPORTED_STATE_SCHEMA_VERSION = 41\n\n# The current version of the exploration states blob schema. If any backward-\n# incompatible changes are made to the states blob schema in the data store,\n# this version number must be changed and the exploration migration job\n# executed.\nCURRENT_STATE_SCHEMA_VERSION = 49\n\n# The current version of the all collection blob schemas (such as the nodes\n# structure within the Collection domain object). If any backward-incompatible\n# changes are made to any of the blob schemas in the data store, this version\n# number must be changed.\nCURRENT_COLLECTION_SCHEMA_VERSION = 6\n\n# The current version of story contents dict in the story schema.\nCURRENT_STORY_CONTENTS_SCHEMA_VERSION = 5\n\n# The current version of skill contents dict in the skill schema.\nCURRENT_SKILL_CONTENTS_SCHEMA_VERSION = 4\n\n# The current version of misconceptions dict in the skill schema.\nCURRENT_MISCONCEPTIONS_SCHEMA_VERSION = 5\n\n# The current version of rubric dict in the skill schema.\nCURRENT_RUBRIC_SCHEMA_VERSION = 5\n\n# The current version of subtopics dict in the topic schema.\nCURRENT_SUBTOPIC_SCHEMA_VERSION = 4\n\n# The current version of story reference dict in the topic schema.\nCURRENT_STORY_REFERENCE_SCHEMA_VERSION = 1\n\n# The current version of page_contents dict in the subtopic page schema.\nCURRENT_SUBTOPIC_PAGE_CONTENTS_SCHEMA_VERSION = 4\n\n# This value should be updated in the event of any\n# StateAnswersModel.submitted_answer_list schema change.\nCURRENT_STATE_ANSWERS_SCHEMA_VERSION = 1\n\n# This value should be updated if the schema of LearnerAnswerInfo\n# dict schema changes.\nCURRENT_LEARNER_ANSWER_INFO_SCHEMA_VERSION = 1\n\n# This value should be updated if the schema of PlatformParameterRule dict\n# schema changes.\nCURRENT_PLATFORM_PARAMETER_RULE_SCHEMA_VERSION = 1\n\n# The default number of exploration tiles to load at a time in the search\n# results page.\nSEARCH_RESULTS_PAGE_SIZE = 20\n\n# The default number of commits to show on a page in the exploration history\n# tab.\nCOMMIT_LIST_PAGE_SIZE = 50\n\n# The default number of items to show on a page in the exploration feedback\n# tab.\nFEEDBACK_TAB_PAGE_SIZE = 20\n\n# The maximum number of top unresolved answers which should be aggregated\n# from all of the submitted answers.\nTOP_UNRESOLVED_ANSWERS_LIMIT = 20\n\n# Default title for a newly-minted exploration.\nDEFAULT_EXPLORATION_TITLE = ''\n# Default category for a newly-minted exploration.\nDEFAULT_EXPLORATION_CATEGORY = ''\n# Default objective for a newly-minted exploration.\nDEFAULT_EXPLORATION_OBJECTIVE = ''\n\n# NOTE TO DEVELOPERS: If any of the 5 constants below are modified, the\n# corresponding field in NEW_STATE_TEMPLATE in constants.js also has to be\n# modified.\n\n# Default name for the initial state of an exploration.\nDEFAULT_INIT_STATE_NAME = 'Introduction'\n# Default content id for the state's content.\nDEFAULT_NEW_STATE_CONTENT_ID = 'content'\n# Default content id for the interaction's default outcome.\nDEFAULT_OUTCOME_CONTENT_ID = 'default_outcome'\n# Default content id for the explanation in the concept card of a skill.\nDEFAULT_EXPLANATION_CONTENT_ID = 'explanation'\n# Content id assigned to rule inputs that do not match any interaction\n# customization argument choices.\nINVALID_CONTENT_ID = 'invalid_content_id'\n# Default recorded_voiceovers dict for a default state template.\nDEFAULT_RECORDED_VOICEOVERS: Dict[str, Dict[str, Dict[str, str]]] = {\n    'voiceovers_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# Default written_translations dict for a default state template.\nDEFAULT_WRITTEN_TRANSLATIONS: Dict[str, Dict[str, Dict[str, str]]] = {\n    'translations_mapping': {\n        'content': {},\n        'default_outcome': {}\n    }\n}\n# The default content text for the initial state of an exploration.\nDEFAULT_INIT_STATE_CONTENT_STR = ''\n\n# Whether new explorations should have automatic text-to-speech enabled\n# by default.\nDEFAULT_AUTO_TTS_ENABLED = False\n# Whether new explorations should have correctness-feedback enabled\n# by default.\nDEFAULT_CORRECTNESS_FEEDBACK_ENABLED = True\n\n# Default title for a newly-minted collection.\nDEFAULT_COLLECTION_TITLE = ''\n# Default category for a newly-minted collection.\nDEFAULT_COLLECTION_CATEGORY = ''\n# Default objective for a newly-minted collection.\nDEFAULT_COLLECTION_OBJECTIVE = ''\n\n# Default description for a newly-minted story.\nDEFAULT_STORY_DESCRIPTION = ''\n# Default notes for a newly-minted story.\nDEFAULT_STORY_NOTES = ''\n\n# Default explanation for a newly-minted skill.\nDEFAULT_SKILL_EXPLANATION = ''\n# Default name for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NAME = ''\n# Default notes for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_NOTES = ''\n# Default feedback for a newly-minted misconception.\nDEFAULT_MISCONCEPTION_FEEDBACK = ''\n# Default content_id for explanation subtitled html.\nDEFAULT_SKILL_EXPLANATION_CONTENT_ID = 'explanation'\n\n# Default description for a newly-minted topic.\nDEFAULT_TOPIC_DESCRIPTION = ''\n# Default abbreviated name for a newly-minted topic.\nDEFAULT_ABBREVIATED_TOPIC_NAME = ''\n# Default content id for the subtopic page's content.\nDEFAULT_SUBTOPIC_PAGE_CONTENT_ID = 'content'\n\n# Default ID of VM which is used for training classifier.\nDEFAULT_VM_ID = 'vm_default'\n# Shared secret key for default VM.\nDEFAULT_VM_SHARED_SECRET = '1a2b3c4e'\n\nIMAGE_FORMAT_JPEG = 'jpeg'\nIMAGE_FORMAT_PNG = 'png'\nIMAGE_FORMAT_GIF = 'gif'\nIMAGE_FORMAT_SVG = 'svg'\n\n# An array containing the accepted image formats (as determined by the imghdr\n# module) and the corresponding allowed extensions in the filenames of uploaded\n# images.\nACCEPTED_IMAGE_FORMATS_AND_EXTENSIONS = {\n    IMAGE_FORMAT_JPEG: ['jpg', 'jpeg'],\n    IMAGE_FORMAT_PNG: ['png'],\n    IMAGE_FORMAT_GIF: ['gif'],\n    IMAGE_FORMAT_SVG: ['svg']\n}\n\n# An array containing the image formats that can be compressed.\nCOMPRESSIBLE_IMAGE_FORMATS = [IMAGE_FORMAT_JPEG, IMAGE_FORMAT_PNG]\n\n# An array containing the accepted audio extensions for uploaded files and\n# the corresponding MIME types.\nACCEPTED_AUDIO_EXTENSIONS = {\n    'mp3': ['audio/mp3']\n}\n\n# Prefix for data sent from the server to the client via JSON.\nXSSI_PREFIX = b')]}\\'\\n'\n# A regular expression for alphanumeric characters.\nALPHANUMERIC_REGEX = r'^[A-Za-z0-9]+$'\n\n# These are here rather than in rating_services.py to avoid import\n# circularities with exp_services.\n# TODO(Jacob): Refactor exp_services to remove this problem.\n_EMPTY_RATINGS = {'1': 0, '2': 0, '3': 0, '4': 0, '5': 0}\n\n\ndef get_empty_ratings() -> Dict[str, int]:\n    \"\"\"Returns a copy of the empty ratings object.\n\n    Returns:\n        dict. Copy of the '_EMPTY_RATINGS' dict object which contains the empty\n        ratings.\n    \"\"\"\n    return copy.deepcopy(_EMPTY_RATINGS)\n\n\n# To use mailchimp email service.\nBULK_EMAIL_SERVICE_PROVIDER_MAILCHIMP = 'mailchimp_email_service'\n# Use GAE email service by default.\nBULK_EMAIL_SERVICE_PROVIDER = BULK_EMAIL_SERVICE_PROVIDER_MAILCHIMP\n\n# Empty scaled average rating as a float.\nEMPTY_SCALED_AVERAGE_RATING = 0.0\n\n# To use mailgun email service.\nEMAIL_SERVICE_PROVIDER_MAILGUN = 'mailgun_email_service'\n# Use GAE email service by default.\nEMAIL_SERVICE_PROVIDER = EMAIL_SERVICE_PROVIDER_MAILGUN\n# If the Mailgun email API is used, the \"None\" below should be replaced\n# with the Mailgun API key.\nMAILGUN_API_KEY = None\n# If the Mailgun email API is used, the \"None\" below should be replaced\n# with the Mailgun domain name (ending with mailgun.org).\nMAILGUN_DOMAIN_NAME = None\n\n# Audience ID of the mailing list for Oppia in Mailchimp.\nMAILCHIMP_AUDIENCE_ID = None\n# Mailchimp API Key.\nMAILCHIMP_API_KEY = None\n# Mailchimp username.\nMAILCHIMP_USERNAME = None\n# Mailchimp secret, used to authenticate webhook requests.\nMAILCHIMP_WEBHOOK_SECRET = None\n\nES_LOCALHOST_PORT = 9200\n# NOTE TO RELEASE COORDINATORS: Replace this with the correct ElasticSearch\n# auth information during deployment.\nES_CLOUD_ID = None\nES_USERNAME = None\nES_PASSWORD = None\n\n# NOTE TO RELEASE COORDINATORS: Replace this with the correct Redis Host and\n# Port when switching to prod server. Keep this in sync with redis.conf in the\n# root folder. Specifically, REDISPORT should always be the same as the port in\n# redis.conf.\nREDISHOST = 'localhost'\nREDISPORT = 6379\n\n# The DB numbers for various Redis instances that Oppia uses. Do not reuse these\n# if you're creating a new Redis client.\nOPPIA_REDIS_DB_INDEX = 0\nCLOUD_NDB_REDIS_DB_INDEX = 1\nSTORAGE_EMULATOR_REDIS_DB_INDEX = 2\n\n\n# NOTE TO RELEASE COORDINATORS: Replace this project id with the correct oppia\n# project id when switching to the prod server.\nOPPIA_PROJECT_ID = 'dev-project-id'\nGOOGLE_APP_ENGINE_REGION = 'us-central1'\n\n# NOTE TO RELEASE COORDINATORS: Replace these GCS bucket paths with real prod\n# buckets. It's OK for them to be the same.\nDATAFLOW_TEMP_LOCATION = 'gs://todo/todo'\nDATAFLOW_STAGING_LOCATION = 'gs://todo/todo'\n\nOPPIA_VERSION = '3.2.1'\nOPPIA_PYTHON_PACKAGE_PATH = './build/oppia-beam-job-%s.tar.gz' % OPPIA_VERSION\n\n# Committer id for system actions. The username for the system committer\n# (i.e. admin) is also 'admin'.\nSYSTEM_COMMITTER_ID = 'admin'\n# Domain name for email address.\nINCOMING_EMAILS_DOMAIN_NAME = 'example.com'\nSYSTEM_EMAIL_ADDRESS = 'system@example.com'\nSYSTEM_EMAIL_NAME = '.'\nADMIN_EMAIL_ADDRESS = 'testadmin@example.com'\nNOREPLY_EMAIL_ADDRESS = 'noreply@example.com'\n# Ensure that SYSTEM_EMAIL_ADDRESS and ADMIN_EMAIL_ADDRESS are both valid and\n# correspond to owners of the app before setting this to True. If\n# SYSTEM_EMAIL_ADDRESS is not that of an app owner, email messages from this\n# address cannot be sent. If True then emails can be sent to any user.\nCAN_SEND_EMAILS = False\n# If you want to turn on this facility please check the email templates in the\n# send_role_notification_email() function in email_manager.py and modify them\n# accordingly.\nCAN_SEND_EDITOR_ROLE_EMAILS = False\n# If enabled then emails will be sent to creators for feedback messages.\nCAN_SEND_FEEDBACK_MESSAGE_EMAILS = False\n# If enabled subscription emails will be sent to that user.\nCAN_SEND_SUBSCRIPTION_EMAILS = False\n# Time to wait before sending feedback message emails (currently set to 1\n# hour).\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_COUNTDOWN_SECS = 3600\n# Whether to send an email when new feedback message is received for\n# an exploration.\nDEFAULT_FEEDBACK_MESSAGE_EMAIL_PREFERENCE = True\n# Whether to send an email to all the creator's subscribers when he/she\n# publishes an exploration.\nDEFAULT_SUBSCRIPTION_EMAIL_PREFERENCE = True\n# Whether exploration feedback emails are muted,\n# when the user has not specified a preference.\nDEFAULT_FEEDBACK_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether exploration suggestion emails are muted,\n# when the user has not specified a preference.\nDEFAULT_SUGGESTION_NOTIFICATIONS_MUTED_PREFERENCE = False\n# Whether to send email updates to a user who has not specified a preference.\nDEFAULT_EMAIL_UPDATES_PREFERENCE = False\n# Whether to send an invitation email when the user is granted\n# new role permissions in an exploration.\nDEFAULT_EDITOR_ROLE_EMAIL_PREFERENCE = True\n# Whether to require an email to be sent, following a moderator action.\nREQUIRE_EMAIL_ON_MODERATOR_ACTION = False\n# Timespan in minutes before allowing duplicate emails.\nDUPLICATE_EMAIL_INTERVAL_MINS = 2\n# Number of digits after decimal to which the average ratings value in the\n# dashboard is rounded off to.\nAVERAGE_RATINGS_DASHBOARD_PRECISION = 2\n# Whether to enable maintenance mode on the site. For non-admins, this redirects\n# all HTTP requests to the maintenance page. This is the only check which\n# determines whether the site is in maintenance mode to avoid queries to the\n# database by non-admins.\nENABLE_MAINTENANCE_MODE = False\n\n# The interactions permissible for a question.\nALLOWED_QUESTION_INTERACTION_IDS = [\n    'TextInput', 'MultipleChoiceInput', 'NumericInput']\n\n# Flag to disable sending emails related to reviews for suggestions. To be\n# flipped after deciding (and implementing) whether a user should be scored\n# only for curated lessons.\nSEND_SUGGESTION_REVIEW_RELATED_EMAILS = False\n# To prevent recording scores for users until details like whether to score\n# users for only curated lessons is confirmed.\nENABLE_RECORDING_OF_SCORES = False\n\n# No. of pretest questions to display.\nNUM_PRETEST_QUESTIONS = 0\n\nEMAIL_INTENT_SIGNUP = 'signup'\nEMAIL_INTENT_DAILY_BATCH = 'daily_batch'\nEMAIL_INTENT_EDITOR_ROLE_NOTIFICATION = 'editor_role_notification'\nEMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION = 'feedback_message_notification'\nEMAIL_INTENT_SUBSCRIPTION_NOTIFICATION = 'subscription_notification'\nEMAIL_INTENT_SUGGESTION_NOTIFICATION = 'suggestion_notification'\nEMAIL_INTENT_REPORT_BAD_CONTENT = 'report_bad_content'\nEMAIL_INTENT_MARKETING = 'marketing'\nEMAIL_INTENT_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nEMAIL_INTENT_DELETE_EXPLORATION = 'delete_exploration'\nEMAIL_INTENT_QUERY_STATUS_NOTIFICATION = 'query_status_notification'\nEMAIL_INTENT_ONBOARD_REVIEWER = 'onboard_reviewer'\nEMAIL_INTENT_REMOVE_REVIEWER = 'remove_reviewer'\nEMAIL_INTENT_ADDRESS_CONTRIBUTOR_DASHBOARD_SUGGESTIONS = (\n    'address_contributor_dashboard_suggestions'\n)\nEMAIL_INTENT_REVIEW_CREATOR_DASHBOARD_SUGGESTIONS = (\n    'review_creator_dashboard_suggestions')\nEMAIL_INTENT_REVIEW_CONTRIBUTOR_DASHBOARD_SUGGESTIONS = (\n    'review_contributor_dashboard_suggestions'\n)\nEMAIL_INTENT_ADD_CONTRIBUTOR_DASHBOARD_REVIEWERS = (\n    'add_contributor_dashboard_reviewers'\n)\nEMAIL_INTENT_VOICEOVER_APPLICATION_UPDATES = 'voiceover_application_updates'\nEMAIL_INTENT_ACCOUNT_DELETED = 'account_deleted'\n# Possible intents for email sent in bulk.\nBULK_EMAIL_INTENT_MARKETING = 'bulk_email_marketing'\nBULK_EMAIL_INTENT_IMPROVE_EXPLORATION = 'bulk_email_improve_exploration'\nBULK_EMAIL_INTENT_CREATE_EXPLORATION = 'bulk_email_create_exploration'\nBULK_EMAIL_INTENT_CREATOR_REENGAGEMENT = 'bulk_email_creator_reengagement'\nBULK_EMAIL_INTENT_LEARNER_REENGAGEMENT = 'bulk_email_learner_reengagement'\nBULK_EMAIL_INTENT_ML_JOB_FAILURE = 'bulk_email_ml_job_failure'\nBULK_EMAIL_INTENT_TEST = 'bulk_email_test'\n\nMESSAGE_TYPE_FEEDBACK = 'feedback'\nMESSAGE_TYPE_SUGGESTION = 'suggestion'\n\nMODERATOR_ACTION_UNPUBLISH_EXPLORATION = 'unpublish_exploration'\nDEFAULT_SALUTATION_HTML_FN = (\n    lambda recipient_username: 'Hi %s,' % recipient_username)\nDEFAULT_SIGNOFF_HTML_FN = (\n    lambda sender_username: (\n        'Thanks!<br>%s (Oppia moderator)' % sender_username))\n\nVALID_MODERATOR_ACTIONS = {\n    MODERATOR_ACTION_UNPUBLISH_EXPLORATION: {\n        'email_config': 'unpublish_exploration_email_html_body',\n        'email_subject_fn': (\n            lambda exp_title: (\n                'Your Oppia exploration \"%s\" has been unpublished' % exp_title)\n        ),\n        'email_intent': 'unpublish_exploration',\n        'email_salutation_html_fn': DEFAULT_SALUTATION_HTML_FN,\n        'email_signoff_html_fn': DEFAULT_SIGNOFF_HTML_FN,\n    },\n}\n\n# When the site terms were last updated, in UTC.\nREGISTRATION_PAGE_LAST_UPDATED_UTC = datetime.datetime(2015, 10, 14, 2, 40, 0)\n\n# Format of string for dashboard statistics logs.\n# NOTE TO DEVELOPERS: This format should not be changed, since it is used in\n# the existing storage models for UserStatsModel.\nDASHBOARD_STATS_DATETIME_STRING_FORMAT = '%Y-%m-%d'\n\n# Timestamp in sec since epoch for Mar 1 2021 12:00:00 UTC for the earliest\n# datetime that a report could be received.\nEARLIEST_APP_FEEDBACK_REPORT_DATETIME = datetime.datetime.fromtimestamp(\n    1614556800)\n\n# The minimum and maximum package version codes for Oppia Android.\nMINIMUM_ANDROID_PACKAGE_VERSION_CODE = 1\n\n# We generate images for existing math rich text components in batches. This\n# gives the maximum size for a batch of Math SVGs in bytes.\nMAX_SIZE_OF_MATH_SVGS_BATCH_BYTES = 31 * 1024 * 1024\n\n# The maximum size of an uploaded file, in bytes.\nMAX_FILE_SIZE_BYTES = 1048576\n\n# The maximum playback length of an audio file, in seconds.\nMAX_AUDIO_FILE_LENGTH_SEC = 300\n\n# The maximum number of questions to be fetched at one time.\nMAX_QUESTIONS_FETCHABLE_AT_ONE_TIME = 20\n\n# The minimum score required for a user to review suggestions of a particular\n# category.\nMINIMUM_SCORE_REQUIRED_TO_REVIEW = 10\n\n# The maximum number of skills to be requested at one time when fetching\n# questions.\nMAX_NUMBER_OF_SKILL_IDS = 20\n\n# The maximum number of blog post cards to be visible on each page in blog\n# homepage.\nMAX_NUM_CARDS_TO_DISPLAY_ON_BLOG_HOMEPAGE = 10\n\n# The maximum number of blog post cards to be visible on each page in author\n# specific blog post page.\nMAX_NUM_CARDS_TO_DISPLAY_ON_AUTHOR_SPECIFIC_BLOG_POST_PAGE = 12\n\n# The maximum number of blog post cards to be visible as suggestions on the\n# blog post page.\nMAX_POSTS_TO_RECOMMEND_AT_END_OF_BLOG_POST = 2\n\n# The prefix for an 'accepted suggestion' commit message.\nCOMMIT_MESSAGE_ACCEPTED_SUGGESTION_PREFIX = 'Accepted suggestion by'\n\n# User id and username for exploration migration bot. Commits made by this bot\n# are not reflected in the exploration summary models, but are recorded in the\n# exploration commit log.\nMIGRATION_BOT_USER_ID = 'OppiaMigrationBot'\nMIGRATION_BOT_USERNAME = 'OppiaMigrationBot'\n\n# User id for scrubber bot. This bot is used to represent the cron job that\n# scrubs expired app feedback reports.\nAPP_FEEDBACK_REPORT_SCRUBBER_BOT_ID = 'AppFeedbackReportScrubberBot'\nAPP_FEEDBACK_REPORT_SCRUBBER_BOT_USERNAME = 'AppFeedbackReportScrubberBot'\n\n# User id and username for suggestion bot. This bot will be used to accept\n# suggestions automatically after a threshold time.\nSUGGESTION_BOT_USER_ID = 'OppiaSuggestionBot'\nSUGGESTION_BOT_USERNAME = 'OppiaSuggestionBot'\n\n# The system usernames are reserved usernames. Before adding new value to this\n# dict, make sure that there aren't any similar usernames in the datastore.\n# Note: All bot user IDs and usernames should start with \"Oppia\" and end with\n# \"Bot\".\nSYSTEM_USERS = {\n    SYSTEM_COMMITTER_ID: SYSTEM_COMMITTER_ID,\n    MIGRATION_BOT_USER_ID: MIGRATION_BOT_USERNAME,\n    SUGGESTION_BOT_USER_ID: SUGGESTION_BOT_USERNAME,\n    APP_FEEDBACK_REPORT_SCRUBBER_BOT_ID: (\n        APP_FEEDBACK_REPORT_SCRUBBER_BOT_USERNAME)\n}\n\n# Ids and locations of the permitted extensions.\nALLOWED_RTE_EXTENSIONS = {\n    'Collapsible': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Collapsible')\n    },\n    'Image': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Image')\n    },\n    'Link': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Link')\n    },\n    'Math': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Math')\n    },\n    'Tabs': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Tabs')\n    },\n    'Video': {\n        'dir': os.path.join(RTE_EXTENSIONS_DIR, 'Video')\n    },\n}\n\n# The list of interaction IDs which correspond to interactions that set their\n# is_linear property to true. Linear interactions do not support branching and\n# thus only allow for default answer classification. This value is guarded by a\n# test in extensions.interactions.base_test.\nLINEAR_INTERACTION_IDS = ['Continue']\n\n# Demo explorations to load through the admin panel. The id assigned to each\n# exploration is based on the key of the exploration in this dict, so ensure it\n# doesn't change once it's in the list. Only integer-based indices should be\n# used in this list, as it maintains backward compatibility with how demo\n# explorations used to be assigned IDs. The value of each entry in this dict is\n# either a YAML file or a directory (depending on whether it ends in .yaml).\n# These explorations can be found under data/explorations.\nDEMO_EXPLORATIONS = {\n    u'0': 'welcome',\n    u'1': 'multiples.yaml',\n    u'2': 'binary_search',\n    u'3': 'root_linear_coefficient_theorem',\n    u'4': 'three_balls',\n    # TODO(bhenning): Replace demo exploration '5' with a new exploration\n    # described in #1376.\n    u'6': 'boot_verbs.yaml',\n    u'7': 'hola.yaml',\n    u'8': 'adventure.yaml',\n    u'9': 'pitch_perfect.yaml',\n    u'10': 'test_interactions',\n    u'11': 'modeling_graphs',\n    u'12': 'protractor_test_1.yaml',\n    u'13': 'solar_system',\n    u'14': 'about_oppia.yaml',\n    u'15': 'classifier_demo_exploration.yaml',\n    u'16': 'all_interactions',\n    u'17': 'audio_test',\n    # Exploration with ID 18 was used for testing CodeClassifier functionality\n    # which has been removed (#10060).\n    u'19': 'example_exploration_in_collection1.yaml',\n    u'20': 'example_exploration_in_collection2.yaml',\n    u'21': 'example_exploration_in_collection3.yaml',\n    u'22': 'protractor_mobile_test_exploration.yaml',\n    u'23': 'rating_test.yaml',\n    u'24': 'learner_flow_test.yaml',\n    u'25': 'exploration_player_test.yaml',\n    u'26': 'android_interactions',\n}\n\nDEMO_COLLECTIONS = {\n    u'0': 'welcome_to_collections.yaml',\n    u'1': 'learner_flow_test_collection.yaml'\n}\n\n# IDs of explorations which should not be displayable in either the learner or\n# editor views.\nDISABLED_EXPLORATION_IDS = ['5']\n\n# Oppia Google Group URL.\nGOOGLE_GROUP_URL = (\n    'https://groups.google.com/forum/?place=forum/oppia#!forum/oppia')\n\n# NOTE TO RELEASE COORDINATORS: External URL for the oppia production site.\n# Change to the correct url for internal testing in the testing production\n# environment.\n# Change to the production URL when deploying to production site.\nOPPIA_SITE_URL = 'http://localhost:8181'\n\n# Prefix for all taskqueue-related URLs.\nTASKQUEUE_URL_PREFIX = '/task'\nTASK_URL_FEEDBACK_MESSAGE_EMAILS = (\n    '%s/email/batchfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FEEDBACK_STATUS_EMAILS = (\n    '%s/email/feedbackthreadstatuschangeemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_FLAG_EXPLORATION_EMAILS = (\n    '%s/email/flagexplorationemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_INSTANT_FEEDBACK_EMAILS = (\n    '%s/email/instantfeedbackmessageemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_SUGGESTION_EMAILS = (\n    '%s/email/suggestionemailhandler' % TASKQUEUE_URL_PREFIX)\nTASK_URL_DEFERRED = (\n    '%s/deferredtaskshandler' % TASKQUEUE_URL_PREFIX)\n\n# TODO(sll): Add all other URLs here.\nABOUT_FOUNDATION_PAGE_URL = '/about-foundation'\nADMIN_URL = '/admin'\nADMIN_ROLE_HANDLER_URL = '/adminrolehandler'\nBLOG_ADMIN_PAGE_URL = '/blog-admin'\nBLOG_ADMIN_ROLE_HANDLER_URL = '/blogadminrolehandler'\nBLOG_DASHBOARD_DATA_URL = '/blogdashboardhandler/data'\nBLOG_DASHBOARD_URL = '/blog-dashboard'\nBLOG_EDITOR_DATA_URL_PREFIX = '/blogeditorhandler/data'\nBULK_EMAIL_WEBHOOK_ENDPOINT = '/bulk_email_webhook_endpoint'\nBLOG_HOMEPAGE_DATA_URL = '/blogdatahandler/data'\nBLOG_HOMEPAGE_URL = '/blog'\nAUTHOR_SPECIFIC_BLOG_POST_PAGE_URL_PREFIX = '/blog/author'\nCLASSROOM_DATA_HANDLER = '/classroom_data_handler'\nCOLLECTION_DATA_URL_PREFIX = '/collection_handler/data'\nCOLLECTION_EDITOR_DATA_URL_PREFIX = '/collection_editor_handler/data'\nCOLLECTION_SUMMARIES_DATA_URL = '/collectionsummarieshandler/data'\nCOLLECTION_RIGHTS_PREFIX = '/collection_editor_handler/rights'\nCOLLECTION_PUBLISH_PREFIX = '/collection_editor_handler/publish'\nCOLLECTION_UNPUBLISH_PREFIX = '/collection_editor_handler/unpublish'\nCOLLECTION_EDITOR_URL_PREFIX = '/collection_editor/create'\nCOLLECTION_URL_PREFIX = '/collection'\nCONCEPT_CARD_DATA_URL_PREFIX = '/concept_card_handler'\nCONTRIBUTOR_DASHBOARD_URL = '/contributor-dashboard'\nCONTRIBUTOR_DASHBOARD_ADMIN_URL = '/contributor-dashboard-admin'\nCONTRIBUTOR_OPPORTUNITIES_DATA_URL = '/opportunitiessummaryhandler'\nCREATOR_DASHBOARD_DATA_URL = '/creatordashboardhandler/data'\nCREATOR_DASHBOARD_URL = '/creator-dashboard'\nCSRF_HANDLER_URL = '/csrfhandler'\nCUSTOM_NONPROFITS_LANDING_PAGE_URL = '/nonprofits'\nCUSTOM_PARENTS_LANDING_PAGE_URL = '/parents'\nCUSTOM_PARTNERS_LANDING_PAGE_URL = '/partners'\nCUSTOM_TEACHERS_LANDING_PAGE_URL = '/teachers'\nCUSTOM_VOLUNTEERS_LANDING_PAGE_URL = '/volunteers'\nDASHBOARD_CREATE_MODE_URL = '%s?mode=create' % CREATOR_DASHBOARD_URL\nEDITOR_URL_PREFIX = '/create'\nEXPLORATION_DATA_PREFIX = '/createhandler/data'\nEXPLORATION_IMAGE_UPLOAD_PREFIX = '/createhandler/imageupload'\nEXPLORATION_FEATURES_PREFIX = '/explorehandler/features'\nEXPLORATION_INIT_URL_PREFIX = '/explorehandler/init'\nEXPLORATION_LEARNER_ANSWER_DETAILS = (\n    '/learneranswerinfohandler/learner_answer_details')\nEXPLORATION_METADATA_SEARCH_URL = '/exploration/metadata_search'\nEXPLORATION_PRETESTS_URL_PREFIX = '/pretest_handler'\nEXPLORATION_RIGHTS_PREFIX = '/createhandler/rights'\nEXPLORATION_STATE_ANSWER_STATS_PREFIX = '/createhandler/state_answer_stats'\nEXPLORATION_STATUS_PREFIX = '/createhandler/status'\nEXPLORATION_SUMMARIES_DATA_URL = '/explorationsummarieshandler/data'\nEXPLORATION_URL_PREFIX = '/explore'\nEXPLORATION_URL_EMBED_PREFIX = '/embed/exploration'\nFEEDBACK_STATS_URL_PREFIX = '/feedbackstatshandler'\nFEEDBACK_THREAD_URL_PREFIX = '/threadhandler'\nFEEDBACK_THREADLIST_URL_PREFIX = '/threadlisthandler'\nFEEDBACK_THREADLIST_URL_PREFIX_FOR_TOPICS = '/threadlisthandlerfortopic'\nFEEDBACK_THREAD_VIEW_EVENT_URL = '/feedbackhandler/thread_view_event'\nFETCH_SKILLS_URL_PREFIX = '/fetch_skills'\nFLAG_EXPLORATION_URL_PREFIX = '/flagexplorationhandler'\nFRACTIONS_LANDING_PAGE_URL = '/fractions'\nIMPROVEMENTS_URL_PREFIX = '/improvements'\nIMPROVEMENTS_HISTORY_URL_PREFIX = '/improvements/history'\nIMPROVEMENTS_CONFIG_URL_PREFIX = '/improvements/config'\nLEARNER_ANSWER_INFO_HANDLER_URL = (\n    '/learneranswerinfohandler/learner_answer_details')\nLEARNER_ANSWER_DETAILS_SUBMIT_URL = '/learneranswerdetailshandler'\nLEARNER_DASHBOARD_URL = '/learner-dashboard'\nLEARNER_DASHBOARD_TOPIC_AND_STORY_DATA_URL = (\n    '/learnerdashboardtopicsandstoriesprogresshandler/data')\nLEARNER_DASHBOARD_COLLECTION_DATA_URL = (\n    '/learnerdashboardcollectionsprogresshandler/data')\nLEARNER_DASHBOARD_EXPLORATION_DATA_URL = (\n    '/learnerdashboardexplorationsprogresshandler/data')\nLEARNER_DASHBOARD_FEEDBACK_UPDATES_DATA_URL = (\n    '/learnerdashboardfeedbackupdateshandler/data')\nLEARNER_DASHBOARD_IDS_DATA_URL = '/learnerdashboardidshandler/data'\nLEARNER_DASHBOARD_FEEDBACK_THREAD_DATA_URL = '/learnerdashboardthreadhandler'\nLEARNER_GOALS_DATA_URL = '/learnergoalshandler'\nLEARNER_PLAYLIST_DATA_URL = '/learnerplaylistactivityhandler'\nLEARNER_INCOMPLETE_ACTIVITY_DATA_URL = '/learnerincompleteactivityhandler'\nLIBRARY_GROUP_DATA_URL = '/librarygrouphandler'\nLIBRARY_INDEX_URL = '/community-library'\nLIBRARY_INDEX_DATA_URL = '/libraryindexhandler'\nLIBRARY_RECENTLY_PUBLISHED_URL = '/community-library/recently-published'\nLIBRARY_SEARCH_URL = '/search/find'\nLIBRARY_SEARCH_DATA_URL = '/searchhandler/data'\nLIBRARY_TOP_RATED_URL = '/community-library/top-rated'\nMACHINE_TRANSLATION_DATA_URL = '/machine_translated_state_texts_handler'\nMERGE_SKILLS_URL = '/merge_skills_handler'\nNEW_COLLECTION_URL = '/collection_editor_handler/create_new'\nNEW_EXPLORATION_URL = '/contributehandler/create_new'\nNEW_QUESTION_URL = '/question_editor_handler/create_new'\nNEW_SKILL_URL = '/skill_editor_handler/create_new'\nTOPIC_EDITOR_STORY_URL = '/topic_editor_story_handler'\nTOPIC_EDITOR_QUESTION_URL = '/topic_editor_question_handler'\nNEW_TOPIC_URL = '/topic_editor_handler/create_new'\nPREFERENCES_URL = '/preferences'\nPRACTICE_SESSION_URL_PREFIX = '/practice_session'\nPRACTICE_SESSION_DATA_URL_PREFIX = '/practice_session/data'\nPREFERENCES_DATA_URL = '/preferenceshandler/data'\nQUESTION_EDITOR_DATA_URL_PREFIX = '/question_editor_handler/data'\nQUESTION_SKILL_LINK_URL_PREFIX = '/manage_question_skill_link'\nQUESTIONS_LIST_URL_PREFIX = '/questions_list_handler'\nQUESTION_COUNT_URL_PREFIX = '/question_count_handler'\nQUESTIONS_URL_PREFIX = '/question_player_handler'\nRECENT_COMMITS_DATA_URL = '/recentcommitshandler/recent_commits'\nRECENT_FEEDBACK_MESSAGES_DATA_URL = '/recent_feedback_messages'\nDELETE_ACCOUNT_URL = '/delete-account'\nDELETE_ACCOUNT_HANDLER_URL = '/delete-account-handler'\nEXPORT_ACCOUNT_HANDLER_URL = '/export-account-handler'\nPENDING_ACCOUNT_DELETION_URL = '/pending-account-deletion'\nREVIEW_TEST_DATA_URL_PREFIX = '/review_test_handler/data'\nREVIEW_TEST_URL_PREFIX = '/review_test'\nROBOTS_TXT_URL = '/robots.txt'\nSITE_LANGUAGE_DATA_URL = '/save_site_language'\nSIGNUP_DATA_URL = '/signuphandler/data'\nSIGNUP_URL = '/signup'\nSKILL_DASHBOARD_DATA_URL = '/skills_dashboard/data'\nSKILL_DATA_URL_PREFIX = '/skill_data_handler'\nSKILL_EDITOR_DATA_URL_PREFIX = '/skill_editor_handler/data'\nSKILL_EDITOR_URL_PREFIX = '/skill_editor'\nSKILL_EDITOR_QUESTION_URL = '/skill_editor_question_handler'\nSKILL_MASTERY_DATA_URL = '/skill_mastery_handler/data'\nSKILL_RIGHTS_URL_PREFIX = '/skill_editor_handler/rights'\nSKILL_DESCRIPTION_HANDLER = '/skill_description_handler'\nSTORY_DATA_HANDLER = '/story_data_handler'\nSTORY_EDITOR_URL_PREFIX = '/story_editor'\nSTORY_EDITOR_DATA_URL_PREFIX = '/story_editor_handler/data'\nSTORY_PROGRESS_URL_PREFIX = '/story_progress_handler'\nSTORY_PUBLISH_HANDLER = '/story_publish_handler'\nSTORY_URL_FRAGMENT_HANDLER = '/story_url_fragment_handler'\nSTORY_VIEWER_URL_PREFIX = '/story'\nSUBTOPIC_DATA_HANDLER = '/subtopic_data_handler'\n# This should be synchronized with SUBTOPIC_MASTERY_DATA_URL_TEMPLATE\n# in app.constants.ts.\nSUBTOPIC_MASTERY_DATA_URL = '/subtopic_mastery_handler/data'\nSUBTOPIC_VIEWER_URL_PREFIX = '/subtopic'\nSUGGESTION_ACTION_URL_PREFIX = '/suggestionactionhandler'\nSUGGESTION_LIST_URL_PREFIX = '/suggestionlisthandler'\nSUGGESTION_URL_PREFIX = '/suggestionhandler'\nUPDATE_TRANSLATION_SUGGESTION_URL_PREFIX = (\n    '/updatetranslationsuggestionhandler')\nUPDATE_QUESTION_SUGGESTION_URL_PREFIX = (\n    '/updatequestionsuggestionhandler')\nSUBSCRIBE_URL_PREFIX = '/subscribehandler'\nSUBTOPIC_PAGE_EDITOR_DATA_URL_PREFIX = '/subtopic_page_editor_handler/data'\nTOPIC_VIEWER_URL_PREFIX = (\n    '/learn/<classroom_url_fragment>/<topic_url_fragment>')\nTOPIC_DATA_HANDLER = '/topic_data_handler'\nTOPIC_EDITOR_DATA_URL_PREFIX = '/topic_editor_handler/data'\nTOPIC_EDITOR_URL_PREFIX = '/topic_editor'\nTOPIC_NAME_HANDLER = '/topic_name_handler'\nTOPIC_RIGHTS_URL_PREFIX = '/rightshandler/get_topic_rights'\nTOPIC_SEND_MAIL_URL_PREFIX = '/rightshandler/send_topic_publish_mail'\nTOPIC_STATUS_URL_PREFIX = '/rightshandler/change_topic_status'\nTOPIC_URL_FRAGMENT_HANDLER = '/topic_url_fragment_handler'\nTOPICS_AND_SKILLS_DASHBOARD_DATA_URL = '/topics_and_skills_dashboard/data'\nUNASSIGN_SKILL_DATA_HANDLER_URL = '/topics_and_skills_dashboard/unassign_skill'\nTOPICS_AND_SKILLS_DASHBOARD_URL = '/topics-and-skills-dashboard'\nUNSUBSCRIBE_URL_PREFIX = '/unsubscribehandler'\nUPLOAD_EXPLORATION_URL = '/contributehandler/upload'\nUSER_EXPLORATION_EMAILS_PREFIX = '/createhandler/notificationpreferences'\nUSER_PERMISSIONS_URL_PREFIX = '/createhandler/permissions'\nUSERNAME_CHECK_DATA_URL = '/usernamehandler/data'\nVALIDATE_STORY_EXPLORATIONS_URL_PREFIX = '/validate_story_explorations'\n\n# Event types.\nEVENT_TYPE_ALL_STATS = 'all_stats'\nEVENT_TYPE_STATE_HIT = 'state_hit'\nEVENT_TYPE_STATE_COMPLETED = 'state_complete'\nEVENT_TYPE_ANSWER_SUBMITTED = 'answer_submitted'\nEVENT_TYPE_DEFAULT_ANSWER_RESOLVED = 'default_answer_resolved'\nEVENT_TYPE_NEW_THREAD_CREATED = 'feedback_thread_created'\nEVENT_TYPE_THREAD_STATUS_CHANGED = 'feedback_thread_status_changed'\nEVENT_TYPE_RATE_EXPLORATION = 'rate_exploration'\nEVENT_TYPE_SOLUTION_HIT = 'solution_hit'\nEVENT_TYPE_LEAVE_FOR_REFRESHER_EXP = 'leave_for_refresher_exp'\n# The values for these event types should be left as-is for backwards\n# compatibility.\nEVENT_TYPE_START_EXPLORATION = 'start'\nEVENT_TYPE_ACTUAL_START_EXPLORATION = 'actual_start'\nEVENT_TYPE_MAYBE_LEAVE_EXPLORATION = 'leave'\nEVENT_TYPE_COMPLETE_EXPLORATION = 'complete'\n\n# Play type constants.\nPLAY_TYPE_PLAYTEST = 'playtest'\nPLAY_TYPE_NORMAL = 'normal'\n\n# Predefined commit messages.\nCOMMIT_MESSAGE_EXPLORATION_DELETED = 'Exploration deleted.'\nCOMMIT_MESSAGE_COLLECTION_DELETED = 'Collection deleted.'\nCOMMIT_MESSAGE_QUESTION_DELETED = 'Question deleted.'\nCOMMIT_MESSAGE_SKILL_DELETED = 'Skill deleted.'\nCOMMIT_MESSAGE_STORY_DELETED = 'Story deleted.'\nCOMMIT_MESSAGE_SUBTOPIC_PAGE_DELETED = 'Subtopic page deleted.'\nCOMMIT_MESSAGE_TOPIC_DELETED = 'Topic deleted.'\n\n# Max number of playthroughs for an issue.\nMAX_PLAYTHROUGHS_FOR_ISSUE = 5\n\n# Number of unresolved answers to be displayed in the dashboard for each\n# exploration.\nTOP_UNRESOLVED_ANSWERS_COUNT_DASHBOARD = 3\n# Number of open feedback to be displayed in the dashboard for each exploration.\nOPEN_FEEDBACK_COUNT_DASHBOARD = 3\n# NOTE TO DEVELOPERS: This should be synchronized with app.constants.ts.\nENABLE_ML_CLASSIFIERS = False\n\n# The regular expression used to identify whether a string contains float value.\n# The regex must match with regex that is stored in vmconf.py file of Oppia-ml.\n# If this regex needs to be modified then first of all shutdown Oppia-ml VM.\n# Then update the regex constant in here and Oppia both.\n# Run any migration job that is required to migrate existing trained models\n# before starting Oppia-ml again.\nFLOAT_VERIFIER_REGEX = (\n    '^([-+]?\\\\d*\\\\.\\\\d+)$|^([-+]?(\\\\d*\\\\.?\\\\d+|\\\\d+\\\\.?\\\\d*)e[-+]?\\\\d*)$')\n\n# Current event models schema version. All event models with an\n# event_schema_version of 1 are the events collected before the rework of the\n# statistics framework which brought about the recording of new event models;\n# these models include all models recorded before Feb 2018.\nCURRENT_EVENT_MODELS_SCHEMA_VERSION = 2\n\n# Output formats of downloaded explorations.\nOUTPUT_FORMAT_JSON = 'json'\nOUTPUT_FORMAT_ZIP = 'zip'\n\n# Types of updates shown in the 'recent updates' table in the dashboard page.\nUPDATE_TYPE_EXPLORATION_COMMIT = 'exploration_commit'\nUPDATE_TYPE_COLLECTION_COMMIT = 'collection_commit'\nUPDATE_TYPE_FEEDBACK_MESSAGE = 'feedback_thread'\n\n# Possible values for user query status.\n# Valid status transitions are: processing --> completed --> archived\n# or processing --> failed.\nUSER_QUERY_STATUS_PROCESSING = 'processing'\nUSER_QUERY_STATUS_COMPLETED = 'completed'\nUSER_QUERY_STATUS_ARCHIVED = 'archived'\nUSER_QUERY_STATUS_FAILED = 'failed'\n\nALLOWED_USER_QUERY_STATUSES = (\n    USER_QUERY_STATUS_PROCESSING,\n    USER_QUERY_STATUS_COMPLETED,\n    USER_QUERY_STATUS_ARCHIVED,\n    USER_QUERY_STATUS_FAILED\n)\n\n# The time difference between which to consider two login events \"close\". This\n# is taken to be 12 hours.\nPROXIMAL_TIMEDELTA_SECS = 12 * 60 * 60\n\n# The i18n id for the header of the \"Featured Activities\" category in the\n# library index page.\nLIBRARY_CATEGORY_FEATURED_ACTIVITIES = 'I18N_LIBRARY_GROUPS_FEATURED_ACTIVITIES'\n# The i18n id for the header of the \"Top Rated Explorations\" category in the\n# library index page.\nLIBRARY_CATEGORY_TOP_RATED_EXPLORATIONS = (\n    'I18N_LIBRARY_GROUPS_TOP_RATED_EXPLORATIONS')\n# The i18n id for the header of the \"Recently Published\" category in the\n# library index page.\nLIBRARY_CATEGORY_RECENTLY_PUBLISHED = 'I18N_LIBRARY_GROUPS_RECENTLY_PUBLISHED'\n\n# The group name that appears at the end of the url for the recently published\n# page.\nLIBRARY_GROUP_RECENTLY_PUBLISHED = 'recently-published'\n# The group name that appears at the end of the url for the top rated page.\nLIBRARY_GROUP_TOP_RATED = 'top-rated'\n\n# Defaults for topic similarities.\nDEFAULT_TOPIC_SIMILARITY = 0.5\nSAME_TOPIC_SIMILARITY = 1.0\n\n# The type of the response returned by a handler when an exception is raised.\nHANDLER_TYPE_HTML = 'html'\nHANDLER_TYPE_JSON = 'json'\nHANDLER_TYPE_DOWNLOADABLE = 'downloadable'\n\n# Following are the constants for the role IDs.\n# TODO(#13388): The role id variable name doesn't match the string value,\n# write a one-off job to update the string value in the datastore.\nROLE_ID_CURRICULUM_ADMIN = 'ADMIN'\nROLE_ID_BLOG_ADMIN = 'BLOG_ADMIN'\nROLE_ID_BLOG_POST_EDITOR = 'BLOG_POST_EDITOR'\nROLE_ID_COLLECTION_EDITOR = 'COLLECTION_EDITOR'\nROLE_ID_FULL_USER = 'EXPLORATION_EDITOR'\nROLE_ID_GUEST = 'GUEST'\nROLE_ID_MOBILE_LEARNER = 'LEARNER'\nROLE_ID_MODERATOR = 'MODERATOR'\nROLE_ID_QUESTION_ADMIN = 'QUESTION_ADMIN'\nROLE_ID_RELEASE_COORDINATOR = 'RELEASE_COORDINATOR'\nROLE_ID_TOPIC_MANAGER = 'TOPIC_MANAGER'\nROLE_ID_TRANSLATION_ADMIN = 'TRANSLATION_ADMIN'\nROLE_ID_VOICEOVER_ADMIN = 'VOICEOVER_ADMIN'\n\nALLOWED_DEFAULT_USER_ROLES_ON_REGISTRATION = [\n    ROLE_ID_FULL_USER, ROLE_ID_MOBILE_LEARNER]\n\nALLOWED_USER_ROLES = [\n    ROLE_ID_CURRICULUM_ADMIN,\n    ROLE_ID_BLOG_ADMIN,\n    ROLE_ID_BLOG_POST_EDITOR,\n    ROLE_ID_COLLECTION_EDITOR,\n    ROLE_ID_FULL_USER,\n    ROLE_ID_GUEST,\n    ROLE_ID_MOBILE_LEARNER,\n    ROLE_ID_MODERATOR,\n    ROLE_ID_QUESTION_ADMIN,\n    ROLE_ID_RELEASE_COORDINATOR,\n    ROLE_ID_TOPIC_MANAGER,\n    ROLE_ID_TRANSLATION_ADMIN,\n    ROLE_ID_VOICEOVER_ADMIN\n]\n\n# Intent of the User making query to role structure via admin interface. Used\n# to store audit data regarding queries to role IDs.\nROLE_ACTION_ADD = 'add'\nROLE_ACTION_REMOVE = 'remove'\nDEPRECATED_ROLE_ACTION_UPDATE = 'update'\nROLE_ACTION_VIEW_BY_USERNAME = 'view_by_username'\nROLE_ACTION_VIEW_BY_ROLE = 'view_by_role'\n\nUSER_FILTER_CRITERION_ROLE = 'role'\nUSER_FILTER_CRITERION_USERNAME = 'username'\n\n# Max questions allowed in a session of practice questions.\nQUESTION_BATCH_SIZE = 10\n\nSTATE_ANSWER_STATS_MIN_FREQUENCY = 2\n\nRTE_FORMAT_TEXTANGULAR = 'text-angular'\n\nRTE_FORMAT_CKEDITOR = 'ck-editor'\n\n# RTE content specifications according to the type of the editor.\nRTE_CONTENT_SPEC = {\n    'RTE_TYPE_TEXTANGULAR': {\n        # Valid parent-child relation in TextAngular.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', 'div', 'pre', '[document]', 'ol', 'ul', 'li'],\n            'b': ['i', 'li', 'p', 'pre'],\n            'br': ['b', 'i', 'li', 'p'],\n            'i': ['b', 'li', 'p', 'pre'],\n            'li': ['ol', 'ul'],\n            'ol': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'ul': ['ol', 'ul', 'blockquote', 'li', 'pre', 'div', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-collapsible': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-video': ['b', 'i', 'li', 'p', 'pre'],\n            'oppia-noninteractive-tabs': ['b', 'i', 'li', 'p', 'pre']\n        },\n        # Valid html tags in TextAngular.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'b',\n            'br',\n            'i',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n    },\n    'RTE_TYPE_CKEDITOR': {\n        # Valid parent-child relation in CKEditor.\n        'ALLOWED_PARENT_LIST': {\n            'p': ['blockquote', '[document]', 'li'],\n            'strong': ['em', 'li', 'p', 'pre'],\n            'em': ['strong', 'li', 'p', 'pre'],\n            'br': ['strong', 'em', 'li', 'p'],\n            'li': ['ol', 'ul'],\n            'ol': ['li', 'blockquote', 'pre', '[document]'],\n            'ul': ['li', 'blockquote', 'pre', '[document]'],\n            'pre': ['ol', 'ul', 'blockquote', 'li', '[document]'],\n            'blockquote': ['blockquote', '[document]'],\n            'oppia-noninteractive-link': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-math': ['strong', 'em', 'li', 'p', 'pre'],\n            'oppia-noninteractive-image': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-collapsible': [\n                'blockquote', 'li', '[document]'\n            ],\n            'oppia-noninteractive-video': ['blockquote', 'li', '[document]'],\n            'oppia-noninteractive-tabs': ['blockquote', 'li', '[document]']\n        },\n        # Valid html tags in CKEditor.\n        'ALLOWED_TAG_LIST': [\n            'p',\n            'strong',\n            'br',\n            'em',\n            'li',\n            'ol',\n            'ul',\n            'pre',\n            'blockquote',\n            'oppia-noninteractive-link',\n            'oppia-noninteractive-math',\n            'oppia-noninteractive-image',\n            'oppia-noninteractive-collapsible',\n            'oppia-noninteractive-video',\n            'oppia-noninteractive-tabs'\n        ]\n\n    }\n}\n\n# Classroom page names for generating URLs. These need to be kept in sync with\n# CLASSROOM_PAGES_DATA property in config_domain.\nCLASSROOM_PAGES = ['math']\n\n# Authentication method using GAE ID (google sign in).\nGAE_AUTH_PROVIDER_ID = 'gae'\n# Authentication method using Firebase authentication. Firebase signs its ID\n# Tokens with iss='Firebase' (iss: issuer, public API refers to this as\n# \"provider id\"), so using this naming convention helps us stay consistent with\n# the status quo.\nFIREBASE_AUTH_PROVIDER_ID = 'Firebase'\n# Firebase-specific role specified for users with super admin privileges.\nFIREBASE_ROLE_SUPER_ADMIN = 'super_admin'\n\n# Firebase *explicitly* requires IDs to have at most 128 characters, and may\n# contain any valid ASCII character:\n# https://firebase.google.com/docs/auth/admin/manage-users#create_a_user\n#\n# After manually inspecting ~200 of them, however, we've found that they only\n# use alpha-numeric characters, hence the tighter restriction.\nFIREBASE_AUTH_ID_REGEX = '^[A-Za-z0-9]{1,128}$'\n\nCLOUD_DATASTORE_EMULATOR_HOST = 'localhost'\nCLOUD_DATASTORE_EMULATOR_PORT = 8089\n\nFIREBASE_EMULATOR_CONFIG_PATH = '.firebase.json'\nFIREBASE_EMULATOR_PORT = 9099\n\n# The duration a session cookie from Firebase should remain valid for. After the\n# duration expires, a new cookie will need to be generated. Generating a new\n# cookie requires the user to sign-in _explicitly_.\nFIREBASE_SESSION_COOKIE_MAX_AGE = datetime.timedelta(days=14)\n\n# TODO(#10501): Once domain objects can be imported by the storage layer, move\n# these back to appropriate places (rights_domain, topic_domain).\n# The reserved prefix for keys that are automatically inserted into a\n# commit_cmd dict by this model.\nAUTOGENERATED_PREFIX = 'AUTO'\n\n# The command string for a revert commit.\nCMD_REVERT_COMMIT = '%s_revert_version_number' % AUTOGENERATED_PREFIX\n\n# The command string for a delete commit.\nCMD_DELETE_COMMIT = '%s_mark_deleted' % AUTOGENERATED_PREFIX\n\n# IMPORTANT: Ensure that all changes to how these cmds are interpreted preserve\n# backward-compatibility with previous exploration snapshots in the datastore.\n# Do not modify the definitions of CMD keys that already exist.\nCMD_CREATE_NEW = 'create_new'\nCMD_CHANGE_ROLE = 'change_role'\nCMD_REMOVE_ROLE = 'remove_role'\nCMD_CHANGE_EXPLORATION_STATUS = 'change_exploration_status'\nCMD_CHANGE_COLLECTION_STATUS = 'change_collection_status'\nCMD_CHANGE_PRIVATE_VIEWABILITY = 'change_private_viewability'\nCMD_RELEASE_OWNERSHIP = 'release_ownership'\nCMD_UPDATE_FIRST_PUBLISHED_MSEC = 'update_first_published_msec'\n\n# Roles used in collections and explorations.\nROLE_OWNER = 'owner'\nROLE_EDITOR = 'editor'\nROLE_VOICE_ARTIST = 'voice artist'\nROLE_VIEWER = 'viewer'\nROLE_NONE = 'none'\n\n# The list of entity types that do not require entity specific access control\n# when viewing respective suggestions.\nENTITY_TYPES_WITH_UNRESTRICTED_VIEW_SUGGESTION_ACCESS = [ENTITY_TYPE_SKILL]\n\n# The allowed list of roles which can be used in change_role command.\nALLOWED_ACTIVITY_ROLES = [\n    ROLE_OWNER, ROLE_EDITOR, ROLE_VOICE_ARTIST, ROLE_VIEWER]\n\n# The allowed list of status which can be used in change_exploration_status\n# and change_collection_status commands.\nALLOWED_ACTIVITY_STATUS = [\n    constants.ACTIVITY_STATUS_PRIVATE, constants.ACTIVITY_STATUS_PUBLIC]\n\n# Commands allowed in CollectionRightsChange and ExplorationRightsChange.\nCOMMON_RIGHTS_ALLOWED_COMMANDS: List[CommandType] = [{\n    'name': CMD_CREATE_NEW,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_CHANGE_ROLE,\n    'required_attribute_names': ['assignee_id', 'old_role', 'new_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['assignee_id'],\n    'allowed_values': {\n        'new_role': ALLOWED_ACTIVITY_ROLES, 'old_role': ALLOWED_ACTIVITY_ROLES}\n}, {\n    'name': CMD_REMOVE_ROLE,\n    'required_attribute_names': ['removed_user_id', 'old_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['removed_user_id'],\n    'allowed_values': {'old_role': ALLOWED_ACTIVITY_ROLES}\n}, {\n    'name': CMD_CHANGE_PRIVATE_VIEWABILITY,\n    'required_attribute_names': [\n        'old_viewable_if_private', 'new_viewable_if_private'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_RELEASE_OWNERSHIP,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_UPDATE_FIRST_PUBLISHED_MSEC,\n    'required_attribute_names': [\n        'old_first_published_msec', 'new_first_published_msec'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_DELETE_COMMIT,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}]\n\nCOLLECTION_RIGHTS_CHANGE_ALLOWED_COMMANDS: List[CommandType] = copy.deepcopy(\n    COMMON_RIGHTS_ALLOWED_COMMANDS\n)\nCOLLECTION_RIGHTS_CHANGE_ALLOWED_COMMANDS.append({\n    'name': CMD_CHANGE_COLLECTION_STATUS,\n    'required_attribute_names': ['old_status', 'new_status'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {\n        'old_status': ALLOWED_ACTIVITY_STATUS,\n        'new_status': ALLOWED_ACTIVITY_STATUS\n    }\n})\n\nEXPLORATION_RIGHTS_CHANGE_ALLOWED_COMMANDS = copy.deepcopy(\n    COMMON_RIGHTS_ALLOWED_COMMANDS)\nEXPLORATION_RIGHTS_CHANGE_ALLOWED_COMMANDS.append({\n    'name': CMD_CHANGE_EXPLORATION_STATUS,\n    'required_attribute_names': ['old_status', 'new_status'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': [],\n    'allowed_values': {\n        'old_status': ALLOWED_ACTIVITY_STATUS,\n        'new_status': ALLOWED_ACTIVITY_STATUS\n    },\n    # TODO(#12991): Remove this once once we use the migration jobs to remove\n    # the deprecated values from the server data.\n    'deprecated_values': {\n        'new_status': ['publicized']\n    }\n})\n\nCMD_REMOVE_MANAGER_ROLE = 'remove_manager_role'\nCMD_PUBLISH_TOPIC = 'publish_topic'\nCMD_UNPUBLISH_TOPIC = 'unpublish_topic'\n\nROLE_MANAGER = 'manager'\n\n# The allowed list of roles which can be used in TopicRightsChange change_role\n# command.\nALLOWED_TOPIC_ROLES = [ROLE_NONE, ROLE_MANAGER]\n\n# Commands allowed in TopicRightsChange.\nTOPIC_RIGHTS_CHANGE_ALLOWED_COMMANDS: List[CommandType] = [{\n    'name': CMD_CREATE_NEW,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_CHANGE_ROLE,\n    'required_attribute_names': ['assignee_id', 'new_role', 'old_role'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['assignee_id'],\n    'allowed_values': {\n        'new_role': ALLOWED_TOPIC_ROLES, 'old_role': ALLOWED_TOPIC_ROLES\n    }\n}, {\n    'name': CMD_REMOVE_MANAGER_ROLE,\n    'required_attribute_names': ['removed_user_id'],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': ['removed_user_id']\n}, {\n    'name': CMD_PUBLISH_TOPIC,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_UNPUBLISH_TOPIC,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}, {\n    'name': CMD_DELETE_COMMIT,\n    'required_attribute_names': [],\n    'optional_attribute_names': [],\n    'user_id_attribute_names': []\n}]\n\nUSER_ID_RANDOM_PART_LENGTH = 32\nUSER_ID_LENGTH = 36\nUSER_ID_REGEX = r'uid_[a-z]{%s}' % USER_ID_RANDOM_PART_LENGTH\nPSEUDONYMOUS_ID_REGEX = r'pid_[a-z]{%s}' % USER_ID_RANDOM_PART_LENGTH\n\n# Length of user PIN for different roles used on Android.\nFULL_USER_PIN_LENGTH = 5\nPROFILE_USER_PIN_LENGTH = 3\n\nMAX_NUMBER_OF_OPS_IN_TRANSACTION = 25\n\n# This is the maximum wait time for the task queue HTTP request. If the request\n# takes longer than this value, an exception is raised. The default value\n# of 5 seconds is too short and must be avoided because it can cause events\n# to go unrecorded.\n# https://cloud.google.com/appengine/docs/standard/python/outbound-requests#request_timeouts\nDEFAULT_TASKQUEUE_TIMEOUT_SECONDS = 30\n\n# Mapping from issue type to issue keyname in the issue customization dict. This\n# mapping is useful to uniquely identify issues by the combination of their\n# issue type and other type-specific information (such as the list of states\n# involved).\nCUSTOMIZATION_ARG_WHICH_IDENTIFIES_ISSUE = {\n    'EarlyQuit': 'state_name',\n    'MultipleIncorrectSubmissions': 'state_name',\n    'CyclicStateTransitions': 'state_names'\n}\n\n# Constants defining various suggestion types.\nSUGGESTION_TYPE_EDIT_STATE_CONTENT = 'edit_exploration_state_content'\nSUGGESTION_TYPE_TRANSLATE_CONTENT = 'translate_content'\nSUGGESTION_TYPE_ADD_QUESTION = 'add_question'\n\n# Suggestion fields that can be queried.\nALLOWED_SUGGESTION_QUERY_FIELDS = [\n    'suggestion_type', 'target_type', 'target_id', 'status', 'author_id',\n    'final_reviewer_id', 'score_category', 'language_code'\n]\n\n# Possible targets that the suggestions can modify.\nSUGGESTION_TARGET_TYPE_CHOICES = [\n    ENTITY_TYPE_EXPLORATION,\n    ENTITY_TYPE_QUESTION,\n    ENTITY_TYPE_SKILL,\n    ENTITY_TYPE_TOPIC\n]\n\n# Possible suggestion types.\nSUGGESTION_TYPE_CHOICES = [\n    SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n    SUGGESTION_TYPE_TRANSLATE_CONTENT,\n    SUGGESTION_TYPE_ADD_QUESTION\n]\n\n# The types of suggestions that are offered on the Contributor Dashboard.\nCONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES = [\n    SUGGESTION_TYPE_TRANSLATE_CONTENT,\n    SUGGESTION_TYPE_ADD_QUESTION\n]\n\n# This represents a literal constant for All and is used whereever\n# we need to compare a value with value All (for example, all topics)\nALL_LITERAL_CONSTANT = 'All'\n\n# Prefix for all access validation handlers.\n# The naming scheme for access validation handlers is\n# '/access_validation_handler/<handler_name>'\n# example '/access_validation_handler/validate_access_to_splash_page'.\nACCESS_VALIDATION_HANDLER_PREFIX = '/access_validation_handler'\n\n# The possible commit types.\nCOMMIT_TYPE_CREATE = 'create'\nCOMMIT_TYPE_REVERT = 'revert'\nCOMMIT_TYPE_EDIT = 'edit'\nCOMMIT_TYPE_DELETE = 'delete'\n\n# The data type for the translated or translatable content in any\n# BaseTranslatableObject.\nContentValueType = Union[str, List[str]]\n\n\nclass TranslatableEntityType(enum.Enum):\n    \"\"\"Represents all possible entity types which support new translations\n    architecture.\n    \"\"\"\n\n    EXPLORATION = 'exploration'\n    QUESTION = 'question'\n\n\nclass TranslatedContentDict(TypedDict):\n    \"\"\"Dictionary representing TranslatedContent object.\"\"\"\n\n    content_value: ContentValueType\n    needs_update: bool\n"
    },
    {
      "filename": "core/storage/suggestion/gae_models.py",
      "content": "# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Models for Oppia suggestions.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core.platform import models\n\nfrom typing import Any, Dict, List, Optional, Sequence, Tuple, Union\n\nMYPY = False\nif MYPY: # pragma: no cover\n    from mypy_imports import base_models\n    from mypy_imports import datastore_services\n\n(base_models, user_models) = models.Registry.import_models(\n    [models.NAMES.base_model, models.NAMES.user])\n\ndatastore_services = models.Registry.import_datastore_services()\n\n# Constants defining the different possible statuses of a suggestion.\nSTATUS_ACCEPTED = 'accepted'\nSTATUS_IN_REVIEW = 'review'\nSTATUS_REJECTED = 'rejected'\n\nSTATUS_CHOICES = [\n    STATUS_ACCEPTED,\n    STATUS_IN_REVIEW,\n    STATUS_REJECTED\n]\n\n# Daily emails are sent to reviewers to notify them of suggestions on the\n# Contributor Dashboard to review. The constants below define the number of\n# question and translation suggestions to fetch to come up with these daily\n# suggestion recommendations.\nMAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS = 30\nMAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS = 30\n\n# Defines what is the minimum role required to review suggestions\n# of a particular type.\nSUGGESTION_MINIMUM_ROLE_FOR_REVIEW = {\n    feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT: feconf.ROLE_ID_FULL_USER\n}\n\n# Constants defining various contribution types.\nSCORE_TYPE_CONTENT = 'content'\nSCORE_TYPE_TRANSLATION = 'translation'\nSCORE_TYPE_QUESTION = 'question'\n\nSCORE_TYPE_CHOICES = [\n    SCORE_TYPE_CONTENT,\n    SCORE_TYPE_TRANSLATION,\n    SCORE_TYPE_QUESTION\n]\n\n# The delimiter to be used in score category field.\nSCORE_CATEGORY_DELIMITER = '.'\n\n# Threshold number of days after which suggestion will be accepted.\nTHRESHOLD_DAYS_BEFORE_ACCEPT = 7\n\n# Threshold time after which suggestion is considered stale and auto-accepted.\nTHRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS = (\n    THRESHOLD_DAYS_BEFORE_ACCEPT * 24 * 60 * 60 * 1000)\n\n# Threshold number of days after which to notify the admin that the\n# suggestion has waited too long for a review. The admin will be notified of the\n# top MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN number of suggestions that have\n# waited for a review longer than the threshold number of days.\nSUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS = 7\n\n# The maximum number of suggestions, that have been waiting too long for review,\n# to email admins about.\nMAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN = 10\n\n# The default message to be shown when accepting stale suggestions.\nDEFAULT_SUGGESTION_ACCEPT_MESSAGE = (\n    'Automatically accepting suggestion after'\n    ' %d days' % THRESHOLD_DAYS_BEFORE_ACCEPT)\n\n# The message to be shown when rejecting a suggestion with a target ID of a\n# deleted skill.\nDELETED_SKILL_REJECT_MESSAGE = 'The associated skill no longer exists.'\n\n# The message to be shown when rejecting a translation suggestion that is\n# associated with an exploration that no longer corresponds to the story.\n# The story could have been deleted or the exploration could have been removed\n# from the story.\nINVALID_STORY_REJECT_TRANSLATION_SUGGESTIONS_MSG = (\n    'This text snippet has been removed from the story, and no longer needs '\n    'translation. Sorry about that!'\n)\n\n# The amount to increase the score of the author by after successfuly getting an\n# accepted suggestion.\nINCREMENT_SCORE_OF_AUTHOR_BY = 1\n\n# The unique ID for the CommunityContributionStatsModel.\nCOMMUNITY_CONTRIBUTION_STATS_MODEL_ID = 'community_contribution_stats'\n\n\nclass GeneralSuggestionModel(base_models.BaseModel):\n    \"\"\"Model to store suggestions made by Oppia users.\n\n    The ID of the suggestions created is the same as the ID of the thread\n    linked to the suggestion.\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The type of suggestion.\n    suggestion_type = datastore_services.StringProperty(\n        required=True, indexed=True, choices=feconf.SUGGESTION_TYPE_CHOICES)\n    # The type of the target entity which the suggestion is linked to.\n    target_type = datastore_services.StringProperty(\n        required=True,\n        indexed=True,\n        choices=feconf.SUGGESTION_TARGET_TYPE_CHOICES\n    )\n    # The ID of the target entity being suggested to.\n    target_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The version number of the target entity at the time of creation of the\n    # suggestion.\n    target_version_at_submission = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # Status of the suggestion.\n    status = datastore_services.StringProperty(\n        required=True, indexed=True, choices=STATUS_CHOICES)\n    # The ID of the author of the suggestion.\n    author_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The ID of the reviewer who accepted/rejected the suggestion.\n    final_reviewer_id = datastore_services.StringProperty(indexed=True)\n    # The change command linked to the suggestion. Contains the details of the\n    # change.\n    change_cmd = datastore_services.JsonProperty(required=True)\n    # The category to score the suggestor in. This field will contain 2 values\n    # separated by a ., the first will be a value from SCORE_TYPE_CHOICES and\n    # the second will be the subcategory of the suggestion.\n    score_category = (\n        datastore_services.StringProperty(required=True, indexed=True))\n    # The ISO 639-1 code used to query suggestions by language, or None if the\n    # suggestion type is not queryable by language.\n    language_code = datastore_services.StringProperty(indexed=True)\n    # A flag that indicates whether the suggestion is edited by the reviewer.\n    edited_by_reviewer = datastore_services.BooleanProperty(\n        default=False, indexed=True)\n\n    @staticmethod\n    def get_deletion_policy() -> base_models.DELETION_POLICY:\n        \"\"\"Model contains data to pseudonymize corresponding to a user:\n        author_id, and final_reviewer_id fields.\n        \"\"\"\n        return base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple unshared instance since there\n        are multiple suggestions per user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'suggestion_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_id': base_models.EXPORT_POLICY.EXPORTED,\n            'target_version_at_submission':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'status': base_models.EXPORT_POLICY.EXPORTED,\n            # The author_id and final_reviewer_id are not exported since\n            # we do not want to reveal internal user ids.\n            'author_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'final_reviewer_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'change_cmd': base_models.EXPORT_POLICY.EXPORTED,\n            'score_category': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'edited_by_reviewer': base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether GeneralSuggestionModel exists for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(datastore_services.any_of(\n            cls.author_id == user_id, cls.final_reviewer_id == user_id\n        )).get(keys_only=True) is not None\n\n    # TODO(#13523): Change 'change_cmd' to TypedDict/Domain Object\n    # to remove Any used below.\n    @classmethod\n    def create(\n            cls,\n            suggestion_type: str,\n            target_type: str,\n            target_id: str,\n            target_version_at_submission: int,\n            status: str,\n            author_id: str,\n            final_reviewer_id: str,\n            change_cmd: Dict[str, Any],\n            score_category: str,\n            thread_id: str,\n            language_code: Optional[str]\n    ) -> None:\n        \"\"\"Creates a new SuggestionModel entry.\n\n        Args:\n            suggestion_type: str. The type of the suggestion.\n            target_type: str. The type of target entity being edited.\n            target_id: str. The ID of the target entity being edited.\n            target_version_at_submission: int. The version number of the target\n                entity at the time of creation of the suggestion.\n            status: str. The status of the suggestion.\n            author_id: str. The ID of the user who submitted the suggestion.\n            final_reviewer_id: str. The ID of the reviewer who has\n                accepted/rejected the suggestion.\n            change_cmd: dict. The actual content of the suggestion.\n            score_category: str. The scoring category for the suggestion.\n            thread_id: str. The ID of the feedback thread linked to the\n                suggestion.\n            language_code: str|None. The ISO 639-1 code used to query\n                suggestions by language, or None if the suggestion type is not\n                queryable by language.\n\n        Raises:\n            Exception. There is already a suggestion with the given id.\n        \"\"\"\n        instance_id = thread_id\n\n        if cls.get_by_id(instance_id):\n            raise Exception(\n                'There is already a suggestion with the given'\n                ' id: %s' % instance_id)\n\n        cls(\n            id=instance_id, suggestion_type=suggestion_type,\n            target_type=target_type, target_id=target_id,\n            target_version_at_submission=target_version_at_submission,\n            status=status, author_id=author_id,\n            final_reviewer_id=final_reviewer_id, change_cmd=change_cmd,\n            score_category=score_category, language_code=language_code).put()\n\n    @classmethod\n    def query_suggestions(\n        cls, query_fields_and_values: List[Tuple[str, str]]\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Queries for suggestions.\n\n        Args:\n            query_fields_and_values: list(tuple(str, str)). A list of queries.\n                The first element in each tuple is the field to be queried, and\n                the second element is the corresponding value to query for.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that match the given\n            query values, up to a maximum of\n            feconf.DEFAULT_SUGGESTION_QUERY_LIMIT suggestions.\n\n        Raises:\n            Exception. The field cannot be queried.\n        \"\"\"\n        query = cls.query()\n        for (field, value) in query_fields_and_values:\n            if field not in feconf.ALLOWED_SUGGESTION_QUERY_FIELDS:\n                raise Exception('Not allowed to query on field %s' % field)\n            query = query.filter(getattr(cls, field) == value)\n        return query.fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_translation_suggestions_in_review_with_exp_id(\n        cls, exp_id: str, language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns translation suggestions which are in review with target_id\n        == exp_id.\n\n        Args:\n            exp_id: str. Exploration ID matching the target ID of the\n                translation suggestions.\n            language_code: str. Language code.\n\n        Returns:\n            list(SuggestionModel). A list of translation suggestions in review\n            with target_id of exp_id. The number of returned results is capped\n            by feconf.DEFAULT_SUGGESTION_QUERY_LIMIT.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.language_code == language_code,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id == exp_id\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_multiple_suggestions_from_suggestion_ids(\n        cls, suggestion_ids: List[str]\n    ) -> List[Optional[GeneralSuggestionModel]]:\n        \"\"\"Returns suggestions matching the supplied suggestion IDs.\n\n        Args:\n            suggestion_ids: list(str). Suggestion IDs of suggestions that need\n                to be returned.\n\n        Returns:\n            list(SuggestionModel|None). A list of suggestions in matching the\n            supplied suggestion IDs.\n        \"\"\"\n        return GeneralSuggestionModel.get_multi(suggestion_ids)\n\n    @classmethod\n    def get_translation_suggestions_in_review_ids_with_exp_id(\n            cls, target_exp_ids: List[str]\n    ) -> List[str]:\n        \"\"\"Returns IDs of in review translation suggestions matching the\n        supplied target IDs.\n\n        Args:\n            target_exp_ids: list(str). Exploration IDs matching the target ID\n                of the translation suggestions.\n\n        Returns:\n            list(str). A list of IDs of translation suggestions in review\n            with given target_exp_ids.\n        \"\"\"\n        suggestion_keys = GeneralSuggestionModel.query(\n            cls.status == STATUS_IN_REVIEW,\n            GeneralSuggestionModel.target_id.IN(target_exp_ids)\n            ).fetch(keys_only=True)\n\n        return [suggestion_key.id() for suggestion_key in suggestion_keys]\n\n    @classmethod\n    def get_translation_suggestion_ids_with_exp_ids(\n            cls, exp_ids: List[str]\n    ) -> List[str]:\n        \"\"\"Gets the ids of translation suggestions corresponding to\n        explorations with the given exploration ids.\n\n        Args:\n            exp_ids: list(str). List of exploration ids to query for.\n\n        Returns:\n            list(str). A list of translation suggestion ids that\n            correspond to the given exploration ids. Note: it is not\n            guaranteed that the suggestion ids returned are ordered by the\n            exploration ids in exp_ids.\n        \"\"\"\n        query = cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id.IN(exp_ids)\n        ))\n        suggestion_models: List[GeneralSuggestionModel] = []\n        offset, more = (0, True)\n        while more:\n            results: Sequence[GeneralSuggestionModel] = (\n                query.fetch(\n                    feconf.DEFAULT_SUGGESTION_QUERY_LIMIT, offset=offset))\n            if len(results):\n                offset = offset + len(results)\n                suggestion_models.extend(results)\n            else:\n                more = False\n        return [suggestion_model.id for suggestion_model in suggestion_models]\n\n    @classmethod\n    def get_all_stale_suggestion_ids(cls) -> List[str]:\n        \"\"\"Gets the ids of the suggestions which were last updated before the\n        threshold time.\n\n        Returns:\n            list(str). A list of the ids of the suggestions that are stale.\n        \"\"\"\n        threshold_time = (\n            datetime.datetime.utcnow() - datetime.timedelta(\n                0, 0, 0, THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS))\n        suggestion_models: Sequence[GeneralSuggestionModel] = (\n            cls.get_all().filter(\n                cls.status == STATUS_IN_REVIEW\n            ).filter(cls.last_updated < threshold_time).fetch()\n        )\n        return [suggestion_model.id for suggestion_model in suggestion_models]\n\n    @classmethod\n    def get_suggestions_waiting_too_long_for_review(\n        cls\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns a list of suggestions that have been waiting for a review\n        longer than SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS days on the\n        Contributor Dashboard. MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN\n        suggestions are returned, sorted in descending order by their review\n        wait time.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of suggestions, sorted in\n            descending order by their review wait time.\n\n        Raises:\n            Exception. If there are no suggestion types offered on the\n                Contributor Dashboard.\n        \"\"\"\n        if not feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES:\n            raise Exception(\n                'Expected the suggestion types offered on the Contributor '\n                'Dashboard to be nonempty.')\n        threshold_time = (\n            datetime.datetime.utcnow() - datetime.timedelta(\n                days=SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS))\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.last_updated < threshold_time,\n            cls.suggestion_type.IN(\n                feconf.CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES)\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_NUMBER_OF_SUGGESTIONS_TO_EMAIL_ADMIN)\n\n    @classmethod\n    def get_in_review_suggestions_in_score_categories(\n        cls, score_categories: List[str], user_id: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions which are in review in the given\n        score_categories.\n\n        Args:\n            score_categories: list(str). List of score categories to query for.\n            user_id: str. The id of the user trying to make this query.\n                As a user cannot review their own suggestions, suggestions\n                authored by the user will be excluded.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are in the given\n            score categories, which are in review, but not created by the\n            given user.\n\n        Raises:\n            Exception. Given list of score categories is empty.\n        \"\"\"\n        if len(score_categories) == 0:\n            raise Exception('Received empty list of score categories')\n\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.score_category.IN(score_categories),\n            cls.author_id != user_id\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_in_review_translation_suggestions_by_offset(\n        cls,\n        limit: int,\n        offset: int,\n        user_id: str,\n        language_codes: List[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches translation suggestions that are in-review where the\n        author_id != user_id and language_code matches one of the supplied\n        language_codes.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. Number of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query. As a\n                user cannot review their own suggestions, suggestions authored\n                by the user will be excluded.\n            language_codes: list(str). List of language codes that the\n                suggestions should match.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, and that match\n                    one of the supplied language codes.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.author_id != user_id,\n            cls.language_code.IN(language_codes)\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_in_review_translation_suggestions_with_exp_ids_by_offset(\n        cls,\n        limit: int,\n        offset: int,\n        user_id: str,\n        language_codes: List[str],\n        exp_ids: List[str]\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Gets all translation suggestions for the given language\n        codes which are in review and correspond to the\n        given exploration IDs.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. Number of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query.\n                As a user cannot review their own suggestions, suggestions\n                authored by the user will be excluded.\n            language_codes: list(str). The list of language codes.\n            exp_ids: list(str). Exploration IDs matching the target ID of the\n                translation suggestions.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, match\n                    one of the supplied language codes and correspond to the\n                    given exploration IDs.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.author_id != user_id,\n            cls.language_code.IN(language_codes),\n            cls.target_id.IN(exp_ids)\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_in_review_translation_suggestions_by_exp_ids(\n        cls, exp_ids: List[str], language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all in-review translation suggestions matching the supplied\n        exp_ids and language_code.\n\n        Args:\n            exp_ids: list(str). Exploration IDs matching the target ID of the\n                translation suggestions.\n            language_code: str. The ISO 639-1 language code of the translation\n                suggestions.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions matching the supplied\n            exp_ids and language_code.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.target_id.IN(exp_ids),\n            cls.language_code == language_code\n        )).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_in_review_question_suggestions_by_offset(\n        cls, limit: int, offset: int, user_id: str\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches question suggestions that are in-review and not authored by\n        the supplied user.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. Number of of results to skip from the beginning of all\n                results matching the query.\n            user_id: str. The id of the user trying to make this query. As a\n                user cannot review their own suggestions, suggestions authored\n                by the user will be excluded.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    in-review, not authored by the supplied user, and that match\n                    one of the supplied language codes.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            cls.author_id != user_id\n        ))\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_question_suggestions_waiting_longest_for_review(\n        cls\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS number\n        of question suggestions, sorted in descending order by review wait\n        time.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of question suggestions,\n            sorted in descending order based on how long the suggestions have\n            been waiting for review.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_ADD_QUESTION\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS)\n\n    @classmethod\n    def get_translation_suggestions_waiting_longest_for_review(\n        cls, language_code: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Returns MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS\n        number of translation suggestions in the specified language code,\n        sorted in descending order by review wait time.\n\n        Args:\n            language_code: str. The ISO 639-1 language code of the translation\n                suggestions.\n\n        Returns:\n            list(GeneralSuggestionModel). A list of translation suggestions,\n            sorted in descending order based on how long the suggestions have\n            been waiting for review.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.status == STATUS_IN_REVIEW,\n            cls.suggestion_type == feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            cls.language_code == language_code\n        )).order(\n            cls.last_updated\n        ).fetch(MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS)\n\n    @classmethod\n    def get_user_created_suggestions_of_suggestion_type(\n        cls, suggestion_type: str, user_id: str\n    ) -> Sequence[GeneralSuggestionModel]:\n        \"\"\"Gets all suggestions of suggestion_type which the user has created.\n\n        Args:\n            suggestion_type: str. The type of suggestion to query for.\n            user_id: str. The id of the user trying to make this query.\n\n        Returns:\n            list(SuggestionModel). A list of suggestions that are of the given\n            type, which the given user has created.\n        \"\"\"\n        return cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == suggestion_type,\n            cls.author_id == user_id\n        )).order(-cls.created_on).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def get_user_created_suggestions_by_offset(\n        cls, limit: int, offset: int, suggestion_type: str, user_id: str\n    ) -> Tuple[Sequence[GeneralSuggestionModel], int]:\n        \"\"\"Fetches suggestions of suggestion_type which the supplied user has\n        created.\n\n        Args:\n            limit: int. Maximum number of entities to be returned.\n            offset: int. The number of results to skip from the beginning of all\n                results matching the query.\n            suggestion_type: str. The type of suggestion to query for.\n            user_id: str. The id of the user trying to make this query.\n\n        Returns:\n            Tuple of (results, next_offset). Where:\n                results: list(SuggestionModel). A list of suggestions that are\n                    of the supplied type which the supplied user has created.\n                next_offset: int. The input offset + the number of results\n                    returned by the current query.\n        \"\"\"\n        suggestion_query = cls.get_all().filter(datastore_services.all_of(\n            cls.suggestion_type == suggestion_type,\n            cls.author_id == user_id\n        )).order(-cls.created_on)\n\n        results: Sequence[GeneralSuggestionModel] = (\n            suggestion_query.fetch(limit, offset=offset)\n        )\n        next_offset = offset + len(results)\n\n        return (\n            results,\n            next_offset\n        )\n\n    @classmethod\n    def get_all_score_categories(cls) -> List[str]:\n        \"\"\"Gets all the score categories for which suggestions have been\n        created.\n\n        Returns:\n            list(str). A list of all the score categories.\n        \"\"\"\n        query_set = cls.query(projection=['score_category'], distinct=True)\n        return [data.score_category for data in query_set]\n\n    # TODO(#13523): Change 'change_cmd' to TypedDict/Domain Object\n    # to remove Any used below.\n    @classmethod\n    def export_data(\n            cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, bool, Dict[str, Any], None]]]:\n        \"\"\"Exports the data from GeneralSuggestionModel\n        into dict format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from GeneralSuggestionModel.\n        \"\"\"\n\n        user_data = {}\n        suggestion_models: Sequence[GeneralSuggestionModel] = (\n            cls.get_all().filter(cls.author_id == user_id).fetch())\n\n        for suggestion_model in suggestion_models:\n            user_data[suggestion_model.id] = {\n                'suggestion_type': suggestion_model.suggestion_type,\n                'target_type': suggestion_model.target_type,\n                'target_id': suggestion_model.target_id,\n                'target_version_at_submission': (\n                    suggestion_model\n                    .target_version_at_submission),\n                'status': suggestion_model.status,\n                'change_cmd': suggestion_model.change_cmd,\n                'language_code': suggestion_model.language_code,\n                'edited_by_reviewer': suggestion_model.edited_by_reviewer\n            }\n\n        return user_data\n\n\nclass GeneralVoiceoverApplicationModel(base_models.BaseModel):\n    \"\"\"A general model for voiceover application of an entity.\n\n    The ID of the voiceover application will be a random hashed value.\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The type of entity to which the user will be assigned as a voice artist\n    # once the application will get approved.\n    target_type = datastore_services.StringProperty(required=True, indexed=True)\n    # The ID of the entity to which the application belongs.\n    target_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The language code for the voiceover audio.\n    language_code = (\n        datastore_services.StringProperty(required=True, indexed=True))\n    # The status of the application. One of: accepted, rejected, in-review.\n    status = datastore_services.StringProperty(\n        required=True, indexed=True, choices=STATUS_CHOICES)\n    # The HTML content written in the given language_code.\n    # This will typically be a snapshot of the content of the initial card of\n    # the target.\n    content = datastore_services.TextProperty(required=True)\n    # The filename of the voiceover audio. The filename will have\n    # datetime-randomId(length 6)-language_code.mp3 pattern.\n    filename = datastore_services.StringProperty(required=True, indexed=True)\n    # The ID of the author of the voiceover application.\n    author_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The ID of the reviewer who accepted/rejected the voiceover application.\n    final_reviewer_id = datastore_services.StringProperty(indexed=True)\n    # The plain text message submitted by the reviewer while rejecting the\n    # application.\n    rejection_message = datastore_services.TextProperty()\n\n    @staticmethod\n    def get_deletion_policy() -> base_models.DELETION_POLICY:\n        \"\"\"Model contains data to pseudonymize corresponding to a user:\n        author_id, and final_reviewer_id fields.\n        \"\"\"\n        return base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether GeneralVoiceoverApplicationModel exists for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(datastore_services.any_of(\n            cls.author_id == user_id, cls.final_reviewer_id == user_id\n        )).get(keys_only=True) is not None\n\n    @classmethod\n    def get_user_voiceover_applications(\n        cls, author_id: str, status: Optional[str] = None\n    ) -> Sequence[GeneralVoiceoverApplicationModel]:\n        \"\"\"Returns a list of voiceover application submitted by the given user.\n\n        Args:\n            author_id: str. The id of the user created the voiceover\n                application.\n            status: str|None. The status of the voiceover application.\n                If the status is None, the query will fetch all the\n                voiceover applications.\n\n        Returns:\n            list(GeneralVoiceoverApplicationModel). The list of voiceover\n            applications submitted by the given user.\n        \"\"\"\n        if status in STATUS_CHOICES:\n            voiceover_application_query = cls.query(\n                datastore_services.all_of(\n                    cls.author_id == author_id, cls.status == status))\n        else:\n            voiceover_application_query = cls.query(cls.author_id == author_id)\n\n        return voiceover_application_query.fetch()\n\n    @classmethod\n    def get_reviewable_voiceover_applications(\n        cls, user_id: str\n    ) -> Sequence[GeneralVoiceoverApplicationModel]:\n        \"\"\"Returns a list of voiceover application which a given user can\n        review.\n\n        Args:\n            user_id: str. The id of the user trying to make this query.\n                As a user cannot review their own voiceover application, so the\n                voiceover application created by the user will be excluded.\n\n        Returns:\n            list(GeneralVoiceoverApplicationModel). The list of voiceover\n            applications which the given user can review.\n        \"\"\"\n        return cls.query(datastore_services.all_of(\n            cls.author_id != user_id,\n            cls.status == STATUS_IN_REVIEW\n        )).fetch()\n\n    @classmethod\n    def get_voiceover_applications(\n        cls,\n        target_type: str,\n        target_id: str,\n        language_code: str\n    ) -> Sequence[GeneralVoiceoverApplicationModel]:\n        \"\"\"Returns a list of voiceover applications submitted for a give entity\n        in a given language.\n\n        Args:\n            target_type: str. The type of entity.\n            target_id: str. The ID of the targeted entity.\n            language_code: str. The code of the language in which the voiceover\n                application is submitted.\n\n        Returns:\n            list(GeneralVoiceoverApplicationModel). The list of voiceover\n            application which is submitted to a give entity in a given language.\n        \"\"\"\n        return cls.query(datastore_services.all_of(\n            cls.target_type == target_type,\n            cls.target_id == target_id,\n            cls.language_code == language_code\n        )).fetch()\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple voiceover applications relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'target_type': base_models.EXPORT_POLICY.EXPORTED,\n            'target_id': base_models.EXPORT_POLICY.EXPORTED,\n            'language_code': base_models.EXPORT_POLICY.EXPORTED,\n            'status': base_models.EXPORT_POLICY.EXPORTED,\n            'content': base_models.EXPORT_POLICY.EXPORTED,\n            'filename': base_models.EXPORT_POLICY.EXPORTED,\n            # The author_id and final_reviewer_id are not exported in order to\n            # keep internal ids private.\n            'author_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'final_reviewer_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'rejection_message': base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def export_data(cls, user_id: str) -> Dict[str, Dict[str, Optional[str]]]:\n        \"\"\"(Takeout) Exports the data from GeneralVoiceoverApplicationModel\n        into dict format.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from GeneralVoiceoverApplicationModel.\n        \"\"\"\n        user_data = {}\n\n        voiceover_models: Sequence[GeneralVoiceoverApplicationModel] = (\n            cls.query(cls.author_id == user_id).fetch())\n\n        for voiceover_model in voiceover_models:\n            user_data[voiceover_model.id] = {\n                'target_type': voiceover_model.target_type,\n                'target_id': voiceover_model.target_id,\n                'language_code': voiceover_model.language_code,\n                'status': voiceover_model.status,\n                'content': voiceover_model.content,\n                'filename': voiceover_model.filename,\n                'rejection_message': voiceover_model.rejection_message\n            }\n        return user_data\n\n\nclass CommunityContributionStatsModel(base_models.BaseModel):\n    \"\"\"Records the contributor dashboard contribution stats. This includes the\n    total number of reviewers for each suggestion type and the total number of\n    suggestions in review for each suggestion type. There is only ever one\n    instance of this model, and its ID is COMMUNITY_CONTRIBUTION_STATS_MODEL_ID.\n\n    Note: since this is a singleton model, the model GET and PUT must be done in\n    a transaction to avoid the loss of updates that come in rapid succession.\n    \"\"\"\n\n    # A dictionary where the keys represent the language codes that translation\n    # suggestions are offered in and the values correspond to the total number\n    # of reviewers who have permission to review translation suggestions in\n    # that language.\n    translation_reviewer_counts_by_lang_code = (\n        datastore_services.JsonProperty(required=True))\n    # A dictionary where the keys represent the language codes that translation\n    # suggestions are offered in and the values correspond to the total number\n    # of translation suggestions that are currently in review in that language.\n    translation_suggestion_counts_by_lang_code = (\n        datastore_services.JsonProperty(required=True))\n    # The total number of reviewers who have permission to review question\n    # suggestions.\n    question_reviewer_count = datastore_services.IntegerProperty(required=True)\n    # The total number of question suggestions that are currently in review.\n    question_suggestion_count = (\n        datastore_services.IntegerProperty(required=True))\n\n    # We have ignored [override] here because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get(cls) -> Optional[CommunityContributionStatsModel]: # type: ignore[override]\n        \"\"\"Gets the CommunityContributionStatsModel instance. If the\n        CommunityContributionStatsModel does not exist yet, it is created.\n        This method helps enforce that there should only ever be one instance\n        of this model.\n\n        Returns:\n            CommunityContributionStatsModel|None. The single model instance,\n            or None if no such model instance exists.\n        \"\"\"\n        community_contribution_stats_model = cls.get_by_id(\n            COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n\n        if community_contribution_stats_model is None:\n            community_contribution_stats_model = cls(\n                id=COMMUNITY_CONTRIBUTION_STATS_MODEL_ID,\n                translation_reviewer_counts_by_lang_code={},\n                translation_suggestion_counts_by_lang_code={},\n                question_reviewer_count=0,\n                question_suggestion_count=0\n            )\n            community_contribution_stats_model.update_timestamps()\n            community_contribution_stats_model.put()\n            return community_contribution_stats_model\n\n        else:\n            return super(\n                CommunityContributionStatsModel, cls).get(\n                    COMMUNITY_CONTRIBUTION_STATS_MODEL_ID)\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model doesn't contain any data directly corresponding to a user.\"\"\"\n        return base_models.DELETION_POLICY.NOT_APPLICABLE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"This model only contains general statistical information about the\n        contributor dashboard and does not include any individual user\n        information.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model doesn't contain any data directly corresponding to a user\n        because the data is aggregated.\n        \"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'translation_reviewer_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'translation_suggestion_counts_by_lang_code':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_reviewer_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'question_suggestion_count':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE\n        })\n\n\nclass TranslationContributionStatsModel(base_models.BaseModel):\n    \"\"\"Records the contributor dashboard translation contribution stats. There\n    is one instance of this model per (language_code, contributor_user_id,\n    topic_id) tuple. See related design doc for more details:\n    https://docs.google.com/document/d/1JEDiy-f1vnBLwibu8hsfuo3JObBWiaFvDTTU9L18zpY/edit#\n    \"\"\"\n\n    # We use the model id as a key in the Takeout dict.\n    ID_IS_USED_AS_TAKEOUT_KEY = True\n\n    # The ISO 639-1 language code for which the translation contributions were\n    # made.\n    language_code = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The user ID of the translation contributor.\n    contributor_user_id = datastore_services.StringProperty(\n        required=True, indexed=True)\n    # The topic ID of the translation contribution.\n    topic_id = datastore_services.StringProperty(required=True, indexed=True)\n    # The number of submitted translations.\n    submitted_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The total word count of submitted translations. Excludes HTML tags and\n    # attributes.\n    submitted_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations.\n    accepted_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of accepted translations without reviewer edits.\n    accepted_translations_without_reviewer_edits_count = (\n        datastore_services.IntegerProperty(required=True, indexed=True))\n    # The total word count of accepted translations. Excludes HTML tags and\n    # attributes.\n    accepted_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The number of rejected translations.\n    rejected_translations_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The total word count of rejected translations. Excludes HTML tags and\n    # attributes.\n    rejected_translation_word_count = datastore_services.IntegerProperty(\n        required=True, indexed=True)\n    # The unique last_updated dates of the translation suggestions.\n    contribution_dates = datastore_services.DateProperty(\n        repeated=True, indexed=True)\n\n    @classmethod\n    def create(\n            cls,\n            language_code: str,\n            contributor_user_id: str,\n            topic_id: str,\n            submitted_translations_count: int,\n            submitted_translation_word_count: int,\n            accepted_translations_count: int,\n            accepted_translations_without_reviewer_edits_count: int,\n            accepted_translation_word_count: int,\n            rejected_translations_count: int,\n            rejected_translation_word_count: int,\n            contribution_dates: List[datetime.date]\n    ) -> str:\n        \"\"\"Creates a new TranslationContributionStatsModel instance and returns\n        its ID.\n        \"\"\"\n        entity_id = cls.generate_id(\n            language_code, contributor_user_id, topic_id)\n        entity = cls(\n            id=entity_id,\n            language_code=language_code,\n            contributor_user_id=contributor_user_id,\n            topic_id=topic_id,\n            submitted_translations_count=submitted_translations_count,\n            submitted_translation_word_count=submitted_translation_word_count,\n            accepted_translations_count=accepted_translations_count,\n            accepted_translations_without_reviewer_edits_count=(\n                accepted_translations_without_reviewer_edits_count),\n            accepted_translation_word_count=accepted_translation_word_count,\n            rejected_translations_count=rejected_translations_count,\n            rejected_translation_word_count=rejected_translation_word_count,\n            contribution_dates=contribution_dates)\n        entity.update_timestamps()\n        entity.put()\n        return entity_id\n\n    @staticmethod\n    def generate_id(\n            language_code: str, contributor_user_id: str, topic_id: str\n    ) -> str:\n        \"\"\"Generates a unique ID for a TranslationContributionStatsModel\n        instance.\n\n        Args:\n            language_code: str. ISO 639-1 language code.\n            contributor_user_id: str. User ID.\n            topic_id: str. Topic ID.\n\n        Returns:\n            str. An ID of the form:\n\n            [language_code].[contributor_user_id].[topic_id]\n        \"\"\"\n        return (\n            '%s.%s.%s' % (language_code, contributor_user_id, topic_id)\n        )\n\n    # We have ignored [override] here because the signature of this method\n    # doesn't match with BaseModel.get().\n    # https://mypy.readthedocs.io/en/stable/error_code_list.html#check-validity-of-overrides-override\n    @classmethod\n    def get( # type: ignore[override]\n        cls, language_code: str, contributor_user_id: str, topic_id: str\n    ) -> Optional[TranslationContributionStatsModel]:\n        \"\"\"Gets the TranslationContributionStatsModel matching the supplied\n        language_code, contributor_user_id, topic_id.\n\n        Returns:\n            TranslationContributionStatsModel|None. The matching\n            TranslationContributionStatsModel, or None if no such model\n            instance exists.\n        \"\"\"\n        entity_id = cls.generate_id(\n            language_code, contributor_user_id, topic_id)\n        return cls.get_by_id(entity_id)\n\n    @classmethod\n    def get_all_by_user_id(\n        cls, user_id: str\n    ) -> Sequence[TranslationContributionStatsModel]:\n        \"\"\"Gets all TranslationContributionStatsModels matching the supplied\n        user_id.\n\n        Returns:\n            list(TranslationContributionStatsModel). The matching\n            TranslationContributionStatsModels.\n        \"\"\"\n        return cls.get_all().filter(\n            cls.contributor_user_id == user_id\n        ).fetch(feconf.DEFAULT_SUGGESTION_QUERY_LIMIT)\n\n    @classmethod\n    def has_reference_to_user_id(cls, user_id: str) -> bool:\n        \"\"\"Check whether TranslationContributionStatsModel references the\n        supplied user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be checked.\n\n        Returns:\n            bool. Whether any models refer to the given user ID.\n        \"\"\"\n        return cls.query(\n            cls.contributor_user_id == user_id\n        ).get(keys_only=True) is not None\n\n    @classmethod\n    def get_deletion_policy(cls) -> base_models.DELETION_POLICY:\n        \"\"\"Model contains corresponding to a user: contributor_user_id.\"\"\"\n        return base_models.DELETION_POLICY.DELETE\n\n    @staticmethod\n    def get_model_association_to_user(\n    ) -> base_models.MODEL_ASSOCIATION_TO_USER:\n        \"\"\"Model is exported as multiple instances per user since there are\n        multiple languages and topics relevant to a user.\n        \"\"\"\n        return base_models.MODEL_ASSOCIATION_TO_USER.MULTIPLE_INSTANCES_PER_USER\n\n    @classmethod\n    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:\n        \"\"\"Model contains data to export corresponding to a user.\"\"\"\n        return dict(super(cls, cls).get_export_policy(), **{\n            'language_code':\n                base_models.EXPORT_POLICY.EXPORTED,\n            # User ID is not exported in order to keep internal ids private.\n            'contributor_user_id':\n                base_models.EXPORT_POLICY.NOT_APPLICABLE,\n            'topic_id':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'submitted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translations_without_reviewer_edits_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'accepted_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translations_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'rejected_translation_word_count':\n                base_models.EXPORT_POLICY.EXPORTED,\n            'contribution_dates':\n                base_models.EXPORT_POLICY.EXPORTED\n        })\n\n    @classmethod\n    def apply_deletion_policy(cls, user_id: str) -> None:\n        \"\"\"Delete instances of TranslationContributionStatsModel for the user.\n\n        Args:\n            user_id: str. The ID of the user whose data should be deleted.\n        \"\"\"\n        datastore_services.delete_multi(\n            cls.query(cls.contributor_user_id == user_id).fetch(keys_only=True))\n\n    @classmethod\n    def export_data(\n            cls, user_id: str\n    ) -> Dict[str, Dict[str, Union[str, int, List[str]]]]:\n        \"\"\"Exports the data from TranslationContributionStatsModel into dict\n        format for Takeout.\n\n        Args:\n            user_id: str. The ID of the user whose data should be exported.\n\n        Returns:\n            dict. Dictionary of the data from TranslationContributionStatsModel.\n        \"\"\"\n        user_data = {}\n        stats_models: Sequence[TranslationContributionStatsModel] = (\n            cls.get_all().filter(cls.contributor_user_id == user_id).fetch())\n        for model in stats_models:\n            user_data[model.id] = {\n                'language_code': model.language_code,\n                'topic_id': model.topic_id,\n                'submitted_translations_count': (\n                    model.submitted_translations_count),\n                'submitted_translation_word_count': (\n                    model.submitted_translation_word_count),\n                'accepted_translations_count': (\n                    model.accepted_translations_count),\n                'accepted_translations_without_reviewer_edits_count': (\n                    model.accepted_translations_without_reviewer_edits_count),\n                'accepted_translation_word_count': (\n                    model.accepted_translation_word_count),\n                'rejected_translations_count': (\n                    model.rejected_translations_count),\n                'rejected_translation_word_count': (\n                    model.rejected_translation_word_count),\n                'contribution_dates': [\n                    date.isoformat() for date in model.contribution_dates]\n            }\n        return user_data\n"
    },
    {
      "filename": "core/storage/suggestion/gae_models_test.py",
      "content": "# coding: utf-8\n#\n# Copyright 2018 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the suggestion gae_models.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\n\nfrom core import feconf\nfrom core.platform import models\nfrom core.tests import test_utils\n\nfrom typing import Any, Dict\n\nMYPY = False\nif MYPY: # pragma: no cover\n    from mypy_imports import base_models\n    from mypy_imports import suggestion_models\n\n(base_models, suggestion_models, user_models) = models.Registry.import_models(\n    [models.NAMES.base_model, models.NAMES.suggestion, models.NAMES.user])\n\n\nclass SuggestionModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the suggestionModel class.\"\"\"\n\n    score_category = (\n        suggestion_models.SCORE_TYPE_TRANSLATION +\n        suggestion_models.SCORE_CATEGORY_DELIMITER + 'English')\n\n    topic_name = 'topic'\n    target_id = 'exp1'\n    target_version_at_submission = 1\n    # TODO(#13523): Use of Any here in the type annotation below will\n    # be removed when change_cmd will be changed to\n    # TypedDict/Domain Object.\n    change_cmd: Dict[str, Any] = {}\n    # Language code that would normally be derived from the change_cmd.\n    translation_language_code = 'en'\n    # Language code that would normally be derived from the question_dict in\n    # the change_cmd.\n    question_language_code = 'en'\n    mocked_datetime_utcnow = datetime.datetime(2020, 6, 15, 5)\n\n    def setUp(self) -> None:\n        super(SuggestionModelUnitTests, self).setUp()\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_1',\n            'reviewer_1', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_1', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_2',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_2', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_2',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_3', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_2',\n            'reviewer_3', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_4', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_5', None)\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            suggestion_models.GeneralSuggestionModel.get_deletion_policy(),\n            base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE)\n\n    def test_has_reference_to_user_id(self) -> None:\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_1')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_2')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('author_3')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_1')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_2')\n        )\n        self.assertTrue(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('reviewer_3')\n        )\n        self.assertFalse(\n            suggestion_models.GeneralSuggestionModel\n            .has_reference_to_user_id('id_x')\n        )\n\n    def test_score_type_contains_delimiter(self) -> None:\n        for score_type in suggestion_models.SCORE_TYPE_CHOICES:\n            self.assertTrue(\n                suggestion_models.SCORE_CATEGORY_DELIMITER not in score_type)\n\n    def test_create_new_object_succesfully(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_3', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', None)\n\n        suggestion_id = 'exploration.exp1.thread_6'\n\n        observed_suggestion_model = (\n            suggestion_models.GeneralSuggestionModel.get_by_id(suggestion_id))\n\n        self.assertEqual(\n            observed_suggestion_model.suggestion_type,\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        self.assertEqual(\n            observed_suggestion_model.target_type,\n            feconf.ENTITY_TYPE_EXPLORATION)\n        self.assertEqual(\n            observed_suggestion_model.target_id, self.target_id)\n        self.assertEqual(\n            observed_suggestion_model.target_version_at_submission,\n            self.target_version_at_submission)\n        self.assertEqual(\n            observed_suggestion_model.status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(observed_suggestion_model.author_id, 'author_3')\n        self.assertEqual(\n            observed_suggestion_model.final_reviewer_id, 'reviewer_3')\n        self.assertEqual(\n            observed_suggestion_model.score_category, self.score_category)\n        self.assertEqual(observed_suggestion_model.change_cmd, self.change_cmd)\n\n    def test_create_suggestion_fails_if_id_collides_with_existing_one(\n            self\n    ) -> None:\n        with self.assertRaisesRegex( # type: ignore[no-untyped-call]\n            Exception, 'There is already a suggestion with the given id: '\n                       'exploration.exp1.thread_1'):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                self.target_id, self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_3', self.change_cmd,\n                self.score_category, 'exploration.exp1.thread_1', None)\n\n    def test_get_suggestions_by_type(self) -> None:\n        queries = [(\n            'suggestion_type',\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n        queries = [('suggestion_type', 'invalid_suggestion_type')]\n\n        with self.assertRaisesRegex( # type: ignore[no-untyped-call]\n            Exception, 'Value \\'invalid_suggestion_type\\' for property'\n                       ' suggestion_type is not an allowed choice'):\n            suggestion_models.GeneralSuggestionModel.query_suggestions(queries)\n\n    def test_get_suggestion_by_author(self) -> None:\n        queries = [('author_id', 'author_1')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('author_id', 'author_2')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n        queries = [('author_id', 'author_3')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('author_id', 'author_invalid')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_get_suggestion_by_reviewer(self) -> None:\n        queries = [('final_reviewer_id', 'reviewer_1')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('final_reviewer_id', 'reviewer_2')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n        queries = [('final_reviewer_id', 'reviewer_3')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('final_reviewer_id', 'reviewer_invalid')]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_get_suggestions_by_status(self) -> None:\n        queries = [('status', suggestion_models.STATUS_IN_REVIEW)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n        queries = [('status', suggestion_models.STATUS_REJECTED)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n        queries = [('status', suggestion_models.STATUS_ACCEPTED)]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n\n    def test_get_suggestions_by_target_id(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', 'exp_invalid')\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 0)\n\n    def test_query_suggestions(self) -> None:\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 5)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('author_id', 'author_2')\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 3)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('author_id', 'author_2'),\n            ('status', suggestion_models.STATUS_ACCEPTED)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 2)\n\n        queries = [\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('invalid_field', 'value')\n        ]\n        with self.assertRaisesRegex( # type: ignore[no-untyped-call]\n            Exception, 'Not allowed to query on field invalid_field'):\n            suggestion_models.GeneralSuggestionModel.query_suggestions(queries)\n\n        queries = [\n            (\n                'suggestion_type',\n                feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT),\n            ('target_type', feconf.ENTITY_TYPE_EXPLORATION),\n            ('target_id', self.target_id),\n            ('status', suggestion_models.STATUS_IN_REVIEW),\n            ('author_id', 'author_1'),\n            ('final_reviewer_id', 'reviewer_1'),\n            ('score_category', self.score_category)\n        ]\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n\n    def test_query_suggestions_by_language(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n\n        queries = [('language_code', self.translation_language_code)]\n\n        self.assertEqual(\n            len(suggestion_models.GeneralSuggestionModel.query_suggestions(\n                queries)), 1)\n\n    def test_get_translation_suggestions_in_review_ids_with_valid_exp(\n        self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestion_ids = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_ids_with_exp_id(\n                ['exp1']))\n\n        self.assertEqual(len(suggestion_ids), 3)\n\n    def test_get_multiple_translation_suggestions_in_review(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestion_ids = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_ids_with_exp_id(\n                ['exp1']))\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_multiple_suggestions_from_suggestion_ids(suggestion_ids))\n        self.assertEqual(len(suggestions), 3)\n\n    def test_get_translation_suggestions_in_review_with_valid_exp(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 2)\n        self.assertEqual(suggestions[0].target_id, 'exp1')\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n        self.assertEqual(suggestions[1].target_id, 'exp1')\n\n    def test_get_translation_suggestions_in_review_with_exp_ids_by_offset(\n            self) -> None:\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions, offset_1 = (\n            suggestion_models\n                .GeneralSuggestionModel\n                .get_in_review_translation_suggestions_with_exp_ids_by_offset(\n                    limit, 0, 'author_4',\n                    [self.translation_language_code], ['exp1']))\n\n        self.assertEqual(len(suggestions), 1)\n        self.assertEqual(suggestions[0].target_id, 'exp1')\n        self.assertEqual(offset_1, 1)\n        self.assertEqual(\n            suggestions[0].suggestion_type,\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT)\n        self.assertEqual(\n            suggestions[0].status,\n            suggestion_models.STATUS_IN_REVIEW)\n\n    def test_get_in_review_translation_suggestions_by_offset(self) -> None:\n        suggestion_1_id = 'exploration.exp1.thread_6'\n        suggestion_2_id = 'exploration.exp1.thread_7'\n        user_id = 'author1'\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_1_id, self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            suggestion_2_id, self.translation_language_code)\n\n        results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                user_id=user_id,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_1_id)\n        self.assertEqual(offset_1, 1)\n\n        results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=offset_1,\n                user_id=user_id,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_2_id)\n        self.assertEqual(offset_2, 2)\n\n        results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_translation_suggestions_by_offset(\n                limit=limit,\n                offset=offset_2,\n                user_id=user_id,\n                language_codes=[self.translation_language_code]))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), 0)\n        self.assertEqual(offset_3, 2)\n\n    def test_get_in_review_question_suggestions_by_offset(self) -> None:\n        suggestion_1_id = 'skill1.thread1'\n        suggestion_2_id = 'skill1.thread2'\n        user_id = 'author1'\n        limit = 1\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            suggestion_1_id, self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, 'category1',\n            suggestion_2_id, self.question_language_code)\n\n        results, offset_1 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                user_id=user_id))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_1_id)\n        self.assertEqual(offset_1, 1)\n\n        results, offset_2 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=offset_1,\n                user_id=user_id))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, suggestion_2_id)\n        self.assertEqual(offset_2, 2)\n\n        results, offset_3 = (\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_question_suggestions_by_offset(\n                limit=limit,\n                offset=offset_2,\n                user_id=user_id))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), 0)\n        self.assertEqual(offset_3, 2)\n\n    def test_user_created_suggestions_by_offset(self) -> None:\n        authored_translation_suggestion_id = 'exploration.exp1.thread_6'\n        non_authored_translation_suggestion_id = 'exploration.exp1.thread_7'\n        authored_question_suggestion_id = 'skill1.thread1'\n        user_id = 'author1'\n        limit = 1\n        # User created translation suggestion.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, self.score_category,\n            authored_translation_suggestion_id, self.translation_language_code)\n        # Translation suggestion created by a different user.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            non_authored_translation_suggestion_id,\n            self.translation_language_code)\n        # User created question suggestion.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, user_id,\n            'reviewer_2', self.change_cmd, 'category1',\n            authored_question_suggestion_id, self.question_language_code)\n\n        results, translation_suggestion_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                suggestion_type=feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                user_id=user_id))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, authored_translation_suggestion_id)\n        self.assertEqual(translation_suggestion_offset, 1)\n\n        results, question_suggestion_offset = (\n            suggestion_models.GeneralSuggestionModel\n            .get_user_created_suggestions_by_offset(\n                limit=limit,\n                offset=0,\n                suggestion_type=feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                user_id=user_id))\n        # Ruling out the possibility of None for mypy type checking.\n        assert results is not None\n        self.assertEqual(len(results), limit)\n        self.assertEqual(results[0].id, authored_question_suggestion_id)\n        self.assertEqual(question_suggestion_offset, 1)\n\n    def test_get_translation_suggestions_in_review_with_exp_id_with_invalid_exp(\n            self\n    ) -> None:\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'invalid_exp', 'hi'))\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_one_exp(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n\n        # Assert that there is one translation suggestion with the given\n        # exploration id found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['exp1'])), 1)\n\n    def test_get_exp_translation_suggestions_in_review_returns_limited_values(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        with self.swap(feconf, 'DEFAULT_SUGGESTION_QUERY_LIMIT', 1):\n            suggestions = (\n                suggestion_models.GeneralSuggestionModel\n                .get_translation_suggestions_in_review_with_exp_id(\n                    'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 1)\n\n    def test_get_exp_translation_suggestions_in_review_for_resolved_suggestion_returns_no_items( # pylint: disable=line-too-long\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_ACCEPTED, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_exp_translation_suggestions_in_review_for_non_translation_suggestion_returns_no_items( # pylint: disable=line-too-long\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_6', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id(\n                'exp1', self.translation_language_code))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_exp_translation_suggestions_in_review_for_different_language_code_returns_no_items( # pylint: disable=line-too-long\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_4',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', 'hi')\n\n        suggestions = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_in_review_with_exp_id('exp1', 'pt'))\n\n        self.assertEqual(len(suggestions), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_multiple_exps(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_7', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_8', self.translation_language_code)\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['exp2', 'exp3'])), 2)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_with_invalid_exp(\n            self\n    ) -> None:\n        # Assert that there are no translation suggestions with an invalid\n        # exploration id found.\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestion_ids_with_exp_ids(\n                ['invalid_exp'])), 0)\n\n    def test_get_translation_suggestion_ids_with_exp_ids_past_default_query(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp4', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_9', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp5', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread_10', self.translation_language_code)\n\n        with self.swap(feconf, 'DEFAULT_SUGGESTION_QUERY_LIMIT', 1):\n            suggestion_model_results = (\n                suggestion_models\n                .GeneralSuggestionModel\n                .get_translation_suggestion_ids_with_exp_ids(\n                    ['exp4', 'exp5'])\n            )\n\n        # Assert that there are two translation suggestions with the given\n        # exploration ids found. There should be two fetch_page calls.\n        self.assertEqual(len(suggestion_model_results), 2)\n\n    def test_get_all_stale_suggestion_ids(self) -> None:\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS', 0):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_all_stale_suggestion_ids()), 1)\n\n        with self.swap(\n            suggestion_models, 'THRESHOLD_TIME_BEFORE_ACCEPT_IN_MSECS',\n            7 * 24 * 60 * 60 * 1000):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_all_stale_suggestion_ids()), 0)\n\n    def test_get__suggestions_waiting_too_long_raises_if_suggestion_types_empty(\n            self\n    ) -> None:\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES', []):\n            with self.assertRaisesRegex( # type: ignore[no-untyped-call]\n                Exception,\n                'Expected the suggestion types offered on the Contributor '\n                'Dashboard to be nonempty.'):\n                (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n    def test_get_suggestions_waiting_too_long_if_not_contributor_suggestion(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', None)\n        # This mocked list cannot be empty because then the query will fail.\n        mocked_contributor_dashboard_suggestion_types = [\n            feconf.SUGGESTION_TYPE_ADD_QUESTION]\n\n        with self.swap(\n            feconf, 'CONTRIBUTOR_DASHBOARD_SUGGESTION_TYPES',\n            mocked_contributor_dashboard_suggestion_types):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_returns_empty_if_neg_timedelta(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n\n        # Make sure the threshold is nonzero.\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 1):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestions_waited_less_limit(\n            self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_less_than_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=1))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_less_than_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestion_waited_limit(\n            self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        mocked_threshold_review_wait_time_in_days = 2\n        mocked_datetime_eq_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(\n                days=mocked_threshold_review_wait_time_in_days))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_eq_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review()\n                )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 0)\n\n    def test_get_suggestions_waiting_too_long_if_suggestion_waited_past_limit(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 1)\n\n    def test_get_suggestions_waiting_too_long_with_diff_review_wait_times(\n            self\n    ) -> None:\n        with self.mock_datetime_utcnow(self.mocked_datetime_utcnow):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n                feconf.ENTITY_TYPE_EXPLORATION,\n                'exp1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, self.score_category,\n                'exploration.exp1.thread1', self.translation_language_code)\n        with self.mock_datetime_utcnow(\n            self.mocked_datetime_utcnow + datetime.timedelta(days=2)):\n            suggestion_models.GeneralSuggestionModel.create(\n                feconf.SUGGESTION_TYPE_ADD_QUESTION,\n                feconf.ENTITY_TYPE_SKILL,\n                'skill_1', self.target_version_at_submission,\n                suggestion_models.STATUS_IN_REVIEW, 'author_3',\n                'reviewer_2', self.change_cmd, 'category1',\n                'skill1.thread1', self.question_language_code)\n        mocked_threshold_review_wait_time_in_days = 3\n        mocked_datetime_past_review_wait_time_threshold = (\n            self.mocked_datetime_utcnow + datetime.timedelta(days=4))\n\n        with self.mock_datetime_utcnow(\n            mocked_datetime_past_review_wait_time_threshold):\n            with self.swap(\n                suggestion_models,\n                'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS',\n                mocked_threshold_review_wait_time_in_days):\n                suggestions_waiting_too_long_for_review = (\n                    suggestion_models.GeneralSuggestionModel\n                    .get_suggestions_waiting_too_long_for_review())\n\n        # The question suggestion was created 2 days after the translation\n        # suggestion, so it has only waited 1 day for a review, which is less\n        # than 3, the mocked review wait time threshold. Therefore, only the\n        # translation suggestion has waited too long for a review.\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 1)\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[0].id,\n            'exploration.exp1.thread1')\n\n    def test_get_suggestions_waiting_too_long_returns_in_correct_wait_order(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', 'fr')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', 'en')\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp3.thread1', 'hi')\n\n        with self.swap(\n            suggestion_models,\n            'SUGGESTION_REVIEW_WAIT_TIME_THRESHOLD_IN_DAYS', 0):\n            suggestions_waiting_too_long_for_review = (\n                suggestion_models.GeneralSuggestionModel\n                .get_suggestions_waiting_too_long_for_review()\n            )\n\n        self.assertEqual(len(suggestions_waiting_too_long_for_review), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[0].id,\n            'exploration.exp1.thread1')\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[1].id,\n            'exploration.exp2.thread1')\n        self.assertEqual(\n            suggestions_waiting_too_long_for_review[2].id,\n            'exploration.exp3.thread1')\n\n    def test_get_in_review_suggestions_in_score_categories(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_6', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_2',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_7', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_2',\n            'reviewer_2', self.change_cmd, 'category3',\n            'exploration.exp1.thread_8', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_2',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_9', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_10', None)\n\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1'], 'author_3')), 0)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1'], 'author_2')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category2'], 'author_2')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category2'], 'author_3')), 1)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category2', 'category3'], 'author_1')), 4)\n        self.assertEqual(len(\n            suggestion_models.GeneralSuggestionModel\n            .get_in_review_suggestions_in_score_categories(\n                ['category1', 'category_invalid'], 'author_2')), 1)\n        with self.assertRaisesRegex( # type: ignore[no-untyped-call]\n            Exception, 'Received empty list of score categories'):\n            self.assertEqual(len(\n                suggestion_models.GeneralSuggestionModel\n                .get_in_review_suggestions_in_score_categories(\n                    [], 'author_1')), 0)\n\n    def test_get_all_score_categories(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'exploration.exp1.thread_11', None)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            self.target_id, self.target_version_at_submission,\n            suggestion_models.STATUS_REJECTED, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'exploration.exp1.thread_12', None)\n        score_categories = (\n            suggestion_models.GeneralSuggestionModel.get_all_score_categories())\n        self.assertIn(self.score_category, score_categories)\n        self.assertIn('category1', score_categories)\n        self.assertIn('category2', score_categories)\n\n    def test_get_question_suggestions_waiting_longest_for_review(self) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'skill1.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill2.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill3.thread1', self.question_language_code)\n\n        question_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_question_suggestions_waiting_longest_for_review()\n        )\n\n        self.assertEqual(len(question_suggestion_models), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(question_suggestion_models[0].id, 'skill1.thread1')\n        self.assertEqual(question_suggestion_models[1].id, 'skill2.thread1')\n        self.assertEqual(question_suggestion_models[2].id, 'skill3.thread1')\n\n    def test_get_translation_suggestions_waiting_longest_for_review_per_lang(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp3', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp3.thread1', self.translation_language_code)\n        # Create a translation suggestion that has a different language code.\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp4', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp4.thread1', 'fr')\n\n        translation_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                self.translation_language_code\n            )\n        )\n\n        self.assertEqual(len(translation_suggestion_models), 3)\n        # Assert that the order of the returned suggestion models represents\n        # the suggestions sorted in descending order, based on how long each\n        # suggestion has been waiting for review.\n        self.assertEqual(\n            translation_suggestion_models[0].id, 'exploration.exp1.thread1')\n        self.assertEqual(\n            translation_suggestion_models[1].id, 'exploration.exp2.thread1')\n        self.assertEqual(\n            translation_suggestion_models[2].id, 'exploration.exp3.thread1')\n\n        translation_suggestion_models_with_different_lang_code = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                'fr'\n            )\n        )\n\n        self.assertEqual(len(\n            translation_suggestion_models_with_different_lang_code), 1)\n        self.assertEqual(\n            translation_suggestion_models_with_different_lang_code[0].id,\n            'exploration.exp4.thread1')\n\n    def test_get_translation_suggestions_waiting_longest_for_review_wrong_lang(\n            self\n    ) -> None:\n        translation_suggestion_models = (\n            suggestion_models.GeneralSuggestionModel\n            .get_translation_suggestions_waiting_longest_for_review(\n                'wrong_language_code'\n            )\n        )\n\n        self.assertEqual(len(translation_suggestion_models), 0)\n\n    def test_get_translation_suggestions_waiting_longest_for_review_max_fetch(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp1.thread1', self.translation_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_TRANSLATE_CONTENT,\n            feconf.ENTITY_TYPE_EXPLORATION,\n            'exp2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, self.score_category,\n            'exploration.exp2.thread1', self.translation_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'MAX_TRANSLATION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS', 1):\n            translation_suggestion_models = (\n                suggestion_models.GeneralSuggestionModel.\n                get_translation_suggestions_waiting_longest_for_review(\n                    self.translation_language_code)\n            )\n\n        # There should only be one translation suggestion returned since we\n        # changed the maximum translations to fetch to 1.\n        self.assertEqual(len(translation_suggestion_models), 1)\n        self.assertEqual(\n            translation_suggestion_models[0].id, 'exploration.exp1.thread1')\n\n    def test_get_question_suggestions_waiting_longest_for_review_max_fetch(\n            self\n    ) -> None:\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_1', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category1',\n            'skill1.thread1', self.question_language_code)\n        suggestion_models.GeneralSuggestionModel.create(\n            feconf.SUGGESTION_TYPE_ADD_QUESTION,\n            feconf.ENTITY_TYPE_SKILL,\n            'skill_2', self.target_version_at_submission,\n            suggestion_models.STATUS_IN_REVIEW, 'author_3',\n            'reviewer_2', self.change_cmd, 'category2',\n            'skill2.thread1', self.question_language_code)\n\n        with self.swap(\n            suggestion_models,\n            'MAX_QUESTION_SUGGESTIONS_TO_FETCH_FOR_REVIEWER_EMAILS', 1):\n            question_suggestion_models = (\n                suggestion_models.GeneralSuggestionModel\n                .get_question_suggestions_waiting_longest_for_review()\n            )\n\n        # There should only be one question suggestion returned since we\n        # changed the maximum questions to fetch to 1.\n        self.assertEqual(len(question_suggestion_models), 1)\n        self.assertEqual(question_suggestion_models[0].id, 'skill1.thread1')\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.GeneralSuggestionModel\n            .export_data('non_existent_user'))\n        test_data: Dict[str, str] = {}\n        self.assertEqual(user_data, test_data)\n\n    def test_export_data_nontrivial(self) -> None:\n        test_export_suggestion_type = (\n            feconf.SUGGESTION_TYPE_EDIT_STATE_CONTENT)\n        test_export_target_type = feconf.ENTITY_TYPE_EXPLORATION\n        test_export_target_id = self.target_id\n        test_export_target_version = self.target_version_at_submission\n        test_export_status = suggestion_models.STATUS_IN_REVIEW\n        test_export_author = 'test_export_author'\n        test_export_reviewer = 'test_export_reveiwer'\n        test_export_change_cmd = self.change_cmd\n        test_export_score_category = 'category1'\n        test_export_thread_id = 'exploration.exp1.thread_export'\n        test_export_language_code = 'en'\n        test_export_edited_by_reviewer = False\n\n        suggestion_models.GeneralSuggestionModel.create(\n            test_export_suggestion_type,\n            test_export_target_type,\n            test_export_target_id,\n            test_export_target_version,\n            test_export_status,\n            test_export_author,\n            test_export_reviewer,\n            test_export_change_cmd,\n            test_export_score_category,\n            test_export_thread_id,\n            test_export_language_code\n        )\n\n        user_data = (\n            suggestion_models.GeneralSuggestionModel\n            .export_data('test_export_author'))\n\n        test_data = {\n            test_export_thread_id: {\n                'suggestion_type': test_export_suggestion_type,\n                'target_type': test_export_target_type,\n                'target_id': test_export_target_id,\n                'target_version_at_submission': test_export_target_version,\n                'status': test_export_status,\n                'change_cmd': test_export_change_cmd,\n                'language_code': test_export_language_code,\n                'edited_by_reviewer': test_export_edited_by_reviewer\n            },\n\n        }\n\n        self.assertEqual(user_data, test_data)\n\n\nclass GeneralVoiceoverApplicationModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests for the GeneralVoiceoverApplicationModel class.\"\"\"\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            suggestion_models.GeneralSuggestionModel.get_deletion_policy(),\n            base_models.DELETION_POLICY.LOCALLY_PSEUDONYMIZE)\n\n    def test_has_reference_to_user_id_author(self) -> None:\n        self.assertFalse(\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .has_reference_to_user_id('author_1'))\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id='author_1',\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n\n        self.assertTrue(\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .has_reference_to_user_id('author_1'))\n        self.assertFalse(\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .has_reference_to_user_id('author_2'))\n\n    def test_get_user_voiceover_applications(self) -> None:\n        author_id = 'author'\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_user_voiceover_applications(author_id))\n        self.assertEqual(applicant_models, [])\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id=author_id,\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_user_voiceover_applications(author_id))\n        self.assertEqual(len(applicant_models), 1)\n        self.assertEqual(applicant_models[0].id, 'application_id')\n\n    def test_get_user_voiceover_applications_with_status(self) -> None:\n        author_id = 'author'\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_user_voiceover_applications(\n                author_id, status=suggestion_models.STATUS_IN_REVIEW))\n        self.assertEqual(applicant_models, [])\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id=author_id,\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_user_voiceover_applications(\n                author_id, status=suggestion_models.STATUS_IN_REVIEW))\n        self.assertEqual(len(applicant_models), 1)\n        self.assertEqual(applicant_models[0].id, 'application_id')\n\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_user_voiceover_applications(\n                author_id, status=suggestion_models.STATUS_REJECTED))\n        self.assertEqual(applicant_models, [])\n\n    def test_get_reviewable_voiceover_applications(self) -> None:\n        author_id = 'author'\n        reviewer_id = 'reviewer_id'\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_reviewable_voiceover_applications(reviewer_id))\n        self.assertEqual(applicant_models, [])\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_reviewable_voiceover_applications(author_id))\n        self.assertEqual(applicant_models, [])\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id=author_id,\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_reviewable_voiceover_applications(reviewer_id))\n        self.assertEqual(len(applicant_models), 1)\n        self.assertEqual(applicant_models[0].id, 'application_id')\n\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_reviewable_voiceover_applications(author_id))\n        self.assertEqual(applicant_models, [])\n\n    def test_get_voiceover_applications(self) -> None:\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id='author_id',\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_voiceover_applications('exploration', 'exp_id', 'en'))\n        self.assertEqual(len(applicant_models), 1)\n        self.assertEqual(applicant_models[0].id, 'application_id')\n\n        applicant_models = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .get_voiceover_applications('exploration', 'exp_id', 'hi'))\n        self.assertEqual(len(applicant_models), 0)\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .export_data('non_existent_user'))\n        test_data: Dict[str, str] = {}\n        self.assertEqual(user_data, test_data)\n\n    def test_export_data_nontrivial(self) -> None:\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_1_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id='author_1',\n            final_reviewer_id='reviewer_id',\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n\n        suggestion_models.GeneralVoiceoverApplicationModel(\n            id='application_2_id',\n            target_type='exploration',\n            target_id='exp_id',\n            status=suggestion_models.STATUS_IN_REVIEW,\n            author_id='author_1',\n            final_reviewer_id=None,\n            language_code='en',\n            filename='application_audio.mp3',\n            content='<p>Some content</p>',\n            rejection_message=None).put()\n\n        expected_data = {\n            'application_1_id': {\n                'target_type': 'exploration',\n                'target_id': 'exp_id',\n                'status': 'review',\n                'language_code': 'en',\n                'filename': 'application_audio.mp3',\n                'content': '<p>Some content</p>',\n                'rejection_message': None\n            },\n            'application_2_id': {\n                'target_type': 'exploration',\n                'target_id': 'exp_id',\n                'status': 'review',\n                'language_code': 'en',\n                'filename': 'application_audio.mp3',\n                'content': '<p>Some content</p>',\n                'rejection_message': None\n            }\n        }\n        user_data = (\n            suggestion_models.GeneralVoiceoverApplicationModel\n            .export_data('author_1'))\n        self.assertEqual(expected_data, user_data)\n\n\nclass CommunityContributionStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the CommunityContributionStatsModel class.\"\"\"\n\n    translation_reviewer_counts_by_lang_code = {\n        'hi': 0,\n        'en': 1\n    }\n\n    translation_suggestion_counts_by_lang_code = {\n        'fr': 6,\n        'en': 5\n    }\n\n    question_reviewer_count = 1\n    question_suggestion_count = 4\n\n    def test_get_returns_community_contribution_stats_model_when_it_exists(\n            self\n    ) -> None:\n        suggestion_models.CommunityContributionStatsModel(\n            id=suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID,\n            translation_reviewer_counts_by_lang_code=(\n                self.translation_reviewer_counts_by_lang_code),\n            translation_suggestion_counts_by_lang_code=(\n                self.translation_suggestion_counts_by_lang_code),\n            question_reviewer_count=self.question_reviewer_count,\n            question_suggestion_count=self.question_suggestion_count\n        ).put()\n\n        community_contribution_stats_model = (\n            suggestion_models.CommunityContributionStatsModel.get()\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert community_contribution_stats_model is not None\n        self.assertEqual(\n            community_contribution_stats_model.id,\n            suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_reviewer_counts_by_lang_code\n            ),\n            self.translation_reviewer_counts_by_lang_code\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_suggestion_counts_by_lang_code\n            ),\n            self.translation_suggestion_counts_by_lang_code\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_reviewer_count,\n            self.question_reviewer_count\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_suggestion_count,\n            self.question_suggestion_count\n        )\n\n    def test_get_returns_new_community_contribution_stats_model_if_not_found(\n            self\n    ) -> None:\n        \"\"\"If the model has not been created yet, get should create the model\n        with default values.\n        \"\"\"\n        community_contribution_stats_model = (\n            suggestion_models.CommunityContributionStatsModel.get()\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert community_contribution_stats_model is not None\n        self.assertEqual(\n            community_contribution_stats_model.id,\n            suggestion_models.COMMUNITY_CONTRIBUTION_STATS_MODEL_ID\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_reviewer_counts_by_lang_code\n            ), {}\n        )\n        self.assertEqual(\n            (\n                community_contribution_stats_model\n                .translation_suggestion_counts_by_lang_code\n            ), {}\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_reviewer_count, 0\n        )\n        self.assertEqual(\n            community_contribution_stats_model.question_suggestion_count, 0\n        )\n\n    def test_get_deletion_policy_returns_not_applicable(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.CommunityContributionStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.NOT_APPLICABLE\n        )\n\n\nclass TranslationContributionStatsModelUnitTests(test_utils.GenericTestBase):\n    \"\"\"Tests the TranslationContributionStatsModel class.\"\"\"\n\n    LANGUAGE_CODE = 'es'\n    CONTRIBUTOR_USER_ID = 'user_id'\n    TOPIC_ID = 'topic_id'\n    SUBMITTED_TRANSLATIONS_COUNT = 2\n    SUBMITTED_TRANSLATION_WORD_COUNT = 100\n    ACCEPTED_TRANSLATIONS_COUNT = 1\n    ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT = 0\n    ACCEPTED_TRANSLATION_WORD_COUNT = 50\n    REJECTED_TRANSLATIONS_COUNT = 0\n    REJECTED_TRANSLATION_WORD_COUNT = 0\n    # Timestamp dates in sec since epoch for Mar 19 2021 UTC.\n    CONTRIBUTION_DATES = [\n        datetime.date.fromtimestamp(1616173836),\n        datetime.date.fromtimestamp(1616173837)\n    ]\n\n    def test_get_returns_model_when_it_exists(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n\n        translation_contribution_stats_model = (\n            suggestion_models.TranslationContributionStatsModel.get(\n                self.LANGUAGE_CODE, self.CONTRIBUTOR_USER_ID, self.TOPIC_ID\n            )\n        )\n\n        # Ruling out the possibility of None for mypy type checking.\n        assert translation_contribution_stats_model is not None\n        self.assertEqual(\n            translation_contribution_stats_model.language_code,\n            self.LANGUAGE_CODE\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.contributor_user_id,\n            self.CONTRIBUTOR_USER_ID\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.submitted_translations_count,\n            self.SUBMITTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .submitted_translation_word_count\n            ),\n            self.SUBMITTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.accepted_translations_count,\n            self.ACCEPTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translations_without_reviewer_edits_count\n            ),\n            self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .accepted_translation_word_count\n            ),\n            self.ACCEPTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.rejected_translations_count,\n            self.REJECTED_TRANSLATIONS_COUNT\n        )\n        self.assertEqual(\n            (\n                translation_contribution_stats_model\n                .rejected_translation_word_count\n            ),\n            self.REJECTED_TRANSLATION_WORD_COUNT\n        )\n        self.assertEqual(\n            translation_contribution_stats_model.contribution_dates,\n            self.CONTRIBUTION_DATES\n        )\n\n    def test_get_deletion_policy(self) -> None:\n        self.assertEqual(\n            (\n                suggestion_models.TranslationContributionStatsModel\n                .get_deletion_policy()\n            ),\n            base_models.DELETION_POLICY.DELETE)\n\n    def test_apply_deletion_policy(self) -> None:\n        suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        self.assertTrue(\n            suggestion_models.TranslationContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n        (\n            suggestion_models.TranslationContributionStatsModel\n            .apply_deletion_policy(self.CONTRIBUTOR_USER_ID)\n        )\n\n        self.assertFalse(\n            suggestion_models.TranslationContributionStatsModel\n            .has_reference_to_user_id(self.CONTRIBUTOR_USER_ID))\n\n    def test_export_data_trivial(self) -> None:\n        user_data = (\n            suggestion_models.TranslationContributionStatsModel\n            .export_data('non_existent_user'))\n        self.assertEqual(user_data, {})\n\n    def test_export_data_nontrivial(self) -> None:\n        topic_id_2 = 'topic ID 2'\n        # Seed translation stats data for two different topics.\n        model_1_id = suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=self.TOPIC_ID,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        model_2_id = suggestion_models.TranslationContributionStatsModel.create(\n            language_code=self.LANGUAGE_CODE,\n            contributor_user_id=self.CONTRIBUTOR_USER_ID,\n            topic_id=topic_id_2,\n            submitted_translations_count=self.SUBMITTED_TRANSLATIONS_COUNT,\n            submitted_translation_word_count=(\n                self.SUBMITTED_TRANSLATION_WORD_COUNT),\n            accepted_translations_count=self.ACCEPTED_TRANSLATIONS_COUNT,\n            accepted_translations_without_reviewer_edits_count=(\n                self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n            accepted_translation_word_count=(\n                self.ACCEPTED_TRANSLATION_WORD_COUNT),\n            rejected_translations_count=self.REJECTED_TRANSLATIONS_COUNT,\n            rejected_translation_word_count=(\n                self.REJECTED_TRANSLATION_WORD_COUNT),\n            contribution_dates=self.CONTRIBUTION_DATES\n        )\n        dates_in_iso_format = [\n            date.isoformat() for date in self.CONTRIBUTION_DATES]\n        expected_data = {\n            model_1_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': self.TOPIC_ID,\n                'submitted_translations_count': (\n                    self.SUBMITTED_TRANSLATIONS_COUNT),\n                'submitted_translation_word_count': (\n                    self.SUBMITTED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_without_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'rejected_translations_count': (\n                    self.REJECTED_TRANSLATIONS_COUNT),\n                'rejected_translation_word_count': (\n                    self.REJECTED_TRANSLATION_WORD_COUNT),\n                'contribution_dates': dates_in_iso_format\n            },\n            model_2_id: {\n                'language_code': self.LANGUAGE_CODE,\n                'topic_id': topic_id_2,\n                'submitted_translations_count': (\n                    self.SUBMITTED_TRANSLATIONS_COUNT),\n                'submitted_translation_word_count': (\n                    self.SUBMITTED_TRANSLATION_WORD_COUNT),\n                'accepted_translations_count': (\n                    self.ACCEPTED_TRANSLATIONS_COUNT),\n                'accepted_translations_without_reviewer_edits_count': (\n                    self.ACCEPTED_TRANSLATIONS_WITHOUT_REVIEWER_EDITS_COUNT),\n                'accepted_translation_word_count': (\n                    self.ACCEPTED_TRANSLATION_WORD_COUNT),\n                'rejected_translations_count': (\n                    self.REJECTED_TRANSLATIONS_COUNT),\n                'rejected_translation_word_count': (\n                    self.REJECTED_TRANSLATION_WORD_COUNT),\n                'contribution_dates': dates_in_iso_format\n            }\n        }\n\n        user_data = (\n            suggestion_models.TranslationContributionStatsModel\n            .export_data(self.CONTRIBUTOR_USER_ID))\n\n        self.assertEqual(expected_data, user_data)\n"
    }
  ],
  "questions": [
    "Hy, why do you need a custom linter and not, e.g., for python \"black\" or for AngularJS \"prettier\"? If you want to use these - opinionated but state-of-the-art - tools, then please assign me to this issue :)",
    "Hello @U8NWXD, I am unable to register my IndentationChecker class. Whenever I am registering my custom check class in the register function, it is throwing UnboundLocalError on tests run. If I remove `linter.register_checker(IndentationChecker(linter))` from register function, it works fine. Can you guide me on this? I am stuck on this for hours. I closely followed the documentation. It is no help at this stage.\r\n\r\nmy custom linter rule class (not fully-completed yet):\r\n![image](https://user-images.githubusercontent.com/57310134/181806422-2983b40c-d21b-4e71-ae25-44e8b7e6231d.png)\r\n\r\n\r\nregister func in pylint_extensions.py:\r\n![image](https://user-images.githubusercontent.com/57310134/181805418-72e001d0-e2ac-4ec2-85d4-d6061a72a41a.png)\r\n\r\n\r\nHere's the error:\r\n![image](https://user-images.githubusercontent.com/57310134/181805232-e20d2fef-f7be-4b08-b2af-fea909e3d4e2.png)\r\n\r\n\r\ncommand used for running tests:\r\n`python -m scripts.run_backend_tests --test_target=scripts.linters.pylint_extensions_test --verbose`",
    "@FaazAbidi can you paste the logs you see from before the `WARNING: FAILED TO RUN...` message? The `AttributeError: 'NoneType' object has no attribute 'group'` error usually arises because the test failed to output a coverage message because of an earlier error. Also, have you merged in the latest `develop`? We recently changed the code throwing `UnboundLocalError` to fix a bug"
  ],
  "golden_answers": [
    "@RMeissnerCC we don't use tools like black or prettier because they enforce a different coding style than our [style guide](https://github.com/oppia/oppia/wiki/Coding-style-guide), and as far as I know, no one has been able to configure them to enforce our style guide",
    "@FaazAbidi can you paste the logs you see from before the `WARNING: FAILED TO RUN...` message? The `AttributeError: 'NoneType' object has no attribute 'group'` error usually arises because the test failed to output a coverage message because of an earlier error. Also, have you merged in the latest `develop`? We recently changed the code throwing `UnboundLocalError` to fix a bug",
    "Thank you @U8NWXD. After merging the latest `develop`, the logs were really helpful (nice improvement), I found the cause of error. It was message id. I was using the message id `C0040`  and it was already taken by some other custom rule. So, I changed it and it's working fine now. Thank you!"
  ],
  "questions_generated": [
    "What is the primary goal of the issue described in the oppia_oppia repository?",
    "Why is there a need for 8-space indentation in some scenarios according to the issue description?",
    "What is an example of correct indentation for closing braces according to the issue description?",
    "What are the challenges in implementing the custom lint check for indentation?",
    "What is the role of the `suggestion_services` module in the oppia_oppia repository?",
    "How does the issue description propose dealing with parentheses/braces/brackets in indentation?",
    "What is the significance of the `feconf` module in the context of this issue?",
    "What is the purpose of the `SuggestionHandler` class in the oppia_oppia repository?",
    "Why might reviewers have previously needed to manually check indentations, and how does this issue aim to alleviate that?"
  ],
  "golden_answers_generated": [
    "The primary goal is to implement a custom pylint check for indentation in Python code to ensure consistent indentation styles and improve code readability.",
    "The need for 8-space indentation arises in situations where indenting by 4 spaces could be confusing, such as when continuing lines of a condition in an `if` statement, to improve clarity and readability.",
    "Correct indentation example for closing braces is positioning them at the end of the line or at the same indentation level as the opening brace/bracket/parenthesis, such as:\n\n```python\nmy_list = {\n    'a': [\n        1,\n        2,\n    ],\n    'b': True,\n}\n```",
    "Challenges include accurately identifying various indentation scenarios, such as distinguishing between necessary and unnecessary additional indentation, handling multiline statements, and ensuring compatibility with Python's syntax rules.",
    "In the oppia_oppia repository, the `suggestion_services` module is likely responsible for handling operations related to suggestions, such as creating, updating, and retrieving suggestion data, although specific details are not provided in the given context.",
    "The issue description suggests that in some cases, it is acceptable to not indent a pair of parentheses/braces/brackets if they are placed on a new line, treating them as a single opening character, thereby allowing the following lines to be indented by only 4 spaces.",
    "The `feconf` module is used to define constants and configuration options, such as `SUGGESTION_TYPE_CHOICES` and `SUGGESTION_TARGET_TYPE_CHOICES`, which are referenced in the `SuggestionHandler` class for validating input data.",
    "The `SuggestionHandler` class handles operations related to suggestions, specifically managing POST requests that involve creating or interacting with suggestions, as indicated by its URL path and handler argument schemas.",
    "Reviewers likely needed to manually check indentations due to the absence of automated checks for specific indentation styles. This issue aims to alleviate that by proposing a custom pylint check to automatically enforce consistent indentation practices."
  ]
}