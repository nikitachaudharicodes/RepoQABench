{
  "repo_name": "bokeh_bokeh",
  "issue_id": "9907",
  "issue_description": "# Improve Auth Request Handler hierarchy\n\n`AuthMixin` is not a proper Mixin since it shadows methods on another base class. Move to just single inheritance as described in https://github.com/bokeh/bokeh/pull/9906#issuecomment-611855445",
  "issue_comments": [
    {
      "id": 626565637,
      "user": "ayushiitr2901",
      "body": "You mentioned about renaming class `AuthMixin` to `BokehAuthRequestHandler`. Would it be better handled by creating a new file, defining the class `BokehAuthRequestHandler`, and adding a deprecation message to the old auth_mixin file."
    },
    {
      "id": 626804433,
      "user": "bryevdv",
      "body": "I don't personally think there is any need for a deprecation on this, I think we can just take the change at 3.0 without anything else done up front. It's not part of any user-facing code paths, I can't imagine any scenario that any user would even know about this class much less be trying to use it directly. "
    },
    {
      "id": 627131155,
      "user": "ayushiitr2901",
      "body": "Oh, I get it. I agree the code part is not visible to the user directly and hence there is no need to give a deprecation message. I will go ahead and make the changes accordingly."
    },
    {
      "id": 627142541,
      "user": "bryevdv",
      "body": "If a PR is made now, it will have to be against the `future` branch not `master`. This is a breaking change so it should go in a future 3.0 release, but that's probably quite a way off, at least towards the end of this year if not sometime next year. Earlier I meant that I did not think a providing an explicit deprecation is necessary during the rest of the 2.x series leading up to 3.0 (i.e the change can land at 3.0 with no fore warning)"
    },
    {
      "id": 627144086,
      "user": "ayushiitr2901",
      "body": "Oh apologies, I already made a pull request, should I close it for now or mark it to the future branch?"
    },
    {
      "id": 627446423,
      "user": "bryevdv",
      "body": "@ayushiitr2901 No apologies necessary! Thinking a bit about it it might have been misleading to mark this as a `Good First Isssue` since it does have this extra consideration. \r\n\r\nI don't have a strong preference about merging now (against `future`) or closing and re-resubmitting nearer to 3.0. In general it's a bit of a pain to keep long running branches of parallel development, but @mattpap  has been tending to `future`. @mattpap do you want this in `future` now? or close and wait?"
    },
    {
      "id": 628608584,
      "user": "mattpap",
      "body": "> do you want this in future now? or close and wait?\r\n\r\nI changed the base of PR #10011 to `future`, so it can be merged as soon as code quality issues are addressed. As to `future` branch itself, I backported all changes from that branch to `master` and reset it to `master`, so that we don't duplicated commits."
    },
    {
      "id": 628841186,
      "user": "bryevdv",
      "body": "@mattpap it can't be merged into master now, if that is what you mean?  It is a breaking change so should go in 3.0 I would say in that case close for now and re-open when we are on final approach for 3.0"
    },
    {
      "id": 629079632,
      "user": "ayushiitr2901",
      "body": "I will look at the code bug in the PR and fix it. But, I agree with @bryevdv, this is a big change that can be merged in the next coming update as a big one."
    },
    {
      "id": 629188722,
      "user": "mattpap",
      "body": "> It is a breaking change so should go in 3.0 (...)\r\n\r\nThat's why it should go into `future` branch. As I said, I changed the base of the PR to `future`, so it can be merged into that branch as soon as test failures are sorted out."
    },
    {
      "id": 2439554365,
      "user": "github-actions[bot]",
      "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
    }
  ],
  "text_context": "# Improve Auth Request Handler hierarchy\n\n`AuthMixin` is not a proper Mixin since it shadows methods on another base class. Move to just single inheritance as described in https://github.com/bokeh/bokeh/pull/9906#issuecomment-611855445\n\nYou mentioned about renaming class `AuthMixin` to `BokehAuthRequestHandler`. Would it be better handled by creating a new file, defining the class `BokehAuthRequestHandler`, and adding a deprecation message to the old auth_mixin file.\n\nI don't personally think there is any need for a deprecation on this, I think we can just take the change at 3.0 without anything else done up front. It's not part of any user-facing code paths, I can't imagine any scenario that any user would even know about this class much less be trying to use it directly. \n\nOh, I get it. I agree the code part is not visible to the user directly and hence there is no need to give a deprecation message. I will go ahead and make the changes accordingly.\n\nIf a PR is made now, it will have to be against the `future` branch not `master`. This is a breaking change so it should go in a future 3.0 release, but that's probably quite a way off, at least towards the end of this year if not sometime next year. Earlier I meant that I did not think a providing an explicit deprecation is necessary during the rest of the 2.x series leading up to 3.0 (i.e the change can land at 3.0 with no fore warning)\n\nOh apologies, I already made a pull request, should I close it for now or mark it to the future branch?\n\n@ayushiitr2901 No apologies necessary! Thinking a bit about it it might have been misleading to mark this as a `Good First Isssue` since it does have this extra consideration. \r\n\r\nI don't have a strong preference about merging now (against `future`) or closing and re-resubmitting nearer to 3.0. In general it's a bit of a pain to keep long running branches of parallel development, but @mattpap  has been tending to `future`. @mattpap do you want this in `future` now? or close and wait?\n\n> do you want this in future now? or close and wait?\r\n\r\nI changed the base of PR #10011 to `future`, so it can be merged as soon as code quality issues are addressed. As to `future` branch itself, I backported all changes from that branch to `master` and reset it to `master`, so that we don't duplicated commits.\n\n@mattpap it can't be merged into master now, if that is what you mean?  It is a breaking change so should go in 3.0 I would say in that case close for now and re-open when we are on final approach for 3.0\n\nI will look at the code bug in the PR and fix it. But, I agree with @bryevdv, this is a big change that can be merged in the next coming update as a big one.\n\n> It is a breaking change so should go in 3.0 (...)\r\n\r\nThat's why it should go into `future` branch. As I said, I changed the base of the PR to `future`, so it can be merged into that branch as soon as test failures are sorted out.\n\nThis issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.",
  "pr_link": "https://github.com/bokeh/bokeh/pull/9906",
  "code_context": [
    {
      "filename": "bokeh/server/views/auth_mixin.py",
      "content": "#-----------------------------------------------------------------------------\n# Copyright (c) 2012 - 2020, Anaconda, Inc., and Bokeh Contributors.\n# All rights reserved.\n#\n# The full license is in the file LICENSE.txt, distributed with this software.\n#-----------------------------------------------------------------------------\n''' Provide a mixin class to add authorization hooks to a request handler.\n\n'''\n\n#-----------------------------------------------------------------------------\n# Boilerplate\n#-----------------------------------------------------------------------------\nimport logging # isort:skip\nlog = logging.getLogger(__name__)\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Globals and constants\n#-----------------------------------------------------------------------------\n\n__all__ = (\n    'AuthMixin',\n)\n\n#-----------------------------------------------------------------------------\n# General API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Dev API\n#-----------------------------------------------------------------------------\n\nclass AuthMixin(object):\n    ''' This mixin adds the expected Tornado authorization hooks:\n\n    * get_login_url\n    * get_current_user\n    * prepare\n\n    All of these delegate to the a :class:`~bokeh.serve.auth_provider.AuthProvider`\n    confiured on the Bokeh tornado application.\n\n    '''\n\n    def get_login_url(self):\n        ''' Delegates to``get_login_url`` method of the auth provider, or the\n        ``login_url`` attribute.\n\n        '''\n        if self.application.auth_provider.get_login_url is not None:\n            return self.application.auth_provider.get_login_url(self)\n        if self.application.auth_provider.login_url is not None:\n            return self.application.auth_provider.login_url\n        raise RuntimeError('login_url or get_login_url() must be supplied when authentication hooks are enabled')\n\n    def get_current_user(self):\n        ''' Delegate to the synchronous ``get_user`` method of the auth\n        provider\n\n        '''\n        if self.application.auth_provider.get_user is not None:\n            return self.application.auth_provider.get_user(self)\n        return \"default_user\"\n\n    async def prepare(self):\n        ''' Async counterpart to ``get_current_user``\n\n        '''\n        if self.application.auth_provider.get_user_async is not None:\n            self.current_user = await self.application.auth_provider.get_user_async(self)\n\n#-----------------------------------------------------------------------------\n# Private API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Code\n#-----------------------------------------------------------------------------\n"
    },
    {
      "filename": "bokeh/server/views/root_handler.py",
      "content": "#-----------------------------------------------------------------------------\n# Copyright (c) 2012 - 2020, Anaconda, Inc., and Bokeh Contributors.\n# All rights reserved.\n#\n# The full license is in the file LICENSE.txt, distributed with this software.\n#-----------------------------------------------------------------------------\n''' Provide a Request handler that lists the application (if more than one)\nor (if only one) redirects to the route of that applications.\n\n'''\n\n#-----------------------------------------------------------------------------\n# Boilerplate\n#-----------------------------------------------------------------------------\nimport logging # isort:skip\nlog = logging.getLogger(__name__)\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\n# External imports\nfrom tornado.web import RequestHandler, authenticated\n\n# Bokeh imports\nfrom .auth_mixin import AuthMixin\n\n#-----------------------------------------------------------------------------\n# Globals and constants\n#-----------------------------------------------------------------------------\n\n__all__ = (\n    'RootHandler',\n)\n\n#-----------------------------------------------------------------------------\n# General API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Dev API\n#-----------------------------------------------------------------------------\n\nclass RootHandler(AuthMixin, RequestHandler):\n    ''' Implements a custom Tornado handler to display the available applications\n    If only one application it redirects to that application route\n    '''\n\n    def initialize(self, *args, **kw):\n        self.applications = kw[\"applications\"]\n        self.prefix = kw[\"prefix\"]\n        self.index = kw[\"index\"]\n        self.use_redirect = kw[\"use_redirect\"]\n\n    @authenticated\n    async def get(self, *args, **kwargs):\n        prefix = \"\" if self.prefix is None else self.prefix\n        if self.use_redirect and len(self.applications) == 1:\n            app_names = list(self.applications.keys())\n            redirect_to = prefix + app_names[0]\n            self.redirect(redirect_to)\n        else:\n            index = \"app_index.html\" if self.index is None else self.index\n            self.render(index, prefix=prefix, items=sorted(self.applications.keys()))\n\n    # NOTE: The methods below exist on both AuthMixin and RequestHandler. This\n    # makes it explicit which of the versions is intended to be called.\n    get_login_url = AuthMixin.get_login_url\n    get_current_user = AuthMixin.get_current_user\n    prepare = AuthMixin.prepare\n\n#-----------------------------------------------------------------------------\n# Private API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Code\n#-----------------------------------------------------------------------------\n"
    },
    {
      "filename": "bokeh/server/views/session_handler.py",
      "content": "#-----------------------------------------------------------------------------\n# Copyright (c) 2012 - 2020, Anaconda, Inc., and Bokeh Contributors.\n# All rights reserved.\n#\n# The full license is in the file LICENSE.txt, distributed with this software.\n#-----------------------------------------------------------------------------\n''' Abstract request handler that handles bokeh-session-id\n\n'''\n\n#-----------------------------------------------------------------------------\n# Boilerplate\n#-----------------------------------------------------------------------------\nimport logging # isort:skip\nlog = logging.getLogger(__name__)\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\n# External imports\nfrom tornado.web import HTTPError, RequestHandler, authenticated\n\n# Bokeh imports\nfrom bokeh.util.token import (\n    check_token_signature,\n    generate_jwt_token,\n    generate_session_id,\n    get_session_id,\n)\n\n# Bokeh imports\nfrom .auth_mixin import AuthMixin\n\n#-----------------------------------------------------------------------------\n# Globals and constants\n#-----------------------------------------------------------------------------\n\n__all__ = (\n    'SessionHandler',\n)\n\n#-----------------------------------------------------------------------------\n# General API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Dev API\n#-----------------------------------------------------------------------------\n\nclass SessionHandler(AuthMixin, RequestHandler):\n    ''' Implements a custom Tornado handler for document display page\n\n    '''\n    def __init__(self, tornado_app, *args, **kw):\n        self.application_context = kw['application_context']\n        self.bokeh_websocket_path = kw['bokeh_websocket_path']\n        # Note: tornado_app is stored as self.application\n        super().__init__(tornado_app, *args, **kw)\n\n    def initialize(self, *args, **kw):\n        pass\n\n    @authenticated\n    async def get_session(self):\n        token = self.get_argument(\"bokeh-token\", default=None)\n        session_id = self.get_argument(\"bokeh-session-id\", default=None)\n        if 'Bokeh-Session-Id' in self.request.headers:\n            if session_id is not None:\n                log.debug(\"Server received session ID in request argument and header, expected only one\")\n                raise HTTPError(status_code=403, reason=\"session ID was provided as an argument and header\")\n            session_id = self.request.headers.get('Bokeh-Session-Id')\n\n        if token is not None:\n            if session_id is not None:\n                log.debug(\"Server received both token and session ID, expected only one\")\n                raise HTTPError(status_code=403, reason=\"Both token and session ID were provided\")\n            session_id = get_session_id(token)\n        elif session_id is None:\n            if self.application.generate_session_ids:\n                session_id = generate_session_id(secret_key=self.application.secret_key,\n                                                 signed=self.application.sign_sessions)\n            else:\n                log.debug(\"Server configured not to generate session IDs and none was provided\")\n                raise HTTPError(status_code=403, reason=\"No bokeh-session-id provided\")\n\n        if token is None:\n            if self.application.include_headers is None:\n                excluded_headers = (self.application.exclude_headers or [])\n                allowed_headers = [header for header in self.request.headers\n                                   if header not in excluded_headers]\n            else:\n                allowed_headers = self.application.include_headers\n            headers = {k: v for k, v in self.request.headers.items()\n                       if k in allowed_headers}\n\n            if self.application.include_cookies is None:\n                excluded_cookies = (self.application.exclude_cookies or [])\n                allowed_cookies = [cookie for cookie in self.request.cookies\n                                   if cookie not in excluded_cookies]\n            else:\n                allowed_cookies = self.application.include_cookies\n            cookies = {k: v.value for k, v in self.request.cookies.items()\n                       if k in allowed_cookies}\n\n            payload = {'headers': headers, 'cookies': cookies}\n            payload.update(self.application_context.application.process_request(self.request))\n            token = generate_jwt_token(session_id,\n                                       secret_key=self.application.secret_key,\n                                       signed=self.application.sign_sessions,\n                                       expiration=self.application.session_token_expiration,\n                                       extra_payload=payload)\n\n        if not check_token_signature(token,\n                                     secret_key=self.application.secret_key,\n                                     signed=self.application.sign_sessions):\n            log.error(\"Session id had invalid signature: %r\", session_id)\n            raise HTTPError(status_code=403, reason=\"Invalid token or session ID\")\n\n        session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n\n        return session\n\n    # NOTE: The methods below exist on both AuthMixin and RequestHandler. This\n    # makes it explicit which of the versions is intended to be called.\n    get_login_url = AuthMixin.get_login_url\n    get_current_user = AuthMixin.get_current_user\n    prepare = AuthMixin.prepare\n\n#-----------------------------------------------------------------------------\n# Private API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Code\n#-----------------------------------------------------------------------------\n"
    },
    {
      "filename": "tests/unit/bokeh/server/test_auth_provider.py",
      "content": "#-----------------------------------------------------------------------------\n# Copyright (c) 2012 - 2020, Anaconda, Inc., and Bokeh Contributors.\n# All rights reserved.\n#\n# The full license is in the file LICENSE.txt, distributed with this software.\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Boilerplate\n#-----------------------------------------------------------------------------\nimport pytest ; pytest\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\n# Standard library imports\nfrom types import ModuleType\n\n# External imports\nfrom tornado.web import RequestHandler\n\n# Bokeh imports\nfrom bokeh._testing.util.api import verify_all\nfrom bokeh._testing.util.filesystem import with_file_contents, with_file_contents_async\n\n# Module under test\nimport bokeh.server.auth_provider as bsa # isort:skip\n\n#-----------------------------------------------------------------------------\n# Setup\n#-----------------------------------------------------------------------------\n\nALL = (\n    'AuthModule',\n    'AuthProvider',\n    'NullAuth'\n)\n\n@pytest.fixture\ndef null_auth():\n    return bsa.NullAuth()\n\n#-----------------------------------------------------------------------------\n# General API\n#-----------------------------------------------------------------------------\n\nTest___all__ = verify_all(bsa, ALL)\n\nclass TestNullAuth(object):\n    def test_endpoints(self, null_auth) -> None:\n        assert null_auth.endpoints == []\n\n    def test_get_user(self, null_auth) -> None:\n        assert null_auth.get_user == None\n\n    async def test_get_user_async(self, null_auth) -> None:\n        assert null_auth.get_user_async == None\n\n    def test_login_url(self, null_auth) -> None:\n        assert null_auth.login_url == None\n\n    def test_get_login_url(self, null_auth) -> None:\n        assert null_auth.get_login_url == None\n\n    def test_login_handler(self, null_auth) -> None:\n        assert null_auth.login_handler == None\n\n    def test_logout_url(self, null_auth) -> None:\n        assert null_auth.logout_url == None\n\n    def test_logout_handler(self, null_auth) -> None:\n        assert null_auth.logout_handler == None\n\nclass TestAuthModule_properties(object):\n    def test_no_endpoints(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.endpoints == []\n\n        with_file_contents(\"\"\"\ndef get_user(): pass\ndef get_login_url(): pass\n        \"\"\", func, suffix='.py')\n\n        with_file_contents(\"\"\"\ndef get_user(): pass\nlogin_url = \"/foo\"\n        \"\"\", func, suffix='.py')\n\n    def test_login_url_endpoint(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.endpoints[0][0] == '/foo'\n            assert issubclass(am.endpoints[0][1], RequestHandler)\n        with_file_contents(\"\"\"\nfrom tornado.web import RequestHandler\ndef get_user(): pass\nlogin_url = \"/foo\"\nclass LoginHandler(RequestHandler): pass\n        \"\"\", func, suffix='.py')\n\n    def test_logout_url_endpoint(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.endpoints[0][0] == '/bar'\n            assert issubclass(am.endpoints[0][1], RequestHandler)\n        with_file_contents(\"\"\"\nfrom tornado.web import RequestHandler\ndef get_user(): pass\nlogin_url = \"/foo\"\nlogout_url = \"/bar\"\nclass LogoutHandler(RequestHandler): pass\n        \"\"\", func, suffix='.py')\n\n    def test_login_logout_url_endpoint(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            endpoints = sorted(am.endpoints)\n            assert endpoints[0][0] == '/bar'\n            assert issubclass(endpoints[0][1], RequestHandler)\n            assert endpoints[1][0] == '/foo'\n            assert issubclass(endpoints[1][1], RequestHandler)\n        with_file_contents(\"\"\"\ndef get_user(): pass\nlogin_url = \"/foo\"\nfrom tornado.web import RequestHandler\nclass LoginHandler(RequestHandler): pass\nlogout_url = \"/bar\"\nfrom tornado.web import RequestHandler\nclass LogoutHandler(RequestHandler): pass\n        \"\"\", func, suffix='.py')\n\n    def test_get_user(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.get_user is not None\n            assert am.get_user('handler') == 10\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\n        \"\"\", func, suffix='.py')\n\n    async def test_get_user_async(self) -> None:\n        async def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.get_user_async is not None\n            assert await am.get_user_async('handler') == 10\n\n        await with_file_contents_async(\"\"\"\nasync def get_user_async(handler): return 10\nlogin_url = \"/foo\"\n        \"\"\", func, suffix='.py')\n\n\n    def test_login_url(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.login_url == \"/foo\"\n            assert am.get_login_url is None\n            assert am.login_handler is None\n            assert am.logout_url is None\n            assert am.logout_handler is None\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\n        \"\"\", func, suffix='.py')\n\n    def test_get_login_url(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.login_url is None\n            assert am.get_login_url('handler') == 20\n            assert am.login_handler is None\n            assert am.logout_url is None\n            assert am.logout_handler is None\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\ndef get_login_url(handler): return 20\n        \"\"\", func, suffix='.py')\n\n    def test_login_handler(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.login_url == \"/foo\"\n            assert am.get_login_url is None\n            assert issubclass(am.login_handler, RequestHandler)\n            assert am.logout_url is None\n            assert am.logout_handler is None\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\nfrom tornado.web import RequestHandler\nclass LoginHandler(RequestHandler): pass\n        \"\"\", func, suffix='.py')\n\n    def test_logout_url(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.login_url == \"/foo\"\n            assert am.get_login_url is None\n            assert am.login_handler is None\n            assert am.logout_url == \"/bar\"\n            assert am.logout_handler is None\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\nlogout_url = \"/bar\"\n        \"\"\", func, suffix='.py')\n\n    def test_logout_handler(self) -> None:\n        def func(filename):\n            am = bsa.AuthModule(filename)\n            assert am.login_url == \"/foo\"\n            assert am.get_login_url is None\n            assert am.login_handler is None\n            assert am.logout_url == \"/bar\"\n            assert issubclass(am.logout_handler, RequestHandler)\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\nlogout_url = \"/bar\"\nfrom tornado.web import RequestHandler\nclass LogoutHandler(RequestHandler): pass\n    \"\"\", func, suffix='.py')\n\n\nclass TestAuthModule_validation(object):\n    def test_no_file(self) -> None:\n        with pytest.raises(ValueError) as e:\n            bsa.AuthModule(\"junkjunkjunk\")\n            assert str(e).startswith(\"no file exists at module_path:\")\n\n    def test_both_user(self) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"Only one of get_user or get_user_async should be supplied\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nasync def get_user_async(handler): return 20\n    \"\"\", func, suffix='.py')\n\n    @pytest.mark.parametrize('user_func', ['get_user', 'get_user_async'])\n    def test_no_login(self, user_func) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"When user authentication is enabled, one of login_url or get_login_url must be supplied\"\n\n        with_file_contents(\"\"\"\ndef %s(handler): return 10\n    \"\"\" % user_func, func, suffix='.py')\n\n    def test_both_login(self) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"At most one of login_url or get_login_url should be supplied\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\ndef get_login_url(handler): return 20\nlogin_url = \"/foo\"\n    \"\"\", func, suffix='.py')\n\n    def test_handler_with_get_login_url(self) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"LoginHandler cannot be used with a get_login_url() function\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\ndef get_login_url(handler): return 20\nfrom tornado.web import RequestHandler\nclass LoginHandler(RequestHandler): pass\n    \"\"\", func, suffix='.py')\n\n    def test_login_handler_wrong_type(self) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"LoginHandler must be a Tornado RequestHandler\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\nclass LoginHandler(object): pass\n    \"\"\", func, suffix='.py')\n\n    @pytest.mark.parametrize('login_url', ['http://foo.com', 'https://foo.com', '//foo.com'])\n    def test_login_handler_wrong_url(self, login_url) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"LoginHandler can only be used with a relative login_url\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = %r\n    \"\"\" % login_url, func, suffix='.py')\n\n    def test_logout_handler_wrong_type(self) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"LoginHandler must be a Tornado RequestHandler\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogin_url = \"/foo\"\nclass LogoutHandler(object): pass\n    \"\"\", func, suffix='.py')\n\n    @pytest.mark.parametrize('logout_url', ['http://foo.com', 'https://foo.com', '//foo.com'])\n    def test_logout_handler_wrong_url(self, logout_url) -> None:\n        def func(filename):\n            with pytest.raises(ValueError) as e:\n                bsa.AuthModule(filename)\n                assert str(e) == \"LoginHandler can only be used with a relative login_url\"\n\n        with_file_contents(\"\"\"\ndef get_user(handler): return 10\nlogout_url = %r\n    \"\"\" % logout_url, func, suffix='.py')\n\n_source = \"\"\"\ndef get_login_url():\n    pass\n\nlogout_url = \"foo\"\n\nclass LoginHandler(object):\n    pass\n\"\"\"\n\ndef test_load_auth_module() -> None:\n    def func(filename):\n        m =  bsa.load_auth_module(filename)\n        assert isinstance(m, ModuleType)\n        assert [x for x in sorted(dir(m)) if not x.startswith(\"__\")] == ['LoginHandler', 'get_login_url', 'logout_url']\n    with_file_contents(_source, func, suffix='.py')\n\ndef test_probably_relative_url() -> None:\n    assert bsa.probably_relative_url(\"httpabc\")\n    assert bsa.probably_relative_url(\"httpsabc\")\n    assert bsa.probably_relative_url(\"/abc\")\n    assert not bsa.probably_relative_url(\"http://abc\")\n    assert not bsa.probably_relative_url(\"https://abc\")\n    assert not bsa.probably_relative_url(\"//abc\")\n\n#-----------------------------------------------------------------------------\n# Dev API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Private API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Code\n#-----------------------------------------------------------------------------\n"
    }
  ]
}