{
  "repo_name": "bokeh_bokeh",
  "issue_id": "1671",
  "issue_description": "# allow users to specify explicit tick labels\n\n`FixedTicker` allows users to specify fixed tick locations, but also need to allow users to specify explicit tick labels\n",
  "issue_comments": [
    {
      "id": 206486134,
      "user": "bryevdv",
      "body": "One idea would be to add mapping (`labels`? `custom`?)  to any `TickFormatter` that maps numeric tick values to specific custom labels for that tick location. Before doing its normal formatting and rendering for a tick value, the `TickFormatter` would first try to look that value up in the mapping. If it exists, that label is used as-is, instead of the normal formatting. \n\nSo use might look something like:\n\n```\nplot.xaxis.formatter.custom[50] = \"median\"\n```\n\nRandom observations:\n- this means the customization is attached to a formatter, so if the formatter is changed the customization is lost (potentially confusing in those situations)\n- suggests might want ability to add custom fixed ticks to any ticker (or to be able to combine a fixed ticker with a regular ticker)\n\n@bokeh/dev  thoughts?\n"
    },
    {
      "id": 220956563,
      "user": "pzwang",
      "body": "I can see multiple angles on this.  There is an argument to be made that it should be on the Ticker, as well as the Formatter.  However, the most important thing IMO is that the split between ticker vs. formatter is an architectural one in our object model, and, under normal circumstances, it's not a distinction that we should burden the user with understanding.\n\nWe need to consider the use cases when an end user is most likely to want to specify these things:\n1. They have a few, specific locations that they want labelled.\n2. They have a custom format that _extends_ an existing built-in formatter\n3. They want to replace a built-in ticker+formatter altogether and _only_ show labels at certain locations, regardless of zoom level\n\nWhat would the ideal spelling look like for each of these?  Are there other common use cases I'm missing here?\n"
    },
    {
      "id": 254219677,
      "user": "Rubyj",
      "body": "@bryevdv Is there a way to do this yet?\n"
    },
    {
      "id": 254231932,
      "user": "bryevdv",
      "body": "Currently you could do this with a custom `TickFormatter`. Given that there is _some_ path to doing this, even if it is not ideal, adding support into the core library will probably not rise high in the ~750 open issue list. A new interested contributor submitting a PR is probably the quickest route. \n"
    },
    {
      "id": 254241022,
      "user": "Rubyj",
      "body": "@bryevdv Thanks. That is currently the way I'm doing it in my code as well.\n"
    },
    {
      "id": 254260063,
      "user": "canavandl",
      "body": "Here's an example of doing exactly that (using a FixedTicker and FuncTickFormatter together to set explicit tick labels at specific locations). I think it's the best method for doing this:\n\n``` python\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import ColorBar, LinearColorMapper, Plot, Range1d, LinearAxis, FixedTicker, FuncTickFormatter\n\ncolor_mapper = LinearColorMapper(palette=\"Spectral6\", low=0, high=60)\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\nformatter = FuncTickFormatter(code=\"\"\"\n    data = {5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'}\n    return data[tick]\n\"\"\")\n\ncbar = ColorBar(color_mapper=color_mapper, ticker=ticker, formatter=formatter,\n                major_tick_out=0, major_tick_in=0, major_label_text_align='left',\n                major_label_text_font_size='10pt', label_standoff=2)\n\np = Plot(x_range=Range1d(0,1), y_range=Range1d(0,1), width=500, height=500, toolbar_location=None)\np.add_layout(LinearAxis(), 'left')\np.add_layout(LinearAxis(), 'below')\n\np.add_layout(cbar)\n\nshow(p)\n```\n"
    },
    {
      "id": 254292697,
      "user": "Rubyj",
      "body": "@canavandl Thank you for the idea. Currently I am using\n\n``` python\nclass FixedTickFormatter(TickFormatter):\n    \"\"\"\n    Class used to allow custom axis tick labels on a bokeh chart\n    Extends bokeh.model.formatters.TickFormatte\n    \"\"\"\n\n    JS_CODE =  \"\"\"\n        _ = require \"underscore\"\n        Model = require \"model\"\n        p = require \"core/properties\"\n        class FixedTickFormatter extends Model\n          type: 'FixedTickFormatter'\n          doFormat: (ticks) ->\n            labels = @get(\"labels\")\n            return (labels[tick] ? \"\" for tick in ticks)\n          @define {\n            labels: [ p.Any ]\n          }\n        module.exports =\n          Model: FixedTickFormatter\n    \"\"\"\n\n    labels = Dict(Int, String, help=\"\"\"\n    A mapping of integer ticks values to their labels.\n    \"\"\")\n\n    __implementation__ = JS_CODE\n```\n"
    },
    {
      "id": 254338617,
      "user": "birdsarah",
      "body": "@Rubyj I was curious about this, so I put together a complete example.\n\nPlease note that you're custom FixedTickFormatter needed to be changed quite a lot for it to work on master (and hence the next release)\n\n``` python\nfrom bokeh.plotting import show\nfrom bokeh.properties import Dict, Int, String\nfrom bokeh.models import (\n    ColorBar,\n    LinearColorMapper,\n    Plot,\n    Range1d,\n    LinearAxis,\n    FixedTicker,\n    TickFormatter,\n)\nfrom bokeh.util.compiler import CoffeeScript\n\nclass FixedTickFormatter(TickFormatter):\n    \"\"\"\n    Class used to allow custom axis tick labels on a bokeh chart\n    Extends bokeh.model.formatters.TickFormatter\n    \"\"\"\n\n    COFFEESCRIPT =  \"\"\"\n        import {Model} from \"model\"\n        import * as p from \"core/properties\"\n        export class FixedTickFormatter extends Model\n          type: 'FixedTickFormatter'\n          doFormat: (ticks) ->\n            labels = @get(\"labels\")\n            return (labels[tick] ? \"\" for tick in ticks)\n          @define {\n            labels: [ p.Any ]\n          }\n    \"\"\"\n\n    labels = Dict(Int, String, help=\"\"\"\n    A mapping of integer ticks values to their labels.\n    \"\"\")\n\n    __implementation__ = CoffeeScript(COFFEESCRIPT)\n\n\ncolor_mapper = LinearColorMapper(palette=\"Spectral6\", low=0, high=60)\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\nformatter = FixedTickFormatter(labels={5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'})\n\ncbar = ColorBar(color_mapper=color_mapper, ticker=ticker, formatter=formatter,\n                major_tick_out=0, major_tick_in=0, major_label_text_align='left',\n                major_label_text_font_size='10pt', label_standoff=2)\n\np = Plot(x_range=Range1d(0,1), y_range=Range1d(0,1), width=500, height=500, toolbar_location=None)\np.add_layout(LinearAxis(), 'left')\np.add_layout(LinearAxis(), 'below')\np.add_layout(cbar)\nshow(p)\n```\n\n@bryevdv - we're going to need some major migration notes about the new export stuff, then new import stuff, and the compilation stuff for folks\n"
    },
    {
      "id": 254389449,
      "user": "Rubyj",
      "body": "@birdsarah awesome! Thank you for this :)\n"
    },
    {
      "id": 254911319,
      "user": "mattpap",
      "body": "```\ndoFormat: (ticks) ->\n    labels = @get(\"labels\")\n    return (labels[tick] ? \"\" for tick in ticks)\n```\n\nActually `labels = @labels`, otherwise deprecation warning will appear.\n"
    },
    {
      "id": 281687486,
      "user": "ghost",
      "body": "Hi, I arrived here via Stack Overflow.  \r\nThe example above breaks somewhere between v 0.12.2 and 0.12.4.  I get the following message:\r\n\r\n> Model `FixedTickFormatter' does not exist. This could be due to a widget or a custom model not being registered before first usage.\r\n\r\nThe clue seems to be in the comment above :)\r\n\r\n>  we're going to need some major migration notes about the new export stuff, then new import stuff, and the compilation stuff for folks\r\n\r\nHas anyone got any suggestion what the best way to go about this is now?  I guess there's some different way to register the JS code?"
    },
    {
      "id": 281696035,
      "user": "Rubyj",
      "body": "@hodgson-neil \r\n\r\n I am using the below code which works fine in my application running the latest version of bokeh\r\n\r\n```class FixedTickFormatter(TickFormatter):\r\n    \"\"\"\r\n    Class used to allow custom axis tick labels on a bokeh chart\r\n    Extends bokeh.model.formatters.TickFormatter\r\n    \"\"\"\r\n\r\n    COFFEESCRIPT =  \"\"\"\r\n        import {Model} from \"model\"\r\n        import * as p from \"core/properties\"\r\n        export class FixedTickFormatter extends Model\r\n          type: 'FixedTickFormatter'\r\n          doFormat: (ticks) ->\r\n            labels = @labels\r\n            return (labels[tick] ? \"\" for tick in ticks)\r\n          @define {\r\n            labels: [ p.Any ]\r\n          }\r\n    \"\"\"\r\n\r\n    labels = Dict(Int, String, help=\"\"\"\r\n    A mapping of integer ticks values to their labels.\r\n    \"\"\")\r\n\r\n    __implementation__ = CoffeeScript(COFFEESCRIPT)```"
    },
    {
      "id": 281705821,
      "user": "ghost",
      "body": "@Rubyj Thanks, my mistake.  It is indeed working fine on my use case!  Thanks."
    },
    {
      "id": 288573555,
      "user": "tommycarstensen",
      "body": "@canavandl How can you do the same for the x-axis in a scatter plot? Thanks."
    },
    {
      "id": 288574754,
      "user": "tommycarstensen",
      "body": "@pzwang I guess my use case is either the first or the third.\r\n\r\nI'm generating a Manhattan plot, which plots millions of points with the probability of association between phenotypes and genotypes at millions of base pair locations in the genome:\r\nhttps://en.wikipedia.org/wiki/Manhattan_plot\r\n\r\nPreferably I would also like for the position on a given chromosome to be shown, when I zoom in, but that would probably require a secondary x-axis.\r\n\r\nI'm super excited about Bokeh! Right now I have to semi naively down-sample my data to less than 100k data points, because the hover tool doesn't work with datashader. Tomorrow I'll look into doing what I think you refer to as call backs with Bokeh serve, so I can do Manhattan plots for various phenotypic traits. Awesome! Excited!"
    },
    {
      "id": 288727858,
      "user": "canavandl",
      "body": "@tommycarstensen , I haven't tested it, but the below should work:\r\n\r\n```python\r\nfrom bokeh.plotting import show\r\nfrom bokeh.properties import Dict, Int, String\r\nfrom bokeh.models import (\r\n    Plot,\r\n    Range1d,\r\n    LinearAxis,\r\n    FixedTicker,\r\n    TickFormatter,\r\n)\r\nfrom bokeh.util.compiler import CoffeeScript\r\n\r\nclass FixedTickFormatter(TickFormatter):\r\n    \"\"\"\r\n    Class used to allow custom axis tick labels on a bokeh chart\r\n    Extends bokeh.model.formatters.TickFormatter\r\n    \"\"\"\r\n\r\n    COFFEESCRIPT =  \"\"\"\r\n        import {Model} from \"model\"\r\n        import * as p from \"core/properties\"\r\n        export class FixedTickFormatter extends Model\r\n          type: 'FixedTickFormatter'\r\n          doFormat: (ticks) ->\r\n            labels = @get(\"labels\")\r\n            return (labels[tick] ? \"\" for tick in ticks)\r\n          @define {\r\n            labels: [ p.Any ]\r\n          }\r\n    \"\"\"\r\n\r\n    labels = Dict(Int, String, help=\"\"\"\r\n    A mapping of integer ticks values to their labels.\r\n    \"\"\")\r\n\r\n    __implementation__ = CoffeeScript(COFFEESCRIPT)\r\n\r\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\r\nformatter = FixedTickFormatter(labels={5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'})\r\nx_axis = LinearAxis(ticker=ticker, formatter=formatter)\r\n\r\np = Plot(x_range=Range1d(0,60))\r\np.add_layout(x_axis, 'below')\r\n\r\nshow(p)\r\n```"
    },
    {
      "id": 288869569,
      "user": "jbednar",
      "body": "> Right now I have to semi naively down-sample my data to less than 100k data points, because the hover tool doesn't work with datashader.\r\n\r\nWith the latest GitHub master version of HoloViews, you can now easily overlay a hover layer on a datashader plot, as shown here: https://github.com/ioam/holoviews/pull/1223\r\n\r\nNot sure if that helps your use case, but if it doesn't, please file an issue about that on the datashader site."
    },
    {
      "id": 296260352,
      "user": "bryevdv",
      "body": "Ok I'd like to do something for this for `0.12.6`. There's alot that's somewhat tangential above, mostly I'd like to return to @pzwang  observation that users should not be unduly burdened with considering tickers and formatters unless it's necessary. So I propose the following:\r\n\r\n```\r\nplot.xaxis.major_label_overrides = { 5: \"0-10\", 15: \"10-20\", ... } \r\n```\r\nThen internally axis models would pass this on to their tick formatters on init (or when a formatter is replaced). All the built in formatters would refer to this list of overrides (and extension formatters could as well). Users would only need to worry about supplying this mapping on an axis, which is a bit more common/approachable than tickers and formatter. \r\n\r\nThis would let specific values be overridden, however they occur. If *only* these ticks are desired, use of `FixedTickFormatter` would still be needed. However we could probably also make it so that \r\n```\r\nplot.xaxis.ticker = [5, 15, ... ]\r\n```\r\nworks as a shorthand for setting up a fixed ticker.\r\n\r\nDoes this sound acceptable to everyone? If so I would plan on working on this after the refactor of categorical values. "
    },
    {
      "id": 296320227,
      "user": "pzwang",
      "body": "+1,  I think this would be super!"
    },
    {
      "id": 298506684,
      "user": "bryevdv",
      "body": "@hodgson-neil @tommycarstensen @Rubyj PR #6225 should solve this issue in the manner described above, if you have the opportunity to build and test it, it would be helpful and appreciated. "
    },
    {
      "id": 2442839166,
      "user": "github-actions[bot]",
      "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
    }
  ],
  "text_context": "# allow users to specify explicit tick labels\n\n`FixedTicker` allows users to specify fixed tick locations, but also need to allow users to specify explicit tick labels\n\n\nOne idea would be to add mapping (`labels`? `custom`?)  to any `TickFormatter` that maps numeric tick values to specific custom labels for that tick location. Before doing its normal formatting and rendering for a tick value, the `TickFormatter` would first try to look that value up in the mapping. If it exists, that label is used as-is, instead of the normal formatting. \n\nSo use might look something like:\n\n```\nplot.xaxis.formatter.custom[50] = \"median\"\n```\n\nRandom observations:\n- this means the customization is attached to a formatter, so if the formatter is changed the customization is lost (potentially confusing in those situations)\n- suggests might want ability to add custom fixed ticks to any ticker (or to be able to combine a fixed ticker with a regular ticker)\n\n@bokeh/dev  thoughts?\n\n\nI can see multiple angles on this.  There is an argument to be made that it should be on the Ticker, as well as the Formatter.  However, the most important thing IMO is that the split between ticker vs. formatter is an architectural one in our object model, and, under normal circumstances, it's not a distinction that we should burden the user with understanding.\n\nWe need to consider the use cases when an end user is most likely to want to specify these things:\n1. They have a few, specific locations that they want labelled.\n2. They have a custom format that _extends_ an existing built-in formatter\n3. They want to replace a built-in ticker+formatter altogether and _only_ show labels at certain locations, regardless of zoom level\n\nWhat would the ideal spelling look like for each of these?  Are there other common use cases I'm missing here?\n\n\n@bryevdv Is there a way to do this yet?\n\n\nCurrently you could do this with a custom `TickFormatter`. Given that there is _some_ path to doing this, even if it is not ideal, adding support into the core library will probably not rise high in the ~750 open issue list. A new interested contributor submitting a PR is probably the quickest route. \n\n\n@bryevdv Thanks. That is currently the way I'm doing it in my code as well.\n\n\nHere's an example of doing exactly that (using a FixedTicker and FuncTickFormatter together to set explicit tick labels at specific locations). I think it's the best method for doing this:\n\n``` python\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import ColorBar, LinearColorMapper, Plot, Range1d, LinearAxis, FixedTicker, FuncTickFormatter\n\ncolor_mapper = LinearColorMapper(palette=\"Spectral6\", low=0, high=60)\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\nformatter = FuncTickFormatter(code=\"\"\"\n    data = {5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'}\n    return data[tick]\n\"\"\")\n\ncbar = ColorBar(color_mapper=color_mapper, ticker=ticker, formatter=formatter,\n                major_tick_out=0, major_tick_in=0, major_label_text_align='left',\n                major_label_text_font_size='10pt', label_standoff=2)\n\np = Plot(x_range=Range1d(0,1), y_range=Range1d(0,1), width=500, height=500, toolbar_location=None)\np.add_layout(LinearAxis(), 'left')\np.add_layout(LinearAxis(), 'below')\n\np.add_layout(cbar)\n\nshow(p)\n```\n\n\n@canavandl Thank you for the idea. Currently I am using\n\n``` python\nclass FixedTickFormatter(TickFormatter):\n    \"\"\"\n    Class used to allow custom axis tick labels on a bokeh chart\n    Extends bokeh.model.formatters.TickFormatte\n    \"\"\"\n\n    JS_CODE =  \"\"\"\n        _ = require \"underscore\"\n        Model = require \"model\"\n        p = require \"core/properties\"\n        class FixedTickFormatter extends Model\n          type: 'FixedTickFormatter'\n          doFormat: (ticks) ->\n            labels = @get(\"labels\")\n            return (labels[tick] ? \"\" for tick in ticks)\n          @define {\n            labels: [ p.Any ]\n          }\n        module.exports =\n          Model: FixedTickFormatter\n    \"\"\"\n\n    labels = Dict(Int, String, help=\"\"\"\n    A mapping of integer ticks values to their labels.\n    \"\"\")\n\n    __implementation__ = JS_CODE\n```\n\n\n@Rubyj I was curious about this, so I put together a complete example.\n\nPlease note that you're custom FixedTickFormatter needed to be changed quite a lot for it to work on master (and hence the next release)\n\n``` python\nfrom bokeh.plotting import show\nfrom bokeh.properties import Dict, Int, String\nfrom bokeh.models import (\n    ColorBar,\n    LinearColorMapper,\n    Plot,\n    Range1d,\n    LinearAxis,\n    FixedTicker,\n    TickFormatter,\n)\nfrom bokeh.util.compiler import CoffeeScript\n\nclass FixedTickFormatter(TickFormatter):\n    \"\"\"\n    Class used to allow custom axis tick labels on a bokeh chart\n    Extends bokeh.model.formatters.TickFormatter\n    \"\"\"\n\n    COFFEESCRIPT =  \"\"\"\n        import {Model} from \"model\"\n        import * as p from \"core/properties\"\n        export class FixedTickFormatter extends Model\n          type: 'FixedTickFormatter'\n          doFormat: (ticks) ->\n            labels = @get(\"labels\")\n            return (labels[tick] ? \"\" for tick in ticks)\n          @define {\n            labels: [ p.Any ]\n          }\n    \"\"\"\n\n    labels = Dict(Int, String, help=\"\"\"\n    A mapping of integer ticks values to their labels.\n    \"\"\")\n\n    __implementation__ = CoffeeScript(COFFEESCRIPT)\n\n\ncolor_mapper = LinearColorMapper(palette=\"Spectral6\", low=0, high=60)\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\nformatter = FixedTickFormatter(labels={5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'})\n\ncbar = ColorBar(color_mapper=color_mapper, ticker=ticker, formatter=formatter,\n                major_tick_out=0, major_tick_in=0, major_label_text_align='left',\n                major_label_text_font_size='10pt', label_standoff=2)\n\np = Plot(x_range=Range1d(0,1), y_range=Range1d(0,1), width=500, height=500, toolbar_location=None)\np.add_layout(LinearAxis(), 'left')\np.add_layout(LinearAxis(), 'below')\np.add_layout(cbar)\nshow(p)\n```\n\n@bryevdv - we're going to need some major migration notes about the new export stuff, then new import stuff, and the compilation stuff for folks\n\n\n@birdsarah awesome! Thank you for this :)\n\n\n```\ndoFormat: (ticks) ->\n    labels = @get(\"labels\")\n    return (labels[tick] ? \"\" for tick in ticks)\n```\n\nActually `labels = @labels`, otherwise deprecation warning will appear.\n\n\nHi, I arrived here via Stack Overflow.  \r\nThe example above breaks somewhere between v 0.12.2 and 0.12.4.  I get the following message:\r\n\r\n> Model `FixedTickFormatter' does not exist. This could be due to a widget or a custom model not being registered before first usage.\r\n\r\nThe clue seems to be in the comment above :)\r\n\r\n>  we're going to need some major migration notes about the new export stuff, then new import stuff, and the compilation stuff for folks\r\n\r\nHas anyone got any suggestion what the best way to go about this is now?  I guess there's some different way to register the JS code?\n\n@hodgson-neil \r\n\r\n I am using the below code which works fine in my application running the latest version of bokeh\r\n\r\n```class FixedTickFormatter(TickFormatter):\r\n    \"\"\"\r\n    Class used to allow custom axis tick labels on a bokeh chart\r\n    Extends bokeh.model.formatters.TickFormatter\r\n    \"\"\"\r\n\r\n    COFFEESCRIPT =  \"\"\"\r\n        import {Model} from \"model\"\r\n        import * as p from \"core/properties\"\r\n        export class FixedTickFormatter extends Model\r\n          type: 'FixedTickFormatter'\r\n          doFormat: (ticks) ->\r\n            labels = @labels\r\n            return (labels[tick] ? \"\" for tick in ticks)\r\n          @define {\r\n            labels: [ p.Any ]\r\n          }\r\n    \"\"\"\r\n\r\n    labels = Dict(Int, String, help=\"\"\"\r\n    A mapping of integer ticks values to their labels.\r\n    \"\"\")\r\n\r\n    __implementation__ = CoffeeScript(COFFEESCRIPT)```\n\n@Rubyj Thanks, my mistake.  It is indeed working fine on my use case!  Thanks.\n\n@canavandl How can you do the same for the x-axis in a scatter plot? Thanks.\n\n@pzwang I guess my use case is either the first or the third.\r\n\r\nI'm generating a Manhattan plot, which plots millions of points with the probability of association between phenotypes and genotypes at millions of base pair locations in the genome:\r\nhttps://en.wikipedia.org/wiki/Manhattan_plot\r\n\r\nPreferably I would also like for the position on a given chromosome to be shown, when I zoom in, but that would probably require a secondary x-axis.\r\n\r\nI'm super excited about Bokeh! Right now I have to semi naively down-sample my data to less than 100k data points, because the hover tool doesn't work with datashader. Tomorrow I'll look into doing what I think you refer to as call backs with Bokeh serve, so I can do Manhattan plots for various phenotypic traits. Awesome! Excited!\n\n@tommycarstensen , I haven't tested it, but the below should work:\r\n\r\n```python\r\nfrom bokeh.plotting import show\r\nfrom bokeh.properties import Dict, Int, String\r\nfrom bokeh.models import (\r\n    Plot,\r\n    Range1d,\r\n    LinearAxis,\r\n    FixedTicker,\r\n    TickFormatter,\r\n)\r\nfrom bokeh.util.compiler import CoffeeScript\r\n\r\nclass FixedTickFormatter(TickFormatter):\r\n    \"\"\"\r\n    Class used to allow custom axis tick labels on a bokeh chart\r\n    Extends bokeh.model.formatters.TickFormatter\r\n    \"\"\"\r\n\r\n    COFFEESCRIPT =  \"\"\"\r\n        import {Model} from \"model\"\r\n        import * as p from \"core/properties\"\r\n        export class FixedTickFormatter extends Model\r\n          type: 'FixedTickFormatter'\r\n          doFormat: (ticks) ->\r\n            labels = @get(\"labels\")\r\n            return (labels[tick] ? \"\" for tick in ticks)\r\n          @define {\r\n            labels: [ p.Any ]\r\n          }\r\n    \"\"\"\r\n\r\n    labels = Dict(Int, String, help=\"\"\"\r\n    A mapping of integer ticks values to their labels.\r\n    \"\"\")\r\n\r\n    __implementation__ = CoffeeScript(COFFEESCRIPT)\r\n\r\nticker = FixedTicker(ticks=[5,15,25,35,45,55])\r\nformatter = FixedTickFormatter(labels={5: '0-10', 15: '10-20', 25: '20-30', 35: '30-40', 45: '40-50', 55: '50+'})\r\nx_axis = LinearAxis(ticker=ticker, formatter=formatter)\r\n\r\np = Plot(x_range=Range1d(0,60))\r\np.add_layout(x_axis, 'below')\r\n\r\nshow(p)\r\n```\n\n> Right now I have to semi naively down-sample my data to less than 100k data points, because the hover tool doesn't work with datashader.\r\n\r\nWith the latest GitHub master version of HoloViews, you can now easily overlay a hover layer on a datashader plot, as shown here: https://github.com/ioam/holoviews/pull/1223\r\n\r\nNot sure if that helps your use case, but if it doesn't, please file an issue about that on the datashader site.\n\nOk I'd like to do something for this for `0.12.6`. There's alot that's somewhat tangential above, mostly I'd like to return to @pzwang  observation that users should not be unduly burdened with considering tickers and formatters unless it's necessary. So I propose the following:\r\n\r\n```\r\nplot.xaxis.major_label_overrides = { 5: \"0-10\", 15: \"10-20\", ... } \r\n```\r\nThen internally axis models would pass this on to their tick formatters on init (or when a formatter is replaced). All the built in formatters would refer to this list of overrides (and extension formatters could as well). Users would only need to worry about supplying this mapping on an axis, which is a bit more common/approachable than tickers and formatter. \r\n\r\nThis would let specific values be overridden, however they occur. If *only* these ticks are desired, use of `FixedTickFormatter` would still be needed. However we could probably also make it so that \r\n```\r\nplot.xaxis.ticker = [5, 15, ... ]\r\n```\r\nworks as a shorthand for setting up a fixed ticker.\r\n\r\nDoes this sound acceptable to everyone? If so I would plan on working on this after the refactor of categorical values. \n\n+1,  I think this would be super!\n\n@hodgson-neil @tommycarstensen @Rubyj PR #6225 should solve this issue in the manner described above, if you have the opportunity to build and test it, it would be helpful and appreciated. \n\nThis issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.",
  "pr_link": "https://github.com/ioam/holoviews/pull/1223",
  "code_context": [
    {
      "filename": "holoviews/element/raster.py",
      "content": "import warnings\nfrom operator import itemgetter\nfrom itertools import product\nimport numpy as np\nimport colorsys\nimport param\n\nfrom ..core import util\nfrom ..core.data import ArrayInterface, NdElementInterface, DictInterface\nfrom ..core import (Dimension, NdMapping, Element2D,\n                    Overlay, Element, Dataset, NdElement)\nfrom ..core.boundingregion import BoundingRegion, BoundingBox\nfrom ..core.sheetcoords import SheetCoordinateSystem, Slice\nfrom ..core.util import pd\nfrom .chart import Curve\nfrom .tabular import Table\nfrom .util import compute_edges, toarray, categorical_aggregate2d\n\ntry:\n    from ..core.data import PandasInterface\nexcept ImportError:\n    PandasInterface = None\n\n\nclass Raster(Element2D):\n    \"\"\"\n    Raster is a basic 2D element type for presenting either numpy or\n    dask arrays as two dimensional raster images.\n\n    Arrays with a shape of (N,M) are valid inputs for Raster wheras\n    subclasses of Raster (e.g. RGB) may also accept 3D arrays\n    containing channel information.\n\n    Raster does not support slicing like the Image or RGB subclasses\n    and the extents are in matrix coordinates if not explicitly\n    specified.\n    \"\"\"\n\n    group = param.String(default='Raster', constant=True)\n\n    kdims = param.List(default=[Dimension('x'), Dimension('y')],\n                       bounds=(2, 2), constant=True, doc=\"\"\"\n        The label of the x- and y-dimension of the Raster in form\n        of a string or dimension object.\"\"\")\n\n    vdims = param.List(default=[Dimension('z')], bounds=(1, 1), doc=\"\"\"\n        The dimension description of the data held in the data array.\"\"\")\n\n    def __init__(self, data, extents=None, **params):\n        if extents is None:\n            (d1, d2) = data.shape[:2]\n            extents = (0, 0, d2, d1)\n        super(Raster, self).__init__(data, extents=extents, **params)\n\n\n    @property\n    def _zdata(self):\n        return self.data\n\n\n    def __getitem__(self, slices):\n        if slices in self.dimensions(): return self.dimension_values(slices)\n        slices = util.process_ellipses(self,slices)\n        if not isinstance(slices, tuple):\n            slices = (slices, slice(None))\n        elif len(slices) > (2 + self.depth):\n            raise KeyError(\"Can only slice %d dimensions\" % 2 + self.depth)\n        elif len(slices) == 3 and slices[-1] not in [self.vdims[0].name, slice(None)]:\n            raise KeyError(\"%r is the only selectable value dimension\" % self.vdims[0].name)\n\n        slc_types = [isinstance(sl, slice) for sl in slices[:2]]\n        data = self.data.__getitem__(slices[:2][::-1])\n        if all(slc_types):\n            return self.clone(data, extents=None)\n        elif not any(slc_types):\n            return toarray(data, index_value=True)\n        else:\n            return self.clone(np.expand_dims(data, axis=slc_types.index(True)),\n                              extents=None)\n\n\n    def _coord2matrix(self, coord):\n        return int(round(coord[1])), int(round(coord[0]))\n\n\n    @classmethod\n    def collapse_data(cls, data_list, function, kdims=None, **kwargs):\n        if isinstance(function, np.ufunc):\n            return function.reduce(data_list)\n        else:\n            return function(np.dstack(data_list), axis=-1, **kwargs)\n\n\n    def sample(self, samples=[], **sample_values):\n        \"\"\"\n        Sample the Raster along one or both of its dimensions,\n        returning a reduced dimensionality type, which is either\n        a ItemTable, Curve or Scatter. If two dimension samples\n        and a new_xaxis is provided the sample will be the value\n        of the sampled unit indexed by the value in the new_xaxis\n        tuple.\n        \"\"\"\n        if isinstance(samples, tuple):\n            X, Y = samples\n            samples = zip(X, Y)\n        params = dict(self.get_param_values(onlychanged=True),\n                      vdims=self.vdims)\n        params.pop('extents', None)\n        params.pop('bounds', None)\n        if len(sample_values) == self.ndims or len(samples):\n            if not len(samples):\n                samples = zip(*[c if isinstance(c, list) else [c] for _, c in\n                               sorted([(self.get_dimension_index(k), v) for k, v in\n                                       sample_values.items()])])\n            table_data = [c+(self._zdata[self._coord2matrix(c)],)\n                          for c in samples]\n            params['kdims'] = self.kdims\n            return Table(table_data, **params)\n        else:\n            dimension, sample_coord = list(sample_values.items())[0]\n            if isinstance(sample_coord, slice):\n                raise ValueError(\n                    'Raster sampling requires coordinates not slices,'\n                    'use regular slicing syntax.')\n            # Indices inverted for indexing\n            sample_ind = self.get_dimension_index(dimension)\n            if sample_ind is None:\n                raise Exception(\"Dimension %s not found during sampling\" % dimension)\n            other_dimension = [d for i, d in enumerate(self.kdims) if\n                               i != sample_ind]\n\n            # Generate sample slice\n            sample = [slice(None) for i in range(self.ndims)]\n            coord_fn = (lambda v: (v, 0)) if not sample_ind else (lambda v: (0, v))\n            sample[sample_ind] = self._coord2matrix(coord_fn(sample_coord))[abs(sample_ind-1)]\n\n            # Sample data\n            x_vals = self.dimension_values(other_dimension[0].name, False)\n            ydata = self._zdata[sample[::-1]]\n            if hasattr(self, 'bounds') and sample_ind == 0: ydata = ydata[::-1]\n            data = list(zip(x_vals, ydata))\n            params['kdims'] = other_dimension\n            return Curve(data, **params)\n\n\n    def reduce(self, dimensions=None, function=None, **reduce_map):\n        \"\"\"\n        Reduces the Raster using functions provided via the\n        kwargs, where the keyword is the dimension to be reduced.\n        Optionally a label_prefix can be provided to prepend to\n        the result Element label.\n        \"\"\"\n        function, dims = self._reduce_map(dimensions, function, reduce_map)\n        if len(dims) == self.ndims:\n            if isinstance(function, np.ufunc):\n                return function.reduce(self.data, axis=None)\n            else:\n                return function(self.data)\n        else:\n            dimension = dims[0]\n            other_dimension = [d for d in self.kdims if d.name != dimension]\n            oidx = self.get_dimension_index(other_dimension[0])\n            x_vals = self.dimension_values(other_dimension[0].name, False)\n            reduced = function(self._zdata, axis=oidx)\n            if oidx and hasattr(self, 'bounds'):\n                reduced = reduced[::-1]\n            data = zip(x_vals, reduced)\n            params = dict(dict(self.get_param_values(onlychanged=True)),\n                          kdims=other_dimension, vdims=self.vdims)\n            params.pop('bounds', None)\n            params.pop('extents', None)\n            return Table(data, **params)\n\n\n    def dimension_values(self, dim, expanded=True, flat=True):\n        \"\"\"\n        The set of samples available along a particular dimension.\n        \"\"\"\n        dim_idx = self.get_dimension_index(dim)\n        if not expanded and dim_idx == 0:\n            return np.array(range(self.data.shape[1]))\n        elif not expanded and dim_idx == 1:\n            return np.array(range(self.data.shape[0]))\n        elif dim_idx in [0, 1]:\n            values = np.mgrid[0:self.data.shape[1], 0:self.data.shape[0]][dim_idx]\n            return values.flatten() if flat else values\n        elif dim_idx == 2:\n            arr = toarray(self.data.T)\n            return arr.flatten() if flat else arr\n        else:\n            return super(Raster, self).dimension_values(dim)\n\n\n    @property\n    def depth(self):\n        return 1 if len(self.data.shape) == 2 else self.data.shape[2]\n\n\n    @property\n    def mode(self):\n        \"\"\"\n        Mode specifying the color space for visualizing the array data\n        and is a function of the depth. For a depth of one, a colormap\n        is used as determined by the style. If the depth is 3 or 4,\n        the mode is 'rgb' or 'rgba' respectively.\n        \"\"\"\n        if   self.depth == 1:  return 'cmap'\n        elif self.depth == 3:  return 'rgb'\n        elif self.depth == 4:  return 'rgba'\n        else:\n            raise Exception(\"Mode cannot be determined from the depth\")\n\n\n\nclass QuadMesh(Raster):\n    \"\"\"\n    QuadMesh is a Raster type to hold x- and y- bin values\n    with associated values. The x- and y-values of the QuadMesh\n    may be supplied either as the edges of each bin allowing\n    uneven sampling or as the bin centers, which will be converted\n    to evenly sampled edges.\n\n    As a secondary but less supported mode QuadMesh can contain\n    a mesh of quadrilateral coordinates that is not laid out in\n    a grid. The data should then be supplied as three separate\n    2D arrays for the x-/y-coordinates and grid values.\n    \"\"\"\n\n    group = param.String(default=\"QuadMesh\", constant=True)\n\n    kdims = param.List(default=[Dimension('x'), Dimension('y')])\n\n    vdims = param.List(default=[Dimension('z')], bounds=(1,1))\n\n    def __init__(self, data, **params):\n        data = self._process_data(data)\n        Element2D.__init__(self, data, **params)\n        self.data = self._validate_data(self.data)\n        self._grid = self.data[0].ndim == 1\n\n\n    @property\n    def depth(self): return 1\n\n    def _process_data(self, data):\n        if isinstance(data, GridImage):\n            x = data.dimension_values(0, expanded=False)\n            y = data.dimension_values(1, expanded=False)\n            zarray = data.dimension_values(2, flat=False)\n        else:\n            data = tuple(np.array(el) for el in data)\n            x, y, zarray = data\n        ys, xs = zarray.shape\n        if x.ndim == 1 and len(x) == xs:\n            x = compute_edges(x)\n        if y.ndim == 1 and len(y) == ys:\n            y = compute_edges(y)\n        return (x, y, zarray)\n\n\n    @property\n    def _zdata(self):\n        return self.data[2]\n\n\n    def _validate_data(self, data):\n        x, y, z = data\n        if not z.ndim == 2:\n            raise ValueError(\"Z-values must be 2D array\")\n\n        ys, xs = z.shape\n        shape_errors = []\n        if x.ndim == 1 and xs+1 != len(x):\n            shape_errors.append('x')\n        if x.ndim == 1 and ys+1 != len(y):\n            shape_errors.append('y')\n        if shape_errors:\n            raise ValueError(\"%s-edges must match shape of z-array.\" %\n                             '/'.join(shape_errors))\n        return data\n\n\n    def __getitem__(self, slices):\n        if slices in self.dimensions(): return self.dimension_values(slices)\n        slices = util.process_ellipses(self,slices)\n        if not self._grid:\n            raise KeyError(\"Indexing of non-grid based QuadMesh\"\n                             \"currently not supported\")\n        if len(slices) > (2 + self.depth):\n            raise KeyError(\"Can only slice %d dimensions\" % (2 + self.depth))\n        elif len(slices) == 3 and slices[-1] not in [self.vdims[0].name, slice(None)]:\n            raise KeyError(\"%r is the only selectable value dimension\" % self.vdims[0].name)\n        slices = slices[:2]\n        if not isinstance(slices, tuple): slices = (slices, slice(None))\n        slc_types = [isinstance(sl, slice) for sl in slices]\n        if not any(slc_types):\n            indices = []\n            for idx, data in zip(slices, self.data[:self.ndims]):\n                indices.append(np.digitize([idx], data)-1)\n            return self.data[2][tuple(indices[::-1])]\n        else:\n            sliced_data, indices = [], []\n            for slc, data in zip(slices, self.data[:self.ndims]):\n                if isinstance(slc, slice):\n                    low, high = slc.start, slc.stop\n                    lidx = ([None] if low is None else\n                            max((np.digitize([low], data)-1, 0)))[0]\n                    hidx = ([None] if high is None else\n                            np.digitize([high], data))[0]\n                    sliced_data.append(data[lidx:hidx])\n                    indices.append(slice(lidx, (hidx if hidx is None else hidx-1)))\n                else:\n                    index = (np.digitize([slc], data)-1)[0]\n                    sliced_data.append(data[index:index+2])\n                    indices.append(index)\n            z = np.atleast_2d(self.data[2][tuple(indices[::-1])])\n            if not all(slc_types) and not slc_types[0]:\n                z = z.T\n            return self.clone(tuple(sliced_data+[z]))\n\n\n    @classmethod\n    def collapse_data(cls, data_list, function, kdims=None, **kwargs):\n        \"\"\"\n        Allows collapsing the data of a number of QuadMesh\n        Elements with a function.\n        \"\"\"\n        if not all(data[0].ndim == 1 for data in data_list):\n            raise Exception(\"Collapsing of non-grid based QuadMesh\"\n                            \"currently not supported\")\n        xs, ys, zs = zip(data_list)\n        if isinstance(function, np.ufunc):\n            z = function.reduce(zs)\n        else:\n            z = function(np.dstack(zs), axis=-1, **kwargs)\n        return xs[0], ys[0], z\n\n\n    def _coord2matrix(self, coord):\n        return tuple((np.digitize([coord[i]], self.data[i])-1)[0]\n                     for i in [1, 0])\n\n\n    def range(self, dimension, data_range=True):\n        idx = self.get_dimension_index(dimension)\n        if data_range and idx in [0, 1]:\n            data = self.data[idx]\n            return np.min(data), np.max(data)\n        elif data_range and idx == 2:\n            data = self.data[idx]\n            return np.nanmin(data), np.nanmax(data)\n        super(QuadMesh, self).range(dimension)\n\n\n    def dimension_values(self, dimension, expanded=True, flat=True):\n        idx = self.get_dimension_index(dimension)\n        data = self.data[idx]\n        if idx in [0, 1]:\n            if not self._grid:\n                return data.flatten()\n            odim = self.data[2].shape[idx] if expanded else 1\n            vals = np.tile(np.convolve(data, np.ones((2,))/2, mode='valid'), odim)\n            if idx:\n                return np.sort(vals)\n            else:\n                return vals\n        elif idx == 2:\n            return data.flatten() if flat else data\n        else:\n            return super(QuadMesh, self).dimension_values(idx)\n\n\nclass HeatMap(Dataset, Element2D):\n    \"\"\"\n    HeatMap is an atomic Element used to visualize two dimensional\n    parameter spaces. It supports sparse or non-linear spaces, dynamically\n    upsampling them to a dense representation, which can be visualized.\n\n    A HeatMap can be initialized with any dict or NdMapping type with\n    two-dimensional keys.\n    \"\"\"\n\n    group = param.String(default='HeatMap', constant=True)\n\n    kdims = param.List(default=[Dimension('x'), Dimension('y')])\n\n    vdims = param.List(default=[Dimension('z')])\n\n    def __init__(self, data, **params):\n        super(HeatMap, self).__init__(data, **params)\n        self.gridded = categorical_aggregate2d(self)\n\n    @property\n    def raster(self):\n        self.warning(\"The .raster attribute on HeatMap is deprecated, \"\n                     \"the 2D aggregate is now computed dynamically \"\n                     \"during plotting.\")\n        return self.gridded.dimension_values(2, flat=False)\n\n\nclass Image(SheetCoordinateSystem, Raster):\n    \"\"\"\n    Image is the atomic unit as which 2D data is stored, along with\n    its bounds object. The input data may be a numpy.matrix object or\n    a two-dimensional numpy array.\n\n    Allows slicing operations of the data in sheet coordinates or direct\n    access to the data, via the .data attribute.\n    \"\"\"\n\n    bounds = param.ClassSelector(class_=BoundingRegion, default=BoundingBox(), doc=\"\"\"\n       The bounding region in sheet coordinates containing the data.\"\"\")\n\n    group = param.String(default='Image', constant=True)\n\n    vdims = param.List(default=[Dimension('z')],\n                       bounds=(1, 1), doc=\"\"\"\n        The dimension description of the data held in the matrix.\"\"\")\n\n\n    def __init__(self, data, bounds=None, extents=None, xdensity=None, ydensity=None, **params):\n        bounds = bounds if bounds is not None else BoundingBox()\n        if np.isscalar(bounds):\n            bounds = BoundingBox(radius=bounds)\n        elif isinstance(bounds, (tuple, list, np.ndarray)):\n            l, b, r, t = bounds\n            bounds = BoundingBox(points=((l, b), (r, t)))\n        if data is None: data = np.array([[0]])\n        l, b, r, t = bounds.lbrt()\n        extents = extents if extents else (None, None, None, None)\n        Element2D.__init__(self, data, extents=extents, bounds=bounds,\n                           **params)\n\n        (dim1, dim2) = self.data.shape[1], self.data.shape[0]\n        xdensity = xdensity if xdensity else dim1/float(r-l)\n        ydensity = ydensity if ydensity else dim2/float(t-b)\n        SheetCoordinateSystem.__init__(self, bounds, xdensity, ydensity)\n\n        if len(self.data.shape) == 3:\n            if self.data.shape[2] != len(self.vdims):\n                raise ValueError(\"Input array has shape %r but %d value dimensions defined\"\n                                 % (self.data.shape, len(self.vdims)))\n\n\n    def _convert_element(self, data):\n        if isinstance(data, (Raster, HeatMap)):\n            return data.data\n        else:\n            return super(Image, self)._convert_element(data)\n\n\n    def closest(self, coords=[], **kwargs):\n        \"\"\"\n        Given a single coordinate or multiple coordinates as\n        a tuple or list of tuples or keyword arguments matching\n        the dimension closest will find the closest actual x/y\n        coordinates.\n        \"\"\"\n        if kwargs and coords:\n            raise ValueError(\"Specify coordinate using as either a list \"\n                             \"keyword arguments not both\")\n        if kwargs:\n            coords = []\n            getter = []\n            for k, v in kwargs.items():\n                idx = self.get_dimension_index(k)\n                if np.isscalar(v):\n                    coords.append((0, v) if idx else (v, 0))\n                else:\n                    if isinstance(coords, tuple):\n                        coords = [(0, c) if idx else (c, 0) for c in v]\n                    if len(coords) not in [0, len(v)]:\n                        raise ValueError(\"Length of samples must match\")\n                    elif len(coords):\n                        coords = [(t[abs(idx-1)], c) if idx else (c, t[abs(idx-1)])\n                                  for c, t in zip(v, coords)]\n                getter.append(idx)\n        else:\n            getter = [0, 1]\n        getter = itemgetter(*sorted(getter))\n        coords = list(coords)\n        if len(coords) == 1:\n            coords = coords[0]\n        if isinstance(coords, tuple):\n            return getter(self.closest_cell_center(*coords))\n        else:\n            return [getter(self.closest_cell_center(*el)) for el in coords]\n\n\n    def __getitem__(self, coords):\n        \"\"\"\n        Slice the underlying numpy array in sheet coordinates.\n        \"\"\"\n        if coords in self.dimensions(): return self.dimension_values(coords)\n        coords = util.process_ellipses(self,coords)\n        if coords is () or coords == slice(None, None):\n            return self\n\n        if not isinstance(coords, tuple):\n            coords = (coords, slice(None))\n        if len(coords) > (2 + self.depth):\n            raise KeyError(\"Can only slice %d dimensions\" % 2 + self.depth)\n        elif len(coords) == 3 and coords[-1] not in [self.vdims[0].name, slice(None)]:\n            raise KeyError(\"%r is the only selectable value dimension\" % self.vdims[0].name)\n\n        coords = coords[:2]\n        if not any([isinstance(el, slice) for el in coords]):\n            return self.data[self.sheet2matrixidx(*coords)]\n        if all([isinstance(c, slice) for c in coords]):\n            l, b, r, t = self.bounds.lbrt()\n            xcoords, ycoords = coords\n            xstart = l if xcoords.start is None else max(l, xcoords.start)\n            xend = r if xcoords.stop is None else min(r, xcoords.stop)\n            ystart = b if ycoords.start is None else max(b, ycoords.start)\n            yend = t if ycoords.stop is None else min(t, ycoords.stop)\n            bounds = BoundingBox(points=((xstart, ystart), (xend, yend)))\n        else:\n            raise KeyError('Indexing requires x- and y-slice ranges.')\n\n        return self.clone(Slice(bounds, self).submatrix(self.data),\n                          bounds=bounds)\n\n\n    def range(self, dim, data_range=True):\n        dim_idx = dim if isinstance(dim, int) else self.get_dimension_index(dim)\n        dim = self.get_dimension(dim_idx)\n        if None not in dim.range:\n            return dim.range\n        elif dim_idx in [0, 1]:\n            l, b, r, t = self.bounds.lbrt()\n            if dim_idx:\n                drange = (b, t)\n            else:\n                drange = (l, r)\n        elif dim_idx < len(self.vdims) + 2:\n            dim_idx -= 2\n            data = np.atleast_3d(self.data)[:, :, dim_idx]\n            drange = (np.nanmin(data), np.nanmax(data))\n        if data_range:\n            soft_range = [np.NaN if sr is None else sr for sr in dim.soft_range]\n            if soft_range:\n                drange = util.max_range([drange, soft_range])\n            ranges = zip(drange, dim.range)\n        else:\n            ranges = zip(dim.soft_range, dim.range)\n        return tuple(datar if dimr is None else dimr\n                     for datar, dimr in ranges)\n\n\n    def _coord2matrix(self, coord):\n        return self.sheet2matrixidx(*coord)\n\n\n    def dimension_values(self, dim, expanded=True, flat=True):\n        \"\"\"\n        The set of samples available along a particular dimension.\n        \"\"\"\n        dim_idx = self.get_dimension_index(dim)\n        if dim_idx in [0, 1]:\n            l, b, r, t = self.bounds.lbrt()\n            dim2, dim1 = self.data.shape[:2]\n            d1_half_unit = (r - l)/dim1/2.\n            d2_half_unit = (t - b)/dim2/2.\n            d1lin = np.linspace(l+d1_half_unit, r-d1_half_unit, dim1)\n            d2lin = np.linspace(b+d2_half_unit, t-d2_half_unit, dim2)\n            if expanded:\n                values = np.meshgrid(d2lin, d1lin)[abs(dim_idx-1)]\n                return values.flatten() if flat else values\n            else:\n                return d2lin if dim_idx else d1lin\n        elif dim_idx == 2:\n            # Raster arrays are stored with different orientation\n            # than expanded column format, reorient before expanding\n            data = np.flipud(self.data).T\n            return data.flatten() if flat else data\n        else:\n            super(Image, self).dimension_values(dim)\n\n\n\nclass GridImage(Dataset, Element2D):\n    \"\"\"\n    Grid interface based version of an Image, which will\n    eventually supercede the original Image implementation.\n    \"\"\"\n\n    group = param.String(default='GridImage', constant=True)\n\n    kdims = param.List(default=[Dimension('x'), Dimension('y')],\n                       bounds=(2, 2))\n\n    vdims = param.List(default=[Dimension('z')], bounds=(1, 1))\n\n    def __init__(self, data, **params):\n        super(GridImage, self).__init__(data, **params)\n        (l, r), (b, t) = self.interface.range(self, 0), self.interface.range(self, 1)\n        (ys, xs) = self.dimension_values(2, flat=False).shape\n        xsampling = (float(r-l)/(xs-1))/2.\n        ysampling = (float(t-b)/(ys-1))/2.\n        l, r = l-xsampling, r+xsampling\n        b, t = b-ysampling, t+ysampling\n        self.bounds = BoundingBox(points=((l, b), (r, t)))\n\n    def range(self, dim, data_range=True):\n        dim_idx = dim if isinstance(dim, int) else self.get_dimension_index(dim)\n        dim = self.get_dimension(dim_idx)\n        if dim.range != (None, None):\n            return dim.range\n        elif dim_idx in [0, 1]:\n            l, b, r, t = self.bounds.lbrt()\n            if dim_idx:\n                drange = (b, t)\n            else:\n                drange = (l, r)\n            return drange\n        else:\n            return self.interface.range(self, dim)\n\n\n\nclass RGB(Image):\n    \"\"\"\n    An RGB element is a Image containing channel data for the the\n    red, green, blue and (optionally) the alpha channels. The values\n    of each channel must be in the range 0.0 to 1.0.\n\n    In input array may have a shape of NxMx4 or NxMx3. In the latter\n    case, the defined alpha dimension parameter is appended to the\n    list of value dimensions.\n    \"\"\"\n\n    group = param.String(default='RGB', constant=True)\n\n    alpha_dimension = param.ClassSelector(default=Dimension('A',range=(0,1)),\n                                          class_=Dimension, instantiate=False,  doc=\"\"\"\n        The alpha dimension definition to add the value dimensions if\n        an alpha channel is supplied.\"\"\")\n\n    vdims = param.List(\n        default=[Dimension('R', range=(0,1)), Dimension('G',range=(0,1)),\n                 Dimension('B', range=(0,1))], bounds=(3, 4), doc=\"\"\"\n        The dimension description of the data held in the matrix.\n\n        If an alpha channel is supplied, the defined alpha_dimension\n        is automatically appended to this list.\"\"\")\n\n    @property\n    def rgb(self):\n        \"\"\"\n        Returns the corresponding RGB element.\n\n        Other than the updating parameter definitions, this is the\n        only change needed to implemented an arbitrary colorspace as a\n        subclass of RGB.\n        \"\"\"\n        return self\n\n\n    @classmethod\n    def load_image(cls, filename, height=1, array=False, bounds=None, bare=False, **kwargs):\n        \"\"\"\n        Returns an raster element or raw numpy array from a PNG image\n        file, using matplotlib.\n\n        The specified height determines the bounds of the raster\n        object in sheet coordinates: by default the height is 1 unit\n        with the width scaled appropriately by the image aspect ratio.\n\n        Note that as PNG images are encoded as RGBA, the red component\n        maps to the first channel, the green component maps to the\n        second component etc. For RGB elements, this mapping is\n        trivial but may be important for subclasses e.g. for HSV\n        elements.\n\n        Setting bare=True will apply options disabling axis labels\n        displaying just the bare image. Any additional keyword\n        arguments will be passed to the Image object.\n        \"\"\"\n        try:\n            from matplotlib import pyplot as plt\n        except:\n            raise ImportError(\"RGB.load_image requires matplotlib.\")\n\n        data = plt.imread(filename)\n        if array:  return data\n\n        (h, w, _) = data.shape\n        if bounds is None:\n            f = float(height) / h\n            xoffset, yoffset = w*f/2, h*f/2\n            bounds=(-xoffset, -yoffset, xoffset, yoffset)\n        rgb = cls(data, bounds=bounds, **kwargs)\n        if bare: rgb = rgb(plot=dict(xaxis=None, yaxis=None))\n        return rgb\n\n\n    def dimension_values(self, dim, expanded=True, flat=True):\n        \"\"\"\n        The set of samples available along a particular dimension.\n        \"\"\"\n        dim_idx = self.get_dimension_index(dim)\n        if self.ndims <= dim_idx < len(self.dimensions()):\n            data = np.flipud(self.data[:,:,dim_idx-self.ndims]).T\n            return data.flatten() if flat else data\n        return super(RGB, self).dimension_values(dim, expanded, flat)\n\n\n    def __init__(self, data, **params):\n        sliced = None\n        if isinstance(data, Overlay):\n            images = data.values()\n            if not all(isinstance(im, Image) for im in images):\n                raise ValueError(\"Input overlay must only contain Image elements\")\n            shapes = [im.data.shape for im in images]\n            if not all(shape==shapes[0] for shape in shapes):\n                raise ValueError(\"Images in the input overlays must contain data of the consistent shape\")\n            ranges = [im.vdims[0].range for im in images]\n            if any(None in r for r in ranges):\n                raise ValueError(\"Ranges must be defined on all the value dimensions of all the Images\")\n            arrays = [(im.data - r[0]) / (r[1] - r[0]) for r,im in zip(ranges, images)]\n            data = np.dstack(arrays)\n\n        if not isinstance(data, Element):\n            if len(data.shape) != 3:\n                raise ValueError(\"Three dimensional matrices or arrays required\")\n            elif data.shape[2] == 4:\n                sliced = data[:,:,:-1]\n\n        if len(params.get('vdims',[])) == 4:\n            alpha_dim = params['vdims'].pop(3)\n            params['alpha_dimension'] = alpha_dim\n\n        super(RGB, self).__init__(data if sliced is None else sliced, **params)\n        if sliced is not None:\n            self.vdims.append(self.alpha_dimension)\n            self.data = data\n\n\n    def __getitem__(self, coords):\n        \"\"\"\n        Slice the underlying numpy array in sheet coordinates.\n        \"\"\"\n        if coords in self.dimensions(): return self.dimension_values(coords)\n        coords = util.process_ellipses(self, coords)\n        if not isinstance(coords, slice) and len(coords) > self.ndims:\n            values = coords[self.ndims:]\n            channels = [el for el in values\n                        if isinstance(el, (str, util.unicode, Dimension))]\n            if len(channels) == 1:\n                sliced = super(RGB, self).__getitem__(coords[:self.ndims])\n                if channels[0] not in self.vdims:\n                    raise KeyError(\"%r is not an available value dimension\"\n                                    % channels[0])\n                vidx = self.get_dimension_index(channels[0])\n                val_index = vidx - self.ndims\n                data = sliced.data[:,:, val_index]\n                return Image(data, **dict(util.get_param_values(self),\n                                          vdims=[self.vdims[val_index]]))\n            elif len(channels) > 1:\n                raise KeyError(\"Channels can only be selected once in __getitem__\")\n            elif all(v==slice(None) for v in values):\n                coords = coords[:self.ndims]\n            else:\n                raise KeyError(\"Only empty value slices currently supported in RGB\")\n        return super(RGB, self).__getitem__(coords)\n\n\nclass HSV(RGB):\n    \"\"\"\n    Example of a commonly used color space subclassed from RGB used\n    for working in a HSV (hue, saturation and value) color space.\n    \"\"\"\n\n    group = param.String(default='HSV', constant=True)\n\n    alpha_dimension = param.ClassSelector(default=Dimension('A',range=(0,1)),\n                                          class_=Dimension, instantiate=False,  doc=\"\"\"\n        The alpha dimension definition to add the value dimensions if\n        an alpha channel is supplied.\"\"\")\n\n    vdims = param.List(\n        default=[Dimension('H', range=(0,1), cyclic=True),\n                 Dimension('S',range=(0,1)),\n                 Dimension('V', range=(0,1))], bounds=(3, 4), doc=\"\"\"\n        The dimension description of the data held in the array.\n\n        If an alpha channel is supplied, the defined alpha_dimension\n        is automatically appended to this list.\"\"\")\n\n    hsv_to_rgb = np.vectorize(colorsys.hsv_to_rgb)\n\n    @property\n    def rgb(self):\n        \"\"\"\n        Conversion from HSV to RGB.\n        \"\"\"\n        hsv = self.hsv_to_rgb(self.data[:,:,0],\n                              self.data[:,:,1],\n                              self.data[:,:,2])\n        if len(self.vdims) == 4:\n            hsv += (self.data[:,:,3],)\n\n        return RGB(np.dstack(hsv), bounds=self.bounds,\n                   group=self.group,\n                   label=self.label)\n"
    }
  ]
}