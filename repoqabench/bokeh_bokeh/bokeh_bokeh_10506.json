{
  "repo_name": "bokeh_bokeh",
  "issue_id": "10506",
  "issue_description": "# [FEATURE] Hiding hex number from color swatch in hover tool\n\nIt'd be nice to have an option to hide hex number from the hover. Swatch is a great option, but sometimes there is no need to share a information about the HEX. Inspired by the discussion [here](https://discourse.bokeh.org/t/hiding-hex-number-from-hover-tool-swatch/6324).\r\n\r\n![image](https://user-images.githubusercontent.com/10706421/93608900-76800480-f9cb-11ea-9f8b-4a6bb914c93d.png)\r\n\r\n\r\n",
  "issue_comments": [
    {
      "id": 697046984,
      "user": "bryevdv",
      "body": "This is supposed to be possible (used to be possible) by specifying  e.g.\r\n```\r\n$color[swatch]:fill_color\"\r\n```\r\nbut AFAICT it is currently not respecting that configuration. @tmikolajczyk can you confirm that it also does not work for you?\r\n\r\nEdit:\r\n\r\nhttps://github.com/bokeh/bokeh/blob/d64f145aa062d8b59daa8b8f13505675f775f57a/bokehjs/src/lib/models/tools/inspectors/hover_tool.ts#L455-L457\r\n\r\nOffhand it seems like the last line should be part of the if-block"
    },
    {
      "id": 697214024,
      "user": "tmikolajczyk",
      "body": "@bryevdv, yes I confirm that hiding hex does not work for me"
    },
    {
      "id": 697223125,
      "user": "mattpap",
      "body": "> This is supposed to be possible (used to be possible) by specifying (...)\r\n\r\nAs far as I can tell (at least going back to 2017), this hasn't been possible and adding `hex` only means to convert a CSS color spec to hex representation, but color string regardless of representation is non-optional (swatch is). Changing the existing behavior would be a breaking change, so I would add another special variable `$swatch:field_name` to resolve this."
    },
    {
      "id": 734644024,
      "user": "MarkSachinPerera",
      "body": "Hey, I am new to the project and I would like to take a crack at this."
    },
    {
      "id": 734947060,
      "user": "bryevdv",
      "body": "@MarkSachinPerera Contributors come in with lots varying experience, please let us know where we can help with any guidance as you start taking a look. "
    },
    {
      "id": 734950186,
      "user": "MarkSachinPerera",
      "body": "Thanks! ill let you know if i need help ðŸ˜„ "
    },
    {
      "id": 735318058,
      "user": "MarkSachinPerera",
      "body": "Link to new code: https://github.com/MarkSachinPerera/bokeh/commit/3df6917a8fa1d5d954eefa70c32990c2b391c1ac\r\n\r\nSo running this piece of code: \r\n\r\n```\r\nsource = ColumnDataSource(data=dict(\r\n    x=[1, 2, 3, 4, 5],\r\n    y=[2, 5, 8, 2, 7],\r\n    color=['red', 'red', '#1f9ca7', '#0ea2e9', '#01e3ed']\r\n))\r\n\r\np = figure(plot_width=400, plot_height=400, tooltips=[(\"fill color\", \"$color[swatch,hideColorValue]:color\"),],\r\n           title=\"Mouse over the dots\")\r\n\r\np.circle('x', 'y', size=20, source=source, color='color')\r\n```\r\n\r\nHere the new `hideColorValues` option will hide any text (string  representation or hex representation) from the fill color tag. \r\n\r\nSome screen shots:\r\n![image](https://user-images.githubusercontent.com/34218455/100530102-136cd400-31ab-11eb-958b-52bbdfec0eea.png)\r\n\r\n![image](https://user-images.githubusercontent.com/34218455/100530110-27183a80-31ab-11eb-8499-8dc0fd86e146.png)\r\n\r\n\r\nIs this solution valid?\r\n\r\nBecause I was unsure what this comment meant?\r\n\r\n> so I would add another special variable $swatch:field_name to resolve this.\r\n\r\n\r\n"
    },
    {
      "id": 735338652,
      "user": "bryevdv",
      "body": "@MarkSachinPerera My interpretation of the above is to allow:\r\n```\r\n$color:fieldname      # display the color value as-is (no swatch) \r\n$color[hex]:fieldname # display the color value hex-formatted (no swatch)\r\n$swatch:fieldname     # display a swatch for fieldname (no color value)\r\n```\r\nThis decouples swatch inclusion from color string formatting, which is preferable for sure. It leaves open a natural place for new formatting types in the future e.g. `$color[rgb]:fieldname` or similar. \r\n\r\nFor compatibility, this should still work:\r\n```\r\n$color[swatch,hex]:fieldname  # display color value hex-formatter, and a swatch (current behavior)\r\n```\r\nbut we can deprecate that usage, and encourage this instead:\r\n```\r\n$color[hex]:fieldname $swatch:fieldname\r\n```"
    },
    {
      "id": 735429025,
      "user": "MarkSachinPerera",
      "body": "ahh okay. I will update this accordingly. "
    },
    {
      "id": 736118360,
      "user": "MarkSachinPerera",
      "body": "Link: https://github.com/bokeh/bokeh/pull/10743/files\r\n\r\n\r\nI updated the code as requested. I defined a new special variable called \"swatch\" which decouples the swatch functionality from the color field. Now, you can add the swatch element to any field you want.  In addition, the code is backwards compatible so that the swatch option continues to work for the color field. For bad input handling, I was not sure what the preferred behavior is. Right now, I hide the swatch element and just display text.\r\n\r\nI can update the documentation if the behavior looks good. In terms of testing, I looked around and couldn't finding existing tests for testing specific special variables used in the hover_tool. Do we need tests for this case?\r\n\r\nTest program: \r\n\r\n```\r\nimport numpy as np\r\n\r\nfrom bokeh.io import curdoc\r\nfrom bokeh.layouts import column, row\r\nfrom bokeh.models import ColumnDataSource, Slider, TextInput\r\nfrom bokeh.plotting import figure\r\n\r\n\r\n\r\nsource = ColumnDataSource(data=dict(\r\n    x=[1, 2, 3, 4, 5],\r\n    y=[2, 5, 8, 2, 7],\r\n    color=['red', 'red', '#1f9ca7', '#0ea2e9', '#01e3ed']\r\n))\r\n\r\np = figure(plot_width=400, plot_height=400, tooltips = [\r\n    (\"(x,y)\", \"($x, $y)\"),\r\n    (\"old_color_swatch\", \"$color[hex, swatch]:color\"),\r\n    (\"new_color_swatch\", \"$color[hex]:color $swatch:color\"),\r\n    (\"swatch\", \"$swatch:color\")\r\n],\r\n           title=\"Mouse over the dots\")\r\n\r\np.circle('x', 'y', size=20, source=source, color='color')\r\n\r\n\r\ncurdoc().add_root(p)\r\ncurdoc().title = \"Sliders\"\r\n```\r\n\r\nExample 1:\r\n![image](https://user-images.githubusercontent.com/34218455/100678402-45587480-332a-11eb-9817-ce9a6f756427.png)\r\n\r\n\r\nExample 2:\r\n![image](https://user-images.githubusercontent.com/34218455/100678421-55705400-332a-11eb-95bf-80a7f86e71e7.png)\r\n\r\n\r\n\r\n\r\n"
    },
    {
      "id": 2439615202,
      "user": "github-actions[bot]",
      "body": "This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs."
    }
  ],
  "text_context": "# [FEATURE] Hiding hex number from color swatch in hover tool\n\nIt'd be nice to have an option to hide hex number from the hover. Swatch is a great option, but sometimes there is no need to share a information about the HEX. Inspired by the discussion [here](https://discourse.bokeh.org/t/hiding-hex-number-from-hover-tool-swatch/6324).\r\n\r\n![image](https://user-images.githubusercontent.com/10706421/93608900-76800480-f9cb-11ea-9f8b-4a6bb914c93d.png)\r\n\r\n\r\n\n\nThis is supposed to be possible (used to be possible) by specifying  e.g.\r\n```\r\n$color[swatch]:fill_color\"\r\n```\r\nbut AFAICT it is currently not respecting that configuration. @tmikolajczyk can you confirm that it also does not work for you?\r\n\r\nEdit:\r\n\r\nhttps://github.com/bokeh/bokeh/blob/d64f145aa062d8b59daa8b8f13505675f775f57a/bokehjs/src/lib/models/tools/inspectors/hover_tool.ts#L455-L457\r\n\r\nOffhand it seems like the last line should be part of the if-block\n\n@bryevdv, yes I confirm that hiding hex does not work for me\n\n> This is supposed to be possible (used to be possible) by specifying (...)\r\n\r\nAs far as I can tell (at least going back to 2017), this hasn't been possible and adding `hex` only means to convert a CSS color spec to hex representation, but color string regardless of representation is non-optional (swatch is). Changing the existing behavior would be a breaking change, so I would add another special variable `$swatch:field_name` to resolve this.\n\nHey, I am new to the project and I would like to take a crack at this.\n\n@MarkSachinPerera Contributors come in with lots varying experience, please let us know where we can help with any guidance as you start taking a look. \n\nThanks! ill let you know if i need help ðŸ˜„ \n\nLink to new code: https://github.com/MarkSachinPerera/bokeh/commit/3df6917a8fa1d5d954eefa70c32990c2b391c1ac\r\n\r\nSo running this piece of code: \r\n\r\n```\r\nsource = ColumnDataSource(data=dict(\r\n    x=[1, 2, 3, 4, 5],\r\n    y=[2, 5, 8, 2, 7],\r\n    color=['red', 'red', '#1f9ca7', '#0ea2e9', '#01e3ed']\r\n))\r\n\r\np = figure(plot_width=400, plot_height=400, tooltips=[(\"fill color\", \"$color[swatch,hideColorValue]:color\"),],\r\n           title=\"Mouse over the dots\")\r\n\r\np.circle('x', 'y', size=20, source=source, color='color')\r\n```\r\n\r\nHere the new `hideColorValues` option will hide any text (string  representation or hex representation) from the fill color tag. \r\n\r\nSome screen shots:\r\n![image](https://user-images.githubusercontent.com/34218455/100530102-136cd400-31ab-11eb-958b-52bbdfec0eea.png)\r\n\r\n![image](https://user-images.githubusercontent.com/34218455/100530110-27183a80-31ab-11eb-8499-8dc0fd86e146.png)\r\n\r\n\r\nIs this solution valid?\r\n\r\nBecause I was unsure what this comment meant?\r\n\r\n> so I would add another special variable $swatch:field_name to resolve this.\r\n\r\n\r\n\n\n@MarkSachinPerera My interpretation of the above is to allow:\r\n```\r\n$color:fieldname      # display the color value as-is (no swatch) \r\n$color[hex]:fieldname # display the color value hex-formatted (no swatch)\r\n$swatch:fieldname     # display a swatch for fieldname (no color value)\r\n```\r\nThis decouples swatch inclusion from color string formatting, which is preferable for sure. It leaves open a natural place for new formatting types in the future e.g. `$color[rgb]:fieldname` or similar. \r\n\r\nFor compatibility, this should still work:\r\n```\r\n$color[swatch,hex]:fieldname  # display color value hex-formatter, and a swatch (current behavior)\r\n```\r\nbut we can deprecate that usage, and encourage this instead:\r\n```\r\n$color[hex]:fieldname $swatch:fieldname\r\n```\n\nahh okay. I will update this accordingly. \n\nLink: https://github.com/bokeh/bokeh/pull/10743/files\r\n\r\n\r\nI updated the code as requested. I defined a new special variable called \"swatch\" which decouples the swatch functionality from the color field. Now, you can add the swatch element to any field you want.  In addition, the code is backwards compatible so that the swatch option continues to work for the color field. For bad input handling, I was not sure what the preferred behavior is. Right now, I hide the swatch element and just display text.\r\n\r\nI can update the documentation if the behavior looks good. In terms of testing, I looked around and couldn't finding existing tests for testing specific special variables used in the hover_tool. Do we need tests for this case?\r\n\r\nTest program: \r\n\r\n```\r\nimport numpy as np\r\n\r\nfrom bokeh.io import curdoc\r\nfrom bokeh.layouts import column, row\r\nfrom bokeh.models import ColumnDataSource, Slider, TextInput\r\nfrom bokeh.plotting import figure\r\n\r\n\r\n\r\nsource = ColumnDataSource(data=dict(\r\n    x=[1, 2, 3, 4, 5],\r\n    y=[2, 5, 8, 2, 7],\r\n    color=['red', 'red', '#1f9ca7', '#0ea2e9', '#01e3ed']\r\n))\r\n\r\np = figure(plot_width=400, plot_height=400, tooltips = [\r\n    (\"(x,y)\", \"($x, $y)\"),\r\n    (\"old_color_swatch\", \"$color[hex, swatch]:color\"),\r\n    (\"new_color_swatch\", \"$color[hex]:color $swatch:color\"),\r\n    (\"swatch\", \"$swatch:color\")\r\n],\r\n           title=\"Mouse over the dots\")\r\n\r\np.circle('x', 'y', size=20, source=source, color='color')\r\n\r\n\r\ncurdoc().add_root(p)\r\ncurdoc().title = \"Sliders\"\r\n```\r\n\r\nExample 1:\r\n![image](https://user-images.githubusercontent.com/34218455/100678402-45587480-332a-11eb-9817-ce9a6f756427.png)\r\n\r\n\r\nExample 2:\r\n![image](https://user-images.githubusercontent.com/34218455/100678421-55705400-332a-11eb-95bf-80a7f86e71e7.png)\r\n\r\n\r\n\r\n\r\n\n\nThis issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.",
  "pr_link": "https://github.com/bokeh/bokeh/pull/10743",
  "code_context": [
    {
      "filename": "bokeh/models/tools.py",
      "content": "#-----------------------------------------------------------------------------\n# Copyright (c) 2012 - 2020, Anaconda, Inc., and Bokeh Contributors.\n# All rights reserved.\n#\n# The full license is in the file LICENSE.txt, distributed with this software.\n#-----------------------------------------------------------------------------\n''' Bokeh comes with a number of interactive tools.\n\nThere are five types of tool interactions:\n\n.. hlist::\n    :columns: 5\n\n    * Pan/Drag\n    * Click/Tap\n    * Scroll/Pinch\n    * Actions\n    * Inspectors\n\nFor the first three comprise the category of gesture tools, and only\none tool for each gesture can be active at any given time. The active\ntool is indicated on the toolbar by a highlight next to the tool.\nActions are immediate or modal operations that are only activated when\ntheir button in the toolbar is pressed. Inspectors are passive tools that\nmerely report information or annotate the plot in some way, and may\nalways be active regardless of what other tools are currently active.\n\n'''\n\n#-----------------------------------------------------------------------------\n# Boilerplate\n#-----------------------------------------------------------------------------\nimport logging # isort:skip\nlog = logging.getLogger(__name__)\n\n#-----------------------------------------------------------------------------\n# Imports\n#-----------------------------------------------------------------------------\n\n# Standard library imports\nimport difflib\nimport typing as tp\nfrom typing_extensions import Literal\n\n# Bokeh imports\nfrom ..core.enums import (\n    Anchor,\n    Dimension,\n    Dimensions,\n    Location,\n    SelectionMode,\n    TooltipAttachment,\n    TooltipFieldFormatter,\n)\nfrom ..core.has_props import abstract\nfrom ..core.properties import (\n    Alpha,\n    Auto,\n    Bool,\n    Color,\n    Date,\n    Datetime,\n    Dict,\n    Either,\n    Enum,\n    Float,\n    Image,\n    Instance,\n    Int,\n    List,\n    Override,\n    Percent,\n    Seq,\n    String,\n    Tuple,\n)\nfrom ..core.validation import error\nfrom ..core.validation.errors import (\n    INCOMPATIBLE_BOX_EDIT_RENDERER,\n    INCOMPATIBLE_LINE_EDIT_INTERSECTION_RENDERER,\n    INCOMPATIBLE_LINE_EDIT_RENDERER,\n    INCOMPATIBLE_POINT_DRAW_RENDERER,\n    INCOMPATIBLE_POLY_DRAW_RENDERER,\n    INCOMPATIBLE_POLY_EDIT_RENDERER,\n    INCOMPATIBLE_POLY_EDIT_VERTEX_RENDERER,\n    NO_RANGE_TOOL_RANGES,\n)\nfrom ..model import Model\nfrom ..util.deprecation import deprecated\nfrom ..util.string import nice_join\nfrom .annotations import BoxAnnotation, PolyAnnotation\nfrom .callbacks import Callback\nfrom .glyphs import Line, LineGlyph, MultiLine, Patches, Rect, XYGlyph\nfrom .layouts import LayoutDOM\nfrom .ranges import Range1d\nfrom .renderers import DataRenderer, GlyphRenderer\n\n#-----------------------------------------------------------------------------\n# Globals and constants\n#-----------------------------------------------------------------------------\n\n__all__ = (\n    'Action',\n    'ActionTool',\n    'BoxEditTool',\n    'BoxSelectTool',\n    'BoxZoomTool',\n    'CrosshairTool',\n    'CustomAction',\n    'CustomJSHover',\n    'Drag',\n    'EditTool',\n    'FreehandDrawTool',\n    'HelpTool',\n    'HoverTool',\n    'Inspection',\n    'InspectTool',\n    'Gesture',\n    'GestureTool',\n    'LassoSelectTool',\n    'LineEditTool',\n    'PanTool',\n    'PointDrawTool',\n    'PolyDrawTool',\n    'PolyEditTool',\n    'PolySelectTool',\n    'ProxyToolbar',\n    'RangeTool',\n    'RedoTool',\n    'ResetTool',\n    'SaveTool',\n    'Scroll',\n    'Tap',\n    'TapTool',\n    'Tool',\n    'Toolbar',\n    'ToolbarBase',\n    'ToolbarBox',\n    'UndoTool',\n    'WheelPanTool',\n    'WheelZoomTool',\n    'ZoomInTool',\n    'ZoomOutTool',\n)\n\n#-----------------------------------------------------------------------------\n# General API\n#-----------------------------------------------------------------------------\n\n@abstract\nclass Tool(Model):\n    ''' A base class for all interactive tool types.\n\n    '''\n\n    description = String(default=None, help=\"\"\"\n    A string describing the purpose of this tool. If not defined, an auto-generated\n    description will be used. This description will be typically presented in the\n    user interface as a tooltip.\n    \"\"\")\n\n    _known_aliases: tp.ClassVar[tp.Dict[str, tp.Callable[[], \"Tool\"]]] = {}\n\n    @classmethod\n    def from_string(cls, name: str) -> \"Tool\":\n        \"\"\" Takes a string and returns a corresponding `Tool` instance. \"\"\"\n        constructor = cls._known_aliases.get(name)\n        if constructor is not None:\n            return constructor()\n        else:\n            known_names = cls._known_aliases.keys()\n            matches, text = difflib.get_close_matches(name.lower(), known_names), \"similar\"\n            if not matches:\n                matches, text = known_names, \"possible\"\n            raise ValueError(f\"unexpected tool name '{name}', {text} tools are {nice_join(matches)}\")\n\n    @classmethod\n    def register_alias(cls, name: str, constructor: tp.Callable[[], \"Tool\"]) -> None:\n        cls._known_aliases[name] = constructor\n\n@abstract\nclass ActionTool(Tool):\n    ''' A base class for tools that are buttons in the toolbar.\n\n    '''\n    pass\n\n# TODO: deprecated, remove at bokeh 3.0\nAction = ActionTool\n\n@abstract\nclass GestureTool(Tool):\n    ''' A base class for tools that respond to drag events.\n\n    '''\n    pass\n\n# TODO: deprecated, remove at bokeh 3.0\nGesture = GestureTool\n\n@abstract\nclass Drag(GestureTool):\n    ''' A base class for tools that respond to drag events.\n\n    '''\n    pass\n\n@abstract\nclass Scroll(GestureTool):\n    ''' A base class for tools that respond to scroll events.\n\n    '''\n    pass\n\n@abstract\nclass Tap(GestureTool):\n    ''' A base class for tools that respond to tap/click events.\n\n    '''\n    pass\n\n@abstract\nclass SelectTool(GestureTool):\n    ''' A base class for tools that perfrom \"selections\", e.g. ``BoxSelectTool``.\n\n    '''\n\n    names = List(String, help=\"\"\"\n    A list of names to query for. If set, only renderers that have a matching\n    value for their ``name`` attribute will be used.\n\n    .. note:\n        This property is deprecated and will be removed in bokeh 3.0.\n\n    \"\"\")\n\n    renderers = Either(Auto, List(Instance(DataRenderer)), default=\"auto\", help=\"\"\"\n    An explicit list of renderers to hit test against. If unset, defaults to\n    all renderers on a plot.\n    \"\"\")\n\n    mode = Enum(SelectionMode, default=\"replace\", help=\"\"\"\n    Defines what should happen when a new selection is made. The default\n    is to replace the existing selection. Other options are to append to\n    the selection, intersect with it or subtract from it.\n    \"\"\")\n\n@abstract\nclass InspectTool(GestureTool):\n    ''' A base class for tools that perform \"inspections\", e.g. ``HoverTool``.\n\n    '''\n    toggleable = Bool(True, help=\"\"\"\n    Whether an on/off toggle button should appear in the toolbar for this\n    inspection tool. If ``False``, the viewers of a plot will not be able to\n    toggle the inspector on or off using the toolbar.\n    \"\"\")\n\n# TODO: deprecated, remove at bokeh 3.0\nInspection = InspectTool\n\n@abstract\nclass ToolbarBase(Model):\n    ''' A base class for different toolbars.\n\n    '''\n\n    logo = Enum(\"normal\", \"grey\", help=\"\"\"\n    What version of the Bokeh logo to display on the toolbar. If\n    set to None, no logo will be displayed.\n    \"\"\")\n\n    autohide = Bool(default=False, help=\"\"\"\n    Whether the toolbar will be hidden by default. Default: False.\n    If True, hides toolbar when cursor is not in canvas.\n    \"\"\")\n\n    tools = List(Instance(Tool), help=\"\"\"\n    A list of tools to add to the plot.\n    \"\"\")\n\nclass Toolbar(ToolbarBase):\n    ''' Collect tools to display for a single plot.\n\n    '''\n\n    active_drag: tp.Union[Literal[\"auto\"], Drag, None] = Either(Auto, Instance(Drag), help=\"\"\"\n    Specify a drag tool to be active when the plot is displayed.\n    \"\"\")\n\n    active_inspect: tp.Union[Literal[\"auto\"], InspectTool, tp.Sequence[InspectTool], None] = \\\n        Either(Auto, Instance(InspectTool), Seq(Instance(InspectTool)), help=\"\"\"\n    Specify an inspection tool or sequence of inspection tools to be active when\n    the plot is displayed.\n    \"\"\")\n\n    active_scroll: tp.Union[Literal[\"auto\"], Scroll, None] = Either(Auto, Instance(Scroll), help=\"\"\"\n    Specify a scroll/pinch tool to be active when the plot is displayed.\n    \"\"\")\n\n    active_tap: tp.Union[Literal[\"auto\"], Tap, None] = Either(Auto, Instance(Tap), help=\"\"\"\n    Specify a tap/click tool to be active when the plot is displayed.\n    \"\"\")\n\n    active_multi: tp.Union[Literal[\"auto\"], GestureTool, None] = Instance(GestureTool, help=\"\"\"\n    Specify an active multi-gesture tool, for instance an edit tool or a range\n    tool.\n\n    Note that activating a multi-gesture tool will deactivate any other gesture\n    tools as appropriate. For example, if a pan tool is set as the active drag,\n    and this property is set to a ``BoxEditTool`` instance, the pan tool will\n    be deactivated (i.e. the multi-gesture tool will take precedence).\n    \"\"\")\n\nclass ProxyToolbar(ToolbarBase):\n    ''' A toolbar that allow to merge and proxy tools of toolbars in multiple\n    plots.\n\n    '''\n\n    toolbars = List(Instance(Toolbar), help=\"\"\"\n    \"\"\")\n\nclass ToolbarBox(LayoutDOM):\n    ''' A layoutable toolbar that can accept the tools of multiple plots, and\n    can merge the tools into a single button for convenience.\n\n    '''\n\n    toolbar = Instance(ToolbarBase, help=\"\"\"\n    A toolbar associated with a plot which holds all its tools.\n    \"\"\")\n\n    toolbar_location = Enum(Location, default=\"right\")\n\nclass PanTool(Drag):\n    ''' *toolbar icon*: |pan_icon|\n\n    The pan tool allows the user to pan a Plot by left-dragging a mouse, or on\n    touch devices by dragging a finger or stylus, across the plot region.\n\n    The pan tool also activates the border regions of a Plot for \"single axis\"\n    panning. For instance, dragging in the vertical border or axis will effect\n    a pan in the vertical direction only, with horizontal dimension kept fixed.\n\n    .. |pan_icon| image:: /_images/icons/Pan.png\n        :height: 24px\n\n    '''\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the pan tool is constrained to act in. By default\n    the pan tool will pan in any dimension, but can be configured to only\n    pan horizontally across the width of the plot, or vertically across the\n    height of the plot.\n    \"\"\")\n\nDEFAULT_RANGE_OVERLAY = lambda: BoxAnnotation(\n    level=\"overlay\",\n    fill_color=\"lightgrey\",\n    fill_alpha=0.5,\n    line_color=\"black\",\n    line_alpha=1.0,\n    line_width=0.5,\n    line_dash=[2,2],\n)\n\nclass RangeTool(Drag):\n    ''' *toolbar icon*: |range_icon|\n\n    The range tool allows the user to update range objects for either or both\n    of the x- or y-dimensions by dragging a corresponding shaded annotation to\n    move it or change its boundaries.\n\n    A common use case is to add this tool to a plot with a large fixed range,\n    but to configure the tool range from a different plot. When the user\n    manipulates the overlay, the range of the second plot will be updated\n    automatically.\n\n    .. |range_icon| image:: /_images/icons/Range.png\n        :height: 24px\n\n    '''\n\n    x_range = Instance(Range1d, help=\"\"\"\n    A range synchronized to the x-dimension of the overlay. If None, the overlay\n    will span the entire x-dimension.\n    \"\"\")\n\n    x_interaction = Bool(default=True, help=\"\"\"\n    Whether to respond to horizontal pan motions when an ``x_range`` is present.\n\n    By default, when an ``x_range`` is specified, it is possible to adjust the\n    horizontal position of the range box by panning horizontally inside the\n    box, or along the top or bottom edge of the box. To disable this, and fix\n    the  range box in place horizontally, set to False. (The box will still\n    update if the ``x_range`` is updated programmatically.)\n    \"\"\")\n\n    y_range = Instance(Range1d, help=\"\"\"\n    A range synchronized to the y-dimension of the overlay. If None, the overlay\n    will span the entire y-dimension.\n    \"\"\")\n\n    y_interaction = Bool(default=True, help=\"\"\"\n    Whether to respond to vertical pan motions when a ``y_range`` is present.\n\n    By default, when a ``y_range`` is specified, it is possible to adjust the\n    vertical position of the range box by panning vertically inside the box, or\n    along the top or bottom edge of the box. To disable this, and fix the range\n    box in place vertically, set to False. (The box will still update if the\n    ``y_range`` is updated programmatically.)\n    \"\"\")\n\n    overlay = Instance(BoxAnnotation, default=DEFAULT_RANGE_OVERLAY, help=\"\"\"\n    A shaded annotation drawn to indicate the configured ranges.\n    \"\"\")\n\n    @error(NO_RANGE_TOOL_RANGES)\n    def _check_no_range_tool_ranges(self):\n        if self.x_range is None and self.y_range is None:\n            return \"At least one of RangeTool.x_range or RangeTool.y_range must be configured\"\n\nclass WheelPanTool(Scroll):\n    ''' *toolbar icon*: |wheel_pan_icon|\n\n    The wheel pan tool allows the user to pan the plot along the configured\n    dimension using the scroll wheel.\n\n    .. |wheel_pan_icon| image:: /_images/icons/WheelPan.png\n        :height: 24px\n\n    '''\n\n    dimension = Enum(Dimension, default=\"width\", help=\"\"\"\n    Which dimension the wheel pan tool is constrained to act in. By default the\n    wheel pan tool will pan the plot along the x-axis.\n    \"\"\")\n\nclass WheelZoomTool(Scroll):\n    ''' *toolbar icon*: |wheel_zoom_icon|\n\n    The wheel zoom tool will zoom the plot in and out, centered on the\n    current mouse location.\n\n    The wheel zoom tool also activates the border regions of a Plot for\n    \"single axis\" zooming. For instance, zooming in the vertical border or\n    axis will effect a zoom in the vertical direction only, with the\n    horizontal dimension kept fixed.\n\n    .. |wheel_zoom_icon| image:: /_images/icons/WheelZoom.png\n        :height: 24px\n\n    '''\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the wheel zoom tool is constrained to act in. By default\n    the wheel zoom tool will zoom in any dimension, but can be configured to\n    only zoom horizontally across the width of the plot, or vertically across\n    the height of the plot.\n    \"\"\")\n\n    maintain_focus = Bool(default=True, help=\"\"\"\n    Whether or not zooming tool maintains its focus position. Setting to False\n    results in a more \"gliding\" behavior, allowing one to zoom out more\n    smoothly, at the cost of losing the focus position.\n    \"\"\")\n\n    zoom_on_axis = Bool(default=True, help=\"\"\"\n    Whether scrolling on an axis (outside the central plot area) should zoom\n    that dimension.\n    \"\"\")\n\n    speed = Float(default=1/600, help=\"\"\"\n    Speed at which the wheel zooms. Default is 1/600. Optimal range is between\n    0.001 and 0.09. High values will be clipped. Speed may very between browsers.\n    \"\"\")\n\nclass CustomAction(ActionTool):\n    ''' Execute a custom action, e.g. ``CustomJS`` callback when a toolbar\n    icon is activated.\n\n    Example:\n\n        .. code-block:: python\n\n            tool = CustomAction(icon=\"icon.png\",\n                                callback=CustomJS(code='alert(\"foo\")'))\n\n            plot.add_tools(tool)\n\n    '''\n\n    def __init__(self, *args, **kwargs):\n        action_tooltip = kwargs.pop(\"action_tooltip\", None)\n        if action_tooltip is not None:\n            deprecated((2, 3, 0), \"CustomAction.action_tooltip\", \"CustomAction.description\")\n            kwargs[\"description\"] = action_tooltip\n        super().__init__(*args, **kwargs)\n\n    @property\n    def action_tooltip(self):\n        deprecated((2, 3, 0), \"CustomAction.action_tooltip\", \"CustomAction.description\")\n        return self.description\n    @action_tooltip.setter\n    def action_tooltip(self, description):\n        deprecated((2, 3, 0), \"CustomAction.action_tooltip\", \"CustomAction.description\")\n        self.description = description\n\n    description = Override(default=\"Perform a Custom Action\")\n\n    callback = Instance(Callback, help=\"\"\"\n    A Bokeh callback to execute when the custom action icon is activated.\n    \"\"\")\n\n    icon = Image(help=\"\"\"\n    An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.\n    \"\"\")\n\nclass SaveTool(ActionTool):\n    ''' *toolbar icon*: |save_icon|\n\n    The save tool is an action. When activated, the tool opens a download dialog\n    which allows to save an image reproduction of the plot in PNG format. If\n    automatic download is not support by a web browser, the tool falls back to\n    opening the generated image in a new tab or window. User then can manually\n    save it by right clicking on the image and choosing \"Save As\" (or similar)\n    menu item.\n\n    .. |save_icon| image:: /_images/icons/Save.png\n        :height: 24px\n\n    '''\n\nclass ResetTool(ActionTool):\n    ''' *toolbar icon*: |reset_icon|\n\n    The reset tool is an action. When activated in the toolbar, the tool resets\n    the data bounds of the plot to their values when the plot was initially\n    created.\n\n    .. |reset_icon| image:: /_images/icons/Reset.png\n        :height: 24px\n\n    '''\n\n    pass\n\nclass TapTool(Tap, SelectTool):\n    ''' *toolbar icon*: |tap_icon|\n\n    The tap selection tool allows the user to select at single points by\n    left-clicking a mouse, or tapping with a finger.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. |tap_icon| image:: /_images/icons/Tap.png\n        :height: 24px\n\n    .. note::\n        Selections can be comprised of multiple regions, even those\n        made by different selection tools. Hold down the <<shift>> key\n        while making a selection to append the new selection to any\n        previous selection that might exist.\n\n    '''\n\n    behavior = Enum(\"select\", \"inspect\", default=\"select\", help=\"\"\"\n    This tool can be configured to either make selections or inspections\n    on associated data sources. The difference is that selection changes\n    propagate across bokeh and other components (e.g. selection glyph)\n    will be notified. Inspections don't act like this, so it's useful to\n    configure `callback` when setting `behavior='inspect'`.\n    \"\"\")\n\n    gesture = Enum(\"tap\", \"doubletap\", default=\"tap\", help=\"\"\"\n    Specifies which kind of gesture will be used to trigger the tool,\n    either a single or double tap.\n    \"\"\")\n\n    callback = Instance(Callback, help=\"\"\"\n    A callback to execute *whenever a glyph is \"hit\"* by a mouse click\n    or tap.\n\n    This is often useful with the  :class:`~bokeh.models.callbacks.OpenURL`\n    model to open URLs based on a user clicking or tapping a specific glyph.\n\n    However, it may also be a :class:`~bokeh.models.callbacks.CustomJS`\n    which can execute arbitrary JavaScript code in response to clicking or\n    tapping glyphs. The callback will be executed for each individual glyph\n    that is it hit by a click or tap, and will receive the ``TapTool`` model\n    as  ``cb_obj``. The optional ``cb_data`` will have the data source as\n    its ``.source`` attribute and the selection geometry as its\n    ``.geometries`` attribute.\n\n    The ``.geometries`` attribute has 5 members.\n    ``.type`` is the geometry type, which always a ``.point`` for a tap event.\n    ``.sx`` and ``.sy`` are the screen X and Y coordinates where the tap occurred.\n    ``.x`` and ``.y`` are the converted data coordinates for the item that has\n    been selected. The ``.x`` and ``.y`` values are based on the axis assigned\n    to that glyph.\n\n    .. note::\n        This callback does *not* execute on every tap, only when a glyph is\n        \"hit\". If you would like to execute a callback on every mouse tap,\n        please see :ref:`userguide_interaction_jscallbacks_customjs_interactions`.\n\n    \"\"\")\n\nclass CrosshairTool(InspectTool):\n    ''' *toolbar icon*: |crosshair_icon|\n\n    The crosshair tool is a passive inspector tool. It is generally on at all\n    times, but can be configured in the inspector's menu associated with the\n    *toolbar icon* shown above.\n\n    The crosshair tool draws a crosshair annotation over the plot, centered on\n    the current mouse position. The crosshair tool may be configured to draw\n    across only one dimension by setting the ``dimension`` property to only\n    ``width`` or ``height``.\n\n    .. |crosshair_icon| image:: /_images/icons/Crosshair.png\n        :height: 24px\n\n    '''\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the crosshair tool is to track. By default, both vertical\n    and horizontal lines will be drawn. If only \"width\" is supplied, only a\n    horizontal line will be drawn. If only \"height\" is supplied, only a\n    vertical line will be drawn.\n    \"\"\")\n\n    line_color = Color(default=\"black\", help=\"\"\"\n    A color to use to stroke paths with.\n    \"\"\")\n\n    line_alpha = Alpha(help=\"\"\"\n    An alpha value to use to stroke paths with.\n    \"\"\")\n\n    line_width = Float(default=1, help=\"\"\"\n    Stroke width in units of pixels.\n    \"\"\")\n\nDEFAULT_BOX_OVERLAY = lambda: BoxAnnotation(\n    level=\"overlay\",\n    top_units=\"screen\",\n    left_units=\"screen\",\n    bottom_units=\"screen\",\n    right_units=\"screen\",\n    fill_color=\"lightgrey\",\n    fill_alpha=0.5,\n    line_color=\"black\",\n    line_alpha=1.0,\n    line_width=2,\n    line_dash=[4, 4],\n)\n\nclass BoxZoomTool(Drag):\n    ''' *toolbar icon*: |box_zoom_icon|\n\n    The box zoom tool allows users to define a rectangular egion of a Plot to\n    zoom to by dragging he mouse or a finger over the plot region. The end of\n    the drag event indicates the selection region is ready.\n\n    .. |box_zoom_icon| image:: /_images/icons/BoxZoom.png\n        :height: 24px\n\n    .. note::\n        ``BoxZoomTool`` is incompatible with ``GMapPlot`` due to the manner in\n        which Google Maps exert explicit control over aspect ratios. Adding\n        this tool to a ``GMapPlot`` will have no effect.\n\n    '''\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the zoom box is to be free in. By default, users may\n    freely draw zoom boxes with any dimensions. If only \"width\" is supplied,\n    the box will be constrained to span the entire vertical space of the plot,\n    only the horizontal dimension can be controlled. If only \"height\" is\n    supplied, the box will be constrained to span the entire horizontal space\n    of the plot, and the vertical dimension can be controlled.\n    \"\"\")\n\n    overlay = Instance(BoxAnnotation, default=DEFAULT_BOX_OVERLAY, help=\"\"\"\n    A shaded annotation drawn to indicate the selection region.\n    \"\"\")\n\n    match_aspect = Bool(default=False, help=\"\"\"\n    Whether the box zoom region should be restricted to have the same\n    aspect ratio as the plot region.\n\n    .. note::\n        If the tool is restricted to one dimension, this value has\n        no effect.\n\n    \"\"\")\n\n    origin = Enum(\"corner\", \"center\", default=\"corner\", help=\"\"\"\n    Indicates whether the rectangular zoom area should originate from a corner\n    (top-left or bottom-right depending on direction) or the center of the box.\n    \"\"\")\n\nclass ZoomInTool(ActionTool):\n    ''' *toolbar icon*: |zoom_in_icon|\n\n    The zoom-in tool allows users to click a button to zoom in\n    by a fixed amount.\n\n    .. |zoom_in_icon| image:: /_images/icons/ZoomIn.png\n        :height: 24px\n\n    '''\n    # TODO ZoomInTool dimensions should probably be constrained to be the same as ZoomOutTool\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the zoom-in tool is constrained to act in. By default the\n    zoom-in zoom tool will zoom in any dimension, but can be configured to only\n    zoom horizontally across the width of the plot, or vertically across the\n    height of the plot.\n    \"\"\")\n\n    factor = Percent(default=0.1, help=\"\"\"\n    Percentage to zoom for each click of the zoom-in tool.\n    \"\"\")\n\nclass ZoomOutTool(ActionTool):\n    ''' *toolbar icon*: |zoom_out_icon|\n\n    The zoom-out tool allows users to click a button to zoom out\n    by a fixed amount.\n\n    .. |zoom_out_icon| image:: /_images/icons/ZoomOut.png\n        :height: 24px\n\n    '''\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the zoom-out tool is constrained to act in. By default the\n    zoom-out tool will zoom in any dimension, but can be configured to only\n    zoom horizontally across the width of the plot, or vertically across the\n    height of the plot.\n    \"\"\")\n\n    factor = Percent(default=0.1, help=\"\"\"\n    Percentage to zoom for each click of the zoom-in tool.\n    \"\"\")\n\nclass BoxSelectTool(Drag, SelectTool):\n    ''' *toolbar icon*: |box_select_icon|\n\n    The box selection tool allows users to make selections on a Plot by showing\n    a rectangular region by dragging the mouse or a finger over the plot area.\n    The end of the drag event indicates the selection region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n\n    .. |box_select_icon| image:: /_images/icons/BoxSelect.png\n        :height: 24px\n\n    '''\n\n    select_every_mousemove = Bool(False, help=\"\"\"\n    Whether a selection computation should happen on every mouse event, or only\n    once, when the selection region is completed. Default: False\n    \"\"\")\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the box selection is to be free in. By default, users may\n    freely draw selections boxes with any dimensions. If only \"width\" is set,\n    the box will be constrained to span the entire vertical space of the plot,\n    only the horizontal dimension can be controlled. If only \"height\" is set,\n    the box will be constrained to span the entire horizontal space of the\n    plot, and the vertical dimension can be controlled.\n    \"\"\")\n\n    overlay = Instance(BoxAnnotation, default=DEFAULT_BOX_OVERLAY, help=\"\"\"\n    A shaded annotation drawn to indicate the selection region.\n    \"\"\")\n\n    origin = Enum(\"corner\", \"center\", default=\"corner\", help=\"\"\"\n    Indicates whether the rectangular selection area should originate from a corner\n    (top-left or bottom-right depending on direction) or the center of the box.\n    \"\"\")\n\nDEFAULT_POLY_OVERLAY = lambda: PolyAnnotation(\n    level=\"overlay\",\n    xs_units=\"screen\",\n    ys_units=\"screen\",\n    fill_color=\"lightgrey\",\n    fill_alpha=0.5,\n    line_color=\"black\",\n    line_alpha=1.0,\n    line_width=2,\n    line_dash=[4, 4]\n)\n\nclass LassoSelectTool(Drag, SelectTool):\n    ''' *toolbar icon*: |lasso_select_icon|\n\n    The lasso selection tool allows users to make selections on a Plot by\n    indicating a free-drawn \"lasso\" region by dragging the mouse or a finger\n    over the plot region. The end of the drag event indicates the selection\n    region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. note::\n        Selections can be comprised of multiple regions, even those made by\n        different selection tools. Hold down the <<shift>> key while making a\n        selection to append the new selection to any previous selection that\n        might exist.\n\n    .. |lasso_select_icon| image:: /_images/icons/LassoSelect.png\n        :height: 24px\n\n    '''\n\n    select_every_mousemove = Bool(True, help=\"\"\"\n    Whether a selection computation should happen on every mouse event, or only\n    once, when the selection region is completed.\n    \"\"\")\n\n    overlay = Instance(PolyAnnotation, default=DEFAULT_POLY_OVERLAY, help=\"\"\"\n    A shaded annotation drawn to indicate the selection region.\n    \"\"\")\n\nclass PolySelectTool(Tap, SelectTool):\n    ''' *toolbar icon*: |poly_select_icon|\n\n    The polygon selection tool allows users to make selections on a\n    Plot by indicating a polygonal region with mouse clicks. single\n    clicks (or taps) add successive points to the definition of the\n    polygon, and a double click (or tap) indicates the selection\n    region is ready.\n\n    See :ref:`userguide_styling_selected_unselected_glyphs` for information\n    on styling selected and unselected glyphs.\n\n    .. note::\n        Selections can be comprised of multiple regions, even those\n        made by different selection tools. Hold down the <<shift>> key\n        while making a selection to append the new selection to any\n        previous selection that might exist.\n\n    .. |poly_select_icon| image:: /_images/icons/PolygonSelect.png\n        :height: 24px\n\n    '''\n\n    overlay = Instance(PolyAnnotation, default=DEFAULT_POLY_OVERLAY, help=\"\"\"\n    A shaded annotation drawn to indicate the selection region.\n    \"\"\")\n\nclass CustomJSHover(Model):\n    ''' Define a custom formatter to apply to a hover tool field.\n\n    This model can be configured with JavaScript code to format hover tooltips.\n    The JavaScript code has access to the current value to format, some special\n    variables, and any format configured on the tooltip. The variable ``value``\n    will contain the untransformed value. The variable ``special_vars`` will\n    provide a dict with the following contents:\n\n    * ``x`` data-space x-coordinate of the mouse\n    * ``y`` data-space y-coordinate of the mouse\n    * ``sx`` screen-space x-coordinate of the mouse\n    * ``sy`` screen-space y-coordinate of the mouse\n    * ``data_x`` data-space x-coordinate of the hovered glyph\n    * ``data_y`` data-space y-coordinate of the hovered glyph\n    * ``indices`` column indices of all currently hovered glyphs\n    * ``name`` value of the ``name`` property of the hovered glyph renderer\n\n    If the hover is over a \"multi\" glyph such as ``Patches`` or ``MultiLine``\n    then a ``segment_index`` key will also be present.\n\n    Finally, the value of the format passed in the tooltip specification is\n    available as the ``format`` variable.\n\n    Example:\n\n        As an example, the following code adds a custom formatter to format\n        WebMercator northing coordinates (in meters) as a latitude:\n\n        .. code-block:: python\n\n            lat_custom = CustomJSHover(code=\"\"\"\n                var projections = Bokeh.require(\"core/util/projections\");\n                var x = special_vars.x\n                var y = special_vars.y\n                var coords = projections.wgs84_mercator.invert(x, y)\n                return \"\" + coords[1]\n            \"\"\")\n\n            p.add_tools(HoverTool(\n                tooltips=[( 'lat','@y{custom}' )],\n                formatters={'@y':lat_custom}\n            ))\n\n    .. warning::\n        The explicit purpose of this Bokeh Model is to embed *raw JavaScript\n        code* for a browser to execute. If any part of the code is derived\n        from untrusted user inputs, then you must take appropriate care to\n        sanitize the user input prior to passing to Bokeh.\n\n    '''\n\n    args = Dict(String, Instance(Model), help=\"\"\"\n    A mapping of names to Bokeh plot objects. These objects are made available\n    to the callback code snippet as the values of named parameters to the\n    callback.\n    \"\"\")\n\n    code = String(default=\"\", help=\"\"\"\n    A snippet of JavaScript code to transform a single value. The variable\n    ``value`` will contain the untransformed value and can be expected to be\n    present in the function namespace at render time. Additionally, the\n    variable ``special_vars`` will be available, and will provide a dict\n    with the following contents:\n\n    * ``x`` data-space x-coordinate of the mouse\n    * ``y`` data-space y-coordinate of the mouse\n    * ``sx`` screen-space x-coordinate of the mouse\n    * ``sy`` screen-space y-coordinate of the mouse\n    * ``data_x`` data-space x-coordinate of the hovered glyph\n    * ``data_y`` data-space y-coordinate of the hovered glyph\n    * ``indices`` column indices of all currently hovered glyphs\n\n    If the hover is over a \"multi\" glyph such as ``Patches`` or ``MultiLine``\n    then a ``segment_index`` key will also be present.\n\n    Finally, the value of the format passed in the tooltip specification is\n    available as the ``format`` variable.\n\n    The snippet will be made into the body of a function and therefore requires\n    a return statement.\n\n    Example:\n\n        .. code-block:: javascript\n\n            code = '''\n            return value + \" total\"\n            '''\n    \"\"\")\n\nclass HoverTool(InspectTool):\n    ''' *toolbar icon*: |hover_icon|\n\n    The hover tool is a passive inspector tool. It is generally on at all\n    times, but can be configured in the inspector's menu associated with the\n    *toolbar icon* shown above.\n\n    By default, the hover tool displays informational tooltips whenever the\n    cursor is directly over a glyph. The data to show comes from the glyph's\n    data source, and what to display is configurable with the ``tooltips``\n    property that maps display names to columns in the data source, or to\n    special known variables.\n\n    Here is an example of how to configure and use the hover tool::\n\n        # Add tooltip (name, field) pairs to the tool. See below for a\n        # description of possible field values.\n        hover.tooltips = [\n            (\"index\", \"$index\"),\n            (\"(x,y)\", \"($x, $y)\"),\n            (\"radius\", \"@radius\"),\n            (\"fill color\", \"$color[hex, swatch]:fill_color\"),\n            (\"fill color\", \"$color[hex]:fill_color\"),\n            (\"fill color\", \"$color:fill_color\"),\n            (\"fill color\", \"$swatch:fill_color\"),\n            (\"foo\", \"@foo\"),\n            (\"bar\", \"@bar\"),\n            (\"baz\", \"@baz{safe}\"),\n            (\"total\", \"@total{$0,0.00}\"\n        ]\n\n    You can also supply a ``Callback`` to the ``HoverTool``, to build custom\n    interactions on hover. In this case you may want to turn the tooltips\n    off by setting ``tooltips=None``.\n\n    .. warning::\n        When supplying a callback or custom template, the explicit intent\n        of this Bokeh Model is to embed *raw HTML and  JavaScript code* for\n        a browser to execute. If any part of the code is derived from untrusted\n        user inputs, then you must take appropriate care to sanitize the user\n        input prior to passing to Bokeh.\n\n    Hover tool does not currently work with the following glyphs:\n\n        .. hlist::\n            :columns: 3\n\n            * annulus\n            * arc\n            * bezier\n            * image_url\n            * oval\n            * patch\n            * quadratic\n            * ray\n            * step\n            * text\n\n    .. |hover_icon| image:: /_images/icons/Hover.png\n        :height: 24px\n\n    '''\n\n    names = List(String, help=\"\"\"\n    A list of names to query for. If set, only renderers that have a matching\n    value for their ``name`` attribute will be used.\n\n    .. note:\n        This property is deprecated and will be removed in bokeh 3.0.\n\n    \"\"\")\n\n    renderers = Either(Auto, List(Instance(DataRenderer)), default=\"auto\", help=\"\"\"\n    An explicit list of renderers to hit test against. If unset, defaults to\n    all renderers on a plot.\n    \"\"\")\n\n    callback = Instance(Callback, help=\"\"\"\n    A callback to run in the browser whenever the input's value changes. The\n    ``cb_data`` parameter that is available to the Callback code will contain two\n    ``HoverTool`` specific fields:\n\n    :index: object containing the indices of the hovered points in the data source\n    :geometry: object containing the coordinates of the hover cursor\n    \"\"\")\n\n    tooltips = Either(String, List(Tuple(String, String)),\n            default=[\n                (\"index\",\"$index\"),\n                (\"data (x, y)\",\"($x, $y)\"),\n                (\"screen (x, y)\",\"($sx, $sy)\"),\n            ], help=\"\"\"\n    The (name, field) pairs describing what the hover tool should\n    display when there is a hit.\n\n    Field names starting with \"@\" are interpreted as columns on the\n    data source. For instance, \"@temp\" would look up values to display\n    from the \"temp\" column of the data source.\n\n    Field names starting with \"$\" are special, known fields:\n\n    :$index: index of hovered point in the data source\n    :$name: value of the ``name`` property of the hovered glyph renderer\n    :$x: x-coordinate under the cursor in data space\n    :$y: y-coordinate under the cursor in data space\n    :$sx: x-coordinate under the cursor in screen (canvas) space\n    :$sy: y-coordinate under the cursor in screen (canvas) space\n    :$color: color data from data source, with the syntax:\n        ``$color[options]:field_name``. The available options\n        are: ``hex`` (to display the color as a hex value), ``swatch``\n        (color data from data source displayed as a small color box)\n    :$swatch: color data from data source displayed as a small color box\n\n    Field names that begin with ``@`` are associated with columns in a\n    ``ColumnDataSource``. For instance the field name ``\"@price\"`` will\n    display values from the ``\"price\"`` column whenever a hover is triggered.\n    If the hover is for the 17th glyph, then the hover tooltip will\n    correspondingly display the 17th price value.\n\n    Note that if a column name contains spaces, the it must be supplied by\n    surrounding it in curly braces, e.g. ``@{adjusted close}`` will display\n    values from a column named ``\"adjusted close\"``.\n\n    Sometimes (especially with stacked charts) it is desirable to allow the\n    name of the column be specified indirectly. The field name ``@$name`` is\n    distinguished in that it will look up the ``name`` field on the hovered\n    glyph renderer, and use that value as the column name. For instance, if\n    a user hovers with the name ``\"US East\"``, then ``@$name`` is equivalent to\n    ``@{US East}``.\n\n    By default, values for fields (e.g. ``@foo``) are displayed in a basic\n    numeric format. However it is possible to control the formatting of values\n    more precisely. Fields can be modified by appending a format specified to\n    the end in curly braces. Some examples are below.\n\n    .. code-block:: python\n\n        \"@foo{0,0.000}\"    # formats 10000.1234 as: 10,000.123\n\n        \"@foo{(.00)}\"      # formats -10000.1234 as: (10000.123)\n\n        \"@foo{($ 0.00 a)}\" # formats 1230974 as: $ 1.23 m\n\n    Specifying a format ``{safe}`` after a field name will override automatic\n    escaping of the tooltip data source. Any HTML tags in the data tags will\n    be rendered as HTML in the resulting HoverTool output. See\n    :ref:`custom_hover_tooltip` for a more detailed example.\n\n    ``None`` is also a valid value for tooltips. This turns off the\n    rendering of tooltips. This is mostly useful when supplying other\n    actions on hover via the callback property.\n\n    .. note::\n        The tooltips attribute can also be configured with a mapping type,\n        e.g. ``dict`` or ``OrderedDict``. However, if a ``dict`` is used,\n        the visual presentation order is unspecified.\n\n    \"\"\").accepts(Dict(String, String), lambda d: list(d.items()))\n\n    formatters = Dict(String, Either(Enum(TooltipFieldFormatter), Instance(CustomJSHover)), default=lambda: dict(), help=\"\"\"\n    Specify the formatting scheme for data source columns, e.g.\n\n    .. code-block:: python\n\n        tool.formatters = {\"@date\": \"datetime\"}\n\n    will cause format specifications for the \"date\" column to be interpreted\n    according to the \"datetime\" formatting scheme. The following schemes are\n    available:\n\n    :``\"numeral\"``:\n        Provides a wide variety of formats for numbers, currency, bytes, times,\n        and percentages. The full set of formats can be found in the\n        |NumeralTickFormatter| reference documentation.\n\n    :``\"datetime\"``:\n        Provides formats for date and time values. The full set of formats is\n        listed in the |DatetimeTickFormatter| reference documentation.\n\n    :``\"printf\"``:\n        Provides formats similar to C-style \"printf\" type specifiers. See the\n        |PrintfTickFormatter| reference documentation for complete details.\n\n    If no formatter is specified for a column name, the default ``\"numeral\"``\n    formatter is assumed.\n\n    .. |NumeralTickFormatter| replace:: :class:`~bokeh.models.formatters.NumeralTickFormatter`\n    .. |DatetimeTickFormatter| replace:: :class:`~bokeh.models.formatters.DatetimeTickFormatter`\n    .. |PrintfTickFormatter| replace:: :class:`~bokeh.models.formatters.PrintfTickFormatter`\n\n    \"\"\")\n\n    mode = Enum(\"mouse\", \"hline\", \"vline\", help=\"\"\"\n    Whether to consider hover pointer as a point (x/y values), or a\n    span on h or v directions.\n    \"\"\")\n\n    muted_policy = Enum(\"show\", \"ignore\",\n                        default=\"show\", help=\"\"\"\n    Whether to avoid showing tooltips on muted glyphs.\n    \"\"\")\n\n    point_policy = Enum(\"snap_to_data\", \"follow_mouse\", \"none\", help=\"\"\"\n    Whether the tooltip position should snap to the \"center\" (or other anchor)\n    position of the associated glyph, or always follow the current mouse cursor\n    position.\n    \"\"\")\n\n    line_policy = Enum(\"prev\", \"next\", \"nearest\", \"interp\", \"none\",\n                       default=\"nearest\", help=\"\"\"\n    When showing tooltips for lines, designates whether the tooltip position\n    should be the \"previous\" or \"next\" points on the line, the \"nearest\" point\n    to the current mouse position, or \"interpolate\" along the line to the\n    current mouse position.\n    \"\"\")\n\n    anchor = Enum(Anchor, default=\"center\", help=\"\"\"\n    If point policy is set to `\"snap_to_data\"`, `anchor` defines the attachment\n    point of a tooltip. The default is to attach to the center of a glyph.\n    \"\"\")\n\n    attachment = Enum(TooltipAttachment, help=\"\"\"\n    Whether the tooltip should be displayed to the left or right of the cursor\n    position or above or below it, or if it should be automatically placed\n    in the horizontal or vertical dimension.\n    \"\"\")\n\n    show_arrow = Bool(default=True, help=\"\"\"\n    Whether tooltip's arrow should be shown.\n    \"\"\")\n\nDEFAULT_HELP_TIP = \"Click the question mark to learn more about Bokeh plot tools.\"\nDEFAULT_HELP_URL = \"https://docs.bokeh.org/en/latest/docs/user_guide/tools.html\"\n\nclass HelpTool(ActionTool):\n    ''' A button tool to provide a \"help\" link to users.\n\n    The hover text can be customized through the ``help_tooltip`` attribute\n    and the redirect site overridden as well.\n\n    '''\n\n    def __init__(self, *args, **kwargs):\n        help_tooltip = kwargs.pop(\"help_tooltip\", None)\n        if help_tooltip is not None:\n            deprecated((2, 3, 0), \"HelpTool.help_tooltip\", \"HelpTool.description\")\n            kwargs[\"description\"] = help_tooltip\n        super().__init__(*args, **kwargs)\n\n    @property\n    def help_tooltip(self):\n        deprecated((2, 3, 0), \"HelpTool.help_tooltip\", \"HelpTool.description\")\n        return self.description\n    @help_tooltip.setter\n    def help_tooltip(self, description):\n        deprecated((2, 3, 0), \"HelpTool.help_tooltip\", \"HelpTool.description\")\n        self.description = description\n\n    description = Override(default=DEFAULT_HELP_TIP)\n\n    redirect = String(default=DEFAULT_HELP_URL, help=\"\"\"\n    Site to be redirected through upon click.\n    \"\"\")\n\nclass UndoTool(ActionTool):\n    ''' *toolbar icon*: |undo_icon|\n\n    Undo tool allows to restore previous state of the plot.\n\n    .. |undo_icon| image:: /_images/icons/Undo.png\n        :height: 24px\n\n    '''\n\nclass RedoTool(ActionTool):\n    ''' *toolbar icon*: |redo_icon|\n\n    Redo tool reverses the last action performed by undo tool.\n\n    .. |redo_icon| image:: /_images/icons/Redo.png\n        :height: 24px\n\n    '''\n\n@abstract\nclass EditTool(GestureTool):\n    ''' A base class for all interactive draw tool types.\n\n    '''\n\n    def __init__(self, *args, **kwargs):\n        custom_tooltip = kwargs.pop(\"custom_tooltip\", None)\n        if custom_tooltip is not None:\n            deprecated((2, 3, 0), \"EditTool.custom_tooltip\", \"EditTool.description\")\n            kwargs[\"description\"] = custom_tooltip\n        super().__init__(*args, **kwargs)\n\n    @property\n    def custom_tooltip(self):\n        deprecated((2, 3, 0), \"EditTool.custom_tooltip\", \"EditTool.description\")\n        return self.description\n    @custom_tooltip.setter\n    def custom_tooltip(self, description):\n        deprecated((2, 3, 0), \"EditTool.custom_tooltip\", \"EditTool.description\")\n        self.description = description\n\n    empty_value = Either(Bool, Int, Float, Date, Datetime, Color, String, help=\"\"\"\n    Defines the value to insert on non-coordinate columns when a new\n    glyph is inserted into the ``ColumnDataSource`` columns, e.g. when a\n    circle glyph defines 'x', 'y' and 'color' columns, adding a new\n    point will add the x and y-coordinates to 'x' and 'y' columns and\n    the color column will be filled with the defined empty value.\n    \"\"\")\n\n    custom_icon = Image(help=\"\"\"\n    An icon to display in the toolbar.\n\n    The icon can provided as a string filename for an image, a PIL ``Image``\n    object, or an RGB(A) NumPy array.\n    \"\"\")\n\n    renderers = List(Instance(GlyphRenderer), help=\"\"\"\n    An explicit list of renderers corresponding to scatter glyphs that may\n    be edited.\n    \"\"\")\n\n@abstract\nclass PolyTool(EditTool):\n    ''' A base class for polygon draw/edit tools. '''\n\n    vertex_renderer = Instance(GlyphRenderer, help=\"\"\"\n    The renderer used to render the vertices of a selected line or polygon.\n    \"\"\")\n\n    @error(INCOMPATIBLE_POLY_EDIT_VERTEX_RENDERER)\n    def _check_compatible_vertex_renderer(self):\n        if self.vertex_renderer is None:\n            return\n        glyph = self.vertex_renderer.glyph\n        if not isinstance(glyph, XYGlyph):\n            return \"glyph type %s found.\" % type(glyph).__name__\n\nclass BoxEditTool(EditTool, Drag, Tap):\n    ''' *toolbar icon*: |box_edit_icon|\n\n    Allows drawing, dragging and deleting ``Rect`` glyphs on one or more\n    renderers by editing the underlying ``ColumnDataSource`` data. Like other\n    drawing tools, the renderers that are to be edited must be supplied\n    explicitly as a list. When drawing a new box the data will always be added\n    to the ``ColumnDataSource`` on the first supplied renderer.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x``, ``y``, ``width`` and ``height`` values of the glyph. Any additional\n    columns in the data source will be padded with ``empty_value``, when adding\n    a new box.\n\n    The supported actions include:\n\n    * Add box: Hold shift then click and drag anywhere on the plot or double\n      tap once to start drawing, move the mouse and double tap again to finish\n      drawing.\n\n    * Move box: Click and drag an existing box, the box will be dropped once\n      you let go of the mouse button.\n\n    * Delete box: Tap a box to select it then press <<backspace>> key while the\n      mouse is within the plot area.\n\n    To **Move** or **Delete** multiple boxes at once:\n\n    * Move selection: Select box(es) with <<shift>>+tap (or another selection\n      tool) then drag anywhere on the plot. Selecting and then dragging on a\n      specific box will move both.\n\n    * Delete selection: Select box(es) with <<shift>>+tap (or another selection\n      tool) then press <<backspace>> while the mouse is within the plot area.\n\n    .. |box_edit_icon| image:: /_images/icons/BoxEdit.png\n        :height: 24px\n    '''\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions the box drawing is to be free in. By default, users may\n    freely draw boxes with any dimensions. If only \"width\" is set, the box will\n    be constrained to span the entire vertical space of the plot, only the\n    horizontal dimension can be controlled. If only \"height\" is set, the box\n    will be constrained to span the entire horizontal space of the plot, and the\n    vertical dimension can be controlled.\n    \"\"\")\n\n    num_objects = Int(default=0, help=\"\"\"\n    Defines a limit on the number of boxes that can be drawn. By default there\n    is no limit on the number of objects, but if enabled the oldest drawn box\n    will be dropped to make space for the new box being added.\n    \"\"\")\n\n    @error(INCOMPATIBLE_BOX_EDIT_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, Rect):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__ for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\nclass PointDrawTool(EditTool, Drag, Tap):\n    ''' *toolbar icon*: |point_draw_icon|\n\n    The PointDrawTool allows adding, dragging and deleting point-like glyphs\n    (i.e subclasses of``XYGlyph``) on one or more renderers by editing the\n    underlying ``ColumnDataSource`` data. Like other drawing tools, the\n    renderers that are to be edited must be supplied explicitly as a list. Any\n    newly added points will be inserted on the ``ColumnDataSource`` of the\n    first supplied renderer.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x`` and ``y`` values of the glyph. Any additional columns in the data\n    source will be padded with the given ``empty_value`` when adding a new\n    point.\n\n    .. note::\n        The data source updates will trigger data change events continuously\n        throughout the edit operations on the BokehJS side. In Bokeh server\n        apps, the data source will only be synced once, when the edit operation\n        finishes.\n\n    The supported actions include:\n\n    * Add point: Tap anywhere on the plot\n\n    * Move point: Tap and drag an existing point, the point will be\n      dropped once you let go of the mouse button.\n\n    * Delete point: Tap a point to select it then press <<backspace>>\n      key while the mouse is within the plot area.\n\n    .. |point_draw_icon| image:: /_images/icons/PointDraw.png\n        :height: 24px\n    '''\n\n    add = Bool(default=True, help=\"\"\"\n    Enables adding of new points on tap events.\n    \"\"\")\n\n    drag = Bool(default=True, help=\"\"\"\n    Enables dragging of existing points on pan events.\n    \"\"\")\n\n    num_objects = Int(default=0, help=\"\"\"\n    Defines a limit on the number of points that can be drawn. By default there\n    is no limit on the number of objects, but if enabled the oldest drawn point\n    will be dropped to make space for the new point.\n    \"\"\")\n\n    @error(INCOMPATIBLE_POINT_DRAW_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, XYGlyph):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__ for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\nclass PolyDrawTool(PolyTool, Drag, Tap):\n    ''' *toolbar icon*: |poly_draw_icon|\n\n    The PolyDrawTool allows drawing, selecting and deleting ``Patches`` and\n    ``MultiLine`` glyphs on one or more renderers by editing the underlying\n    ``ColumnDataSource`` data. Like other drawing tools, the renderers that\n    are to be edited must be supplied explicitly.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared ``empty_value``, when adding a new\n    point.\n\n    If a ``vertex_renderer`` with an point-like glyph is supplied then the\n    ``PolyDrawTool`` will use it to display the vertices of the multi-lines or\n    patches on all supplied renderers. This also enables the ability to snap\n    to existing vertices while drawing.\n\n    The supported actions include:\n\n    * Add patch or multi-line: Double tap to add the first vertex, then use tap\n      to add each subsequent vertex, to finalize the draw action double tap to\n      insert the final vertex or press the <<esc> key.\n\n    * Move patch or ulti-line: Tap and drag an existing patch/multi-line, the\n      point will be dropped once you let go of the mouse button.\n\n    * Delete patch or multi-line: Tap a patch/multi-line to select it then\n      press <<backspace>> key while the mouse is within the plot area.\n\n    .. |poly_draw_icon| image:: /_images/icons/PolyDraw.png\n        :height: 24px\n    '''\n\n    drag = Bool(default=True, help=\"\"\"\n    Enables dragging of existing patches and multi-lines on pan events.\n    \"\"\")\n\n    num_objects = Int(default=0, help=\"\"\"\n    Defines a limit on the number of patches or multi-lines that can be drawn.\n    By default there is no limit on the number of objects, but if enabled the\n    oldest drawn patch or multi-line will be dropped to make space for the new\n    patch or multi-line.\n    \"\"\")\n\n    @error(INCOMPATIBLE_POLY_DRAW_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, (MultiLine, Patches)):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__ for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\nclass FreehandDrawTool(EditTool, Drag, Tap):\n    ''' *toolbar icon*: |freehand_draw_icon|\n\n    Allows freehand drawing of ``Patches`` and ``MultiLine`` glyphs. The glyph\n    to draw may be defined via the ``renderers`` property.\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared ``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Draw vertices: Click and drag to draw a line\n\n    * Delete patch/multi-line: Tap a patch/multi-line to select it then press\n      <<backspace>> key while the mouse is within the plot area.\n\n    .. |freehand_draw_icon| image:: /_images/icons/FreehandDraw.png\n        :height: 24px\n    '''\n\n    num_objects = Int(default=0, help=\"\"\"\n    Defines a limit on the number of patches or multi-lines that can be drawn.\n    By default there is no limit on the number of objects, but if enabled the\n    oldest drawn patch or multi-line will be overwritten when the limit is\n    reached.\n    \"\"\")\n\n    @error(INCOMPATIBLE_POLY_DRAW_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, (MultiLine, Patches)):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__ for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\nclass PolyEditTool(PolyTool, Drag, Tap):\n    ''' *toolbar icon*: |poly_edit_icon|\n\n    The PolyEditTool allows editing the vertices of one or more ``Patches`` or\n    ``MultiLine`` glyphs. Glyphs to be edited are defined via the ``renderers``\n    property and a renderer for the vertices is set via the ``vertex_renderer``\n    property (must render a point-like Glyph (a subclass of ``XYGlyph``).\n\n    The tool will modify the columns on the data source corresponding to the\n    ``xs`` and ``ys`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Show vertices: Double tap an existing patch or multi-line\n\n    * Add vertex: Double tap an existing vertex to select it, the tool will\n      draw the next point, to add it tap in a new location. To finish editing\n      and add a point double tap otherwise press the <<esc> key to cancel.\n\n    * Move vertex: Drag an existing vertex and let go of the mouse button to\n      release it.\n\n    * Delete vertex: After selecting one or more vertices press <<backspace>>\n      while the mouse cursor is within the plot area.\n\n    .. |poly_edit_icon| image:: /_images/icons/PolyEdit.png\n        :height: 24px\n    '''\n\n    @error(INCOMPATIBLE_POLY_EDIT_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, (MultiLine, Patches)):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__\n                                    for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\n\nclass LineEditTool(EditTool, Drag, Tap):\n    ''' *toolbar icon*: |line_edit_icon|\n\n    The LineEditTool allows editing the intersection points of one or more ``Line`` glyphs.\n    Glyphs to be edited are defined via the ``renderers``\n    property and a renderer for the intersections is set via the ``intersection_renderer``\n    property (must render a point-like Glyph (a subclass of ``XYGlyph``).\n\n    The tool will modify the columns on the data source corresponding to the\n    ``x`` and ``y`` values of the glyph. Any additional columns in the data\n    source will be padded with the declared``empty_value``, when adding a new\n    point.\n\n    The supported actions include:\n\n    * Show intersections: Double tap an existing line\n\n    * Move point: Drag an existing point and let go of the mouse button to\n      release it.\n\n    .. |line_edit_icon| image:: /_images/icons/LineEdit.png\n        :height: 24px\n     '''\n\n    intersection_renderer = Instance(GlyphRenderer, help=\"\"\"\n    The renderer used to render the intersections of a selected line\n    \"\"\")\n\n    dimensions = Enum(Dimensions, default=\"both\", help=\"\"\"\n    Which dimensions this edit tool is constrained to act in. By default\n    the line edit tool allows moving points in any dimension, but can be\n    configured to only allow horizontal movement across the width of the\n    plot, or vertical across the height of the plot.\n    \"\"\")\n\n    @error(INCOMPATIBLE_LINE_EDIT_INTERSECTION_RENDERER)\n    def _check_compatible_intersection_renderer(self):\n        glyph = self.intersection_renderer.glyph\n        if not isinstance(glyph, LineGlyph):\n            return \"glyph type %s found.\" % type(glyph).__name__\n\n    @error(INCOMPATIBLE_LINE_EDIT_RENDERER)\n    def _check_compatible_renderers(self):\n        incompatible_renderers = []\n        for renderer in self.renderers:\n            if not isinstance(renderer.glyph, (Line,)):\n                incompatible_renderers.append(renderer)\n        if incompatible_renderers:\n            glyph_types = ', '.join(type(renderer.glyph).__name__\n                                    for renderer in incompatible_renderers)\n            return \"%s glyph type(s) found.\" % glyph_types\n\n#\n#-----------------------------------------------------------------------------\n# Dev API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Private API\n#-----------------------------------------------------------------------------\n\n#-----------------------------------------------------------------------------\n# Code\n#-----------------------------------------------------------------------------\n\nTool.register_alias(\"pan\", lambda: PanTool(dimensions=\"both\"))\nTool.register_alias(\"xpan\", lambda: PanTool(dimensions=\"width\"))\nTool.register_alias(\"ypan\", lambda: PanTool(dimensions=\"height\"))\nTool.register_alias(\"xwheel_pan\", lambda: WheelPanTool(dimension=\"width\"))\nTool.register_alias(\"ywheel_pan\", lambda: WheelPanTool(dimension=\"height\"))\nTool.register_alias(\"wheel_zoom\", lambda: WheelZoomTool(dimensions=\"both\"))\nTool.register_alias(\"xwheel_zoom\", lambda: WheelZoomTool(dimensions=\"width\"))\nTool.register_alias(\"ywheel_zoom\", lambda: WheelZoomTool(dimensions=\"height\"))\nTool.register_alias(\"zoom_in\", lambda: ZoomInTool(dimensions=\"both\"))\nTool.register_alias(\"xzoom_in\", lambda: ZoomInTool(dimensions=\"width\"))\nTool.register_alias(\"yzoom_in\", lambda: ZoomInTool(dimensions=\"height\"))\nTool.register_alias(\"zoom_out\", lambda: ZoomOutTool(dimensions=\"both\"))\nTool.register_alias(\"xzoom_out\", lambda: ZoomOutTool(dimensions=\"width\"))\nTool.register_alias(\"yzoom_out\", lambda: ZoomOutTool(dimensions=\"height\"))\nTool.register_alias(\"click\", lambda: TapTool(behavior=\"inspect\"))\nTool.register_alias(\"tap\", lambda: TapTool())\nTool.register_alias(\"doubletap\", lambda: TapTool(gesture=\"doubletap\"))\nTool.register_alias(\"crosshair\", lambda: CrosshairTool())\nTool.register_alias(\"box_select\", lambda: BoxSelectTool())\nTool.register_alias(\"xbox_select\", lambda: BoxSelectTool(dimensions=\"width\"))\nTool.register_alias(\"ybox_select\", lambda: BoxSelectTool(dimensions=\"height\"))\nTool.register_alias(\"poly_select\", lambda: PolySelectTool())\nTool.register_alias(\"lasso_select\", lambda: LassoSelectTool())\nTool.register_alias(\"box_zoom\", lambda: BoxZoomTool(dimensions=\"both\"))\nTool.register_alias(\"xbox_zoom\", lambda: BoxZoomTool(dimensions=\"width\"))\nTool.register_alias(\"ybox_zoom\", lambda: BoxZoomTool(dimensions=\"height\"))\nTool.register_alias(\"save\", lambda: SaveTool())\nTool.register_alias(\"undo\", lambda: UndoTool())\nTool.register_alias(\"redo\", lambda: RedoTool())\nTool.register_alias(\"reset\", lambda: ResetTool())\nTool.register_alias(\"help\", lambda: HelpTool())\nTool.register_alias(\"box_edit\", lambda: BoxEditTool())\nTool.register_alias(\"line_edit\", lambda: LineEditTool())\nTool.register_alias(\"point_draw\", lambda: PointDrawTool())\nTool.register_alias(\"poly_draw\", lambda: PolyDrawTool())\nTool.register_alias(\"poly_edit\", lambda: PolyEditTool())\nTool.register_alias(\"hover\", lambda: HoverTool(tooltips=[\n    (\"index\", \"$index\"),\n    (\"data (x, y)\", \"($x, $y)\"),\n    (\"screen (x, y)\", \"($sx, $sy)\"),\n]))\n"
    },
    {
      "filename": "bokehjs/src/lib/models/tools/inspectors/hover_tool.ts",
      "content": "import {InspectTool, InspectToolView} from \"./inspect_tool\"\nimport {CustomJSHover} from \"./customjs_hover\"\nimport {CallbackLike1} from \"../../callbacks/callback\"\nimport {Tooltip, TooltipView} from \"../../annotations/tooltip\"\nimport {Renderer} from \"../../renderers/renderer\"\nimport {GlyphRenderer} from \"../../renderers/glyph_renderer\"\nimport {GraphRenderer} from \"../../renderers/graph_renderer\"\nimport {DataRenderer} from \"../../renderers/data_renderer\"\nimport {LineView} from \"../../glyphs/line\"\nimport {MultiLineView} from \"../../glyphs/multi_line\"\nimport * as hittest from \"core/hittest\"\nimport {MoveEvent} from \"core/ui_events\"\nimport {replace_placeholders, Formatters, FormatterType, Vars} from \"core/util/templating\"\nimport {div, span, display, undisplay, empty} from \"core/dom\"\nimport * as p from \"core/properties\"\nimport {NumberArray, Color} from \"core/types\"\nimport {color2hex, color2css} from \"core/util/color\"\nimport {isEmpty} from \"core/util/object\"\nimport {enumerate} from \"core/util/iterator\"\nimport {isString, isFunction, isNumber} from \"core/util/types\"\nimport {build_views, remove_views} from \"core/build_views\"\nimport {HoverMode, PointPolicy, LinePolicy, Anchor, TooltipAttachment, MutedPolicy} from \"core/enums\"\nimport {Geometry, PointGeometry, SpanGeometry, GeometryData} from \"core/geometry\"\nimport {ColumnarDataSource} from \"../../sources/columnar_data_source\"\nimport {ImageIndex, Selection} from \"../../selections/selection\"\nimport {tool_icon_hover} from \"styles/icons.css\"\nimport {Signal} from \"core/signaling\"\nimport {compute_renderers} from \"../../util\"\nimport * as styles from \"styles/tooltips.css\"\n\nexport type TooltipVars = {index: number} & Vars\n\nexport function _nearest_line_hit(i: number, geometry: Geometry,\n    sx: number, sy: number, dx: NumberArray, dy: NumberArray): [[number, number], number] {\n  const d1 = {x: dx[i], y: dy[i]}\n  const d2 = {x: dx[i+1], y: dy[i+1]}\n\n  let dist1: number\n  let dist2: number\n  if (geometry.type == \"span\") {\n    if (geometry.direction == \"h\") {\n      dist1 = Math.abs(d1.x - sx)\n      dist2 = Math.abs(d2.x - sx)\n    } else {\n      dist1 = Math.abs(d1.y - sy)\n      dist2 = Math.abs(d2.y - sy)\n    }\n  } else {\n    const s = {x: sx, y: sy}\n    dist1 = hittest.dist_2_pts(d1, s)\n    dist2 = hittest.dist_2_pts(d2, s)\n  }\n\n  if (dist1 < dist2)\n    return [[d1.x, d1.y], i]\n  else\n    return [[d2.x, d2.y], i+1]\n}\n\nexport function _line_hit(xs: NumberArray, ys: NumberArray, ind: number): [[number, number], number] {\n  return [[xs[ind], ys[ind]], ind]\n}\n\nexport class HoverToolView extends InspectToolView {\n  model: HoverTool\n\n  protected _ttviews: Map<Tooltip, TooltipView>\n  protected _ttmodels: Map<GlyphRenderer, Tooltip>\n  protected _template_el?: HTMLElement\n\n  initialize(): void {\n    super.initialize()\n    this._ttmodels = new Map()\n    this._ttviews = new Map()\n  }\n\n  async lazy_initialize(): Promise<void> {\n    await super.lazy_initialize()\n    await this._update_ttmodels()\n  }\n\n  remove(): void {\n    remove_views(this._ttviews)\n    super.remove()\n  }\n\n  connect_signals(): void {\n    super.connect_signals()\n\n    const plot_renderers = this.plot_model.properties.renderers\n    const {renderers, tooltips} = this.model.properties\n    this.on_change(tooltips, () => delete this._template_el)\n    this.on_change([plot_renderers, renderers, tooltips], async () => await this._update_ttmodels())\n  }\n\n  protected async _update_ttmodels(): Promise<void> {\n    const {_ttmodels, computed_renderers} = this\n    _ttmodels.clear()\n\n    const {tooltips} = this.model\n    if (tooltips != null) {\n      for (const r of this.computed_renderers) {\n        const tooltip = new Tooltip({\n          custom: isString(tooltips) || isFunction(tooltips),\n          attachment: this.model.attachment,\n          show_arrow: this.model.show_arrow,\n        })\n\n        if (r instanceof GlyphRenderer) {\n          _ttmodels.set(r, tooltip)\n        } else if (r instanceof GraphRenderer) {\n          _ttmodels.set(r.node_renderer, tooltip)\n          _ttmodels.set(r.edge_renderer, tooltip)\n        }\n      }\n    }\n\n    const views = await build_views(this._ttviews, [..._ttmodels.values()], {parent: this.plot_view})\n    for (const ttview of views) {\n      ttview.render()\n    }\n\n    const glyph_renderers = [...(function* () {\n      for (const r of computed_renderers) {\n        if (r instanceof GlyphRenderer)\n          yield r\n        else if (r instanceof GraphRenderer) {\n          yield r.node_renderer\n          yield r.edge_renderer\n        }\n      }\n    })()]\n\n    const slot = this._slots.get(this._update)\n    if (slot != null) {\n      const except = new Set(glyph_renderers.map((r) => r.data_source))\n      Signal.disconnect_receiver(this, slot, except)\n    }\n\n    for (const r of glyph_renderers) {\n      this.connect(r.data_source.inspect, this._update)\n    }\n  }\n\n  get computed_renderers(): DataRenderer[] {\n    const {renderers, names} = this.model\n    const all_renderers = this.plot_model.data_renderers\n    return compute_renderers(renderers, all_renderers, names)\n  }\n\n  get ttmodels(): Map<GlyphRenderer, Tooltip> {\n    return this._ttmodels\n  }\n\n  _clear(): void {\n    this._inspect(Infinity, Infinity)\n\n    for (const [, tooltip] of this.ttmodels) {\n      tooltip.clear()\n    }\n  }\n\n  _move(ev: MoveEvent): void {\n    if (!this.model.active)\n      return\n    const {sx, sy} = ev\n    if (!this.plot_view.frame.bbox.contains(sx, sy))\n      this._clear()\n    else\n      this._inspect(sx, sy)\n  }\n\n  _move_exit(): void {\n    this._clear()\n  }\n\n  _inspect(sx: number, sy: number): void {\n    let geometry: PointGeometry | SpanGeometry\n    if (this.model.mode == 'mouse')\n      geometry = {type: 'point', sx, sy}\n    else {\n      const direction = this.model.mode == 'vline' ? 'h' : 'v'\n      geometry = {type: 'span', direction, sx, sy}\n    }\n\n    for (const r of this.computed_renderers) {\n      const sm = r.get_selection_manager()\n      const rview = this.plot_view.renderer_view(r)\n      if (rview != null)\n        sm.inspect(rview, geometry)\n    }\n\n    this._emit_callback(geometry)\n  }\n\n  _update([renderer, {geometry}]: [Renderer, {geometry: Geometry}]): void {\n    if (!this.model.active)\n      return\n\n    if (!(geometry.type == \"point\" || geometry.type == \"span\"))\n      return\n\n    if (!(renderer instanceof GlyphRenderer)) // || renderer instanceof GraphRenderer))\n      return\n\n    if (this.model.muted_policy == 'ignore' && renderer.muted)\n      return\n\n    const tooltip = this.ttmodels.get(renderer)\n    if (tooltip == null)\n      return\n\n    const selection_manager = renderer.get_selection_manager()\n\n    let indices = selection_manager.inspectors.get(renderer)!\n    indices = renderer.view.convert_selection_to_subset(indices)\n\n    if (indices.is_empty()) {\n      tooltip.clear()\n      return\n    }\n\n    const ds = selection_manager.source\n    const renderer_view = this.plot_view.renderer_view(renderer)\n    if (renderer_view == null)\n      return\n\n    const {sx, sy} = geometry\n    const xscale = renderer_view.coordinates.x_scale\n    const yscale = renderer_view.coordinates.y_scale\n    const x = xscale.invert(sx)\n    const y = yscale.invert(sy)\n\n    const {glyph} = renderer_view\n\n    const tooltips: [number, number, HTMLElement | null][] = []\n\n    if (glyph instanceof LineView) {\n      for (const i of indices.line_indices) {\n        let data_x = glyph._x[i+1]\n        let data_y = glyph._y[i+1]\n        let ii = i\n\n        let rx: number\n        let ry: number\n        switch (this.model.line_policy) {\n          case \"interp\": { // and renderer.get_interpolation_hit?\n            [data_x, data_y] = glyph.get_interpolation_hit(i, geometry)\n            rx = xscale.compute(data_x)\n            ry = yscale.compute(data_y)\n            break\n          }\n          case \"prev\": {\n            [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i)\n            break\n          }\n          case \"next\": {\n            [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i+1)\n            break\n          }\n          case \"nearest\": {\n            [[rx, ry], ii] = _nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy)\n            data_x = glyph._x[ii]\n            data_y = glyph._y[ii]\n            break\n          }\n          default: {\n            [rx, ry] = [sx, sy]\n          }\n        }\n\n        const vars = {\n          index: ii,\n          x, y, sx, sy, data_x, data_y, rx, ry,\n          indices: indices.line_indices,\n          name: renderer.name,\n        }\n        tooltips.push([rx, ry, this._render_tooltips(ds, ii, vars)])\n      }\n    }\n\n    for (const struct of indices.image_indices) {\n      const vars = {\n        index: struct.index,\n        x, y, sx, sy,\n        name: renderer.name,\n      }\n      const rendered = this._render_tooltips(ds, struct, vars)\n      tooltips.push([sx, sy, rendered])\n    }\n\n    for (const i of indices.indices) {\n      // multiglyphs set additional indices, e.g. multiline_indices for different tooltips\n      if (glyph instanceof MultiLineView && !isEmpty(indices.multiline_indices)) {\n        for (const j of indices.multiline_indices[i.toString()]) { // TODO: indices.multiline_indices.get(i)\n          let data_x = glyph._xs.get(i)[j]\n          let data_y = glyph._ys.get(i)[j]\n          let jj = j\n\n          let rx: number\n          let ry: number\n          switch (this.model.line_policy) {\n            case \"interp\": { // and renderer.get_interpolation_hit?\n              [data_x, data_y] = glyph.get_interpolation_hit(i, j, geometry)\n              rx = xscale.compute(data_x)\n              ry = yscale.compute(data_y)\n              break\n            }\n            case \"prev\": {\n              [[rx, ry], jj] = _line_hit(glyph.sxs.get(i), glyph.sys.get(i), j)\n              break\n            }\n            case \"next\": {\n              [[rx, ry], jj] = _line_hit(glyph.sxs.get(i), glyph.sys.get(i), j+1)\n              break\n            }\n            case \"nearest\": {\n              [[rx, ry], jj] = _nearest_line_hit(j, geometry, sx, sy, glyph.sxs.get(i), glyph.sys.get(i))\n              data_x = glyph._xs.get(i)[jj]\n              data_y = glyph._ys.get(i)[jj]\n              break\n            }\n            default:\n              throw new Error(\"should't have happened\")\n          }\n\n          let index: number\n          if (renderer instanceof GlyphRenderer)\n            index = renderer.view.convert_indices_from_subset([i])[0]\n          else\n            index = i\n\n          const vars = {\n            index, x, y, sx, sy, data_x, data_y,\n            segment_index: jj,\n            indices: indices.multiline_indices,\n            name: renderer.name,\n          }\n          tooltips.push([rx, ry, this._render_tooltips(ds, index, vars)])\n        }\n      } else {\n        // handle non-multiglyphs\n        const data_x = (glyph as any)._x?.[i]\n        const data_y = (glyph as any)._y?.[i]\n\n        let rx: number\n        let ry: number\n        if (this.model.point_policy == 'snap_to_data') { // and renderer.glyph.sx? and renderer.glyph.sy?\n          // Pass in our screen position so we can determine which patch we're\n          // over if there are discontinuous patches.\n          let pt = glyph.get_anchor_point(this.model.anchor, i, [sx, sy])\n          if (pt == null) {\n            pt = glyph.get_anchor_point(\"center\", i, [sx, sy])\n            if (pt == null)\n              continue // TODO?\n          }\n\n          rx = pt.x\n          ry = pt.y\n        } else\n          [rx, ry] = [sx, sy]\n\n        let index: number\n        if (renderer instanceof GlyphRenderer)\n          index = renderer.view.convert_indices_from_subset([i])[0]\n        else\n          index = i\n\n        const vars = {\n          index, x, y, sx, sy, data_x, data_y,\n          indices: indices.indices,\n          name: renderer.name,\n        }\n        tooltips.push([rx, ry, this._render_tooltips(ds, index, vars)])\n      }\n    }\n\n    if (tooltips.length == 0)\n      tooltip.clear()\n    else {\n      const {content} = tooltip\n      empty(tooltip.content)\n      for (const [,, node] of tooltips) {\n        if (node != null)\n          content.appendChild(node)\n      }\n\n      const [x, y] = tooltips[tooltips.length-1]\n      tooltip.setv({position: [x, y]}, {check_eq: false}) // XXX: force update\n    }\n  }\n\n  _emit_callback(geometry: PointGeometry | SpanGeometry): void {\n    const {callback} = this.model\n    if (callback == null)\n      return\n\n    for (const renderer of this.computed_renderers) {\n      if (!(renderer instanceof GlyphRenderer))\n        continue\n\n      const glyph_renderer_view = this.plot_view.renderer_view(renderer)\n      if (glyph_renderer_view == null)\n        continue\n\n      const {x_scale, y_scale} = glyph_renderer_view.coordinates\n      const x = x_scale.invert(geometry.sx)\n      const y = y_scale.invert(geometry.sy)\n\n      const index = renderer.data_source.inspected\n\n      callback.execute(this.model, {\n        geometry: {x, y, ...geometry},\n        renderer,\n        index,\n      })\n    }\n  }\n\n  _create_template(tooltips: [string, string][]): HTMLElement {\n    const rows = div({style: {display: \"table\", borderSpacing: \"2px\"}})\n\n    for (const [label] of tooltips) {\n      const row = div({style: {display: \"table-row\"}})\n      rows.appendChild(row)\n\n      const label_cell = div({style: {display: \"table-cell\"}, class: styles.tooltip_row_label}, label.length != 0 ? `${label}: ` : \"\")\n      row.appendChild(label_cell)\n\n      const value_el = span()\n      value_el.dataset.value = \"\"\n\n      const swatch_el = span({class: styles.tooltip_color_block}, \" \")\n      swatch_el.dataset.swatch = \"\"\n      undisplay(swatch_el)\n\n      const value_cell = div({style: {display: \"table-cell\"}, class: styles.tooltip_row_value}, value_el, swatch_el)\n      row.appendChild(value_cell)\n    }\n\n    return rows\n  }\n\n  _render_template(template: HTMLElement, tooltips: [string, string][], ds: ColumnarDataSource, i: number | ImageIndex, vars: TooltipVars): HTMLElement {\n    const el = template.cloneNode(true) as HTMLElement\n\n    const value_els = el.querySelectorAll<HTMLElement>(\"[data-value]\")\n    const swatch_els = el.querySelectorAll<HTMLElement>(\"[data-swatch]\")\n\n    const color_re = /\\$color(\\[.*\\])?:(\\w*)/\n    const swatch_re = /\\$swatch:(\\w*)/\n\n    for (const [[, value], j] of enumerate(tooltips)) {\n      const swatch_match = value.match(swatch_re)\n      const color_match = value.match(color_re)\n\n      if (swatch_match != null || color_match != null) {\n        if (swatch_match != null) {\n          const [, colname] = swatch_match\n          const column = ds.get_column(colname)\n\n          if (column == null) {\n            value_els[j].textContent = `${colname} unknown`\n          } else {\n            const color = isNumber(i) ? column[i] : null\n\n            if (color != null) {\n              swatch_els[j].style.backgroundColor = color2css(color)\n              display(swatch_els[j])\n            }\n          }\n        }\n\n        if (color_match != null) {\n          const [, opts = \"\", colname] = color_match\n          const column = ds.get_column(colname) // XXX: change to columnar ds\n          if (column == null) {\n            value_els[j].textContent = `${colname} unknown`\n            continue\n          }\n          const hex = opts.indexOf(\"hex\") >= 0\n          const swatch = opts.indexOf(\"swatch\") >= 0\n          const color: Color | null = isNumber(i) ? column[i] : null\n          if (color == null) {\n            value_els[j].textContent = \"(null)\"\n            continue\n          }\n          value_els[j].textContent = hex ? color2hex(color) : color2css(color) // TODO: color2pretty\n          if (swatch) {\n            swatch_els[j].style.backgroundColor = color2css(color)\n            display(swatch_els[j])\n          }\n        }\n      } else {\n        const content = replace_placeholders(value.replace(\"$~\", \"$data_\"), ds, i, this.model.formatters, vars)\n        if (isString(content)) {\n          value_els[j].textContent = content\n        } else {\n          for (const el of content) {\n            value_els[j].appendChild(el)\n          }\n        }\n      }\n    }\n\n    return el\n  }\n\n  _render_tooltips(ds: ColumnarDataSource, i: number | ImageIndex, vars: TooltipVars): HTMLElement | null {\n    const {tooltips} = this.model\n    if (isString(tooltips)) {\n      const content = replace_placeholders({html: tooltips}, ds, i, this.model.formatters, vars)\n      return div({}, content)\n    } else if (isFunction(tooltips)) {\n      return tooltips(ds, vars)\n    } else if (tooltips != null) {\n      const template = this._template_el ?? (this._template_el = this._create_template(tooltips))\n      return this._render_template(template, tooltips, ds, i, vars)\n    } else\n      return null\n  }\n}\n\nexport namespace HoverTool {\n  export type Attrs = p.AttrsOf<Props>\n\n  export type Props = InspectTool.Props & {\n    tooltips: p.Property<null | string | [string, string][] | ((source: ColumnarDataSource, vars: TooltipVars) => HTMLElement)>\n    formatters: p.Property<Formatters>\n    renderers: p.Property<DataRenderer[] | \"auto\">\n    /** @deprecated */\n    names: p.Property<string[]>\n    mode: p.Property<HoverMode>\n    muted_policy: p.Property<MutedPolicy>\n    point_policy: p.Property<PointPolicy>\n    line_policy: p.Property<LinePolicy>\n    show_arrow: p.Property<boolean>\n    anchor: p.Property<Anchor>\n    attachment: p.Property<TooltipAttachment>\n    callback: p.Property<CallbackLike1<HoverTool, {geometry: GeometryData, renderer: Renderer, index: Selection}> | null>\n  }\n}\n\nexport interface HoverTool extends HoverTool.Attrs {}\n\nexport class HoverTool extends InspectTool {\n  properties: HoverTool.Props\n  __view_type__: HoverToolView\n\n  constructor(attrs?: Partial<HoverTool.Attrs>) {\n    super(attrs)\n  }\n\n  static init_HoverTool(): void {\n    this.prototype.default_view = HoverToolView\n\n    this.define<HoverTool.Props>(({Any, Boolean, String, Array, Tuple, Dict, Or, Ref, Function, Auto, Nullable}) => ({\n      tooltips: [ Nullable(Or(String, Array(Tuple(String, String)), Function<[ColumnarDataSource, TooltipVars], HTMLElement>())), [\n        [\"index\",         \"$index\"    ],\n        [\"data (x, y)\",   \"($x, $y)\"  ],\n        [\"screen (x, y)\", \"($sx, $sy)\"],\n      ]],\n      formatters:   [ Dict(Or(Ref(CustomJSHover), FormatterType)), {} ],\n      renderers:    [ Or(Array(Ref(DataRenderer)), Auto), \"auto\" ],\n      names:        [ Array(String), [] ],\n      mode:         [ HoverMode, \"mouse\" ],\n      muted_policy: [ MutedPolicy, \"show\" ],\n      point_policy: [ PointPolicy, \"snap_to_data\" ],\n      line_policy:  [ LinePolicy, \"nearest\" ],\n      show_arrow:   [ Boolean, true ],\n      anchor:       [ Anchor, \"center\" ],\n      attachment:   [ TooltipAttachment, \"horizontal\" ],\n      callback:     [ Nullable(Any /*TODO*/) ],\n    }))\n\n    this.register_alias(\"hover\", () => new HoverTool())\n  }\n\n  tool_name = \"Hover\"\n  icon = tool_icon_hover\n}\n"
    },
    {
      "filename": "bokehjs/test/unit/models/tools/inspectors/hover_tool.ts",
      "content": "import {expect} from \"assertions\"\nimport {display, fig} from \"_util\"\n\nimport {assert} from \"@bokehjs/core/util/assert\"\nimport {build_view} from \"@bokehjs/core/build_views\"\nimport {ColumnDataSource} from \"@bokehjs/models/sources/column_data_source\"\nimport {Circle} from \"@bokehjs/models/glyphs/circle\"\nimport {GlyphRenderer} from \"@bokehjs/models/renderers/glyph_renderer\"\nimport {Plot} from \"@bokehjs/models/plots/plot\"\nimport {Range1d} from \"@bokehjs/models/ranges/range1d\"\n\nimport {HoverTool, HoverToolView} from \"@bokehjs/models/tools/inspectors/hover_tool\"\n\nasync function make_testcase(): Promise<{hover_view: HoverToolView, data_source: ColumnDataSource}> {\n  const plot = new Plot({\n    x_range: new Range1d({start: -1, end: 1}),\n    y_range: new Range1d({start: -1, end: 1}),\n  })\n\n  const data = {x: [0, 0.5, 1], y: [0, 0.5, 1]}\n  const data_source = new ColumnDataSource({data})\n\n  const glyph = new Circle({x: {field: \"x\"}, y: {field: \"y\"}})\n  const glyph_renderer = new GlyphRenderer({glyph, data_source})\n\n  const hover_tool = new HoverTool({active: true, renderers: [glyph_renderer]})\n  plot.add_tools(hover_tool)\n\n  const plot_view = (await build_view(plot)).build()\n  const hover_view = plot_view.tool_views.get(hover_tool)! as HoverToolView\n\n  return {hover_view, data_source}\n}\n\ndescribe(\"HoverTool\", () => {\n\n  describe(\"View\", () => {\n\n    it(\"should invalidate tooltips' template when changing the tooltips property\", async () => {\n      const {hover_view, data_source} = await make_testcase()\n\n      const el0 = hover_view._render_tooltips(data_source, 0, {index: 0, x: 123, y: 456, sx: 0, sy: 0})\n      assert(el0 != null)\n      expect(el0.childElementCount).to.be.equal(3)\n\n      hover_view.model.tooltips = [[\"foo\", \"$x\"]]\n      await hover_view.ready\n\n      const el1 = hover_view._render_tooltips(data_source, 0, {index: 0, x: 123, y: 456})\n      assert(el1 != null)\n      expect(el1.childElementCount).to.be.equal(1)\n\n      hover_view.model.tooltips = \"<b>foo</b> is <i>$x</i>\"\n      await hover_view.ready\n\n      const el2 = hover_view._render_tooltips(data_source, 0, {index: 0, x: 123, y: 456})\n      assert(el2 != null)\n      expect(el2.childElementCount).to.be.equal(2)\n    })\n  })\n\n  it(\"should allow to render various combinations of color[hex] and swatch\", async () => {\n    const tooltips: [string, string][] = [\n      [\"index\", \"$index\"],\n      [\"(x,y)\", \"($x, $y)\"],\n      [\"radius\", \"@radius\"],\n      [\"hex & swatch (known)\", \"$color[hex, swatch]:colors\"],\n      [\"swatch & hex (known)\", \"$color[swatch, hex]:colors\"],\n      [\"hex, swatch (known)\", \"$color[hex]:colors $swatch:colors\"],\n      [\"swatch, hex (known)\", \"$swatch:colors $color[hex]:colors\"],\n      [\"hex (known)\", \"$color[hex]:colors\"],\n      [\"swatch (known)\", \"$swatch:colors\"],\n      [\"hex & swatch (unknown)\", \"$color[hex, swatch]:__colors\"],\n      [\"swatch & hex (unknown)\", \"$color[swatch, hex]:__colors\"],\n      [\"hex, swatch (unknown)\", \"$color[hex]:__colors $swatch:__colors\"],\n      [\"swatch, hex (unknown)\", \"$swatch:__colors $color[hex]:__colors\"],\n      [\"hex (unknown)\", \"$color[hex]:__colors\"],\n      [\"swatch (unknown)\", \"$swatch:__colors\"],\n      [\"foo\", \"@foo\"],\n      [\"bar\", \"@bar\"],\n    ]\n\n    const hover = new HoverTool({tooltips})\n    const p = fig([200, 200], {tools: [hover]})\n    const r = p.circle({\n      x: [1, 2, 3],\n      y: [4, 5, 6],\n      radius: [0.2, 0.4, 0.6],\n      fill_color: [\"red\", \"green\", \"blue\"],\n      source: {\n        foo: [\"abcd\", \"bacd\", \"bcad\"],\n        bar: [-1, -2, -3],\n      },\n    })\n\n    const {view} = await display(p)\n\n    const hover_view = view.tool_views.get(hover)! as HoverTool[\"__view_type__\"]\n    const el = hover_view._render_tooltips(r.data_source, 0, {index: 0, x: 10, y: 20})\n\n    const html =\n`\n<div class=\"bk\" style=\"display: table; border-spacing: 2px;\">\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">index: </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">0</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">(x,y): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">(10, 20)</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">radius: </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">0.200</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex &amp; swatch (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch &amp; hex (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex, swatch (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch, hex (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch (known): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex &amp; swatch (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch &amp; hex (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex, swatch (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch, hex (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">hex (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">swatch (unknown): </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">__colors unknown</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">foo: </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">abcd</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n  <div class=\"bk\" style=\"display: table-row;\">\n    <div class=\"bk bk-tooltip-row-label\" style=\"display: table-cell;\">bar: </div>\n    <div class=\"bk bk-tooltip-row-value\" style=\"display: table-cell;\">\n      <span class=\"bk\" data-value=\"\">-1</span>\n      <span class=\"bk bk-tooltip-color-block\" data-swatch=\"\" style=\"display: none;\"> </span>\n    </div>\n  </div>\n</div>\n`\n    expect(el!.outerHTML).to.be.equal(html.trim().split(\"\\n\").map((s) => s.trim()).join(\"\"))\n  })\n})\n"
    }
  ]
}