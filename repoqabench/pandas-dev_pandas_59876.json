{
  "repo_name": "pandas-dev_pandas",
  "issue_id": "59876",
  "issue_description": "# BUG: `pd.options.display.float_format` did not follow left side or before decimal places format \n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [ ] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n\r\n# Set the global float format\r\npd.options.display.float_format = '{:6.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\ndf\n```\n\n\n### Issue Description\n\nPandas `pd.options.display.float_format` did not follow left side or before decimal places format.\n\n### Expected Behavior\n\nIf also follows the left side or before decimal places format. \n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit                : d9cdd2ee5a58015ef6f4d15c7226110c9aab8140\r\npython                : 3.10.11.final.0\r\npython-bits           : 64\r\nOS                    : Darwin\r\nOS-release            : 23.6.0\r\nVersion               : Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:21 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T8103\r\nmachine               : arm64\r\nprocessor             : arm\r\nbyteorder             : little\r\nLC_ALL                : None\r\nLANG                  : None\r\nLOCALE                : None.UTF-8\r\n\r\npandas                : 2.2.2\r\nnumpy                 : 1.26.4\r\npytz                  : 2024.1\r\ndateutil              : 2.9.0.post0\r\nsetuptools            : 69.1.0\r\npip                   : 24.0\r\nCython                : None\r\npytest                : 8.1.1\r\nhypothesis            : None\r\nsphinx                : None\r\nblosc                 : None\r\nfeather               : None\r\nxlsxwriter            : None\r\nlxml.etree            : None\r\nhtml5lib              : None\r\npymysql               : None\r\npsycopg2              : None\r\njinja2                : 3.1.3\r\nIPython               : 8.23.0\r\npandas_datareader     : None\r\nadbc-driver-postgresql: None\r\nadbc-driver-sqlite    : None\r\nbs4                   : None\r\nbottleneck            : None\r\ndataframe-api-compat  : None\r\nfastparquet           : None\r\nfsspec                : None\r\ngcsfs                 : None\r\nmatplotlib            : 3.8.4\r\nnumba                 : None\r\nnumexpr               : None\r\nodfpy                 : None\r\nopenpyxl              : 3.1.2\r\npandas_gbq            : None\r\npyarrow               : None\r\npyreadstat            : None\r\npython-calamine       : None\r\npyxlsb                : None\r\ns3fs                  : None\r\nscipy                 : 1.11.4\r\nsqlalchemy            : None\r\ntables                : None\r\ntabulate              : None\r\nxarray                : None\r\nxlrd                  : None\r\nzstandard             : None\r\ntzdata                : 2024.1\r\nqtpy                  : None\r\npyqt5                 : None\r\n\r\n</details>\r\n",
  "issue_comments": [
    {
      "id": 2369922344,
      "user": "rhshadrach",
      "body": "Thanks for the report. Can you include what output you currently get and the output you expect to get."
    },
    {
      "id": 2370093520,
      "user": "yasirroni",
      "body": "Current output:\r\n\r\n<img width=\"119\" alt=\"image\" src=\"https://github.com/user-attachments/assets/9a808933-1374-44f2-84b1-6a010f026b98\">\r\n\r\nExpected output:\r\n\r\nThe width of all column should be the same based on the allocated space by \"format\".\r\n\r\n<img width=\"180\" alt=\"image\" src=\"https://github.com/user-attachments/assets/dcc04949-f77b-4c23-88ec-08de73e5c253\">\r\n\r\nExample code to generate my output:\r\n\r\n```python\r\nimport pandas as pd\r\n\r\n# Set the global float format\r\nfmt = '{:6.3f}'.format\r\npd.options.display.float_format = fmt\r\n\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\nfor index, row in df.iterrows():\r\n    formatted_row = [fmt(value) for value in row]  # Format each value in the row\r\n    print(f\"Col {index}: {formatted_row}\")\r\n```\r\n"
    },
    {
      "id": 2372653404,
      "user": "rhshadrach",
      "body": "Thanks for the information. It appears to me you are using something akin to Juptyer's `display` which is a different method than printing.\r\n\r\n```python\r\npd.options.display.float_format = '{:12.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\nprint(df)\r\n#              A            B\r\n# 0      123.456        2.718\r\n# 1      789.101        3.142\r\n```\r\n\r\nYou can see the option is having the expected impact on printed DataFrames. It's not clear to me whether this is due to a limitation on the Jupyter (or other notebooks) side. Further investigations are welcome!"
    },
    {
      "id": 2372680776,
      "user": "yasirroni",
      "body": "Thank you. I'm using VSCode Jupyter Notebook and I can confirm that print is working as expected but display is not. Using jupeyter lab also works the same.\r\n\r\n```python\r\nimport pandas as pd\r\n\r\nfrom IPython.display import display\r\n\r\npd.options.display.float_format = '{:.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\nprint(df)\r\ndisplay(df)\r\n\r\npd.options.display.float_format = '{:12.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\nprint(df)\r\ndisplay(df)\r\n```\r\n\r\n<img width=\"391\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7a97b71d-b8f8-47d4-86d6-860e1a794047\">\r\n"
    },
    {
      "id": 2372682045,
      "user": "yasirroni",
      "body": "So, I think we should close this and pass it to jupyter developer? Please give me feedback on where is the best place to bring this (is it pandas or jupyter)."
    },
    {
      "id": 2372706988,
      "user": "yasirroni",
      "body": "After some investigation, even string format didn't respected by display.\r\n\r\n```python\r\npd.options.display.float_format = '{:.3f}'.format.  # if float, use .3f\r\ndf_formatted = df.map(lambda x: str(f'{x:12.3f}')).astype('string').  # change to string to ignore float_format\r\ndisplay(df_formatted)\r\nprint(df_formatted)  # correctly using str(f'{x:12.3f}')\r\n```\r\n\r\nThe workaround is to directly change Styler:\r\n\r\n```python\r\nstyled_df = df_formatted.style.set_table_styles(\r\n    [{'selector': 'td', 'props': [('min-width', '80px')]}]\r\n)\r\n\r\ndisplay(styled_df)\r\n```"
    },
    {
      "id": 2373904037,
      "user": "rhshadrach",
      "body": "Thanks for the investigation - I think your investigation suggests this is an issue with HTML formatting. We still control the HTML that is produced by `display(df)`, so I suspect we may be able to fix it. Even if that is the case, perhaps we should consider having some formatting options only for printed DataFrames.\r\n\r\nLeaving this open for now. I plan to investigate it in the near future."
    },
    {
      "id": 2381351682,
      "user": "rhshadrach",
      "body": "Two things need to change in order to implement this. First, is passing `get_option(\"display.float_format\")` to `DataFrameFormatter` in `frame.DataFrame._repr_html`. The 2nd is adding `\" \": \"&nbsp;\"` to `esc` in `io.formats.html.HTMLFormatter._write_cell`.\r\n\r\nFor the 2nd, we also fix other issues with multiple spaces in strings, e.g.\r\n\r\n    df = pd.DataFrame({\"A\": [\"foo      foo\", \"bar\"]})\r\n    display(df)\r\n\r\nfixed:\r\n\r\n![image](https://github.com/user-attachments/assets/70c75b09-d2c8-4149-8cdb-6ad5cd3bfded)\r\n\r\nmain:\r\n\r\n![image](https://github.com/user-attachments/assets/38ba465f-1ad7-4872-8a09-b0eb9d99ff39)\r\n\r\nI think each of these are not controversial, marking as a good first issue for now. But cc @pandas-dev/pandas-core for any thoughts."
    },
    {
      "id": 2381450278,
      "user": "saldanhad",
      "body": "Are you expecting a pytest script to cover this change?"
    },
    {
      "id": 2381482007,
      "user": "rhshadrach",
      "body": "Yes - I think something along the lines of `test_info_repr_html` would be sufficient."
    },
    {
      "id": 2381570621,
      "user": "saldanhad",
      "body": "take"
    },
    {
      "id": 2386475602,
      "user": "saldanhad",
      "body": "For the 2nd implementation is it ok if the html output is `<td>&nbsp;foo&nbsp;&nbsp;&nbsp;&nbsp;foo</td> `  or should it have to be of the form ` <td>foo&nbsp;&nbsp;&nbsp;&nbsp;foo</td>`"
    },
    {
      "id": 2387011408,
      "user": "rhshadrach",
      "body": "@saldanhad - offhand I'm not sure; it may be that another section of code is adding `&nbsp;` prior to `foo` outside of where I indicated in https://github.com/pandas-dev/pandas/issues/59876#issuecomment-2381351682. If that's occurring, I think it should remain."
    },
    {
      "id": 2387028811,
      "user": "saldanhad",
      "body": "Thanks for clarifying. The leading `&nbsp` was not there before and it seems to be appearing after adding it to `esc`, so I am assuming this is not expected. "
    },
    {
      "id": 2387030526,
      "user": "rhshadrach",
      "body": "Interesting - I'll take a deeper look."
    },
    {
      "id": 2387035957,
      "user": "saldanhad",
      "body": "Meanwhile I was able to implement the `float formatting` with unit tests passed, if you don't mind can I make the PR for review for completion of this part ?"
    },
    {
      "id": 2387037603,
      "user": "rhshadrach",
      "body": "Sure, that sounds fine."
    },
    {
      "id": 2387059985,
      "user": "rhshadrach",
      "body": "The issue with the extra space is the use of strip here:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/f598670353311a6fff4e6e1e96074ccf0737e6b7/pandas/io/formats/html.py#L197\r\n\r\nBy replacing spaces with `&nbsp`, that strip no longer does anything. This goes back to https://github.com/pandas-dev/pandas/issues/4987.\r\n\r\nI think the solution is to leave `esc` alone and use `rs = rs.replace(\" \", \"&nbsp\")` after the call to `pprint_thing`."
    },
    {
      "id": 2387101908,
      "user": "saldanhad",
      "body": "Thanks for your help on this. Implementing it, this way, does give the desired outcome now. My understanding prior was to have replace come inside the if conditional before pretty print and it wasn't getting implemented. \r\n\r\nHowever still a few tests are failing and further investigation is needed:\r\n```\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_escaped[kwargs0-<type 'str'>-escaped] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_escaped[kwargs1-<b>bold</b>-escape_disabled] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[10-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[10-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[20-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[20-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[50-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[50-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[100-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[100-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_na_rep_non_scalar_data - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_tuple_col_with_colspace - AssertionError\r\n```"
    },
    {
      "id": 2392213196,
      "user": "rhshadrach",
      "body": "Perhaps it's better to use `rs.replace(\"  \", \"&nbsp;&nbsp;\")`. In the case there is 1 space, this would leave it alone. In the case of an odd number of spaces greater than 1, it would give the slightly odd result of something like `foo&nbsp;&nbsp;&nbsp;&nbsp; foo`. However this still produces correct HTML, with the added benefit of leaving single spaces alone. This should reduce (eliminate?) the number of test failures you're seeing."
    },
    {
      "id": 2393371393,
      "user": "saldanhad",
      "body": "Thanks, this worked, raising PR to close this issue."
    }
  ],
  "text_context": "# BUG: `pd.options.display.float_format` did not follow left side or before decimal places format \n\n### Pandas version checks\n\n- [X] I have checked that this issue has not already been reported.\n\n- [X] I have confirmed this bug exists on the [latest version](https://pandas.pydata.org/docs/whatsnew/index.html) of pandas.\n\n- [ ] I have confirmed this bug exists on the [main branch](https://pandas.pydata.org/docs/dev/getting_started/install.html#installing-the-development-version-of-pandas) of pandas.\n\n\n### Reproducible Example\n\n```python\nimport pandas as pd\r\n\r\n# Set the global float format\r\npd.options.display.float_format = '{:6.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\ndf\n```\n\n\n### Issue Description\n\nPandas `pd.options.display.float_format` did not follow left side or before decimal places format.\n\n### Expected Behavior\n\nIf also follows the left side or before decimal places format. \n\n### Installed Versions\n\n<details>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit                : d9cdd2ee5a58015ef6f4d15c7226110c9aab8140\r\npython                : 3.10.11.final.0\r\npython-bits           : 64\r\nOS                    : Darwin\r\nOS-release            : 23.6.0\r\nVersion               : Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:21 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T8103\r\nmachine               : arm64\r\nprocessor             : arm\r\nbyteorder             : little\r\nLC_ALL                : None\r\nLANG                  : None\r\nLOCALE                : None.UTF-8\r\n\r\npandas                : 2.2.2\r\nnumpy                 : 1.26.4\r\npytz                  : 2024.1\r\ndateutil              : 2.9.0.post0\r\nsetuptools            : 69.1.0\r\npip                   : 24.0\r\nCython                : None\r\npytest                : 8.1.1\r\nhypothesis            : None\r\nsphinx                : None\r\nblosc                 : None\r\nfeather               : None\r\nxlsxwriter            : None\r\nlxml.etree            : None\r\nhtml5lib              : None\r\npymysql               : None\r\npsycopg2              : None\r\njinja2                : 3.1.3\r\nIPython               : 8.23.0\r\npandas_datareader     : None\r\nadbc-driver-postgresql: None\r\nadbc-driver-sqlite    : None\r\nbs4                   : None\r\nbottleneck            : None\r\ndataframe-api-compat  : None\r\nfastparquet           : None\r\nfsspec                : None\r\ngcsfs                 : None\r\nmatplotlib            : 3.8.4\r\nnumba                 : None\r\nnumexpr               : None\r\nodfpy                 : None\r\nopenpyxl              : 3.1.2\r\npandas_gbq            : None\r\npyarrow               : None\r\npyreadstat            : None\r\npython-calamine       : None\r\npyxlsb                : None\r\ns3fs                  : None\r\nscipy                 : 1.11.4\r\nsqlalchemy            : None\r\ntables                : None\r\ntabulate              : None\r\nxarray                : None\r\nxlrd                  : None\r\nzstandard             : None\r\ntzdata                : 2024.1\r\nqtpy                  : None\r\npyqt5                 : None\r\n\r\n</details>\r\n\n\nThanks for the report. Can you include what output you currently get and the output you expect to get.\n\nCurrent output:\r\n\r\n<img width=\"119\" alt=\"image\" src=\"https://github.com/user-attachments/assets/9a808933-1374-44f2-84b1-6a010f026b98\">\r\n\r\nExpected output:\r\n\r\nThe width of all column should be the same based on the allocated space by \"format\".\r\n\r\n<img width=\"180\" alt=\"image\" src=\"https://github.com/user-attachments/assets/dcc04949-f77b-4c23-88ec-08de73e5c253\">\r\n\r\nExample code to generate my output:\r\n\r\n```python\r\nimport pandas as pd\r\n\r\n# Set the global float format\r\nfmt = '{:6.3f}'.format\r\npd.options.display.float_format = fmt\r\n\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\nfor index, row in df.iterrows():\r\n    formatted_row = [fmt(value) for value in row]  # Format each value in the row\r\n    print(f\"Col {index}: {formatted_row}\")\r\n```\r\n\n\nThanks for the information. It appears to me you are using something akin to Juptyer's `display` which is a different method than printing.\r\n\r\n```python\r\npd.options.display.float_format = '{:12.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\n\r\nprint(df)\r\n#              A            B\r\n# 0      123.456        2.718\r\n# 1      789.101        3.142\r\n```\r\n\r\nYou can see the option is having the expected impact on printed DataFrames. It's not clear to me whether this is due to a limitation on the Jupyter (or other notebooks) side. Further investigations are welcome!\n\nThank you. I'm using VSCode Jupyter Notebook and I can confirm that print is working as expected but display is not. Using jupeyter lab also works the same.\r\n\r\n```python\r\nimport pandas as pd\r\n\r\nfrom IPython.display import display\r\n\r\npd.options.display.float_format = '{:.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\nprint(df)\r\ndisplay(df)\r\n\r\npd.options.display.float_format = '{:12.3f}'.format\r\n\r\n# Example DataFrame\r\ndf = pd.DataFrame({\r\n    'A': [123.456, 789.1011],\r\n    'B': [2.71828, 3.14159]\r\n})\r\nprint(df)\r\ndisplay(df)\r\n```\r\n\r\n<img width=\"391\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7a97b71d-b8f8-47d4-86d6-860e1a794047\">\r\n\n\nSo, I think we should close this and pass it to jupyter developer? Please give me feedback on where is the best place to bring this (is it pandas or jupyter).\n\nAfter some investigation, even string format didn't respected by display.\r\n\r\n```python\r\npd.options.display.float_format = '{:.3f}'.format.  # if float, use .3f\r\ndf_formatted = df.map(lambda x: str(f'{x:12.3f}')).astype('string').  # change to string to ignore float_format\r\ndisplay(df_formatted)\r\nprint(df_formatted)  # correctly using str(f'{x:12.3f}')\r\n```\r\n\r\nThe workaround is to directly change Styler:\r\n\r\n```python\r\nstyled_df = df_formatted.style.set_table_styles(\r\n    [{'selector': 'td', 'props': [('min-width', '80px')]}]\r\n)\r\n\r\ndisplay(styled_df)\r\n```\n\nThanks for the investigation - I think your investigation suggests this is an issue with HTML formatting. We still control the HTML that is produced by `display(df)`, so I suspect we may be able to fix it. Even if that is the case, perhaps we should consider having some formatting options only for printed DataFrames.\r\n\r\nLeaving this open for now. I plan to investigate it in the near future.\n\nTwo things need to change in order to implement this. First, is passing `get_option(\"display.float_format\")` to `DataFrameFormatter` in `frame.DataFrame._repr_html`. The 2nd is adding `\" \": \"&nbsp;\"` to `esc` in `io.formats.html.HTMLFormatter._write_cell`.\r\n\r\nFor the 2nd, we also fix other issues with multiple spaces in strings, e.g.\r\n\r\n    df = pd.DataFrame({\"A\": [\"foo      foo\", \"bar\"]})\r\n    display(df)\r\n\r\nfixed:\r\n\r\n![image](https://github.com/user-attachments/assets/70c75b09-d2c8-4149-8cdb-6ad5cd3bfded)\r\n\r\nmain:\r\n\r\n![image](https://github.com/user-attachments/assets/38ba465f-1ad7-4872-8a09-b0eb9d99ff39)\r\n\r\nI think each of these are not controversial, marking as a good first issue for now. But cc @pandas-dev/pandas-core for any thoughts.\n\nAre you expecting a pytest script to cover this change?\n\nYes - I think something along the lines of `test_info_repr_html` would be sufficient.\n\ntake\n\nFor the 2nd implementation is it ok if the html output is `<td>&nbsp;foo&nbsp;&nbsp;&nbsp;&nbsp;foo</td> `  or should it have to be of the form ` <td>foo&nbsp;&nbsp;&nbsp;&nbsp;foo</td>`\n\n@saldanhad - offhand I'm not sure; it may be that another section of code is adding `&nbsp;` prior to `foo` outside of where I indicated in https://github.com/pandas-dev/pandas/issues/59876#issuecomment-2381351682. If that's occurring, I think it should remain.\n\nThanks for clarifying. The leading `&nbsp` was not there before and it seems to be appearing after adding it to `esc`, so I am assuming this is not expected. \n\nInteresting - I'll take a deeper look.\n\nMeanwhile I was able to implement the `float formatting` with unit tests passed, if you don't mind can I make the PR for review for completion of this part ?\n\nSure, that sounds fine.\n\nThe issue with the extra space is the use of strip here:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/f598670353311a6fff4e6e1e96074ccf0737e6b7/pandas/io/formats/html.py#L197\r\n\r\nBy replacing spaces with `&nbsp`, that strip no longer does anything. This goes back to https://github.com/pandas-dev/pandas/issues/4987.\r\n\r\nI think the solution is to leave `esc` alone and use `rs = rs.replace(\" \", \"&nbsp\")` after the call to `pprint_thing`.\n\nThanks for your help on this. Implementing it, this way, does give the desired outcome now. My understanding prior was to have replace come inside the if conditional before pretty print and it wasn't getting implemented. \r\n\r\nHowever still a few tests are failing and further investigation is needed:\r\n```\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_escaped[kwargs0-<type 'str'>-escaped] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_escaped[kwargs1-<b>bold</b>-escape_disabled] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[10-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[10-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[20-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[20-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[50-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[50-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[100-to_html-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_ignore_display_max_colwidth[100-_repr_html_-<lambda>] - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_na_rep_non_scalar_data - AssertionError\r\nFAILED pandas/tests/io/formats/test_to_html.py::test_to_html_tuple_col_with_colspace - AssertionError\r\n```\n\nPerhaps it's better to use `rs.replace(\"  \", \"&nbsp;&nbsp;\")`. In the case there is 1 space, this would leave it alone. In the case of an odd number of spaces greater than 1, it would give the slightly odd result of something like `foo&nbsp;&nbsp;&nbsp;&nbsp; foo`. However this still produces correct HTML, with the added benefit of leaving single spaces alone. This should reduce (eliminate?) the number of test failures you're seeing.\n\nThanks, this worked, raising PR to close this issue.",
  "pr_link": "https://github.com/pandas-dev/pandas/pull/59964",
  "code_context": [
    {
      "filename": "pandas/io/formats/html.py",
      "content": "\"\"\"\nModule for formatting output data in HTML.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom textwrap import dedent\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Final,\n    cast,\n)\n\nfrom pandas._config import get_option\n\nfrom pandas._libs import lib\n\nfrom pandas import (\n    MultiIndex,\n    option_context,\n)\n\nfrom pandas.io.common import is_url\nfrom pandas.io.formats.format import (\n    DataFrameFormatter,\n    get_level_lengths,\n)\nfrom pandas.io.formats.printing import pprint_thing\n\nif TYPE_CHECKING:\n    from collections.abc import (\n        Hashable,\n        Iterable,\n        Mapping,\n    )\n\n\nclass HTMLFormatter:\n    \"\"\"\n    Internal class for formatting output data in html.\n    This class is intended for shared functionality between\n    DataFrame.to_html() and DataFrame._repr_html_().\n    Any logic in common with other output formatting methods\n    should ideally be inherited from classes in format.py\n    and this class responsible for only producing html markup.\n    \"\"\"\n\n    indent_delta: Final = 2\n\n    def __init__(\n        self,\n        formatter: DataFrameFormatter,\n        classes: str | list[str] | tuple[str, ...] | None = None,\n        border: int | bool | None = None,\n        table_id: str | None = None,\n        render_links: bool = False,\n    ) -> None:\n        self.fmt = formatter\n        self.classes = classes\n\n        self.frame = self.fmt.frame\n        self.columns = self.fmt.tr_frame.columns\n        self.elements: list[str] = []\n        self.bold_rows = self.fmt.bold_rows\n        self.escape = self.fmt.escape\n        self.show_dimensions = self.fmt.show_dimensions\n        if border is None or border is True:\n            border = cast(int, get_option(\"display.html.border\"))\n        elif not border:\n            border = None\n\n        self.border = border\n        self.table_id = table_id\n        self.render_links = render_links\n\n        self.col_space = {}\n        is_multi_index = isinstance(self.columns, MultiIndex)\n        for column, value in self.fmt.col_space.items():\n            col_space_value = f\"{value}px\" if isinstance(value, int) else value\n            self.col_space[column] = col_space_value\n            # GH 53885: Handling case where column is index\n            # Flatten the data in the multi index and add in the map\n            if is_multi_index and isinstance(column, tuple):\n                for column_index in column:\n                    self.col_space[str(column_index)] = col_space_value\n\n    def to_string(self) -> str:\n        lines = self.render()\n        if any(isinstance(x, str) for x in lines):\n            lines = [str(x) for x in lines]\n        return \"\\n\".join(lines)\n\n    def render(self) -> list[str]:\n        self._write_table()\n\n        if self.should_show_dimensions:\n            by = chr(215)  # ×  # noqa: RUF003\n            self.write(\n                f\"<p>{len(self.frame)} rows {by} {len(self.frame.columns)} columns</p>\"\n            )\n\n        return self.elements\n\n    @property\n    def should_show_dimensions(self) -> bool:\n        return self.fmt.should_show_dimensions\n\n    @property\n    def show_row_idx_names(self) -> bool:\n        return self.fmt.show_row_idx_names\n\n    @property\n    def show_col_idx_names(self) -> bool:\n        return self.fmt.show_col_idx_names\n\n    @property\n    def row_levels(self) -> int:\n        if self.fmt.index:\n            # showing (row) index\n            return self.frame.index.nlevels\n        elif self.show_col_idx_names:\n            # see gh-22579\n            # Column misalignment also occurs for\n            # a standard index when the columns index is named.\n            # If the row index is not displayed a column of\n            # blank cells need to be included before the DataFrame values.\n            return 1\n        # not showing (row) index\n        return 0\n\n    def _get_columns_formatted_values(self) -> Iterable:\n        return self.columns\n\n    @property\n    def is_truncated(self) -> bool:\n        return self.fmt.is_truncated\n\n    @property\n    def ncols(self) -> int:\n        return len(self.fmt.tr_frame.columns)\n\n    def write(self, s: Any, indent: int = 0) -> None:\n        rs = pprint_thing(s)\n        self.elements.append(\" \" * indent + rs)\n\n    def write_th(\n        self, s: Any, header: bool = False, indent: int = 0, tags: str | None = None\n    ) -> None:\n        \"\"\"\n        Method for writing a formatted <th> cell.\n\n        If col_space is set on the formatter then that is used for\n        the value of min-width.\n\n        Parameters\n        ----------\n        s : object\n            The data to be written inside the cell.\n        header : bool, default False\n            Set to True if the <th> is for use inside <thead>.  This will\n            cause min-width to be set if there is one.\n        indent : int, default 0\n            The indentation level of the cell.\n        tags : str, default None\n            Tags to include in the cell.\n\n        Returns\n        -------\n        A written <th> cell.\n        \"\"\"\n        col_space = self.col_space.get(s, None)\n\n        if header and col_space is not None:\n            tags = tags or \"\"\n            tags += f'style=\"min-width: {col_space};\"'\n\n        self._write_cell(s, kind=\"th\", indent=indent, tags=tags)\n\n    def write_td(self, s: Any, indent: int = 0, tags: str | None = None) -> None:\n        self._write_cell(s, kind=\"td\", indent=indent, tags=tags)\n\n    def _write_cell(\n        self, s: Any, kind: str = \"td\", indent: int = 0, tags: str | None = None\n    ) -> None:\n        if tags is not None:\n            start_tag = f\"<{kind} {tags}>\"\n        else:\n            start_tag = f\"<{kind}>\"\n\n        if self.escape:\n            # escape & first to prevent double escaping of &\n            esc = {\"&\": r\"&amp;\", \"<\": r\"&lt;\", \">\": r\"&gt;\"}\n        else:\n            esc = {}\n\n        rs = pprint_thing(s, escape_chars=esc).strip()\n        # replace spaces betweens strings with non-breaking spaces\n        rs = rs.replace(\"  \", \"&nbsp;&nbsp;\")\n\n        if self.render_links and is_url(rs):\n            rs_unescaped = pprint_thing(s, escape_chars={}).strip()\n            start_tag += f'<a href=\"{rs_unescaped}\" target=\"_blank\">'\n            end_a = \"</a>\"\n        else:\n            end_a = \"\"\n\n        self.write(f\"{start_tag}{rs}{end_a}</{kind}>\", indent)\n\n    def write_tr(\n        self,\n        line: Iterable,\n        indent: int = 0,\n        indent_delta: int = 0,\n        header: bool = False,\n        align: str | None = None,\n        tags: dict[int, str] | None = None,\n        nindex_levels: int = 0,\n    ) -> None:\n        if tags is None:\n            tags = {}\n\n        if align is None:\n            self.write(\"<tr>\", indent)\n        else:\n            self.write(f'<tr style=\"text-align: {align};\">', indent)\n        indent += indent_delta\n\n        for i, s in enumerate(line):\n            val_tag = tags.get(i, None)\n            if header or (self.bold_rows and i < nindex_levels):\n                self.write_th(s, indent=indent, header=header, tags=val_tag)\n            else:\n                self.write_td(s, indent, tags=val_tag)\n\n        indent -= indent_delta\n        self.write(\"</tr>\", indent)\n\n    def _write_table(self, indent: int = 0) -> None:\n        _classes = [\"dataframe\"]  # Default class.\n        use_mathjax = get_option(\"display.html.use_mathjax\")\n        if not use_mathjax:\n            _classes.append(\"tex2jax_ignore\")\n        if self.classes is not None:\n            if isinstance(self.classes, str):\n                self.classes = self.classes.split()\n            if not isinstance(self.classes, (list, tuple)):\n                raise TypeError(\n                    \"classes must be a string, list, \"\n                    f\"or tuple, not {type(self.classes)}\"\n                )\n            _classes.extend(self.classes)\n\n        if self.table_id is None:\n            id_section = \"\"\n        else:\n            id_section = f' id=\"{self.table_id}\"'\n\n        if self.border is None:\n            border_attr = \"\"\n        else:\n            border_attr = f' border=\"{self.border}\"'\n\n        self.write(\n            f'<table{border_attr} class=\"{\" \".join(_classes)}\"{id_section}>',\n            indent,\n        )\n\n        if self.fmt.header or self.show_row_idx_names:\n            self._write_header(indent + self.indent_delta)\n\n        self._write_body(indent + self.indent_delta)\n\n        self.write(\"</table>\", indent)\n\n    def _write_col_header(self, indent: int) -> None:\n        row: list[Hashable]\n        is_truncated_horizontally = self.fmt.is_truncated_horizontally\n        if isinstance(self.columns, MultiIndex):\n            template = 'colspan=\"{span:d}\" halign=\"left\"'\n\n            sentinel: lib.NoDefault | bool\n            if self.fmt.sparsify:\n                # GH3547\n                sentinel = lib.no_default\n            else:\n                sentinel = False\n            levels = self.columns._format_multi(sparsify=sentinel, include_names=False)\n            level_lengths = get_level_lengths(levels, sentinel)\n            inner_lvl = len(level_lengths) - 1\n            for lnum, (records, values) in enumerate(zip(level_lengths, levels)):\n                if is_truncated_horizontally:\n                    # modify the header lines\n                    ins_col = self.fmt.tr_col_num\n                    if self.fmt.sparsify:\n                        recs_new = {}\n                        # Increment tags after ... col.\n                        for tag, span in list(records.items()):\n                            if tag >= ins_col:\n                                recs_new[tag + 1] = span\n                            elif tag + span > ins_col:\n                                recs_new[tag] = span + 1\n                                if lnum == inner_lvl:\n                                    values = (\n                                        values[:ins_col] + (\"...\",) + values[ins_col:]\n                                    )\n                                else:\n                                    # sparse col headers do not receive a ...\n                                    values = (\n                                        values[:ins_col]\n                                        + (values[ins_col - 1],)\n                                        + values[ins_col:]\n                                    )\n                            else:\n                                recs_new[tag] = span\n                            # if ins_col lies between tags, all col headers\n                            # get ...\n                            if tag + span == ins_col:\n                                recs_new[ins_col] = 1\n                                values = values[:ins_col] + (\"...\",) + values[ins_col:]\n                        records = recs_new\n                        inner_lvl = len(level_lengths) - 1\n                        if lnum == inner_lvl:\n                            records[ins_col] = 1\n                    else:\n                        recs_new = {}\n                        for tag, span in list(records.items()):\n                            if tag >= ins_col:\n                                recs_new[tag + 1] = span\n                            else:\n                                recs_new[tag] = span\n                        recs_new[ins_col] = 1\n                        records = recs_new\n                        values = values[:ins_col] + [\"...\"] + values[ins_col:]\n\n                # see gh-22579\n                # Column Offset Bug with to_html(index=False) with\n                # MultiIndex Columns and Index.\n                # Initially fill row with blank cells before column names.\n                # TODO: Refactor to remove code duplication with code\n                # block below for standard columns index.\n                row = [\"\"] * (self.row_levels - 1)\n                if self.fmt.index or self.show_col_idx_names:\n                    # see gh-22747\n                    # If to_html(index_names=False) do not show columns\n                    # index names.\n                    # TODO: Refactor to use _get_column_name_list from\n                    # DataFrameFormatter class and create a\n                    # _get_formatted_column_labels function for code\n                    # parity with DataFrameFormatter class.\n                    if self.fmt.show_index_names:\n                        name = self.columns.names[lnum]\n                        row.append(pprint_thing(name or \"\"))\n                    else:\n                        row.append(\"\")\n\n                tags = {}\n                j = len(row)\n                for i, v in enumerate(values):\n                    if i in records:\n                        if records[i] > 1:\n                            tags[j] = template.format(span=records[i])\n                    else:\n                        continue\n                    j += 1\n                    row.append(v)\n                self.write_tr(row, indent, self.indent_delta, tags=tags, header=True)\n        else:\n            # see gh-22579\n            # Column misalignment also occurs for\n            # a standard index when the columns index is named.\n            # Initially fill row with blank cells before column names.\n            # TODO: Refactor to remove code duplication with code block\n            # above for columns MultiIndex.\n            row = [\"\"] * (self.row_levels - 1)\n            if self.fmt.index or self.show_col_idx_names:\n                # see gh-22747\n                # If to_html(index_names=False) do not show columns\n                # index names.\n                # TODO: Refactor to use _get_column_name_list from\n                # DataFrameFormatter class.\n                if self.fmt.show_index_names:\n                    row.append(self.columns.name or \"\")\n                else:\n                    row.append(\"\")\n            row.extend(self._get_columns_formatted_values())\n            align = self.fmt.justify\n\n            if is_truncated_horizontally:\n                ins_col = self.row_levels + self.fmt.tr_col_num\n                row.insert(ins_col, \"...\")\n\n            self.write_tr(row, indent, self.indent_delta, header=True, align=align)\n\n    def _write_row_header(self, indent: int) -> None:\n        is_truncated_horizontally = self.fmt.is_truncated_horizontally\n        row = [x if x is not None else \"\" for x in self.frame.index.names] + [\"\"] * (\n            self.ncols + (1 if is_truncated_horizontally else 0)\n        )\n        self.write_tr(row, indent, self.indent_delta, header=True)\n\n    def _write_header(self, indent: int) -> None:\n        self.write(\"<thead>\", indent)\n\n        if self.fmt.header:\n            self._write_col_header(indent + self.indent_delta)\n\n        if self.show_row_idx_names:\n            self._write_row_header(indent + self.indent_delta)\n\n        self.write(\"</thead>\", indent)\n\n    def _get_formatted_values(self) -> dict[int, list[str]]:\n        with option_context(\"display.max_colwidth\", None):\n            fmt_values = {i: self.fmt.format_col(i) for i in range(self.ncols)}\n        return fmt_values\n\n    def _write_body(self, indent: int) -> None:\n        self.write(\"<tbody>\", indent)\n        fmt_values = self._get_formatted_values()\n\n        # write values\n        if self.fmt.index and isinstance(self.frame.index, MultiIndex):\n            self._write_hierarchical_rows(fmt_values, indent + self.indent_delta)\n        else:\n            self._write_regular_rows(fmt_values, indent + self.indent_delta)\n\n        self.write(\"</tbody>\", indent)\n\n    def _write_regular_rows(\n        self, fmt_values: Mapping[int, list[str]], indent: int\n    ) -> None:\n        is_truncated_horizontally = self.fmt.is_truncated_horizontally\n        is_truncated_vertically = self.fmt.is_truncated_vertically\n\n        nrows = len(self.fmt.tr_frame)\n\n        if self.fmt.index:\n            fmt = self.fmt._get_formatter(\"__index__\")\n            if fmt is not None:\n                index_values = self.fmt.tr_frame.index.map(fmt)\n            else:\n                # only reached with non-Multi index\n                index_values = self.fmt.tr_frame.index._format_flat(include_name=False)\n\n        row: list[str] = []\n        for i in range(nrows):\n            if is_truncated_vertically and i == (self.fmt.tr_row_num):\n                str_sep_row = [\"...\"] * len(row)\n                self.write_tr(\n                    str_sep_row,\n                    indent,\n                    self.indent_delta,\n                    tags=None,\n                    nindex_levels=self.row_levels,\n                )\n\n            row = []\n            if self.fmt.index:\n                row.append(index_values[i])\n            # see gh-22579\n            # Column misalignment also occurs for\n            # a standard index when the columns index is named.\n            # Add blank cell before data cells.\n            elif self.show_col_idx_names:\n                row.append(\"\")\n            row.extend(fmt_values[j][i] for j in range(self.ncols))\n\n            if is_truncated_horizontally:\n                dot_col_ix = self.fmt.tr_col_num + self.row_levels\n                row.insert(dot_col_ix, \"...\")\n            self.write_tr(\n                row, indent, self.indent_delta, tags=None, nindex_levels=self.row_levels\n            )\n\n    def _write_hierarchical_rows(\n        self, fmt_values: Mapping[int, list[str]], indent: int\n    ) -> None:\n        template = 'rowspan=\"{span}\" valign=\"top\"'\n\n        is_truncated_horizontally = self.fmt.is_truncated_horizontally\n        is_truncated_vertically = self.fmt.is_truncated_vertically\n        frame = self.fmt.tr_frame\n        nrows = len(frame)\n\n        assert isinstance(frame.index, MultiIndex)\n        idx_values = frame.index._format_multi(sparsify=False, include_names=False)\n        idx_values = list(zip(*idx_values))\n\n        if self.fmt.sparsify:\n            # GH3547\n            sentinel = lib.no_default\n            levels = frame.index._format_multi(sparsify=sentinel, include_names=False)\n\n            level_lengths = get_level_lengths(levels, sentinel)\n            inner_lvl = len(level_lengths) - 1\n            if is_truncated_vertically:\n                # Insert ... row and adjust idx_values and\n                # level_lengths to take this into account.\n                ins_row = self.fmt.tr_row_num\n                inserted = False\n                for lnum, records in enumerate(level_lengths):\n                    rec_new = {}\n                    for tag, span in list(records.items()):\n                        if tag >= ins_row:\n                            rec_new[tag + 1] = span\n                        elif tag + span > ins_row:\n                            rec_new[tag] = span + 1\n\n                            # GH 14882 - Make sure insertion done once\n                            if not inserted:\n                                dot_row = list(idx_values[ins_row - 1])\n                                dot_row[-1] = \"...\"\n                                idx_values.insert(ins_row, tuple(dot_row))\n                                inserted = True\n                            else:\n                                dot_row = list(idx_values[ins_row])\n                                dot_row[inner_lvl - lnum] = \"...\"\n                                idx_values[ins_row] = tuple(dot_row)\n                        else:\n                            rec_new[tag] = span\n                        # If ins_row lies between tags, all cols idx cols\n                        # receive ...\n                        if tag + span == ins_row:\n                            rec_new[ins_row] = 1\n                            if lnum == 0:\n                                idx_values.insert(\n                                    ins_row, tuple([\"...\"] * len(level_lengths))\n                                )\n\n                            # GH 14882 - Place ... in correct level\n                            elif inserted:\n                                dot_row = list(idx_values[ins_row])\n                                dot_row[inner_lvl - lnum] = \"...\"\n                                idx_values[ins_row] = tuple(dot_row)\n                    level_lengths[lnum] = rec_new\n\n                level_lengths[inner_lvl][ins_row] = 1\n                for ix_col in fmt_values:\n                    fmt_values[ix_col].insert(ins_row, \"...\")\n                nrows += 1\n\n            for i in range(nrows):\n                row = []\n                tags = {}\n\n                sparse_offset = 0\n                j = 0\n                for records, v in zip(level_lengths, idx_values[i]):\n                    if i in records:\n                        if records[i] > 1:\n                            tags[j] = template.format(span=records[i])\n                    else:\n                        sparse_offset += 1\n                        continue\n\n                    j += 1\n                    row.append(v)\n\n                row.extend(fmt_values[j][i] for j in range(self.ncols))\n                if is_truncated_horizontally:\n                    row.insert(\n                        self.row_levels - sparse_offset + self.fmt.tr_col_num, \"...\"\n                    )\n                self.write_tr(\n                    row,\n                    indent,\n                    self.indent_delta,\n                    tags=tags,\n                    nindex_levels=len(levels) - sparse_offset,\n                )\n        else:\n            row = []\n            for i in range(len(frame)):\n                if is_truncated_vertically and i == (self.fmt.tr_row_num):\n                    str_sep_row = [\"...\"] * len(row)\n                    self.write_tr(\n                        str_sep_row,\n                        indent,\n                        self.indent_delta,\n                        tags=None,\n                        nindex_levels=self.row_levels,\n                    )\n\n                idx_values = list(\n                    zip(*frame.index._format_multi(sparsify=False, include_names=False))\n                )\n                row = []\n                row.extend(idx_values[i])\n                row.extend(fmt_values[j][i] for j in range(self.ncols))\n                if is_truncated_horizontally:\n                    row.insert(self.row_levels + self.fmt.tr_col_num, \"...\")\n                self.write_tr(\n                    row,\n                    indent,\n                    self.indent_delta,\n                    tags=None,\n                    nindex_levels=frame.index.nlevels,\n                )\n\n\nclass NotebookFormatter(HTMLFormatter):\n    \"\"\"\n    Internal class for formatting output data in html for display in Jupyter\n    Notebooks. This class is intended for functionality specific to\n    DataFrame._repr_html_() and DataFrame.to_html(notebook=True)\n    \"\"\"\n\n    def _get_formatted_values(self) -> dict[int, list[str]]:\n        return {i: self.fmt.format_col(i) for i in range(self.ncols)}\n\n    def _get_columns_formatted_values(self) -> list[str]:\n        # only reached with non-Multi Index\n        return self.columns._format_flat(include_name=False)\n\n    def write_style(self) -> None:\n        # We use the \"scoped\" attribute here so that the desired\n        # style properties for the data frame are not then applied\n        # throughout the entire notebook.\n        template_first = \"\"\"\\\n            <style scoped>\"\"\"\n        template_last = \"\"\"\\\n            </style>\"\"\"\n        template_select = \"\"\"\\\n                .dataframe %s {\n                    %s: %s;\n                }\"\"\"\n        element_props = [\n            (\"tbody tr th:only-of-type\", \"vertical-align\", \"middle\"),\n            (\"tbody tr th\", \"vertical-align\", \"top\"),\n        ]\n        if isinstance(self.columns, MultiIndex):\n            element_props.append((\"thead tr th\", \"text-align\", \"left\"))\n            if self.show_row_idx_names:\n                element_props.append(\n                    (\"thead tr:last-of-type th\", \"text-align\", \"right\")\n                )\n        else:\n            element_props.append((\"thead th\", \"text-align\", \"right\"))\n        template_mid = \"\\n\\n\".join(template_select % t for t in element_props)\n        template = dedent(f\"{template_first}\\n{template_mid}\\n{template_last}\")\n        self.write(template)\n\n    def render(self) -> list[str]:\n        self.write(\"<div>\")\n        self.write_style()\n        super().render()\n        self.write(\"</div>\")\n        return self.elements\n"
    },
    {
      "filename": "pandas/tests/io/formats/test_format.py",
      "content": "\"\"\"\nTests for the file pandas.io.formats.format, *not* tests for general formatting\nof pandas objects.\n\"\"\"\n\nfrom datetime import datetime\nfrom io import StringIO\nimport re\nfrom shutil import get_terminal_size\n\nimport numpy as np\nimport pytest\n\nfrom pandas._config import using_string_dtype\n\nimport pandas as pd\nfrom pandas import (\n    DataFrame,\n    Index,\n    MultiIndex,\n    NaT,\n    Series,\n    Timestamp,\n    date_range,\n    get_option,\n    option_context,\n    read_csv,\n    reset_option,\n)\n\nfrom pandas.io.formats import printing\nimport pandas.io.formats.format as fmt\n\n\ndef has_info_repr(df):\n    r = repr(df)\n    c1 = r.split(\"\\n\")[0].startswith(\"<class\")\n    c2 = r.split(\"\\n\")[0].startswith(r\"&lt;class\")  # _repr_html_\n    return c1 or c2\n\n\ndef has_non_verbose_info_repr(df):\n    has_info = has_info_repr(df)\n    r = repr(df)\n\n    # 1. <class>\n    # 2. Index\n    # 3. Columns\n    # 4. dtype\n    # 5. memory usage\n    # 6. trailing newline\n    nv = len(r.split(\"\\n\")) == 6\n    return has_info and nv\n\n\ndef has_horizontally_truncated_repr(df):\n    try:  # Check header row\n        fst_line = np.array(repr(df).splitlines()[0].split())\n        cand_col = np.where(fst_line == \"...\")[0][0]\n    except IndexError:\n        return False\n    # Make sure each row has this ... in the same place\n    r = repr(df)\n    for ix, _ in enumerate(r.splitlines()):\n        if not r.split()[cand_col] == \"...\":\n            return False\n    return True\n\n\ndef has_vertically_truncated_repr(df):\n    r = repr(df)\n    only_dot_row = False\n    for row in r.splitlines():\n        if re.match(r\"^[\\.\\ ]+$\", row):\n            only_dot_row = True\n    return only_dot_row\n\n\ndef has_truncated_repr(df):\n    return has_horizontally_truncated_repr(df) or has_vertically_truncated_repr(df)\n\n\ndef has_doubly_truncated_repr(df):\n    return has_horizontally_truncated_repr(df) and has_vertically_truncated_repr(df)\n\n\ndef has_expanded_repr(df):\n    r = repr(df)\n    for line in r.split(\"\\n\"):\n        if line.endswith(\"\\\\\"):\n            return True\n    return False\n\n\nclass TestDataFrameFormatting:\n    def test_repr_truncation(self):\n        max_len = 20\n        with option_context(\"display.max_colwidth\", max_len):\n            df = DataFrame(\n                {\n                    \"A\": np.random.default_rng(2).standard_normal(10),\n                    \"B\": [\n                        \"a\"\n                        * np.random.default_rng(2).integers(max_len - 1, max_len + 1)\n                        for _ in range(10)\n                    ],\n                }\n            )\n            r = repr(df)\n            r = r[r.find(\"\\n\") + 1 :]\n\n            adj = printing.get_adjustment()\n\n            for line, value in zip(r.split(\"\\n\"), df[\"B\"]):\n                if adj.len(value) + 1 > max_len:\n                    assert \"...\" in line\n                else:\n                    assert \"...\" not in line\n\n        with option_context(\"display.max_colwidth\", 999999):\n            assert \"...\" not in repr(df)\n\n        with option_context(\"display.max_colwidth\", max_len + 2):\n            assert \"...\" not in repr(df)\n\n    def test_repr_truncation_preserves_na(self):\n        # https://github.com/pandas-dev/pandas/issues/55630\n        df = DataFrame({\"a\": [pd.NA for _ in range(10)]})\n        with option_context(\"display.max_rows\", 2, \"display.show_dimensions\", False):\n            assert repr(df) == \"       a\\n0   <NA>\\n..   ...\\n9   <NA>\"\n\n    def test_max_colwidth_negative_int_raises(self):\n        # Deprecation enforced from:\n        # https://github.com/pandas-dev/pandas/issues/31532\n        with pytest.raises(\n            ValueError, match=\"Value must be a nonnegative integer or None\"\n        ):\n            with option_context(\"display.max_colwidth\", -1):\n                pass\n\n    def test_repr_chop_threshold(self):\n        df = DataFrame([[0.1, 0.5], [0.5, -0.1]])\n        reset_option(\"display.chop_threshold\")  # default None\n        assert repr(df) == \"     0    1\\n0  0.1  0.5\\n1  0.5 -0.1\"\n\n        with option_context(\"display.chop_threshold\", 0.2):\n            assert repr(df) == \"     0    1\\n0  0.0  0.5\\n1  0.5  0.0\"\n\n        with option_context(\"display.chop_threshold\", 0.6):\n            assert repr(df) == \"     0    1\\n0  0.0  0.0\\n1  0.0  0.0\"\n\n        with option_context(\"display.chop_threshold\", None):\n            assert repr(df) == \"     0    1\\n0  0.1  0.5\\n1  0.5 -0.1\"\n\n    def test_repr_chop_threshold_column_below(self):\n        # GH 6839: validation case\n\n        df = DataFrame([[10, 20, 30, 40], [8e-10, -1e-11, 2e-9, -2e-11]]).T\n\n        with option_context(\"display.chop_threshold\", 0):\n            assert repr(df) == (\n                \"      0             1\\n\"\n                \"0  10.0  8.000000e-10\\n\"\n                \"1  20.0 -1.000000e-11\\n\"\n                \"2  30.0  2.000000e-09\\n\"\n                \"3  40.0 -2.000000e-11\"\n            )\n\n        with option_context(\"display.chop_threshold\", 1e-8):\n            assert repr(df) == (\n                \"      0             1\\n\"\n                \"0  10.0  0.000000e+00\\n\"\n                \"1  20.0  0.000000e+00\\n\"\n                \"2  30.0  0.000000e+00\\n\"\n                \"3  40.0  0.000000e+00\"\n            )\n\n        with option_context(\"display.chop_threshold\", 5e-11):\n            assert repr(df) == (\n                \"      0             1\\n\"\n                \"0  10.0  8.000000e-10\\n\"\n                \"1  20.0  0.000000e+00\\n\"\n                \"2  30.0  2.000000e-09\\n\"\n                \"3  40.0  0.000000e+00\"\n            )\n\n    def test_repr_no_backslash(self):\n        with option_context(\"mode.sim_interactive\", True):\n            df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))\n            assert \"\\\\\" not in repr(df)\n\n    def test_expand_frame_repr(self):\n        df_small = DataFrame(\"hello\", index=[0], columns=[0])\n        df_wide = DataFrame(\"hello\", index=[0], columns=range(10))\n        df_tall = DataFrame(\"hello\", index=range(30), columns=range(5))\n\n        with option_context(\"mode.sim_interactive\", True):\n            with option_context(\n                \"display.max_columns\",\n                10,\n                \"display.width\",\n                20,\n                \"display.max_rows\",\n                20,\n                \"display.show_dimensions\",\n                True,\n            ):\n                with option_context(\"display.expand_frame_repr\", True):\n                    assert not has_truncated_repr(df_small)\n                    assert not has_expanded_repr(df_small)\n                    assert not has_truncated_repr(df_wide)\n                    assert has_expanded_repr(df_wide)\n                    assert has_vertically_truncated_repr(df_tall)\n                    assert has_expanded_repr(df_tall)\n\n                with option_context(\"display.expand_frame_repr\", False):\n                    assert not has_truncated_repr(df_small)\n                    assert not has_expanded_repr(df_small)\n                    assert not has_horizontally_truncated_repr(df_wide)\n                    assert not has_expanded_repr(df_wide)\n                    assert has_vertically_truncated_repr(df_tall)\n                    assert not has_expanded_repr(df_tall)\n\n    def test_repr_non_interactive(self):\n        # in non interactive mode, there can be no dependency on the\n        # result of terminal auto size detection\n        df = DataFrame(\"hello\", index=range(1000), columns=range(5))\n\n        with option_context(\n            \"mode.sim_interactive\", False, \"display.width\", 0, \"display.max_rows\", 5000\n        ):\n            assert not has_truncated_repr(df)\n            assert not has_expanded_repr(df)\n\n    def test_repr_truncates_terminal_size(self, monkeypatch):\n        # see gh-21180\n\n        terminal_size = (118, 96)\n        monkeypatch.setattr(\n            \"pandas.io.formats.format.get_terminal_size\", lambda: terminal_size\n        )\n\n        index = range(5)\n        columns = MultiIndex.from_tuples(\n            [\n                (\"This is a long title with > 37 chars.\", \"cat\"),\n                (\"This is a loooooonger title with > 43 chars.\", \"dog\"),\n            ]\n        )\n        df = DataFrame(1, index=index, columns=columns)\n\n        result = repr(df)\n\n        h1, h2 = result.split(\"\\n\")[:2]\n        assert \"long\" in h1\n        assert \"loooooonger\" in h1\n        assert \"cat\" in h2\n        assert \"dog\" in h2\n\n        # regular columns\n        df2 = DataFrame({\"A\" * 41: [1, 2], \"B\" * 41: [1, 2]})\n        result = repr(df2)\n\n        assert df2.columns[0] in result.split(\"\\n\")[0]\n\n    def test_repr_truncates_terminal_size_full(self, monkeypatch):\n        # GH 22984 ensure entire window is filled\n        terminal_size = (80, 24)\n        df = DataFrame(np.random.default_rng(2).random((1, 7)))\n\n        monkeypatch.setattr(\n            \"pandas.io.formats.format.get_terminal_size\", lambda: terminal_size\n        )\n        assert \"...\" not in str(df)\n\n    def test_repr_truncation_column_size(self):\n        # dataframe with last column very wide -> check it is not used to\n        # determine size of truncation (...) column\n        df = DataFrame(\n            {\n                \"a\": [108480, 30830],\n                \"b\": [12345, 12345],\n                \"c\": [12345, 12345],\n                \"d\": [12345, 12345],\n                \"e\": [\"a\" * 50] * 2,\n            }\n        )\n        assert \"...\" in str(df)\n        assert \"    ...    \" not in str(df)\n\n    def test_repr_max_columns_max_rows(self):\n        term_width, term_height = get_terminal_size()\n        if term_width < 10 or term_height < 10:\n            pytest.skip(f\"terminal size too small, {term_width} x {term_height}\")\n\n        def mkframe(n):\n            index = [f\"{i:05d}\" for i in range(n)]\n            return DataFrame(0, index, index)\n\n        df6 = mkframe(6)\n        df10 = mkframe(10)\n        with option_context(\"mode.sim_interactive\", True):\n            with option_context(\"display.width\", term_width * 2):\n                with option_context(\"display.max_rows\", 5, \"display.max_columns\", 5):\n                    assert not has_expanded_repr(mkframe(4))\n                    assert not has_expanded_repr(mkframe(5))\n                    assert not has_expanded_repr(df6)\n                    assert has_doubly_truncated_repr(df6)\n\n                with option_context(\"display.max_rows\", 20, \"display.max_columns\", 10):\n                    # Out off max_columns boundary, but no extending\n                    # since not exceeding width\n                    assert not has_expanded_repr(df6)\n                    assert not has_truncated_repr(df6)\n\n                with option_context(\"display.max_rows\", 9, \"display.max_columns\", 10):\n                    # out vertical bounds can not result in expanded repr\n                    assert not has_expanded_repr(df10)\n                    assert has_vertically_truncated_repr(df10)\n\n            # width=None in terminal, auto detection\n            with option_context(\n                \"display.max_columns\",\n                100,\n                \"display.max_rows\",\n                term_width * 20,\n                \"display.width\",\n                None,\n            ):\n                df = mkframe((term_width // 7) - 2)\n                assert not has_expanded_repr(df)\n                df = mkframe((term_width // 7) + 2)\n                printing.pprint_thing(df._repr_fits_horizontal_())\n                assert has_expanded_repr(df)\n\n    def test_repr_min_rows(self):\n        df = DataFrame({\"a\": range(20)})\n\n        # default setting no truncation even if above min_rows\n        assert \"..\" not in repr(df)\n        assert \"..\" not in df._repr_html_()\n\n        df = DataFrame({\"a\": range(61)})\n\n        # default of max_rows 60 triggers truncation if above\n        assert \"..\" in repr(df)\n        assert \"..\" in df._repr_html_()\n\n        with option_context(\"display.max_rows\", 10, \"display.min_rows\", 4):\n            # truncated after first two rows\n            assert \"..\" in repr(df)\n            assert \"2  \" not in repr(df)\n            assert \"...\" in df._repr_html_()\n            assert \"<td>2</td>\" not in df._repr_html_()\n\n        with option_context(\"display.max_rows\", 12, \"display.min_rows\", None):\n            # when set to None, follow value of max_rows\n            assert \"5    5\" in repr(df)\n            assert \"<td>5</td>\" in df._repr_html_()\n\n        with option_context(\"display.max_rows\", 10, \"display.min_rows\", 12):\n            # when set value higher as max_rows, use the minimum\n            assert \"5    5\" not in repr(df)\n            assert \"<td>5</td>\" not in df._repr_html_()\n\n        with option_context(\"display.max_rows\", None, \"display.min_rows\", 12):\n            # max_rows of None -> never truncate\n            assert \"..\" not in repr(df)\n            assert \"..\" not in df._repr_html_()\n\n    @pytest.mark.parametrize(\n        \"data, format_option, expected_values\",\n        [\n            (12345.6789, \"{:12.3f}\", \"12345.679\"),\n            (None, \"{:.3f}\", \"None\"),\n            (\"\", \"{:.2f}\", \"\"),\n            (112345.6789, \"{:6.3f}\", \"112345.679\"),\n            (\"foo      foo\", None, \"foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo\"),\n            (\" foo\", None, \"foo\"),\n            (\n                \"foo foo       foo\",\n                None,\n                \"foo foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo\",\n            ),  # odd no.of spaces\n            (\n                \"foo foo    foo\",\n                None,\n                \"foo foo&nbsp;&nbsp;&nbsp;&nbsp;foo\",\n            ),  # even no.of spaces\n        ],\n    )\n    def test_repr_float_formatting_html_output(\n        self, data, format_option, expected_values\n    ):\n        if format_option is not None:\n            with option_context(\"display.float_format\", format_option.format):\n                df = DataFrame({\"A\": [data]})\n                html_output = df._repr_html_()\n                assert expected_values in html_output\n        else:\n            df = DataFrame({\"A\": [data]})\n            html_output = df._repr_html_()\n            assert expected_values in html_output\n\n    def test_str_max_colwidth(self):\n        # GH 7856\n        df = DataFrame(\n            [\n                {\n                    \"a\": \"foo\",\n                    \"b\": \"bar\",\n                    \"c\": \"uncomfortably long line with lots of stuff\",\n                    \"d\": 1,\n                },\n                {\"a\": \"foo\", \"b\": \"bar\", \"c\": \"stuff\", \"d\": 1},\n            ]\n        )\n        df.set_index([\"a\", \"b\", \"c\"])\n        assert str(df) == (\n            \"     a    b                                           c  d\\n\"\n            \"0  foo  bar  uncomfortably long line with lots of stuff  1\\n\"\n            \"1  foo  bar                                       stuff  1\"\n        )\n        with option_context(\"max_colwidth\", 20):\n            assert str(df) == (\n                \"     a    b                    c  d\\n\"\n                \"0  foo  bar  uncomfortably lo...  1\\n\"\n                \"1  foo  bar                stuff  1\"\n            )\n\n    def test_auto_detect(self):\n        term_width, term_height = get_terminal_size()\n        fac = 1.05  # Arbitrary large factor to exceed term width\n        cols = range(int(term_width * fac))\n        index = range(10)\n        df = DataFrame(index=index, columns=cols)\n        with option_context(\"mode.sim_interactive\", True):\n            with option_context(\"display.max_rows\", None):\n                with option_context(\"display.max_columns\", None):\n                    # Wrap around with None\n                    assert has_expanded_repr(df)\n            with option_context(\"display.max_rows\", 0):\n                with option_context(\"display.max_columns\", 0):\n                    # Truncate with auto detection.\n                    assert has_horizontally_truncated_repr(df)\n\n            index = range(int(term_height * fac))\n            df = DataFrame(index=index, columns=cols)\n            with option_context(\"display.max_rows\", 0):\n                with option_context(\"display.max_columns\", None):\n                    # Wrap around with None\n                    assert has_expanded_repr(df)\n                    # Truncate vertically\n                    assert has_vertically_truncated_repr(df)\n\n            with option_context(\"display.max_rows\", None):\n                with option_context(\"display.max_columns\", 0):\n                    assert has_horizontally_truncated_repr(df)\n\n    def test_to_string_repr_unicode2(self):\n        idx = Index([\"abc\", \"\\u03c3a\", \"aegdvg\"])\n        ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)\n        rs = repr(ser).split(\"\\n\")\n        line_len = len(rs[0])\n        for line in rs[1:]:\n            try:\n                line = line.decode(get_option(\"display.encoding\"))\n            except AttributeError:\n                pass\n            if not line.startswith(\"dtype:\"):\n                assert len(line) == line_len\n\n    def test_east_asian_unicode_false(self):\n        # not aligned properly because of east asian width\n\n        # mid col\n        df = DataFrame(\n            {\"a\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"], \"b\": [1, 222, 33333, 4]},\n            index=[\"a\", \"bb\", \"c\", \"ddd\"],\n        )\n        expected = (\n            \"          a      b\\na         あ      1\\n\"\n            \"bb      いいい    222\\nc         う  33333\\n\"\n            \"ddd  ええええええ      4\"\n        )\n        assert repr(df) == expected\n\n        # last col\n        df = DataFrame(\n            {\"a\": [1, 222, 33333, 4], \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"]},\n            index=[\"a\", \"bb\", \"c\", \"ddd\"],\n        )\n        expected = (\n            \"         a       b\\na        1       あ\\n\"\n            \"bb     222     いいい\\nc    33333       う\\n\"\n            \"ddd      4  ええええええ\"\n        )\n        assert repr(df) == expected\n\n        # all col\n        df = DataFrame(\n            {\n                \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n            },\n            index=[\"a\", \"bb\", \"c\", \"ddd\"],\n        )\n        expected = (\n            \"         a       b\\na    あああああ       あ\\n\"\n            \"bb       い     いいい\\nc        う       う\\n\"\n            \"ddd    えええ  ええええええ\"\n        )\n        assert repr(df) == expected\n\n        # column name\n        df = DataFrame(\n            {\n                \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                \"あああああ\": [1, 222, 33333, 4],\n            },\n            index=[\"a\", \"bb\", \"c\", \"ddd\"],\n        )\n        expected = (\n            \"          b  あああああ\\na         あ      1\\n\"\n            \"bb      いいい    222\\nc         う  33333\\n\"\n            \"ddd  ええええええ      4\"\n        )\n        assert repr(df) == expected\n\n        # index\n        df = DataFrame(\n            {\n                \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n            },\n            index=[\"あああ\", \"いいいいいい\", \"うう\", \"え\"],\n        )\n        expected = (\n            \"            a       b\\nあああ     あああああ       あ\\n\"\n            \"いいいいいい      い     いいい\\nうう          う       う\\n\"\n            \"え         えええ  ええええええ\"\n        )\n        assert repr(df) == expected\n\n        # index name\n        df = DataFrame(\n            {\n                \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n            },\n            index=Index([\"あ\", \"い\", \"うう\", \"え\"], name=\"おおおお\"),\n        )\n        expected = (\n            \"          a       b\\n\"\n            \"おおおお               \\n\"\n            \"あ     あああああ       あ\\n\"\n            \"い         い     いいい\\n\"\n            \"うう        う       う\\n\"\n            \"え       えええ  ええええええ\"\n        )\n        assert repr(df) == expected\n\n        # all\n        df = DataFrame(\n            {\n                \"あああ\": [\"あああ\", \"い\", \"う\", \"えええええ\"],\n                \"いいいいい\": [\"あ\", \"いいい\", \"う\", \"ええ\"],\n            },\n            index=Index([\"あ\", \"いいい\", \"うう\", \"え\"], name=\"お\"),\n        )\n        expected = (\n            \"       あああ いいいいい\\n\"\n            \"お               \\n\"\n            \"あ      あああ     あ\\n\"\n            \"いいい      い   いいい\\n\"\n            \"うう       う     う\\n\"\n            \"え    えええええ    ええ\"\n        )\n        assert repr(df) == expected\n\n        # MultiIndex\n        idx = MultiIndex.from_tuples(\n            [(\"あ\", \"いい\"), (\"う\", \"え\"), (\"おおお\", \"かかかか\"), (\"き\", \"くく\")]\n        )\n        df = DataFrame(\n            {\n                \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n            },\n            index=idx,\n        )\n        expected = (\n            \"              a       b\\n\"\n            \"あ   いい    あああああ       あ\\n\"\n            \"う   え         い     いいい\\n\"\n            \"おおお かかかか      う       う\\n\"\n            \"き   くく      えええ  ええええええ\"\n        )\n        assert repr(df) == expected\n\n        # truncate\n        with option_context(\"display.max_rows\", 3, \"display.max_columns\", 3):\n            df = DataFrame(\n                {\n                    \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                    \"c\": [\"お\", \"か\", \"ききき\", \"くくくくくく\"],\n                    \"ああああ\": [\"さ\", \"し\", \"す\", \"せ\"],\n                },\n                columns=[\"a\", \"b\", \"c\", \"ああああ\"],\n            )\n\n            expected = (\n                \"        a  ... ああああ\\n0   あああああ  ...    さ\\n\"\n                \"..    ...  ...  ...\\n3     えええ  ...    せ\\n\"\n                \"\\n[4 rows x 4 columns]\"\n            )\n            assert repr(df) == expected\n\n            df.index = [\"あああ\", \"いいいい\", \"う\", \"aaa\"]\n            expected = (\n                \"         a  ... ああああ\\nあああ  あああああ  ...    さ\\n\"\n                \"..     ...  ...  ...\\naaa    えええ  ...    せ\\n\"\n                \"\\n[4 rows x 4 columns]\"\n            )\n            assert repr(df) == expected\n\n    def test_east_asian_unicode_true(self):\n        # Enable Unicode option -----------------------------------------\n        with option_context(\"display.unicode.east_asian_width\", True):\n            # mid col\n            df = DataFrame(\n                {\"a\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"], \"b\": [1, 222, 33333, 4]},\n                index=[\"a\", \"bb\", \"c\", \"ddd\"],\n            )\n            expected = (\n                \"                a      b\\na              あ      1\\n\"\n                \"bb         いいい    222\\nc              う  33333\\n\"\n                \"ddd  ええええええ      4\"\n            )\n            assert repr(df) == expected\n\n            # last col\n            df = DataFrame(\n                {\"a\": [1, 222, 33333, 4], \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"]},\n                index=[\"a\", \"bb\", \"c\", \"ddd\"],\n            )\n            expected = (\n                \"         a             b\\na        1            あ\\n\"\n                \"bb     222        いいい\\nc    33333            う\\n\"\n                \"ddd      4  ええええええ\"\n            )\n            assert repr(df) == expected\n\n            # all col\n            df = DataFrame(\n                {\n                    \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                },\n                index=[\"a\", \"bb\", \"c\", \"ddd\"],\n            )\n            expected = (\n                \"              a             b\\n\"\n                \"a    あああああ            あ\\n\"\n                \"bb           い        いいい\\n\"\n                \"c            う            う\\n\"\n                \"ddd      えええ  ええええええ\"\n            )\n            assert repr(df) == expected\n\n            # column name\n            df = DataFrame(\n                {\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                    \"あああああ\": [1, 222, 33333, 4],\n                },\n                index=[\"a\", \"bb\", \"c\", \"ddd\"],\n            )\n            expected = (\n                \"                b  あああああ\\n\"\n                \"a              あ           1\\n\"\n                \"bb         いいい         222\\n\"\n                \"c              う       33333\\n\"\n                \"ddd  ええええええ           4\"\n            )\n            assert repr(df) == expected\n\n            # index\n            df = DataFrame(\n                {\n                    \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                },\n                index=[\"あああ\", \"いいいいいい\", \"うう\", \"え\"],\n            )\n            expected = (\n                \"                       a             b\\n\"\n                \"あああ        あああああ            あ\\n\"\n                \"いいいいいい          い        いいい\\n\"\n                \"うう                  う            う\\n\"\n                \"え                えええ  ええええええ\"\n            )\n            assert repr(df) == expected\n\n            # index name\n            df = DataFrame(\n                {\n                    \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                },\n                index=Index([\"あ\", \"い\", \"うう\", \"え\"], name=\"おおおお\"),\n            )\n            expected = (\n                \"                   a             b\\n\"\n                \"おおおお                          \\n\"\n                \"あ        あああああ            あ\\n\"\n                \"い                い        いいい\\n\"\n                \"うう              う            う\\n\"\n                \"え            えええ  ええええええ\"\n            )\n            assert repr(df) == expected\n\n            # all\n            df = DataFrame(\n                {\n                    \"あああ\": [\"あああ\", \"い\", \"う\", \"えええええ\"],\n                    \"いいいいい\": [\"あ\", \"いいい\", \"う\", \"ええ\"],\n                },\n                index=Index([\"あ\", \"いいい\", \"うう\", \"え\"], name=\"お\"),\n            )\n            expected = (\n                \"            あああ いいいいい\\n\"\n                \"お                           \\n\"\n                \"あ          あああ         あ\\n\"\n                \"いいい          い     いいい\\n\"\n                \"うう            う         う\\n\"\n                \"え      えええええ       ええ\"\n            )\n            assert repr(df) == expected\n\n            # MultiIndex\n            idx = MultiIndex.from_tuples(\n                [(\"あ\", \"いい\"), (\"う\", \"え\"), (\"おおお\", \"かかかか\"), (\"き\", \"くく\")]\n            )\n            df = DataFrame(\n                {\n                    \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                    \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                },\n                index=idx,\n            )\n            expected = (\n                \"                          a             b\\n\"\n                \"あ     いい      あああああ            あ\\n\"\n                \"う     え                い        いいい\\n\"\n                \"おおお かかかか          う            う\\n\"\n                \"き     くく          えええ  ええええええ\"\n            )\n            assert repr(df) == expected\n\n            # truncate\n            with option_context(\"display.max_rows\", 3, \"display.max_columns\", 3):\n                df = DataFrame(\n                    {\n                        \"a\": [\"あああああ\", \"い\", \"う\", \"えええ\"],\n                        \"b\": [\"あ\", \"いいい\", \"う\", \"ええええええ\"],\n                        \"c\": [\"お\", \"か\", \"ききき\", \"くくくくくく\"],\n                        \"ああああ\": [\"さ\", \"し\", \"す\", \"せ\"],\n                    },\n                    columns=[\"a\", \"b\", \"c\", \"ああああ\"],\n                )\n\n                expected = (\n                    \"             a  ... ああああ\\n\"\n                    \"0   あああああ  ...       さ\\n\"\n                    \"..         ...  ...      ...\\n\"\n                    \"3       えええ  ...       せ\\n\"\n                    \"\\n[4 rows x 4 columns]\"\n                )\n                assert repr(df) == expected\n\n                df.index = [\"あああ\", \"いいいい\", \"う\", \"aaa\"]\n                expected = (\n                    \"                 a  ... ああああ\\n\"\n                    \"あああ  あああああ  ...       さ\\n\"\n                    \"...            ...  ...      ...\\n\"\n                    \"aaa         えええ  ...       せ\\n\"\n                    \"\\n[4 rows x 4 columns]\"\n                )\n                assert repr(df) == expected\n\n            # ambiguous unicode\n            df = DataFrame(\n                {\n                    \"b\": [\"あ\", \"いいい\", \"¡¡\", \"ええええええ\"],\n                    \"あああああ\": [1, 222, 33333, 4],\n                },\n                index=[\"a\", \"bb\", \"c\", \"¡¡¡\"],\n            )\n            expected = (\n                \"                b  あああああ\\n\"\n                \"a              あ           1\\n\"\n                \"bb         いいい         222\\n\"\n                \"c              ¡¡       33333\\n\"\n                \"¡¡¡  ええええええ           4\"\n            )\n            assert repr(df) == expected\n\n    def test_to_string_buffer_all_unicode(self):\n        buf = StringIO()\n\n        empty = DataFrame({\"c/\\u03c3\": Series(dtype=object)})\n        nonempty = DataFrame({\"c/\\u03c3\": Series([1, 2, 3])})\n\n        print(empty, file=buf)\n        print(nonempty, file=buf)\n\n        # this should work\n        buf.getvalue()\n\n    @pytest.mark.parametrize(\n        \"index_scalar\",\n        [\n            \"a\" * 10,\n            1,\n            Timestamp(2020, 1, 1),\n            pd.Period(\"2020-01-01\"),\n        ],\n    )\n    @pytest.mark.parametrize(\"h\", [10, 20])\n    @pytest.mark.parametrize(\"w\", [10, 20])\n    def test_to_string_truncate_indices(self, index_scalar, h, w):\n        with option_context(\"display.expand_frame_repr\", False):\n            df = DataFrame(\n                index=[index_scalar] * h, columns=[str(i) * 10 for i in range(w)]\n            )\n            with option_context(\"display.max_rows\", 15):\n                if h == 20:\n                    assert has_vertically_truncated_repr(df)\n                else:\n                    assert not has_vertically_truncated_repr(df)\n            with option_context(\"display.max_columns\", 15):\n                if w == 20:\n                    assert has_horizontally_truncated_repr(df)\n                else:\n                    assert not has_horizontally_truncated_repr(df)\n            with option_context(\"display.max_rows\", 15, \"display.max_columns\", 15):\n                if h == 20 and w == 20:\n                    assert has_doubly_truncated_repr(df)\n                else:\n                    assert not has_doubly_truncated_repr(df)\n\n    def test_to_string_truncate_multilevel(self):\n        arrays = [\n            [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n            [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n        ]\n        df = DataFrame(index=arrays, columns=arrays)\n        with option_context(\"display.max_rows\", 7, \"display.max_columns\", 7):\n            assert has_doubly_truncated_repr(df)\n\n    @pytest.mark.parametrize(\"dtype\", [\"object\", \"datetime64[us]\"])\n    def test_truncate_with_different_dtypes(self, dtype):\n        # 11594, 12045\n        # when truncated the dtypes of the splits can differ\n\n        # 11594\n        ser = Series(\n            [datetime(2012, 1, 1)] * 10\n            + [datetime(1012, 1, 2)]\n            + [datetime(2012, 1, 3)] * 10,\n            dtype=dtype,\n        )\n\n        with option_context(\"display.max_rows\", 8):\n            result = str(ser)\n        assert dtype in result\n\n    def test_truncate_with_different_dtypes2(self):\n        # 12045\n        df = DataFrame({\"text\": [\"some words\"] + [None] * 9}, dtype=object)\n\n        with option_context(\"display.max_rows\", 8, \"display.max_columns\", 3):\n            result = str(df)\n            assert \"None\" in result\n            assert \"NaN\" not in result\n\n    def test_truncate_with_different_dtypes_multiindex(self):\n        # GH#13000\n        df = DataFrame({\"Vals\": range(100)})\n        frame = pd.concat([df], keys=[\"Sweep\"], names=[\"Sweep\", \"Index\"])\n        result = repr(frame)\n\n        result2 = repr(frame.iloc[:5])\n        assert result.startswith(result2)\n\n    def test_datetimelike_frame(self):\n        # GH 12211\n        df = DataFrame({\"date\": [Timestamp(\"20130101\").tz_localize(\"UTC\")] + [NaT] * 5})\n\n        with option_context(\"display.max_rows\", 5):\n            result = str(df)\n            assert \"2013-01-01 00:00:00+00:00\" in result\n            assert \"NaT\" in result\n            assert \"...\" in result\n            assert \"[6 rows x 1 columns]\" in result\n\n        dts = [Timestamp(\"2011-01-01\", tz=\"US/Eastern\")] * 5 + [NaT] * 5\n        df = DataFrame({\"dt\": dts, \"x\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]})\n        with option_context(\"display.max_rows\", 5):\n            expected = (\n                \"                          dt   x\\n\"\n                \"0  2011-01-01 00:00:00-05:00   1\\n\"\n                \"1  2011-01-01 00:00:00-05:00   2\\n\"\n                \"..                       ...  ..\\n\"\n                \"8                        NaT   9\\n\"\n                \"9                        NaT  10\\n\\n\"\n                \"[10 rows x 2 columns]\"\n            )\n            assert repr(df) == expected\n\n        dts = [NaT] * 5 + [Timestamp(\"2011-01-01\", tz=\"US/Eastern\")] * 5\n        df = DataFrame({\"dt\": dts, \"x\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]})\n        with option_context(\"display.max_rows\", 5):\n            expected = (\n                \"                          dt   x\\n\"\n                \"0                        NaT   1\\n\"\n                \"1                        NaT   2\\n\"\n                \"..                       ...  ..\\n\"\n                \"8  2011-01-01 00:00:00-05:00   9\\n\"\n                \"9  2011-01-01 00:00:00-05:00  10\\n\\n\"\n                \"[10 rows x 2 columns]\"\n            )\n            assert repr(df) == expected\n\n        dts = [Timestamp(\"2011-01-01\", tz=\"Asia/Tokyo\")] * 5 + [\n            Timestamp(\"2011-01-01\", tz=\"US/Eastern\")\n        ] * 5\n        df = DataFrame({\"dt\": dts, \"x\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]})\n        with option_context(\"display.max_rows\", 5):\n            expected = (\n                \"                           dt   x\\n\"\n                \"0   2011-01-01 00:00:00+09:00   1\\n\"\n                \"1   2011-01-01 00:00:00+09:00   2\\n\"\n                \"..                        ...  ..\\n\"\n                \"8   2011-01-01 00:00:00-05:00   9\\n\"\n                \"9   2011-01-01 00:00:00-05:00  10\\n\\n\"\n                \"[10 rows x 2 columns]\"\n            )\n            assert repr(df) == expected\n\n    @pytest.mark.parametrize(\n        \"start_date\",\n        [\n            \"2017-01-01 23:59:59.999999999\",\n            \"2017-01-01 23:59:59.99999999\",\n            \"2017-01-01 23:59:59.9999999\",\n            \"2017-01-01 23:59:59.999999\",\n            \"2017-01-01 23:59:59.99999\",\n            \"2017-01-01 23:59:59.9999\",\n        ],\n    )\n    def test_datetimeindex_highprecision(self, start_date):\n        # GH19030\n        # Check that high-precision time values for the end of day are\n        # included in repr for DatetimeIndex\n        df = DataFrame({\"A\": date_range(start=start_date, freq=\"D\", periods=5)})\n        result = str(df)\n        assert start_date in result\n\n        dti = date_range(start=start_date, freq=\"D\", periods=5)\n        df = DataFrame({\"A\": range(5)}, index=dti)\n        result = str(df.index)\n        assert start_date in result\n\n    def test_string_repr_encoding(self, datapath):\n        filepath = datapath(\"io\", \"parser\", \"data\", \"unicode_series.csv\")\n        df = read_csv(filepath, header=None, encoding=\"latin1\")\n        repr(df)\n        repr(df[1])\n\n    def test_repr_corner(self):\n        # representing infs poses no problems\n        df = DataFrame({\"foo\": [-np.inf, np.inf]})\n        repr(df)\n\n    def test_frame_info_encoding(self):\n        index = [\"'Til There Was You (1997)\", \"ldum klaka (Cold Fever) (1994)\"]\n        with option_context(\"display.max_rows\", 1):\n            df = DataFrame(columns=[\"a\", \"b\", \"c\"], index=index)\n            repr(df)\n            repr(df.T)\n\n    def test_wide_repr(self):\n        with option_context(\n            \"mode.sim_interactive\",\n            True,\n            \"display.show_dimensions\",\n            True,\n            \"display.max_columns\",\n            20,\n        ):\n            max_cols = get_option(\"display.max_columns\")\n            df = DataFrame([[\"a\" * 25] * (max_cols - 1)] * 10)\n            with option_context(\"display.expand_frame_repr\", False):\n                rep_str = repr(df)\n\n            assert f\"10 rows x {max_cols - 1} columns\" in rep_str\n            with option_context(\"display.expand_frame_repr\", True):\n                wide_repr = repr(df)\n            assert rep_str != wide_repr\n\n            with option_context(\"display.width\", 120):\n                wider_repr = repr(df)\n                assert len(wider_repr) < len(wide_repr)\n\n    def test_wide_repr_wide_columns(self):\n        with option_context(\"mode.sim_interactive\", True, \"display.max_columns\", 20):\n            df = DataFrame(\n                np.random.default_rng(2).standard_normal((5, 3)),\n                columns=[\"a\" * 90, \"b\" * 90, \"c\" * 90],\n            )\n            rep_str = repr(df)\n\n            assert len(rep_str.splitlines()) == 20\n\n    def test_wide_repr_named(self):\n        with option_context(\"mode.sim_interactive\", True, \"display.max_columns\", 20):\n            max_cols = get_option(\"display.max_columns\")\n            df = DataFrame([[\"a\" * 25] * (max_cols - 1)] * 10)\n            df.index.name = \"DataFrame Index\"\n            with option_context(\"display.expand_frame_repr\", False):\n                rep_str = repr(df)\n            with option_context(\"display.expand_frame_repr\", True):\n                wide_repr = repr(df)\n            assert rep_str != wide_repr\n\n            with option_context(\"display.width\", 150):\n                wider_repr = repr(df)\n                assert len(wider_repr) < len(wide_repr)\n\n            for line in wide_repr.splitlines()[1::13]:\n                assert \"DataFrame Index\" in line\n\n    def test_wide_repr_multiindex(self):\n        with option_context(\"mode.sim_interactive\", True, \"display.max_columns\", 20):\n            midx = MultiIndex.from_arrays([[\"a\" * 5] * 10] * 2)\n            max_cols = get_option(\"display.max_columns\")\n            df = DataFrame([[\"a\" * 25] * (max_cols - 1)] * 10, index=midx)\n            df.index.names = [\"Level 0\", \"Level 1\"]\n            with option_context(\"display.expand_frame_repr\", False):\n                rep_str = repr(df)\n            with option_context(\"display.expand_frame_repr\", True):\n                wide_repr = repr(df)\n            assert rep_str != wide_repr\n\n            with option_context(\"display.width\", 150):\n                wider_repr = repr(df)\n                assert len(wider_repr) < len(wide_repr)\n\n            for line in wide_repr.splitlines()[1::13]:\n                assert \"Level 0 Level 1\" in line\n\n    def test_wide_repr_multiindex_cols(self):\n        with option_context(\"mode.sim_interactive\", True, \"display.max_columns\", 20):\n            max_cols = get_option(\"display.max_columns\")\n            midx = MultiIndex.from_arrays([[\"a\" * 5] * 10] * 2)\n            mcols = MultiIndex.from_arrays([[\"b\" * 3] * (max_cols - 1)] * 2)\n            df = DataFrame(\n                [[\"c\" * 25] * (max_cols - 1)] * 10, index=midx, columns=mcols\n            )\n            df.index.names = [\"Level 0\", \"Level 1\"]\n            with option_context(\"display.expand_frame_repr\", False):\n                rep_str = repr(df)\n            with option_context(\"display.expand_frame_repr\", True):\n                wide_repr = repr(df)\n            assert rep_str != wide_repr\n\n        with option_context(\"display.width\", 150, \"display.max_columns\", 20):\n            wider_repr = repr(df)\n            assert len(wider_repr) < len(wide_repr)\n\n    def test_wide_repr_unicode(self):\n        with option_context(\"mode.sim_interactive\", True, \"display.max_columns\", 20):\n            max_cols = 20\n            df = DataFrame([[\"a\" * 25] * 10] * (max_cols - 1))\n            with option_context(\"display.expand_frame_repr\", False):\n                rep_str = repr(df)\n            with option_context(\"display.expand_frame_repr\", True):\n                wide_repr = repr(df)\n            assert rep_str != wide_repr\n\n            with option_context(\"display.width\", 150):\n                wider_repr = repr(df)\n                assert len(wider_repr) < len(wide_repr)\n\n    def test_wide_repr_wide_long_columns(self):\n        with option_context(\"mode.sim_interactive\", True):\n            df = DataFrame({\"a\": [\"a\" * 30, \"b\" * 30], \"b\": [\"c\" * 70, \"d\" * 80]})\n\n            result = repr(df)\n            assert \"ccccc\" in result\n            assert \"ddddd\" in result\n\n    def test_long_series(self):\n        n = 1000\n        s = Series(\n            np.random.default_rng(2).integers(-50, 50, n),\n            index=[f\"s{x:04d}\" for x in range(n)],\n            dtype=\"int64\",\n        )\n\n        str_rep = str(s)\n        nmatches = len(re.findall(\"dtype\", str_rep))\n        assert nmatches == 1\n\n    def test_to_string_ascii_error(self):\n        data = [\n            (\n                \"0  \",\n                \"                        .gitignore \",\n                \"     5 \",\n                \" \\xe2\\x80\\xa2\\xe2\\x80\\xa2\\xe2\\x80\\xa2\\xe2\\x80\\xa2\\xe2\\x80\\xa2\",\n            )\n        ]\n        df = DataFrame(data)\n\n        # it works!\n        repr(df)\n\n    def test_show_dimensions(self):\n        df = DataFrame(123, index=range(10, 15), columns=range(30))\n\n        with option_context(\n            \"display.max_rows\",\n            10,\n            \"display.max_columns\",\n            40,\n            \"display.width\",\n            500,\n            \"display.expand_frame_repr\",\n            \"info\",\n            \"display.show_dimensions\",\n            True,\n        ):\n            assert \"5 rows\" in str(df)\n            assert \"5 rows\" in df._repr_html_()\n        with option_context(\n            \"display.max_rows\",\n            10,\n            \"display.max_columns\",\n            40,\n            \"display.width\",\n            500,\n            \"display.expand_frame_repr\",\n            \"info\",\n            \"display.show_dimensions\",\n            False,\n        ):\n            assert \"5 rows\" not in str(df)\n            assert \"5 rows\" not in df._repr_html_()\n        with option_context(\n            \"display.max_rows\",\n            2,\n            \"display.max_columns\",\n            2,\n            \"display.width\",\n            500,\n            \"display.expand_frame_repr\",\n            \"info\",\n            \"display.show_dimensions\",\n            \"truncate\",\n        ):\n            assert \"5 rows\" in str(df)\n            assert \"5 rows\" in df._repr_html_()\n        with option_context(\n            \"display.max_rows\",\n            10,\n            \"display.max_columns\",\n            40,\n            \"display.width\",\n            500,\n            \"display.expand_frame_repr\",\n            \"info\",\n            \"display.show_dimensions\",\n            \"truncate\",\n        ):\n            assert \"5 rows\" not in str(df)\n            assert \"5 rows\" not in df._repr_html_()\n\n    def test_info_repr(self):\n        # GH#21746 For tests inside a terminal (i.e. not CI) we need to detect\n        # the terminal size to ensure that we try to print something \"too big\"\n        term_width, term_height = get_terminal_size()\n\n        max_rows = 60\n        max_cols = 20 + (max(term_width, 80) - 80) // 4\n        # Long\n        h, w = max_rows + 1, max_cols - 1\n        df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})\n        assert has_vertically_truncated_repr(df)\n        with option_context(\"display.large_repr\", \"info\"):\n            assert has_info_repr(df)\n\n        # Wide\n        h, w = max_rows - 1, max_cols + 1\n        df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})\n        assert has_horizontally_truncated_repr(df)\n        with option_context(\n            \"display.large_repr\", \"info\", \"display.max_columns\", max_cols\n        ):\n            assert has_info_repr(df)\n\n    def test_info_repr_max_cols(self):\n        # GH #6939\n        df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)))\n        with option_context(\n            \"display.large_repr\",\n            \"info\",\n            \"display.max_columns\",\n            1,\n            \"display.max_info_columns\",\n            4,\n        ):\n            assert has_non_verbose_info_repr(df)\n\n        with option_context(\n            \"display.large_repr\",\n            \"info\",\n            \"display.max_columns\",\n            1,\n            \"display.max_info_columns\",\n            5,\n        ):\n            assert not has_non_verbose_info_repr(df)\n\n        # FIXME: don't leave commented-out\n        # test verbose overrides\n        # set_option('display.max_info_columns', 4)  # exceeded\n\n    def test_pprint_pathological_object(self):\n        \"\"\"\n        If the test fails, it at least won't hang.\n        \"\"\"\n\n        class A:\n            def __getitem__(self, key):\n                return 3  # obviously simplified\n\n        df = DataFrame([A()])\n        repr(df)  # just don't die\n\n    def test_float_trim_zeros(self):\n        vals = [\n            2.08430917305e10,\n            3.52205017305e10,\n            2.30674817305e10,\n            2.03954217305e10,\n            5.59897817305e10,\n        ]\n        skip = True\n        for line in repr(DataFrame({\"A\": vals})).split(\"\\n\")[:-2]:\n            if line.startswith(\"dtype:\"):\n                continue\n            if _three_digit_exp():\n                assert (\"+010\" in line) or skip\n            else:\n                assert (\"+10\" in line) or skip\n            skip = False\n\n    @pytest.mark.parametrize(\n        \"data, expected\",\n        [\n            ([\"3.50\"], \"0    3.50\\ndtype: object\"),\n            ([1.20, \"1.00\"], \"0     1.2\\n1    1.00\\ndtype: object\"),\n            ([np.nan], \"0   NaN\\ndtype: float64\"),\n            ([None], \"0    None\\ndtype: object\"),\n            ([\"3.50\", np.nan], \"0    3.50\\n1     NaN\\ndtype: object\"),\n            ([3.50, np.nan], \"0    3.5\\n1    NaN\\ndtype: float64\"),\n            ([3.50, np.nan, \"3.50\"], \"0     3.5\\n1     NaN\\n2    3.50\\ndtype: object\"),\n            ([3.50, None, \"3.50\"], \"0     3.5\\n1    None\\n2    3.50\\ndtype: object\"),\n        ],\n    )\n    def test_repr_str_float_truncation(self, data, expected, using_infer_string):\n        # GH#38708\n        series = Series(data, dtype=object if \"3.50\" in data else None)\n        result = repr(series)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"float_format,expected\",\n        [\n            (\"{:,.0f}\".format, \"0   1,000\\n1    test\\ndtype: object\"),\n            (\"{:.4f}\".format, \"0   1000.0000\\n1        test\\ndtype: object\"),\n        ],\n    )\n    def test_repr_float_format_in_object_col(self, float_format, expected):\n        # GH#40024\n        df = Series([1000.0, \"test\"])\n        with option_context(\"display.float_format\", float_format):\n            result = repr(df)\n\n        assert result == expected\n\n    def test_period(self):\n        # GH 12615\n        df = DataFrame(\n            {\n                \"A\": pd.period_range(\"2013-01\", periods=4, freq=\"M\"),\n                \"B\": [\n                    pd.Period(\"2011-01\", freq=\"M\"),\n                    pd.Period(\"2011-02-01\", freq=\"D\"),\n                    pd.Period(\"2011-03-01 09:00\", freq=\"h\"),\n                    pd.Period(\"2011-04\", freq=\"M\"),\n                ],\n                \"C\": list(\"abcd\"),\n            }\n        )\n        exp = (\n            \"         A                 B  C\\n\"\n            \"0  2013-01           2011-01  a\\n\"\n            \"1  2013-02        2011-02-01  b\\n\"\n            \"2  2013-03  2011-03-01 09:00  c\\n\"\n            \"3  2013-04           2011-04  d\"\n        )\n        assert str(df) == exp\n\n    @pytest.mark.parametrize(\n        \"length, max_rows, min_rows, expected\",\n        [\n            (10, 10, 10, 10),\n            (10, 10, None, 10),\n            (10, 8, None, 8),\n            (20, 30, 10, 30),  # max_rows > len(frame), hence max_rows\n            (50, 30, 10, 10),  # max_rows < len(frame), hence min_rows\n            (100, 60, 10, 10),  # same\n            (60, 60, 10, 60),  # edge case\n            (61, 60, 10, 10),  # edge case\n        ],\n    )\n    def test_max_rows_fitted(self, length, min_rows, max_rows, expected):\n        \"\"\"Check that display logic is correct.\n\n        GH #37359\n\n        See description here:\n        https://pandas.pydata.org/docs/dev/user_guide/options.html#frequently-used-options\n        \"\"\"\n        formatter = fmt.DataFrameFormatter(\n            DataFrame(np.random.default_rng(2).random((length, 3))),\n            max_rows=max_rows,\n            min_rows=min_rows,\n        )\n        result = formatter.max_rows_fitted\n        assert result == expected\n\n\ndef gen_series_formatting():\n    s1 = Series([\"a\"] * 100)\n    s2 = Series([\"ab\"] * 100)\n    s3 = Series([\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\"])\n    s4 = s3[::-1]\n    test_sers = {\"onel\": s1, \"twol\": s2, \"asc\": s3, \"desc\": s4}\n    return test_sers\n\n\nclass TestSeriesFormatting:\n    def test_freq_name_separation(self):\n        s = Series(\n            np.random.default_rng(2).standard_normal(10),\n            index=date_range(\"1/1/2000\", periods=10),\n            name=0,\n        )\n\n        result = repr(s)\n        assert \"Freq: D, Name: 0\" in result\n\n    def test_unicode_name_in_footer(self):\n        s = Series([1, 2], name=\"\\u05e2\\u05d1\\u05e8\\u05d9\\u05ea\")\n        sf = fmt.SeriesFormatter(s, name=\"\\u05e2\\u05d1\\u05e8\\u05d9\\u05ea\")\n        sf._get_footer()  # should not raise exception\n\n    @pytest.mark.xfail(using_string_dtype(), reason=\"Fixup when arrow is default\")\n    def test_east_asian_unicode_series(self):\n        # not aligned properly because of east asian width\n\n        # unicode index\n        s = Series([\"a\", \"bb\", \"CCC\", \"D\"], index=[\"あ\", \"いい\", \"ううう\", \"ええええ\"])\n        expected = \"\".join(\n            [\n                \"あ         a\\n\",\n                \"いい       bb\\n\",\n                \"ううう     CCC\\n\",\n                \"ええええ      D\\ndtype: object\",\n            ]\n        )\n        assert repr(s) == expected\n\n        # unicode values\n        s = Series([\"あ\", \"いい\", \"ううう\", \"ええええ\"], index=[\"a\", \"bb\", \"c\", \"ddd\"])\n        expected = \"\".join(\n            [\n                \"a         あ\\n\",\n                \"bb       いい\\n\",\n                \"c       ううう\\n\",\n                \"ddd    ええええ\\n\",\n                \"dtype: object\",\n            ]\n        )\n\n        assert repr(s) == expected\n\n        # both\n        s = Series(\n            [\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n            index=[\"ああ\", \"いいいい\", \"う\", \"えええ\"],\n        )\n        expected = \"\".join(\n            [\n                \"ああ         あ\\n\",\n                \"いいいい      いい\\n\",\n                \"う        ううう\\n\",\n                \"えええ     ええええ\\n\",\n                \"dtype: object\",\n            ]\n        )\n\n        assert repr(s) == expected\n\n        # unicode footer\n        s = Series(\n            [\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n            index=[\"ああ\", \"いいいい\", \"う\", \"えええ\"],\n            name=\"おおおおおおお\",\n        )\n        expected = (\n            \"ああ         あ\\nいいいい      いい\\nう        ううう\\n\"\n            \"えええ     ええええ\\nName: おおおおおおお, dtype: object\"\n        )\n        assert repr(s) == expected\n\n        # MultiIndex\n        idx = MultiIndex.from_tuples(\n            [(\"あ\", \"いい\"), (\"う\", \"え\"), (\"おおお\", \"かかかか\"), (\"き\", \"くく\")]\n        )\n        s = Series([1, 22, 3333, 44444], index=idx)\n        expected = (\n            \"あ    いい          1\\n\"\n            \"う    え          22\\n\"\n            \"おおお  かかかか     3333\\n\"\n            \"き    くく      44444\\ndtype: int64\"\n        )\n        assert repr(s) == expected\n\n        # object dtype, shorter than unicode repr\n        s = Series([1, 22, 3333, 44444], index=[1, \"AB\", np.nan, \"あああ\"])\n        expected = (\n            \"1          1\\nAB        22\\nNaN     3333\\nあああ    44444\\ndtype: int64\"\n        )\n        assert repr(s) == expected\n\n        # object dtype, longer than unicode repr\n        s = Series(\n            [1, 22, 3333, 44444], index=[1, \"AB\", Timestamp(\"2011-01-01\"), \"あああ\"]\n        )\n        expected = (\n            \"1                          1\\n\"\n            \"AB                        22\\n\"\n            \"2011-01-01 00:00:00     3333\\n\"\n            \"あああ                    44444\\ndtype: int64\"\n        )\n        assert repr(s) == expected\n\n        # truncate\n        with option_context(\"display.max_rows\", 3):\n            s = Series([\"あ\", \"いい\", \"ううう\", \"ええええ\"], name=\"おおおおおおお\")\n\n            expected = (\n                \"0       あ\\n     ... \\n\"\n                \"3    ええええ\\n\"\n                \"Name: おおおおおおお, Length: 4, dtype: object\"\n            )\n            assert repr(s) == expected\n\n            s.index = [\"ああ\", \"いいいい\", \"う\", \"えええ\"]\n            expected = (\n                \"ああ        あ\\n       ... \\n\"\n                \"えええ    ええええ\\n\"\n                \"Name: おおおおおおお, Length: 4, dtype: object\"\n            )\n            assert repr(s) == expected\n\n        # Enable Unicode option -----------------------------------------\n        with option_context(\"display.unicode.east_asian_width\", True):\n            # unicode index\n            s = Series(\n                [\"a\", \"bb\", \"CCC\", \"D\"],\n                index=[\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n            )\n            expected = (\n                \"あ            a\\nいい         bb\\nううう      CCC\\n\"\n                \"ええええ      D\\ndtype: object\"\n            )\n            assert repr(s) == expected\n\n            # unicode values\n            s = Series(\n                [\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n                index=[\"a\", \"bb\", \"c\", \"ddd\"],\n            )\n            expected = (\n                \"a            あ\\nbb         いい\\nc        ううう\\n\"\n                \"ddd    ええええ\\ndtype: object\"\n            )\n            assert repr(s) == expected\n            # both\n            s = Series(\n                [\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n                index=[\"ああ\", \"いいいい\", \"う\", \"えええ\"],\n            )\n            expected = (\n                \"ああ              あ\\n\"\n                \"いいいい        いい\\n\"\n                \"う            ううう\\n\"\n                \"えええ      ええええ\\ndtype: object\"\n            )\n            assert repr(s) == expected\n\n            # unicode footer\n            s = Series(\n                [\"あ\", \"いい\", \"ううう\", \"ええええ\"],\n                index=[\"ああ\", \"いいいい\", \"う\", \"えええ\"],\n                name=\"おおおおおおお\",\n            )\n            expected = (\n                \"ああ              あ\\n\"\n                \"いいいい        いい\\n\"\n                \"う            ううう\\n\"\n                \"えええ      ええええ\\n\"\n                \"Name: おおおおおおお, dtype: object\"\n            )\n            assert repr(s) == expected\n\n            # MultiIndex\n            idx = MultiIndex.from_tuples(\n                [(\"あ\", \"いい\"), (\"う\", \"え\"), (\"おおお\", \"かかかか\"), (\"き\", \"くく\")]\n            )\n            s = Series([1, 22, 3333, 44444], index=idx)\n            expected = (\n                \"あ      いい            1\\n\"\n                \"う      え             22\\n\"\n                \"おおお  かかかか     3333\\n\"\n                \"き      くく        44444\\n\"\n                \"dtype: int64\"\n            )\n            assert repr(s) == expected\n\n            # object dtype, shorter than unicode repr\n            s = Series([1, 22, 3333, 44444], index=[1, \"AB\", np.nan, \"あああ\"])\n            expected = (\n                \"1             1\\nAB           22\\nNaN        3333\\n\"\n                \"あああ    44444\\ndtype: int64\"\n            )\n            assert repr(s) == expected\n\n            # object dtype, longer than unicode repr\n            s = Series(\n                [1, 22, 3333, 44444],\n                index=[1, \"AB\", Timestamp(\"2011-01-01\"), \"あああ\"],\n            )\n            expected = (\n                \"1                          1\\n\"\n                \"AB                        22\\n\"\n                \"2011-01-01 00:00:00     3333\\n\"\n                \"あああ                 44444\\ndtype: int64\"\n            )\n            assert repr(s) == expected\n\n            # truncate\n            with option_context(\"display.max_rows\", 3):\n                s = Series([\"あ\", \"いい\", \"ううう\", \"ええええ\"], name=\"おおおおおおお\")\n                expected = (\n                    \"0          あ\\n       ...   \\n\"\n                    \"3    ええええ\\n\"\n                    \"Name: おおおおおおお, Length: 4, dtype: object\"\n                )\n                assert repr(s) == expected\n\n                s.index = [\"ああ\", \"いいいい\", \"う\", \"えええ\"]\n                expected = (\n                    \"ああ            あ\\n\"\n                    \"            ...   \\n\"\n                    \"えええ    ええええ\\n\"\n                    \"Name: おおおおおおお, Length: 4, dtype: object\"\n                )\n                assert repr(s) == expected\n\n            # ambiguous unicode\n            s = Series(\n                [\"¡¡\", \"い¡¡\", \"ううう\", \"ええええ\"],\n                index=[\"ああ\", \"¡¡¡¡いい\", \"¡¡\", \"えええ\"],\n            )\n            expected = (\n                \"ああ              ¡¡\\n\"\n                \"¡¡¡¡いい        い¡¡\\n\"\n                \"¡¡            ううう\\n\"\n                \"えええ      ええええ\\ndtype: object\"\n            )\n            assert repr(s) == expected\n\n    def test_float_trim_zeros(self):\n        vals = [\n            2.08430917305e10,\n            3.52205017305e10,\n            2.30674817305e10,\n            2.03954217305e10,\n            5.59897817305e10,\n        ]\n        for line in repr(Series(vals)).split(\"\\n\"):\n            if line.startswith(\"dtype:\"):\n                continue\n            if _three_digit_exp():\n                assert \"+010\" in line\n            else:\n                assert \"+10\" in line\n\n    @pytest.mark.parametrize(\n        \"start_date\",\n        [\n            \"2017-01-01 23:59:59.999999999\",\n            \"2017-01-01 23:59:59.99999999\",\n            \"2017-01-01 23:59:59.9999999\",\n            \"2017-01-01 23:59:59.999999\",\n            \"2017-01-01 23:59:59.99999\",\n            \"2017-01-01 23:59:59.9999\",\n        ],\n    )\n    def test_datetimeindex_highprecision(self, start_date):\n        # GH19030\n        # Check that high-precision time values for the end of day are\n        # included in repr for DatetimeIndex\n        s1 = Series(date_range(start=start_date, freq=\"D\", periods=5))\n        result = str(s1)\n        assert start_date in result\n\n        dti = date_range(start=start_date, freq=\"D\", periods=5)\n        s2 = Series(3, index=dti)\n        result = str(s2.index)\n        assert start_date in result\n\n    def test_mixed_datetime64(self):\n        df = DataFrame({\"A\": [1, 2], \"B\": [\"2012-01-01\", \"2012-01-02\"]})\n        df[\"B\"] = pd.to_datetime(df.B)\n\n        result = repr(df.loc[0])\n        assert \"2012-01-01\" in result\n\n    def test_period(self):\n        # GH 12615\n        index = pd.period_range(\"2013-01\", periods=6, freq=\"M\")\n        s = Series(np.arange(6, dtype=\"int64\"), index=index)\n        exp = (\n            \"2013-01    0\\n\"\n            \"2013-02    1\\n\"\n            \"2013-03    2\\n\"\n            \"2013-04    3\\n\"\n            \"2013-05    4\\n\"\n            \"2013-06    5\\n\"\n            \"Freq: M, dtype: int64\"\n        )\n        assert str(s) == exp\n\n        s = Series(index)\n        exp = (\n            \"0    2013-01\\n\"\n            \"1    2013-02\\n\"\n            \"2    2013-03\\n\"\n            \"3    2013-04\\n\"\n            \"4    2013-05\\n\"\n            \"5    2013-06\\n\"\n            \"dtype: period[M]\"\n        )\n        assert str(s) == exp\n\n        # periods with mixed freq\n        s = Series(\n            [\n                pd.Period(\"2011-01\", freq=\"M\"),\n                pd.Period(\"2011-02-01\", freq=\"D\"),\n                pd.Period(\"2011-03-01 09:00\", freq=\"h\"),\n            ]\n        )\n        exp = (\n            \"0             2011-01\\n1          2011-02-01\\n\"\n            \"2    2011-03-01 09:00\\ndtype: object\"\n        )\n        assert str(s) == exp\n\n    def test_max_multi_index_display(self):\n        # GH 7101\n\n        # doc example (indexing.rst)\n\n        # multi-index\n        arrays = [\n            [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n            [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n        ]\n        tuples = list(zip(*arrays))\n        index = MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"])\n        s = Series(np.random.default_rng(2).standard_normal(8), index=index)\n\n        with option_context(\"display.max_rows\", 10):\n            assert len(str(s).split(\"\\n\")) == 10\n        with option_context(\"display.max_rows\", 3):\n            assert len(str(s).split(\"\\n\")) == 5\n        with option_context(\"display.max_rows\", 2):\n            assert len(str(s).split(\"\\n\")) == 5\n        with option_context(\"display.max_rows\", 1):\n            assert len(str(s).split(\"\\n\")) == 4\n        with option_context(\"display.max_rows\", 0):\n            assert len(str(s).split(\"\\n\")) == 10\n\n        # index\n        s = Series(np.random.default_rng(2).standard_normal(8), None)\n\n        with option_context(\"display.max_rows\", 10):\n            assert len(str(s).split(\"\\n\")) == 9\n        with option_context(\"display.max_rows\", 3):\n            assert len(str(s).split(\"\\n\")) == 4\n        with option_context(\"display.max_rows\", 2):\n            assert len(str(s).split(\"\\n\")) == 4\n        with option_context(\"display.max_rows\", 1):\n            assert len(str(s).split(\"\\n\")) == 3\n        with option_context(\"display.max_rows\", 0):\n            assert len(str(s).split(\"\\n\")) == 9\n\n    # Make sure #8532 is fixed\n    def test_consistent_format(self):\n        s = Series([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9999, 1, 1] * 10)\n        with option_context(\"display.max_rows\", 10, \"display.show_dimensions\", False):\n            res = repr(s)\n        exp = (\n            \"0      1.0000\\n1      1.0000\\n2      1.0000\\n3      \"\n            \"1.0000\\n4      1.0000\\n        ...  \\n125    \"\n            \"1.0000\\n126    1.0000\\n127    0.9999\\n128    \"\n            \"1.0000\\n129    1.0000\\ndtype: float64\"\n        )\n        assert res == exp\n\n    def chck_ncols(self, s):\n        lines = [\n            line for line in repr(s).split(\"\\n\") if not re.match(r\"[^\\.]*\\.+\", line)\n        ][:-1]\n        ncolsizes = len({len(line.strip()) for line in lines})\n        assert ncolsizes == 1\n\n    @pytest.mark.xfail(using_string_dtype(), reason=\"change when arrow is default\")\n    def test_format_explicit(self):\n        test_sers = gen_series_formatting()\n        with option_context(\"display.max_rows\", 4, \"display.show_dimensions\", False):\n            res = repr(test_sers[\"onel\"])\n            exp = \"0     a\\n1     a\\n     ..\\n98    a\\n99    a\\ndtype: object\"\n            assert exp == res\n            res = repr(test_sers[\"twol\"])\n            exp = \"0     ab\\n1     ab\\n      ..\\n98    ab\\n99    ab\\ndtype: object\"\n            assert exp == res\n            res = repr(test_sers[\"asc\"])\n            exp = (\n                \"0         a\\n1        ab\\n      ...  \\n4     abcde\\n5    \"\n                \"abcdef\\ndtype: object\"\n            )\n            assert exp == res\n            res = repr(test_sers[\"desc\"])\n            exp = (\n                \"5    abcdef\\n4     abcde\\n      ...  \\n1        ab\\n0         \"\n                \"a\\ndtype: object\"\n            )\n            assert exp == res\n\n    def test_ncols(self):\n        test_sers = gen_series_formatting()\n        for s in test_sers.values():\n            self.chck_ncols(s)\n\n    def test_max_rows_eq_one(self):\n        s = Series(range(10), dtype=\"int64\")\n        with option_context(\"display.max_rows\", 1):\n            strrepr = repr(s).split(\"\\n\")\n        exp1 = [\"0\", \"0\"]\n        res1 = strrepr[0].split()\n        assert exp1 == res1\n        exp2 = [\"..\"]\n        res2 = strrepr[1].split()\n        assert exp2 == res2\n\n    def test_truncate_ndots(self):\n        def getndots(s):\n            return len(re.match(r\"[^\\.]*(\\.*)\", s).groups()[0])\n\n        s = Series([0, 2, 3, 6])\n        with option_context(\"display.max_rows\", 2):\n            strrepr = repr(s).replace(\"\\n\", \"\")\n        assert getndots(strrepr) == 2\n\n        s = Series([0, 100, 200, 400])\n        with option_context(\"display.max_rows\", 2):\n            strrepr = repr(s).replace(\"\\n\", \"\")\n        assert getndots(strrepr) == 3\n\n    def test_show_dimensions(self):\n        # gh-7117\n        s = Series(range(5))\n\n        assert \"Length\" not in repr(s)\n\n        with option_context(\"display.max_rows\", 4):\n            assert \"Length\" in repr(s)\n\n        with option_context(\"display.show_dimensions\", True):\n            assert \"Length\" in repr(s)\n\n        with option_context(\"display.max_rows\", 4, \"display.show_dimensions\", False):\n            assert \"Length\" not in repr(s)\n\n    def test_repr_min_rows(self):\n        s = Series(range(20))\n\n        # default setting no truncation even if above min_rows\n        assert \"..\" not in repr(s)\n\n        s = Series(range(61))\n\n        # default of max_rows 60 triggers truncation if above\n        assert \"..\" in repr(s)\n\n        with option_context(\"display.max_rows\", 10, \"display.min_rows\", 4):\n            # truncated after first two rows\n            assert \"..\" in repr(s)\n            assert \"2  \" not in repr(s)\n\n        with option_context(\"display.max_rows\", 12, \"display.min_rows\", None):\n            # when set to None, follow value of max_rows\n            assert \"5      5\" in repr(s)\n\n        with option_context(\"display.max_rows\", 10, \"display.min_rows\", 12):\n            # when set value higher as max_rows, use the minimum\n            assert \"5      5\" not in repr(s)\n\n        with option_context(\"display.max_rows\", None, \"display.min_rows\", 12):\n            # max_rows of None -> never truncate\n            assert \"..\" not in repr(s)\n\n\nclass TestGenericArrayFormatter:\n    def test_1d_array(self):\n        # _GenericArrayFormatter is used on types for which there isn't a dedicated\n        # formatter. np.bool_ is one of those types.\n        obj = fmt._GenericArrayFormatter(np.array([True, False]))\n        res = obj.get_result()\n        assert len(res) == 2\n        # Results should be right-justified.\n        assert res[0] == \"  True\"\n        assert res[1] == \" False\"\n\n    def test_2d_array(self):\n        obj = fmt._GenericArrayFormatter(np.array([[True, False], [False, True]]))\n        res = obj.get_result()\n        assert len(res) == 2\n        assert res[0] == \" [True, False]\"\n        assert res[1] == \" [False, True]\"\n\n    def test_3d_array(self):\n        obj = fmt._GenericArrayFormatter(\n            np.array([[[True, True], [False, False]], [[False, True], [True, False]]])\n        )\n        res = obj.get_result()\n        assert len(res) == 2\n        assert res[0] == \" [[True, True], [False, False]]\"\n        assert res[1] == \" [[False, True], [True, False]]\"\n\n    def test_2d_extension_type(self):\n        # GH 33770\n\n        # Define a stub extension type with just enough code to run Series.__repr__()\n        class DtypeStub(pd.api.extensions.ExtensionDtype):\n            @property\n            def type(self):\n                return np.ndarray\n\n            @property\n            def name(self):\n                return \"DtypeStub\"\n\n        class ExtTypeStub(pd.api.extensions.ExtensionArray):\n            def __len__(self) -> int:\n                return 2\n\n            def __getitem__(self, ix):\n                return [ix == 1, ix == 0]\n\n            @property\n            def dtype(self):\n                return DtypeStub()\n\n        series = Series(ExtTypeStub(), copy=False)\n        res = repr(series)  # This line crashed before #33770 was fixed.\n        expected = \"\\n\".join(\n            [\"0    [False True]\", \"1    [True False]\", \"dtype: DtypeStub\"]\n        )\n        assert res == expected\n\n\ndef _three_digit_exp():\n    return f\"{1.7e8:.4g}\" == \"1.7e+008\"\n\n\nclass TestFloatArrayFormatter:\n    def test_misc(self):\n        obj = fmt.FloatArrayFormatter(np.array([], dtype=np.float64))\n        result = obj.get_result()\n        assert len(result) == 0\n\n    def test_format(self):\n        obj = fmt.FloatArrayFormatter(np.array([12, 0], dtype=np.float64))\n        result = obj.get_result()\n        assert result[0] == \" 12.0\"\n        assert result[1] == \"  0.0\"\n\n    def test_output_display_precision_trailing_zeroes(self):\n        # Issue #20359: trimming zeros while there is no decimal point\n\n        # Happens when display precision is set to zero\n        with option_context(\"display.precision\", 0):\n            s = Series([840.0, 4200.0])\n            expected_output = \"0     840\\n1    4200\\ndtype: float64\"\n            assert str(s) == expected_output\n\n    @pytest.mark.parametrize(\n        \"value,expected\",\n        [\n            ([9.4444], \"   0\\n0  9\"),\n            ([0.49], \"       0\\n0  5e-01\"),\n            ([10.9999], \"    0\\n0  11\"),\n            ([9.5444, 9.6], \"    0\\n0  10\\n1  10\"),\n            ([0.46, 0.78, -9.9999], \"       0\\n0  5e-01\\n1  8e-01\\n2 -1e+01\"),\n        ],\n    )\n    def test_set_option_precision(self, value, expected):\n        # Issue #30122\n        # Precision was incorrectly shown\n\n        with option_context(\"display.precision\", 0):\n            df_value = DataFrame(value)\n            assert str(df_value) == expected\n\n    def test_output_significant_digits(self):\n        # Issue #9764\n\n        # In case default display precision changes:\n        with option_context(\"display.precision\", 6):\n            # DataFrame example from issue #9764\n            d = DataFrame(\n                {\n                    \"col1\": [\n                        9.999e-8,\n                        1e-7,\n                        1.0001e-7,\n                        2e-7,\n                        4.999e-7,\n                        5e-7,\n                        5.0001e-7,\n                        6e-7,\n                        9.999e-7,\n                        1e-6,\n                        1.0001e-6,\n                        2e-6,\n                        4.999e-6,\n                        5e-6,\n                        5.0001e-6,\n                        6e-6,\n                    ]\n                }\n            )\n\n            expected_output = {\n                (0, 6): \"           col1\\n\"\n                \"0  9.999000e-08\\n\"\n                \"1  1.000000e-07\\n\"\n                \"2  1.000100e-07\\n\"\n                \"3  2.000000e-07\\n\"\n                \"4  4.999000e-07\\n\"\n                \"5  5.000000e-07\",\n                (1, 6): \"           col1\\n\"\n                \"1  1.000000e-07\\n\"\n                \"2  1.000100e-07\\n\"\n                \"3  2.000000e-07\\n\"\n                \"4  4.999000e-07\\n\"\n                \"5  5.000000e-07\",\n                (1, 8): \"           col1\\n\"\n                \"1  1.000000e-07\\n\"\n                \"2  1.000100e-07\\n\"\n                \"3  2.000000e-07\\n\"\n                \"4  4.999000e-07\\n\"\n                \"5  5.000000e-07\\n\"\n                \"6  5.000100e-07\\n\"\n                \"7  6.000000e-07\",\n                (8, 16): \"            col1\\n\"\n                \"8   9.999000e-07\\n\"\n                \"9   1.000000e-06\\n\"\n                \"10  1.000100e-06\\n\"\n                \"11  2.000000e-06\\n\"\n                \"12  4.999000e-06\\n\"\n                \"13  5.000000e-06\\n\"\n                \"14  5.000100e-06\\n\"\n                \"15  6.000000e-06\",\n                (9, 16): \"        col1\\n\"\n                \"9   0.000001\\n\"\n                \"10  0.000001\\n\"\n                \"11  0.000002\\n\"\n                \"12  0.000005\\n\"\n                \"13  0.000005\\n\"\n                \"14  0.000005\\n\"\n                \"15  0.000006\",\n            }\n\n            for (start, stop), v in expected_output.items():\n                assert str(d[start:stop]) == v\n\n    def test_too_long(self):\n        # GH 10451\n        with option_context(\"display.precision\", 4):\n            # need both a number > 1e6 and something that normally formats to\n            # having length > display.precision + 6\n            df = DataFrame({\"x\": [12345.6789]})\n            assert str(df) == \"            x\\n0  12345.6789\"\n            df = DataFrame({\"x\": [2e6]})\n            assert str(df) == \"           x\\n0  2000000.0\"\n            df = DataFrame({\"x\": [12345.6789, 2e6]})\n            assert str(df) == \"            x\\n0  1.2346e+04\\n1  2.0000e+06\"\n\n\nclass TestTimedelta64Formatter:\n    def test_days(self):\n        x = pd.to_timedelta(list(range(5)) + [NaT], unit=\"D\")._values\n        result = fmt._Timedelta64Formatter(x).get_result()\n        assert result[0].strip() == \"0 days\"\n        assert result[1].strip() == \"1 days\"\n\n        result = fmt._Timedelta64Formatter(x[1:2]).get_result()\n        assert result[0].strip() == \"1 days\"\n\n        result = fmt._Timedelta64Formatter(x).get_result()\n        assert result[0].strip() == \"0 days\"\n        assert result[1].strip() == \"1 days\"\n\n        result = fmt._Timedelta64Formatter(x[1:2]).get_result()\n        assert result[0].strip() == \"1 days\"\n\n    def test_days_neg(self):\n        x = pd.to_timedelta(list(range(5)) + [NaT], unit=\"D\")._values\n        result = fmt._Timedelta64Formatter(-x).get_result()\n        assert result[0].strip() == \"0 days\"\n        assert result[1].strip() == \"-1 days\"\n\n    def test_subdays(self):\n        y = pd.to_timedelta(list(range(5)) + [NaT], unit=\"s\")._values\n        result = fmt._Timedelta64Formatter(y).get_result()\n        assert result[0].strip() == \"0 days 00:00:00\"\n        assert result[1].strip() == \"0 days 00:00:01\"\n\n    def test_subdays_neg(self):\n        y = pd.to_timedelta(list(range(5)) + [NaT], unit=\"s\")._values\n        result = fmt._Timedelta64Formatter(-y).get_result()\n        assert result[0].strip() == \"0 days 00:00:00\"\n        assert result[1].strip() == \"-1 days +23:59:59\"\n\n    def test_zero(self):\n        x = pd.to_timedelta(list(range(1)) + [NaT], unit=\"D\")._values\n        result = fmt._Timedelta64Formatter(x).get_result()\n        assert result[0].strip() == \"0 days\"\n\n        x = pd.to_timedelta(list(range(1)), unit=\"D\")._values\n        result = fmt._Timedelta64Formatter(x).get_result()\n        assert result[0].strip() == \"0 days\"\n\n\nclass TestDatetime64Formatter:\n    def test_mixed(self):\n        x = Series([datetime(2013, 1, 1), datetime(2013, 1, 1, 12), NaT])._values\n        result = fmt._Datetime64Formatter(x).get_result()\n        assert result[0].strip() == \"2013-01-01 00:00:00\"\n        assert result[1].strip() == \"2013-01-01 12:00:00\"\n\n    def test_dates(self):\n        x = Series([datetime(2013, 1, 1), datetime(2013, 1, 2), NaT])._values\n        result = fmt._Datetime64Formatter(x).get_result()\n        assert result[0].strip() == \"2013-01-01\"\n        assert result[1].strip() == \"2013-01-02\"\n\n    def test_date_nanos(self):\n        x = Series([Timestamp(200)])._values\n        result = fmt._Datetime64Formatter(x).get_result()\n        assert result[0].strip() == \"1970-01-01 00:00:00.000000200\"\n\n    def test_dates_display(self):\n        # 10170\n        # make sure that we are consistently display date formatting\n        x = Series(date_range(\"20130101 09:00:00\", periods=5, freq=\"D\"))\n        x.iloc[1] = np.nan\n        result = fmt._Datetime64Formatter(x._values).get_result()\n        assert result[0].strip() == \"2013-01-01 09:00:00\"\n        assert result[1].strip() == \"NaT\"\n        assert result[4].strip() == \"2013-01-05 09:00:00\"\n\n        x = Series(date_range(\"20130101 09:00:00\", periods=5, freq=\"s\"))\n        x.iloc[1] = np.nan\n        result = fmt._Datetime64Formatter(x._values).get_result()\n        assert result[0].strip() == \"2013-01-01 09:00:00\"\n        assert result[1].strip() == \"NaT\"\n        assert result[4].strip() == \"2013-01-01 09:00:04\"\n\n        x = Series(date_range(\"20130101 09:00:00\", periods=5, freq=\"ms\"))\n        x.iloc[1] = np.nan\n        result = fmt._Datetime64Formatter(x._values).get_result()\n        assert result[0].strip() == \"2013-01-01 09:00:00.000\"\n        assert result[1].strip() == \"NaT\"\n        assert result[4].strip() == \"2013-01-01 09:00:00.004\"\n\n        x = Series(date_range(\"20130101 09:00:00\", periods=5, freq=\"us\"))\n        x.iloc[1] = np.nan\n        result = fmt._Datetime64Formatter(x._values).get_result()\n        assert result[0].strip() == \"2013-01-01 09:00:00.000000\"\n        assert result[1].strip() == \"NaT\"\n        assert result[4].strip() == \"2013-01-01 09:00:00.000004\"\n\n        x = Series(date_range(\"20130101 09:00:00\", periods=5, freq=\"ns\"))\n        x.iloc[1] = np.nan\n        result = fmt._Datetime64Formatter(x._values).get_result()\n        assert result[0].strip() == \"2013-01-01 09:00:00.000000000\"\n        assert result[1].strip() == \"NaT\"\n        assert result[4].strip() == \"2013-01-01 09:00:00.000000004\"\n\n    def test_datetime64formatter_yearmonth(self):\n        x = Series([datetime(2016, 1, 1), datetime(2016, 2, 2)])._values\n\n        def format_func(x):\n            return x.strftime(\"%Y-%m\")\n\n        formatter = fmt._Datetime64Formatter(x, formatter=format_func)\n        result = formatter.get_result()\n        assert result == [\"2016-01\", \"2016-02\"]\n\n    def test_datetime64formatter_hoursecond(self):\n        x = Series(\n            pd.to_datetime([\"10:10:10.100\", \"12:12:12.120\"], format=\"%H:%M:%S.%f\")\n        )._values\n\n        def format_func(x):\n            return x.strftime(\"%H:%M\")\n\n        formatter = fmt._Datetime64Formatter(x, formatter=format_func)\n        result = formatter.get_result()\n        assert result == [\"10:10\", \"12:12\"]\n\n    def test_datetime64formatter_tz_ms(self):\n        x = (\n            Series(\n                np.array([\"2999-01-01\", \"2999-01-02\", \"NaT\"], dtype=\"datetime64[ms]\")\n            )\n            .dt.tz_localize(\"US/Pacific\")\n            ._values\n        )\n        result = fmt._Datetime64TZFormatter(x).get_result()\n        assert result[0].strip() == \"2999-01-01 00:00:00-08:00\"\n        assert result[1].strip() == \"2999-01-02 00:00:00-08:00\"\n\n\nclass TestFormatPercentiles:\n    @pytest.mark.parametrize(\n        \"percentiles, expected\",\n        [\n            (\n                [0.01999, 0.02001, 0.5, 0.666666, 0.9999],\n                [\"1.999%\", \"2.001%\", \"50%\", \"66.667%\", \"99.99%\"],\n            ),\n            (\n                [0, 0.5, 0.02001, 0.5, 0.666666, 0.9999],\n                [\"0%\", \"50%\", \"2.0%\", \"50%\", \"66.67%\", \"99.99%\"],\n            ),\n            ([0.281, 0.29, 0.57, 0.58], [\"28.1%\", \"29%\", \"57%\", \"58%\"]),\n            ([0.28, 0.29, 0.57, 0.58], [\"28%\", \"29%\", \"57%\", \"58%\"]),\n            (\n                [0.9, 0.99, 0.999, 0.9999, 0.99999],\n                [\"90%\", \"99%\", \"99.9%\", \"99.99%\", \"99.999%\"],\n            ),\n        ],\n    )\n    def test_format_percentiles(self, percentiles, expected):\n        result = fmt.format_percentiles(percentiles)\n        assert result == expected\n\n    @pytest.mark.parametrize(\n        \"percentiles\",\n        [\n            ([0.1, np.nan, 0.5]),\n            ([-0.001, 0.1, 0.5]),\n            ([2, 0.1, 0.5]),\n            ([0.1, 0.5, \"a\"]),\n        ],\n    )\n    def test_error_format_percentiles(self, percentiles):\n        msg = r\"percentiles should all be in the interval \\[0,1\\]\"\n        with pytest.raises(ValueError, match=msg):\n            fmt.format_percentiles(percentiles)\n\n    def test_format_percentiles_integer_idx(self):\n        # Issue #26660\n        result = fmt.format_percentiles(np.linspace(0, 1, 10 + 1))\n        expected = [\n            \"0%\",\n            \"10%\",\n            \"20%\",\n            \"30%\",\n            \"40%\",\n            \"50%\",\n            \"60%\",\n            \"70%\",\n            \"80%\",\n            \"90%\",\n            \"100%\",\n        ]\n        assert result == expected\n\n\n@pytest.mark.parametrize(\"method\", [\"to_string\", \"to_html\", \"to_latex\"])\n@pytest.mark.parametrize(\n    \"encoding, data\",\n    [(None, \"abc\"), (\"utf-8\", \"abc\"), (\"gbk\", \"造成输出中文显示乱码\"), (\"foo\", \"abc\")],\n)\n@pytest.mark.parametrize(\"filepath_or_buffer_id\", [\"string\", \"pathlike\", \"buffer\"])\ndef test_filepath_or_buffer_arg(\n    method,\n    tmp_path,\n    encoding,\n    data,\n    filepath_or_buffer_id,\n):\n    if filepath_or_buffer_id == \"buffer\":\n        filepath_or_buffer = StringIO()\n    elif filepath_or_buffer_id == \"pathlike\":\n        filepath_or_buffer = tmp_path / \"foo\"\n    else:\n        filepath_or_buffer = str(tmp_path / \"foo\")\n\n    df = DataFrame([data])\n    if method in [\"to_latex\"]:  # uses styler implementation\n        pytest.importorskip(\"jinja2\")\n\n    if filepath_or_buffer_id not in [\"string\", \"pathlike\"] and encoding is not None:\n        with pytest.raises(\n            ValueError, match=\"buf is not a file name and encoding is specified.\"\n        ):\n            getattr(df, method)(buf=filepath_or_buffer, encoding=encoding)\n    elif encoding == \"foo\":\n        with pytest.raises(LookupError, match=\"unknown encoding\"):\n            getattr(df, method)(buf=filepath_or_buffer, encoding=encoding)\n    else:\n        expected = getattr(df, method)()\n        getattr(df, method)(buf=filepath_or_buffer, encoding=encoding)\n        encoding = encoding or \"utf-8\"\n        if filepath_or_buffer_id == \"string\":\n            with open(filepath_or_buffer, encoding=encoding) as f:\n                result = f.read()\n        elif filepath_or_buffer_id == \"pathlike\":\n            result = filepath_or_buffer.read_text(encoding=encoding)\n        elif filepath_or_buffer_id == \"buffer\":\n            result = filepath_or_buffer.getvalue()\n        assert result == expected\n    if filepath_or_buffer_id == \"buffer\":\n        assert not filepath_or_buffer.closed\n\n\n@pytest.mark.parametrize(\"method\", [\"to_string\", \"to_html\", \"to_latex\"])\ndef test_filepath_or_buffer_bad_arg_raises(float_frame, method):\n    if method in [\"to_latex\"]:  # uses styler implementation\n        pytest.importorskip(\"jinja2\")\n    msg = \"buf is not a file name and it has no write method\"\n    with pytest.raises(TypeError, match=msg):\n        getattr(float_frame, method)(buf=object())\n"
    }
  ],
  "questions": [
    "So, I think we should close this and pass it to jupyter developer? Please give me feedback on where is the best place to bring this (is it pandas or jupyter).",
    "Meanwhile I was able to implement the `float formatting` with unit tests passed, if you don't mind can I make the PR for review for completion of this part ?"
  ],
  "golden_answers": [
    "After some investigation, even string format didn't respected by display.\r\n\r\n```python\r\npd.options.display.float_format = '{:.3f}'.format.  # if float, use .3f\r\ndf_formatted = df.map(lambda x: str(f'{x:12.3f}')).astype('string').  # change to string to ignore float_format\r\ndisplay(df_formatted)\r\nprint(df_formatted)  # correctly using str(f'{x:12.3f}')\r\n```\r\n\r\nThe workaround is to directly change Styler:\r\n\r\n```python\r\nstyled_df = df_formatted.style.set_table_styles(\r\n    [{'selector': 'td', 'props': [('min-width', '80px')]}]\r\n)\r\n\r\ndisplay(styled_df)\r\n```",
    "The issue with the extra space is the use of strip here:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/f598670353311a6fff4e6e1e96074ccf0737e6b7/pandas/io/formats/html.py#L197\r\n\r\nBy replacing spaces with `&nbsp`, that strip no longer does anything. This goes back to https://github.com/pandas-dev/pandas/issues/4987.\r\n\r\nI think the solution is to leave `esc` alone and use `rs = rs.replace(\" \", \"&nbsp\")` after the call to `pprint_thing`."
  ],
  "questions_generated": [
    "How does the current implementation of `pd.options.display.float_format` handle formatting of numbers before the decimal point?",
    "What part of the pandas codebase is likely responsible for handling the `float_format` option in DataFrame display?",
    "Why might the `pd.options.display.float_format` not follow the left side or before decimal places format as expected?",
    "In which module of the pandas codebase would you expect changes to be made to address this floating-point formatting issue?",
    "What is the role of the `HTMLFormatter` class in the pandas codebase, and is it directly responsible for the float formatting issue?"
  ],
  "golden_answers_generated": [
    "The current implementation of `pd.options.display.float_format` in pandas allows users to define how floating point numbers are displayed in the output DataFrame, specifically targeting the number of decimal places. However, it does not inherently support formatting the digits before the decimal point to ensure a fixed width, which is the issue highlighted in this bug report.",
    "The `float_format` option is likely handled in the pandas codebase within the `DataFrameFormatter` class or related functions in `pandas/io/formats/format.py`. This module is responsible for formatting output data, including handling how numbers and other data types are represented when a DataFrame is displayed.",
    "The `pd.options.display.float_format` option is primarily designed to format the decimal part of floating-point numbers, controlling the number of decimal places. It does not inherently support specifying the width of the left side of numbers (digits before the decimal point), which requires zero-padding or similar handling that is not included in the current formatting logic.",
    "To address this issue, changes would likely need to be made in the `pandas/io/formats/format.py` module. This module contains the classes and functions responsible for formatting various data types when displaying DataFrames, including the `DataFrameFormatter` class, which handles the `float_format` option.",
    "The `HTMLFormatter` class in the pandas codebase is responsible for formatting DataFrame output in HTML, specifically for methods like `DataFrame.to_html()` and `DataFrame._repr_html_()`. While it handles the presentation of DataFrames in HTML format, it is not directly responsible for the float formatting issue; that responsibility lies with the more general formatting functions and classes in `pandas/io/formats/format.py`."
  ]
}